[
  {
    "language": "Scala",
    "code": "object Main {\n  val mod: Int = 1e9.toInt + 7\n  def pow(a: Int, b: Int): Int = {\n    var bit = 1\n    var pow = a.toLong\n    var ans = 1L\n    while (bit <= b) {\n      if ((b & bit) != 0) ans = ans * pow % mod\n      pow = pow * pow % mod\n      bit *= 2\n    }\n    ans.toInt\n  }\n  def inv(a: Int): Int = pow(a, mod - 2)\n\n  def main(args: Array[String]): Unit = {\n    val n = io.Source.stdin.bufferedReader().readLine().toInt\n    val fact = Range(1, n).iterator.scanLeft(1)((x, y) => (x.toLong * y % mod).toInt).toArray\n    val ifact = fact.map(inv)\n    val f = Range(0, n).iterator.map { k =>\n      if (2 * k - n < 0) 0\n      else (fact(k-1).toLong * fact(k) % mod * ifact(2*k - n) % mod).toInt\n    }.toArray\n    val answer = Range(1, n).iterator\n      .map(i => (f(i) - f(i - 1) + mod).toLong * i % mod)\n      .reduce((x, y) => (x + y) % mod)\n    println(answer)\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  val mod: Int = 1e9.toInt + 7\n  def pow(a: Int, b: Int): Int = {\n    var bit = 1\n    var pow = a.toLong\n    var ans = 1L\n    while (bit <= b) {\n      if ((b & bit) != 0) ans = ans * pow % mod\n      pow = pow * pow % mod\n      bit *= 2\n    }\n    ans.toInt\n  }\n  def inv(a: Int): Int = pow(a, mod - 2)\n\n  def main(args: Array[String]): Unit = {\n    val n = io.Source.stdin.bufferedReader().readLine().toInt\n    val fact = Range(1, n).scanLeft(1)((x, y) => (x.toLong * y % mod).toInt)\n    val ifact = fact.map(inv)\n    val f = Range(0, n).map { k =>\n      if (2 * k - n < 0) 0\n      else (fact(k-1).toLong * fact(k) % mod * ifact(2*k - n) % mod).toInt\n    }\n    val answer = Range(1, n)\n      .map(i => (f(i) - f(i - 1) + mod).toLong * i % mod)\n      .reduce((x, y) => (x + y) % mod)\n    println(answer)\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  val mod: Int = 1e9.toInt + 7\n  def pow(a: Int, b: Int): Int = b match {\n    case 0 => 1\n    case _ =>\n      val tmp = pow(a, b / 2).toLong\n      if (b % 2 == 0) (tmp * tmp % mod).toInt\n      else (tmp * tmp % mod * a % mod).toInt\n  }\n  def inv(a: Int): Int = pow(a, mod - 2)\n\n  def main(args: Array[String]): Unit = {\n    val n = io.Source.stdin.bufferedReader().readLine().toInt\n    val fact = Range(1, n).scanLeft(1)((x, y) => (x.toLong * y % mod).toInt)\n    val ifact = fact.map(inv)\n    val f = Range(0, n).map { k =>\n      if (2 * k - n < 0) 0\n      else (fact(k-1).toLong * fact(k) % mod * ifact(2*k - n) % mod).toInt\n    }\n    val answer = Range(1, n)\n      .map(i => (f(i) - f(i - 1) + mod).toLong * i % mod)\n      .reduce((x, y) => (x + y) % mod)\n    println(answer)\n  }\n}\n"
  },
  {
    "language": "Fortran",
    "code": "module mod_modulo_util\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer(8), allocatable :: f(:), invf(:)\ncontains\n  subroutine init(n)\n    implicit none\n    integer, intent(in) :: n\n    integer :: i\n    if (allocated(f)) deallocate(f)\n    if (allocated(invf)) deallocate(invf)\n    allocate(f(0:n),invf(0:n))\n    f = 0_8\n    invf = 0_8\n    f(0) = 1_8\n    do i = 1, n\n      f(i) = mod(f(i-1)*int(i,8),md)\n    end do\n    invf(n) = inv(f(n))\n    do i = n, 1, -1\n      invf(i-1) = mod(invf(i)*int(i,8),md)\n    end do\n    return\n  end subroutine init\n  integer(8) function perm(n,k)\n    implicit none\n    integer, intent(in) :: n, k\n    perm = 0_8\n    if (n < 0 .or. k > n) return\n    perm = mod(f(n)*invf(n-k),md)\n    return\n  end function perm\n  integer(8) function comb(n,k)\n    implicit none\n    integer, intent(in) :: n, k\n    comb = mod(perm(n,k)*invf(k),md)\n    return\n  end function comb\n  integer(8) function homo(n,k)\n    implicit none\n    integer, intent(in) :: n, k\n    homo = comb(n+k-1,k)\n    return\n  end function homo\n  function inv(n) result(y)\n    implicit none\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = mod(n,md)\n    b = md\n    x = 0_8\n    y = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    y = mod(y,md)\n    if (y < 0_8) y = y+md\n    return\n  end function inv\n  function pow(a,b) result(r)\n    implicit none\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: i\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    do i = 0, 32\n      if (btest(b,i)) r = mod(r*p,md)\n      p = mod(p*p,md)\n    end do\n    return\n  end function pow\n  integer(8) function fact(n)\n    implicit none\n    integer, intent(in) :: n\n    fact = 0_8\n    if (n < 0) return\n    fact = f(n)\n    return\n  end function fact\nend module mod_modulo_util\nprogram painting_machines\n  use mod_modulo_util\n  implicit none\n  integer :: n, k\n  integer(8) :: ans = 0_8\n  read(*,*) n\n  call init(n)\n  ans = mod(mod(f(n)*f(n),md)*invf(n),md)\n  do k = (n+1)/2, n-1\n    ans = mod(ans+md-mod(mod(f(k-1)*f(k),md)*invf(2*k-n),md),md)\n  end do\n  write(*,'(i0)') ans\n  stop\nend program painting_machines"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N = 1e6 + 10, mod = 1e9 + 7;\nint fact[N], invfact[N];\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (((ll) x) * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\nvoid pre(){\n\tfact[0] = invfact[0] = 1;\n\tfor(int i = 1;i < N; i++) fact[i] = mul(i, fact[i - 1]);\n\tinvfact[N - 1] = inv(fact[N - 1]);\n\tfor(int i = N - 2; i >= 1; i--) invfact[i] = mul(invfact[i + 1], i + 1);\n\tassert(invfact[1] == 1);\n}\ninline int C(int n, int k){\n\tif(n < k || k < 0) return 0;\n\treturn mul(fact[n], mul(invfact[k], invfact[n - k]));\n}\n\nint get(int n, int k){\n\tif(k == 1) return (n == 2 || n == 3);\n}\n\nint f(int n, int k){\n\tif(k == 0) return 0;\n\tif(k == 1) return n == 2;\n\tif(n == 2) return 1;\n\treturn mul(C(k - 1, n - 1 - k), mul(fact[k], fact[n - 1 - k]));\n}\n\nint main(){\n\tint n;\n\tpre();\n\tcin >> n;\n\tint ans = 0;\n\tfor(int k = 0; k <= n - 1; k++){\n\t\tans = add(ans, mul(k, sub(f(n, k), f(n, k - 1))));\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\n\nint N;\nint fact[2000001];\nint modpow(int x, int k) {\n  int a = 1;\n  while (k > 0) {\n    if (k & 1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nint inv(int x) {\n  return modpow(x, MOD-2);\n}\n\nint nCr(int n, int k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  return (1LL * fact[n] * inv((1LL*fact[k]*fact[n-k]) % MOD)) % MOD;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=2000000; i++) fact[i] = (1LL*i*fact[i-1])%MOD;\n\n  cin >> N;\n  int s = 0;\n  rep(num, N) {\n    int n=N-2, k = num-1;\n    int sum = 0;\n    if (k>=0&&n-k>=0) sum = nCr(k, n-k);\n    sum = (MOD-sum)%MOD;\n    add(sum, nCr(N-1, num));\n    sum = (1LL*sum*fact[num])%MOD;\n    sum = (1LL*sum*fact[N-1-num])%MOD;\n    add(s, sum);\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define mo(x) (x%mod+mod)%mod\n\nusing namespace std;\n\nconst int mod = 998244353;\nconst int maxn = 1000010;\ntypedef long long ll;\nint inv[maxn], jc[maxn], ijc[maxn];\nint n = 0;\n\nint C(int n, int m) {\n    if (n < m) return 0;\n    return 1ll*jc[n]*ijc[m]%mod*ijc[n-m]%mod;\n}\n\nint main() {\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    inv[1] = 1; jc[0] = ijc[0] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = mo(-1ll*inv[mod%i]*(mod/i)%mod);\n    for (int i = 1; i <= n; i++) {\n        jc[i] = 1ll*jc[i-1]*i%mod;\n        ijc[i] = 1ll*ijc[i-1]*inv[i]%mod;\n    }\n    int ans = 1ll*n*jc[n-1]%mod;\n    for (int i = 1; i <= n; i++) {\n        int t = 1ll*C(i-1, n-i-1)*jc[i]%mod*jc[n-1-i]%mod;\n        ans = mo(ans-t);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nll fact[200000];\nll ppow(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=(res*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nll C(ll n,ll k){\n\treturn fact[n]*ppow(fact[k],MOD-2)%MOD*ppow(fact[n-k],MOD-2)%MOD;\n}\n\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"1\");return 0;\n\t}\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++)fact[i]=(fact[i-1]*i)%MOD;\n\tll cnt=0,ans=0;\n\tfor(int k=2;k<=n-1;k++){\n\t\tif(k-1<n-k-1)continue;\n\t\tll a=C(k-1,n-k-1)*fact[k]%MOD*fact[n-k-1]%MOD;\n\t\t(ans+=k*(a+MOD-cnt)%MOD)%=MOD;\n\t\tcnt=a;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n\n\n#define INF 4000000000000000000LL\n#define MOD 1000000007\n#define ALL(x) std::begin(x), std::end(x)\n\n\nlong long modpow(long long x, long long y)\n{\n  long long p = 1;\n\n  for ( ; y; (x *= x) %= MOD, y >>= 1)\n    if (y & 1)\n      (p *= x) %= MOD;\n\n  return p;\n}\n\nclass modint_t {\n  friend std::ostream& operator<<(std::ostream& ofs, const modint_t a);\n\npublic:\n  modint_t(long long xx = 0) : x(xx % MOD) {};\n\npublic:\n  bool operator==(long long a) const {\n    return x == a;\n  };\n\npublic:\n  long long value() const {\n    return x;\n  };\n\npublic:\n  modint_t operator+(const modint_t& a) const {\n    return (x + a.x) % MOD;\n  };\n\n  modint_t operator-(const modint_t& a) const {\n    return (x - a.x) % MOD;\n  };\n\n  modint_t operator*(const modint_t& a) const {\n    return x * a.x % MOD;\n  };\n\n  modint_t operator/(const modint_t& a) const {\n    return (*this) * a.inverse();\n  };\n\n  // Note that operator^'s priority is quite low in C++...\n  modint_t operator^(long long i) const {\n    return modint_t(modpow(x, i));\n  };\n\npublic:\n  modint_t& operator+=(const modint_t& a) {\n    (x += a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator-=(const modint_t& a) {\n    (x -= a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator*=(const modint_t& a) {\n    (x *= a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator/=(const modint_t& a) {\t// Not tested\n    (x *= a.inverse().x) %= MOD;\n\n    return *this;\n  };\n\npublic:\n  modint_t inverse() const {\n    assert(x % MOD);\n\n    return modint_t(modpow(x, MOD - 2));\n  };\n\npublic:\n  modint_t normalized() const {\n    return modint_t(x % MOD + MOD);\n  };\n\nprivate:\n  long long x;\n};\n\nmodint_t operator-(long long a, const modint_t& b)\n{\n  return modint_t(a) - b;\n}\n\nmodint_t operator*(long long a, const modint_t& b)\n{\n  return modint_t(a) * b;\n}\n\nmodint_t operator/(long long a, const modint_t& b)\n{\n  return modint_t(a) / b;\n}\n\nstd::ostream& operator<<(std::ostream& ofs, const modint_t a)\n{\n  ofs << a.x;\n\n  return ofs;\n}\n\n\nint main(int argc, char** argv)\n{\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n\n  std::cout << std::fixed << std::setprecision(6);\n  std::cerr << std::fixed << std::setprecision(6);\n\n  modint_t memo[1111111], memo2[1111111];\n\n  memo[0] = memo[1] = 1;\n  \n  for (int i = 2; i < 1111111; i ++)\n    memo[i] = memo[i - 1] * i;\n\n  memo2[0] = memo2[1] = 1;\n\n  for (int i = 2; i < 1111111; i ++)\n    memo2[i] = memo2[i - 1] / modint_t(i);\n\n  int N;\n  \n  std::cin >> N;\n\n  if (N < 4) {\n    std::cout << 1 << std::endl;\n\n    return 0;\n  }\n  else if (N == 4) {\n    std::cout << 16 << std::endl;\n\n    return 0;\n  }\n\n  modint_t C = 0, c = 0;\n\n  for (int K = (N + 1) / 2; K < N; K ++) {\n    modint_t k = K - 1, l = (N - 2) - k, m = k - l;\n    \n    modint_t cc = memo[(l + m).value()] * memo2[l.value()] * memo2[m.value()] * memo[K] * memo[N - 1 - K];\n\n    C += (cc - c) * K;\n\n    c = cc;\n  }\n\n  std::cout << C << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nconst ll MOD = 1e9+7;\n\n\n//verified KUPC2014-D,ABC034-C\n//前処理O(n), クエリO(1)\nll power(ll a,ll b){\n    ll ret=1;\n    if(b>0){\n        ret = power(a,b/2);\n        if(b%2==0)ret = (ret*ret)%MOD;\n        else ret = (((ret*ret)%MOD)*a)%MOD;\n    }\n    return ret;\n}\n\nvector<ll> fact,invfact;\n\nvoid init(int n){\n    fact.resize(n+1,1);\n    invfact.resize(n+1,1);\n    for(int i=2;i<=n;i++)fact[i] = (fact[i-1]*i)%MOD;\n    \n    invfact[n] = power(fact[n],MOD-2);\n    for(int i=n-1;i>=1;i--) invfact[i] = (invfact[i+1]*(i+1))%MOD;\n}\n\n\nll C(int n,int r){\n    if(n<r)return 0;\n    return ( ( fact[n]*invfact[r] )%MOD * invfact[n-r] )%MOD;\n}\n\nint f(int n, int k){\n    int a = 2*k-n;\n    int b = n-k-1;\n    if(a<0 || b<0)return 0;\n    \n    return ((C(a+b,a) * fact[k])%MOD * fact[n-k-1])%MOD;\n}\n\nsigned main(){\n    int n;\n    cin>>n;\n    init(n+100);\n\n    int ans = 0;\n    for(int k=1; k<=n-1; k++){\n        (ans += k*(f(n,k)-f(n,k-1)))%=MOD;\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\n\n\nvector<P> v[10];\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nint l[33];\n\nint o[3000544];\nint j[41][6];\nint dx[10]={0,1,0,-1,1,1,-1,-1},dy[10]={-1,0,1,0,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z[1000100],z1[100100];\n\nP u[1000020];\nstack<int> s[2];\n//queue<int> q,q1,q2;\n//set<int> s;\nqueue<P> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<long long,long long> p;\n//list<int> l;\n//string r1,r;\nchar r[52];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y<b.y;\n}\nlong long g(long long a)\n{\n    if(a<0) return 0;\n    return z[a];\n}\n\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b/2);\n    x*=x;\n    x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nlong long f(long long x,long long y)\n{\n    if(x<y) return 0;\n    //printf(\"@@%lld %lld\\n\",z1[y],p(g(y),mod-2));\n    return g(x)*p(g(y),mod-2)%mod*p(g(x-y),mod-2)%mod;\n}\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    z[0]=1;\n    z1[0]=1;\n    for(int t=1;t<=a;t++)\n        z[t]=z[t-1]*t%mod,z1[t]=p(z[t],mod-2);\n    long long n=0;\n    for(int t=2;t<a;t++)\n    {\n\n        y=x;\n        x=f(t-1,a-1-t)*g(t)%mod*g(a-1-t)%mod;\n        n+=(x-y)*t;\n        n%=mod;\n        //printf(\"@@%lld %lld\\n\",z1[t],p(g(t),mod-2));\n        //printf(\"!!%lld %lld %lld %lld\\n\",x,f(t-1,a-t-1),g(t),g(a-1-t));\n    }\n    printf(\"%lld\",n);\n}\n//128397156\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static AlgStruct idAdd(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static AlgStruct idMul(Args... args) { return Operators::IdMul(args...); }\n\n    const AlgStruct operator+() const { return *this; }\n    const AlgStruct operator-() const { return Operators::Opposite(x); }\n    const AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct& operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct& operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct& operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct& operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    const AlgStruct power(LL n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& value){ s << value.x; return s; }\n\n\ntemplate<LL mod>\nstruct GaloisFieldOperators {\n    static LL Add(LL lhs, LL rhs) { return (lhs + rhs) % mod; };\n    static LL Mul(LL lhs, LL rhs) { return (lhs * rhs) % mod; };\n    static LL IdAdd() { return 0; };\n    static LL IdMul() { return 1; };\n    static LL Opposite(LL value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(LL lhs, LL rhs) { return lhs < rhs; };\n    static LL Power(LL value, LL n) {\n        LL res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static LL Reciprocal(LL value) { return Power(value, mod-2); }\n};\n\nconst LL MOD = 1e9+7;\n\nusing GaloisField = AlgStruct<LL, GaloisFieldOperators<MOD>>;\n\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring::idMul();\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\n\nsigned main()\n{\n    LL n; cin >> n;\n\n    Fact<GaloisField> fact(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * fact[k] * fact[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (LL k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize = 1000010;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nvector<ll> fac(modsize + 5);\nvector<ll> inv(modsize + 5);\nvector<ll> facinv(modsize + 5);\n\nvoid modcalc() {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = facinv[1] = 1;\n\tfor (int i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn modcomb(n + k - 1, k);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tmodcalc();\n\n\tint n;\n\tcin >> n;\n\tn--;\n\tint ans = 0;\n\tint cnt = 0;\n\tfor (int i = (n + 1) / 2; i <= n; i++) {\n\t\tcnt = fac[i] * fac[n - i] % mod*modcomb(i - 1, n - i) % mod;\n\t\tcnt -= fac[i - 1] * fac[n - i + 1] % mod*modcomb(i - 2, n - i + 1) % mod;\n\t\tif (cnt < 0) cnt += mod;\n\t\tans += cnt * i;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define queue QQQ\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e5+233; \nconst int mod = 1e9+7;\nint fac[maxn],inv[maxn],f[maxn],n;\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\ninline int C(int n,int m){\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n-m] % mod;\n}\nint main(){\n\tn=rd();\n\tfac[0] = 1;\n\tRep(i,1,n) fac[i] = 1ll * fac[i-1] * i % mod;\n\tinv[n] = qpow(fac[n],mod-2);\n\tDep(i,n-1,0) inv[i] = 1ll * inv[i+1] * (i+1) % mod;\n\tDep(i,n-1,(n+1)/2){\n\t\tf[i] = 1ll * C(i-1,n-1-i) * fac[i] % mod * fac[n-1-i] % mod;\n\t\tf[i+1] = (f[i+1] - f[i] + mod) % mod;\n\t}\n\tint ans = 0;\n\tDep(i,n-1,(n+1)/2) ans = (ans + 1ll * i * f[i] % mod) % mod;\n\twriteln(ans);\n}\n//f[i]表示答案小于等于i的方案数：i步可以完成\n//也就是相当于有i个变量 \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\n// head\n\nconst int N=1010000;\nint n;\nll fac[N],fnv[N],way[N],ret;\nint main() {\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\trep(i,1,n+1) fac[i]=fac[i-1]*i%mod;\n\tfnv[n]=powmod(fac[n],mod-2);\n\tper(i,1,n+1) fnv[i-1]=fnv[i]*i%mod;\n\t--n;\n\tfor (int j=0;2*j<n;j++) {\n\t\tint i=n-2*j;\n\t\tway[i+j]=fac[i+j-1]*fnv[i-1]%mod*fnv[j]%mod;\n\t}\n\trep(i,1,n+1) {\n\t\tway[i]=way[i]*fac[i]%mod*fac[n-i]%mod;\n\t}\n\trep(i,1,n+1) ret=(ret+(way[i]-way[i-1])*i)%mod;\n\tif (ret<0) ret+=mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nconst ll MOD = 1e9+7;\n\n\n//verified KUPC2014-D,ABC034-C\n//前処理O(n), クエリO(1)\nll power(ll a,ll b){\n    ll ret=1;\n    if(b>0){\n        ret = power(a,b/2);\n        if(b%2==0)ret = (ret*ret)%MOD;\n        else ret = (((ret*ret)%MOD)*a)%MOD;\n    }\n    return ret;\n}\n\nvector<ll> fact,invfact;\n\nvoid init(int n){\n    fact.resize(n+1,1);\n    invfact.resize(n+1,1);\n    for(int i=2;i<=n;i++)fact[i] = (fact[i-1]*i)%MOD;\n    \n    invfact[n] = power(fact[n],MOD-2);\n    for(int i=n-1;i>=1;i--) invfact[i] = (invfact[i+1]*(i+1))%MOD;\n}\n\n\nll C(int n,int r){\n    if(n<r)return 0;\n    return ( ( fact[n]*invfact[r] )%MOD * invfact[n-r] )%MOD;\n}\n\nint f(int n, int k){\n    int a = 2*k-n;\n    int b = n-k-1;\n    if(a<0 || b<0)return 0;\n    \n    return ((C(a+b,a) * fact[k])%MOD * fact[n-k-1])%MOD;\n}\n\nsigned main(){\n    int n;\n    cin>>n;\n    init(n+100);\n\n    int ans = 0;\n    for(int k=1; k<=n-1; k++){\n        (ans += k*(f(n,k)-f(n,k-1)+MOD))%=MOD;\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static AlgStruct idAdd(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static AlgStruct idMul(Args... args) { return Operators::IdMul(args...); }\n\n    AlgStruct operator+() const { return *this; }\n    AlgStruct operator-() const { return Operators::Opposite(x); }\n    AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    AlgStruct power(LL n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& value){ s << value.x; return s; }\n\n\ntemplate<LL mod>\nstruct GaloisFieldOperators {\n    static LL Add(LL lhs, LL rhs) { return (lhs + rhs) % mod; };\n    static LL Mul(LL lhs, LL rhs) { return (lhs * rhs) % mod; };\n    static LL IdAdd() { return 0; };\n    static LL IdMul() { return 1; };\n    static LL Opposite(LL value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(LL lhs, LL rhs) { return lhs < rhs; };\n    static LL Power(LL value, LL n) {\n        LL res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static LL Reciprocal(LL value) { return Power(value, mod-2); }\n};\n\nconst LL MOD = 1e9+7;\n\nusing GaloisField = AlgStruct<LL, GaloisFieldOperators<MOD>>;\n\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring::idMul();\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\n\nsigned main()\n{\n    LL n; cin >> n;\n\n    Fact<GaloisField> fact(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * fact[k] * fact[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (LL k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n\ntemplate<unsigned MOD>  class ModInt {\npublic:\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline auto extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nconst int mod = 1000000007;\nusing mint = ModInt<mod>;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\n\n\nvector<mint> Fact, InvFact;\nvoid makeFact(int n){\n\tFact = vector<mint>(n+1);\n\tFact[0] = mint(1);\n\trep(i,1,n+1) Fact[i] = mint(i) * Fact[i-1];\n\n\tInvFact = vector<mint>(n+1);\n\tInvFact[n] = mint(1) / Fact[n];\n\trrep(i,n) InvFact[i] = mint(i+1) * InvFact[i+1];\n}\n\nmint Factorial(int n){ return Fact[n];}\nmint InverseFactorial(int n){ return InvFact[n];}\nmint Permutation(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[k];}\nmint Combination(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[k] * InvFact[n-k];}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tmakeFact(n+10);\n\n\tmint ans = ZERO;\n\tif(n <= 3){\n\t\tcout << (n == 2 ? 1 : 4) << endl;\n\t\treturn 0;\n\t}\n\n\tmint prv = ZERO;\n\n\trep(k,1,n){\n\t\tmint cur = ONE;\n\t\tcur *= Factorial(k);\n\t\tcur *= Factorial(n - 1 - k);\n\t\tcur *= Combination(k - 1, n - 1 - k);\n\t\tans += mint(k) * (cur - prv);\n\t\tprv = cur;\n\t}\n\t\n\t\n\tcout << ans.getval() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"0\"),0;\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,f[55][55][55],flag[55][55][55],vis[55],tot,z[55],a[55],b[55],ans;\n//f[i][j][k] i到j，用<=k的模数能否到达 \nint solve(int a,int b,int k){\n\tif (k==0) return (a==b);\n\tif (flag[a][b][k]) return f[a][b][k];\n\tflag[a][b][k]=1;\n\treturn f[a][b][k]=solve(a,b,k-1)|solve(a%k,b,k-1);\n}\nbool check1(int x,int y,int p){\n\tF(i,0,50) vis[i]=0;\n\tvis[x]=1;\n\tint pd=0;\n\tD(i,x,y){\n\t\tif (vis[i]){\n\t\t\tpd|=solve(i,y,p);\n\t\t\tF(j,1,tot) vis[i%z[j]]=1;\n\t\t}\n\t}\n\treturn pd;\n}\nbool check(int x){\n\tmemset(vis,0,sizeof(vis));\n\tint pd=0;\n\tF(i,1,n){\n\t\tpd=check1(a[i],b[i],x-1);\n\t\tif (!pd) return 0;\n\t}\n\treturn 1;\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n) a[i]=read();\n\tF(i,1,n) b[i]=read();\n\tint pd=1;\n\tF(i,1,n) if (a[i]!=b[i]) pd=0;\n\tif (pd) ret;\n\tif (!check(51)){\n\t\treturn puts(\"-1\"),0;\n\t}\n\tD(i,50,1){\n\t\tif (!check(i)) z[++tot]=i,ans+=1LL<<i;\n\t}\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong m=1e9+7,n;\nlong fac[1<<17],inv[1<<17];\nlong p(long a,long b){return b?p(a*a%m,b/2)*(b%2?a:1)%m:1;}\nlong c(int a,int b){return fac[a]*inv[b]%m*inv[a-b]%m;}\nmain()\n{\n\tcin>>n;\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%m;\n\tinv[n]=p(fac[n],m-2);\n\tfor(int i=n;i--;)inv[i]=inv[i+1]*(i+1)%m;\n\tlong ans=fac[n];\n\tfor(int k=(n+1)/2;k<n;k++)\n\t{\n\t\tans=(ans-c(k-1,n-k-1)*fac[k]%m*fac[n-k-1]%m+m)%m;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n#define endl \"\\n\"\n \nconst LD eps=1e-10;\nconst long long INFLL=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9;\n \ntemplate<class T>\nvoid chmin(T& a, const T b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tfor(int i=0;i<q;i++)\n\t\tt*=p;\n\treturn t;\n}\n\ntemplate <typename T>\nstruct has_iter\n{\n\tprivate:\n\t\ttemplate <typename U>\n\t\tstatic constexpr true_type check(typename U::iterator*);\n\t\ttemplate <typename U>\n\t\tstatic constexpr false_type check(...);\n\n\tpublic:\n\t\tstatic constexpr bool value = decltype(check<T>(nullptr))::value;\n};\n\n\ntemplate<typename T, typename U = typename T::iterator>\nvoid print(const T& container)\n{\n\t\tauto&& first=begin(container), last=end(container);\n\t\tauto&& back=prev(last);\n\t\tfor(auto e=first; e!=last; e=next(e))\n\t\t\tcout<<*e<<\" \\n\"[e==back];\n}\n\n\nextern void* enabler;\ntemplate<typename Head, typename enable_if<!has_iter<Head>::value>::type*& = enabler>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<> void print<string>(const string& container)\n{\n\tcout<<container<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec)\n{\n\tfor(T& x: vec) is >> x;\n\treturn is;\n}\n\n\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& p)\n{\n\tos<<'('<<p.first<<\", \"<<p.second<<')';\n\treturn os;\n}\n\ntemplate<typename T>\nvector<T> read(int n)\n{\n\tvector<T> t(n);\n\tcin>>t;\n\treturn t;\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\ntemplate<typename Head, typename... Tail>\nstruct vector_demensions\n{\n\tusing type=vector<typename vector_demensions<Tail...>::type>;\n};\n\ntemplate<typename Head>\nstruct vector_demensions<Head> { using type=Head; };\n\ntemplate<typename T>\nvector<T> make_vectors(int size, T val)\n{\n\treturn vector<T>(size, val);\n}\n\ntemplate<typename T=int, typename... Args>\nauto make_vectors(int size, Args... tail)\n\t-> typename vector_demensions<Args..., T>::type\n{\n\tauto val=make_vectors<T>(forward<Args>(tail)...);\n\treturn vector<decltype(val)>(size, val);\n}\n\n\nclass Mod\n{\n\tpublic:\n\t\tusing value_type = long long;\n\tprivate:\n\t\tstatic const value_type MODULO = 1e9+7;\n\t\tvalue_type value;\n\n\t\tconstexpr value_type Normalize(value_type x) const\n\t\t{\n\t\t\treturn x<0?(x%MODULO+MODULO):(x%MODULO);\n\t\t}\n\n\tpublic:\n\t\tconstexpr Mod():value(0){}\n\t\tconstexpr Mod(const value_type &val):value(Normalize(val)) {}\n\t\t\n\t\texplicit operator value_type () const\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\tconstexpr const Mod operator -() const\n\t\t{\n\t\t\treturn Mod(MODULO - value);\n\t\t}\n\t\tconstexpr const Mod operator +(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value + rhs.value);\n\t\t}\n\t\tconstexpr const Mod operator -(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value + (-rhs).value);\n\t\t}\n\t\tconstexpr const Mod operator *(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value * rhs.value);\n\t\t}\n\t\tMod &operator +=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\tMod &operator -=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\tMod &operator *=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\n\n\t\tMod pow(value_type p) const;\n\n\t\tMod inv() const\n\t\t{\n\t\t\treturn pow(MODULO-2);\n\t\t}\n\n\t\tconst Mod operator /(const Mod &rhs) const\n\t\t{\n\t\t\treturn *this * rhs.inv();\n\t\t}\n\t\tMod &operator /=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this / rhs;\n\t\t}  \n\t\tconstexpr bool operator ==(const Mod &rhs)\n\t\t{\n\t\t\treturn value == rhs.value;\n\t\t}\n};\n\nMod Mod::pow(value_type p) const\n{\n\tMod tmp=1, mult=*this;\n\twhile(p)\n\t{\n\t\tif((p&1)>0) tmp*=mult;\n\t\tp>>=1;\n\t\tmult*=mult;\n\t}\n\treturn tmp;\n}\n\nnamespace std\n{\n\tostream& operator<<(ostream& os, const Mod mod)\n\t{\n\t\tos<<(typename Mod::value_type)mod;\n\t\treturn os;\n\t}\n};\n\nclass Factorial\n{\n\tprivate:\n\t\tvector<Mod> ary;\n\tpublic:\n\t\texplicit Factorial(const size_t size):ary(vector<Mod>(size))\n\t\t{\n\t\t\tary[0]=1;\n\t\t\tfor(size_t i=1;i<size;i++)\n\t\t\t\tary[i]=ary[i-1]*i;\n\t\t}\n\n\t\tsize_t size() const {   return ary.size();  }\n\n\t\tMod operator[] (const int id) const\n\t\t{\n\t\t\treturn ary[id];\n\t\t}\n};\nclass FactorialInv\n{\n\tprivate:\n\t\tvector<Mod> ary;\n\tpublic:\n\t\texplicit FactorialInv(const Factorial &fact):ary(vector<Mod>(fact.size()))\n\t\t{\n\t\t\tfor(size_t i=0;i<ary.size();i++)\n\t\t\t\tary[i]=fact[i].inv();\n\t\t}\n\n\t\t//FactorialInv& operator=(FactorialInv&&)=default;\n\n\t\tMod operator[] (const int id) const\n\t\t{\n\t\t\treturn ary[id];\n\t\t}\n};\n\nclass Combination\n{\n\tprivate:\n\t\tconst Factorial *fact;\n\t\tconst FactorialInv *fact_inv;\n\tpublic:\n\t\tCombination(const Factorial &fact_, const FactorialInv &fact_inv_):fact(&fact_),fact_inv(&fact_inv_)\n\t\t{}\n\n\t\tMod operator()(const int n, const int m) const\n\t\t{\n\t\t\treturn (*fact)[n] * (*fact_inv)[m] * (*fact_inv)[n-m];\n\t\t}\n};\n\n\nint main()\n{\n\tconst int N=1000000*2;\n\tFactorial fa(N);\n\tFactorialInv fi(fa);\n\tCombination comb(fa,fi);\n\tint n;\n\tcin>>n;\n\tMod ans=0, pre=0, t;\n\tFOR(k,1,n+1)\n\t{\n\t\tif(!(0<=n-k-1&&n-k-1<=k-1)) continue;\n\t\tt=comb(k-1, n-k-1)*fa[k]*fa[n-k-1];\n\t\t//print(k,t);\n\t\tans+=(t-pre)*Mod(k);\n\t\tpre=t;\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fin cin\n#define fout cout\n//ifstream fin(\"x.in\"); ofstream fout(\"x.out\");\n\ntypedef long long i64;\nconst int nmax = 1e6;\nconst int mod = 1e9 + 7;\n\nint n;\ni64 fact[nmax + 1], inv[nmax + 1];\n\ni64 lgput (i64 b, int p) {\n    i64 ans = 1;\n    while (p > 0) {\n        if (p & 1)\n            ans = ans * b % mod;\n        b = b * b % mod;\n        p >>= 1;\n    }\n    return ans;\n}\n\ni64 C (int x, int y) {\n    if (x < y) return 0;\n    if (x < 0) return 0;\n    return fact[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\ni64 min_p (int k) {\n    i64 aux = C(k - 1, n - k - 1);\n    return fact[k] * aux % mod * fact[n - k - 1] % mod;\n}\n\nint main() {\n    fin.sync_with_stdio(false); fin.tie(); fout.tie();\n\n    fact[0] = 1;\n    for (int i = 1; i <= nmax; ++ i)\n        fact[i] = fact[i - 1] * i % mod;\n\n    inv[nmax] = lgput(fact[nmax], mod - 2);\n    for (int i = nmax - 1; i >= 0; -- i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n\n    i64 ans = 0;\n    fin >> n;\n\n    for (int i = 1; i < n; ++ i) {\n        i64 aux = min_p(i) - min_p(i - 1);\n        if (aux < 0)\n            aux += mod;\n\n        ans = (ans + 1LL * i * aux) % mod;\n    }\n    fout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int MAX_N=1e6+5;\nconst int Mod=1e9+7;\nint n;\nint ans; \nint F[MAX_N];\nint inv[MAX_N];\nint inv_F[MAX_N];\nsigned main()\n{\n\tcin>>n;\n\tF[0]=inv_F[0]=1;\n\tfor(int i=1;i<=n;i++)F[i]=F[i-1]*i%Mod;\n\tinv[1]=inv_F[1]=1;\n    for(int i=2;i<=n;i++)inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;\n    for(int i=2;i<=n;i++)inv_F[i]=inv_F[i-1]*inv[i]%Mod;\n\t/*\tdp[k]=(k-1)!/((n-k-1)!*(2k-n)!)*(n-k-1)!*(k)!\n\t\t=(k-1)!*k!/(2k-n)!*/\n\tfor(int i=(n+1)/2;i<n;i++)ans=(ans+(F[i-1]*F[i]%Mod*inv_F[2*i-n]%Mod))%Mod;\t\n\tcout<<(Mod+F[n]-ans%Mod)%Mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1000006;\nconst int MOD = 1000000007;\n\n\nint n;\nint fact[MAXN];\nint ifact[MAXN];\n\nll ADD(ll a, ll b){\n    return (a+b)%MOD;\n}\nll SUB(ll a, ll b){\n    return (a-b+MOD)%MOD;\n}\nll MUL(ll a, ll b){\n    return a*b%MOD;\n}\nll POW(ll a, ll b){\n    if(b==0) return 1;\n    if(b%2) return MUL(a, POW(a, b-1));\n    ll v=POW(a, b/2);\n    return MUL(v, v);\n}\n\nll DIV(ll a, ll b){\n    return MUL(a, POW(b, MOD-2));\n}\n\n\nvoid init(){\n    fact[0]=1;\n    ifact[0]=1;\n    for(int i=1;i<MAXN;++i) {\n        fact[i]=MUL(fact[i-1], i);\n        ifact[i]=POW(fact[i], MOD-2);\n    }\n}\n\nint bc(int n, int k){\n    return MUL(MUL(fact[n], ifact[k]), ifact[n-k]);\n}\n\nint main(){\n    init();\n    scanf(\"%d\", &n);\n    int prevc=0,sol=0;\n    for(int i=(n+1)/2;i<n;++i){\n        int c=MUL(bc(i-1, n-i-1), fact[i]);\n        sol=ADD(sol, MUL(SUB(c, prevc), i));\n        //printf(\"%d\\n\", bc(i-1, n-i-1));\n        prevc=c;\n    }\n    printf(\"%d\", sol);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007, m = 79133769, n = 536396504, mask = 1073741823;\n \ninline long long int MR(long long int A){\n    long long int ret = (A + M * (m * A & mask)) >> 30;\n    return ret - (ret >= M) * M;\n}\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  constexpr Fact() : val() {\n    val[0] = 73741817;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F * 73741817 % M;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000001>();\nconstexpr auto ifact = IFact<1000001, 397802501>();\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += MR(MR(fact.val[i] * fact.val[i - 1]) * ifact.val[i * 2 - N]);\n    }\n    ans = fact.val[N] - fact.val[N - 1] - ans;\n    ans %= M;\n    cout << MR(ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\n\nint main()\n{\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(ll i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst ll MAX = 1e7;\nconst ll MOD = 1e9+7;\n\nll N;\n\n//階乗とその逆元\nll fac[MAX+1],facInv[MAX+1];\n\nll power(ll e, ll x){ //e^x % MOD\n\tif (x == 0) return 1LL;\n\tif (x % 2 != 0) return ((power(e, x-1) * e) % MOD);\n\tll temp = power(e, x / 2);\n\treturn (temp * temp) % MOD;\n}\n\nll nck(ll n, ll k){\n\tif (!(n >= k && k >= 0)) return 0;\n\tll temp = (fac[n] * facInv[n-k]) % MOD;\n\treturn ((temp * facInv[k]) % MOD);\n}\n\nvoid fact(void){\n\t//階乗とその逆元\n\tfac[0] = facInv[0] = 1; //0! = 1\n\t//(x!)^(-1) ≡ (x!)^(p-2) (mod p)\n\tRep(1, MAX, i) fac[i] = (fac[i-1] * i) % MOD;\n\tfacInv[MAX] = power(fac[MAX], MOD-2);\n\tRep(1, MAX-1, i) facInv[MAX-i] = (facInv[MAX-i+1] * (MAX-i+1)) % MOD;\n}\n\nll calc(ll k) {\n\tll a = 2*k - N, b = N - k - 1LL;\n\treturn (nck(a+b, b)*fac[k]%MOD)*fac[N-k-1LL]%MOD;\n}\n\nvoid solve(void){\n\tcin >> N;\n\tfact();\n\tvector <ll> res(N);\n\trep(N, i) res[i] = calc(i);\n\tll ans = 0LL;\n\tRep(1, N-1, i) {\n\t\tans += i*(res[i]-res[i-1]);\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fre(i,t,n)  for(int i =(t);i<=(n);++i)\n#define fer(i,n,t)  for(int i =(n);i>=(t);--i)\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nvoid smain();\nint main(){\n    ios::sync_with_stdio(false);\n    smain();\n    return 0;\n}\nconst int maxn = 1e6+100;\nconst ll MOD = 1000000007;\nll fac[maxn];\nll inv[maxn];\nll qp(ll a,ll n)\n{\n    ll ans=1,now=a%MOD;\n    while(n)\n    {\n        if(n&1) ans=(ans*now)%MOD;\n        now=now*now%MOD;\n        n>>=1;\n    }\n    return ans;\n}\nll C(int a,int b)\n{\n    if(a<b) return 0;\n    return fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}\nll pre[maxn];\nvoid smain(){\n    fac[0]=1;\n    for(int i=1;i<maxn;++i) fac[i]=(fac[i-1]*i)%MOD;\n    inv[maxn-1]=qp(fac[maxn-1],MOD-2);\n    for(int i=maxn-2;i>=0;--i)  inv[i]=(inv[i+1]*(i+1))%MOD;\n    int N;\n    cin>>N;\n\n    for(int K=1;K<N;++K)\n        pre[K]=C(K-1,N-K-1)*fac[K]%MOD*fac[N-K-1]%MOD;\n    ll ans=0,tmp;\n    for(int K=1;K<N;++K)\n    {\n        tmp=(pre[K]-pre[K-1]+MOD)%MOD;\n        ans=(ans+tmp*(K)%MOD)%MOD;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\nll mypow(ll a, ll n) {\n\tif (n == 0)return 1;\n\tll d = mypow(a, n / 2);\n\tif (n & 1)return a * d%MOD*d%MOD;\n\treturn d * d%MOD;\n}\nvl fact,inv;\n\nll comb(ll n, ll r) {\n\treturn fact[n] * inv[r] % MOD*inv[n - r] % MOD;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfact.resize(n + 1);\n\tinv.resize(n + 1);\n\tfact[0] = 1;\n\tinv[0] = 1;\n\tREP(i, n) {\n\t\tfact[i + 1] = fact[i] * (i + 1);\n\t\tfact[i + 1] %= MOD;\n\t\tinv[i + 1] = mypow(fact[i + 1], MOD - 2);\n\t}\n\tll ans = 0;\n\tvl cnt(n);\n\n\tFOR(i, (n + 1) / 2, n) {\n\t\tcnt[i] = fact[i] * fact[n - 1 - i] % MOD*comb(i - 1, n - 1 - i) % MOD;\n\t}\n\tFOR(i, (n + 1) / 2, n) {\n\t\tans += i*(cnt[i] - cnt[i - 1]+MOD)%MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define MAXN 2000005\n#define LL long long\n#define mod 1000000007\nusing namespace std;\n\nint n;\nLL fac[MAXN], inv[MAXN], ans, last;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    fac[0]=fac[1]=1; inv[0]=inv[1]=1;\n    for(int i=2; i<=n; i++) fac[i]=(fac[i-1]*i)%mod;\n    for(int i=2; i<=n; i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2; i<=n; i++) inv[i]=inv[i-1]*inv[i]%mod;\n    for(int i=(n+1)/2; i<n; i++)\n    {\n        LL com=fac[i-1]*inv[n-i-1]%mod*inv[2*i-n]%mod;\n        LL temp=com*fac[i]%mod*fac[n-i-1]%mod;\n        ans=(ans+(mod+temp-last)%mod*i)%mod;\n        last=temp;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    if(N == 2){\n        cout << 1;\n        return 0;\n    }\n    int mod = 1000000007;\n\n    Combination C(N, mod);\n    int ans = 0;\n\n    vec F(N);\n    REP(k, N){\n        int tmp = C.fact[k] * C.fact[N - 1 - k];\n        tmp %= mod;\n        tmp *= C.comb(k - 1, N - 1 - k);\n        tmp %= mod;\n        F[k] = tmp;\n    }\n\n    FOR(k, 1, N){\n        ans += k * (F[k] - F[k - 1] + mod);\n        ans %= mod;\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<ll> vll;\ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\ntypedef unsigned long long ull;\n\n/////////////////////////////////\n\nint const MAX = 1e6 + 41;\nint const MOD = 1e9 + 7;\n\nint f[MAX];\nint invf[MAX];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mult(int a, int b) {\n\treturn (ll) a * b % MOD;\n}\n\nint getc(int n, int k) {\n\tif (k > n) return 0;\n\treturn mult(f[n], mult(invf[n - k], invf[k]));\n}\n\nint bp(int x, int d) {\n\tint res = 1;\n\twhile (d) {\n\t\tif (d & 1) res = mult(res, x);\n\t\tx = mult(x, x);\n\t\td >>= 1;\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tf[0] = 1;\n\tfi(1, MAX - 1) {\n\t\tf[i] = mult(f[i - 1], i);\n\t}\n\tfi(0, MAX - 1) {\n\t\tinvf[i] = bp(f[i], MOD - 2);\n\t}\n}\n\nint n, ans, all;\n\nvoid solve() {\n\tif (n == 2) {\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\tfi(1, n - 1) {\n\t\tint w = getc(i - 1, n - 1 - i);\n\t\tif (!w) continue;\n\t\tw = mult(w, f[i]);\n\t\tw = mult(w, f[n - 1 - i]);\n\t\tw = add(w, -all);\n\t\tans = add(ans, mult(i, w));\n\t\tall = add(all, w);\t\t\t\t\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tinit();  \n\tscanf(\"%d\", &n);\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n#define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#include <fstream>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\n#define forifrom(i, s, n) for (ll i = s; i < n; ++i)\n#define forirto(i, n, e) for (ll i = (n) - 1; i >= e; --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n\nconst ll MOD = 1000000007;\nconst ll INF = 2000000000;\nconst long long BIG = 1446803456761533460LL;\n\n#define XL (x << 1)\n#define XR (XL | 1)\n#define MD ((l + r) >> 1)\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 1000010;\n\nll n, fact[maxn], ifact[maxn];\nll cnt[maxn];\n\nll poww(ll a, ll b) {\n    ll r = 1;\n    while (b) {\n        if (b & 1) Mul(r, a);\n        Mul(a, a);\n        b >>= 1;\n    }\n    return r;\n}\n\nll ent(ll a, ll b) {\n    return a > b ? 0 : fact[b] * ifact[a] % MOD * ifact[b - a] % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    fact[0] = 1;\n    fori (i, maxn - 1) fact[i + 1] = fact[i] * (i + 1) % MOD;\n    ifact[maxn - 1] = poww(fact[maxn - 1], MOD - 2);\n    forir (i, maxn - 1) ifact[i] = ifact[i + 1] * (i + 1) % MOD;\n\n    cin >> n;\n    fori (i, n) {\n        cnt[n - i] = ent(i, n - 2 - i) * fact[i] % MOD * fact[n - 1 - i] % MOD;\n    }\n    ll s = 0;\n    fori (i, n) {\n        Add(s, (cnt[i + 1] - cnt[i] + MOD) * i);\n    }\n    cout << s << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <ctype.h>\n\nusing namespace std;\ntypedef long long lli;\ntypedef pair<int,int> pii;\ntypedef pair<lli,int> pli;\ntypedef pair<lli,lli> pll;\n\nint _abs_int(int a) {return a<0 ? -a : a;}\nlli _abs_lli(lli a) {return a<0 ? -a : a;}\n\nconst lli mod=1e9+7;\n\nlli power(lli a,lli p) {\n\tlli res=1;\n\twhile(p) {\n\t\tif(p&1) res=res*a%mod;\n\t\ta=a*a%mod;\n\t\tp>>=1;\n\t}\n\treturn res;\n}\nlli inv(lli a) {return power(a,mod-2);}\n\nlli fact[1000001];\nint n;\nint main() {\n\tfact[0]=1;\n\tfor(int i=1;i<=1000000;i++) fact[i]=fact[i-1]*i%mod;\n\tscanf(\"%d\",&n);\n\t\n\tint tn=n/2, on=n&1;\n\tlli ans=0, ps=0;\n\tfor(;on<n;on+=2,tn--) {\n\t\tlli val=fact[tn+on-1] * inv(fact[tn-1]) % mod;\n\t\tval = val*inv(fact[on])%mod;\n\t\tval=val*fact[tn+on]%mod;\n\t\tval=val*fact[n-tn-on-1]%mod;\n\t\tval=(val-ps+mod)%mod;\n\t\tans=(ans + val%mod*(tn+on)%mod)%mod;\n\t\tps=(ps+val)%mod;\n\t}\n\tif(ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 1e6 + 10;\n\ntemplate<int mod>\nclass ModCalc {\nprivate:\n    const int defnum = -1;\npublic:\n    ModCalc() { }\n    const inline int add(int a, const int b) const {\n        a += b;\n        while (a < 0) a += mod;\n        while (a >= mod) a -= mod;\n        return a;\n    }\n    const inline int mul(const int a, const int b) const {\n        return (long long)a * b % mod;\n    }\n    const inline void add_ref(int &a, const int b) const {\n        a = this->add(a, b);\n    }\n    const inline void mul_ref(int &a, const int b) const {\n        a = this->mul(a, b);\n    }\n    const inline void add_ref(long long &a, const int b) const {\n        a = this->add(a, b);\n    }\n    const inline void mul_ref(long long &a, const int b) const {\n        a = this->mul(a, b);\n    }\n    const inline int pow(int a, int p) const {\n        int res = 1;\n        while (p > 0) {\n            if (p & 1) res = this->mul(res, a);\n            a = this->mul(a, a);\n            p >>= 1;\n        }\n        return res;\n    }\n    const inline int inverse(int a) const {\n        return this->pow(a, mod - 2);\n    }\n};\n\nModCalc<MOD> mc;\nint memoFact[MAX], memoInvFact[MAX];\n\ninline int fact(int n) {\n    if (memoFact[n] != -1) return memoFact[n];\n    return memoFact[n] = (n == 0 ? 1 : mc.mul(n, fact(n - 1)));\n}\n\ninline int invFact(int n) {\n    if (memoInvFact[n] != -1) return memoInvFact[n];\n    return memoInvFact[n] = mc.inverse(fact(n));\n}\n\ninline long long Perm(int n, int r) {\n    return mc.mul(fact(n), invFact(n - r));\n}\n\ninline long long comb(int n, int r) {\n    return mc.mul(mc.mul(fact(n), invFact(r)), invFact(n - r));\n}\n\n// M個の物をN人で分ける\ninline long long combWithRepetition(int M, int N) {\n    return comb(M + N - 1, N - 1);\n}\n\n//最初に呼んで♪\ninline void init() {\n    memset(memoFact, -1, sizeof(memoFact));\n    memset(memoInvFact, -1, sizeof(memoInvFact));\n    for (int i = 0; i < MAX; i++) {\n        fact(i);\n        invFact(i);\n    }\n}\n\nint N;\n\nint main(void) {\n    init();\n    cin >> N;\n    int ans = 0;\n    int foo = 0;\n    const int mi = (N + 1) / 2;\n    FOR(i, mi, N) {\n        const auto bar = mc.add(mc.mul(fact(i), mc.mul(fact(N - 1 - i), comb(i - 1, N - 1 - i))), -foo);\n        mc.add_ref(ans, mc.mul(bar, i));\n        mc.add_ref(foo, bar);\n        //DEBUG(ans)\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <boost/math/special_functions/factorials.hpp>\n \nint64_t score(int n) {\n  if (n == 2)\n    return 1;\n  if (n == 3)\n    return 4;\n  if (n == 4)\n    return 16;\n  return ((boost::math::factorial<int>(n-2) + score(n-1)) * (n-1) -2 * boost::math::factorial<int>(n-3)) % (10000000007);\n}\n \nint main() {\n  int n;\n  std::cin >> n;\n  std::cout << score(n) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define N 1000005\n#define MOD 1000000007\n\nusing namespace std;\n\nint n;\nll fact[N] , invfact[N];\n\nll Pow(ll n , ll p)\n{\n    ll npow = n , ans = 1;\n\n    for(; p ; p >>= 1)\n    {\n        if(p & 1)\n            ans = ans * npow % MOD;\n\n        npow = npow * npow % MOD;\n    }\n\n    return ans;\n}\n\nvoid Prepare()\n{\n    int i;\n\n    fact[0] = invfact[0] = 1;\n\n    for(i = 1 ; i <= n ; i++)\n    {\n        fact[i] = fact[i - 1] * i % MOD;\n        invfact[i] = Pow(fact[i] , MOD - 2);\n    }\n}\n\nll Comb(ll n , ll k)\n{\n    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD;\n}\n\nint main()\n{\n    ll x , ans = 0 , y = 0;\n    int k;\n\n    cin >> n;\n\n    Prepare();\n\n    for(k = n / 2 ; k < n ; k++)\n    {\n        x = Comb(k - 1 , n - k - 1) * fact[k] % MOD * fact[n - k - 1] % MOD;\n        x = (x - y + MOD) % MOD;\n        y = (y + x) % MOD;\n        x = x * k % MOD;\n        ans = (ans + x) % MOD;\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\nconst int NP = 1e6 + 7;\nmodint p[NP], v[NP], vp[NP];\ninline void init(int n) {\n  p[0] = v[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n  vp[n] = 1 / p[n];\n  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n}\ninline modint binom(int n, int m) {\n  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n}\n\nint main() {\n\tint n;\n\trd(n), init(n);\n\tmodint ans, s, o;\n\tfor (int i = 1; i < n; i++)\n\t\to = binom(i - 1, n - 1 - i) * p[i] * p[n-1-i],\n\t\tans += (o - s) * i, s = o;\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(ll i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst ll MAX = 1e6;\nconst ll MOD = 1e9+7;\n\nll N;\n\n//階乗とその逆元\nll fac[MAX+1],facInv[MAX+1];\n\nll power(ll e, ll x){ //e^x % MOD\n\tif (x == 0) return 1LL;\n\tif (x % 2 != 0) return ((power(e, x-1) * e) % MOD);\n\tll temp = power(e, x / 2);\n\treturn (temp * temp) % MOD;\n}\n\nll nck(ll n, ll k){\n\tif (!(n >= k && k >= 0)) return 0;\n\tll temp = (fac[n] * facInv[n-k]) % MOD;\n\treturn ((temp * facInv[k]) % MOD);\n}\n\nvoid fact(void){\n\t//階乗とその逆元\n\tfac[0] = facInv[0] = 1; //0! = 1\n\t//(x!)^(-1) ≡ (x!)^(p-2) (mod p)\n\tRep(1, MAX, i) fac[i] = (fac[i-1] * i) % MOD;\n\tfacInv[MAX] = power(fac[MAX], MOD-2);\n\tRep(1, MAX-1, i) facInv[MAX-i] = (facInv[MAX-i+1] * (MAX-i+1)) % MOD;\n}\n\nll calc(ll k) {\n\tll a = 2*k - N, b = N - k - 1LL;\n\treturn (nck(a+b, b)*fac[k]%MOD)*fac[N-k-1LL]%MOD;\n}\n\nvoid solve(void){\n\tcin >> N;\n\tfact();\n\tvector <ll> res(N);\n\trep(N, i) res[i] = calc(i);\n\tll ans = 0LL;\n\tRep(1, N-1, i) {\n\t\tans += i*(res[i]-res[i-1]+MOD)%MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007, m = 79133769, n = 536396504, mask = 1073741823;\n \ninline long long int MR(long long int A){\n    long long int ret((A + M * (m * A & mask)) >> 30);\n    return ret - (ret >= M) * M;\n}\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  constexpr Fact() : val() {\n    val[0] = 73741817;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F * 73741817 % M;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += MR(MR(fact.val[i] * fact.val[i - 1]) * ifact.val[i * 2 - N]);\n    }\n    ans = fact.val[N] - fact.val[N - 1] - ans;\n    ans %= M;\n    cout << MR(ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1000005;\nconst int mod=1000000007;\n\nint n,ans,sum;\nint fac[N],inv[N],f[N];\n\nint quickpow(int x,int y){\n\tint s=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mod)\n\t\tif (y&1) s=1ll*s*x%mod;\n\treturn s;\n}\n\nvoid init(int n){\n\tint i;\n\tfac[0]=inv[0]=1;\n\tfor (i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=quickpow(fac[n],mod-2);\n\tfor (i=n-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int x,int y){\n\tif (x<y) return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tinit(n);\n\tfor (i=1;i<n;i++){\n\t\tsum=C(i-1,n-1-i);\n\t\tf[i]=1ll*sum*fac[i]%mod*fac[n-1-i]%mod;\n\t}\n\tfor (i=1;i<n;i++) (ans+=1ll*(f[i]-f[i-1])*i%mod)%=mod;\n\tans=(ans%mod+mod)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int inv(int n, int p) {\n\tint i = 1;\n\tfor (int r = n; r > 1; r = p % r)\n\t\ti = p / r * long(p - i) % p;\n\treturn i;\n}\nint f[111111], g[111111];\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint p = 1e9 + 7;\n\tf[0] = 1, g[n - 1] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tf[i] = long(i)*f[i - 1] % p;\n\t\tg[n - 1 - i] = long(n - 1 - i)*g[n - i] % p;\n\t}\n\tint a = 0;\n\tfor (int i = (n + 1) / 2; i < n - 1; i++)\n\t\ta = (a + (long(f[i])*f[i - 1]) % p*g[i * 2 - n + 1]) % p;\n\tcout << (long(n - 1)*f[n - 1] + long(p - a)*inv(f[n - 2], p)) % p << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MAXN=1e6+5,P=1e9+7;\nint n;\nint fac[MAXN],fac_inv[MAXN];\n\ninline int pow(int x,int y){\n\tint ret=1;\n\tfor(;y;x=(long long)x*x%P,y>>=1){\n\t\tif(y&1) ret=(long long)ret*x%P;\n\t}\n\treturn ret;\n}\n\ninline int inv(int x){return pow(x,P-2);}\n\ninline int C(int n,int m){\n\tif(n<m || m<0) return 0;\n\treturn (long long)fac[n]*fac_inv[m]%P*fac_inv[n-m]%P;\n}\n\ninline int cal(){\n\tstatic int f[MAXN];\n\tfor(int i=1;i<n;++i)\n\t\tf[i]=(long long)C(i-1,n-1-i)*fac[i]%P*fac[n-1-i]%P;\n\tint ret=0;\n\tfor(int i=1;i<n;++i)\n\t\tret=(ret+(long long)(f[i]-f[i-1]+P)%P*i%P)%P;\n\treturn ret;\n}\n\ninline void pre_cal(){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=(long long)fac[i-1]*i%P;\n\tfac_inv[n]=inv(fac[n]);\n\tfor(int i=n-1;i>=0;--i)\n\t\tfac_inv[i]=(long long)fac_inv[i+1]*(i+1)%P;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tpre_cal();\n\tprintf(\"%d\",cal());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#define MN 1000000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,p[MN+5],inv[MN+5],ans;\ninline int C(int n,int m){return m<=n?1LL*p[n]*inv[m]%mod*inv[n-m]%mod:0;}\nint main()\n{\n    n=read();p[0]=p[1]=inv[0]=inv[1]=1;\n    for(int i=2;i<=MN;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=MN;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    ans=1LL*p[n-1]*(n-1)%mod;\n    for(int i=2;i<n;++i) ans=(ans-1LL*C(i-2,(n-2-(i-2)))*p[i-1]%mod*p[n-i]%mod+mod)%mod;\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433L;\n\ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n/*\n * @title ModInt\n */\ntemplate<long long mod> class ModInt {\npublic:\n\tlong long x;\n\tconstexpr ModInt():x(0) {\n\t\t// do nothing\n\t}\n\tconstexpr ModInt(long long y) : x(y>=0?(y%mod): (mod - (-y)%mod)%mod) {\n\t\t// do nothing\n\t}\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const long long y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const int y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const long long y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const int y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt operator=(const int y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator=(const long long y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator-() const { return ModInt(-x); }\n\tModInt operator++() { \n\t\tx++;\n\t\tif(x>=mod) x-=mod;\n\t\treturn *this; \n\t}\n\tModInt operator--() { \n\t\tx--;\n\t\tif(x<0) x+=mod;\n\t\treturn *this; \n\t}\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\tbool operator<(const ModInt &p) const { return x < p.x; }\n\tModInt inv() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(long long n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tlong long t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n};\nusing modint = ModInt<MOD>;\n\n/*\n * @title CombinationMod\n */\ntemplate<long long mod> class CombinationMod {\n\tvector<long long> fac,finv,inv;\npublic:\n\tCombinationMod(int N) : fac(N + 1), finv(N + 1), inv(N + 1) {\n\t\tfac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n\t\tfor (int i = 2; i <= N; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % mod;\n\t\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n\tinline long long binom(int n, int k) {\n\t\treturn ((n < 0 || k < 0 || n < k) ? 0 : fac[n] * (finv[k] * finv[n - k] % mod) % mod);\n\t}\n\tinline long long factorial(int n) {\n\t\treturn (n<0?0:fac[n]);\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc021/tasks/abc021_d\nCombinationMod<MOD> CM(1000000);\nint N; \nmodint f(int l,int r) {\n    modint sum = 0;\n    for(int i=0;i<=N/2;++i) {\n        int use=i;\n        use += (l&1?(l-1)/2+1:l/2);\n        use += (r&1?(r-1)/2+1:r/2);\n        int res=N-1-(use+1);\n        int can=0;\n        can += (l&1?(l-3)/2:max(0,(l-2)/2));\n        can += (r&1?(r-3)/2:max(0,(r-2)/2));\n        modint cnt = 1;\n        cnt *= CM.factorial(use);\n        cnt *= CM.factorial(res);\n        cnt *= CM.binom(can,i);\n        cnt *= use+1;\n        sum += cnt;\n    }\n    return sum;\n}\nint main() {\n    cin >> N;\n    corner(N==2,1);\n    corner(N==3,4);\n    modint ans = 0;\n    for(int i = 1; i+1<=N; ++i) {\n        {\n            int l = i-1,r=N-(i+1);\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n        {\n            int l = i-1,r=N-i;\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n        {\n            int l = i,r=N-(i+1);\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MSIZE=1000010;\n\nconst long long mod=1000000007ll;\nvoid ad(long long &a,long long b){a+=b;a%=mod;}\nvoid mn(long long &a,long long b){a+=mod-b;a%=mod;}\nvoid ml(long long &a,long long b){a*=b;a%=mod;}\nlong long sq(long long a){return a*a%mod;}\nlong long pw(long long a,long long n)\n{\n  return n==0?1ll:sq(pw(a,n/2))*(n%2==1?a:1ll)%mod;\n}\nlong long iv(long long a){return pw(a,mod-2);}\nlong long inv[MSIZE],F[MSIZE],iF[MSIZE];\n\nvoid prev(int N)\n{\n  inv[0]=0;\n  inv[1]=1;\n  for(int i=2;i<N;i++){\n    inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n  }\n  F[0]=iF[0]=1;\n  for(int i=1;i<N;i++){\n    F[i]=F[i-1]*i%mod;\n    iF[i]=iF[i-1]*inv[i]%mod;\n  }\n}\n\nlong long Ch(int i,int j)\n{\n  return F[i]*iF[j]%mod*iF[i-j]%mod;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  prev(n+1);\n  long long ans=0ll;\n  for(int i=0;i<n-1;i++){\n    ad(ans,F[n-1]+(i-1<n-1-i?0:mod-Ch(i-1,n-1-i)*F[i]%mod*F[n-1-i]%mod));\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define trav(a,x) for(auto &a:x)\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\n//ll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n\tif (b) { ll d = euclid(b, a % b, y, x);\n\t\treturn y -= a/b * x, d; }\n\treturn x = 1, y = 0, a;\n}\nconst ll MOD=1e9+7;\nll inv(ll a) {\n    ll x, y;\n    euclid(a,MOD,x,y);\n    return (x+MOD)%MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    const int M=3*n;\n    vector<ll> fact(M);\n    fact[0]=1;\n    rep(i,1,M) {\n        fact[i]=(i*fact[i-1])%MOD;\n    }\n\n    vector<ll> a(n);\n    int mink=(n+1)/2;\n    rep(k,mink,n) {\n        int holes=n-1-k;\n        int j=k-1-holes;\n        a[k]=fact[k];//((holes+2)*fact[k-1])%MOD;\n        a[k]=(a[k]*fact[j+holes])%MOD;\n        a[k]=(a[k]*inv(fact[j]))%MOD;\n        //a[k]=(a[k]*inv(fact[holes]))%MOD;\n        //debug(a[k]);\n    }\n    ll ans=0;\n    rep(k,mink,n) {\n        ll x=(a[k]-a[k-1]+MOD)%MOD;\n        x=(x*k)%MOD;\n        ans=(ans+x)%MOD;\n    }\n    cout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007, maxN = 1000000;\n\nint Add(int x, int y) {\n\treturn (x += y) < mod ? x : x - mod;\n}\nint Dec(int x, int y) {\n\treturn (x -= y) < 0 ? x + mod : x;\n}\nint Mul(int x, int y) {\n\treturn 1ll * x * y % mod;\n}\nint Fpow(int x, int y) {\n\treturn y ? Mul(Fpow(Mul(x, x), y >> 1), y & 1 ? x : 1) : 1;\n}\n\nint n, fac[maxN + 10], inv[maxN + 10], invFac[maxN + 10], val[maxN + 10], ans;\n\nvoid PreWork() {\n\tfac[0] = invFac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tinv[i] = i == 1 ? 1 : Dec(0, Mul(mod / i, inv[mod % i]));\n\t\tfac[i] = Mul(fac[i - 1], i);\n\t\tinvFac[i] = Mul(invFac[i - 1], inv[i]);\n\t}\n}\n\nint Comb(int x, int y) {\n\treturn x < y ? 0 : Mul(fac[x], Mul(invFac[y], invFac[x - y]));\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tPreWork();\n\tfor (int i = 1; i < n; ++i) {\n\t\tval[i] = Mul(Mul(Comb(i - 1, n - 1 - i), fac[i]), fac[n - 1 - i]);\n\t\tans = Add(ans, Mul(i, Dec(val[i], val[i - 1])));\n\t}\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Combination {\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod) {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nconst int mod = 1e9 + 7;\n\nint main() {\n  int N;\n  cin >> N;\n  Combination beet(N, mod);\n  int ret = 0, pv = 0;\n  for(int i = 1; i < N; i++) {\n    auto curr = beet.C(i - 1, N - 1 - i) * beet.mfact[i] % mod * beet.mfact[N - 1 - i] % mod;\n    auto sz = (curr + mod - pv) % mod;\n    ret += sz * i % mod;\n    ret %= mod;\n    pv = curr;\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\n\nconst int MAX_N = 1000010;\nll fact[MAX_N],fact_inv[MAX_N],inv[MAX_N];\n\nll pow_mod(ll a,ll b) {\n    ll ret;\n    if (b < 0) ret = pow_mod(a,mod+b-1);\n    else if (b == 0) ret = 1;\n    else if (b == 1) ret = a;\n    else {\n        ll c = pow_mod(a,b/2);\n        if (b%2) ret = (c*c)%mod*a%mod;\n        else ret = c*c%mod;\n    }\n    return ret;\n}\n\nvoid create_table(int n) {\n    fact[0] = 1;fact[1] = 1;\n    for (int i = 2;i <= n;++i) fact[i] = fact[i-1]*i%mod;\n    fact_inv[n] = pow_mod(fact[n],-1);\n    for (int i = n;i > 0;--i) fact_inv[i-1] = fact_inv[i]*i%mod;\n    for (int i = 1;i <= n;++i) inv[i] = fact_inv[i]*fact[i-1]%mod;\n}\n\nll combi(ll a, ll b) {\n    return fact[a]*fact_inv[b]%mod*fact_inv[a-b]%mod;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    create_table(1000000);\n    ll ans = 0,s = 0;\n    for (int i = (n+1)/2;i < n;++i) {\n        ll x = combi(i-1,n-i-1)*fact[i]%mod;\n        (ans += (x-s)*fact[n-i-1]%mod*i%mod) %= mod;\n        s = x*(n-i-1)%mod;\n    }\n    cout << (ans+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nstruct Modint {\n  int n;\n  Modint(int n = 0) : n(n) {}\n};\n\nModint operator+(Modint a, Modint b) { return (a.n += b.n) >= mod ? a.n - mod : a.n; }\nModint operator-(Modint a, Modint b) { return (a.n -= b.n) < 0 ? a.n + mod : a.n; }\nModint operator*(Modint a, Modint b) { return 1LL * a.n * b.n % mod; }\nModint &operator+=(Modint &a, Modint b) { return a = a + b; }\nModint &operator-=(Modint &a, Modint b) { return a = a - b; }\nModint &operator*=(Modint &a, Modint b) { return a = a * b; }\n\nModint modpow(Modint a, long long b) {\n  Modint ans = 1;\n  while (b > 0) {\n    if (b & 1) ans *= a;\n    a *= a;\n    b >>= 1;\n  }\n  return ans;\n}\n\nModint modinv(Modint a) {\n  return modpow(a, mod - 2);\n}\n\nModint operator/(Modint a, Modint b) { return a * modinv(b); }\n\nModint fact[2020202];\nModint ifact[2020202];\nModint inv[2020202];\n\nModint C(int n, int r) {\n  if (n < 0 || r < 0 || n < r) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n  int n;\n  cin >> n;\n  inv[1] = 1;\n  for (int i = 2; i < 2020202; i++) {\n    inv[i] = inv[mod % i] * (mod - mod / i);\n  }\n  fact[0] = 1;\n  ifact[0] = 1;\n  for (int i = 1; i < 2020202; i++) {\n    fact[i] = i * fact[i - 1];\n    ifact[i] = inv[i] * ifact[i - 1];\n  }\n\n  Modint ans = 0;\n  n--;\n  for (int i = 0; i < n; i++) {\n    ans += 1 - C(i - 1, n - i) / C(n, i);\n  }\n  for (int i = 1; i <= n; i++) {\n    ans *= i;\n  }\n\n  cout << ans.n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n\ntypedef long long ll;\n \ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.141592653589;\nconst int mod = 1000000007;\n// memset(a,0,sizeof(a)); →全部０にする\n \nvector<int> G[100005];\nstd::vector<P> tree[100010];\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\n\n#define p(x) cout<<x<<endl;\n \nll i,j,k,l,ii,jj;\nll n,m;\nll x,y;\nll used[200005];\nchar s[305][305];\nll ans=0;\nll v=-1,w;\nll num;\n\n\nll kai(ll n,ll x){\n\tll kei=1;\n\tfor(i=1;i<=n-x;i++){\n\t\tkei *= i;\n\t\tkei = kei%mod;\n\t}\n\treturn kei;\n\n}\nvoid kotae(ll x){\n\tfor(int i=1;i<=n;i++){\n\t\tif(!used[i]){\n\t\t\tused[i]=true;\n\t\t\tif(!used[i-1] && !used[i+1] && i>=2 && i<=n-1){\n\t\t\t\tkotae(x+1);//iminasi kakutei\n\t\t\t}else{\n\t\t\t\tans += kai(n,x);\n\t\t\t}\n\t\t\tused[i]=false;\n\t\t}\n\t}\n \n}\nint main(){\n    cin>>n;\n\t\n\tfor(i=1;i<=n/2;i++){\n\t\tused[i]=true;\n\t\tkotae(1);\n\t\tused[i]=false;\n\n\t}\n\tp(ans%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007;\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  long long int v2[N];\n  constexpr Fact() : val(), v2() {\n    val[0] = 1;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n    for(int i = 1; i < N; ++i)v2[i] = val[i - 1] * val[i] % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000001>();\nconstexpr auto ifact = IFact<1000001, 397802501>();\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += fact.v2[i] * ifact.val[i * 2 - N] % M;\n    }\n    ans = fact.val[N] - fact.val[N - 1] - ans;\n    ans %= M;\n    cout << (ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1000000007;\nconst int Maxn = 1000005;\n\nint fac[Maxn], inv[Maxn];\nint n;\nint res;\n\nint Inv(int a)\n{\n\tint p = mod - 2;\n\tint res = 1;\n\twhile (p) {\n\t\tif (p & 1) res = ll(res) * a % mod;\n\t\tp >>= 1; a = ll(a) * a % mod;\n\t}\n\treturn res;\n}\n\nint C(int n, int k)\n{\n\tif (n < 0 || k < 0 || k > n) return 0;\n\treturn ll(fac[n]) * inv[k] % mod * inv[n - k] % mod;\n}\n\nint main()\n{\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < Maxn; i++) {\n\t\tfac[i] = ll(i) * fac[i - 1] % mod;\n\t\tinv[i] = Inv(fac[i]);\n\t}\n\tscanf(\"%d\", &n);\n\tres = ll(n - 1) * fac[n - 1] % mod;\n\tfor (int i = 1; i <= (n - 2) / 2; i++)\n\t\tres = (res - ll(fac[n - 1 - i]) * C(n - 2 - i, i) % mod * fac[i] % mod + mod) % mod;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <int MOD> struct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tModInt(signed long long sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = (unsigned long long)x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tif (u < 0)\n\t\t\tu += MOD;\n\t\tModInt res;\n\t\tres.x = (unsigned)u;\n\t\treturn res;\n\t}\n};\ntemplate <int MOD> ostream &operator<<(ostream &os, const ModInt<MOD> &m) {\n\treturn os << m.x;\n}\ntemplate <int MOD> istream &operator>>(istream &is, ModInt<MOD> &m) {\n\tsigned long long s;\n\tis >> s;\n\tm = ModInt<MOD>(s);\n\treturn is;\n};\n// pow(mint(2), 1000) のように\ntemplate <int MOD> ModInt<MOD> pow(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tr *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\n\n//#define int long long を使っても大丈夫\nusing mint = ModInt<1000000007>;\n\n// nCrで用いる\nvector<mint> fact, factinv;\n// nCrで用いる 予め計算しておく\nvoid nCr_compute_factinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1);\n\tfactinv.resize(N + 1);\n\tfact[0] = 1;\n\trep(i, 1, N + 1) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor (int i = N; i >= 1; i--)\n\t\tfactinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif (n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) *\n\t\tnCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nmint nHr(int n, int r) { return r == 0 ? 1 : nCr(n + r - 1, r); }\n\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N; cin >> N;\n\tnCr_compute_factinv(N + 10);\n\tmint ans = 0;\n\tmint sum = 0;\n\tmint prev = 0;\n\trep(k, 2, N) {\n\t\tint re = N - 1 - k;\n\t\tif (k - 1 >= re) {\n\t\t\tmint x = nCr(k - 1, re)*fact[k] * fact[re];\n\t\t\tans += (x - prev) * k;\n\t\t\tprev = x;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define MOD 1000000007\n#define MAX_P 1000005\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];;\nInt extgcd(Int a,Int b,Int& x,Int& y){\n  Int d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;y=0;\n  }\n  return d;\n}\nInt mod_inverse(Int a,Int mod){\n  Int x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n}\n\nInt mod_pow(Int x,Int n,Int mod){\n  Int res=1;\n  while(n){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\n\nInt mod_inverse2(Int a,Int mod){\n  return mod_pow(a,mod-2,mod);\n}\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  \n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=finv[i-1]*inv[i]%mod;\n}\n\nInt mod_fact(Int n,Int mod,Int& e){\n  e=0;\n  if(n==0) return 1;\n  Int res=mod_fact(n/mod,mod,e);\n  e+=n/mod;\n  if(n/mod%2!=0)return res*(mod-fact[n%mod]) %mod;\n  return res*fact[n%mod]%mod;\n}\n\nInt mod_comb(Int n,Int k,Int mod){\n  if(n==k||k==0) return 1;\n  Int e1,e2,e3;\n  Int a1=mod_fact(n,mod,e1),a2=mod_fact(k,mod,e2),a3=mod_fact(n-k,mod,e3);\n  if(e1>e2+e3) return 0;\n  return a1*mod_inverse(a2*a3%mod,mod)%mod;\n}\n\nInt mod_comb2(Int n,Int k,Int mod){\n  Int res=1;\n  for(Int i=0;i<k;i++){\n    res*=(n-i)%mod;\n    res%=mod;\n    res*=mod_inverse(i+1,mod);\n    res%=mod;\n  }\n  return res;\n}\n\n//only for prime mod\nInt mod_comb3(Int n,Int k,Int mod){\n  if(k<0||k>n) return 0;\n  return fact[n]*finv[k]%mod*finv[n-k]%mod;\n}\n\nInt montmort(Int n,Int mod){\n  Int res=0,inv=1;\n  for(Int k=2;k<=n;k++){\n    (inv*=mod_inverse(k,mod))%=mod;\n    if(k%2) (res+=mod-inv)%=mod;\n    else (res+=inv)%=mod;\n  }\n  for(Int i=1;i<=n;i++)\n    (res*=i)%=mod;\n  return res;\n}\n\n// calculate P(t) from given points in [0,N]\nInt LagrangePolynomial(vector<Int> &y,Int t,const Int mod){\n  init(mod);\n  Int n=y.size()-1;\n  Int num=1;\n  for(Int i=0;i<=n;i++)\n    num=num*((t-i)%mod)%mod;\n  Int res=0;\n  for(Int i=0;i<=n;i++){\n    Int tmp=(y[i]*num%mod)*mod_inverse((t-i)%mod,mod)%mod;\n    tmp=tmp*finv[i]%mod;\n    tmp=tmp*finv[n-i]%mod;\n    if((n-i)&1) tmp=mod-tmp;\n    res=(res+tmp)%mod;\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  init(MOD);\n  Int n;\n  cin>>n;\n  if(n==2){\n    cout<<1<<endl;\n    return 0;\n  }\n  if(n==3){\n    cout<<4<<endl;\n    return 0;\n  }\n  Int ans=0,pre=0;\n  for(Int i=1;i<n;i++){\n    if(i*2<n) continue;\n    Int len=mod_comb3(i-1,n-1-i,MOD)*fact[n-1-i]%MOD*fact[i]%MOD;\n    ans+=i*(len+MOD-pre)%MOD;\n    ans%=MOD;\n    pre=len;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\nusing namespace std;\nint main(void){\n    long long int n=0,i=1,buf1=0,buf3=0,buf4=0,buf2=0;\n    cin >> n;\n    if(n>1000000||n<2){\n    \texit(0);\n    }\n    buf3=n;\n    n=n-1;\n    cout << n <<endl;\n    for(int f=1;f<buf3;f++){\n    \ti=i*f;\n    \tcout << i<< \" \";\n    \tif(i>=2432902008176640000)i=i/(1000000000+7);\n    }\n    cout << i<<endl;\n    /*vector<long long int> v(n);\n    vector<long long int> buf2;\n    iota(v.begin(),v.end(),1);\n    do {\n        for(auto x : v)buf2.push_back(x);i++;\n    }while(next_permutation(v.begin(),v.end()));*/\n    buf2=2*2/1000000000+7;\n    if(buf3%2==0){\n        buf1=(i-2)*3+(2*2);\n    }\n    else{\n        buf1=(i-(buf3%2+buf3/2))*n;\n    }\n    cout << i<<endl;\n    cout  << buf1%(1000000000+7);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll MOD = 1000000007;\n\nll exp(ll a, ll b){\n    if(b==0)\n        return 1;\n    else if (b%2==0){\n        ll y = exp(a,b/2);\n        return (y*y)%MOD;\n    }\n    return (a*exp(a,b-1))%MOD;\n}\n\nll prod[1000005];\n\nint main()\n{\n    ll N;\n    cin>>N;\n    prod[0] = 1;\n    for(ll i=1; i<1000005; i++){\n        prod[i] = (prod[i-1]*i)%MOD;\n    }\n\n\n    ll ans = 0;\n    if(N==2){\n        cout<<1<<endl;\n        return 0;\n    }\n    if(N==3){\n        cout<<4<<endl;\n        return 0;\n    }\n    else{\n        ans = (prod[N-1]*(N-1))%MOD;\n        ll prev = 0;\n        for(ll i=(N-2)/2; i>=1; i--){\n            ll carry = prod[N-2-i];\n            carry = (carry*exp(prod[N-2-2*i],MOD-2))%MOD;\n            carry = (carry*exp(prod[i],MOD-2))%MOD;\n            carry = (carry*prod[N-1-i])%MOD;\n            carry = (carry*prod[i])%MOD;\n            ll ct = carry;\n            carry = (carry-prev)%MOD;\n            prev = ct;\n            carry = (carry*i)%MOD;\n            ans = (ans + MOD - carry)%MOD;\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 1000010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll nq[MAXN],inv[MAXN];\nll fsp(ll x,int y){\n    ll res=1;\n    while(y){\n        if(y&1) res=(res*x)%MOD;\n        x=(x*x)%MOD;\n        y>>=1;\n    }\n    return res;\n}\nll C(int n,int m){\n    if(n<m)\n        return 0;\n    return nq[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nint n,k;\nll ans;\nint main(){\n    SF(\"%d\",&n);\n    nq[0]=1;\n    for(int i=1;i<=n;i++)\n        nq[i]=(nq[i-1]*i)%MOD;\n    inv[n]=fsp(nq[n],MOD-2);\n    for(int i=n;i>0;i--)\n        inv[i-1]=(inv[i]*i)%MOD;\n    ll las=0;\n    for(int i=(n+1)/2;i<n;i++){\n        ll num=C(i-1,n-i-1)*nq[i]%MOD*nq[n-i-1]%MOD;\n        ll sum=(num-las+MOD)%MOD;\n        ans=(ans+sum*i%MOD)%MOD;\n        las=num;\n    }\n    PF(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n9999G99X999999999999999X9X999X9X9X9X9X9X999X9X9X99999999G9GX99G9GG9S9M9SS9SHG9G9GGGG999999G99X9X9999999X99999X99999X999X9X999X9X99999999999X999X999X99\n9XX9X9XXX9XXSXSXSSSXSXSXSXSXSSHSHXSXSXXXSXSXSXX9SXX99X522sssrsrrrsr:isirrrrH9SX9XHsss25S2X59SX99999XXXX9XXX9X9S9SXSXSXSSSXSXS9XXSXSXSXX9SXXXSXSXSXSXSS\n9X99999X999X9X9S9X9X9X9X9X9X9X9X9XXSXX9XXX999X9X9SXXXssiiii:i::::,: ,,,,,,:irisrri::i;riss2SXSSSXSGGGG9X9X9X9X9X99999X9X9X9X9X9999999X9X9X9X999X9X9X9S\n9X99X999X999X9X9X9X9X9X9X9X9X9SXXXX9X9X9X99GX222sriii::::i:ii;irrri:,,,,,,,,,,,,,:,:::,:::iirri;i;rs299G99999XH9S999S9X9X9X9XXSXX9X999X9X9X9X9X99999XX\n9S9X999X9X9XXS9X9XXX9XXX9X9X9S9X9X9XXX9X9XXXHsr:::::,,,:::::irrssssr:,:,::,,:,:::::::::::::,:,:,:,,,:isHX9G9XS9X9SXX9XXX9XXSXX9X9X9X9X9X999X9999999X9S\nXX9999X999X9X9X9X9S9X9X9X9SXXXX9X9SXX9X999SSsr:::i:::,,,,,,::;rss2si::,::i:::::::iiii::iii:i:i::::::,,,::;rss5SHXXX9XHX9X9X9X999X9X9X999X9X999X9X9X9XX\n9X9X9X9X9X999X9X9XXX9X9X9X9SXX9X9X9X9X99X9Xr:::ir:, ,,,,,,,:iirsssr:iii:::i:::i:iiiii:i:iiriiii:i::::,,,, ,,:::issSSHSG99X9999999X9999999999999X999X9X\n99X9X999X9X9X9X9999999X9X9X9X9X9X9S9XX99X9s::i;ri:,,,,,,::rssssririiiiiiiiiiiiiiiii;iiii;;iriii;iiii::::,,,:ii::::irsX999999XX99X9X99999X999999999X9X9\n9X999X9X9X9X9X9X99999X9SXX9S9X9X9X9X9XX99s,:rrsrrri::::;ss252ss;iiiiriiiiiiirrrrrir;rirrr;ii;iiiiiii::i:::iissrri::,:is2SH9X9X9X9X9X999X9X99999999999X\n9X99X99999X9X999X999X9X9XX99S9XXX9X9X9X9s::rrsssssrrrsssssrssrirrr;r;;iiiiirrrrrrri;:iirrriirrir;riiii:::::irssrrr;i::,:is2999X9X9X99999X9999999X99999\n9X9999999X99999XXX99999X9X999X9X9X9X99G9s:irss22sssss25siirrrrrir;ri;iii;rrrr;;;rii::iiriiiiiirrri;i;ii:::::rssssrri;i:,,:sSG99X9X9X9X9X999999999X9999\n9XX9X99999XXX9X9S9X999X9X9X9SXS9S9XX9GSs:irsrssSHSH5ssrrrsssrrrrrr;;ii;rrri;iii;ii::ii:;rriiirii;r;;i;iiii:::;ssr;iiiiii:,,r9G99X9X999X9999999X9999999\n9S999X9X9X9X9X9X999X9X9X9X9X9SXSXX9XGXr:irsssssssrrs25S22ssrrrrrrrrrrrr;ririiiri:ii:i:iirii:;iirrrrrr;ririi:iirii::ii:ii;:,:2S99999X9X9X9X9999999X9999\nXXX9X9999999X9X9X9X9X9X9X999XXXXX9X99s:irsssssssr;r2522srr;rirrrirrr;rrrrri;irir:iiriir;ii:::ii;i;rrrrrr;iiiiiir;i:::::iii:,:s255XX9999999999G9G9G9G99\n9S9999G9G9999X9X9X9X9X9X999X9X999X999i:irrsssssr;r22ssrrri;irrrrriii;irrr;rrr;ri;iriiiri::iii:iii:iirrrrrrr;;iiirrr;::iii;i,isHS9X9X9X999999G9G99999G9\n9X99999G99X999X9XXXXX9X999X9X999999Gsi:rrrsss22ssssri;irir;rrririi:r;ririiirirrrirriiriiiriri;iiii;rrrssrrrrrriiirssrrirrri:rSS9XXX9X99G9G99999G9G9GGG\n9S9999999X9X9X9X9S9X9X9XXXXX999X99G92iirrrss2sssrrri;iiirir;;iiiiirirrr;;irirrrrrri;riiir;i:iirir;r;rrrrsssrrri:i:;rssssssr:sSXX99G9GGGGMGMGGGGGMGMMMG\nXX99999G99999999X9X9S9X9X9X99999X99GXrirssssrii::iiiirrrrrrrirrrirrrrrisrr;i;rrrrrrsriirr;ir;rriiiiiiiirrrrsrrrrr;iis222ssriH@M@B@B@B@@@B@B@B@MMMGGG9X\n9S999999G99X9X999X9X9X9X9XXXXX999X99Sirsssr::,::i;rirrrrrrri;rrrrrrirrrirrrr;irrrrrr;;rrrrrrrri;rriii:ii;rrrrrrii:i;s2S22srrMB@B@B@B@B@B@B@BBMMGG999XH\n999999999999X999X9XXSXSXSXS9X9X9S99G9srr;i:::::i:iiiirriiiirirrri;rrrsrrrsrssrrrrrrrrsssrrrrrirr;rrrrriiirrrrrrr;;irrs22ssr9B@B@B@B@BBMBMBBBMBMMGG99XX\n999999G9G9999X9X9X9SXX9X9X9SXX9X9X9X2::::::i;i::::riiirrrrrrrirrrrrrrrrrrrrrsrsrsssrsssrrrsrrrrrrrrrri;i;iiirrrir;r;;isssrrX@BBB@BBMBBBMBMBB@BBMMGG99S\n999G999G9999X9X9S9X9SXSXSXSXX9XXX9X9Hi,:,::i:::::ii;iririri;irrsrrrrrrrsrrrssrssrrrrrsrrssrsrrrri;rrrrrrrri;;rrriiiiiirsr;sMBBM@B@MBMBMBMBMBB@BBMMGG99\n9X9X9X99999X9XXSXS9XXXXSXX9999GGGGGBBi,,::::::::::iii:i;r:iirrrrsrrrsrsrsssssrrrssrrrrsssrrssrrrrrrrrirrrii:::ii;ii:i:;ss;2M@B@BBBBMBMBMBMMMBBBBBMBMMG\n99X9X9999999999G9GGGGGGGGMMBB@B@B@B@M,,,,:::,:,::::iiiiri;;;i;riir;rrsssrss2srssrrsrisrrrsssssrrrrrsrrr;iiii:::i:ii::::i;;S@B@B@BBMBB@MBMBM@MBM@B@@@BM\nMGMGMGMMBMBMBB@B@B@B@B@B@B@B@B@B@B@Si,,,:,,,,,,,:::irrrrrrrrr;rii;rrsssssrssrsrrrssrssrrrrsssrssssrrrrririiiri;ii:::::::,r@B@B@B@BBBBB@@@BBB@B@@@B@B@B\nB@B@B@B@B@B@B@B@B@B@B@B@B@B@@@MGGSi  ,,,,,,,,,,,,::rrsrrrrrri;iiirrs29995srrrs;rsssrssrrrrrrrrrsssssssrrrririiirr;:i:i:: r@@@@B@B@B@B@B@BBMBMBMMMMMMGG\n@B@B@@@B@@@B@B@B@B@B@B@B@G2ri:,,:    ,,,,,,,,,,,:::iirrrsssr;irsss2XG9GGXsss2sss222srrsssr;irrrrsrrrrrrrrrrrrrrrrr;::::, s@B@B@B@MBMMMMMMGMGG9999XX5Hs\nB@@@B@B@B@B@B@BMMBB@B@B@Ss:,        ,,,,,,,,,,,,:::iiii;rsrrrss22222ss2925S999S2S92srrsrr;rri;rsssrrirrsrrrsrrrrii:i::,,i@BBMMMMGMGG99999XSXHS5222ssss\n@BMGGGBB@B@B@MM999GM@B@M2i:,   ,, ,,,,,,,,,,,,,,::::iirsss22ssrrrii:i;2sssssHX9X925ssirrr:iirrrssssrr;rrrrrrrrrrrii::,,:M@BMMGGGG99X9XS5S5H2522s2s2sss\nBM9G9MMBB@B@B@BGX9SX5S2sri,,,,,,,,,, ,,,,,,,,,,,,::i;ss22H2s;irrrssS9SXHsssssH2S22sS2ss2sssss2sssrrsrr;r;rirrrrrrii:,,,5B@MG9G9999X9HX5S222222sssssssr\n@BMGGGMM@B@B@BM92ssii::,,,,,,,,,, ,   ,,,,,,,,,,,::irrrirrr;sXBB@B@B@BBG9SG52s2SS2SSXXXSS52ssssssssssrrrsrrrssrrri:,,,,rSG9XXSS2H2222ssssssrrrr;ri;i;:\nMMG99XX9XX2H22ssri:,,,,,,,,,           ,,,,,,,,,::::::::::,,rMB@B@9G@@BBSGMM2s2HHSs52Xsrrrrss2222SX2s222ssssrrrrr;:::,,,,:rsssrrrriri;iii:::::,:,:::,,\nX5S22ssssrrrriiii::,::i:,,,   ,,,       ,,,,,,:::::,,,,,::,,:2MB@B@B@B@95MM92sSSXH2ss59ss2SGBB@BBB@@M999S2sssssrsri:i::,, ,::::::,:::,:,:,:,,,,,,,,,,,\n22ssssssssrsrrrrrrrs22i,,,,,,,,,,,,,,,,,,,,,,,,,,,,, , ,,::::isMB@@@BM22B@MGXSGM995sr2B@B@9GB@B@B@BM9Ssss222ssri:i::,,,,,,,,,,,,,,,,,,,:,,,,,,,,,,,::,\n9HXSSSXS9X9999GGMB@@X:, , ,,,,,,,,,,,,,,,,,,,,,,,,,,, , ,,,,::ir22SXSHB@@M9MMGM99S2rrsMBBMrr@B@B@B92srrssssrrri,:,,       ,,,,,,,,,,,,:,,,,,,,,,,,,,,,\nBBB@B@B@B@@@B@B@B@Gs   , ,   , , ,,,,:,:,,,,,,,,,,,,,,,,,,,,,,,,:isS992srrii:iir::i;;sS9MMGGB@BG5srrirrri:::,,,,           ,,:,,,,,,,,,,,,,,,:,,,,,,,,\n@B@B@@@B@B@B@B@B9:              , ,,,,::i::,,,,,,,,,,,,,,,,,,,,,,:sri, ,,,,,,:::i:,,:::rSMG55srii;r:ii:,,,,                 ,,,,,,,,,,,,,,,,,,,,,,,,,,\n@@B@B@MBMMMMGM9r                   ,,,:i:iri,,,,,,,:::,:,,,,,,,,::,,,,,,,,,:::,,,,,,,i::,rGSsrii:::::,,,                   ,,,,,,,,,,,,,,,,,,,,,,,,:,,\nG99SS5522s2ssi                      ,,::rrss:,, ,,::i:i,,,:,,:rsrir:,,:,is2SX5sssr:,,,:,,,r92i:,,:i,,                      ,,,:,,,:,:,,,:,,,,,,,,,,,,\nsrrrrrrrrrrr:      ,                 ,,;srs2sssr:,,::iii:i:::rri:i:, ,,:sM9X2s5H2GG2:,,,,,,r25ssss,                        ,,:,,,,,,,,,,,,,,,,,,,,,,,\ni:i:ii;ii:i:                      , ,,,:sss2SS99Hr:,:iri;:::i:,,, ,    ,s9SBBs2s99XMr ,,,,;rs9X9s:,                        ,i,,,,,,,,,,,,,,,,,,,, ,,,\n:::i:i:::::,                       ,,,,:is25HHS9992r:::i:iii,,,,    ,,  :MM@MG9GBM92,  ,,irsssS9i,     ,      ,,       ,  ,;::,,,:,,,, ,,,,,,,,,,, ,,,\n:,:::,::::,                       ,,,,:::r2SSH99MM@MXsi:::i:i:, , ,     ,9@BMMMM@BS,,   ,,irirXM2,        :r:,,,:;:  ,issrsr:,,,,,, ,,,,,,,,, ,,,,,,,\n:,,:,:,,,:,                      ,,,,,:r:rS99GM@@@B@M9sii:,,:i:,,  , , ,isXM@@MBM2,:,, ,,,,,:5M@BBHi,ri,,iX9r:::rMS22GSssr,      ,  ,,,,,,,,,,,,,,,,,,\n:,:,,,:,,,,                     , , ,,iir2BB@BBMGsrrrrsssri:::iii::,::irsssrsssii:,,, ,,,:isGBM9229929S;2GMssir;;rri,,      ,,,  ,,,, ,,, ,,,,,,,,,,,\n:,:,,,,:,:,                    ,  ,,,isSG@BM92sri::irssSSX25HHS9XSH9X22HSG9BG9XXXSssssrrrssr:,     ,                     ,,,,,,,,,,,,,       ,,,,,,,\n,,,,:,,,,,:                 , ,  ,:i5GM9Hr:,,,,,,,,,::::::iisrss2s299XS9G9GGSS92ss2sr,,,,             ,    ,, ,  ,,  ,,,, ,    ,, ,,, ,,,   ,,,,,,  ,\n:,,:,,,,,,:, ,,,       ,:, ,:;sssXss2s:        , ,     ,             ,,                  , , , ,,,,,,, , , ,,, ,,,,,   ,,,  ,, ,,,   ,,, , ,   ,,, ,,,\n, ,,,,:,:,:irsX2srsssrr2S22ssss:ii,       , , , ,,, ,,, ,,    , ,                   , ,,, , , ,,,  ,,,   ,,  ,,,, , ,,,,,,,,, , ,,, ,,,   ,,, ,,,,,,,,\n, ,:,,,,,,,,:i:i;r;r::,,,,,,         ,,,,,,,,,,, ,,,,,  ,,,,  ,, , ,,, ,, ,  , , , ,  ,, ,,,,,,, ,,,,,    ,, ,    ,,,,,,,, , ,,, ,,,,, ,,, ,,,,, ,:,,\n, ,,,,,,,,,,                    , ,,,,,,,,, ,,, ,,,,, ,  ,,, ,,,, ,      ,, , ,,,, ,, , , ,,  ,    ,, , ,  ,,,, ,,,   ,,, ,,, , ,,,   ,,, ,,,,, ,,,,,,\n, ,,,,,,,,,,,,,,,,,, , ,,, ,,,,,,, ,,,  ,, ,, ,, ,,,   ,,,,,  ,, ,   ,,,,, , ,,  ,     ,,    , ,,, ,,,,, ,,, ,,,,,   ,,, ,,,,,,,,, ,,,,,,,,,,, ,,,,,,,\n, ,,,,,,,,,,, , ,,,,,,, ,,, ,,,,,,, ,   ,   ,,,,,,, ,,,,, ,   , ,  ,,   ,       ,   , ,,,,,   , ,   ,,,,,,, ,,,,    ,,  ,,  ,,,,,,, , ,,,,,,,, ,, ,,,\n,  ,,,,,,,,, ,,,,,,,,, ,,, ,,,   ,,,,, ,,, , , , ,,  ,,,    ,, ,, ,,       , , ,,,,, ,,, ,,, ,         , , ,     , , ,  ,, ,,, ,,,,,  ,,,,,,,, ,, ,,,\n, ,,,,,,, ,,,,, ,,, , ,,  ,,, , ,,,,, ,  ,,,,  ,,   , ,,, , ,       ,   , ,     , , , ,   , , , ,,, , , , , ,,, ,,, ,,, ,,,,  ,,,,,,,,,,, ,,,, ,, ,,,\n, ,,,,,,,,,,,,,,,,,,,,,  ,,,,,,, ,,    ,,,   , ,,,,, ,  ,,,, , ,   ,,, ,   , , , ,   , ,,,   ,,,,, , ,,,    ,,,, , ,  ,,,, ,,,,,,,,,,,,, ,,,,,,,,,,,,,\n: ,,,,,,,,,,,,,,,,,,, ,,,,,,,,,,,,,,,,,,,,, ,,,,,,,,,   ,,, ,,,,,,,,, ,,, ,,,,,,, , ,   ,,,,, , ,,, , ,,,,,,, ,,,,, ,,:,:,:,:::i:::i:::::::,::::::,,,,\n, ,,          ,,   ,   ,                                                                                        , , , ,    ,, ,   , ,\n*/\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define LL long long\n#define ll   long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define PB pop_back\n#define p push\n#define P pop\n#define INF 2147483647\n#define ull unsigned long long\n#define vi vector < int >\n#define vpii vector < pii >\n#define pq priority_queue\n#define rep(i,n) for (int (i)=0;(i)<n;(i)++)\n#define End return 0\n#define mi multiset <int>\n#define si set <int>\n#define sll set<ll>\n#define mll multiset<ll>\n#define vll vector <ll>\n#define Rep(i,a,b) for (int (i)=(a);(i)<=(b);(i)++)\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int Maxn=1e6+5;\nconst LL mod=1e9+7;\nLL fact[Maxn];\nLL qp(LL x,LL p){\n\tLL ans=1;\n\twhile (p){\n\t\tif (p & 1){\n\t\t\tans=ans*x%mod;\n\t\t} \n\t\tx=x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn ans;\n} \nLL inv(LL x){\n\treturn qp(x,mod-2);\n}\nLL C(LL x,LL y){\n\tif (x<y) return 0;\n\treturn fact[x]*inv(fact[y])%mod*inv(fact[x-y])%mod;\n}\nLL d[Maxn];\nint main(){\n\tfact[0]=1;\n\tfor (int i=1;i<Maxn;i++){\n\t\tfact[i]=fact[i-1]*(LL)i%mod;\n\t}\n\tint n;\n\tscanf(\"%d\",&n);\n\tLL ans=0;\n\tfor (int i=1;i<=n-1;i++){\n\t\td[i]=C(i-1,n-1-i)*fact[i]%mod*fact[n-i-1]%mod;\n\t\td[i]=(d[i]%mod+mod)%mod; \n\t}\n\tfor (int i=1;i<=n-1;i++){\n\t\tans=ans+(d[i]-d[i-1])*i%mod;\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=(1e6)+10;\nconst ll mod=(1e9)+7;\nint n;\nll jc[maxn],ivjc[maxn],iv[maxn],ans;\nll c(ll a,ll b) {\n\tif (a<b) return 0;\n\tll res=jc[a]*ivjc[b]%mod*ivjc[a-b]%mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tjc[0]=ivjc[0]=1;\n\tfor (int i=1;i<=n;i++) {\n\t\tjc[i]=jc[i-1]*i%mod;\n\t\tiv[i]=(mod-iv[mod%i]*(mod/i)%mod)%mod;\n\t\tif (i==1) iv[1]=1;\n\t\tivjc[i]=ivjc[i-1]*iv[i]%mod;\n\t}\n\tll lst=0;\n\tfor (int s=max(1,n/2-1);s<n;s++) {\n\t\tll tmp=jc[s]*jc[n-s-1]%mod*c(s-1,n-s-1)%mod;\n\t\tans+=(tmp-lst)*s%mod;\n\t\tlst=tmp;\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1e6+10,mod=1e9+7;\nint ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nint fac[maxn],ifac[maxn],f[maxn];\ninline int C(int n,int m){\n\treturn (ll)fac[n]*ifac[n-m]%mod*ifac[m]%mod;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)ifac[i]*i%mod;\n}\ninline void add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint calc(int n,int i){\n\treturn (ll)C(n-2-i,i)*fac[n-1-i]%mod*fac[i]%mod;\n}\nint main(){\n\tint n=read();\n\tinit(n);\n\tint ans=0;\n\tREP(i,0,(n-2)>>1) add(ans,(ll)(calc(n,i)-calc(n,i+1)+mod)*(n-1-i)%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri rd<int>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; --i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++i)\nconst int maxN = 1e6 + 7;\ntypedef long long LL;\nconst LL O = 1e9 + 7;\n\ntemplate<class T> T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return f ? x : -x;\n}\n\nint n;\nLL f[maxN];\nLL fac[maxN], ifac[maxN], iv[maxN];;\n\nLL C(int x, int y) {\n\treturn 0 <= y && y <= x ? fac[x] * ifac[y] % O * ifac[x-y] % O : 0;\n}\n\nint main() {\n\n\tn = ri() - 1;\n\tiv[1] = 1; rep (i, 2, n) iv[i] = iv[O % i] * (O - O / i) % O;\n\tfac[0] = 1; rep (i, 1, n) fac[i] = fac[i-1] * i % O;\n\tifac[0] = 1; rep (i, 1, n) ifac[i] = ifac[i-1] * iv[i] % O;\n\n\trep (i, 1, n) f[i] = C(i-1, n-i);\n\trep (i, 1, n) f[i] = (fac[i] * fac[n-i] % O * f[i]) % O;\n\n\tLL res = 0;\n\trep (i, 1, n) res += (f[i] - f[i-1]) * i % O;\n\tprintf(\"%lld\\n\", (res % O + O) % O);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll mod = 1e9 + 7;\nll fact[1000005];\nll suffix[1000005];\nll cnt[1000005];\nll binpow(ll a, ll b){\n\tif (b == 0) return 1;\n\tll x = binpow(a, b / 2);\n\tx *= x; x %= mod;\n\tif (b % 2) return (x * a) % mod;\n\telse return x;\n}\nll bindiv(ll a, ll b){\n\tll inv = binpow(b, mod - 2);\n\treturn (a * inv) % mod;\n}\nint main(){\n\tfact[0] = 1;\n\tfor (ll i = 1; i < 1000005; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tll n; cin >> n;\n\tll ans = 0;\n\tfor (ll k = 0; k <= (n - 2) / 2; k++){\n\t\tll u = fact[n - k - 1] * fact[n - k - 2]; u %= mod;\n\t\tll d = fact[n - (2 * k) - 2]; suffix[k] = bindiv(u, d);\n\t}\n\tfor (ll k = (n - 2) / 2; k >= 1; k--) cnt[k] = (suffix[k] - suffix[k + 1] + mod) % mod;\n\tfor (ll k = 1; k <= (n - 2) / 2; k++) (ans += (cnt[k] * k)) %= mod;\n\tans = ((n - 1) * fact[n - 1] - ans) % mod; \n\tans += mod; ans %= mod; cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long \n#define MAX_N 500010\n#define MOD 1000000007\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    make();\n    ll n;\n    cin >> n;  \n    vector<ll> a(n);\n    rep(i,n){\n        if(i>=n-1){\n            a[i] = fac[n-1];\n            continue;\n        }\n        a[i] = comb(n-2-i,i)*fac[i]%mod;\n        a[i] *= fac[n-1-i]%mod;\n        a[i] = (fac[n-1]-a[i]+mod)%mod;\n    }\n    for(int i=n-1;i>=1;i--){\n        a[i] += mod-a[i-1];\n        a[i] %= mod;\n    }\n    //rep(i,n)cerr << a[i] << endl;\n    ll sm = 0;\n    rep(i,n){\n        sm += (n-i)*a[i]%mod;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FORE(i, a) for (auto i = a.begin(); i != a.end(); ++i)\n#define REPU(i, a, b) for (int i = (a); i < (b); ++i)\n#define REPD(i, a, b) for (int i = (a); i > (b); --i)\n#define MEM(a, x) memset(a, x, sizeof(a))\n#define ALL(a) a.begin(), a.end()\n#define UNIQUE(a) a.erase(unique(ALL(a)), a.end())\n\nvector<string> split(const string &s, char c) {\n\tvector<string> v; stringstream ss(s); string x;\n\twhile (getline(ss, x, c)) v.push_back(x);\n\treturn v;\n}\n#define DEBUG(args...) { vector<string> _v = split(#args, ','); err(_v.begin(), args); }\nvoid err(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args>\nvoid err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << \"[DEBUG] \" << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << '\\n';\n\terr(++it, args...);\n}\n\ntypedef long long ll;\nconst int MOD = 1000000007;\n\ntemplate<class T, class U> inline T tmin(T a, U b) { return (a < b) ? a : b; }\ntemplate<class T, class U> inline T tmax(T a, U b) { return (a > b) ? a : b; }\ntemplate<class T, class U> inline void amax(T &a, U b) { if (b > a) a = b; }\ntemplate<class T, class U> inline void amin(T &a, U b) { if (b < a) a = b; }\ntemplate<class T> T gcd(T a, T b) { while (b != 0) { T c = a; a = b; b = c % b; } return a; }\n\nconst int N = 1000005;\nll ft[N];\n\nll mod_pow(ll x, ll y, ll p) {\n    ll res = 1;\n    while (y > 0) {\n        if (y & 1) res = res * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return res;\n}\n\ninline ll comb(int n, int k) {\n\tif (k > n || k < 0) return 0;\n\tll ans = mod_pow(ft[n - k] * ft[k] % MOD, MOD - 2, MOD);\n\tans = ans * ft[n] % MOD;\n\treturn ans;\n}\n\nint main(int argc, char *argv[]) {\n\tios_base::sync_with_stdio(false);\n\n\tint n; cin >> n;\n\n\tll ans = 0;\n\n\tvector<ll> dp1(n + 1, 0), dp2(n + 1, 0);\n\tft[0] = 1;\n\tREPU(k, 1, N) {\n\t\tft[k] = k * ft[k - 1] % MOD;\n\t}\n\n\tREPU(k, 1, n) {\n\t\tdp1[k] = (comb(k - 1, n - k - 1) * ft[k] % MOD) * ft[n - 1 - k] % MOD;\n\t}\n\tll acc = 0;\n\tREPU(k, 1, n) {\n\t\tdp2[k] = (dp1[k] - acc) % MOD;\n\t\tans = (ans + k * dp2[k]) % MOD;\n\t\tacc = (acc + dp2[k]) % MOD;\n\t}\n\tif (ans < 0) ans += MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\ntemplate <ll mod>\nstruct modular {\n    ll value;\n    modular(ll x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n    modular& operator+=(modular other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(modular other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(modular other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(modular other) {\n        ll a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            ll t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    modular& operator^=(modular other) {\n        ll r = 1, x = value, n = other.value;\n        while (n > 0) {\n            if (n & 1) r = r * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n        }\n        value = r;\n        return *this;\n    }\n    modular operator+(modular rhs) {\n        return modular(*this) += rhs;\n    }\n    modular operator-(modular rhs) {\n        return modular(*this) -= rhs;\n    }\n    modular operator*(modular rhs) {\n        return modular(*this) *= rhs;\n    }\n    modular operator/(modular rhs) {\n        return modular(*this) /= rhs;\n    }\n    modular operator^(modular rhs) {\n        return modular(*this) ^= rhs;\n    }\n    bool operator==(modular rhs) {\n        return value == rhs.value;\n    };\n    bool operator!=(modular rhs) {\n        return value != rhs.value;\n    };\n    bool operator<(modular rhs) {\n        return value < rhs.value;\n    }\n};\ntemplate <ll mod>\nstring to_string(modular<mod> x) {\n    return to_string(x.value);\n}\ntemplate <ll mod>\nostream& operator<<(ostream& stream, modular<mod> x) {\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream << x.value;\n}\ntemplate <ll mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\nconst ll mod = 1e9 + 7;\nusing mint = modular<mod>;\n\nvector<mint> fac, finv;\ninline void cinit(int n) {\n    fac.resize(n, 1);\n    finv.resize(n, 1);\n    for (int i = 2; i < n; i++) {\n        fac[i] = fac[i - 1] * i;\n        finv[i] = finv[i - 1] / i;\n    }\n}\ninline mint C(int n, int k) {\n    if (n < k || k < 0 || n < 0) return 0;\n    return fac[n] * finv[k] * finv[n - k];\n}\ninline mint H(int n, int k) {\n    return C(n + k - 1, k);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    cinit(n + 1);\n    mint ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans += fac[i] * fac[n - 1 - i] * C(i - 1, n - i - 1);\n    }\n    cout << fac[n] - ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define MAXN 1000010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll fac[MAXN], invfac[MAXN], ans;\nint N;\ninline ll fpow(const ll& x, ll c)\n{\n\tregister ll res = 1, t = x;\n\twhile (c)\n\t{\n\t\tif (c & 1) res = res * t % MOD;\n\t\tt = t * t % MOD;\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\ninline ll C(const int& n, const int& m)\n{\n\tif (n < m) return 0;\n\treturn fac[n] * invfac[m] % MOD * invfac[n - m] % MOD;\n}\ninline ll W(const int& k)\n{\n\tint x = N - 2 - k;\n\tint y = k - x;\n\tif (x < 0 || y < 0) return 0;\n\treturn fac[k] * invfac[y] % MOD * invfac[x] % MOD;\n}\nint main()\n{\n\tscanf(\"%d\", &N);\n\tif (N == 2)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = invfac[0] = 1;\n\tfor (register int i = 1; i <= N; ++i)\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\tinvfac[N] = fpow(fac[N], MOD - 2);\n\tfor (register int i = N - 1; i >= 1; --i)\n\t\tinvfac[i] = invfac[i + 1] * (i + 1) % MOD;\n\tans += fac[N - 1];\n\tfor (register int i = 1; i < N - 1; ++i)\n\t\tans += (C(N - 2, i) + C(N - 2, i - 1) + MOD - W(i - 1))* fac[i] % MOD * fac[N - 1 - i] % MOD, ans %= MOD;\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int MAXN = 1000005;\n\nlong long modpow(long long a, long long p){\n\tif(p == 0)return 1;\n\tif(p % 2 == 1)return a * modpow(a, p - 1) % MOD;\n\t\n\tlong long r = modpow(a, p / 2);\n\treturn r * r % MOD;\n}\nlong long modinv(long long a){\n\treturn modpow(a, MOD - 2);\n}\n\nlong long fact[MAXN], invfact[MAXN];\nlong long C(int n, int r){\n\treturn fact[n] * invfact[r] % MOD * invfact[n - r] % MOD;\n}\n\nint n;\n\nint main(){\n\tscanf(\"%d\", &n);\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tif(i == 0)fact[i] = 1;\n\t\telse fact[i] = i * fact[i - 1] % MOD;\n\t}\n\tfor(int i = n; i >= 0; i--){\n\t\tif(i == n)invfact[i] = modinv(fact[i]);\n\t\telse invfact[i] = (i + 1) * invfact[i + 1] % MOD;\n\t}\n\t\n\tlong long res = fact[n - 1];\n\tfor(int i = 1; i < n - 1; i++){\n\t\tif(2 * i <= n - 1){\n\t\t\tres = (res + fact[n - 1]) % MOD;\n\t\t}else{\n\t\t\tres = (res + fact[i] * fact[n - 1 - i] % MOD * (C(n - 1, i) - C(i - 1, n - 1 - i) + MOD)) % MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <int MOD> struct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tModInt(signed long long sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = (unsigned long long)x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tif (u < 0)\n\t\t\tu += MOD;\n\t\tModInt res;\n\t\tres.x = (unsigned)u;\n\t\treturn res;\n\t}\n};\ntemplate <int MOD> ostream &operator<<(ostream &os, const ModInt<MOD> &m) {\n\treturn os << m.x;\n}\ntemplate <int MOD> istream &operator>>(istream &is, ModInt<MOD> &m) {\n\tsigned long long s;\n\tis >> s;\n\tm = ModInt<MOD>(s);\n\treturn is;\n};\n// pow(mint(2), 1000) のように\ntemplate <int MOD> ModInt<MOD> pow(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tr *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\n\n//#define int long long を使っても大丈夫\nusing mint = ModInt<1000000007>;\n\n// nCrで用いる\nvector<mint> fact, factinv;\n// nCrで用いる 予め計算しておく\nvoid nCr_compute_factinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1);\n\tfactinv.resize(N + 1);\n\tfact[0] = 1;\n\trep(i, 1, N + 1) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor (int i = N; i >= 1; i--)\n\t\tfactinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif (n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) *\n\t\tnCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nmint nHr(int n, int r) { return r == 0 ? 1 : nCr(n + r - 1, r); }\n\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N; cin >> N;\n\tif (N == 2) {\n\t\tcout << 1 << endl;\n\t}\n\telse if (N == 3) {\n\t\tcout << 4 << endl;\n\t}\n\telse {\n\t\tnCr_compute_factinv(N + 10);\n\t\tmint ans = 0;\n\t\tmint sum = 0;\n\t\tmint prev = 0;\n\t\trep(k, 2, N) {\n\t\t\tint re = N - 1 - k;\n\t\t\tif (k - 1 >= re) {\n\t\t\t\tmint x = nCr(k - 1, re)*fact[k] * fact[re];\n\t\t\t\tans += (x - prev) * k;\n\t\t\t\tprev = x;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2000100;\nconst int M=1e9+7;\nint fac[N],n,ans,inv[N],f[N];\nint fp(int x,int y){\n\tint ret=1;\n\tfor (; y; y>>=1,x=(long long)x*x%M) if (y&1) ret=(long long)ret*x%M;\n\treturn ret;\n}\nint c(int x,int y){\n\tif (x>y) return 0;\n\treturn (long long)fac[y]*inv[x]%M*inv[y-x]%M;\n}\nint calcg(int deep,int x){\n\treturn c(x,deep-x+1);\n}\nint main(){\n\tfac[0]=1; for (int i=1; i<=2000000; ++i) fac[i]=(long long)fac[i-1]*i%M;\n\tinv[2000000]=fp(fac[2000000],M-2); for (int i=1999999; i>=0; --i) inv[i]=(long long)inv[i+1]*(i+1)%M;\n\tscanf(\"%d\",&n);\n\tif (n==2) return puts(\"1\"),0;\n\tfor (int i=1; i<n; ++i){\n\t\tf[i]=(long long)calcg(n-1,n-1-i)*fac[n-1-i]%M*fac[i]%M;\n\t\t// cerr<<f[i]<<endl;\n\t\t(ans+=(long long)((f[i]-f[i-1]+M)%M)*(i+1)%M)%=M;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N;\nll fact[1010101];\nll mo=1000000007;\n\nll combi(ll N_, ll C_) {\n\tconst int NUM_=1400001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfact[0]=1;\n\tfor(i=1;i<=1010000;i++) fact[i]=fact[i-1]*i%mo;\n\tN--;\n\t\n\tll tot=fact[N]*N%mo;\n\tll pr=0;\n\tfor(i=N-1;i>=1;i--) {\n\t\tll pat=combi(N-1-i,i);\n\t\tif(pat==0) continue;\n\t\ttot-=pat*fact[N-i]%mo*fact[i]%mo%mo;\n\t}\n\t\n\tcout<<(tot%mo+mo)%mo<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 1000001, md = 1000000007;\n\nlong long f[MX], inv[MX], f_inv[MX];\n\nint main() {\n\tf[0] = f[1] = inv[1] = f_inv[0] = f_inv[1] = 1;\n\tfor (int i = 2; i < MX; i++) {\n\t\tf[i] = f[i - 1] * i % md;\n\t\tinv[i] = md - (md / i) * inv[md % i] % md;\n\t\tf_inv[i] = f_inv[i - 1] * inv[i] % md;\n\t}\n\t\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\t\n\tif (n == 2) {\n\t\tprintf(\"%d\\n\", 1);\n\t\treturn 0;\n\t}\n\t\n\tint ans = 0, sum = 0;\n\tfor (int k = 2; k < n; k++) {\n\t\tif (n - 1 - k > k - 1) continue;\n\t\t\n\t\tint x = f[k - 1] * f[k] % md * f_inv[2 * k - n] % md;\n\t\tans = (ans + (x - sum + md) * (long long)(k)) % md;\n\t\tsum = x;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nll ans;\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[2000005],R[2000005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<2000005;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<2000005;i++) R[i] = modpow(F[i],mod-2);\n}\nll C(int a,int b){\n    if(a<0 || b<0 || a<b) return 0;\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\nint main(){\n\tcin>>n; make();\n\tfor(int k=0;k<=n-1;k++){\n\t\tll beg = C(n-1,k);\n\t\tbeg = beg+mod-C(k-1,n-k-1);\n\t\tbeg %= mod;\n\t\tbeg = beg*F[k]%mod*F[n-1-k]%mod;\n\t\tans += beg;\n\t}\n\tcout<<ans%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; } // これを使うならば、tieとかを消して！！\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile(b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b; std::swap(a, b);\n\t\t\tu -= t * v; std::swap(u, v);\n\t\t}\n\t\tif(u < 0) u += Mod;\n\t\tModInt res; res.x = (unsigned)u;\n\t\treturn res;\n\t}\n\n\tbool operator==(ModInt that) const { return x == that.x; }\n\tbool operator!=(ModInt that) const { return x != that.x; }\n\tModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile(k) {\n\t\tif(k & 1) r *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\ntypedef ModInt<1000000007> mint;\ntypedef vector<mint> vmint;\nostream &operator<<(ostream &o, const mint v) {  o << v.x; return o; }\n\n// n!と1/n!のテーブルを作る。\n// nCrを高速に計算するためのもの。\n//\n// O(n + log mo)\nvector<mint> fact, rfact;\nvoid constructFactorial(const long long n) {\n    fact.resize(n);\n    rfact.resize(n);\n    fact[0] = rfact[0] = 1;\n    for (int i = 0; i < n - 1; i++) {\n        fact[i+1] = fact[i] * (i+1);\n    }\n    rfact[n-1] = mint(1) / fact[n-1]; \n    for (int i = n - 1; i >= 1; i--) \n        rfact[i-1] = rfact[i] * i; // ((n-1)!)^-1 = (n!)^-1 * n\n}\n\n// O(1)\n// constructFactorialしておけば、n, r=1e7くらいまではいけます\nmint nCr(const long long n, const long long r) {\n    if (n < 0 || r < 0) return 0;\n    if (n < r) return 0;\n    return fact[n] * rfact[r] * rfact[n-r];\n}\n\n// O(r.size())\n// sum(r)! / r[0]! / r[1]! / ...\nmint nCr(const vector<long long> r) {\n    ll sum = accumulate(r.begin(), r.end(), 0ll);\n    mint ret = fact[sum];\n    rep(i, r.size()) \n        ret *= rfact[r[i]];\n    return ret;\n}\n\n// O(k log mo) \nmint nCrWithoutConstruction(const long long n, const long long k) {\n    if (n < 0) return 0;\n    if (k < 0) return 0;\n    mint ret = 1;\n    for (int i = 0; i < k; i++) {\n        ret *= (mint)n - (mint)i;\n        ret /= mint(i+1);\n    }\n    return ret;\n}\n\n\n\n\n\n\n// Matrix\n\n\n// 行列xベクトル\nvector<mint> mul(vector<vector<mint>> A, vector<mint> x) {\n    assert(A.size() >= 0); assert(A[0].size() == x.size());\n    vector<mint> b(A.size());\n    rep(i, A.size()) {\n        rep(j, A[0].size()) {\n            b[i] += A[i][j] * x[j];\n        }\n    }\n    return b;\n}\n// 行列x行列\nvector<vector<mint>> mul(vector<vector<mint>> A, vector<vector<mint>> B) {\n    assert(A[0].size() == B.size());\n    vector<vector<mint>> C(A.size(), vector<mint>(B[0].size()));\n    rep(i, A.size()) rep(j, B[0].size()) {\n        rep(h, A[0].size()) {\n            C[i][j] += A[i][h] * B[h][j];\n        }\n    }\n    return C;\n}\n// ベクトル+ベクトル\nvector<mint> plu(vector<mint> x, vector<mint> y) {\n    assert(x.size() == y.size());\n    rep(i, x.size()) {\n        y[i] += x[i];\n    }\n    return y;\n}\n// 行列+行列\nvector<vector<mint>> plu(vector<vector<mint>> A, vector<vector<mint>> B) {\n    assert(A.size() == B.size());\n    assert(A[0].size() == B[0].size());\n    rep(i, A.size()) rep(j, A[0].size()) {\n        B[i][j] += A[i][j];\n    }\n    return B;\n}\n\n\nvector<vector<mint>> transpose(vector<vector<mint>> A) {\n    rep(i, A.size()) repi(j, i+1, A.size()) swap(A[i][j], A[j][i]);\n    return A;\n}\nmint dot(vector<mint> x, vector<mint> y) {\n    mint ret = 0;\n    rep(i, x.size())\n        ret += x[i] * y[i];\n    return ret;\n}\nvector<mint> pow(vector<vector<mint>> A, vector<mint> x, long long k) {\n    vector<vector<vector<mint>>> Ak; // Ak[i] = A^{2^i}\n\n    Ak.push_back(A);\n    rep(i, 70) \n        Ak.push_back(mul(Ak[i], Ak[i]));\n    ll cyc = 0;\n    while (k) {\n        if (k & 1)\n            x = mul(Ak[cyc], x);\n        k /= 2;\n        cyc++;\n    }\n    return x;\n}\n\n\n\n\n// Black box liner algebra\nstruct RandomModInt {\n    default_random_engine re;\n    uniform_int_distribution<int> dist;\n#ifndef _DEBUG\n    RandomModInt() : re(random_device{}()), dist(1, mint::Mod - 1) { }\n#else\n    RandomModInt() : re(), dist(1, mint::Mod - 1) { }\n#endif\n    mint operator()() {\n        mint r;\n        r.x = dist(re);\n        return r;\n    }\n} randomModInt;\n\nvoid randomModIntVector(vector<mint> &v) {\n    int n = (int)v.size();\n    for(int i = 0; i < n; ++ i)\n        v[i] = randomModInt();\n}\n\n\n// GF(mo)列sから、それを生成する最小線形漸化式Cを復元する\n//\n// 入力: 漸化式が生成したGF(mo)列s\n// 出力: d項間漸化式の係数C (size = d+1)\n// 漸化式\n//      C_0 s_{n} + C_1 s_{n-1} + ... + C_{L} s{n-L} = 0\n// がsを生成した時、Cを求める。\n//\n// O(n^2)\n//\n// 例:\n// s = [1, 2, 4, 8] -> C = [1, 1000000005(-2)] (s[1] - 2 * s[0] = 0)\n// s = [1, 1, 1, 1] -> C = [1, 1000000006(-1)] (s[1] - s[0] = 0)\nint berlekampMassey(const vector<mint> &s, vector<mint> &C) {\n    int N = (int)s.size();\n    C.assign(N + 1, mint());\n    vector<mint> B(N + 1, mint());\n    C[0] = B[0] = 1;\n    int degB = 0;\n    vector<mint> T;\n    int L = 0, m = 1;\n    mint b = 1;\n    for(int n = 0; n < N; ++ n) {\n        mint d = s[n];\n        for(int i = 1; i <= L; ++ i)\n            d += C[i] * s[n - i];\n        if(d == mint()) {\n            ++ m;\n        } else {\n            if(2 * L <= n)\n                T.assign(C.begin(), C.begin() + (L + 1));\n            mint coeff = -d * b.inverse();\n            for(int i = -1; i <= degB; ++ i)\n                C[m + i] += coeff * B[i];\n            if(2 * L <= n) {\n                L = n + 1 - L;\n                B.swap(T);\n                degB = (int)B.size() - 1;\n                b = d;\n                m = 1;\n            } else {\n                ++ m;\n            }\n        }\n    }\n    C.resize(L + 1);\n    return L;\n}\n\n// GF(mo)列aから、それを生成する最小線形漸化式\\phiを復元する\n// berlekampMasseyとの違いは、係数の順序が違うのと安全用のassertチェックがあること。\n//\n// 入力: 漸化式が生成したGF(mo)列a\n// 出力: d項間漸化式の係数\\phi (size = d+1)\n// 漸化式\n//      \\phi_0 a_{i} + \\phi_1 a_{1} + ... + \\phi_L a_L = 0\n// がaを生成した時、\\phiを求める。\n//\n// O(n^2)\n//\n// 例:\n// s = [1, 2, 4, 8] -> C = [1000000005(-2), 1] (s[1] - 2 * s[0] = 0)\n// s = [1, 1, 1, 1] -> C = [1000000006(-1), 1] (s[1] - s[0] = 0)\nvoid computeMinimumPolynomialForLinearlyRecurrentSequence(const vector<mint> &a, vector<mint> &phi) {\n    assert(a.size() % 2 == 0);\n    int L = berlekampMassey(a, phi);\n    reverse(phi.begin(), phi.begin() + (L + 1));\n}\n\n// 漸化式\n//      \\phi_0 a_0 + \\phi_1 a_1 + ... + \\phi_L a_L = 0\n// と、initValues = a[0:phi.size()-1]が与えられる。\n// この時、a[k]をinitValues(=a[0:phi.size()-1])の線形結合の係数を返す。\n//     a[k] = coeff[0] * initValues[0] + coeff[1] * initValues[1] + ...  + coeff[d-1] * initValues[d-1] \n//\n// O(n^2 log k)\nvoid linearlyRecurrentSequenceCoeffs(long long k, const vector<mint> &phi_in, vector<mint> &coeffs) {\n\tint d = (int)phi_in.size() - 1;\n\tassert(d >= 0);\n\tassert(phi_in[d].get() == 1);\n\n    coeffs = vector<mint>(d);\n\tvector<mint> square;\n\tcoeffs[0] = 1;\n\tint l = 0;\n\twhile ((k >> l) > 1) ++l;\n\tfor (; l >= 0; --l) {\n\t\tsquare.assign(d * 2 - 1, mint());\n        rep(i, d) rep(j, d) square[i + j] += coeffs[i] * coeffs[j];\n\t\tfor (int i = d * 2 - 2; i >= d; -- i) {\n\t\t\tmint c = square[i];\n\t\t\tif (c.x == 0) continue;\n            rep(j, d) square[i - d + j] -= c * phi_in[j];\n\t\t}\n        rep(i, d)\n\t\t\tcoeffs[i] = square[i];\n\t\tif (k >> l & 1) {\n\t\t\tmint lc = coeffs[d - 1];\n\t\t\tfor(int i = d - 1; i >= 1; -- i)\n\t\t\t\tcoeffs[i] = coeffs[i - 1] - lc * phi_in[i];\n\t\t\tcoeffs[0] = mint() - lc * phi_in[0];\n\t\t}\n\t}\n}\n\n// 漸化式\n//      \\phi_0 a_{i} + \\phi_1 a_{1} + ... + \\phi_L a_L = 0\n// と、initValues = a[0:phi.size()-1]が与えられる。\n// この時、\n//      a_{k}を求める\n//\n// O(n^2 log k)\n// \n// また、副産物として、a[k]をinitVectorの線形結合として表す係数coeffが得られる\n// a[k] = coeff[0] * initValues[0] + coeff[1] * initValues[1] + ...  + coeff[d-1] * initValues[d-1] \n// \nmint linearlyRecurrentSequenceValue(long long k, const vector<mint> &initValues, const vector<mint> &phi) {\n    int d = phi.size() - 1;\n\tif(d == 0) return mint();\n\tassert(d <= (int)initValues.size());\n    assert(k >= 0);\n\n    if(k < (int)initValues.size())\n        return initValues[(int)k];\n\n    vector<mint> coeffs;\n    linearlyRecurrentSequenceCoeffs(k, phi, coeffs);\n\n\tmint res; rep(i, d) res += coeffs[i] * initValues[i];\n\treturn res;\n}\n\n// 線形漸化的数列aのk番目は？\n// O(n^2 log k)\nmint reconstruct(long long k, vector<mint> a) {\n    if (a.size() % 2) a.pop_back();\n    vector<mint> a_first_half;\n    rep(i, a.size() / 2)\n        a_first_half.push_back(a[i]);\n    vector<mint> phi;\n    computeMinimumPolynomialForLinearlyRecurrentSequence(a, phi);\n    return linearlyRecurrentSequenceValue(k, a_first_half, phi);\n}\n\n\n// GF(mod)の行列演算\n// thisが表す行列はAとする。\n//\n// この行列演算は、「掛け算の実装のみを要求する」。\n// 合計で、O(n^2 + n^2 log k + n T(n))\nclass matrixData {\npublic:\n    int n;\n    matrixData(int n_arg) { n = n_arg; }\n    int size(void) { return n; }\n\n    // 行列Aとベクトルvec_inの掛け算して、vec_outを返す。\n    // vec_outはこの関数で確保される。\n    // \n    // O(M(n)) : 密行列でO(n^2), コンパニオンでO(n), w要素疎行列でO(w)\n    virtual void productMatrixByVector(vmint& vec_out, const vmint& vec_in) = 0;\n\n    // 行列Aとベクトルdiag_inの掛け算して、副作用でAを更新する\n    // この関数は最小多項式を特性多項式に一致させるためのものなので、diag_inの掛け算方向は問わない\n    // \n    // O(w) : w要素疎行列でO(w)\n    virtual void productDiagByMatrix(const vmint& diag_in) = 0;\n\n    // Black Box Linear Algebraを使って、最小多項式の係数を乱択計算する\n    // 乱択だがほぼ100%一致するので、答えが合っているかのチェックする必要なし\n    // 出力はthis->phiに格納される。\n    // \n    // O(n^2 + n T(n)), T(n)は行列とベクトルの掛け算\n    void computeMinimumPolynomialUsingBlackBoxLinearAlgebra(vmint& phi_out) {\n        vector<mint> dp(n * 2), u(n), v(n);\n        randomModIntVector(u); randomModIntVector(v);\n        vector<mint> Aiv = v; // i = 0\n\n        // 2n個のdp[i]=u^t A^i vを列挙\n        vector<mint> Aiv_next;\n        rep(i, n * 2) {\n            rep(j, n) dp[i] += u[j] * Aiv[j];\n            productMatrixByVector(Aiv_next, Aiv);\n            Aiv = Aiv_next;\n        }\n\n        // dpが線形漸化的で、その係数が行列の最小多項式phi_outに高確率に一致する\n        computeMinimumPolynomialForLinearlyRecurrentSequence(dp, phi_out);\n    }\n\n    // A^k vec_inを、vec_outを返す。\n    // vec_outはこの関数で確保される。\n    // \n    // O(n^2 log k)\n    void computeMatrixPowerByVector(vmint &res_out, const vmint &v_in, const long long k) {\n        res_out.assign(n, mint());\n\n        // 最小多項式を得る\n        vmint phi; computeMinimumPolynomialUsingBlackBoxLinearAlgebra(phi);\n\n        // A^k = \\Sigma A^i coeffs[i]となるcoeffsを得る。\n        vector<mint> coeffs; linearlyRecurrentSequenceCoeffs(k, phi, coeffs);\n\n        // A^k v_inを具体的に計算\n        vmint vec = v_in, vec_next;\n        rep(i, phi.size() - 1) {\n            rep(j, n) res_out[j] += coeffs[i] * vec[j];\n            productMatrixByVector(vec_next, vec);\n            vec = vec_next;\n        }\n    }\n\n    // ベクトルbを入力として、A x = bなるxを返す。\n    // xこの関数で確保される。\n    // \n    // O(n T(n)), T(n)は行列とベクトルの掛け算\n    void solve(vmint &x, const vmint &b) {\n        x.assign(n, mint());\n\n        // 最小多項式を得る\n        vmint phi; computeMinimumPolynomialUsingBlackBoxLinearAlgebra(phi);\n\n        // x = -1/phi[0]*(phi[1]*b+phi[2]*A*b+...+phi[d]*A^{d-1}*b)\n        // なのでそれを愚直に計算\n        vmint Aib = b;\n        repi(i, 1, phi.size()) {\n            rep(j, n) x[j] += phi[i] * Aib[j];\n            vmint Aib_next;\n            productMatrixByVector(Aib_next, Aib);\n            Aib = Aib_next;\n        }\n        rep(j, n) x[j] /= -phi[0];\n    }\n\n    // det(A)を高確率に求める\n    // \n    // det(A) = (-1)^n char(A)(0)なので、まず特性方程式char(A)を求める。\n    // Black Box Linear Algebraで求めるのは最小多項式だが、\n    // ランダムな対角行列をかけると、最小多項式と特性方程式が高確率で一致する。\n    // 特性多項式というのは、要するにケイリーハミルトンの係数のことである。\n    // \n    // 乱択だがほぼ100%一致するので、答えが合っているかのチェックする必要なし\n    ///\n    // O(n^2 + n T(n)), T(n)は行列とベクトルの掛け算\n    mint det(void) {\n        // ランダム対角行列DをAにかける\n        vmint D(n); randomModIntVector(D); productDiagByMatrix(D);\n\n        // 最小多項式phi(AD)を得る。\n        // ランダム対角行列Dをかけたので、これは高確率で特性多項式char(AD)でもある。\n        vmint Dphi; computeMinimumPolynomialUsingBlackBoxLinearAlgebra(Dphi);\n\n        // det(AD) = det(DA) = (-1)^n * char(AD)(0) = det(A) * \\Pi D[i]\n        // なので、det(A) = (-1)^n * char(AD)(0) / (\\Pi D[i])\n        mint ret = Dphi[0] * (n % 2 ? -1 : 1); rep(i, n) ret /= D[i];\n\n        // productDiagByMatrixは副作用で変更するので、行列を戻しとく\n        rep(i, n) D[i] = mint(1) / D[i];\n        productDiagByMatrix(D);\n\n        return ret;\n    }\n\n    virtual ~matrixData() {}\n};\n\n// yukicoder旨味の相乗効果用。O(n)\nclass myMatrixData : public matrixData {\npublic:\n    vmint data; // 行列のデータ。データのアラインメントはユーザに任せる。\n    myMatrixData(int n_arg, vmint &data_arg) : matrixData(n_arg) {\n        data = data_arg; \n    }\n    // O(n)\n    virtual void productMatrixByVector(vmint& vec_out, const vmint& vec_in) {\n        vec_out.resize(n);\n        vec_out[0] = vec_in[0] * data[0];\n        rep(i, n-1) \n            vec_out[i+1] = vec_out[i] + vec_in[i+1] * data[i+1];\n    }\n    // O(n), 対角行列は右からかける\n    virtual void productDiagByMatrix(const vmint& diag_in) {\n        rep(i, n) data[i] *= diag_in[i];\n    }\n\n    virtual ~myMatrixData() {}\n};\n\n\n/*\n   テンプレート\n*/\nclass templateMatrixData : public matrixData {\npublic:\n    vmint data; // 行列のデータ。データのアラインメントはユーザに任せる。\n    templateMatrixData(int n_arg, vmint &data_arg) : matrixData(n_arg) {\n        data = data_arg; \n    }\n    virtual void productMatrixByVector(vmint& vec_out, const vmint& vec_in) {\n        cerr << \"productMatrixByVector not implemented.\" << endl; exit(1); \n    }\n    virtual void productDiagByMatrix(const vmint& diag_in) {\n        cerr << \"productDiagByMatrix not implemented.\" << endl; exit(1); \n    }\n\n    virtual ~templateMatrixData() {}\n};\n\nll solve(ll n) {\n    vll a(n-1);\n    rep(i,n-1)a[i]=i;\n    ll ret = 0;\n    do{\n        vector<bool> u(n);\n        vll tmp;\n        rep(i,n-1) {\n            u[a[i]]=u[a[i]+1]=1;\n            tmp.pb(a[i]);\n            ll c =0;\n            rep(j,n)c+=u[j];\n            if (c == n) {\n                cout << tmp << \" \"<< i+1 << endl;\n                ret += i+1;\n                break;\n            }\n        }\n\n    }while(next_permutation(all(a)));\n    return  ret%mo;\n}\n\nint main(void) {\n    ll n; cin >> n;\n    constructFactorial(2e6);\n    vector<mint> f(n);\n    rep(k, n) {\n        f[k] = nCr(k-1,n-k-1)*fact[k]*fact[n-1-k];\n    }\n    mint ret = 0;\n    repi(k,1,n) {\n        ret += (f[k] - f[k-1]) * mint(k);\n    }\n    cout << ret << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2000000;\nconst int mod = 1e9 + 7;\n\nint step[maxn], inv_step[maxn];\n\nint power(int x, int times) {\n\tint rt = 1, base = x;\n\twhile (times) {\n\t\tif (times & 1) rt = (long long)rt * base % mod;\n\t\tbase = (long long)base * base % mod;\n\t\ttimes >>= 1;\n\t}\n\treturn rt;\n}\n\nint C(int a, int b) {\n\tif (b < 0 || b > a) return 0;\n\treturn (long long)step[a] * inv_step[b] % mod * inv_step[a - b] % mod;\n}\n\nint f[maxn];\n\nint main() {\n\tstep[0] = 1;\n\tfor (int i = 1; i < maxn; i++) step[i] = (long long)step[i - 1] * i % mod;\n\tfor (int i = 0; i < maxn; i++) inv_step[i] = power(step[i], mod - 2);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tn--;\n\tfor (int i = 1; i <= n; i++) f[i] = C(i - 1, n - i);\n\n\n\t//for (int i = n; i >= 1; i--) f[i] = (f[i] - (long long)f[i - 1] * (n - (i - 1))) % mod;\n//\tfor (int i = 1; i <= n; i++) cout << f[i] << endl;\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans = (ans + (long long)f[i] % mod * step[i] % mod * step[n - i]) % mod;\n//\t\tcout << ans << endl;\n\t}\n\n\tans = ((long long)step[n] * (n + 1) - ans) % mod;\n\tcout << (ans + mod) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=1e9+7;\nint lt[2000050],tlt[2000050],n,ans,cnt;\nint binpow(int a,int b){\n\tif(b==0) return 1;\n\tif(b==1) return a%mod;\n\tint mid=binpow(a,b/2);\n\tif(b%2==0) return mid*mid%mod;\n\telse return mid*mid%mod*a%mod;\n}\nint c(int n,int k){\n\tif(n<k) return 0;\n\telse{\n\t\tint tmp=lt[n];\n\t\ttmp*=tlt[k];\n\t\ttmp%=mod;\n\t\ttmp*=tlt[n-k];\n\t\ttmp%=mod;\n\t\treturn tmp;\n\t}\n}\nsigned main(){\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tlt[0]=1;\n\tfor(int i=0;i<2000004;i++){\n\t\tif(i) lt[i]=lt[i-1]*i%mod;\n\t}\n\tcin>>n;\n\ttlt[n] = binpow(lt[n],mod-2);\n\tfor(int i=n;i>=1;i--) tlt[i-1]=(tlt[i]*i)%mod;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tint tmp=((c(i-1,n-i-1)%mod*lt[i]%mod*lt[n-i-1]%mod)%mod-cnt+mod*mod)%mod;\n\t\tans+=tmp*i;\n\t\tans%=mod;\n\t\tcnt+=tmp;\n\t\tcnt%=mod;\n\t}\n\tcout<<ans;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n\n\n#define INF 4000000000000000000LL\n#define MOD 1000000007\n#define ALL(x) std::begin(x), std::end(x)\n\n\nlong long modpow(long long x, long long y)\n{\n  long long p = 1;\n\n  for ( ; y; (x *= x) %= MOD, y >>= 1)\n    if (y & 1)\n      (p *= x) %= MOD;\n\n  return p;\n}\n\nclass modint_t {\n  friend std::ostream& operator<<(std::ostream& ofs, const modint_t a);\n\npublic:\n  modint_t(long long xx = 0) : x(xx % MOD) {};\n\npublic:\n  bool operator==(long long a) const {\n    return x == a;\n  };\n\npublic:\n  long long value() const {\n    return x;\n  };\n\npublic:\n  modint_t operator+(const modint_t& a) const {\n    return (x + a.x) % MOD;\n  };\n\n  modint_t operator-(const modint_t& a) const {\n    return (x - a.x) % MOD;\n  };\n\n  modint_t operator*(const modint_t& a) const {\n    return x * a.x % MOD;\n  };\n\n  modint_t operator/(const modint_t& a) const {\n    return (*this) * a.inverse();\n  };\n\n  // Note that operator^'s priority is quite low in C++...\n  modint_t operator^(long long i) const {\n    return modint_t(modpow(x, i));\n  };\n\npublic:\n  modint_t& operator+=(const modint_t& a) {\n    (x += a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator-=(const modint_t& a) {\n    (x -= a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator*=(const modint_t& a) {\n    (x *= a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator/=(const modint_t& a) {\t// Not tested\n    (x *= a.inverse().x) %= MOD;\n\n    return *this;\n  };\n\npublic:\n  modint_t inverse() const {\n    assert(x % MOD);\n\n    return modint_t(modpow(x, MOD - 2));\n  };\n\npublic:\n  modint_t normalized() const {\n    return modint_t(x % MOD + MOD);\n  };\n\nprivate:\n  long long x;\n};\n\nmodint_t operator-(long long a, const modint_t& b)\n{\n  return modint_t(a) - b;\n}\n\nmodint_t operator*(long long a, const modint_t& b)\n{\n  return modint_t(a) * b;\n}\n\nmodint_t operator/(long long a, const modint_t& b)\n{\n  return modint_t(a) / b;\n}\n\nstd::ostream& operator<<(std::ostream& ofs, const modint_t a)\n{\n  ofs << a.x;\n\n  return ofs;\n}\n\n\nmodint_t memo[1111111], memo2[1111111];\n\n\nint main(int argc, char** argv)\n{\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n\n  std::cout << std::fixed << std::setprecision(6);\n  std::cerr << std::fixed << std::setprecision(6);\n\n  memo[0] = memo[1] = 1;\n  \n  for (int i = 2; i < 1111111; i ++)\n    memo[i] = memo[i - 1] * i;\n\n  memo2[0] = memo2[1] = 1;\n\n  for (int i = 2; i < 1111111; i ++)\n    memo2[i] = memo2[i - 1] / i;\n\n  int N;\n  \n  std::cin >> N;\n\n  if (N == 2) {\n    std::cout << 1 << std::endl;\n\n    return 0;\n  }\n  else if (N == 3) {\n    std::cout << 4 << std::endl;\n\n    return 0;\n  }\n  else if (N == 4) {\n    std::cout << 16 << std::endl;\n\n    return 0;\n  }\n\n  modint_t C = 0, c = 0;\n\n  for (int K = (N + 1) / 2; K < N; K ++) {\n    modint_t k = K - 1, l = (N - 2) - k, m = k - l;\n    \n    modint_t cc = memo[(l + m).value()] * memo2[l.value()] * memo2[m.value()] * memo[K] * memo[N - 1 - K];\n\n    C += (cc - c) * K;\n\n    c = cc;\n  }\n\n  std::cout << C.normalized() << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nlong long P = 1000000007;\n\nclass C {\npublic:\n  int n;\n  vector<long long> fac, inv, facInv;\n  long long power(long long e, long long x) {\n    if (x == 0)\n      return 1;\n    if (x == 1)\n      return e;\n    if (x % 2 == 0)\n      return power((e * e) % P, x / 2);\n    return (e * power(e, x - 1)) % P;\n  }\n  C(int n_) {\n    n = n_;\n    fac.resize(n + 1);\n    inv.resize(n + 1);\n    facInv.resize(n + 1);\n    fac[0] = 1;\n    fac[1] = 1;\n    for (int i = 2; i <= n; i++)\n      fac[i] = (i * fac[i - 1]) % P;\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      inv[i] = power(i, P - 2);\n    facInv[0] = 1;\n    facInv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      facInv[i] = (inv[i] * facInv[i - 1]) % P;\n  }\n  long long comb(int N, int K) {\n    if (N == 0 || K == 0 || K == N)\n      return 1;\n    if (N < K || K < 0 || N < 0)\n      return 0;\n    return ((fac[N] * facInv[K]) % P * facInv[N - K]) % P;\n  }\n};\n\nlong long mul(long long a, long long b) { return (a * b) % P; }\n\nlong long add(long long a, long long b) { return (a + b) % P; }\n\nint main() {\n  int n;\n  cin >> n;\n  C c(2000001);\n  if (n == 2) {\n    cout << 1 << endl;\n  } else if (n == 3) {\n    cout << 2 << endl;\n  } else {\n    long long ans = 0;\n    vector<long long> dp(2000001);\n    dp[0] = dp[1] = 0;\n    for (int i = 2; i < n; i++) {\n      dp[i] = mul(c.comb(i - 1, n - 1 - i), mul(c.fac[i], c.fac[n - i - 1]));\n    }\n    for (int i = 1; i < n; i++) {\n      ans = add(ans, mul(i, (dp[i] - dp[i - 1] + P) % P));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\nstruct S\n{\n    int x,y,z;\n\n    bool operator<(const S &a)const{\n              return x<a.x;\n    }\n};\n\nvector<int> v;\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nlong long l[1114000];\n\nlong long o[1114211];\nint j[2];\nint dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z;\n\nP u[555320];\n//stack<int> s;\n\n//set<int> s;\nqueue<int> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<int,int> p;\n//list<int> l;\n//string r1,r;\n//char r[1152][1111];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y>b.y;\n}\n\nlong long f(int a)\n{\n    if(a<0) return 0;\n    else\n    return o[a];\n}\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b>>1);\n    x*=x,x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nlong long g(int a,int b)\n{\n    if(b<a) return 0;\n    return f(b)*(p(f(a),mod-2)*p(f(b-a),mod-2)%mod)%mod;\n}\n\n\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    o[0]=1;\n    for(int t=1;t<=a;t++)\n        o[t]=o[t-1]*t%mod;\n    //l[0]=1;\n    //for(int t=1;t<=a;t++)\n     //   l[t]=p(o[t],mod-2);\n    for(int t=2;t<a;t++)\n    {\n        y=x;\n        x=f(a-t-1)*f(t)%mod*g(a-t-1,t-1)%mod;\n        z+=(x-y+mod)%mod*t%mod;\n        z%=mod;\n        //printf(\"##%lld\\n\",x);\n        //printf(\"%lld %lld %lld\\n\",f(a-t-1),f(t),g(a-t-1,t-1));\n    }\n    printf(\"%lld\",z);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#define for1(i,l,r) for(int i=(l);i<(r);i++)\n#define for2(i,l,r) for(int i=(l);i>(r);i--)\n#define int long long\nusing namespace std;\nconst int mod=1e9+7;\nint lt[2000005],tlt[2000005],n,ans,cnt;\nint binpow(int a,int b){\n\tif(b==0) return 1;\n\tif(b==1) return a;\n\tint mid=binpow(a,b/2);\n\tif(b%2==0) return mid*mid%mod;\n\telse return mid*mid%mod*a%mod;\n}\nint c(int n,int k){\n\tint tmp=lt[n];\n\ttmp*=tlt[k];\n\ttmp%=mod;\n\ttmp*=tlt[n-k];\n\ttmp%=mod;\n\tif(n>=k) return tmp;\n\telse return 0;\n}\nsigned main(){\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tlt[0]=1;\n\tfor(int i=0;i<2000004;i++){\n\t\tif(i) lt[i]=lt[i-1]*i%mod;\n\t\ttlt[i]=binpow(lt[i],mod-2);\n\t}\n\tcin>>n;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tint tmp=(c(i-1,n-i-1)*lt[i]%mod*lt[n-i-1]%mod-cnt%mod)%mod;\n\t\ttmp%=mod;\n\t\tans+=tmp*i;\n\t\tans%=mod;\n\t\tcnt+=tmp;\n\t\tcnt%=mod;\n\t}\n\tcout<<ans;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst long long mod = 1000000007;\nlong long inv[1001001] = { 0,1 }, fact[1001001] = { 1,1 }, ifact[1001001] = { 1,1,1 };\n\nint main()\n{\n\tfor (int i = 2; i < 1001001; i++) {\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tifact[i] = ifact[i - 1] * inv[i] % mod;\n\t}\n\n\tint N; scanf(\"%d\", &N);\n\tlong long ans = N * fact[N-1] % mod;\n\tfor (int p = 1; p < N; p++) {\n\t\tint u = 2 * p;\n\t\tif (u < N) continue;\n\t\tint h = N-1-p;\n\t\tif (h > p - 1) continue;\n\t\tlong long v = fact[p] * fact[p - 1] % mod * ifact[p - 1 - h] % mod;\n\t\tans = (ans + mod -  v) % mod;\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long \nusing namespace std;\nconst int MAXN = 1e6 + 10, INF = 1e9 + 7, mod = 1000000007;\ntemplate<typename A, typename B> inline void chmax(A &x, B y) {\n\tx = x > y ? x : y;\n}\ntemplate<typename A, typename B> inline void chmin(A &x, B y) {\n\tx = x < y ? x : y;\n}\ntemplate<typename A, typename B> inline int mul(A x, B y) {\n\treturn 1ll * x * y % mod;\n}\ntemplate<typename A, typename B> inline void add2(A &x, B y) {\n\tif(x + y < 0) x = x + y + mod;\n\telse x = (x + y >= mod ? x + y - mod : x + y);\n}\ntemplate<typename A, typename B> inline int add(A x, B y) {\n\tif(x + y < 0) return x + y + mod;\n\telse return x + y >= mod ? x + y - mod : x + y;\n}\ntemplate<typename A, typename B> inline int fp(A a, B p) {\n\tint base = 1;\n\twhile(p) {\n\t\tif(p & 1) base = mul(base, a);\n\t\ta = mul(a, a); p >>= 1;\n\t}\n\treturn base;\n}\ninline int read() {\n\tchar c = getchar(); int x = 0, f = 1;\n\twhile(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * f;\n}\nint N, fac[MAXN], ifac[MAXN], f[MAXN];\nint C(int N, int M) {\n\tif(M > N) return 0;\n\treturn mul(fac[N], mul(ifac[M], ifac[N - M]));\n}\nint main() {\n\tN = read(); fac[0] = 1;\n\tfor(int i = 1; i <= N; i++) fac[i] = mul(i, fac[i - 1]);\n\tifac[N] = fp(fac[N], mod - 2);\n\tfor(int i = N; i >= 1; i--) ifac[i - 1] = mul(ifac[i], i);\n\tint down = N / 2 + (N & 1);\n\tfor(int i = down; i < N; i++) \n\t\tf[i] = mul(mul(C(i - 1, N - i - 1), fac[i]), fac[N - i - 1]);\n\tint ans = 0;\n\tfor(int i = down; i < N; i++) add2(ans, mul(i, add(f[i], -f[i - 1])));\n\tcout << ans;\n\treturn 0;\n}\n/*\n3\n0 1 1\n5 7 3\n*/"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-4-28 22:56:15\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nconst int MAX_SIZE = 1000010;\nconst long long MOD = 1000000007;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init() {\n  inv[1] = 1;\n  for (int i=2; i<MAX_SIZE; i++) {\n    inv[i] = ((MOD - inv[MOD%i]) * (MOD/i))%MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i=1; i<MAX_SIZE; i++) {\n    fact[i] = (i * fact[i-1])%MOD;\n    factinv[i] = (inv[i] * factinv[i-1])%MOD;\n  }\n}\n\nlong long C(int n, int k) {\n  if (n >=0 && k >= 0 && n-k >= 0) {\n    return ((fact[n] * factinv[k])%MOD * factinv[n-k])%MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n) {\n  if (n == 0) {\n    return 1;\n  } else if (n%2 == 1) {\n    return (x * power(x, n-1)) % MOD;\n  } else {\n    long long half = power(x, n/2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcm(long long a, long long b) {\n  if (a < b) {\n    return gcm(b, a);\n  }\n  if (b == 0) return a;\n  return gcm(b, a%b);\n}\n\nll N;\nll Ika[200010];\n\nint main()\n{\n  init();\n  cin >> N;\n  Ika[0] = Ika[1] = 0;\n  if (N == 2)\n  {\n    cout << 1 << endl;\n    return 0;\n  }\n  for (auto A = 2; A <= N - 1; A++)\n  {\n    ll x = N - 1 - A;\n    if (x >= 0 && A >= 0)\n    {\n      Ika[A] = (((C(A - 1, N - 1 - A) * fact[x]) % MOD) * fact[A]) % MOD;\n      if (N < 100)\n      {\n        cerr << \"Ika[\" << A << \"] = \" << Ika[A] << endl;\n      }\n    }\n  }\n  ll ans = 0;\n  for (ll A = 1; A <= N - 1; A++)\n  {\n    ans += (A * ((Ika[A] + MOD - Ika[A - 1]) % MOD)) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\n#define NDEBUG\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return ((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\n\n\n/**\n * http://xoshiro.di.unimi.it/xoshiro128starstar.c\n * http://xoshiro.di.unimi.it/xoshiro256starstar.c\n * http://xoshiro.di.unimi.it/splitmix64.c\n */\nclass xoshiro\n{\npublic:\n    using result_type = uint32_t;\n    static constexpr result_type min() { return std::numeric_limits<result_type>::min(); }\n    static constexpr result_type max() { return std::numeric_limits<result_type>::max(); }\n    xoshiro() : xoshiro(std::random_device{}()) {}\n    xoshiro(uint64_t seed)\n    {\n        uint64_t z = 0;\n        for (int i = 0; i < 4; i++) { z = (seed += 0x9e3779b97f4a7c15), z = (z ^ (z >> 33)) * 0x62A9D9ED799705F5, z = (z ^ (z >> 28)) * 0xCB24D0A5C88C35B3, s[i] = static_cast<result_type>(z >> 32); }\n    }\n    result_type operator()()\n    {\n        const result_type result = rotl(s[1] * 5, 7) * 9, t = s[1] << 9;\n        return s[2] ^= s[0], s[3] ^= s[1], s[1] ^= s[2], s[0] ^= s[3], s[2] ^= t, s[3] = rotl(s[3], 11), result;\n    }\n    void discard(const usize rep)\n    {\n        for (usize i = 0; i < rep; i++) { (*this)(); }\n    }\n\nprivate:\n    result_type s[4];\n    static result_type rotl(const result_type x, const int k) { return (x << k) | (x >> (32 - k)); }\n};\nclass xoshiro_64\n{\npublic:\n    using result_type = uint64_t;\n    static constexpr result_type min() { return std::numeric_limits<result_type>::min(); }\n    static constexpr result_type max() { return std::numeric_limits<result_type>::max(); }\n    xoshiro_64() : xoshiro_64(std::random_device{}()) {}\n    xoshiro_64(uint64_t seed)\n    {\n        uint64_t z = 0;\n        for (int i = 0; i < 4; i++) { z = (seed += 0x9e3779b97f4a7c15), z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9, z = (z ^ (z >> 27)) * 0x94d049bb133111eb, s[i] = static_cast<result_type>(z ^ (z >> 31)); }\n    }\n    result_type operator()()\n    {\n        const result_type result = rotl(s[1] * 5, 7) * 9, t = s[1] << 17;\n        return s[2] ^= s[0], s[3] ^= s[1], s[1] ^= s[2], s[0] ^= s[3], s[2] ^= t, s[3] = rotl(s[3], 45), result;\n    }\n    void discard(const usize rep)\n    {\n        for (usize i = 0; i < rep; i++) { (*this)(); }\n    }\n\nprivate:\n    result_type s[4];\n    static result_type rotl(const result_type x, const int k) { return (x << k) | (x >> (64 - k)); }\n};\ntemplate<typename Rng>\nclass rng_base\n{\npublic:\n    using rng_type    = Rng;\n    using result_type = typename rng_type::result_type;\n    static constexpr result_type min() { return rng_type::min(); }\n    static constexpr result_type max() { return rng_type::max(); }\n    rng_base() : rng_base(std::random_device{}()) {}\n    rng_base(const u64 seed) : rng(seed) {}\n    ~rng_base() = default;\n    result_type operator()() { return rng(); }\n    template<typename Int>\n    Int uniform_int(const Int max)\n    {\n        static_assert(std::is_integral<Int>::value, \"Integer type is needed.\");\n        if (ispow2(max + 1)) { return static_cast<Int>(rng() & max); }\n        const result_type mask = static_cast<result_type>(ceil2(static_cast<u64>(max + 1))) - 1;\n        while (true) {\n            const Int ans = static_cast<Int>(rng() & mask);\n            if (ans <= max) { return ans; }\n        }\n    }\n    template<typename Int> Int uniform_int(const Int min, const Int max) { return min + uniform_int(static_cast<Int>(max - min)); }\n    bool uniform_bool() { return uniform_int<bool>(0, 1); }\n    template<typename Real>\n    Real uniform_real()\n    {\n        static_assert(std::is_floating_point<Real>::value, \"FloatingPoint type is needed.\");\n        return static_cast<Real>(uniformInt(~static_cast<result_type>(0)) / static_cast<Real>(~static_cast<result_type>(0)));\n    }\n    template<typename Real> Real uniform_real(const Real min, const Real max) { return assert(min <= max), uniform_real<Real>() * (max - min) + min; }\n    template<typename Int> std::pair<Int, Int> uniform_int_pair(const Int min, const Int max) { return std::minmax(uniform_int(min, max), uniform_int(min, max)); }\n    template<typename Int>\n    std::vector<Int> uniform_int_vec(const std::size_t size, const Int min, const Int max)\n    {\n        std::vector<Int> v(size);\n        for (std::size_t i = 0; i < size; i++) { v[i] = uniformInt(min, max); }\n        return v;\n    }\n    template<typename Real>\n    std::vector<Real> uniform_real_vec(const std::size_t size, const Real min, const Real max)\n    {\n        std::vector<Real> v(size);\n        for (std::size_t i = 0; i < size; i++) { v[i] = uniformReal(min, max); }\n        return v;\n    }\n    void discard(const usize rep) { rng.discard(rep); }\n\nprivate:\n    Rng rng;\n};\nusing rng_mt        = rng_base<std::mt19937>;\nusing rng_mt64      = rng_base<std::mt19937_64>;\nusing rng_xoshiro   = rng_base<xoshiro>;\nusing rng_xoshiro64 = rng_base<xoshiro_64>;\nrng_mt g_rng_mt;\nrng_mt64 g_rng_mt64;\nrng_xoshiro g_rng_xo;\nrng_xoshiro64 g_rng_xo64;\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T>\nstd::vector<T> read_vec(const std::size_t size)\n{\n    std::vector<T> v(size);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\n#define SHOW(...) static_cast<void>(0)\ntemplate<typename T>\nstd::vector<T> make_v(const std::size_t size, T v) { return std::vector<T>(size, v); }\ntemplate<class... Args>\nauto make_v(const std::size_t size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\n\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n\nprivate:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const modint_base& x) { return modint_base{inverse(static_cast<ll>(x.v), static_cast<ll>(mod()))}; }\n\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\ntemplate<uint mod_value, bool dynamic = false>\nclass modcomb_base\n{\npublic:\n    using value_type = modint_base<mod_value, dynamic>;\n    modcomb_base()   = delete;\n    static void set_mod(const uint mod) { value_type::set_mod(mod), inv_ref() = {1, 1}, fact_ref() = {1, 1}, inv_fact_ref() = {1, 1}; }\n    static value_type inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[value_type::mod() % i] * (value_type::mod() / i)); }\n        return in.back();\n    }\n    static value_type fact(const usize n)\n    {\n        auto& f = fact_ref();\n        if (n < f.size()) { return f[n]; }\n        for (usize i = f.size(); i <= n; i++) { f.push_back(f.back() * i); }\n        return f.back();\n    }\n    static value_type inv_fact(const usize n)\n    {\n        auto& invf = inv_fact_ref();\n        if (n < invf.size()) { return invf[n]; }\n        for (usize i = invf.size(); i <= n; i++) { invf.push_back(invf.back() * inv(i)); }\n        return invf.back();\n    }\n    static value_type perm(const usize n, const usize k) { return k > n ? value_type{0} : fact(n) * inv_fact(n - k); }\n    static value_type comb(const usize n, const usize k) { return k > n ? value_type{0} : fact(n) * inv_fact(n - k) * inv_fact(k); }\n\nprivate:\n    static std::vector<value_type>& inv_ref()\n    {\n        static std::vector<value_type> in{1, 1};\n        return in;\n    }\n    static std::vector<value_type>& fact_ref()\n    {\n        static std::vector<value_type> f{1, 1};\n        return f;\n    }\n    static std::vector<value_type>& inv_fact_ref()\n    {\n        static std::vector<value_type> invf{1, 1};\n        return invf;\n    }\n};\ntemplate<uint mod>\nusing modcomb = modcomb_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modcomb = modcomb_base<id, true>;\nint main()\n{\n    using mint   = modint<mod>;\n    using mod    = modcomb<1000000007>;\n    const auto n = read<int>();\n    std::vector<mint> ok(n, 0);\n    for (int k = 1; k <= n - 1; k++) { ok[k] = mod::comb(k - 1, n - k - 1) * mod::fact(n - k - 1) * mod::fact(k); }\n    mint ans = 0;\n    for (int k = n - 1; k >= 1; k--) { ok[k] -= ok[k - 1]; }\n    for (int k = 0; k <= n - 1; k++) { ans += k * ok[k]; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1e9 + 7;\nconst int MX = 1e6;\nint n;\nint a[MX + 10], fac[MX + 10] = {1}, inv[MX + 10] = {1};\nint modpow(int a, long long n, int mod = MOD) {\n\tint r = 1, b = a;\n\twhile(n > 0) {\n\t\tif(n & 1) r = 1ll * r * b % mod;\n\t\tb = 1ll * b * b % mod;\n\t\tn >>= 1;\n\t}\n\treturn r;\n}\nint nCr(int n, int r) {\n\tif(r < 0 || r > n) return 0;\n\treturn 1ll * fac[n] * inv[r] % MOD * inv[n-r] % MOD;\n}\nint main() {\n\tfor(int i=1; i<=MX; i++) {\n\t\tfac[i] = 1ll * fac[i-1] * i % MOD;\n\t\tinv[i] = modpow(fac[i], MOD - 2);\n\t}\n\tscanf(\"%d\", &n);\n\tll res = 0;\n\tfor(int i=(n+1)/2; i<=n-1; i++) {\n\t\ta[i] = 1ll * nCr(i-1, n-1-i) * fac[i] % MOD * fac[n-1-i] % MOD;\n\t\tres = (res + 1ll * (a[i] - a[i-1] + MOD) % MOD * i % MOD) % MOD;\n\t}\n\tprintf(\"%lld\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 1000010\nll inv[N],fact[N],invfact[N];\nvoid Pre(){\n    inv[1]=fact[0]=invfact[0]=1;\n    for(int i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfact[i]=fact[i-1]*i%mod;\n\tinvfact[i]=invfact[i-1]*inv[i]%mod;\n    }\n}\nll C(ll n,ll k){\n    if(n<0||k<0||n<k)return 0;\n    return fact[n]*invfact[n-k]%mod*invfact[k]%mod;\n}\nint main(){\n    Pre();\n    ll n;cin>>n;n--;\n    ll ans=0,bef=0;\n    for(ll k=1;k<=n;k++){\n\tll cur=C(k-1,n-k)*fact[k]%mod*fact[n-k]%mod;\n\tans+=(mod+cur-bef)*k;ans%=mod,bef=cur;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1000001;\nconst int MOD = 1000000007;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main() {\n    COMinit();\n    int N; cin >> N;\n    long long ans = 0;\n    long long prev = 0;\n    for (int K = N / 2; K < N; K++) {\n        long long cnt = COM(K-1, N-1-K) * fac[K] % MOD * fac[N-1-K] % MOD;\n        ans = (ans + (cnt - prev + MOD) * K) % MOD;\n        prev = cnt;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1000000007, MAXN = 1000 * 1000 + 100;\n\nint ans[MAXN], fact[MAXN], inv[MAXN];\n\nvoid PreWorks();\nint power(int a, int b);\nint chose(int k, int n);\n\nint main() {\n\tPreWorks();\n\tint n;\n\tll all = 0;\n\tcin >> n;\n\tfor (int i = 0; i <= n; i++)\n\t\tans[i] = (ll)chose(n - i - 1, i - 1) * fact[i] % MOD * fact[n - i - 1] % MOD;\n\tfor (int i = 1; i < n; i++) {\n\t\tall += (ll)(ans[i] - ans[i - 1]) * i % MOD;\n\t\t//cerr << ans[i] << ' ';\n\t\tall %= MOD;\n\t}\n\t//cerr << endl;\n\tcout << all % MOD;\n}\n\nint power(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\tint t = power(a, b / 2);\n\treturn b % 2? (ll)t * t % MOD * a % MOD: (ll)t * t % MOD;\n} \n\nvoid PreWorks() {\n\tfact[0] = 1;\n\tinv[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\tinv[i] = power(fact[i], MOD - 2);\n\t}\n}\n\nint chose(int k, int n) {\n\tif(k >= 0 && n >= k) return (ll)fact[n] * inv[n - k] % MOD * inv[k] % MOD;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << x << endl;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nll n;\nll mod = 1000000007;\nll rui[1234567];\nconst int NUM_ = 1234567;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\nint main(){\n    cin >> n;\n    inv[1]=fact[0]=factr[0]=1;\n    for (int i=2;i<=NUM_;++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n    for (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mod, factr[i]=factr[i-1]*inv[i]%mod;\n    ll ans = 0;\n    for(ll i = n-1; i>=(n+1)/2; i--){\n        rui[i] = fact[i];\n        ll k = n-1-i;\n        rui[i] = (rui[i]*fact[i-1]%mod)*factr[i-1-k]%mod;\n    }\n    for(ll i = (n+1)/2; i<n;i++){\n        ans += i*(rui[i]-rui[i-1]+mod);\n        ans%=mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n\nint mod = 1e9 + 7;\n\n// mod_power.cc\nll po(ll k, ll x) {\n  if (x == 0) {\n    return 1;\n  }\n  if (x == 1) {\n    return k % mod;\n  }\n  ll y = po(k, x/2);\n  y = y * y % mod;\n  if (x % 2 == 1) {\n    y = y * k % mod;\n  }\n  return y;\n}\n\nvll factorial;\nvll inv_fact;\nll comb(ll x, ll y) {\n  if (x < 0 || x < y) {\n    return 0;\n  }\n  y = min(y, x-y);\n  if (y == 0) {\n    return 1;\n  }\n  ll ret = 1;\n  ret = ret * factorial[x] % mod;\n  ret = ret * inv_fact[y] % mod;\n  ret = ret * inv_fact[x-y] % mod;\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  if (n <= 3) {\n    int ans = 0;\n    if (n == 2) {\n      ans = 1;\n    } else if (n == 3) {\n      ans = 4;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n  }\n\n  factorial.assign(n+1, 0);\n  inv_fact.assign(n+1, 0);\n  factorial[0] = 1;\n  inv_fact[0] = 1;\n  rep (i, n) {\n    factorial[i+1] = factorial[i] * (i+1) % mod;\n    inv_fact[i+1] = po(factorial[i+1], mod-2) % mod;\n  }\n  ll ans = 0;\n  ll sum = 0;\n  FOR (i, 2, n) {\n    ll cnt = 1;\n    cnt = cnt * comb(i-1, n-1-i) % mod;\n    cnt = cnt * factorial[i] % mod;\n    cnt = cnt * factorial[n-1-i] % mod;\n    ll add = (cnt + mod - sum) * i % mod;\n    sum = (sum + cnt) % mod;\n    ans = (ans + add) % mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int mod = 1e9+7, maxn = 1e5+5;\n\nint fac[maxn], revfac[maxn];\nint n;\ninline int fastpow(int a, int p){\n\tint ans = 1;\n\twhile(p){\n\t\tif(p&1) ans = (ans*a)%mod;\n\t\tp >>= 1;\n\t\ta = (a*a)%mod;\n\t}\n\treturn ans;\n}\ninline int rev(int a){return fastpow(a, mod-2);}\nvoid init(){\n\trevfac[0]=fac[0] = 1; \n\tfor(int i = 1; i <= n; i++){\n\t\tfac[i] = fac[i-1]*i%mod;\n\t\trevfac[i] = rev(fac[i]);\n//\t\tcout<<fac[i]<<' '<<revfac[i]<<endl;\n\t}\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*revfac[m]%mod*revfac[n-m]%mod;\n}\n\nvoid work(){\n\tint ans = 0, comb = 0, prev = 0;\n\tfor(int k = (n+1)/2; k < n; k++){\n\t\tprev = comb;\n\t\tcomb = C(k - 1, n - k - 1)%mod*fac[k]%mod*fac[n-k-1]%mod;\n\t\tans += (comb - prev+ mod)%mod *k%mod;\n//\t\tcout<<comb<<endl;\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tcin>>n;\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n/// --- modulo Library {{{ ///\nconstexpr ll extgcd(ll a, ll b, ll& x, ll& y) {\n  if(b==0) {\n    x = 1; y = 0;\n    return a;\n  }\n  ll d = extgcd(b, a % b, y, x);\n  y -= (a / b) * x;\n  return d;\n}\nconstexpr ll modpow(ll a, ll b, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll r = 1;\n  while(b){\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\nconstexpr ll modinv(ll a, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll x = 0, y = 0;\n  extgcd(a, mod, x, y);\n  return (x % mod + mod) % mod;\n}\ntemplate<int N, int mod = int(1e9 + 7)> struct Factorial {\n  int arr[N+1], inv[N+1];\n  int operator[](int i) const { return arr[i]; }\n  constexpr Factorial(): arr(), inv() {\n    arr[0] = 1;\n    for(int i = 1; i <= N; i++) {\n      arr[i] = (ll) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N], mod);\n    for(int i = N-1; i >= 0; i--) {\n      inv[i] = (ll) (i + 1) * inv[i + 1] % mod;\n    }\n  }\n  int C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    return (((ll) arr[n] * inv[r]) % mod * inv[n - r]) % mod;\n  }\n};\n/// }}}--- ///\n\nconstexpr int N = 2e5;\nconstexpr Factorial<N> fact;\n\nll mod = 1e9 + 7;\n\n// これは天才\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n; cin >> n;\n  if(n == 2) return (cout << 1 << endl, 0);\n  ll ans = 0;\n  ll prev = 0;\n  for(int k = 1; k <= n - 1; k++) {\n    ll patterns = fact.C(k - 1, n - 1 - k);\n    patterns = (patterns * fact[k]) % mod;\n    patterns = (patterns * fact[n - 1 - k]) % mod;\n\n    // ここでpatternsは k \"以下\" の場合を数えている.\n    // つまりこれは数え上げテクニックとして,\n    // a_k - a_(k-1)\n    // などで just k回目 の値を数えられる.\n\n    ans = (((ans + (patterns - prev) * k)) % mod + mod) % mod;\n    prev = patterns;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 1000050\n#define F first\n#define S second\n#define M 1000000007\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\nll f[maxn],n,fc[maxn],fi[maxn],ans,s;\nll dp[105][105];\n\nll pow_(ll x,ll y){ll rt=1; while (y){if (y&1) rt=rt*x%M; x=x*x%M; y/=2;} return rt;}\n\nll c(ll x,ll y){if (x<y) return 0; else return fc[x]*fi[y]%M*fi[x-y]%M;}\n\nint main()\n{\n    cin >> n;\n    fc[0]=fc[1]=1; for (int i=2;i<=n;i++) fc[i]=fc[i-1]*i%M;\n    fi[0]=fi[1]=1; for (int i=2;i<=n;i++) fi[i]=pow_(fc[i],M-2);\n    ans=(n-1)*fc[n-1]%M;\n    n--;\n    for (int i=n/2+1;i<n;i++)\n    {\n        (s+=c(i-1,n-i)*fc[i]%M*fc[n-i]%M)%=M;\n        //cout << i << ' ' << s << endl;\n    }\n    ans=(ans-s+M)%M;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"]\"; return os; }\n\n\n// import here\n\nconst LL MOD = 1000000007;\n\nLL mod_pow(LL v, LL n){\n    if(n <= 0) return 1;\n    LL res = mod_pow(v, n/2);\n    res = res * res % MOD;\n    if(n & 1) res = res * v % MOD;\n    return res;\n}\n\nvector<LL> mod_factorial(LL n){\n    vector<LL> res(n);\n    res[0] = 1;\n    for(LL i = 1; i <= n; ++i){\n        res[i] = res[i-1] * i % MOD;\n    }\n    return res;\n}\n\nLL permutation(LL n, LL m, vector<LL>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    LL res = factorial[n];\n    res = res * mod_pow(factorial[m-1], MOD-2) % MOD;\n    return res;\n}\n\nLL combination(LL n, LL m, vector<LL>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    LL res = permutation(n, m, factorial);\n    res = res * mod_pow(factorial[m], MOD-2) % MOD;\n    return res;\n}\n\nint main(){\n    LL n;\n    cin >> n;\n    if(n == 2){\n        cout << 1 << endl;\n        return 0;\n    }\n    if(n == 3){\n        cout << 4 << endl;\n        return 0;\n    }\n    vector<LL> factorial = mod_factorial(n+1);\n    vector<LL> equal_or_less(n+1);\n    for(LL k = 0; k < n; ++k){\n        LL part1 = factorial[k] * factorial[n-1-k] % MOD;\n        LL part2 = combination(k-1, n-1-k, factorial);\n        equal_or_less[k] = part1 * part2 % MOD;\n    }\n    LL ans = 0;\n    for(LL k = (n+1)/2; k+1 <= n; ++k){\n        assert(k-1 >= n-k-1);\n        LL part1 = (equal_or_less[k] - equal_or_less[k-1] + MOD) % MOD;\n        LL part2 = part1 * k % MOD;\n        ans = (ans + part2) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 1e6 + 7, MOD = 1000 * 1000 * 1000 + 7;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nint n, t[N], f[N];\nint C(int n, int k) { \n    if (n < k) return 0;\n    return dv(f[n], mod(f[k] * f[n - k])); \n}\nint get(int k) { return mod(C(k - 1, n - 1 - k) * mod(f[k] * f[n - 1 - k])); }   \nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    f[0] = 1;\n    for (int i = 1; i < N; ++i) f[i] = mod(f[i - 1] * i);\n    cin >> n;\n    if (n <= 2) {\n        cout << \"1\\n\";\n        exit(0);\n    }   \n    int p = 0, ans = 0;\n    for (int i = 1; i < n; ++i) {\n        t[i] = mod(get(i) - p);\n        p = mod(p + t[i]);\n        ans = mod(ans + t[i] * i);\n    }   \n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.141592653897932384626\n//freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\nusing namespace std;\n#define M 1000000007LL\nlong long k[1000006];\ninline long long qm(long long a,long long x)\n{\n    long long s,c;\n    s=1;\n    c=a;\n    while(x){\n        if(x&1)s=(s*c)%M;\n        c=(c*c)%M;\n        x>>=1;\n    }\n    return s;\n}\nint main()\n{\n    long long n;\n    cin>>n;\n    k[0]=1;\n    for(long long i=1;i<1000001LL;++i){k[i]=(k[i-1]*i)%M;}\n    long long x=(n+1)/2,y;\n    long long s=0,s1=0;\n    for(;x<n;++x){\n        y=(k[x-1]*qm(k[x*2-n],M-2)%M*qm(k[n-x-1],M-2)%M*k[x]%M-s1+M)%M;\n        s1=(s1+y)%M;\n        s=(s+y*x%M)%M;\n        //cout<<x<<' '<<y<<' '<<s1<<' '<<s<<endl;\n    }\n    printf(\"%lld\\n\",s);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static AlgStruct id_add(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static AlgStruct id_mul(Args... args) { return Operators::IdMul(args...); }\n\n    AlgStruct operator+() const { return *this; }\n    AlgStruct operator-() const { return Operators::Opposite(x); }\n    AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    AlgStruct power(LL n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& value){ s << value.x; return s; }\n\n\ntemplate<LL mod>\nstruct GaloisFieldOperators {\n    static LL Add(LL lhs, LL rhs) { return (lhs + rhs) % mod; };\n    static LL Mul(LL lhs, LL rhs) { return (lhs * rhs) % mod; };\n    static LL IdAdd() { return 0; };\n    static LL IdMul() { return 1; };\n    static LL Opposite(LL value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(LL lhs, LL rhs) { return lhs < rhs; };\n    static LL Power(LL value, LL n) {\n        LL res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static LL Reciprocal(LL value) { return Power(value, mod-2); }\n};\n\nconst LL MOD = 1e9+7;\n\nusing GaloisField = AlgStruct<LL, GaloisFieldOperators<MOD>>;\n\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring::id_mul();\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\n\nsigned main()\n{\n    LL n; cin >> n;\n\n    Fact<GaloisField> fact(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * fact[k] * fact[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (LL k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nconst ll mod = 1000000007;\nconst ll maxN = 1000011;\n\nll n, i, sg, db;\nll fact[maxN], inv_fact[maxN];\nll ans, aux;\n\nll poww(ll a, ll b) {\n    ll ans = 1;\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n    return ans;\n}\n\nll comb(ll n, ll k) {\n    ll ans = (fact[n] * inv_fact[n - k]) % mod;\n    return (ans * inv_fact[k]) % mod;\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%lld\", &n);\n\n    fact[0] = 1;\n    for (i = 1; i <= n; i++) fact[i] = (fact[i - 1] * i) % mod;\n\n    inv_fact[n] = poww(fact[n], mod - 2);\n    for (i = n - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % mod;\n\n    for (i = (n + 1) / 2; i < n; i++) {\n        db = n - i;\n        sg = i - db;\n\n        aux = (comb(sg + db - 1, sg) * fact[sg + db]) % mod;\n        aux = (aux * fact[n - 1 - sg - db]) % mod;\n\n        ans = (ans + aux) % mod;\n    }\n\n    ans = mod + ((fact[n - 1] * n) % mod) - ans;\n    ans %= mod;\n\n    printf(\"%lld\", ans);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nInt mod = 1000000007;\n\nInt fact[1123456];\n\nvoid init() {\n   fact[0] = 1;\n   for(Int i = 1; i < 1123456; ++i) {\n      fact[i] = fact[i-1] * i % mod;\n   }\n}\n\nInt pow(Int x, Int n) {\n   if( n == 0 ) return 1;\n   Int t = pow(x,n/2);\n   return n % 2 == 0 ? (t * t % mod) : (t * t % mod * x % mod);\n}\n\nInt div(Int x, Int y) {\n   return x * pow(y, mod-2) % mod;\n}\n\nInt nCr(Int n, Int r) {\n   if( r < 0 or n < r ) return 0;\n   return div(fact[n], fact[r] * fact[n-r] % mod);\n}\n\n// void solve(Int n) {\n//    std::vector<Int> xs(n-1);\n//    rep(i,n-1) {\n//       xs[i] = i;\n//    }\n//    Int res = 0;\n//    std::vector<Int> counts(n, 0);\n//    do {\n//       std::vector<bool> ys(n,false);\n//       for(Int i = 0; i < n-1; ++i) {\n//          ys[xs[i]] = ys[xs[i]+1] = true;\n//          bool end = true;\n//          for(Int k = 0; k < n; ++k) {\n//             if( not ys[k] ) end = false;\n//          }\n//          if( end ) {\n//             counts[i] += 1;\n//             if( i+1 == 4 ) {\n//                for(Int j = 0; j < n-1; ++j) {\n//                   printf(\"%ld \", xs[j]);\n//                }\n//                puts(\"\");\n//             }\n//             res += (i+1);\n//             break;\n//          }\n//       }\n//    } while( std::next_permutation(xs.begin(), xs.end()) );\n//    for(Int i = 0; i < n; ++i) {\n//       printf(\"score[%ld] : %ld\\n\", i+1, counts[i]);\n//    }\n//    printf(\"%ld\\n\", res);\n// }\n\nint main() {\n   init();\n   Int n;\n   std::cin >> n;\n   Int res = 0;\n   std::vector<Int> xs(n);\n   for(Int k = n/2; k < n; ++k) {\n      xs[k] = nCr(k-1, n-k-1) * fact[k] % mod * fact[n-1-k] % mod;\n   }\n   for(Int k = n/2; k < n; ++k) {\n      Int diff = xs[k] - xs[k-1];\n      Int t = diff * k % mod;\n      res = (res + t) % mod;\n   }\n   printf(\"%ld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nlong long int fac[1000001],inv[1000001],cnt[1000001];\n\nlong long int C(int n,int k){\n\treturn fac[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=1000000;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=mod-mod/i*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tinv[i]=inv[i-1]*inv[i]%mod;\n\tint n;\n\tcin>>n;\n\tif(n==2)\treturn cout<<1<<endl,0;\n\tlong long int ans = 0, pre = 0;\n\tfor(int i=2;i<n;i++)\n\t\tif(n-i-1<=i-1){\n\t\t\tlong long int cur = C(i-1,n-i-1)*fac[i]%mod*fac[n-1-i]%mod;\n\t\t\tans=(ans+(cur-pre)*i)%mod;\n\t\t\tpre=cur;\n\t\t}\n\tcout<<(ans%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"---------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\t\t\t\t\t\tFor(_x,L,R)cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef vector <int> vi;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=1000005,mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n;\nint Fac[N],Inv[N];\nvoid prework(){\n\tint n=N-1;\n\tfor (int i=Fac[0]=1;i<=n;i++)\n\t\tFac[i]=(LL)Fac[i-1]*i%mod;\n\tInv[n]=Pow(Fac[n],mod-2);\n\tFod(i,n,1)\n\t\tInv[i-1]=(LL)Inv[i]*i%mod;\n}\nint C(int n,int m){\n\tif (m>n||m<0)\n\t\treturn 0;\n\treturn (LL)Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nint a[N];\nint main(){\n\tprework();\n\tn=read();\n\tFor(i,1,n-1)\n\t\ta[i]=(LL)Fac[i]*Fac[n-1-i]%mod*C(i-1,n-i-1)%mod;\n\tint ans=0;\n\tFod(i,n-1,1){\n\t\tDel(a[i],a[i-1]);\n\t\tAdd(ans,(LL)a[i]*i%mod);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\nusing ll = int64_t;\nusing ld = long double;\nusing ull = uint64_t;\nusing namespace std;\nusing namespace __gnu_pbds;\n\nconst int MAXN = 1000002;\nll fct[MAXN];\nll rfct[MAXN];\n\nconst ll MOD = 1e9 + 7;\n\nll pw(ll a, ll b) {\n    if (!b) {\n        return 1;\n    }\n\n    ll v = pw(a, b / 2);\n    v = (v * v) % MOD;\n\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\nll cnk(int a, int b) {\n    return fct[a + b] * rfct[a] % MOD * rfct[b] % MOD;\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);  \n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << \"1\\n\";\n        return 0;\n    }\n\n    fct[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fct[i] = fct[i - 1] * i % MOD;\n    }\n\n    rfct[n] = pw(fct[n], MOD - 2);\n    for (int i = n - 1; i >= 0; --i) {\n        rfct[i] = (rfct[i + 1] * (i + 1)) % MOD;\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        ll tot = cnk(n - 1 - i, i);\n\n        ll gd = 0;\n        ll ln = n - 2;\n        ll cn = i - 1;\n        if (ln <= 2 * cn) {\n            int bg = ln - cn;\n            int sm = cn - bg;\n            gd = cnk(bg, sm);\n        }\n\n        ll b = (tot - gd + MOD * MOD) % MOD;\n\n        b = b * fct[i] % MOD;\n        b = b * fct[n - 1 - i] % MOD;\n\n        ans = (ans + b) % MOD;\n    }\n\n    cout << (ans + MOD * MOD) % MOD << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 1000005;\n\nll inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = fac[i-1] * (ll) i % MOD;\n\t\tfinv[i] = finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * (finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nll add(ll x,ll y)\n{\n    return (x + y)%MOD;\n}\n\nll sub(ll x,ll y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nll mul(ll x,ll y)\n{\n    return x*y%MOD;\n}\n\nint f[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    if(n == 2){\n        cout << \"1\\n\";\n        return 0;\n    }\n    make();\n    srep(i,(n+1)/2,n){\n        f[i] = mul(mul(sub(comb(n-3,i-2),comb(n-3,i)),fac[i]),fac[n-1-i]);\n    }\n    int ans = 0;\n    srep(i,(n+1)/2,n){\n        ans = add(ans,mul(i,sub(f[i],f[i-1])));\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cmath>\n\n#define pf printf\n// #define DEBUG true\n#define DEBUG false\n#define IFD if(DEBUG)\n#define FOR(i,ii,n) for(long long i=ii; i<n; i++)\n#define FORREV(i,ii,n) for(long long i=n-1; i>=ii; i--)\n#define INF ((ll)1e15)\n\nusing namespace std;\ntypedef long long ll;\n\nll const NMAX = 1000001;\n// ll mod = 998244353;\nll mod = 1e9 + 7;\nll fact[NMAX];\nll finv[NMAX];\nll comb(ll n,ll a){\n\treturn fact[n] * finv[a] % mod * finv[n-a] % mod;\n}\nll pow(ll a,ll n){\n\tll prd = 1;\n\tll exp = a;\n\twhile(n > 0){\n\t\tif((n&1)==1){\n\t\t\tprd *= exp;\n\t\t\tprd %= mod;\n\t\t}\n\t\texp *= exp;\n\t\texp %= mod;\n\t\tn >>= 1;\n\t}\n\treturn prd;\n}\n\nll gcd(ll a,ll b){\n\tif(a<b){\n\t\tll tmp = b;\n\t\tb = a;\n\t\ta = tmp;\n\t}\n\tll r = a % b;\n\tif(r==0) return b;\n\treturn gcd(b,r);\n}\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\n\nll numk[NMAX];\nint main(){\n\tll N;\n\tcin >> N;\n\t// init\n\tfact[0] = 1;\n\tfinv[0] = 1;\n\tFOR(i,1,N+1){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tfinv[i] = pow(fact[i], mod-2);\n\t}\n\t// main\n\t// ll least = ceil(N*1.0/2)\n\tll least = ceil(N*1.0/2);\n\tFOR(k,least,N){\n\t\tnumk[k] = comb(k-1, N-1-k) % mod * fact[k] % mod * fact[N-1-k] % mod;\n\t}\n\tll sum = least * numk[least];\tFOR(i,least+1,N){\n\t\tsum += i * (numk[i] - numk[i-1]);\n\t\tsum %= mod;\n\t}\n\tpf(\"%lld\", sum);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n \ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define in(x, a, b) a <= x && x < b\nconst int inf = 1000000001;\nconst ll INF = 2e18;\nconst ll MOD = 1000000007;\n//const ll mod = 1000000009;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p <<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\n\nconst int MAXN = 1000010;\n\n\n\nvl fact(MAXN);\nvl rfact(MAXN);\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n\tfact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n\tfor (ll i = 2; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % M;\n\t\trfact[i] = mod_inverse(fact[i], M);\n\t}\n}\n\nll nCr(ll n, ll r, ll M = MOD) {\n\tll ret = fact[n];\n\tret = (ret*rfact[r]) % M;\n\tret = (ret*rfact[n - r]) % M;\n\treturn ret;\n}\n\n\nint main() {\n  ll n;\n  cin >> n;\n  set_fact(n);\n  vl num(n);\n  rep1(k, n - 1) {\n    if (k - 1 < n - 1 - k) {\n      continue;\n    }\n    num[k] = nCr(k - 1, n - 1 - k);\n  }\n  vl num2(n);\n  rep1(k, n - 1) {\n    num2[k] = (num[k]) % MOD * fact[k] % MOD * fact[n - 1 - k] % MOD;\n  }\n     \n  //DEBUG_VEC(num2);\n  ll ans = 0;\n  rep1(k, n - 1) {\n    ans += (num2[k] - num2[k - 1]) % MOD * k % MOD;\n    ans %= MOD;\n  }\n  while (ans < 0) {\n    ans += MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9+7;\nLL f[1000005], rf[1000005];;\nLL inv(LL a, LL b){\n\tLL res = 1;\n\twhile(b){\n\t\tif(b%2 == 1) res = (res*a)%mod;\n\t\ta = (a*a)%mod;\n\t\tb/=2;\n\t}\n\treturn res;\n}\n\nLL ncr(LL a, LL b){\n\treturn f[a]*rf[b]%mod*rf[a-b]%mod;\n}\nint main(){\n\tf[0] = 1;\n\tfor(int i=1;i<=1000000;i++) f[i] = (f[i-1]*i)%mod;\n\tfor(int i=0;i<=1000000;i++) rf[i] = inv(f[i], mod-2);\n\tint n;\n\tscanf(\"%d\", &n);\n\tint c = n%2, rem = (n+1)/2;\n\tLL ans = 0, pv = 0;\n\n\tfor(int i=c;i<=n-2;i+=2,rem++){\n\t\tLL sum = ncr(rem-1, i)*f[rem]%mod*f[n-1-rem]%mod;\n\t\tLL res = (sum - pv + mod)%mod;\n\t\tans = (ans + res*rem)%mod;\n\t\tpv = sum;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000005, mod = 1e9+7;\n\nint n, fac[MAXN], ifac[MAXN], inv[MAXN];\n\ninline int choose(int n, int m)\n{ return n < m ? 0 : (long long)fac[n]*ifac[m]%mod*ifac[n-m]%mod; }\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tinv[1] = 1, ifac[0] = fac[0] = 1;\n\tfor (register int i = 2; i <= n; i++) inv[i] = (mod-(long long)mod/i*inv[mod%i]%mod)%mod;\n\tfor (register int i = 1; i <= n; i++) fac[i] = (long long)fac[i-1]*i%mod, ifac[i] = (long long)ifac[i-1]*inv[i]%mod;\n\tint ans = 0, pre = 0, cur;\n\tfor (register int k = 1; k < n; k++) {\n\t\tcur = (((long long)choose(k-1, n-k-1)*fac[k]%mod*fac[n-1-k]-pre)%mod+mod)%mod;\n\t\t(pre += cur) %= mod;\n\t\t(ans += (long long)cur*k%mod) %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tlong long int lft = (N - 1) / 2;\n\tlong long int rht = N / 2 - 1;\n\tvector<long long int>by(1000001);\n\tby[0] = 1;\n\tby[1] = 1;\n\tfor (int i = 2; i < 1000001; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t}\n\tlong long int box = 1;\n\tif (rht != lft) {\n\t\tbox = lft;\n\t}\n\tlong long int kazu = (N + 1) / 2;\n\tlong long int ans = 0;\n\tlong long int used = 0;\n\twhile (rht >= 0) {\n\t\t//cout << lft << \" \" << rht << \" \" << box << endl;\n\t\t//cout << kazu << endl;\n\t\tlong long int bag = by[kazu] * by[N - 1 - kazu];\n\t\tbag %= MOD;\n\t\tbag *= box;\n\t\tbag %= MOD;\n\t\tbag -= used;\n\t\tused += bag;\n\t\tbag += MOD;\n\t\tbag %= MOD;\n\t\tans += bag*kazu;\n\t\tans %= MOD;\n\t\tlft++;\n\t\trht--;\n\t\tbox *= rht + 1;\n\t\tbox %= MOD;\n\t\tbox *= lft;\n\t\tbox %= MOD;\n\t\tbox *= power(lft - rht, MOD - 2, MOD);\n\t\tbox %= MOD;\n\t\tbox *= power(lft - rht - 1, MOD - 2, MOD);\n\t\tbox %= MOD;\n\t\tkazu++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int DIV=1000000000+7;\nlong myPow(long x, long n, long m){\n  if(n == 0)\n    return 1;\n  if(n % 2 == 0)\n    return myPow(x * x % m, n / 2, m);\n  else\n    return x * myPow(x, n - 1, m) % m;\n}\nlong fact(long i,long j){//i*i+1*....*i+j-1\n    if(j==0)\n        return 1;\n    else\n        return fact(i,j-1)*(i+j-1) % DIV;\n}\n\nint main(){\n    long N;\n    cin >> N;\n    \n    long m;\n    if(N%2==0)\n        m=N/2;\n        \n    else\n        m=(N-1)/2;\n    long A[m];\n//    long kaijo = fact(1,N-m-1);\n    A[0] = fact(1,N-1);\n//    A[m-1] = kaijo*kaijo*(N-m);\n    for(long i=1;i<m;i++){\n     //   A[i] = A[i-1];\n     //   A[i] /= (N-i)*(N-i-1);\n     //   A[i] *=  (N-i-i)*(N-i-i-1);\n    A[i]=fact(1,N-i-1)*frac(N-i-i-1,i);\n//        cout<<\"Ai:\"<<A[i]<<endl;\n    }\n    long ret;\n    for(int i=0;i<m;i++){\n        A[i] %= DIV;\n    }\n    ret = A[0] * (N-1);\n    for(int i=1;i<m;i++){\n        ret -= A[i];\n//        cout<<\"i:\"<<i<<endl;\n    }\n    ret %= DIV;\n    cout << ret << endl;\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std;\n\n#define fcout(d) cout << fixed << setprecision(d)\n#define rep(i,n) for(int (i) = 0; (i) < (n); ++(i))\n#define rep1(i,n) for(int (i) = 1; (i) <= (n); ++(i))\n#define repU(i,bottom,ceiling) for(auto (i) = (bottom); (i) <= (ceiling); ++(i))\n#define repD(i,ceiling,bottom) for(auto (i) = (ceiling); (i) >= (bottom); --(i))\n#define repS(n) for(int (s) = 0; (s) < 1 << (n); ++(s))\n#define repV(i,v) for(auto (i) = begin(v); (i) < end(v); ++(i))\n#define all(v)  begin(v),end(v)\n#define clr(v) fill(all(v),0)\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define puf push_front\n#define pub push_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define fir first\n#define sec second\n#define divceil(n,d) ((n)/(d) + ((n)%(d) > 0))\n#define parity(a,b) (((a) & 1LL)^((b) & 1LL)^1LL)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\n\nconst pair<int,int> DIR[] = { {1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,1},{-1,-1},{1,-1} };\nconst int INF_32 = -1 + (1 << 30);\nconst ll INF_64 = -1 + (1LL << 62);\nconst int MOD = 1e9 + 7;\n\ntemplate<class T> T gcd(T a, T b){ if(a % b){ return gcd(b, a % b); }else{ return b; } }\n\ntemplate<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\n\nll Pow(ll n, ll m, int mod = MOD){\n\tll res = 1,pow = n % mod;\n\twhile(m) {\n\t\tif(m & 1LL) res = (res * pow) % mod;\n\t\tpow = (pow * pow) % mod;\n\t\tm >>= 1;\n\t}\n\treturn res;\n}\n\nvoid Fact_table(ll *fact, int range, int mod = MOD){\n\tfact[0] = 1;\n\trep1(i,range) fact[i] = fact[i - 1] * i % mod;\n}\n\nvoid Fact_inv_table(ll *fact_inv, ll *fact, int range, int mod = MOD){\n\trep(i,range + 1) fact_inv[i] = Pow(fact[i], mod - 2, mod);\n}\n\nll Comb(int n, int m, ll *fact, ll *fact_inv, int mod = MOD){\n\tif(n < m || m < 0) return 0;\n\tll rev = fact_inv[m] * fact_inv[n - m] % mod;\n\treturn rev * fact[n] % mod;\n}\n\nbool Prime_judge(int n){\n\tif(n <= 1 || !(n % 2)) return 0;\n\tfor(int d = 3; d * d <= n; d += 2) if(!(n % d)) return 0;\n\treturn 1;\n}\n\nvoid Prime_table(bool *is_prime, int n){\n\tfill(is_prime + 1, is_prime + n + 1, 1);\n\trepU(i,2,n/2) is_prime[i * 2] = 0;\n\tis_prime[0] = is_prime[1] = 0;\n\tint p = 3;\n\twhile(p * p <= n){\n\t\tfor(int t = p * 3; t <= n; t += p * 2) is_prime[t] = 0;\n\t\tp += 2;\n\t\twhile(!is_prime[p]) p += 2;\n\t}\n}\n\nint main(){\n\tint N; cin>>N;\n\tll fact[1000001],fact_inv[1000001],cur,last = 0;\n\tll ans = 0;\n\tFact_table(fact,N);\n\tFact_inv_table(fact_inv,fact,N);\n\trep1(i,N - 1){\n\t\tcur = fact[i] * fact[N - i - 1] % MOD * Comb(i - 1, N - i - 1, fact, fact_inv) % MOD;\n\t\tans += (cur - last) * i % MOD;\n\t\tans %= MOD;\n\t\tif(ans < 0) ans += MOD;\n\t\tlast = cur;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int maxn = 1000005;\nint fac[maxn], rev[maxn];\nint n, ans, res;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p&1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n-m] % MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n); n--;\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, n+5) {\n\t\tfac[i] = 1LL * fac[i-1] * i % MOD;\n\t\trev[i] = power(fac[i], MOD - 2);\n\t}\n\tans = 1LL * n * fac[n] % MOD;\n\trep (i, 0, n-3) if (i <= n-2-i-1) {\n\t\tres = (res + 1LL * C(n-2-i-1, i) * (n-2-i) % MOD * fac[n-i-1]) % MOD;\n\t\t// printf(\"%d\\n\", res);\n\t}\n\tans = (ans + MOD - res) % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* main code starts from line 133. */\n\n/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<decltype((v).front())>())\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define NREP(i, n) FOR(i, 1, n + 1)\n\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); i--)\n#define RREP(i, n) RFOR(i, n - 1, 0)\n#define RNREP(i, n) RFOR(i, n, 1)\n\n// Usual REP runs from 0 to n-1 (R: n-1 to 0)\n// Natural REP runs from 1 to n (R: n to 1)\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\n#define fcout cout << fixed << setprecision(10)\n\n/* ----------- debug ---------- */\n\ntemplate <typename T, typename U>\nvoid testP2(T a, U b) {\n    cout << \"(\" << a << \", \" << b << \")\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV(T v) {\n    cout << \"[\";\n    for (auto i : v) {\n        cout << i << \", \";\n    }\n    cout << \"\\b\\b]\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV2(T v) {\n    for (auto sv : v) {\n        testV(sv);\n    }\n    cout << endl;\n    return;\n}\n\n#define GET_VAR_NAME(variable) #variable\n#define test(x) cout << GET_VAR_NAME(x) << \" = \" << x << endl;\n#define testP(p)                      \\\n    cout << GET_VAR_NAME(p) << \" = \"; \\\n    testP2(p.fst, p.snd);\n\n/* ---------- Constants ---------- */\n\nconst ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n// const ll dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const ll dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n/* ---------- Type Definition ----------- */\n\n\n/* ---------- Global Variance ----------- */\n\nconst ll MAX_V = 1000010;\n\n/* ------------- Functions -------------- */\n\nV<ll> fact(MAX_V + 1), invfact(MAX_V + 1);\n\nll calc_pow(ll n, ll k) {\n    if (k == 0) return 1;\n    if (k == 1) return n;\n\n    if (k % 2 > 0) {\n        return calc_pow(n, k - 1) * n % MOD;\n    } else {\n        return calc_pow(n * n % MOD, k / 2);\n    }\n}\n\nvoid precalc() {\n    invfact[0] = fact[0] = 1;\n    NREP(i, MAX_V) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n\n    invfact[MAX_V] = calc_pow(fact[MAX_V], MOD - 2);\n    RREP(i, MAX_V) {\n        invfact[i] = invfact[i + 1] * (i + 1) % MOD;\n    }\n    return;\n}\n\nll comb(ll a, ll b) {\n    if (a < b) return 0;\n    if (a == 0) return 1;  // a = b = 0\n\n    return fact[a] * invfact[a - b] % MOD * invfact[b] % MOD;\n}\n\n/* ----------- Main Function ------------ */\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    precalc();\n\n    ll N;\n    cin >> N;\n\n    V<ll> pat(N);\n    // pat[k] = k台以下で全部塗るパターン数\n\n    REP(k, N) {\n        pat[k] = (fact[k] * fact[N - k - 1]) % MOD * comb(k - 1, N - k - 1) % MOD;\n    }\n\n    ll ans = 0;\n    NREP(k, N - 1) {\n        ans += (pat[k] - pat[k - 1]) * k;\n        while (ans < 0) {\n            ans += MOD;\n        }\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int DIV=1000000000+7;\nlong myPow(long x, long n, long m){\n  if(n == 0)\n    return 1;\n  if(n % 2 == 0)\n    return myPow(x * x % m, n / 2, m);\n  else\n    return x * myPow(x, n - 1, m) % m;\n}\nlong fact(long i,long j){//i*i+1*....*i+j-1\n    if(j==0)\n        return 1;\n    else\n        return fact(i,j-1)*(i+j-1) % DIV;\n}\n\nint main(){\n    long N;\n    cin >> N;\n    \n    long m;\n    if(N%2==0)\n        m=N/2;\n    else\n        m=(N-1)/2;\n    long A[m];\n    for(int i=0;i<m;i++){\n        A[i] =fact(1,N-1-i)*fact(N-1-2*i,i)%DIV;\n        cout<<\"Ai:\"<<A[i]<<endl;\n    }\n    long ret;\n    ret = A[0] * (N-1);\n    for(int i=1;i<m;i++){\n        ret -= A[i];\n        cout<<\"i:\"<<i<<endl;\n    }\n    ret %= DIV;\n    cout << ret << endl;\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n; --n;\n\tmint re=fact[n]*n;\n\trep(i,n){\n\t\tre-=mint(n-i)*fact[i]*fact[n-i-1]*comb(i-1,n-i);\n\t}\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG\n#include \"../../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = (ll)x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = (unsigned long long)x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n    // 平方剰余のうち一つを返す なければ-1\n    friend modint sqrt(modint a) {\n        if(a == 0) return 0;\n        ll q = MOD-1, s = 0;\n        while((q&1)==0) q>>=1, s++;\n        modint z=2;\n        while(1) {\n            if(z.pow((MOD-1)/2) == MOD-1) break;\n            z++;\n        }\n        modint c = z.pow(q), r = a.pow((q+1)/2), t = a.pow(q);\n        ll m = s;\n        while(t.x>1) {\n            modint tp=t;\n            ll k=-1;\n            FOR(i, 1, m) {\n                tp *= tp;\n                if(tp == 1) { k=i; break; }\n            }\n            if(k==-1) return -1;\n            modint cp=c;\n            REP(i, m-k-1) cp *= cp;\n            c = cp*cp, t = c*t, r = cp*r, m = k;\n        }\n        return r.x;\n    }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { \n        is >> a.x;\n        a.x = ((a.x%MOD)+MOD)%MOD;\n        return is;\n    }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<1000000007>;\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=5e5; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nint main(void) {\n    ll n;\n    cin >> n;\n\n    vector<mint> frac(n+1);\n    frac[0] = 1;\n    FOR(i, 1, n+1) frac[i] = frac[i-1] * i;\n\n    mint sum = 0, ans = 0;\n    vector<mint> dp(n+1);\n    FOR(i, 1, n) {\n        dp[i] = combi(i-1, n-1-i) * frac[i] * frac[n-1-i];\n        dp[i] -= sum;\n        ans += dp[i] * i;\n        sum += dp[i];\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nlong long nn;\nlong long kaik[2000000];\nlong long kai(long long a){\n    if(a==0)return 1;\n    else return (a*kai(a-1))%nn;\n}\nlong long rui(long long a,long long b){\n    if(b==0)return 1;\n    if(b==1)return a%nn;\n    if(b>1){\n        if(b%2==0)return (rui(a,b/2)*rui(a,b/2))%nn;\n        if(b%2==1)return (rui(a,(b+1)/2)*rui(a,(b-1)/2))%nn;\n    }\n}\nlong long c(long long n,long long m){\n    long long x;\n    x=(kaik[n-m]*kaik[m])%nn;\n    long long y;\n    y=(kaik[n]*rui(x,nn-2))%nn;\n    return y;\n}\n\nint main(void){\n    long long i,j,k,x,y,z,n,m,w;\n    nn=1000000007;\n    kaik[0]=1;\n    for(i=1;i<2000000;i++){\n        kaik[i]=(kaik[i-1]*i)%nn;\n    }\n    scanf(\"%lld\",&n);\n    x=(kaik[n-1]*(n-1))%nn;\n    m=(n-2)/2;\n    for(i=1;i<=m;i++){\n        z=(c(n-i-2,n-2*i-2)*kaik[n-1-i])%nn;\n        w=(z*kaik[i])%nn;\n        x-=w;\n        if(x<0)x+=nn;\n    }\n    printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\ninline int mul(int x, int y) {return (ll)x * y % mod;}\ninline int inc(int x, int y) {x += y; return x >= mod ? x - mod : x;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = (ll)x * x % mod)\n\t\tif (y & 1) res = (ll)res * x % mod;\n\treturn res; \n}\nconst int MAXN = 1e6 + 10;\nint n, fac[MAXN], inv[MAXN];\ninline int binom(int x, int y) {return y < 0 || y > x ? 0 : mul(fac[x], mul(inv[y], inv[x - y]));}\n\nint main()\n{\n\tcin >> n;\n\tif (n == 2) return puts(\"1\");\n\tif (n == 3) return puts(\"2\");\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tinv[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n; i >= 2; i --)\n\t\tinv[i - 1] = mul(inv[i], i);\n\tint ans = fac[n - 1];\n\tfor (int i = 1; i < n - 1; i ++)\n\t{\n\t\tint cnt = binom(i - 1, n - i - 1);\n\t\tcnt = mul(cnt, fac[i]);\n\t\tcnt = mul(cnt, fac[n - i - 1]);\n\t\tcnt = inc(fac[n - 1], mod - cnt);\n\t\tans = inc(ans, cnt);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize (\"-O2\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 1000000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nll fac[N], inv[N], dp[N];\nint n;\n\nll POW(ll x, ll t){\n\tll res = 1;\n\twhile (t){\n\t\tif (t & 1) res = res * x % MOD;\n\t\tt >>= 1;\n\t\tx = x * x % MOD;\n\t}\n\treturn res;\n}\n\nll nCr(ll x, ll y){\n\tif (y > x || y < 0 || x < 0) return 0;\n\tll res = fac[x];\n\tres = res * inv[y] % MOD;\n\tres = res * inv[x - y] % MOD;\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % MOD, inv[i] = POW(fac[i], MOD - 2);\n\t//cout << nCr(6, 3) << '\\n';\n\tfor (int i = 1; i <= n - 1; i++){\n\t\tdp[i] = nCr(i - 1, n - i - 1);\n\t\tdp[i] = dp[i] * fac[i] % MOD;\n\t\tdp[i] = dp[i] * fac[n - i - 1] % MOD;\n\t}\n\tll sm = 0;\n\tll ans = 0;\n\tfor (int i = 1; i <= n - 1; i++){\n\t//\tcout << dp[i] << '\\n';\n\t\tdp[i] -= sm;\n\t\tdp[i] %= MOD;\n\t\tdp[i] += MOD;\n\t\tdp[i] %= MOD;\n\t\tans = (ans + dp[i] * i % MOD) % MOD;\n\t\tsm = (sm + dp[i]) % MOD;\n\t}\n\tcout << ans;\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> point;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 1000005\n#define MOD 1000000007\n#define oo 1000000000000000007LL\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nint n, fact[maxN], invFact[maxN], f[maxN];\n\nint power(int x, int n) {\n    if (n == 0) return 1;\n    if (n%2 == 1) return (1LL*x*power(x, n-1))%MOD;\n    int p = power(x, n/2);\n    return (1LL*p*p)%MOD;\n}\n\nint C(int n, int k) {\n    if (k > n) return 0;\n    int p = fact[n];\n    int q = (1LL*invFact[k]*invFact[n-k])%MOD;\n    return (1LL*p*q)%MOD;\n}\n\nint main () {\n    scanf(\"%d\", &n);\n    fact[0] = invFact[0] = 1;\n    fto(i, 1, n) {\n        fact[i] = (1LL*fact[i-1]*i)%MOD;\n        invFact[i] = power(fact[i], MOD-2);\n    }\n\n    int ans = 0;\n    fto(t, 1, n-1) {\n        int cof = C(t-1, n-t-1);\n        int perm = (1LL*fact[t]*fact[n-1-t])%MOD;\n        f[t] = (1LL*cof*perm)%MOD;\n//        printf(\"%d %d %d %d\\n\", t, cof, perm, f[t]);\n    }\n    fto(t, 1, n-1) {\n        int cnt = (f[t]-f[t-1]+MOD)%MOD;\n        ans = (ans+1LL*cnt*t)%MOD;\n    }\n\n    printf(\"%d\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=1000005;\nconst int mod=1e9+7;\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN],inv[MAXN],n;\nint C(int n,int m){return n<m?0:1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();int ans=0;\n\tfor(int i=(n+1)/2;i<n;i++)\n\t{\n\t\tint val=C(n-3-(n-1-(i-1)-1),n-1-(i-1));\n\t\tval=1LL*val*pre[i-1]%mod*pre[n-i]%mod;\n\t\tad(ans,(pre[n-1]-val+mod)%mod);\n\t}ad(ans,1LL*((n+1)/2-1)*pre[n-1]%mod);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\n// using mint = ld;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\nstruct Factorial {\n  const int MAX;\n  vector<mint> fac, finv;\n  Factorial(int M) : MAX(M), fac(M, 1), finv(M, 1) {\n    rep2(i, 2, MAX) fac[i] = fac[i-1] * i;\n    finv[MAX-1] /= fac[MAX-1];\n    drep2(i, MAX, 3) finv[i-1] = finv[i] * i;\n  }\n};\nFactorial fc(int(1e6)+3);\n\nmint binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fc.fac[n] * fc.finv[k] * fc.finv[n-k];\n}\n\n\n\nint main() {\n  int n; cin >> n;\n\n  mint ans = 0;\n  rep2(m, 1, n) {\n    mint res = 0;\n    rep(k, n) res += binom(n-m-1, k) * binom(m+1, n-m-k) / (n-k);\n    // rep(l, m+1) res += binom(n-m-1, l) * binom(m+1, l-1) / (l+m+1);\n    if (m&1) ans += res;\n    else ans -= res;\n  }\n  if (n&1) ans += mint(1) / n;\n  else ans -= mint(1) / n;\n\n\n\n  rep2(i, 1, n+1) ans *= i;\n\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1'000'100, mod = 1'000'000'007;\nint add(int a, int b){\n\ta += b;\n\tif(a >= mod) a -= mod;\n\treturn a;\n}\nint sub(int a, int b){\n\treturn add(a, mod - b);\n}\nint mul(long long a, long long b){\n\treturn a * b % mod;\n}\nint pwr(long long a, long long b){\n\tint r = 1;\n\tfor(; b; b >>= 1, a = mul(a, a)) if(b&1) r = mul(r, a);\n\treturn r;\n}\nint fat[maxn], ifat[maxn];\nvoid init(){\n\tfat[0] = 1;\n\tfor(int i = 1; i < maxn; i++) fat[i] = mul(i, fat[i - 1]);\n\tifat[maxn - 1] = pwr(fat[maxn - 1], mod - 2);\n\tfor(int i = maxn - 2; i >= 0; i--) ifat[i] = mul(i + 1, ifat[i + 1]);\n}\nint ncr(int n, int r){\n\tif(n < r) return 0;\n\treturn mul(fat[n], mul(ifat[r], ifat[n - r]));\n}\nint main(){\n\tinit();\n\tint n; cin >> n;\n\tint ans = 0, comp = 0;\n\tfor(int i = 1; i <= n - 1; i++){\n\t\tint ways = mul(ncr(i - 1, n - 1 - i), mul(fat[i], mul(fat[n - 1 - i], 1)));\n\t\tans = add(ans, mul(sub(ways, comp), i));\n\t\tcomp = ways;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nint n;\nconst int N=1000010,mod=1e9+7;\nLL ans;\nLL jc[N],inv[N],f[N];\ninline LL ksm(LL a,LL b,LL mod)\n{\n\tLL res=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)res=res*a%mod;\n\treturn res;\n}\ninline int read()\n{\n\tint res = 0; char ch = getchar(); bool XX = false;\n\tfor (; !isdigit(ch); ch = getchar())(ch == '-') && (XX = true);\n\tfor (; isdigit(ch); ch = getchar())res = (res << 3) + (res << 1) + (ch ^ 48);\n\treturn XX ? -res : res;\n}\ninline void YYCH()\n{\n\tjc[0]=jc[1]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=n;++i)jc[i]=jc[i-1]*i%mod;\n\tinv[n]=ksm(jc[n],mod-2,mod);\n\tfor(int i=n-1;i>=1;--i)inv[i]=inv[i+1]*(i+1)%mod;\n}\ninline LL C(LL n,LL m){return jc[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tcin>>n;\n\tYYCH();\n\tfor(int i=(n+1)>>1;i<=n-1;++i)\n\t{\n\t\tf[i]=C(i-1,n-i-1)*jc[i]%mod*jc[n-1-i]%mod;\n\t\t(((ans+=(f[i]-f[i-1])*i%mod)%=mod)+=mod)%=mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int L = 1e6 + 10;\nconst int M = 1e9 + 7;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint fact[L];\nint rfact[L];\n\nint ncr(int n, int k) {\n    if (k < 0 || k > n)\n        return 0;\n    return (ll) fact[n] * rfact[k] % M * rfact[n - k] % M;\n}\n\nconst int N = 15;\n\nint f[N][N];\n\nvoid smain() {\n\n    fact[0] = 1;\n    for (int i = 1; i < L; ++i) {\n        fact[i] = (ll) fact[i - 1] * i % M;\n    }\n    rfact[L - 1] = pw(fact[L - 1]);\n    for (int i = L - 2; i >= 0; --i) {\n        rfact[i] = (ll) rfact[i + 1] * (i + 1) % M;\n    }\n\n//    f[1][1] = 1;\n//    for (int i = 2; i < N; ++i) {\n//        for (int j = 2; j < N; ++j) {\n//            f[i][j] = f[i - 1][j - 1] + f[i - 2][j - 1];\n//            cout << f[i][j] - 1 * ncr(j - 1, i - j) << ' ';\n//        }\n//        cout << '\\n';\n//    }\n\n\n\n\n    int n;\n    cin >> n;\n    n--;\n    vi g(n + 1);\n    int ans = 0;\n    ll sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        g[i] = ncr(i - 1, n - i);\n//        g[i] = f[n][i];\n        g[i] = (ll) g[i] * fact[i] % M * fact[n - i] % M;\n//        for (int j = 1; j < i; ++j) {\n//            g[i] = (g[i] - g[j] + M) % M;\n//        }\n        g[i] = (g[i] - sum % M + M) % M;\n        sum = (sum + g[i]) % M;\n//        cerr << \"g[\" << i << \"] = \" << g[i] << endl;\n        int cur = (ll) g[i] * i % M;\n        ans = (ans + cur) % M;\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static const AlgStruct idAdd(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static const AlgStruct idMul(Args... args) { return Operators::IdMul(args...); }\n\n    const AlgStruct operator+() const { return *this; }\n    const AlgStruct operator-() const { return Operators::Opposite(x); }\n    const AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct& operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct& operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct& operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct& operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    const AlgStruct power(long long n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& value){ s << value.x; return s; }\n\n\ntemplate<typename T, T mod>\nstruct GaloisFieldOperators {\n    static T Add(T lhs, T rhs) { return (lhs + rhs) % mod; };\n    static T Mul(T lhs, T rhs) { return (lhs * rhs) % mod; };\n    static T IdAdd() { return 0; };\n    static T IdMul() { return 1; };\n    static T Opposite(T value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(T lhs, T rhs) { return lhs < rhs; };\n    static T Power(T value, long long n) {\n        T res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static T Reciprocal(T value) { return Power(value, mod-2); }\n};\n\nconst long long MOD = 1e9+7;\nusing GaloisField = AlgStruct<long long, GaloisFieldOperators<long long, MOD>>;\n\n\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring::idMul();\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\n\n\nint main()\n{\n    long long n; cin >> n;\n\n    Fact<GaloisField> fact(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * fact[k] * fact[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (int k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(2123456);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n; --n;\n\tmint re=fact[n]*n;\n\trep(i,n){\n\t\tre-=mint(n-i)*fact[i]*fact[n-i-1]*comb(i-1,n-i);\n\t}\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 1000005\nusing namespace std;\nlong long n, ans, M=1e9+7, s[N], fac[N]={1,1}, inv[N]={1,1}, fin[N]={1,1};\nint main() {\n\tint i;\n\tcin>>n;\n\tfor(i=2; i<=n; i++) {\n\t\tfac[i] = fac[i-1] * i % M;\n\t\tinv[i] = inv[M%i] * (M-M/i) % M;\n\t\tfin[i] = fin[i-1] * inv[i] % M;\n\t}\n\tfor(i=(n+1)/2; i<n; i++) {\n\t\ts[i] = fac[i] * fac[i-1] % M * fin[2*i-n] % M;\n\t\tans += (s[i] - s[i-1] + M) * i % M;\n\t}\n\tcout<<ans % M;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define F first\n#define S second\n#define ld long double\nint const M=1e6+10,inf=1e9+10,mod=1e9+7;\nint fact[M],ans[M];\nint pw(int x,int y)\n{\n\tif(y==0)return 1;\n\tint tmp=pw(x,y/2);\n\tif(y%2==0)return (tmp*tmp)%mod;\n\treturn ((tmp*tmp)%mod*x)%mod;\n}\nint C(int n,int r)\n{\n\tint tmp=fact[r]*fact[n-r];\n\ttmp%=mod;\n\ttmp=pw(tmp,mod-2);\n\ttmp*=fact[n];\n\ttmp%=mod;\n\treturn tmp;\n}\nint say(int n,int r)\n{\n\tint tmp=n-r;\n\tif(tmp==0 && r==0)return 1;\n\tif(tmp<r || r==0)return 0;\n\treturn C(tmp-1,r-1);\n}\nint32_t main()\n{\n\tint n;\n\tcin>>n;\n\tfact[0]=1;\n\t//cout<<C(5,2)<<\" \"<<pw(2,4)<<endl;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfact[i]=fact[i-1]*i;\n\t\tfact[i]%=mod;\n\t}\n\tint all=0;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tif(n-i-1<0)continue;\n\t\tint res=n-i;\n\t\tif(n-2>=res)\n\t\t\tans[i]=say(n-2,res);\n\t\tans[i]*=res*2;\n\t\tans[i]%=mod;\n\t\tif(n-2>=res-1){\n\t\t\tans[i]+=say(n-2,res-1)*res;\n\t\t\tans[i]%=mod;\n\t\t}\n\t\tif(n-3>=res)\n\t\t{\n\t\t\tans[i]+=say(n-3,res-1)*2*res;\n\t\t\tans[i]%=mod;\n\t\t}\n\t\tint tmp=1;\n\t\ttmp%=mod;\n\t\ttmp*=fact[i-1];\n\t\ttmp%=mod;\n\t\ttmp*=fact[n-i-1];\n\t\ttmp%=mod;\n\t\ttmp*=i;\n\t\ttmp%=mod;\n\t\ttmp*=ans[i];\n\t\ttmp%=mod;\n\t//\tcout<<i<<\" \"<<res<<\" \"<<tmp<<\" \"<<ans[i]<<endl;\n\t\tall+=tmp;\n\t\tall%=mod;\n\t}\n\tcout<<all;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 1e6 + 10;\n\ntemplate<int mod>\nclass ModCalc {\nprivate:\n    const int defnum = -1;\npublic:\n    ModCalc() { }\n    int add(int a, int b) {\n        a += b;\n        while (a < 0) a += mod;\n        while (a >= mod) a -= mod;\n        return a;\n    }\n    int mul(int a, int b) {\n        return (long long)a * b % mod;\n    }\n    int pow(int a, int p) {\n        int res = 1;\n        while (p > 0) {\n            if (p & 1) res = this->mul(res, a);\n            a = this->mul(a, a);\n            p >>= 1;\n        }\n        return res;\n    }\n    int inverse(int a) {\n        return this->pow(a, mod - 2);\n    }\n};\n\nModCalc<MOD> mc;\nint memoFact[MAX], memoInvFact[MAX];\n\nint fact(int n) {\n    if (memoFact[n] != -1) return memoFact[n];\n    return memoFact[n] = (n == 0 ? 1 : mc.mul(n, fact(n - 1)));\n}\n\nint invFact(int n) {\n    if (memoInvFact[n] != -1) return memoInvFact[n];\n    return memoInvFact[n] = mc.inverse(fact(n));\n}\n\nLL Perm(int n, int r) {\n    return mc.mul(fact(n), invFact(n - r));\n}\n\nLL comb(LL n, LL r) {\n    return mc.mul(mc.mul(fact(n), invFact(r)), invFact(n - r));\n}\n\n// M個の物をN人で分ける\nLL combWithRepetition(LL M, LL N) {\n    return comb(M + N - 1, N - 1);\n}\n\n//最初に呼んで♪\nvoid init() {\n    memset(memoFact, -1, sizeof(memoFact));\n    memset(memoInvFact, -1, sizeof(memoInvFact));\n    for (int i = 0; i < MAX; i++) {\n        fact(i);\n        invFact(i);\n    }\n}\n\nint N;\n// 最初(1番目)と最後(N-1番目)のマシンは絶対に使う\n// N=6のとき:1,3,5を最初に選ぶのが最短=(1,3,5)の順列×(2,4)の順列 3回\n//         :1,3,5のいずれかを最後に持ってきて，間に2or4を1回選ぶと4回\n//         :1,3,5のいずれかを最後に持ってきて，間に2と4を選ぶと5回\n\n// N=8のとき:1,3,5,7を最初に選ぶのが最短=(1,3,5,7)の順列×(2,4,6)の順列 4回\n//         :\n\nint main(void) {\n    init();\n    cin >> N;\n    LL ans = 0;\n    int tmp = (N + 1) / 2;\n    FOR(i, tmp, N) {\n        if (i == tmp) {\n            ans += mc.mul(mc.mul(fact(i), fact(N - i - 1)), i);\n        } else {\n            // fact(i - 1) * tmp * comb(n - tmp, i - tmp) * fact(n - i)\n            ans += mc.mul(mc.mul(mc.mul(fact(i - 1), tmp), mc.mul(comb(N - tmp - 1, i - tmp - 1), fact(N - i - 1))), i);\n        }\n        ans %= MOD;\n    //    DEBUG(ans)\n\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n\ni64 MOD = 1e9 + 7;\ni64 inv_mod(i64 a, i64 m = MOD) {\n  i64 b, x, u, q, abs_m, tmp;\n\n  abs_m = (m < 0) ? -m : m;\n  b = m;\n  x = 1;\n  u = 0;\n  while (b > 0) {\n    q = a / b;\n    tmp = u;\n    u = x - q * u;\n    x = tmp;\n    tmp = b;\n    b = a - q * b;\n    a = tmp;\n  }\n\n  return (x < 0) ? abs_m + x : x;\n}\nint main(){\n  int N;\n  cin >> N;\n\n  if(N == 2){\n    cout << 1 << endl;\n  }\n  else if(N == 3){\n    cout << 4 << endl;\n  }\n\n  vector<i64> fact(1010101,0);\n  fact[0] = 1;\n  rep(i,1,1010100){\n    fact[i] = (fact[i - 1] * i) % MOD;\n  }\n  vector<i64> inv_fact(1010101,0);\n  inv_fact[1010100] = inv_mod(fact[1010100]);\n  for(int i = 1010100 - 1;i >= 0;i--){\n    inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n  }\n  i64 ans = 0;\n\n  i64 before = 0;\n  rep(i,1,N - 1){\n    i64 p = fact[i] * fact[N - i - 1];\n    p %= MOD;\n    int n = i - 1;\n    int r = N - i - 1;\n    if(n < r) continue;\n    i64 q = (fact[n] * inv_fact[r]) % MOD ;\n    q = (q * inv_fact[n - r]) % MOD;\n    ans = (ans + ((p * q + MOD - before) % MOD) * i) % MOD;\n    before = q * p;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long int\nusing namespace std;\n\nll mod = 1000000007;\n\nll factorials[1000005];\nll inv[1000005];\n\nll mod_pow(ll k, ll pow) {\n  ll ans = 1;\n  while (pow > 0) {\n    if (pow & 1) ans = ans * k % mod;\n    k = k * k % mod;\n    pow >>= 1;\n  }\n  return ans;\n}\n\nint main() {\n  ll n;\n  cin >> n;\n  factorials[0] = 1;\n  inv[0] = 1;\n\n  for (int i = 1; i < 1000005; i++) {\n    factorials[i] = (factorials[i - 1] * i) % mod;\n    inv[i] = (inv[i - 1] * mod_pow(i, mod - 2)) % mod;\n  }\n  \n  ll min_score = (n + 1) / 2;\n  ll max_score = n - 1;\n  ll ans = 0;\n  ll prev = 0;\n  for (int i = min_score; i <= max_score; i++) {\n    ll cnk = ((factorials[i - 1] * inv[n - 1 - i] % mod) * inv[2 * i - n] % mod) % mod;\n    ll add = (cnk * factorials[i] % mod) * factorials[n - 1 - i] % mod;\n    ans = (ans + (((add - prev + mod) % mod) * i) % mod) % mod;\n    prev = add;\n  }\n  cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\nLL fact[1000005];\nLL inv_fact[1000005];\n\nLL mod_pow(LL a, LL p) {\n\tLL tmp = a;\n\tLL ret = 1;\n\twhile (p) {\n\t\tif (p & 1) ret = (ret*tmp) % MOD;\n\t\tp >>= 1;\n\t\ttmp = (tmp*tmp) % MOD;\n\t}\n\treturn ret;\n}\n\nLL mod_inv(LL a) {\n\treturn mod_pow(a, MOD - 2);\n}\n\nLL f(int n, int k) {\n\tif (2 * k - n < 0)return 0;\n\treturn (((fact[k - 1] * fact[k]) % MOD) * inv_fact[2*k-n]) %MOD;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfact[0] = inv_fact[0] = 1;\n\tFOR(i, 1, 1000005) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = mod_inv(fact[i]);\n\t}\n\tLL ret = 0;\n\tLL cum = 0;\n\tFOR(k, (n + 1) / 2, n) {\n\t\tauto ways = (f(n, k) - f(n, k - 1) + MOD) % MOD;\n\t\tret = (ret + (k*ways)%MOD) % MOD;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-10;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long fact[2100000];\nlong long inv[2100000];\nlong long finv[2100000];\nlong long C(int a,int b){\n\tif(b<0||b>a)return 0;\n\treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nint main(){\n\tfact[0]=inv[1]=finv[0]=1;\n\tfor(int i=2;i<2100000;i++)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfor(int i=1;i<2100000;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n\tint a;scanf(\"%d\",&a);\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tlong long ks=C(a-2-i,i);\n\t\t//printf(\"%d: %lld\\n\",i,ks);\n\t\tret=(ret+fact[i]*ks%mod*fact[a-1-i])%mod;\n\t}\n//\tprintf(\"%lld\\n\",ret);\n\tret=(fact[a-1]*(a)%mod-ret+mod)%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\n\nll fact(ll x){\n  ll res=1;\n  while(x>1){\n    res*=x;\n    res%=MOD;\n    x--;\n  }\n  return res%MOD;\n}\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  REP(i,n+1)a[i]=i;\n  int sm=0;\n  ll f=fact((n+1)/2 - 1);\n  for(int i=(n+1)/2;i<=n-1;i++){\n    f*=i;\n    sm+=(i*(n-i)*f)%MOD;\n  }\n  P(sm);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=1000010,Mo=1000000007;\nint fac[N],inv[N];\ninline int Pow(int x,int y) {\n    int ret=1;\n    while(y) {\n\tif(y&1) ret=1LL*ret*x%Mo;\n\tx=1LL*x*x%Mo,y>>=1;\n    }\n    return ret;\n}\ninline int C(int n,int m) {\n    if(n<m) return 0;\n    return 1LL*fac[n]*inv[m]%Mo*inv[n-m]%Mo;\n}\nint main() {\n    int n,ans=0;\n    cin>>n;\n    fac[0]=1;\n    for(int i=1;i<=n;i++) fac[i]=1LL*fac[i-1]*i%Mo;\n    inv[n]=Pow(fac[n],Mo-2);\n    for(int i=n;i;i--) inv[i-1]=1LL*inv[i]*i%Mo;\n    for(int i=1,la=0;i<n;i++) {\n\tint t=1LL*C(i-1,n-i-1)*fac[i]%Mo*fac[n-i-1]%Mo;\n\tans=(ans+1LL*(t-la+Mo)*i)%Mo,la=t;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst int SIZE = 1000000;\n\nll kai[1000001];\nll dp[1000001];\nll n;\n\nll mod_pow (ll x, ll y) {\n    ll ret = 1;\n    while (y) {\n        if (y&1) ret = ret*x%MOD;\n        x = x * x % MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nll conb (ll x, ll y) {\n    y = kai[y]*kai[x-y]%MOD;\n    y = mod_pow(y, MOD-2);\n    return kai[x]*y%MOD;\n}\n\nvoid init() {\n    kai[0] = 1;\n    for (ll i = 1; i <= SIZE; i++) kai[i] = kai[i-1]*i%MOD;\n}\n\nint main() {\n    init();\n    cin >> n;\n    if (n == 2) {\n        cout << 1 << endl;\n        return 0;\n    }\n    if (n == 3) {\n        cout << 4 << endl;\n        return 0;\n    }\n    ll ans = 0;\n    for (ll k = 2; k <= n-1; k++) {\n        if (k-1 < n-1-k) continue;\n        ll add = kai[k]*kai[n-1-k]%MOD;\n        add = (add * conb(k-1, n-1-k))%MOD;\n        dp[k] = add;\n        ans = (ans+(dp[k]-dp[k-1])*k)%MOD;\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=1000000007; //1000000000000000003LL\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//[HEAD_OF_JKI'S_HEADER_\n\n    //TYPEDEF\n    typedef long long lld;\n    typedef unsigned long long u64;\n    typedef pair<int, int> pii;\n\n    //COMPARE\n    template<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n    template<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n    template<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n    template<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n    //STL\n    template<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n    template<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n    template<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n    //BIT\n    inline int BINT(const int x){ return 1<<x; }\n    inline lld BLLD(const int x){ return 1LL<<x; }\n    inline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n    inline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n    template<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n    template<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n    //CONST VALUE\n    const double PI=acos(-1.0);\n    const double EPS=1e-5;\n\n    //CALCULATE\n    template<class T> inline T SQR(const T x){ return x*x; }\n    template<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n        if(!y)return 1;else if((y&1)==0){\n            return SQR(POW(x, y>>1));\n        }else return POW(x, y^1)*x;\n    }\n\n    //NUMBERIC\n    template<class T> inline T GCD(const T x, const T y){\n        if(x<0)return GCD(-x, y);\n        if(y<0)return GCD(x, -y);\n        return (!y)?x:GCD(y, x%y);\n    }\n    template<class T> inline T LCM(const T x, const T y){\n        if(x<0)return LCM(-x, y);\n        if(y<0)return LCM(x, -y);\n        return x*(y/GCD(x, y));\n    }\n    template<class T> inline T EEA(const T a, const T b, T &x, T &y){\n        /* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n        if(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n        if(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n        if(!b){\n            x=1; y=0; return a;\n        }else{\n            T d=EEA(b, a%b, x, y);\n            T t=x; x=y; y=t-(a/b)*y;\n            return d;\n        }\n    }\n    template<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n        vector<pair<T, int> > ret;\n        if(x<0)x=-x;\n        for (T i=2;x>1;){\n            if(x%i==0){\n                int count=0;\n                for(;x%i==0;x/=i)count++;\n                ret.push_back(MP(i, count));\n            }\n            i++;if(i>x/i)i=x;\n        }\n        return ret;\n    }\n    template<class T> inline int ISPRIME(const T x){\n        if(x<=1)return 0;\n        for(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n        return 1;\n    }\n    template<class T> inline T EULARFUNCTION(T x){\n        vector<pair<T, int> > f=FACTORIZE(x);\n        for(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n            x=x/it->first*(it->first-1);\n        }\n        return x;\n    }\n    template<class T> inline T INVERSEE(const T a, const T b=MOD){\n        T x, y;\n        EEA(a, b, x, y);\n        return x?x:1;\n    }\n    int *PRIMELIST(const int til, int *length=NULL){\n        int *foo=(int*)malloc(sizeof(int)*(til+1));\n        int len=0;\n        memset(foo, 0, sizeof(int)*(til+1));\n        for(int i=2; i<=til; i++){\n            if(!foo[i])foo[len++]=i;\n            for(int j=0; j<len && foo[j]<=til/i; j++){\n                foo[foo[j]*i]=1;\n                if(i%foo[j]==0)break;\n            }\n        }\n        if(length!=NULL){\n            *length=len;\n        }\n        foo[len++]=0;\n        foo=(int*)realloc(foo, sizeof(int)*len);\n        return foo;\n    }\n\n    //REMINDER-LIZATION\n    template<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n    template<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n    template<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n    template<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n    template<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n    template<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n    template<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n        if(y==0)return 1%m;else if((y&1)==0){\n            T1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n        }else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n    }\n    inline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n        MOD_STD(&x, m);\n        MOD_STD(&y, m);\n        if(x<y)swap(x, y);\n        lld z=0LL;\n        while(y>0){\n            if(y&1){\n                MOD_ADD(&z, x, m);\n            }\n            MOD_ADD(&x, x, m);\n            y>>=1;\n        }\n        return z;\n    }\n    inline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n        if(y==0LL)return 1LL%m;else if((y&1)==0LL){\n            lld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n        }else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n    }\n\n    //General\n    template<class T> class cycleq_t{\n        private:\n        size_t cnt, cap;\n        size_t lef, rig;\n        T *que;\n        public:\n        cycleq_t(const size_t size){\n            this->cap=size;\n            this->que=(T*)malloc(sizeof(T)*size);\n            this->clear();\n        }\n        ~cycleq_t(){\n            free(this->que);\n        }\n        inline void clear(){\n            this->lef=this->rig=0;\n            this->cnt=0;\n        }\n        inline void put(const T &obj){\n            assert(this->cnt<this->cap);\n            this->que[this->rig++]=obj;\n            if(this->rig==this->cap)\n                this->rig=0;\n            this->cnt++;\n        }\n        inline void put_back(const T &obj){\n            this->put(obj);\n        }\n        inline void put_front(const T &obj){\n            assert(this->cnt<this->cap);\n            this->lef--;\n            if(!~this->lef)\n                this->lef=this->cap-1;\n            this->que[this->lef]=obj;\n            this->cnt++;\n        }\n        inline T pop(){\n            assert(this->cnt>0);\n            T res=this->que[this->lef++];\n            if(this->lef==this->cap)\n                this->lef=0;\n            this->cnt--;\n            return res;\n        }\n        inline T pop_front(){\n            return this->pop();\n        }\n        inline T pop_back(){\n            assert(this->cnt>0);\n            this->rig--;\n            if(!~this->rig)\n                this->rig=this->cap-1;\n            this->cnt--;\n            return this->que[this->rig];\n        }\n        inline T get(int64_t offset=0){\n            if(offset>=0){\n                assert(offset<this->cnt);\n                offset+=this->lef;\n                if(offset>this->cap)\n                    offset-=this->cap;\n                return this->que[offset];\n            }else{\n                assert(offset>=-this->cnt);\n                offset+=this->rig;\n                if(offset<0)\n                    offset+=this->cap;\n                return this->que[offset];\n            }\n        }\n    };\n\n    //MATRIX\n    template<class T> class MATX{\n        private:\n            unsigned long hig, wid;\n            T *data;\n\n            void __init(){\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                memset(this->data, 0, sizeof(T)*this->hig*this->wid);\n            }\n\n        public:\n            MATX(){ \n                this->hig=this->wid=1;\n                __init();\n            }\n            MATX(const unsigned long _len){\n                this->hig=this->wid=_len;\n                __init();\n            }\n            MATX(const unsigned long _hig, const unsigned long _wid){\n                this->hig=_hig;\n                this->wid=_wid;\n                __init();\n            }\n            MATX(const MATX &rhs){\n                this->hig=rhs.hig;\n                this->wid=rhs.wid;\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n            }\n            ~MATX(){\n                free(this->data);\n            }\n\n            T & operator()(const unsigned long x, const unsigned long y){\n                if(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n                return this->data[x*this->wid+y];\n            }\n\n            T * operator[](const unsigned long x){\n                if(x>=this->hig)return (T*)NULL;\n                return this->data+(x*this->wid);\n            }\n\n            MATX & operator=(const MATX &rhs){\n                if(this->hig!=rhs.hig || this->wid!=rhs.wid){\n                    free(this->data);\n                    this->hig=rhs.hig;\n                    this->wid=rhs.wid;\n                    this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                }\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n                return *this;\n            }\n\n            const MATX operator+(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]+=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator-(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]-=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator*(const MATX &opn) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.hig);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            ret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n                return ret;\n            }\n\n            const MATX mul(const MATX &opn) const{ return *this*opn; }\n            template<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.wid);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            MOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n                return ret;\n            }\n\n            MATX & operator +=(const MATX &rhs){\n                *this=*this+rhs;\n                return *this;\n            }\n            MATX & operator -=(const MATX &rhs){\n                *this=*this-rhs;\n                return *this;\n            }\n            MATX & operator *=(const MATX &rhs){\n                *this=*this*rhs;\n                return *this;\n            }\n\n            const MATX pow(const unsigned long p) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret*=buff;\n                    buff*=buff;\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n            template<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret=ret.mul(buff, m);\n                    buff=buff.mul(buff, m);\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n\n\n            const T at(const unsigned long x, const unsigned long y) const{\n                if(x>=this->hig || y>=this->wid)return 0;\n                return this->data[x*wid+y];\n            }\n\n            void show() const{\n                for(unsigned long x=0; x<this->hig; x++){\n                    for(unsigned long y=0; y<this->wid; y++)\n                        cout<<this->at(x, y)<<\" \";\n                    cout<<endl;\n                }\n            }\n\n            void set_one(){\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=(x==y)?1:0;\n            }\n\n    };\n\n    //Complex\n    template<class T> class complex_t{\n        public:\n        T r, i;//real part & imaginary part; x+yi\n        complex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n        complex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n        complex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n        complex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n    };\n\n    template<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n        for(int i=1, j=len>>1; i<len-1; i++){\n            if(i<j)swap(f[i], f[j]);\n            int k=len>>1;\n            while(j>=k){\n                j-=k;\n                k>>=1;\n            }\n            if(j<k)j+=k;\n        }\n        for(int h=2; h<=len; h<<=1){\n            complex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n            for(int i=0; i<len; i+=h){\n                complex_t<T> wm(1.0, 0.0);\n                for(int j=i; j<i+(h>>1); j++){\n                    complex_t<T> u = f[j];\n                    complex_t<T> t = wm*f[j+(h>>1)];\n                    f[j] = u+t;\n                    f[j+(h>>1)] = u-t;\n                    wm = wm*wn;\n                }\n            }\n        }\n        if(!is_dft){\n            for(int i=0; i<len; i++)\n                f[i].r/=len*1.0;\n        }\n    }\n\n    //MILLERRABIN\n    class MILLERRABIN{\n        private:\n        static const int prime_table[12];\n        int witness(lld a, lld d, lld s, lld n){\n            lld r=MODL_POW(a, d, n);\n            if(r==1 || r==n-1)return 0;\n            for(int i=0; i<s-1; i++){\n                r = MODL_MUL(r, r, n);\n                if(r==1)return 1;\n                if(r==n-1)return 0;\n            }\n            return 1;\n        }\n        public:\n        int test(const lld n){\n            if(n<=2LL) return 0;\n            lld p=n-1LL, s=0LL;\n            while(!(p&1)){ p>>=1;s++; }\n            for(int i=0; i<12 && this->prime_table[i]<n; i++){\n                if(witness(this->prime_table[i], p, s, n))return 0;\n            }\n            return 1;\n        }\n    };\n    const int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n    //Computational Geometry\n\n    template<class T> inline int fsign(const T x){\n        if(x>-eps && x<eps)return 0;\n        return (x<0.0)?-1:1;\n    }\n\n    template<class T> class point_t{\n        public:\n        T x, y;\n        point_t (){\n            this->x=0.0;\n            this->y=0.0;\n        }\n        point_t (const T _x, const T _y){\n            this->x=_x;\n            this->y=_y;\n        }\n        point_t operator - (const point_t &rhs) const{\n            return point_t(this->x-rhs.x, this->y-rhs.y);\n        }\n        T operator ^ (const point_t &rhs) const{\n            return this->x*rhs.y - this->y*rhs.x;\n        }\n        T operator * (const point_t &rhs) const{\n            return this->x*rhs.x + this->y*rhs.y;\n        }\n        bool operator < (const point_t &rhs) const{\n            if(fsign(this->y-rhs.y)!=0)\n                return fsign(this->y-rhs.y)<0;\n            return fsign(this->x-rhs.x)<0;\n        }\n        T cross(const point_t &p, const point_t &q) const{\n            return (p-*this)^(q-*this);\n        }\n        void rotate(const double radian){\n            T x0=x, y0=y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr;\n            y=x0*sinr+y0*cosr;\n        }\n        void rotate(const point_t &p, const double radian){\n            T x0=x-p.x, y0=y-p.y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr+p.x;\n            y=x0*sinr+y0*cosr+p.y;\n        }\n        T dist2(const point_t &lhs, const point_t &rhs) const{\n            return (lhs-rhs)*(lhs-rhs);\n        }\n        T dist2(const point_t &rhs) const{\n            return (*this-rhs)*(*this-rhs);\n        }\n        T dist(const point_t &lhs, const point_t &rhs) const{\n            return sqrt((lhs-rhs)*(lhs-rhs));\n        }\n        T dist(const point_t &rhs) const{\n            return sqrt((*this-rhs)*(*this-rhs));\n        }\n    };\n\n    template<class T> class segment_t{\n        public:\n        point_t<T> p, q;\n        segment_t (){\n            this->p.x=this->p.y=0.0;\n            this->q.x=this->q.y=0.0;\n        }\n        template<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n            this->p.x=_p.x;\n            this->p.y=_p.y;\n            this->q.x=_q.x;\n            this->q.y=_q.y;\n        }\n        segment_t (const T px, const T py, const T qx, const T qy){\n            this->p.x=px;\n            this->p.y=py;\n            this->q.x=qx;\n            this->q.y=qy;\n        }\n        T length() const{\n            return this->p.dist(this->q);\n        }\n        T length2() const{\n            return this->p.dist2(this->q);\n        }\n        int contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n            if(ignore_endpoint){\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n            }else{\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n            }\n        }\n        int intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n            if(!ignore_endpoint){\n                if(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n                    return 1;\n            }\n            return fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n                && fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n        }\n        int intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n            return this->intersection(*this, rhs, ignore_endpoint);\n        }\n    };\n\n    #ifndef __APPLE__\n    template<class T> static int compare_pas(const void *x, const void *y, void *z){\n    #else\n    template<class T> static int compare_pas(void *z, const void *x, const void *y){\n    #endif\n        const point_t<T> *p1 = (point_t<T>*)x;\n        const point_t<T> *p2 = (point_t<T>*)y;\n        const point_t<T> *p0 = (point_t<T>*)z;\n        int sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n        if(sgn!=0)return -sgn;\n        return fsign(p0->dist2(*p1)-p0->dist2(*p2));\n    }\n    template<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n        int p=0;\n        for(int i=1; i<n; i++){\n            if(pnts[p]<pnts[i])p=i;\n        }\n        swap(pnts[0], pnts[p]);\n        #ifndef __APPLE__\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n        #else\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), pnts, compare_pas<T>);\n        #endif\n    }\n\n    template<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n        polar_angle_sort(pnts, n);\n        m=0;\n        if(n<3)return;\n        idx[m++]=0;\n        idx[m++]=1;\n        for(int i=2; i<n; i++){\n            while(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n            idx[m++]=i;\n        }\n    }\n\n    //Graph\n    template<class T> class maxflow_c{\n        private:\n        size_t capv, cape;\n        size_t cntv, cnte;\n        struct mf_edge_t;\n        struct mf_vertex_t{\n            mf_edge_t *head, *hold;\n            size_t idx, hig;\n        } *vertex, **vhead, **vtail, **vque;\n        struct mf_edge_t{\n            mf_vertex_t *src, *dst;\n            mf_edge_t *nxt, *rsv;\n            T cap, cur;\n        } *edge_pool, *edge_tail, **esup;\n        struct dncnode_t{\n            mf_vertex_t *vtx;\n            T precap, reflux;\n        } *dinic_stack_pool;\n        size_t *dcnt;\n        size_t higlev(size_t src, size_t trm, const int reverse=0){\n            if(reverse)\n                swap(src, trm);\n            if(this->vque==NULL)\n                this->vque=(mf_vertex_t**)malloc(sizeof(mf_vertex_t*)*this->capv);\n            size_t lef=0, rig=0;\n            for(mf_vertex_t **vtxp=this->vhead; vtxp!=this->vtail; vtxp++)\n                (*vtxp)->hig=numeric_limits<size_t>::max();\n            this->vertex[src].hig=0;\n            this->vque[rig++]=&this->vertex[src];\n            this->vertex[trm].hig=numeric_limits<size_t>::max();\n            for(; lef<rig; lef++){\n                mf_vertex_t *vtx=this->vque[lef];\n                for(mf_edge_t *edge=vtx->head; edge!=NULL; edge=edge->nxt){\n                    if(!reverse){\n                        if(edge->cur<edge->cap && edge->dst->hig>vtx->hig+1){\n                            edge->dst->hig=vtx->hig+1;\n                            this->vque[rig++]=edge->dst;\n                        }\n                    }else{\n                        if(edge->rsv->cur<edge->rsv->cap && edge->dst->hig>vtx->hig+1){\n                            edge->dst->hig=vtx->hig+1;\n                            this->vque[rig++]=edge->dst;\n                        }\n                    }\n                }\n            }\n            this->vque[rig++]=NULL;\n            return this->vertex[trm].hig;\n        }\n        T isap_augment(const size_t src, const size_t trm){\n            T inc=numeric_limits<T>::max();\n            for(size_t i=trm; i!=src; i=this->esup[i]->src->idx){\n                UPDMIN(inc, this->esup[i]->cap-this->esup[i]->cur);\n            }\n            for(size_t i=trm; i!=src; i=this->esup[i]->src->idx){\n                this->esup[i]->cur+=inc;\n                this->esup[i]->rsv->cur-=inc;\n            }\n            return inc;\n        }\n        size_t isap_retreat(size_t &i, const size_t src){\n            size_t best=numeric_limits<size_t>::max();\n            for(mf_edge_t *edge=this->vertex[i].head; edge!=NULL; edge=edge->nxt){\n                if(edge->cur<edge->cap){\n                    UPDMIN(best, edge->dst->hig+1);\n                }\n            }\n            size_t rep=--this->dcnt[this->vertex[i].hig];\n            this->vertex[i].hig=best;\n            if(best<this->cntv){\n                this->dcnt[best]++;\n            }\n            if(i!=src)\n                i=this->esup[i]->src->idx;\n            return rep;\n        }\n        public:\n        maxflow_c(const size_t numv, const size_t nume){\n            this->capv=numv;\n            this->cape=nume;\n            this->vertex=(mf_vertex_t*)malloc(sizeof(mf_vertex_t)*numv);\n            for(size_t i=0; i<numv; i++){\n                this->vertex[i].idx=i;\n            }\n            this->vhead=(mf_vertex_t**)malloc(sizeof(mf_vertex_t*)*numv);\n            this->vtail=this->vhead;\n            this->vque=NULL;\n            this->edge_pool=(mf_edge_t*)malloc(sizeof(mf_edge_t)*(nume<<1));\n            this->dinic_stack_pool=NULL;\n            this->esup=NULL;\n            this->dcnt=NULL;\n            this->reset();\n        };\n        ~maxflow_c(){\n            if(this->dcnt!=NULL)\n                free(this->dcnt);\n            if(this->esup!=NULL)\n                free(this->esup);\n            if(this->dinic_stack_pool!=NULL)\n                free(this->dinic_stack_pool);\n            free(this->edge_pool);\n            if(this->vque!=NULL)\n                free(this->vque);\n            free(this->vhead);\n            free(this->vertex);\n        }\n        void reset(){\n            for(size_t i=0; i<this->capv; i++)\n                this->vertex[i].head=NULL;\n            this->vtail=this->vhead;\n            this->edge_tail=this->edge_pool;\n            this->cntv=0;\n            this->cnte=0;\n        }\n        void add_edge(const size_t u, const size_t v, const T c, const T r=0){\n            assert(u<this->capv && v<this->capv);\n            assert(this->cnte<this->cape);\n            this->edge_tail->nxt=this->vertex[u].head;\n            this->edge_tail->rsv=this->edge_tail+1;\n            this->edge_tail->src=&this->vertex[u];\n            this->edge_tail->dst=&this->vertex[v];\n            this->edge_tail->cap=c;\n            this->edge_tail->cur=0;\n            if(this->vertex[u].head==NULL){\n                *this->vtail++=&this->vertex[u];\n                this->cntv++;\n            }\n            this->vertex[u].head=this->edge_tail++;\n            this->edge_tail->nxt=this->vertex[v].head;\n            this->edge_tail->rsv=this->edge_tail-1;\n            this->edge_tail->src=&this->vertex[v];\n            this->edge_tail->dst=&this->vertex[u];\n            this->edge_tail->cap=r;\n            this->edge_tail->cur=0;\n            if(this->vertex[v].head==NULL){\n                *this->vtail++=&this->vertex[v];\n                this->cntv++;\n            }\n            this->vertex[v].head=this->edge_tail++;\n            this->cnte++;\n        }\n        T dinic(const size_t src, const size_t trm){\n            assert(src<this->capv && trm<this->capv && src!=trm);\n            T foo=0;\n            if(this->dinic_stack_pool==NULL)\n                this->dinic_stack_pool=(dncnode_t*)malloc(sizeof(dncnode_t)*this->capv);\n            while(higlev(src, trm)<numeric_limits<size_t>::max()){\n                for(size_t i=0; this->vque[i]!=NULL; i++){\n                    this->vque[i]->hold=this->vque[i]->head;\n                }\n                dncnode_t *top=this->dinic_stack_pool;\n                top->vtx=&this->vertex[src];\n                top->precap=numeric_limits<T>::max();\n                top->reflux=0;\n                while(this->vertex[src].hold!=NULL){\n                    if(top->vtx->idx!=trm && top->vtx->hold!=NULL && top->vtx->hold->cur<top->vtx->hold->cap && top->vtx->hold->src->hig+1==top->vtx->hold->dst->hig){\n                        dncnode_t *prv=top++;\n                        top->vtx=prv->vtx->hold->dst;\n                        top->precap=MIN(prv->precap-prv->reflux, prv->vtx->hold->cap-prv->vtx->hold->cur);\n                        top->reflux=0;\n                    }else if(top->vtx->idx==trm){\n                        T inc=top->precap;\n                        foo+=inc;\n                        while(top->precap==top->reflux+inc){\n                            inc+=top->reflux;\n                            top--;\n                            top->vtx->hold->cur+=inc;\n                            top->vtx->hold->rsv->cur-=inc;\n                        }\n                        top->reflux+=inc;\n                    }else{\n                        if(top->vtx->hold==NULL){\n                            T ref=top->reflux;\n                            top--;\n                            top->vtx->hold->cur+=ref;\n                            top->vtx->hold->rsv->cur-=ref;\n                            top->reflux+=ref;\n                        }\n                        top->vtx->hold=top->vtx->hold->nxt;\n                    }\n                }\n            }\n            return foo;\n        }\n        T isap(const size_t src, const size_t trm){\n            assert(src<this->capv && trm<this->capv && src!=trm);\n            T foo=0;\n            if(higlev(src, trm, 1)<numeric_limits<size_t>::max()){\n                if(this->dcnt==NULL)this->dcnt=(size_t*)malloc(sizeof(size_t)*this->capv);\n                if(this->esup==NULL)this->esup=(mf_edge_t**)malloc(sizeof(mf_edge_t*)*this->capv);\n                for(size_t i=0; i<this->cntv; i++)this->dcnt[i]=0;\n                for(size_t i=0; this->vque[i]!=NULL; i++){\n                    this->vque[i]->hold=this->vque[i]->head;\n                    this->dcnt[this->vque[i]->hig]++;\n                }\n                size_t i=src;\n                while(this->vertex[src].hig<this->cntv){\n                    mf_edge_t *edge=this->vertex[i].hold;\n                    while(edge!=NULL && !(edge->cur<edge->cap && edge->src->hig==edge->dst->hig+1)){\n                        edge=edge->nxt;\n                    }\n                    if(edge!=NULL){\n                        this->vertex[i].hold=edge;\n                        this->esup[edge->dst->idx]=edge;\n                        i=edge->dst->idx;\n                        if(i==trm){\n                            foo+=isap_augment(src, trm);\n                            i=src;\n                        }\n                    }else{\n                        this->vertex[i].hold=this->vertex[i].head;\n                        if(isap_retreat(i, src)==0)\n                            break;\n                    }\n                }\n            }\n            return foo;\n        }\n    };\n\n//]TAIL_OF_JKI'S_HEADER\n\nint p[1100000];\n\nint main(){\n    p[0]=1;\n    for(int i=1; i<=1000000; i++)p[i]=MOD_MUL(p[i-1], i);\n    int n;\n    while(scanf(\"%d\", &n)!=EOF){\n        n--;\n        int neg=0;\n        for(int i=n-1; i>=2; i--){\n            MOD_ADD(&neg, MOD_MUL(MOD_MUL(i, i-1), p[n-3]));\n        }\n        MOD_MUL(&neg, n-2);\n        int foo=MOD_ADD(MOD_MUL(p[n], n), -neg);\n        printf(\"%d\\n\", MOD_STD(foo));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nostream &operator<<(ostream &os, const vector<lint> &a) {\n\tos<<\"[\";\n\trep(i,a.size()){\n\t\tos<<a[i];\n\t\tif(i<a.size()-1) os<<\",\";\n\t}\n\tos<<\"]\";\n\treturn os; \n}\nvector<lint> zyo,rz;\nlint mo=1000000007;\nlint extgcd(lint a, lint b, lint &x, lint &y) {\n  lint g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nlint invMod(lint a, lint m) {\n  lint x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;return 0;\n}\nlint co(int a,int b){\n\tif(a<0 || b<0 || a<b) return 0;\n\treturn ((zyo[a]*rz[b])%mo*rz[a-b])%mo;\n}\nlint cal(int n,int x){\n\tif(x*2>=n) return 0;\n\treturn (zyo[n-x]*zyo[n-1-x])%mo*rz[n-1-x*2]%mo;\n}\nint main()\n{\n\tlint out=0;int n;\n\tcin>>n;n--;\n\tif(n<2){\n\t\tcout<<1<<endl;return 0;\n\t}\n\tzyo.pb(1);rep(i,1001001) zyo.pb((zyo[i]*(i+1))%mo);\n\trep(i,1001001) rz.pb(invMod(zyo[i],mo));\n\tvector<lint> v;\n\trep(i,(n+1)/2) v.pb(cal(n,i));\n\t//cout<<v<<endl;\n\trep(i,v.size()-1) v[i]-=v[i+1];\n\trep(i,v.size()){\n\t\tout+=(n-i)*v[i];out%=mo;\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace __init {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n#include \"../debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\ntemplate <ll MOD>\nclass Combination {\nprivate:\n    template <typename T> using V = vector<ll>;\n    ll N;\n    V<ll> factv, rfactv;\n\npublic:\n    /*\n     * MOD must be a prime number.\n     */\n    Combination<MOD> (ll N)\n        : N(N), \n          factv(N + 1, 1),\n          rfactv(N + 1)\n    {\n        for(ll i = 1; i <= N; i++) {\n            factv[i] = factv[i - 1] * i % MOD;\n        }\n        for(ll i = 0; i <= N; i++) {\n            rfactv[i] = pow(factv[i], MOD - 2);\n        }\n    }\n\n    ll fact(ll n) {\n        return factv[n];\n    }\n\n    ll rfact(ll n) {\n        return rfactv[n];\n    }\n\n    ll pow(ll a, ll b) {\n        return b ? (b & 1 ? a : 1) * pow(a * a % MOD, b / 2) % MOD : 1;\n    }\n\n    ll comb(ll n, ll k) {\n        if(n == 0) return 1;\n        return factv[n] * rfactv[n - k] % MOD * rfactv[k] % MOD;\n    }\n};\n\nconst ll mod = 1e9 + 7;\nCombination<mod> comb(1e6 + 10);\n\nint main() {\n    ll N;\n    cin >> N;\n\n    if(N == 2) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    ll ans = 0;\n    ll dist = N - 2;\n    ll pperm = 0;\n    ll machine = N - 1;\n    for(ll two = dist / 2; two >= 0; two--) {\n        ll one = dist - two * 2;\n        ll distr = one + two;\n        ll rest = machine - (distr + 1);\n        ll perm = comb.comb(distr, one) * comb.fact(distr + 1) % mod * comb.fact(rest) % mod;\n        (perm += mod - pperm) %= mod;\n        (pperm += perm) %= mod;\n        ll score = perm * (distr + 1) % mod;\n        DEBUG(one, two, distr, rest, perm, score);\n        (ans += score) %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nconstexpr int MN = 200002;\nconstexpr int MOD = 1e9+7;\n\nll fact[MN] = { 1 }, ifact[MN] = { 1 };\n\ninline ll pw(ll base, ll exp) {\n\tll res = 1;\n\twhile (exp) {\n\t\tif (exp & 1) (res *= base) %= MOD;\n\t\texp >>= 1, (base *= base) %= MOD;\n\t}\n\treturn res;\n}\n\ninline ll inv(ll x) { return pw(x, MOD - 2); }\n\ninline ll nCr(int n, int k) { return fact[n] * ifact[k] % MOD * ifact[n - k] % MOD; }\n\nint main() {\n    if (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    int N; cin >> N;\n\n    for (int i = 0; i < N; ++i) fact[i + 1] = (i + 1ll) * fact[i] % MOD, ifact[i + 1] = inv(fact[i + 1]);\n    \n    ll sum = 0, ans = 0;\n    for (int i = N/2; i < N; ++i) {\n        ll tmp = nCr(i-1, N-i-1)*fact[i]%MOD*fact[N-i-1]%MOD;\n        (ans += i*(tmp-sum)+MOD) %= MOD;\n        sum = tmp;\n    }\n    cout << ans;\n\n    /*for (int N = 2; N <= 10; ++N) {\n        //int N = 7;\n        vector<int> P(N-1);\n        iota(begin(P), end(P), 0);\n        vector<int> ans(N-1);\n        do {\n            vector<bool> A(N, 0);\n            ll cnt = 0;\n            for (int i = 0; i < N-1; ++i) {\n                A[P[i]] = A[P[i]+1] = 1;\n                if (count(begin(A), end(A), 1) == N) {\n                    ++ans[i];\n                    if (i == 3) {\n                        for (int x : P) cout << x << ' ';\n                        cout << '\\n';\n                    }\n                    break;\n                }\n            }\n        } while (next_permutation(begin(P), end(P)));\n        for (int x : ans) cout << setw(6) << x << ' ';\n        cout << '\\n';\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifndef LOCAL\n#define endl '\\n'\n#endif\n\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define rf(i, a, b) for(int i = a; i >= b; i--)\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define sz(x) (int)x.size()\n#define lb lower_bound\n#define ub upper_bound\n\ntypedef long long ll;\ntypedef long double f80;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint pct(int x) { return __builtin_popcount(x); }\nint pct(ll x) { return __builtin_popcountll(x); }\nint bt(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\nint bt(ll x) { return 63 - __builtin_clzll(x); } // floor(log2(x))\nint cdiv(int a, int b) { return a / b + !(a < 0 || a % b == 0); }\nll cdiv(ll a, ll b) { return a / b + !(a < 0 || a % b == 0); }\nint nxt_C(int x) { int c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\nll nxt_C(ll x) { ll c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\n\nvector<int> get_bits(int mask) {\n\tvector<int> bb;\n\twhile(mask) { int b = bt(mask); bb.pb(b); mask ^= (1 << b); }\n\treverse(all(bb));\n\treturn bb;\n}\n\nint get_mask(vector<int> v) {\n\tint mask = 0;\n\tfor(int x : v) { mask ^= (1 << x); }\n\treturn mask;\n}\n\ntemplate<typename T>\nvoid uniq(vector<T> &v) { sort(all(v)); v.resize(unique(all(v)) - v.begin()); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll rand(ll l, ll r){\n\tuniform_int_distribution<ll> uid(l, r);\n\treturn uid(rng);\n}\n\nvoid sc() {}\n\ntemplate <typename Head, typename... Tail>\nvoid sc(Head &H, Tail &... T) { cin >> H; sc(T...); }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[L:\" << __LINE__ << \"][\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// #ifndef LOCAL\n// string to_string(__int128 x) {\n// \tstring s = \"\";\n// \tbool neg = 0;\n// \tif(x < 0) { s += \"-\"; neg = 1; x = -x; }\n// \tif(!x) s += '0';\n// \twhile(x) {\n// \t\tint rem = x % 10;\n// \t\ts += to_string(rem);\n// \t\tx /= 10;\n// \t}\n// \treverse(s.begin() + neg, s.end());\n// \treturn s;\n// }\n// #endif\n\nconst int mod = 1e9 + 7; // 998244353;\n\nint pwr(int a,ll b) {\n\tint ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = (ans * 1LL * a) % mod;\n\t\ta = (a * 1LL * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\n/*\n\tLookout for overflows!!\n\tCheck array sizes!!\n\tClear before test cases!!\n\tUse the correct modulo!!\n\tCheck for corner cases!!\n\tAre you forgetting something?!\n\tRead problem statement carefully!!!\n*/\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\n*/\n\nconstexpr int md = 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint pwr(Mint a, ll k) {\n\tMint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = ans * a;\n\t\ta = a * a;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int N = 1e6 + 5;\nMint fact[N], ifact[N];\n\nMint get_c(int n,int k) {\n    if(n < k || k < 0) return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n}\n\nvoid solve() {\n    fact[0] = 1;\n    fr(i, 1, N - 1)\n        fact[i] = i * fact[i - 1];\n    ifact[N - 1] = 1 / fact[N - 1];\n    rf(i, N - 2, 0) {\n        ifact[i] = ifact[i + 1] * (i + 1);\n    }\n    int n;\n    sc(n);\n    if(n == 2) {\n        cout << 1 << endl;\n        return;\n    }\n    Mint ans = 0;\n    fr(c, 1, n) {\n        ans += c * (get_c(n - 2 - c, c - 2) + 2 * get_c(n - 2 - c, c - 1)) * fact[c - 1] * fact[n - 1 - c] * (n - c);\n    }\n    cout << ans;\n}\n\nsigned main() {\n\tios :: sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t = 1;\n\t// cin >> t;\n\tfor(int tt = 1; tt <= t; tt++) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define fo(i, n) for(int i = 1; i <= (n); i ++)\n#define out(x) cerr << #x << \" = \" << x << \"\\n\"\n#define type(x) __typeof((x).begin())\n#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); ++ it)\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0;char c = getchar(); bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\ntemplate<typename tp> inline void arr(tp *a, int n) {\n  for(int i = 1; i <= n; i ++)\n    cout << a[i] << \" \";\n  puts(\"\");\n}\nconst int mo = 1e9 + 7;\nconst int N = 1e6 + 233;\nint fac[N], inv[N], fac_inv[N];\nint ans = 0, n;\ninline int C(int n, int m) {\n  return fac[n] * fac_inv[m] % mo * fac_inv[n - m] % mo;\n}\n\nmain(void) {\n  read(n); int has = 0;\n  fac[0] = fac[1] = 1; for(int i = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mo;\n  inv[1] = 1; for(int i = 2; i < N; i ++) inv[i] = (mo - (mo / i) * inv[mo % i] % mo) % mo;\n  fac_inv[0] = fac_inv[1] = 1; for(int i = 2; i < N; i ++) fac_inv[i] = fac_inv[i - 1] * inv[i] % mo;\n  // arr(inv, 10); arr(fac, 10); arr(fac_inv, 10);\n  for(int add1 = 0; add1 <= n - 1; add1 ++) {\n    if((n - add1) % 2) continue;\n    int add2 = (n - add1) / 2 - 1;\n    int res = C(add2 + add1, add1) * \n      fac[add2 + add1 + 1] % mo * fac[n - 1 - (add2 + add1 + 1)] % mo;\n    res -= has; if(res < 0) res += mo;\n    has += res; has %= mo;\n    // out(res); cout << add1 << \" \" << add2 << \"\\n\";\n    (ans += res * (add2 + add1 + 1) % mo) %= mo;\n  }\n  cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\nusing namespace std;\nint main(void){\n    int n=0,i=1,buf1=0,buf3=0,buf4=0;\n    cin >> n;\n    if(n>1000000||n<2){\n    \texit(0);\n    }\n    buf3=n;\n    n=n-1;\n    for(int f=1;f<buf3;f++){\n    \ti=i*f;\n    }\n    if(buf3%2==0){\n        buf1=(i-2)*3+(2*2);\n    }\n    else{\n        buf1=(i-(buf3%2+buf3/2))*n;\n    }\n    cout  << buf1%(1000000000+7);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long int\nusing namespace std;\n\nll mod = 1000000007;\n\nll factorials[1000005];\nll inv[1000005];\nll dp[1000005];\n\nll mod_pow(ll k, ll pow) {\n  ll ans = 1;\n  while (pow > 0) {\n    if (pow & 1) ans = ans * k % mod;\n    k = k * k % mod;\n    pow >>= 1;\n  }\n  return ans;\n}\n\nint main() {\n  ll n;\n  cin >> n;\n  factorials[0] = 1;\n  inv[0] = 1;\n\n  for (int i = 1; i < 1000005; i++) {\n    factorials[i] = (factorials[i - 1] * i) % mod;\n    inv[i] = (inv[i - 1] * mod_pow(i, mod - 2)) % mod;\n  }\n  \n  ll min_score = (n + 1) / 2;\n  ll max_score = n - 1;\n  ll ans = 0;\n  dp[min_score - 1] = 0;\n  for (int i = min_score; i <= max_score; i++) {\n    ll cnk = ((factorials[i - 1] * inv[n - 1 - i] % mod) * inv[2 * i - n] % mod) % mod;\n    ll add = (cnk * factorials[i] % mod) * factorials[n - 1 - i] % mod;\n    dp[i] = add;\n    ans += (((dp[i] - dp[i - 1] + mod) % mod) * i) % mod;\n  }\n  cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T,typename U>bool chmin(T& a,const U& b){return a>b?(a=b,1):0;}\ntemplate<typename T,typename U>bool chmax(T& a,const U& b){return a<b?(a=b,1):0;}\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<uint M>\nstruct modint{\n\tuint val;\n\tmodint(uint x=0):val((x%M+M)%M){}\n\tmodint pow(uint r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tll x=1;\n\t\tfor(ll a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn (x+M)%M;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n\texplicit operator uint()const{return val;}\n};\n\ntemplate<uint M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<uint M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<uint M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<uint M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<uint M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<uint M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<uint M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nstruct Factorial{\n\tvector<mint> data;\n\tFactorial(int size):data(size){\n\t\tdata[0]=1;\n\t\trepi(i,1,size)\n\t\t\tdata[i]=mint(i)*data[i-1];\n\t}\n\tmint Fact(int n){\n\t\treturn data[n];\n\t}\n\tmint Choose(int n,int r){\n\t\treturn data[n]/(data[n-r]*data[r]);\n\t}\n};\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tFactorial fact(1000000);\n\n\tfor(int n;cin>>n&&n;){\n\t\tif(n==2){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<mint> cs(n);\n\t\trepi(i,2,n){\n\t\t\tif(i-1<n-1-i)\n\t\t\t\tcontinue;\n\t\t\tcs[i]=fact.Fact(i)*fact.Fact(n-1-i)*fact.Choose(i-1,n-1-i);\n\t\t}\n\t\tmint res=0;\n\t\trepi(i,1,n)\n\t\t\tres+=mint(i)*(cs[i]-cs[i-1]);\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define N 1000001\n#define int long long\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\t\n}\nusing namespace std;\nconst int mod=1000000007;\nint n,ans,jc[N],sum[N],inv[N];\nmain()\n{\n\tre(n);\t\n\tjc[0]=1;\n\tinv[0]=inv[1]=1;\n\tfor(int i=1;i<=n;++i)jc[i]=i*jc[i-1]%mod;\n\tfor(int i=2;i<=n;++i)\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=(n+1)/2,x=(n-1)/2,y=1,j=jc[x];i<n;++i)\t\n\t{\n\t\tsum[i]=j*jc[i]%mod;\n\t\tans=(ans+i*(sum[i]-sum[i-1]))%mod;\n\t\tif(i+2<n)j=1ll*j*(++x)%mod;\n\t\tif(y<x)j=1ll*j*inv[++y]%mod;\n\t\tif(i+2<n && n-3-y>(n-i-2)*2-1)j=1ll*j*inv[++y]%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1000050,mo=1e9+7;\nint fap(int a,int b){\n    int s=1;\n    for (; b; b>>=1,a=1ll*a*a%mo)\n\tif (b&1) s=1ll*s*a%mo;\n    return s;\n}\nint ml[N],np[N],f[N];\nint C(int n,int m){\n    if (n<m) return 0;\n    return 1ll*ml[n]*np[m]%mo*np[n-m]%mo;\n}\nint main(){\n    int n; cin>>n;\n    ml[0]=np[0]=1;\n    for (int i=1; i<=n; ++i) ml[i]=1ll*i*ml[i-1]%mo;\n    np[n]=fap(ml[n],mo-2);\n    for (int i=n-1; i>=1; --i) np[i]=1ll*(i+1)*np[i+1]%mo;\n    for (int i=1; i<n; ++i) f[i]=1ll*C(i-1,n-i-1)*ml[i]%mo*ml[n-i-1]%mo;\n    for (int i=n-1; i>1; --i) f[i]=(mo+f[i]-f[i-1])%mo;\n    int ans=0;\n    for (int i=1; i<=n; ++i) (ans+=1ll*i*f[i]%mo)%=mo;\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e6 + 10;\nconst ll mod = 1e9 + 7;\nint n;\nll ans;\nll fac[maxn], inv[maxn], facinv[maxn], bin[maxn];\nvoid pre()\n{\n\tfac[0] = 1; for(int i = 1; i < maxn; ++i) fac[i] = fac[i - 1] * i % mod;\n\tinv[1] = 1; for(int i = 2; i < maxn; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\tfacinv[0] = 1; for(int i = 1; i < maxn; ++i) facinv[i] = facinv[i - 1] * inv[i] % mod;\n\tbin[0] = 1; for(int i = 1; i < maxn; ++i) bin[i] = bin[i - 1] * 2 % mod;\n}\nll C(int n, int m) { return n < m ? 0 : fac[n] * facinv[m] % mod * facinv[n - m] % mod;}\nll f(ll r, ll x)\n{\n\tll t = n - r - x + 1;\n\tif(t > r - 1 || t < 1) return 0;\n\treturn C(r - 1, 1) * C(r - 1 - 1, n - r - x) % mod;\n}\nll g(ll r, ll x)\n{\n\tll t = x - r;\n\treturn C(r - 1, t);\n}\nll fact(ll n) { return n < 0 ? 1 : fac[n];}\nint main()\n{\n\tpre();\n\tscanf(\"%d\", &n);\n\tif(n == 2) { puts(\"1\"); return 0;}\n\tfor(int i = 1; i <= n - 1; ++i) \n\t{\n\t\tll tmp = (f(i, 3) * 2 + f(i, 4) + g(i, n - 2) * 2 + g(i, n - 3) * 2) % mod;\n\t\tans = (ans + tmp * fact(i + 1) % mod % mod * fact(n - 1 - i - 1) % mod) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(V<ll> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(V<t2> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(V<t3> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(V<t4> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(V<ll> &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\ntemplate <typename T>\nvoid _debug_print(T x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n\n#define MOD   (1000000007LL)\n// #define MOD   (998244353LL)\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n    }\n\n    perm_invs[size-1] = mod_inv(perms[size-1], mod);\n    rrep (i, size-1) {\n        perm_invs[i] = perm_invs[i+1LL] * (i+1LL);\n        perm_invs[i] %= mod;\n    }\n}\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if !DEBUG\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n\n    if (n == 2) {\n        cout << 1 << endl;\n        return;\n    }\n    if (n == 3) {\n        cout << 4 << endl;\n        return;\n    }\n\n    S ll perms[2000006];\n    S ll perm_invs[2000006];\n    make_perms(perms, perm_invs, 2000006, MOD);\n\n    ll ans = 0;\n    ll total = 0;\n    srep (cnt, 2, n) {\n        ll spaces = cnt - 1LL;\n        ll laters = n - 1LL - cnt;\n        if (spaces < laters) continue;\n\n        ll new_total = 1LL;\n\n        new_total *= perms[spaces];\n        new_total %= MOD;\n        new_total *= perm_invs[laters];\n        new_total %= MOD;\n        new_total *= perm_invs[spaces-laters];\n        new_total %= MOD;\n\n        new_total *= perms[cnt];\n        new_total %= MOD;\n\n        new_total *= perms[laters];\n        new_total %= MOD;\n\n        ll diff = new_total - total;\n        if (diff < 0) diff += MOD;\n        ans += diff * cnt;\n        ans %= MOD;\n\n        total = new_total;\n    }\n\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T, class S> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T> inline vector<T> cinv2(ll N){\n\tvector<T> v(N); REP(i, N){ll a, b; cin>>a>>b; v[i]={a,b};} return move(v);}\ntemplate<class T,class S,class R> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv3(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c; cin>>a>>b>>c; v[i]={a,b,c};} return move(v);}\ntemplate<class T,class S,class R,class Q> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv4(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c,d; cin>>a>>b>>c>>d; v[i]={a,b,c,d};} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nstruct Combination{\n\tvmll f, g;\n\tCombination(){}\n\tCombination(ll maxN): f(maxN+1, 1), g(maxN+1){ InitSub(maxN); }\n\tvoid init(ll maxN){ f.resize(maxN+1, 1); g.resize(maxN+1); InitSub(maxN); }\n\tmll operator () (ll n, ll r){ return (n<0||r<0||n<r) ? mll(0) : f[n]*g[n-r]*g[r]; }//nCr\n\tmll P(ll n, ll r){ return (n<0 || r<0 || n<r) ? mll(0) : f[n]*g[n-r]; } //nPr\n\tmll H(ll n, ll r){ return operator()(n+r-1, r); }//nHr\n\tmll inv(ll n) { return f[n-1] * g[n]; } //1/n\n\tmll fact(ll n) { return f[n]; } //n!\n\tmll finv(ll n) { return g[n]; } //1/n!\n\tvoid InitSub(ll maxN){\n\t\tREPS(i, 1, maxN){ f[i] = f[i-1] * i; }\n\t\tg[maxN] = 1 / f[maxN];\n\t\tDEPS(i, 1, maxN){ g[i-1] = g[i] * i; }\n\t}\n};\n/*\nCombination comb(n); //nCrまで計算可能\nmll v1 = comb(100,5); //100 C 5\nmll v2 = comb(85,86); //85 C 86 →0になる\nmll v3 = comb.P(10,5); //10 P 5\nmll v4 = comb.H(10,5); //10 H 5 初期化時のnに10+5-1以上をset要\nmll v5 = comb.inv(7);  // 7の逆数\nmll v6 = comb.finv(7); // 7!の逆数\nmll v7 = comb.fact(7); // 7!\ncomb.init(n); //後で初期化する場合\n*/\n\n\nvoid calc(ll n)\n{\n\tCombination cm(n+10);\n\tif (n==2){\n\t\tcout << 1 << '\\n'; return;\n\t}\n\n\tmll ans1=0;\n\trep(i, 1, INF){\n\t\tll u = n-1-i;\n\t\tif (u<i-1)break;\n\n\t\tans1+=cm(u, i-1)*2*cm.fact(u)*cm.fact(i-1)*(u+1);\n\t}\n\tmll ans2=0;\n\trep(i, 2, INF){\n\t\tll r=n-3-i+1;\n\t\tif (r<i-1)break;\n\t\tll u=n-1-i;\n\n\t\tans2+=cm(r, i-1)*(i-1)*cm.fact(u)*2*cm.fact(i-1)*(u+1);\n\t}\n\tmll ans3=0;\n\trep(i, 3, INF){\n\t\tll r=n-3-i+1;\n\t\tif (r<i-2)break;\n\t\tll u=n-1-i;\n\n\t\tans3+=cm(r, i-2)*(i-2)*cm.fact(u)*cm.fact(i-1)*(u+1);\n\t}\n\n\tmll ans=ans1+ans2+ans3;\n\tcout << ans << '\\n';\n}\n\n#if 0\nvoid calc2(ll n){\n\tll sum=0;\n\tvll idxAry(n-1);\n\trep(i, 0, n-2)idxAry[i]=i;\n\tdo{\n\t\tvll buf(n);\n\t\tll cnt=0;\n\t\trep(i, 0, n-1){\n\t\t\tll idx=idxAry[i];\n\t\t\tif (buf[idx]==0){\n\t\t\t\tbuf[idx]=1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (buf[idx+1]==0){\n\t\t\t\tbuf[idx+1]=1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (cnt==n){\n\t\t\t\tsum+=i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (next_permutation(idxAry.begin(), idxAry.end()));\n\tcout << sum << '\\n';\n}\n\nvoid test(){\n\trep(i, 2, 12){\n\t\tcalc(i);\n\t\tcalc2(i);\n\t}\n}\n#endif\n\nvoid solve()\n{\n\tll n;  cin >> n;\n\tcalc(n);\n}\n\nint main(){\n#if 1\n\t//test();\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int P = 1000000007;\n\nll powmod(ll n, ll k) {\n    ll r = 1, t = n % P;\n    for (; k != 0; k /= 2) {\n        if (k & 1) r = r * t % P;\n        t = t * t % P;\n    }\n    return r;\n}\nll inv(ll n) {\n    return powmod(n, P - 2);\n}\n\nvector<int> f0, f1;\nvoid init(int n) {\n    f0.resize(n + 1);\n    f0[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        f0[i] = (ll)f0[i - 1] * i % P;\n    }\n    f1.resize(n + 1);\n    f1[n] = inv(f0[n]);\n    for (int i = n; i > 0; i--) {\n        f1[i - 1] = (ll)f1[i] * i % P;\n    }\n}\nll fact(int k) {\n    return f0[k];\n}\nll comb(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return (ll)f0[n] * f1[k] % P * f1[n - k] % P;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    init(n);\n\n    ll r = 0;\n    for (int k = (n + 1) / 2; k <= n - 1; k++) {\n        ll a = comb(k - 1, n - 1 - k) * fact(k) % P * fact(n - 1 - k) % P;\n        if (k < n - 1) {\n            r += a;\n        } else {\n            r = a * k - r;\n            r %= P; if (r < 0) r += P;\n        }\n    }\n\n    cout << r << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt rev(Int x){\n  return mod_pow(x, MOD-2);\n}\nInt fact[1080000];\nvoid init(){\n  fact[0] = 1;\n  for(int i = 1;i < 1080000;i++){\n    fact[i] = fact[i-1] * i % MOD;\n  }\n}\n\nInt nCk(Int n, Int k){\n  if(n < k)return 0;\n  return fact[n] * rev(fact[n-k]) %MOD  * rev(fact[k]) % MOD;\n}\n\nInt cnt[1080000];\n\nint main(){\n  init();\n  Int n, res = 0;\n  cin >> n;\n  if(n == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  n--;\n  for(int i = 2;i <= n;i++){\n    cnt[i] =  fact[i] * fact[n-i] % MOD;\n    cnt[i] *= nCk(i-1, n-i);\n    cnt[i] %= MOD;\n  }\n  for(int i = n;i >= 2;i--){\n    cnt[i] -= cnt[i-1];\n    res += cnt[i] * i % MOD;\n    res %= MOD;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,C=0,ans=0,cnt=0;\n  cin>>N;\n  COMinit();\n  ans=(N-1)*fac[N-1]%MOD;\n  \n  for(ll i=4; i<=6; ++i){\n    cnt=0;\n    \n    for(ll j=0; j<=N/2; ++j){\n      C=0;\n      ll P=N-i-2*j;\n      if(P>=0 && P%3==0){\n        ll x=P/3;\n        C=COM(j+x,j)*fac[j+x+1];\n        C%=MOD;\n        C*=fac[N-2-j-x];\n        C%=MOD;\n      }\n      cnt+=C;\n      cnt%=MOD;\n    }\n    \n    if(i==5) cnt*=2;\n    ans=(ans-cnt)%MOD;\n    co(ans);\n  }\n  \n  ans%=MOD;\n  if(ans<0) ans+=MOD;\n  \n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#define MAXN 1000005\n#define MOD 1000000007\n#define mod 1000000007\nusing namespace std;\ntypedef long long LL;\ntypedef long long ll;\nLL n,m,p,f[MAXN],g[MAXN],st;\nll h[MAXN];\nvoid init()\n{\n    f[0]=1;\n    for(int i=1;i<=MAXN;i++)\n    {\n        f[i]=f[i-1]*i;\n        f[i]%=MOD;\n     //   printf(\"%lld\\n\",fact[i]);\n    }\n}\nll powmod(ll x,ll n)\n{\n    ll s=1;\n    while(n)\n    {\n        if(n&1)\n            s=(s*x)%mod;\n        n>>=1;\n        x=(x*x)%mod;\n    }\n    return s;\n}\nll C(ll n,ll m)\n{\n    if(n<m)\n        return 0;\n    ll a=f[n],b=(f[n-m]*f[m])%mod;\n    return (a*powmod(b,mod-2))%mod;\n}\nint main()\n{\n    p=MOD;\n    init();\n    scanf(\"%lld\",&n);\n    //先求g[i]\n    //\n    if(n%2)\n    {\n        st=n/2+1;\n    }\n    else\n    {\n        st=n/2;\n    }\n    //\n    for(int i=st;i<=n-1;i++)\n    {\n     //   printf(\"%d\\n\",i);\n        g[i]=((C(i-1,n-i-1)*f[i])%MOD*f[n-i-1])%MOD;\n    //    printf(\"%lld\\n\",g[i]);\n    }\n    for(int i=st;i<=n-1;i++)\n    {\n        h[i]=g[i]-g[i-1];\n        h[i]%=MOD;\n    }\n    long long ans=0;\n    for(int i=st;i<=n-1;i++)\n    {\n        ans+=(h[i]*i)%MOD;\n        ans%=MOD;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nconstexpr int MN = 1000001;\nconstexpr int MOD = 1e9+7;\n\nll fact[MN] = { 1 }, ifact[MN] = { 1 };\n\ninline ll pw(ll base, ll exp) {\n\tll res = 1;\n\twhile (exp) {\n\t\tif (exp & 1) (res *= base) %= MOD;\n\t\texp >>= 1, (base *= base) %= MOD;\n\t}\n\treturn res;\n}\n\ninline ll inv(ll x) { return pw(x, MOD - 2); }\n\ninline ll nCr(int n, int k) { return fact[n] * ifact[k] % MOD * ifact[n - k] % MOD; }\n\nint main() {\n    if (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    int N; cin >> N;\n\n    for (int i = 0; i < N; ++i) fact[i + 1] = (i + 1ll) * fact[i] % MOD, ifact[i + 1] = inv(fact[i + 1]);\n    \n    ll sum = 0, ans = 0;\n    for (int i = N/2; i < N; ++i) {\n        ll tmp = nCr(i-1, N-i-1)*fact[i]%MOD*fact[N-i-1]%MOD;\n        (ans += i*(tmp-sum)+MOD) %= MOD;\n        sum = tmp;\n    }\n    cout << ans;\n\n    /*for (int N = 2; N <= 10; ++N) {\n        //int N = 7;\n        vector<int> P(N-1);\n        iota(begin(P), end(P), 0);\n        vector<int> ans(N-1);\n        do {\n            vector<bool> A(N, 0);\n            ll cnt = 0;\n            for (int i = 0; i < N-1; ++i) {\n                A[P[i]] = A[P[i]+1] = 1;\n                if (count(begin(A), end(A), 1) == N) {\n                    ++ans[i];\n                    if (i == 3) {\n                        for (int x : P) cout << x << ' ';\n                        cout << '\\n';\n                    }\n                    break;\n                }\n            }\n        } while (next_permutation(begin(P), end(P)));\n        for (int x : ans) cout << setw(6) << x << ' ';\n        cout << '\\n';\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using VV = vector<vector<T>>;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(),(v).end()\n#define siz(v) (ll)(v).size()\n#define rep(i,a,n) for(ll i=a;i<(ll)(n);++i)\n#define repr(i,a,n) for(ll i=n-1;(ll)a<=i;--i)\n#define ENDL '\\n'\ntypedef pair<int,int> Pi;\ntypedef pair<ll,ll> PL;\nconstexpr ll mod = 1000000007;\nconstexpr ll INF = 1000000099;\nconstexpr ll LINF = (ll)(1e18 +99);\nconst vector<ll> dx={-1,1,0,0},dy={0,0,-1,1};\ntemplate<typename T,typename U> inline bool chmin(T& t, const U& u){if(t>u){t=u;return 1;}return 0;}\ntemplate<typename T,typename U> inline bool chmax(T& t, const U& u){if(t<u){t=u;return 1;}return 0;}\ntemplate<typename T> inline T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<typename T,typename Y> inline T mpow(T a, Y n) {\n  T res = 1;\n  for(;n;n>>=1) {\n    if (n & 1) res = res * a;\n    a = a * a;\n  }\n  return res;\n}\n\nconst int MAX = 1000010;//設定して\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;//＊１\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\n\nsigned main(){\n  cin.tie(0);ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n  ll n;cin>>n;\n  COMinit();\n  V<ll> undk(n,0);\n\n  ll ans=0;\n  rep(i,1,n){\n    if(i-1<n-1-i)continue;\n\n    ll tmp=COM(i-1,n-1-i);\n    tmp%=mod;\n    tmp*=fac[i];\n    tmp%=mod;\n    tmp*=fac[n-1-i];\n    tmp%=mod;\n    undk[i]=tmp;\n  }\n\n  rep(i,1,n){\n    ans+=i*(undk[i]-undk[i-1])%mod;\n    ans%=mod;\n  }\n\n  cout<<ans<<ENDL;\n}\n//! ( . _ . ) ! \n//CHECK overflow,vector_size,what to output?"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i] * i % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main() {\n\tunsigned int n;\n\tuint64 ans;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = (N + 1) >> 1; i < N - 1; ++i) {\n\t\tans += fact.v2[i] * ifact.val[(i << 1) - N] % M;\n\t}\n\tans %= M;\n\tlong long unsigned int o = fact.val[N - 1] < ans ? fact.val[N - 1] + M - ans : fact.val[N - 1] - ans;\n\tprintf(\"%llu\\n\", o);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< int mod >\nstruct ModInt {\n  ll x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}\n//using modint=ld;\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing Comb=Combination<modint>;\n\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  Comb comb(1000005);\n  modint ret=comb.fact(n-1)*(n-1);\n  //cout<<ret<<endl;\n  rep(i,1,n-1){\n    ll d=n-3-i;\n    //cout<<i spa d spa ret<<endl;\n    if(d+1<i)break;\n    ret-=comb.C(d+1,i)//後ろに詰めるマシンの選び方\n      *comb.fact(d+2)//前のマシンの順\n      *comb.fact(i)//後ろのマシンの順\n      ;\n  }\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\nstruct S\n{\n    int x,y,z;\n\n    bool operator<(const S &a)const{\n              return x<a.x;\n    }\n};\n\nvector<int> v;\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nlong long l[1114000];\n\nlong long o[1114211];\nint j[2];\nint dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z;\n\nP u[555320];\n//stack<int> s;\n\n//set<int> s;\nqueue<int> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<int,int> p;\n//list<int> l;\n//string r1,r;\n//char r[1152][1111];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y>b.y;\n}\n\nlong long f(int a)\n{\n    if(a<0) return 0;\n    else\n    return o[a];\n}\n\nlong long g(int a,int b)\n{\n    if(b<a) return 0;\n    return f(b)*(l[a]*l[b-a]%mod)%mod;\n}\n\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b>>1);\n    x*=x,x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    o[0]=1;\n    for(int t=1;t<=a;t++)\n        o[t]=o[t-1]*t%mod;\n    l[0]=1;\n    for(int t=1;t<=a;t++)\n        l[t]=p(o[t],mod-2);\n    for(int t=2;t<a;t++)\n    {\n        y=x;\n        x=f(a-t-1)*f(t)%mod*g(a-t-1,t-1)%mod;\n        z+=(x-y+mod)%mod*t%mod;\n        z%=mod;\n        //printf(\"##%lld\\n\",x);\n        //printf(\"%lld %lld %lld\\n\",f(a-t-1),f(t),g(a-t-1,t-1));\n    }\n    printf(\"%lld\",z);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main() {\n\tunsigned int n;\n\tuint64 ans;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = (N + 1) >> 1; i < N - 1; ++i) {\n\t\tans += fact.v2[i] * ifact.val[(i << 1) - N] % M;\n\t}\n\tans = (fact.val[N - 1] * (N - 1) + M - ans) % M;\n\tprintf(\"%llu\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    if(N == 2){\n        cout << 1;\n        return 0;\n    }\n    int mod = 1000000007;\n\n    Combination C(N, mod);\n    int ans = 0;\n    int count = 0;\n\n    //両端以外が最後\n    FOR(k, 1, (N - 3) / 2 + 1){\n        int c = (k * C.comb(N - 3 - k, k)) % mod;\n        int tmp = (c * C.fact[N - k - 2]) % mod;\n        tmp = (tmp * 2 * C.fact[k]) % mod;\n        count = (count + tmp) % mod;\n        tmp = (tmp * (N - 1 - k)) % mod;\n        ans = (ans + tmp) % mod;\n    }\n    FOR(k, 1, (N - 4) / 2 + 1){\n        int c = k * C.comb(N - 4 - k, k);\n        int tmp = (c * C.fact[N - k - 3]) % mod;\n        tmp = (tmp * C.fact[k + 1]) % mod;\n        count = (tmp + count) % mod;\n        tmp = (tmp * (N - 2 - k)) % mod;\n        ans = (ans + tmp) % mod;\n    }\n\n    //両端が最後\n    FOR(k, 0, (N - 2) / 2 + 1){\n        int c = C.comb(N - k - 2, k);\n        int tmp = (c * C.fact[N - 2 - k]) % mod;\n        tmp = (tmp * C.fact[k]) % mod;\n        count = (count + 2 * tmp) % mod;\n        tmp = (tmp * (N - 1 - k)) % mod;\n        ans = (ans + 2 * tmp) % mod;\n    }\n\n    //cout << C.fact[N - 1] << endl << count << endl;\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define pb push_back\n#define mp make_pair\n#define M 1000000007\nll fact[1000001];\nll inv[1000001];\n\nll fermat(ll v,ll p)\n{\n\n    if(p==0)\n        return 1;\n    ll a=1;\n    if(p%2)\n        a=v;\n    ll x=fermat(v,p/2);\nx=(x*x)%M;\nx=(x*a)%M;\nreturn x;\n\n\n\n}\nint main(){\nint i,j;\nfact[0]=1;\n\nfor(i=1;i<=1000000;i++)\n     fact[i]=(fact[i-1]*(i))%M;\ninv[0]=1;\nfor(i=1;i<=1000000;i++)\n    inv[i]=fermat(fact[i],M-2);\n\n  int n;\n  cin>>n;\n  ll ans=0;\n  int k;\n  ll pre=0;\n  for(k=1;k<n;k++)\n  {\n\n      int o=n-1-k;\n\n      if(o>=k)\n        continue;\n\n\n      ll aux=(fact[k]*fact[n-1-k])%M;\n\n\n      aux=aux*(((((fact[k-1])*inv[o])%M)*inv[k-1-o])%M);\n      aux=(aux%M);\n\n      ll temp=aux;\n      aux=aux-pre;\n      pre=temp;\n      if(aux<0)\n        aux+=M;\n  aux=(aux*k)%M;\n      ans=(ans+aux)%M;\n\n\n  }\n\n\n\ncout<<ans<<endl;\n\n\n\nreturn 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nint n,lsg,jc[1000010],N[1000010],ans,f[1000010],sum;\nint ksm(int x,int y){\n\tint ans=1;while (y){\n\t\tif (y&1)(ans*=x)%=lsg;(x*=x)%=lsg;y>>=1;\n\t}return ans;\n}int p(int n,int m){return jc[n]*N[m]%lsg;}\nint C(int n,int m){return jc[n]*N[m]%lsg*N[n-m]%lsg;}\nsigned main(){\n\tn=read();lsg=1e9+7;if (n==2){puts(\"1\");return 0;}\n\tjc[0]=1;for (int i=1;i<=n;i++)jc[i]=jc[i-1]*i%lsg;\n\tN[n]=ksm(jc[n],lsg-2);for (int i=n-1;i>=0;i--)N[i]=N[i+1]*(i+1)%lsg;\n\tfor (int i=1;i<n;i++)if (i*2>=n){\n\t\tf[i]=C((n-2-(i*2-n))/2+i*2-n,i*2-n)*jc[i]%lsg*jc[n-1-i]%lsg;\n\t\t(ans+=(f[i]-f[i-1])*i%lsg+lsg)%=lsg;\n\t}writeln(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\nvector<mint> frac;\nvector<mint> ifrac;\n\nvoid init(ll N) {\n\tfrac.assign(N + 1,1);\n\tifrac.assign(N + 1,1);\n\n\trepn(i, N) {\n\t\tfrac[i] = frac[i - 1] * i;\n\t\tifrac[i] = ifrac[i - 1] / i;\n\t}\n\n}\n\n\nint main() {\n\tll N;\n\tcin >> N;\n\n\t\n\t\tinit(N);\n\n\t\tvector<mint> p(N, 0);\n\n\t\tfor (ll i = (N + 1) / 2; i <= N - 1; i++) {\n\t\t\tp[i] = frac[i - 1] * frac[i] * ifrac[2 * i - N];\n\t\t}\n\n\t\tmint ans = 0;\n\n\t\trepn(i, N - 1) {\n\t\t\tans += (p[i] - p[i - 1])*i;\n\t\t}\n\n\t\tcout << ans << endl;\n\t\n\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int MOD = 1000000007;\n\ninline int inc(int a, int b) { return (a + b >= MOD) ? (a + b - MOD) : (a + b); }\ninline int dec(int a, int b) { return (a >= b) ? (a - b) : (a + MOD - b); }\ninline int mul(int a, int b) { return 1LL * a * b % MOD; }\n\ninline int power(int x, int k) {\n\tint tmp = 1;\n\twhile(k) {\n\t\tif(k & 1) tmp = mul(tmp,x);\n\t\tx = mul(x,x);\n\t\tk >>= 1;\n\t}\n\treturn tmp;\n}\n\nint n, fac[maxn], ifac[maxn], f[maxn];\n\ninline int C(int n, int m) {\n\tif(n < 0 || m < 0 || n < m) return 0;\n\treturn mul(fac[n],mul(ifac[m],ifac[n - m]));\n}\n\nint main() {\n//\tfreopen(\"data.in\",\"r\",stdin);\n  scanf(\"%d\", &n);\n\tfac[0] = ifac[0] = 1;\n\tfor(int i = 1;i <= n;i ++) fac[i] = mul(fac[i - 1],i);\n\tifac[n] = power(fac[n],MOD - 2);\n\tfor(int i = n - 1;i >= 1;i --) ifac[i] = mul(ifac[i + 1],i + 1);\n\tint Ans = 0;\n\tint lim = (n + 1) / 2;\n\tfor(int i = lim;i < n;i ++) {\n\t\tint xs = mul(fac[i],fac[n - 1 - i]);\n\t\tf[i] = mul(xs,C(i - 1,n - i - 1));\n\t}\n\tf[lim - 1] = 0;\n\tfor(int i = lim;i < n;i ++) {\n\t\tAns = inc(Ans,mul(i,dec(f[i],f[i - 1])));\n\t}\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬╬╬██╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntypedef pair<int,int> P;\ntypedef vector<vector<P>> Graph;\n\nint add(int a, int b){\n  return ((a+b) % MOD + MOD) % MOD;\n}\n\ninline int mul(int a, int b) {\n    #if !defined(_WIN32) || defined(_WIN64)\n      return (int) ((long long) a * b % MOD);\n    #endif\n      unsigned long long x = (long long) a * b;\n      unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n      asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n      );\n      return m;\n}\n\ninline int modpow(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n      }\n      a = mul(a, a);\n      b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n    a %= MOD;\n    if (a < 0) a += MOD;\n    int b = MOD, u = 0, v = 1;\n    while (a) {\n      int t = b / a;\n      b -= t * a; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    assert(b == 1);\n    if (u < 0) u += MOD;\n    return u;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int n;\n  cin >> n;\n\n  vector<int> fact(n+1);\n  fact[0] = 1;\n  REP(i,n) fact[i+1] = mul(fact[i],i+1);\n\n  //REP(i,n) debug(fact[i+1]);\n  \n  vector<int> sum(n);\n  REP(i,n){\n    if(i < (n+1)/2){\n      sum[i] = 0;\n      continue;\n    }\n    int tmp = mul(fact[i],fact[n-1-i]);\n    sum[i] = mul(tmp,mul(fact[i-1],inv(mul(fact[2*i-n],fact[n-1-i]))));\n  }\n\n  int ans = 0;\n  FOR(i,1,n){\n    ans = add(ans,mul(i,(sum[i]-sum[i-1]+MOD)));\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nlong long mod = 1000000007, n, fact[(1<<20)], invf[(1<<20)];\n\nlong long pow2( long long a, long long st ) {\n    long long ret = 1;\n    for ( ; st ; st /= 2 ) {\n        if ( st%2 ) {\n            ret *= a;\n            ret %= mod;\n        }\n        a *= a;\n        a %= mod;\n    }\n    return ret;\n}\nlong long comb ( long long k, long long n ) {\n    return fact[n]*invf[k]%mod*invf[n-k]%mod;\n}\nlong long s( long long k ) {\n    if ( n-k-1 > k-1 ) { return 0; }\n    return comb( n-k-1, k-1 );\n}\nlong long f[(1<<20)];\n\nint main () {\n    cin >> n;\n    fact[0] = 1;\n    invf[0] = 1;\n    for ( int i = 1 ; i <= n ; i ++ ) {\n        fact[i] = fact[i-1]*i%mod;\n        invf[i] = pow2( fact[i], mod-2 );\n    }\n\n    long long ans = 0;\n    for ( int k = 1 ; k < n ; k ++ ) {\n        f[k] = s(k)*fact[k]%mod*fact[n-k-1]%mod;\n        ans += ( f[k] - f[k-1] + mod)%mod*k%mod;\n        ans %= mod;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e9+7)\nll N;\nll m,ans,F[1010101];\nll i, j, k;\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\nint main(){\n    scanf(\"%lld\", &N);\n    F[0] = 1;\n    fornum(i,0,N+1){\n        F[i + 1] = F[i] * (i + 1) % MOD;\n    }\n    m = 0;\n    fornum(k,(N+1)/2,N){\n        ll a=moddiv(F[k-1],F[N-k-1]*F[k*2-N])%MOD;\n        a = a * F[k] % MOD;\n        a = a * F[N-1-k] % MOD;\n        ans = (ans + (a-m)*k%MOD) % MOD;\n        m = (a + m) % MOD;\n        //printf(\"%lld %lld %lld %lld\\n\",k, moddiv(F[k-1],F[N-k-1]*F[k*2-N]),F[N-1-k],ans);\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept {\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept {\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=1e6+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n//Be careful with the value of MAX and conducting COMinit()\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\tCOMinit();\n\tint N; cin >> N;\n\tvector<mint> perms(N);\n\tmint ans=0;\n\tfor (int i=1;i<N;++i){\n\t\tperms[i]=fac[i]*fac[N-1-i]*COM(i-1,N-1-i);\n\t\tans+=(perms[i]-perms[i-1])*i;\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000+7;\nconstexpr long long INF = std::numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, q, last, cnt, ans, sum;\nstring str, ss;\nbool f;\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ -1,0 } ,{ 0,-1 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[10000];\nset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nstruct Combination {\n\tint mod;\n\tvector< int64_t > mfact, rfact;\n\n\tCombination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod) {\n\t\tmfact[0] = 1;\n\t\tfor (int i = 1; i < mfact.size(); i++) {\n\t\t\tmfact[i] = mfact[i - 1] * i % mod;\n\t\t}\n\t\trfact[sz] = inv(mfact[sz]);\n\t\tfor (int i = sz - 1; i >= 0; i--) {\n\t\t\trfact[i] = rfact[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\n\tint64_t fact(int k) const {\n\t\treturn (mfact[k]);\n\t}\n\n\tint64_t pow(int64_t x, int64_t n) const {\n\t\tint64_t ret = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) (ret *= x) %= mod;\n\t\t\t(x *= x) %= mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn (ret);\n\t}\n\n\tint64_t inv(int64_t x) const {\n\t\treturn (pow(x, mod - 2));\n\t}\n\n\tint64_t P(int n, int r) const {\n\t\tif (r < 0 || n < r) return (0);\n\t\treturn (mfact[n] * rfact[n - r] % mod);\n\t}\n\n\tint64_t C(int p, int q) const {\n\t\tif (q < 0 || p < q) return (0);\n\t\treturn (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n\t}\n\n\tint64_t H(int n, int r) const {\n\t\tif (n < 0 || r < 0) return (0);\n\t\treturn (r == 0 ? 1 : C(n + r - 1, r));\n\t}\n};\nint main() {\n\tcin >> n;\n\tn--;\n\tCombination comb(n+2, MOD);\n\tfor (int i = 1; i <= n; i++) {\n\t\tans +=((((comb.mfact[i] * comb.C(i - 1, n - i) % MOD)* comb.mfact[n - i]%MOD\n\t\t\t- (comb.mfact[i - 1] * comb.mfact[n - i + 1] % MOD) * comb.C(i - 2, n - i + 1)%MOD) % MOD)+MOD) * i;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rg register\nusing namespace std;\nconst int Mod=1e9+7;\nconst int MAXN=1e6+10;\nint n,k;\nll Ans,Tot,Mi[MAXN]={1};\ninline int Read()\n{   rg int a=0,c=1;   rg char b=getchar();\n\twhile(b!='-'&&(b<'0'||b>'9'))b=getchar();\n\tif(b=='-')c=-1,b=getchar();\n\twhile(b>='0'&&b<='9')a=a*10+b-48,b=getchar();\n\treturn a*c;\n}\ninline ll Fast(rg ll Di,rg ll Mi)\n{   ll Back=1;\n\twhile(Mi>=1)\n\t{   if(Mi&1)  Back=(Back*Di)%Mod;\n\t\tDi=(Di*Di)%Mod;   Mi>>=1;\n\t}\n\treturn Back;\n}\nint main()\n{   n=Read();   k=(n+1)/2;\n\tfor(rg int i=1;i<=n;i++)  Mi[i]=(Mi[i-1]*i)%Mod;\n\tfor(rg int i=k;i<=n-1;i++)\n\t{   ll x=2*i-n,y=n-i-1,Now=0,Size=Tot;\n\t\tNow=((Mi[i-1]*Fast(Mi[x]*Mi[y]%Mod,Mod-2)%Mod)*Mi[i]%Mod*Mi[y])%Mod;\n\t\tTot=Now;   Now-=Size;   Now=(Now%Mod+Mod)%Mod;\n\t\tAns=(Ans+1ll*Now*i)%Mod;\n\t}\n\tprintf(\"%lld\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 1000100\n#define ll long long\n#define mod (int)(1e9+7)\nusing namespace std;\nint fac[N],inv[N],n;\nint C(int n,int m)\n{\n\tif(n<m)return 0;\n\treturn (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint ans=0;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\tfac[i]=(ll)fac[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=n;i++)\n\tinv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;\n\tfor(int i=1;i<=n&&i<mod;i++)\n\tinv[i]=(ll)inv[i]*inv[i-1]%mod;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint now=C(i-1,n-i-1);\n\t\tans=(ans+(ll)now*fac[i]%mod*fac[n-i-1]%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",(fac[n]+mod-ans)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt &p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt &p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt &p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt &p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt &p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt &p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt &p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(const int64_t &n) const {\n        ModInt ret(1), mul(x);\n        int64_t k = n % (M - 1);\n        if(k < 0) k += M - 1;\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\nusing modint = ModInt<mod>;\n\n// 組み合わせ、階乗逆元\nvector<modint> fact, fact_inv;\n\nvoid COMinit(const ll &MAX) {\n    fact.resize(MAX + 1);\n    fact_inv.resize(MAX + 1);\n    fact[0] = 1;\n    rep(i, MAX) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[MAX] = fact[MAX].inverse();\n    for(int i = MAX; i; i--)\n        fact_inv[i - 1] = fact_inv[i] * i;\n}\n\nmodint COM(const ll &n, const ll &k) {\n    if(n < k || k < 0) return 0;\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n;\n    cin >> n;\n    COMinit(n);\n    V<modint> v(n);\n    rep(i, n) v[i] = COM(i - 1, n - 1 - i) * fact[i] * fact[n - 1 - i];\n    FORR(i, n - 1) v[i + 1] -= v[i];\n    modint ans;\n    rep(i, n) ans += v[i] * i;\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 1e6 + 10, K = 1e3 + 10, B = 10, oo = 1e18 + 100, M = 1e9 + 7, LOG = 20;\nconst int M1 = 1000000093, x1 = 27162;\nconst int M2 = 1000000087, x2 = 241;\nconst ld pi = atan2(1, 0) * 2;\n\n\nint MOD(int v)\n{\n    v %= M;\n    if (v < 0)\n        v += M;\n\n    return v;\n}\n\n\nint fact[N];\nint inv[N];\n\n\nint bin_pow(int v, int pw)\n{\n    int res = 1;\n    while (pw)\n    {\n        if (pw & 1)\n            res = MOD(res * v);\n\n        pw >>= 1;\n        v = MOD(v * v);\n    }\n\n    return res;\n}\n\n\nint Cr(int n, int k)\n{\n    assert(n >= k);\n    return MOD(fact[n] * MOD(inv[k] * inv[n - k]));\n}\n\n\nvoid smain() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i)\n        fact[i] = MOD(fact[i - 1] * i);\n\n    inv[N - 1] = bin_pow(fact[N - 1], M - 2);\n    for (int i = N - 2; i >= 0; --i) {\n        inv[i] = inv[i + 1];\n        inv[i] *= (i + 1);\n        inv[i] = MOD(inv[i]);\n    }\n\n    int ans = 0;\n    int n;\n    cin >> n;\n    if (n == 2)\n    {\n        cout << \"1\\n\";\n        return;\n    }\n\n    int prev = 0;\n    for (int k = 2; k <= n - 1; ++k) {\n        int a = n - 1 - k;\n        int b = 2 * k - n;\n        if (min(a, b) >= 0)\n        {\n            int cur = MOD(Cr(k - 1, n - 1 - k) * MOD(fact[k] * fact[n - 1 - k]));\n            ans = MOD(ans + (cur - prev) * k);\n            prev = cur;\n        }\n    }\n\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/07/20\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<double> vd;\ntypedef vector<vector<double>> vvd;\ntypedef vector<vector<vector<double>>> vvvd;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, pair<int, int>> plii;\nconst int bigmod = 1000000007;\nconst int INF = 1050000000;\nconst long long INFll = 100000000000000000;\n\nvi fact;\n\n//足し算\nint add(int a, int b) {\n    return (int) (((ll) a + b + bigmod) % bigmod);\n}\n\n//引き算\nint sub(int a, int b) {\n    return (int) (((ll) a - b + bigmod) % bigmod);\n}\n\n//掛け算\nint mul(int a, int b) {\n    return (int) (((ll) (a % bigmod) * (b % bigmod)) % bigmod);\n}\n\n\n//割り算  -  逆元(求めたい数とbigmodを渡す)\nint divide(int a, int p = bigmod, int b = -1) {\n    if (b < 0) b = p - 2;  //int gyakugen(int a, int p, int b = p - 2とできなかったため。)\n    if (b == 0) return 1;\n    else if (b % 2 == 0) {\n        int d = divide(a, p, b / 2);\n        return mul(d, d);\n    } else {\n        return mul(a, divide(a, p, b - 1));\n    }\n}\n\nint frac(int a, int b) {\n    return mul(a, divide(b));\n}\n\nint nCk_gyakugen(int n, int k, int p = bigmod) {\n    if (k == 0) return 1;\n    if (n == 0) 0;\n    if (n < k) return 0;\n    int denominator = fact[n];\n    int molecule1 = fact[k];\n    int molecule2 = fact[n - k];\n    return mul(denominator, mul(divide(molecule1), divide(molecule2)));\n}\n\nint main() {\n    int N;\n    cin >> N;\n//    if(N == 2){\n//        cout<<1<<endl;\n//    }\n    fact = vi(N);\n    fact[0] = 1;\n    FOR(i, 1, N) fact[i] = mul(fact[i - 1], i);\n    vi A(N + 1, 0);\n    int ans = 0;\n    FOR(k, 1, N) {\n        if (k - 1 < N - 1 - k) continue;\n        A[k] = mul(nCk_gyakugen(k - 1, N - 1 - k), mul(fact[k], fact[N - 1 - k]));\n        ans = add(ans, mul(sub(A[k], A[k- 1]), k));\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ninline int read() {\n  int f = 1;\n  int x = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    f = (ch == '-') ? -1 : 1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return f * x;\n}\n\nconst int N = 1e6 + 5;\nconst int P = 1e9 + 7;\n\ninline int mul(int a, int b) {\n  return (long long) a * b % P;\n}\ninline int sub(int a, int b) {\n  return a - b < 0 ? a - b + P : a - b;\n}\ninline int add(int a, int b) {\n  return a + b >= P ? a + b - P : a + b;\n}\ninline int modexp(int a, int x) {\n  int ret = 1;\n  while (x) {\n    if (x & 1) {\n      ret = mul(ret, a);\n    }\n    a = mul(a, a);\n    x >>= 1;\n  }\n  return ret;\n}\n\nint n;\nint fac[N];\nint inv[N];\n\ninline int calc(int m, int n) {\n  int k = 2 * m - n;\n  if (k >= 0 && m - k >= 0) {\n    return mul(fac[m], mul(inv[k], inv[m - k]));\n  } else {\n    return 0;\n  }\n}\n\ninline int C(int n, int m) {\n  if (n < 0 || m < 0 || n < m) {\n    return 0;\n  }\n  return mul(fac[n], mul(inv[m], inv[n - m]));\n}\n\nint main() {\n  n = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  inv[n] = modexp(fac[n], P - 2);\n  for (int i = n - 1; i >= 0; --i) {\n    inv[i] = mul(inv[i + 1], i + 1);\n  }\n  int ans = mul(fac[n - 1], n);\n  for (int i = (n + 1) / 2; i < n; ++i) {\n    ans = sub(ans, mul(fac[n - i - 1], mul(C(i - 1, n - i - 1), fac[i])));\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\ntypedef long long ll;\nusing namespace std;\n\nll mod=1000000007;\nconst int SIZE=1000100;\nll fac[SIZE], finv[SIZE], inv[SIZE];\nvoid COMinit(ll m){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2; i<SIZE; ++i){\n        fac[i]=(fac[i-1]*i)%m;\n        inv[i]=m-(inv[m%i]*(m/i))%m;\n        finv[i]=(finv[i-1]*inv[i])%m;\n    }\n}\nll COM(int n, int k, ll m){\n    if(n<k) return 0;\n    if(n<0 || k<0) return 0;\n    return (fac[n]*((finv[k]*finv[n-k])%m))%m;\n}\nll modpow(ll a, ll b, ll m){\n    ll res=1, p=0, now=a%m;\n    b %= (m-1);\n    for(int i=0; b>p; ++i){\n        if(b&((ll) 1<<i)){\n            res=(res*now)%m;\n            p |= ((ll) 1<<i);\n        }\n        now=(now*now)%m;\n    }\n    return res;\n}\nll modinv(ll a, ll m){\n    return modpow(a, m-2, m);\n}\nll moddiv(ll a, ll b, ll m){\n    return (a*modinv(b, m))%m;\n}\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tCOMinit(mod);\n\tll ans=0;\n\t--N;\n\tfor(int i=0; i<N; ++i){\n\t\tll g=COM(N, i, mod), h=COM(i-1, N-i, mod);\n\t\th=(g+mod-h)%mod;\n\t\t(ans += moddiv((fac[N]*h)%mod, g, mod)) %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, p = 1000000007, z;\nint f[1000020];\nint v[1000020];\nint main() {\n\tcin >> n;\n\tf[0] = v[0] = v[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tv[i] = (long long)v[p % i] * (p - p / i) % p;\n\t}\n\tfor (int i = 1; i <= 1000000; i++) {\n\t\tf[i] = (long long)f[i - 1] * i % p;\n\t\tv[i] = (long long)v[i - 1] * v[i] % p;\n\t}\n\tfor (int i = (n + 1) / 2; i < n; i++) {\n\t\tz = (z + (long long)f[i] * f[i - 1] % p * v[2 * i - n]) % p;\n\t}\n\tcout << (f[n] + p - z) % p << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//     . .. ... ..... be naame khodaa ..... .... ... .. .     \\\\\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x;}\n\nconst int N = 1200021, MOD = 1e9 + 7;\n\nll fact[N], g[N];\n\nll pw(ll a, ll b)\n{\n\tif(!b)\n\t\treturn 1;\n\tll c = pw(a, b/2);\n\tc = c * c % MOD;\n\treturn c * (b % 2 ? a : 1) % MOD;\n}\n\nll c(int k, int n)\n{\n\tif(n >= k)\n\t\treturn fact[n] * pw(fact[k], MOD - 2) % MOD * pw(fact[n - k], MOD - 2) % MOD;\n\treturn 0;\n}\n\nint main()\n{\n\tint n = in();\n\tfact[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\tif(n == 2)\n\t\tcout << 1 << endl;\n\telse\n\t{\n\t\tn--;\n\t\tll ans  = 0;\n\t\tcerr << n << endl;\n\t\tfor(int k = 2; k <= n; k++)\n\t\t{\n\t\t\tg[k] = fact[n - k] * fact[k] % MOD * c(n - k, k - 1) % MOD; // f[n - k][n - 2]\n\t\t\tans += (g[k] - g[k - 1] + MOD) % MOD * k % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned ui;\ntypedef unsigned long long ul;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\ntypedef pair<bool, bool> pbb;\ntypedef vector<int> vi;\n#define pb push_back\n#define fi first\n#define se second\n#define mid ((l + r) >> 1)\n#define ls (i << 1)\n#define rs (i << 1 | 1)\n#define enum(i, j, k) for(int i = j; i <= (k); i ++)\n#define open(i, j, k) for(int i = j; i <  (k); i ++)\n#define dec(i, j, k)  for(int i = j; i >= (k); i --)\n#define ae(x) for(node *p = h[x]; p; p = p->nxt)\n#define fill(x, k) memset(x, k, sizeof x)\n#define copy(x, y) memcpy(x, y, sizeof x)\n#define fio(x) freopen(x\".in\", \"r\", stdin); freopen(x\".out\", \"w\", stdout);\ntemplate <class T> bool chkmin(T &x, T y)\n{ return y < x ? (x = y , true) : false; }\ntemplate <class T> bool chkmax(T &x, T y)\n{ return y > x ? (x = y , true) : false; }\nvoid __init()\n{\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cout << fixed << setprecision(16);\n    srand(time(0) ^ ui(ul(new char)));\n}\n/* default code ends here */\nconst ll mod = 1e9 + 7;\nconst int maxn = 1e6 + 10;\n\nll fpow(ll x, ll a)\n{\n\tll ret = 1;\n\tfor( ; a; a >>= 1, x = x * x % mod)\n\t\tif(a & 1)\n\t\t\tret = ret * x % mod;\n\treturn ret;\n}\nll ni(ll x)\n{\n\treturn fpow(x, mod - 2);\n}\n\nint n;\nll peng[maxn], np[maxn];\nll C(ll x, ll y)\n{\n\tif(x < y)\n\t\treturn 0;\n\telse if(x == y)\n\t\treturn 1;\n\telse\n\t\treturn peng[x] * np[y] % mod * np[x - y] % mod;\n}\nll res[maxn];\nint main()\n{\n\t__init();\n\tcin >> n;\n\tpeng[0] = np[0] = 1;\n\tenum(i, 1, n)\n\t{\n\t\tpeng[i] = peng[i - 1] * i % mod;\n\t\tnp[i] = ni(peng[i]);\n\t}\n\t\n\tll ans = 0;\n\tenum(i, 1, n - 1)\n\t\tres[i] = C(i - 1, n - i - 1) % mod * peng[i] % mod * peng[n - i - 1] % mod;\n\tdec(i, n - 1, 1)\n\t\tres[i] -= res[i - 1];\n\tenum(i, 1, n - 1)\n\t\tans = (ans + i * res[i]) % mod;\n\t\n\t/*\n\tll ans = peng[n] * n % mod;\n\tif(n >= 3)\n\t\tans = (ans - (n - 2) * C(n, 3) * 2 % mod * peng[n - 3]) % mod;*/\n\t\t\n\t\n\tcout << (ans + mod) % mod << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1e6+5,mo=1e9+7;\nint vf[N],fac[N],inv[N];\ninline int P(int n,int m){return 1ll*fac[n]*vf[n-m]%mo;}\ninline int C(int n,int m){return 1ll*vf[m]*P(n,m)%mo;}\nint n,i,ans;\nint main(){\n\tfor(int i=*vf=*fac=1;i<N;++i)\n\t\tinv[i]=i==1?1:1ll*(mo-mo/i)*inv[mo%i]%mo,\n\t\tvf[i]=1ll*vf[i-1]*inv[i]%mo,\n\t\tfac[i]=1ll*fac[i-1]*i%mo;\n\tscanf(\"%d\",&n);\n\tfor(i=n+1>>1;i<n;++i)\n\t\tans=(ans+1ll*fac[n-1-i]*(P(n-1,i)+mo-1ll*C(i-1,n-1-i)*fac[i]%mo))%mo;\n\tans=(ans+1ll*(n+1>>1)*fac[n-1])%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nconst int64_t M = 1000000007;\nconst int MAX_N = 1000000;\nint64_t fact[MAX_N];\nint64_t inv[MAX_N];\n\nint64_t mod_pow(int64_t a, int64_t b)\n{\n  if (b == 0) return 1;\n  int64_t ret = mod_pow(a, b/2);\n  ret = ret * ret % M;\n  if (b % 2 == 1) ret = a * ret % M;\n  return ret;\n}\n\nint64_t comb(int64_t n, int64_t k)\n{\n  return (fact[n] * inv[n-k] % M) * inv[k] % M;\n}\n\nint main()\n{\n  cin >> n;\n\n  fact[0] = inv[0] = 1;\n  for (int i = 1; i < n; i++) {\n    fact[i] = fact[i-1] * i % M;\n    inv[i] = mod_pow(fact[i], M-2);\n  }\n\n  int64_t sum = 0;\n\n  int64_t prev_c = 0;\n  for (int k = 1; k <= n-1; k++) {\n    if (k - 1 >= n - 1 - k) {\n      int64_t c = (comb(k-1, n-1-k) * fact[k] % M) * fact[n-1-k] % M;\n      sum = (sum + k * ((c - prev_c + M) % M) % M) % M;\n      prev_c = c;\n    }\n  }\n\n  cout << sum << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1000 * 1000 * 1000 + 7;\n\nll Pow(ll x, ll n) {\n  ll result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      n--;\n      result = result * x % mod;\n    } else {\n      n /= 2;\n      x = x * x % mod;\n    }\n  }\n  return result;\n}\n\nll Inv(ll x) {\n  return Pow(x, mod - 2);\n}\n\nconst int maxn = 1000 * 1000 + 2;\nll fact[maxn], inv[maxn];\n\nll C(int n, int k) {\n  if (n < k) return 0;\n  ll result = fact[n];\n  result = result * inv[k] % mod;\n  result = result * inv[n - k] % mod;\n  return result;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n\n  fact[0] = 1;\n  inv[0] = 1;\n  for (ll i = 1; i < maxn; ++i) {\n    fact[i] = fact[i - 1] * i % mod;\n    inv[i] = Inv(fact[i]);\n  }\n\n  vector<ll> A(n);\n  for (int k = 1; k < n; ++k) {\n    A[k] = C(k - 1, n - 1 - k) * fact[k] % mod * fact[n - 1 - k] % mod;\n  }\n\n  ll result = 0;\n  for (ll k = 1; k < n; ++k) {\n    result += k * (A[k] - A[k - 1] + mod) % mod;\n    result %= mod;\n  }\n\n  cout << result << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\n\n\nvoid go(){\n    calc();\n    int n=in();\n    mint ans = 0;\n    rep2(i,1,n-1) ans += (cmb(i-1,n-1-i)*prd[i]*prd[n-1-i]-cmb(i-2,n-i)*prd[i-1]*prd[n-i])*i;\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (int) (n); ++i)\n#define __ << \" \" <<\n\nconst int N = 1000, MOD = (int)1e9 + 7;\nlong long f[N][N], g[N][N];\n\nint main() {\n  //freopen(\"input.txt\", \"r\", stdin);\n  ios::sync_with_stdio(false); cin.tie(0);\n \n  int n; cin >> n;\n  if (n > N) exit(1);\n  f[1][1] = 0;\n  g[1][1] = 1;\n  for (int i = 2; i < n; i++) {\n    for (int x = 1; x <= i; x++) {\n      g[i][x] = (g[i - 1][x - 1] * (x - 1) + f[i - 1][x] * x) % MOD;\n      \n      f[i][x] = (f[i][x - 1] + f[i - 1][x-1] + g[i - 1][x-1]) % MOD;\n    }\n  }\n\n  long long ans = 0;\n  for (int x = 1; x < n; x++) ans += (f[n - 1][x] + g[n-1][x]) * x % MOD;\n\n  cout << ans % MOD << endl;\n  //1, 4, 16, 84, 522, 3768, 30936\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 1000100;\nconst int base = 1e9+7;\n\nint n;\nll fac[maxn],ifac[maxn];\n\nll pw(int a,int n) {\n    if (n==0) return 1ll;\n    if (n==1) return a;\n    ll tg = pw(a,n/2);\n    tg = (tg*tg) % base;\n    if (n%2) return (tg*a)%base;\n    return tg;\n}\n\nll C(int k,int n) {\n    if (k > n) return 0;\n    return (fac[n] * ifac[k] % base * ifac[n-k])%base;\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    fac[0] = 1, ifac[0] = 1;\n    for (int i=1;i<maxn;i++) {\n        fac[i] = (fac[i-1]*1ll*i)%base;\n        ifac[i] = pw(fac[i],base-2);\n    }\n    //cout<<C(1,1)<<endl;\n    cin>>n;\n    ll res=0,pre=0;\n    for (int i=(n+1)/2;i<n;i++) {\n        ll now = C(n-i-1,i-1) * fac[i] %base * fac[n-i-1] % base;\n        res = (res + 1ll*i*(now-pre)%base)%base;\n        pre = now;\n    }\n    cout<<res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 1000005;\nll F[MAXN];\nll fac[MAXN], invfac[MAXN];\nconst ll MOD = 1000000007;\nll binom(int a, int b) {\n\tif (b < 0) return 0;\n\tif (b > a) return 0;\n\treturn (((fac[a] * invfac[b]) % MOD) * invfac[a - b]) % MOD;\n}\nll modex(ll a, ll p, ll m = MOD) {\n\tif (!p) return 1;\n\tif (p & 1) return a * modex(a, p - 1, m) % m;\n\tll v = modex(a, p >> 1, m);\n\treturn v * v % m;\n}\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfac[i] = (fac[i - 1] * i) % MOD;\n\tinvfac[MAXN - 1] = modex(fac[MAXN - 1], MOD - 2);\n\tfor (int i = MAXN - 2; i >= 0; --i)\n\t\tinvfac[i] = (invfac[i + 1] * (i + 1)) % MOD;\n\tint N;\n\tscanf(\"%d\", &N);\n\tll ans = 0;\n\tfor (int k = 1; k < N; ++k) {\n\t\tF[k] = binom(k - 1, N - k - 1) * fac[k] % MOD * fac[N - 1 - k] % MOD;\n\t\tll val = F[k] - F[k - 1];\n\t\tval %= MOD;\n\t\tans += k * val;\n\t\tans %= MOD;\n\t}\n\tif (ans < 0) ans += MOD;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n & 1) return (a * powmod(a, n - 1, mod)) % mod;\n\treturn powmod((a * a) % mod, n / 2, mod);\n}\n\nint mod = 1000000007;\nint n;\nint fact[1000010];\nint factInv[1000010];\nint f[1000010];\n\nvoid initFact() {\n\tfact[0] = 1;\n\tfactInv[0] = 1;\n\tfor (int i = 1; i < 1000010; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t\tfactInv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n}\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * factInv[k] % mod * factInv[n - k] % mod;\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\t\n\tinitFact();\n\t\n\t/*dp[1][1] = 1;\n\tfor (i = 1; i <= n - 2; i++) {\n\t\tfor (j = 1; j <= i; j++) {\n\t\t\tdp[i + 1][j + 1] += dp[i][j] * (j + 1); dp[i + 1][j + 1] %= mod;\n\t\t\tdp[i + 2][j + 1] += dp[i][j] * (j + 1); dp[i + 2][j + 1] %= mod;\n\t\t}\n\t}*/\n\t\n\t//f[j] = dp[n - 1][j] = fact[j] * comb[j - 1][n - 1 - j]. (1 <= j <= n - 1)\n\tfor (i = 1; i < n; i++) {\n\t\tf[i] = fact[i] * comb(i - 1, n - 1 - i) % mod;\n\t\t//cout << i - 1 << \" \" << n - 1 - i << \" \" << comb(i - 1, n - 1 - i) << endl;\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 1; i <= n - 1; i++) {\n\t\tint cnt = (f[i] - (f[i - 1] * (n - i)) % mod + mod) % mod;\n\t\t//cout << \"i = \" << i << \", dp = \" << dp[n - 1][i] << endl;\n\t\tans += cnt * i;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ld long double\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nconstexpr double eps=1e-8;\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint Random(int mi,int ma){\n    random_device rnd;\n    mt19937 mt(rnd());//32bit\n    //[mi,ma]\n    uniform_int_distribution<int>engine(mi,ma);\n    return engine(mt);\n}\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nvector<int>kaijo,invkaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    invkaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n    rep(i,n+1)invkaijo[i]=modpow(kaijo[i],mod-2);\n}\nint comb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return kaijo[a]*invkaijo[a-b]%mod*invkaijo[b]%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nsigned main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    int n,ans=0,memo=0;\n    cin>>n;\n    init_fact(n);\n    for(int k=1;k<=n-1;k++){\n        if(k-1<n-1-k)continue;\n        int c=comb(k-1,n-1-k)*kaijo[k]%mod*kaijo[n-1-k]%mod;\n        ans+=k*(c-memo+mod)%mod;\n        memo=c;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433L;\n\ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n/*\n * @title ModInt\n */\ntemplate<long long mod> class ModInt {\npublic:\n\tlong long x;\n\tconstexpr ModInt():x(0) {\n\t\t// do nothing\n\t}\n\tconstexpr ModInt(long long y) : x(y>=0?(y%mod): (mod - (-y)%mod)%mod) {\n\t\t// do nothing\n\t}\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const long long y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const int y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const long long y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const int y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt operator=(const int y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator=(const long long y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator-() const { return ModInt(-x); }\n\tModInt operator++() { \n\t\tx++;\n\t\tif(x>=mod) x-=mod;\n\t\treturn *this; \n\t}\n\tModInt operator--() { \n\t\tx--;\n\t\tif(x<0) x+=mod;\n\t\treturn *this; \n\t}\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\tModInt inv() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(long long n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tlong long t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n};\nusing modint = ModInt<MOD>;\n\n/*\n * @title CombinationMod\n */\ntemplate<long long mod> class CombinationMod {\n\tvector<long long> fac,finv,inv;\npublic:\n\tCombinationMod(int N) : fac(N + 1), finv(N + 1), inv(N + 1) {\n\t\tfac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n\t\tfor (int i = 2; i <= N; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % mod;\n\t\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n\tinline long long binom(int n, int k) {\n\t\treturn ((n < 0 || k < 0 || n < k) ? 0 : fac[n] * (finv[k] * finv[n - k] % mod) % mod);\n\t}\n\tinline long long factorial(int n) {\n\t\treturn (n<0?0:fac[n]);\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc021/tasks/abc021_d\nCombinationMod<MOD> CM(1000000);\nint N; \nmodint f(int l,int r) {\n    modint sum = 0;\n    for(int i=0;i<=N/2;++i) {\n        int use=i;\n        use += (l&1?(l-1)/2+1:l/2);\n        use += (r&1?(r-1)/2+1:r/2);\n        int res=N-1-(use+1);\n        int can=0;\n        can += (l&1?(l-3)/2:max(0,(l-2)/2));\n        can += (r&1?(r-3)/2:max(0,(r-2)/2));\n        modint cnt = 1;\n        cnt *= CM.factorial(use);\n        cnt *= CM.factorial(res);\n        cnt *= CM.binom(can,i);\n        cnt *= use+1;\n        sum += cnt;\n    }\n    return sum;\n}\nint main() {\n    cin >> N;\n    corner(N==2,1);\n    corner(N==3,4);\n    modint ans = 0;\n    for(int i = 1; i+1<=N; ++i) {\n        {\n            int l = i-1,r=N-(i+1);\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n        {\n            int l = i-1,r=N-i;\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n        {\n            int l = i,r=N-(i+1);\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.141592653897932384626\n//freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\nusing namespace std;\n#define M 1000000007LL\nlong long k[1000006];\ninline long long qm(long long a,long long x)\n{\n    long long s,c;\n    s=1;\n    c=a;\n    while(x){\n        if(x&1)s=(s*c)%M;\n        c=(c*c)%M;\n        x>>=1;\n    }\n    return s;\n}\nint main()\n{\n    long long n;\n    cin>>n;\n    k[0]=1;\n    for(long long i=1;i<1000001LL;++i){k[i]=(k[i-1]*i)%M;}\n    long long x=(n+1)/2,y;\n    long long s=0,s1=0;\n    for(;x<n;++x){\n        y=(k[x-1]*qm(k[x*2-n],M-2)%M*qm(k[n-x-1],M-2)%M*k[x]%M*k[n-x-1]%M-s1+M)%M;\n        s1=(s1+y)%M;\n        s=(s+y*x%M)%M;\n        //cout<<x<<' '<<y<<' '<<s1<<' '<<s<<endl;\n    }\n    printf(\"%lld\\n\",s);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define re register\n#define il inline\n#define ll long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define fp(i,a,b) for(re int i=a;i<=b;i++)\n#define fq(i,a,b) for(re int i=a;i>=b;i--)\nusing namespace std;\nconst int mod=1e9+7,N=1e6+100;\nll n,x,jc[N],p,ans,Need,sum[N];\nil ll gi()\n{\n  re ll x=0,t=1;\n  re char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n  if(ch=='-') t=-1,ch=getchar();\n  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();\n  return x*t;\n}\nil ll ksm(re ll S,re ll n)\n{\n  re ll T=S;S=1;\n  while(n)\n    {\n      if(n&1) S=S*T%mod;\n      T=T*T%mod;\n      n>>=1;\n    }\n  return S;\n}\nil ll C(re ll x,re ll y)\n{\n  return jc[y]*ksm(jc[y-x]*jc[x]%mod,mod-2)%mod;\n}\nint main()\n{\n  n=gi();n--;Need=n/2+1;\n  jc[0]=1;sum[0]=1;\n  fp(i,1,n) sum[i]=(sum[i-1]*2)%mod,jc[i]=jc[i-1]*i%mod;jc[1]=0;jc[0]=0;\n  //fp(i,2,n) {jc[i]-=jc[i-1];if(jc[i]<0) jc[i]+=mod;}\n  fp(i,Need,n)\n    {\n      re ll tot=jc[i]-jc[i-1];if(!tot) ++tot;if(tot<0) tot+=mod;\n      //printf(\"%d %lld\\n\",i,tot);\n      (ans+=(tot*i%mod))%=mod;\n    }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M = 1e9 + 7;\n\nll n, ans;\nll fac[1000005];\nll fiv[1000005];\nll s[1000005];\nll a[1000005];\n\nll C(ll p, ll q)\n{\n    if(p < 0 || q < 0 || p < q) return 0;\n    return fac[p] * fiv[q] % M * fiv[p - q] % M;\n}\n\nint main()\n{\n    cin>>n;\n    fac[0] = 1;\n    for(ll i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % M;\n    fiv[n] = 1;\n    ll t = fac[n];\n    for(ll i = 0; (1 << i) <= M - 2; i++)\n    {\n        if((1 << i) & (M - 2)) fiv[n] *= t, fiv[n] %= M;\n        t *= t;\n        t %= M;\n    }\n    for(ll i = n - 1; i >= 0; i--)\n    {\n        fiv[i] = fiv[i + 1] * (i + 1) % M;\n    }\n    for(ll i = 1; i < n; i++)\n    {\n        s[i] = C(i - 1, n - i - 1) * fac[i] % M * fac[n - i - 1] % M;\n        a[i] = s[i] - s[i - 1] + M;\n        a[i] %= M;\n        ans += a[i] * i % M;\n        ans %= M;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1000000007;\nll n,a[1000005]={1},b[1000005]={1,1},ans;\nll C(ll n,ll m)\n{\n\tif (m<0 || m>n) return 0;\n\treturn a[n]*b[m]%mod*b[n-m]%mod;\n}\nint main()\n{\n\tcin>>n;\n\tfor (int i=1;i<=n;i++) a[i]=a[i-1]*i%mod;\n\tfor (int i=2;i<=n;i++) b[i]=mod-mod/i*b[mod%i]%mod;\n\tfor (int i=2;i<=n;i++) b[i]=b[i]*b[i-1]%mod;\n\tfor (int i=0;i<n;i++) ans=(ans+a[n-1]-C(i-1,n-1-i)*a[i]%mod*a[n-1-i])%mod;\n\tans=(ans+mod)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nconst LL mods=1000000007LL;\nconst int MAXN=1000000;\nstruct M{\n\tLL x;\n\tM(){\n\t\tx=0;\n\t}\n\tM(LL angka){\n\t\tif(angka>=mods||angka<=-mods)\n\t\t\tangka%=mods;\n\t\tif(angka<0)\n\t\t\tangka+=mods;\n\t\tx=angka;\n\t}\n\t\n\tM operator + (const M &other) const{\n\t\treturn M(x+other.x);\n\t}\n\tM operator - (const M &other) const{\n\t\treturn M(x-other.x);\n\t}\n\tM operator * (const M &other) const{\n\t\treturn M(x*other.x);\n\t}\n\tM operator - () const{\n\t\treturn M(-x);\n\t}\n};\nint n;\nM fakt[MAXN+5],invfakt[MAXN+5],pways[MAXN+5],ans;\nM DnC(M angka,LL pangkat){\n\tif(pangkat==0)\n\t\treturn 1;\n\tM ret=DnC(angka,pangkat>>1);\n\tret=ret*ret;\n\tif(pangkat&1)\n\t\tret=ret*angka;\n\treturn ret;\n}\nM inv(int n,int k){\n\t//cout<<\"ngeinv \"<<n<<\" \"<<k<<endl;\n\tM ret;\n\tint i,j;\n\tfor(int ulang=0;ulang<2;ulang++)\n\t{\n\t\tif(ulang==0)\n\t\t\ti=n-2*k,j=k;\n\t\telse\n\t\t\ti=n-2*k+1,j=k-1;\n\t\tif(!(i>=0&&j>=0))\n\t\t\tcontinue;\n\t\tret=ret+fakt[i+j]*invfakt[i]*invfakt[j];\n\t}\n\treturn ret;\n}\nM ways(int i){\n\treturn inv(n-3,(n-1)-i);\n}\nvoid isipways(){\n\tM substract;\n\tfor(int i=2;i<=n-1;i++)\n\t{\n\t\t//cout<<\"untuk \"<<i<<\" caranya \"<<ways(i).x<<endl;\n\t\tpways[i]=ways(i)*fakt[i]-substract;\n\t\tsubstract=substract+pways[i];\n\t\tsubstract=substract*(n-i-1);\n\t\t//cout<<\"pways \"<<i<<\" \"<<pways[i].x<<endl;\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tif(n==2)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tif(n==3)\n\t{\n\t\tcout<<4<<endl;\n\t\treturn 0;\n\t}\n\tfakt[0]=1;\n\tinvfakt[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfakt[i]=fakt[i-1]*i;\n\t\tinvfakt[i]=DnC(fakt[i],mods-2);\n\t}\n\tisipways();\n\tfor(int i=2;i<=n-1;i++)\n\t\tans=ans+pways[i]*fakt[n-1-i]*i;\n\tprintf(\"%lld\\n\",ans.x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long\n#define MOD 1000000007\n\n#define MODA(a, b) ((a + b) % MOD)\n#define MODS(a, b) (((a - b) % MOD + MOD) % MOD)\n#define MODM(a, b) (a * b % MOD)\n\nll power_mod(ll x, ll n) {\n  if (n == 0)\n    return 1;\n  else if (n % 2)\n    return MODM(x, power_mod(x, n - 1));\n  else\n    return power_mod(MODM(x, x), n / 2);\n}\n\nll facts[1000000];\nll rfacts[1000000];\n\nll comb(ll n, ll k) {\n  if (n == 0 || k == 0 || n - k == 0) return 1;\n  return MODM(MODM(facts[n], rfacts[k]), rfacts[n - k]);\n}\n\nint main() {\n  int upper = 1000000;\n\n  ll f = 1;\n  facts[0] = 1;\n  for (int i = 1; i <= upper; i++) {\n    f = MODM(f, i);\n    facts[i] = f;\n    rfacts[i] = power_mod(f, MOD - 2);\n  }\n\n  //ここでcomb()使った処理\n  int n;\n  std::cin >> n;\n\n  ll res = 0;\n  ll pre = 0;\n  for (int k = (n - 1) / 2 + 1; k < n; k++) {\n    ll cnt = MODM(MODM(comb(k - 1, n - k - 1), facts[k]), facts[n - k - 1]);\n\n    res = MODA(res, MODM(k, MODS(cnt, pre)));\n    pre = cnt;\n  }\n\n  std::cout << res << std::endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=2222222;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\nint N;\nsigned main(){\n    cin>>N;\n\n    if(N==2){\n        cout<<1<<endl;\n        return 0;\n    }\n    N--;\n\n    int ans=N*fact[N]%mod;\n    add(ans,mod-(N-2)*fact[N-1]%mod);\n    for(int i=2;i<N;i++){\n        int b=N-2-i-(i-1);\n        int tmp=nCk(i+b,b)*fact[N-i]%mod*fact[i]%mod;\n        add(ans,mod-tmp);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll; \nll fact[1000005], inv[1000005]; \ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD; \n\t\ta = a * a % MOD; \n\t\tn >>= 1; \n\t}\n\treturn res; \n}\ninline ll C(int n, int m)\n{\n\tif (n < m)\n\t\treturn 0; \n\treturn fact[n] * inv[m] % MOD * inv[n - m] % MOD; \n}\nint main()\n{\n\t// freopen(\"AGC023-C.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d\", &n); \n\tll ans = 0; \n\tfact[0] = 1; \n\tfor (int i = 1; i <= n; i++)\n\t\tfact[i] = fact[i - 1] * i % MOD; \n\tinv[n] = quick_pow(fact[n], MOD - 2); \n\tfor (int i = n; i; i--)\n\t\tinv[i - 1] = inv[i] * i % MOD; \n\tfor (int k = 1; k < n; k++)\n\t\t(ans += C(k - 1, n - k - 1) * fact[k] % MOD * fact[n - k - 1]) %= MOD; \n\tprintf(\"%lld\\n\", (fact[n - 1] * n - ans + MOD) % MOD);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n\ni64 MOD = 1e9 + 7;\ni64 inv_mod(i64 a, i64 m = MOD) {\n  i64 b, x, u, q, abs_m, tmp;\n\n  abs_m = (m < 0) ? -m : m;\n  b = m;\n  x = 1;\n  u = 0;\n  while (b > 0) {\n    q = a / b;\n    tmp = u;\n    u = x - q * u;\n    x = tmp;\n    tmp = b;\n    b = a - q * b;\n    a = tmp;\n  }\n\n  return (x < 0) ? abs_m + x : x;\n}\nint main(){\n  int N;\n  cin >> N;\n\n  if(N == 2){\n    cout << 1 << endl;\n  }\n  else if(N == 3){\n    cout << 4 << endl;\n  }\n\n  vector<i64> fact(1010101,0);\n  fact[0] = 1;\n  rep(i,1,1010100){\n    fact[i] = (fact[i - 1] * i) % MOD;\n  }\n  vector<i64> inv_fact(1010101,0);\n  inv_fact[1010100] = inv_mod(fact[1010100]);\n  for(int i = 1010100 - 1;i >= 0;i--){\n    inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n  }\n  i64 ans = 0;\n\n  i64 before = 0;\n  rep(i,1,N - 1){\n    i64 p = fact[i] * fact[N - i - 1];\n    p %= MOD;\n    int n = i - 1;\n    int r = N - i - 1;\n    if(n < r) continue;\n    i64 q = (fact[n] * inv_fact[r]) % MOD ;\n    q = (q * inv_fact[n - r]) % MOD;\n    ans = (ans + ((p * q % MOD + MOD - before) % MOD) * i) % MOD;\n    before = q * p % MOD;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"---------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\t\t\t\t\t\tFor(_x,L,R)cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector <int> vi;\ntypedef long double LD;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=1000005,mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor(;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n;\nint Fac[N],Inv[N];\nvoid prework(){\n\tint n=N-1;\n\tfor (int i=Fac[0]=1;i<=n;i++)\n\t\tFac[i]=(LL)Fac[i-1]*i%mod;\n\tInv[n]=Pow(Fac[n],mod-2);\n\tFod(i,n,1)\n\t\tInv[i-1]=(LL)Inv[i]*i%mod;\n}\nint C(int n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn (LL)Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nint a[N];\nint main(){\n\tprework();\n\tn=read();\n\tFor(i,1,n-1){\n\t\tif (i*2<n)\n\t\t\tcontinue;\n\t\tint A=n/2,B=n-A-2,r=i*2-n;\n\t\ta[i]=(LL)Fac[i]*Fac[n-1-i]%mod*C(A,(r+1)>>1)%mod*C(B,r>>1)%mod;\n\t}\n\tint ans=0;\n\toutarr(a,1,n-1);\n\tFod(i,n-1,1){\n\t\tDel(a[i],a[i-1]);\n\t\tAdd(ans,(LL)a[i]*i%mod);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool p(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 100)sum += (x % poow(sinsuu, i + 1)) / (poow(sinsuu, i));\n\treturn sum;\n}\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[1114514];\nsigned main(){\n\tic(n)\n\tint k=1;\n\trep(2,i,n){\n\t\tif(i==2)k*=i;\n\t\telse k*=(i-1);\n\t\tk%=mod;\n\t}\n\ta[0]=k;\n\tint j=1;\n\tint l=n-3;\n\tint t=1;\n\trep(1,i,n/2){\n\t\tint bu=(sankaku(i+1)-1+(n-i*2-2)*i)%mod;\n\t\ta[i]=gyakugen(a[i-1],j*bu%mod)*((l*2-t+mod)%mod*sankaku(i)%mod)%mod;\n\t\tif(i<n/2-1){\n\t\t\tj=gyakugen(j,i)*(n-i*2)%mod;\n\t\t\tj=gyakugen(j,n-i-1)*(n-i*2-1)%mod;\n\t\t\tl=gyakugen(l,i+1)*(n-i*2-2)%mod;\n\t\t\tl=gyakugen(l,n-i-2)*(n-i*2-3)%mod;\n\t\t\tt=gyakugen(t,i)*(n-i*2-2)%mod;\n\t\t\tt=gyakugen(t,n-i-3)*(n-i*2-3)%mod;\n\t\t}\n\t\t\n\t}\n\tint ans=0;\n\trep(0,i,n){\n\t\tans+=a[i]*i;\n\t\tans%=mod;\n\t}\n\tint m=n-1;\n\trep(1,i,n){\n\t\tm*=i;\n\t\tm%=mod;\n\t}\t\n\tc((m+mod-ans)%mod)\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 1000100;\nconst int base = 1e9+7;\n\nint n;\nll fac[maxn],ifac[maxn];\n\nll pw(int a,int n) {\n    if (n==0) return 1ll;\n    if (n==1) return a;\n    ll tg = pw(a,n/2);\n    tg = (tg*tg) % base;\n    if (n%2) return (tg*a)%base;\n    return tg;\n}\n\nll C(int k,int n) {\n    if (k > n) return 0;\n    return (fac[n] * ifac[k] % base * ifac[n-k])%base;\n}\n\nint main() {\n    //freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    fac[0] = 1, ifac[0] = 1;\n    for (int i=1;i<maxn;i++) {\n        fac[i] = (fac[i-1]*1ll*i)%base;\n        ifac[i] = pw(fac[i],base-2);\n    }\n    //cout<<C(1,1)<<endl;\n    cin>>n;\n    ll res=0,pre=0;\n    for (int i=n/2;i<n;i++) {\n        ll now = C(n-i-1,i-1) * fac[i] %base * fac[n-i-1] % base;\n        res = (res + 1ll*i*(now-pre)%base)%base;\n        pre = now;\n    }\n    cout<<res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconstexpr int mod = 1000000007;\nint n, fact[1000009], inv[1000009], factinv[1000009], val[1000009];\nint main() {\n\tcin >> n;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = 1LL * fact[i - 1] * i % mod;\n\t}\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tinv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\t}\n\tfactinv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfactinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\t}\n\tfor (int i = n - 1; 2 * i - n >= 0; i--) {\n\t\tval[i] = 1LL * fact[i - 1] * factinv[2 * i - n] % mod * fact[i] % mod;\n\t}\n\tint ret = 0;\n\tfor (int i = n - 1; 2 * i - n >= 0; i--) {\n\t\tret = (ret + 1LL * (val[i] - val[i - 1] + mod) * i) % mod;\n\t}\n\tcout << ret << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 2000005, MOD = 1000000007;\nint f[N], finv[N], act[N];\n\nint mul(int a, int b) {\n    return (ll)a * b % MOD;\n}\n\nvoid precalc() {\n    f[0] = 1;\n    for (int i = 1; i < N; i++) {\n        f[i] = mul(f[i - 1], i);\n    }\n    finv[0] = finv[1] = 1;\n    for (int i = 2; i < N; i++) {\n        finv[i] = (MOD - mul(MOD / i, finv[MOD % i])) % MOD;\n    }\n    for (int i = 2; i < N; i++) {\n        finv[i] = mul(finv[i - 1], finv[i]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(cout.fixed);\n    cout.precision(20);\n    precalc();\n    int n;\n    cin >> n;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        act[k] = mul(mul(f[k - 1], f[k]), finv[2 * k - n]);\n    }\n    ll res = 0;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        res = (res + mul(k, act[k] - act[k - 1])) % MOD;\n    }\n    cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#include <bitset>\n\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f3f3f3f3fLL\n#define SIZE 8080\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntypedef pair<double, int> pdi;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nll N;\nll dp[1145141]={0};\nll MOD = 1000000007;\nll bik[1145141];\nll bikinv[1145141];\nll gcd(ll a, ll b) {\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {\n\treturn a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\nll invMod(ll a, ll m) {\n\tll x, y;\n\tif (extgcd(a, m, x, y) == 1) return (x + m) % m;\n\telse                         return 0; // unsolvable\n}\nvoid bikcal(int NN){\n\tll hoge=(ll)1;\n\tbik[0]=(ll)1;\n\tbikinv[0]=(ll)1;\n\tfor(int i=1;i<NN;i++){\n\t\thoge=(hoge*(ll)i)%MOD;\n\t\tbik[i]=hoge;\n\t\tbikinv[i]=invMod(bik[i],MOD);\n\t}\n}\n\n\nll Comb(int a,int b){\n\tll ret;\n\tret=(((bik[a]*bikinv[b])%MOD)*bikinv[a-b])%MOD;\n\treturn ret;\n}\nint main(){\n\tcin>>N;\n\tint now=0;\n\tbikcal(N+1);\n\t//cout<<bikinv[0]<<endl;\n\t//cout<<Comb(4,0)<<endl;\n\tll ans=0;\n\tfor(int i=(N+1)/2;i<=N-1;i++){\n\t\tdp[i]=(((bik[i]*bik[N-i-1])%MOD)*Comb(i-1,2*i-N))%MOD;\n\t\t//if(i!=(N-1)&&(N%2==1))dp[i]=(2*dp[i])%MOD;\n\t\t//cout<<dp[i]<<endl;\n\t\tans=(ans+(((dp[i]-dp[i-1]+MOD)%MOD)*(ll)i)%MOD)%MOD;\n\t\t//cout<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nconstexpr int64 mod = 1e9+7;\n\nint64 fact[1123456] = {}, inv[1123456] = {};\n\nint64 mpow(int64 a, int64 b){\n\tif(b == 0) return 1;\n\tif(b%2) return a*mpow(a, b-1)%mod;\n\tint64 ret = mpow(a, b/2);\n\treturn ret*ret%mod;\n}\n\nint64 comb(int64 a, int64 b){\n\tif(a < b) return 0;\n\treturn fact[a]*inv[b]%mod*inv[a-b]%mod;\n}\n\nvoid init(){\n\tfact[0] = 1;\n\tREP(i, 1123455) fact[i+1] = fact[i]*(i+1)%mod;\n\tinv[1123455] = mpow(fact[1123455], mod-2);\n\tfor(int32 i = 1123454;i >= 0;i--) inv[i] = inv[i+1]*(i+1)%mod;\n}\n\nint main(void){\n\tint64 N;\n\tcin >> N;\n\tint64 bef = 0;\n\tint64 res = 0;\n\tinit();\n\tREP(k, N){\n\t\tint64 now = fact[k]*fact[N-1-k]%mod*comb(k-1, N-1-k)%mod;\n\t\tres = (res+(now-bef+mod)%mod*k%mod)%mod;\n\t\tbef = now;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\ntypedef unsigned long long ull;\n\n/////////////////////////////////\n\nint const MAX = 2e6 + 41;\nint const MOD = 1e9 + 7;\n\nint add(int a, int b) {\n\ta += b;\n\twhile (a >= MOD) a -= MOD;\n\twhile (a < 0) a += MOD;\n\treturn a;\n}\n\nint mult(int a, int b) {\n\treturn (ll) a * b % MOD;\n}\n\nint bp(int x, int d) {\n\tint res = 1;\n\twhile (d) {\n\t\tif (d & 1) res = mult(res, x);\n\t\tx = mult(x, x);\n\t\td >>= 1;\n\t}\n\treturn res;\n}\n\nint inv(int x) {\n\treturn bp(x, MOD - 2);\n}\n\nint f[MAX];\nint invf[MAX];\n\nvoid init() {\n\tf[0] = 1;\n\tfi(1, MAX - 1) {\n\t\tf[i] = mult(f[i - 1], i);\n\t}\n\tfi(0, MAX - 1) {\n\t\tinvf[i] = inv(f[i]);\n\t}\n}\n\nint getc(int n, int k) {\n\tif (k > n) return 0;\n\treturn mult(f[n], mult(invf[k], invf[n - k]));\n}\n\nint ans;\nint n;\n\nint getways(int a, int b) {\n\tif (b == 0) return 1;\n\tint rema = a - (b - 1);\n\treturn getc(b + rema, rema);\n}\n\nvoid solve1() {\n\tint res = 0;\n\tfdi(n, 2) {\n\t\tint a = i - 2;\n\t\tint b = n - i;\n\t\tif (b - 1 > a) continue;\n\t\tint v1 = f[a];\n\t\tint v2 = f[b];\n\t\tint v3 = getways(a, b);\n\t\tint v4 = i - 1;\n\t\tint v = mult(v1, mult(v2, mult(v3, v4)));\n\t\tv = mult(v, i);\n\t\tres = add(res, v);\n\t\t/*\n\t\terr(\"i = %d v = %d\\n\", i, v);\n\t\terr(\"v1 = %d v2 = %d v3 = %d v4 = %d\\n\", v1, v2, v3, v4);\n\t\t*/\n\t}\n\tres = mult(res, 2);\n\tans = add(ans, res);\n}\n\nvoid solve2() {\n\tint res = 0;\n\tfdi(n, 3) {\n\t\tint a = i - 2 - 1;\n\t\tint b = n - i;\n\t\tif (b - 1 <= a) {\n\t\t\tint v1 = f[a];\n\t\t\tint v2 = f[b];\n\t\t\tint v3 = getways(a, b);\n\t\t\tint v4 = mult(i - 1, i - 2);\n\t\t\tint v5 = mult(b, 2);\n\t\t\tint v = mult(v1, mult(v2, mult(v3, mult(v4, v5))));\n\t\t\tv = mult(v, i);\n//\t\t\terr(\"i = %d v1 = %d\\n\", i, v);\n\t\t\tres = add(res, v);\n\t\t}\n\n\t\tb--;\n\t\tif (b - 1 <= a) {\n\t\t\tint v1 = f[a];\n\t\t\tint v2 = f[b + 1];\n\t\t\tint v3 = getways(a, b);\n\t\t\tint v4 = mult(i - 1, i - 2);\n\t\t\tint v5 = b;\n\t\t\tint v = mult(v1, mult(v2, mult(v3, mult(v4, v5))));\n\t\t\tv = mult(v, i);\n\t\t\tres = add(res, v);\n//\t\t\terr(\"i = %d v2 = %d\\n\", i, v);\n\t\t}\n\t}\n\tans = add(ans, res);\n}\n\nvoid solve() {\n\tif (n == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\tsolve1();\n\tsolve2();\n\t\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tinit();\n\tscanf(\"%d\", &n);  \n\tn--;\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n) - 1; i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\ntemplate<typename T, typename S>\nistream& operator>> (istream& in, pair<S, T>& p) {\n    in >> p.fs >> p.sn;\n    return in;\n}\ntemplate<typename T, typename S>\nostream& operator<< (ostream& out, pair<S, T>& p) {\n    out << p.fs << ' ' << p.sn << ' ';\n    return out;\n}\n\ntemplate<typename T>\nistream& operator>> (istream& in, vector<T>& v) {\n    for (T& x : v) in >> x;\n    return in;\n}\ntemplate<typename T>\nostream& operator<< (ostream& out, vector<T>& v) {\n    for (T& x : v) out << x << ' ';\n    return out;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nconst int N = 1e6 + 100;\nll fact[N], tcaf[N], score[N];\n\nll Pow(ll a, ll b) {\n    ll x = 1, y = a;\n    while (b) {\n        if (b % 2) (x *= y) %= MOD;\n        (y *= y) %= MOD;\n        b /= 2;\n    }\n    return x;\n}\n\nll Inv(ll x) {\n    return Pow(x, MOD - 2);\n}\n\nll choose(int n, int k) {\n    if (n < 0) return 0;\n    if (k < 0) return 0;\n    if (k > n) return 0;\n    return fact[n] * tcaf[k] % MOD * tcaf[n - k] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); \n    srand((unsigned)chrono::high_resolution_clock::now().time_since_epoch().count());\n    fact[0] = 1;\n    forn(i, 1, N)\n        fact[i] = fact[i - 1] * i % MOD;\n    tcaf[N - 1] = Inv(fact[N - 1]);\n    ford(i, 0, N - 1)\n        tcaf[i] = tcaf[i + 1] * (i + 1) % MOD;\n\n    int n;\n    cin >> n;\n    fact[0] = 1;\n    forn(k, 0, n)\n        score[k] = choose(k - 1, n - k - 1) * fact[n - k - 1] % MOD * fact[k] % MOD;\n    //forn(k, 0, n) cerr << score[k] << ' ';\n    ll ans = 0;\n    forn(k, 0, n) {\n        ans += k * (MOD + score[k] - (k ? score[k - 1] : 0));\n        ans %= MOD;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1000000007, MAXN = 1000 * 1000 + 100;\n\nint ans[MAXN], fact[MAXN], inv[MAXN];\n\nvoid PreWorks();\nint power(int a, int b);\nint chose(int k, int n);\n\nint main() {\n\tPreWorks();\n\tint n;\n\tll all = 0;\n\tcin >> n;\n\tfor (int i = 0; i <= n; i++)\n\t\tans[i] = (ll)chose(n - i - 1, i - 1) * fact[i] % MOD * fact[n - i - 1] % MOD;\n\tfor (int i = 1; i < n; i++) {\n\t\tall += (ll)(ans[i] - ans[i - 1]) * i % MOD;\n\t\t//cerr << ans[i] << ' ';\n\t\tall %= MOD;\n\t}\n\t//cerr << endl;\n\tcout << (all + MOD) % MOD;\n}\n\nint power(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\tint t = power(a, b / 2);\n\treturn b % 2? (ll)t * t % MOD * a % MOD: (ll)t * t % MOD;\n} \n\nvoid PreWorks() {\n\tfact[0] = 1;\n\tinv[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\tinv[i] = power(fact[i], MOD - 2);\n\t}\n}\n\nint chose(int k, int n) {\n\tif(k >= 0 && n >= k) return (ll)fact[n] * inv[n - k] % MOD * inv[k] % MOD;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(int i=(a);i<=(b);++i)\n#define rep(i,n) rep2(i,0,n-1)\nint MOD=1000000000+7;\n\nusing namespace std;\nstring alphabet(\"abcdefghijklmnopqrstuvwxyz\");\nint mem[1000001][1000001]={};\nll int dp[1000001][1000001]={};\n\nint dp(a,b){\n    if(mem[a][b]==1) return dp[a][b];\n    if(a==2&&b==1) return 1;\n    if(a>b*2) return 0;\n    if(a<b+2) return 0;\n    mem[a][b]=1;\n    return dp[a][b]=dp[a-1][b-1]+dp[a-2][b-1];\n}\nmain(){\n    int n;\n    cin>>n;\n    ll int ans=0;\n    ll int per[1000001]={};\nper[0]=1;\nll int temp=1;\nrep2(i,1,1000000){\n    per[i]=temp;\n    temp*=(i+1);\n    temp%=MOD;\n}\n    rep2(i,n%2+1,n-1)\n    {\n        ans+=dp[n][i]*per(n-i);\n        ans%=MOD;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//start of jonathanirvings' template v3.0.3 (BETA)\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\ntypedef pair<string,string> pss;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef vector<LL> vl;\ntypedef vector<vl> vvl;\n\ndouble EPS = 1e-9;\nint INF = 1000000005;\nlong long INFF = 1000000000000000005LL;\ndouble PI = acos(-1);\nint dirx[8] = {-1,0,0,1,-1,-1,1,1};\nint diry[8] = {0,1,-1,0,-1,1,-1,1};\n\n#ifdef TESTING\n  #define DEBUG fprintf(stderr,\"====TESTING====\\n\")\n  #define VALUE(x) cerr << \"The value of \" << #x << \" is \" << x << endl\n  #define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n  #define DEBUG \n  #define VALUE(x)\n  #define debug(...)\n#endif\n\n#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))\n#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))\n#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))\n#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))\n#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))\n#define FOREACH(a,b) for (auto &(a) : (b))\n#define REP(i,n) FOR(i,0,n)\n#define REPN(i,n) FORN(i,1,n)\n#define MAX(a,b) a = max(a,b)\n#define MIN(a,b) a = min(a,b)\n#define SQR(x) ((LL)(x) * (x))\n#define RESET(a,b) memset(a,b,sizeof(a))\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ALL(v) v.begin(),v.end()\n#define ALLA(arr,sz) arr,arr+sz\n#define SIZE(v) (int)v.size()\n#define SORT(v) sort(ALL(v))\n#define REVERSE(v) reverse(ALL(v))\n#define SORTA(arr,sz) sort(ALLA(arr,sz))\n#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))\n#define PERMUTE next_permutation\n#define TC(t) while(t--)\n\ninline string IntToString(LL a){\n  char x[100];\n  sprintf(x,\"%lld\",a); string s = x;\n  return s;\n}\n\ninline LL StringToInt(string a){\n  char x[100]; LL res;\n  strcpy(x,a.c_str()); sscanf(x,\"%lld\",&res);\n  return res;\n}\n\ninline string GetString(void){\n  char x[1000005];\n  scanf(\"%s\",x); string s = x;\n  return s;\n}\n\ninline string uppercase(string s){\n  int n = SIZE(s); \n  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';\n  return s;\n}\n\ninline string lowercase(string s){\n  int n = SIZE(s); \n  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';\n  return s;\n}\n\ninline void OPEN (string s) {\n  #ifndef TESTING\n  freopen ((s + \".in\").c_str (), \"r\", stdin);\n  freopen ((s + \".out\").c_str (), \"w\", stdout);\n  #endif\n}\n\n//end of jonathanirvings' template v3.0.3 (BETA)\n\nint f(int n,int turns)\n{\n  vi urut;\n  REP(i,n-1) urut.pb(i);\n  int ret = 0;\n  do\n  { \n    vector<bool> dah(n,false);\n    REP(i,n-1)\n    {\n      dah[urut[i]] = dah[urut[i] + 1] = true;\n      REP(j,n) if (!dah[j]) goto lanjut;\n      if (i + 1 >= turns) ++ret;\n      goto hell;\n      lanjut:;\n    }\n    hell:;\n  } while (PERMUTE(ALL(urut)));\n  return ret;\n}\n\nLL MOD = 1e9 + 7;\n\nLL powmod(LL a, LL b)\n{\n  if (b == 0) return 1;\n  LL tmp = powmod(a,b/2);\n  LL tmp2 = tmp * tmp % MOD;\n  if (b % 2 == 0) return tmp2;\n  return tmp2 * a % MOD;\n}\n\nLL inv(LL a) {return powmod(a,MOD-2);};\n\nLL fact[1000005];\nint n;\n\n// ada berapa perm yang score <= turns\nLL g(int n,int turns)\n{\n  if (turns == 0) return 0;\n  if (turns * 2 < n) return 0;\n  if (turns == n - 1) return fact[turns];\n  LL now = fact[turns];\n  int mulai = turns - 1;\n  int bagi = mulai - (n - turns - 1);\n  LL ret = now * fact[mulai] % MOD;\n  ret = ret * inv(fact[bagi]) % MOD;\n  return ret;\n}\n\n// ada berapa perm yang score >= turns\nLL h(int n, int turns)\n{\n  LL ret = fact[n - 1];\n  ret = ret - g(n,turns - 1);\n  if (ret < 0) ret += MOD;\n  return ret;\n}\n\nint main()\n{\n  fact[0] = 1;\n  FORN(i,1,1000000)\n  {\n    fact[i] = (fact[i-1] * i) % MOD;\n  }\n  // FORN(i,2,10)\n  // {\n  //   FORN(j,1,i-1) debug(\"%10d\",f(i,j));\n  //   debug(\"\\n\");\n  //   // FORN(j,1,i-1) printf(\"%d %d %d\\n\",i,j,f(i,j));\n  // }\n  // FORN(i,2,10)\n  // {\n  //   FORN(j,1,i-1) debug(\"%10d\",h(i,j));\n  //   debug(\"\\n\");\n  //   // FORN(j,1,i-1) printf(\"%d %d %d\\n\",i,j,f(i,j));\n  // }\n  // return 0;\n  while (scanf(\"%d\",&n)!=EOF)\n  {\n    // fact[0] = 1;\n    // FORN(i,1,n)\n    // {\n    //   fact[i] = (fact[i-1] * i) % MOD;\n    // }\n    LL risan = 0;\n    FORN(i,1,n-1)\n    {\n      risan = (risan + h(n,i)) % MOD;\n    }\n    printf(\"%lld\\n\",risan);\n  }\n  // FORN(i,2,12)\n  // {\n  //   FORN(j,1,i-1) debug(\"%10d\",f(i,j));\n  //   debug(\"\\n\");\n  //   // FORN(j,1,i-1) printf(\"%d %d %d\\n\",i,j,f(i,j));\n  // }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define dmp(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl;\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\ntemplate<class T,class U>\nostream& operator << (ostream& os,pair<T,U>& p){\n\tos << p.fi << ',' << p.sec; return os;\n}\ntemplate<class T,class U>\nistream& operator >> (istream& is,pair<T,U>& p){\n\tis >> p.fi >> p.sec; return is;\n}\ntemplate<class T>\nostream& operator << (ostream &os,const vector<T> &vec){\n\tfor(int i=0;i<vec.size();i++){\n\t\tos << vec[i];\n\t\tif(i+1<vec.size())os << ' ';\n\t}\n\treturn os;\n}\ntemplate<class T>\nistream& operator >> (istream &is,vector<T>& vec){\n\tfor(int i=0;i<vec.size();i++)is >> vec[i];\n\treturn is;\n}\nvoid fastio(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n}\nll MOD = 1000000007ll; // if inv is needed, this shold be prime.\nstruct ModInt{\n\tll val;\n\tModInt():val(0ll){}\n\tModInt(ll v):val(((v%MOD)+MOD)%MOD){}\n\tModInt exp(ll y)const{\n\t\tif(!y)return ModInt(1ll);\n\t\tModInt a = exp(y/2ll);\n\t\ta *= a;\n\t\tif(y&1)a*=(*this);\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& x)const{return val==x.val;}\n\tinline bool operator!=(const ModInt& x)const{return !(*this==x);}\n\tbool operator<(const ModInt& x)const{return val<x.val;}\n\tbool operator>(const ModInt& x)const{return val>x.val;}\n\tinline bool operator>=(const ModInt& x)const{return !(*this<x);}\n\tinline bool operator<=(const ModInt& x)const{return !(*this>x);}\n\tModInt& operator+=(const ModInt& x){if((val+=x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator-=(const ModInt& x){if((val+=MOD-x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator*=(const ModInt& x){(val*=x.val)%=MOD;return *this;}\n\tModInt operator+(const ModInt& x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt& x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt& x)const{return ModInt(*this)*=x;}\n};\nistream& operator>>(istream&i,ModInt&x){i>>x.val;return i;}\nostream& operator<<(ostream&o,const ModInt&x){o<<x.val;return o;}\nModInt pow(ModInt a,ll x){\n\tModInt res = ModInt(1ll);\n\twhile(x){\n\t\tif(x&1)res *= a;\n\t\tx >>= 1;\n\t\ta = a*a;\n\t}\n\treturn res;\n}\nconst int SIZE = 1000100;\nModInt inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\n// notice: 0C0 = 1 \nModInt nCr(int n,int r){\n\tassert(!(n<r));\n\tassert(!(n<0||r<0));\n\treturn fac[n]*facinv[r]*facinv[n-r];\n}\nvoid init(){\n\tfac[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)fac[i]=fac[i-1]*ModInt(i);\n\tinv[1]=ModInt(1ll);\n\tfor(int i=2;i<=SIZE;i++)inv[i]=ModInt(0ll)-ModInt(MOD/i)*inv[MOD%i];\n\tfacinv[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=facinv[i-1]*inv[i];\n\treturn;\n}\nint N;\nModInt rui[1000100];\nint main(){\n  init();\n  cin >> N;\n  for(int i=0;i<N;i++){\n    if(i-1>=N-1-i){\n      rui[i] = nCr(i-1,N-1-i)*fac[i]*fac[N-1-i];\n    }\n  }\n  ModInt ans;\n  for(int i=N-1;i>0;i--){\n    ans += ModInt(i)*(rui[i]-rui[i-1]);\n  }\n  cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb(x) push_back(x)\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod){}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int operator -() const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow(ll n) const{\n        Mod_Int now = *this, ret;\n        ret.x = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse() const{\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e6;\nmint fac[MAX_N+1];\n\nvoid init(){\n    fac[0] = {1};\n    rep2(i, 1, MAX_N){\n        mint a = {i};\n        fac[i] = fac[i-1]*a;\n    }\n}\n\nmint comb(mint n, mint k){\n    return fac[n.x]/(fac[n.x-k.x]*fac[k.x]);\n}\n\nmint perm(mint n, mint k){\n    return fac[n.x]/fac[n.x-k.x];\n}\nint main(){\n    init();\n    int N;\n    cin >> N;\n    //num[i]:=スコアがi以下になるような並べ方の数\n    mint ans = {0}, num[N];\n    //i個のマシンで全てを黒にする場合\n    rep(i, N){\n        if(2*i < N) {num[i] = {0}; continue;}\n        num[i] = fac[i]*fac[N-1-i]*comb(i-1, N-i-1);\n        ans += (num[i]-num[i-1])*i;\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nInt mod = 1000000007;\n\nInt fact[1123456];\n\nvoid init() {\n   fact[0] = 1;\n   for(Int i = 1; i < 1123456; ++i) {\n      fact[i] = fact[i-1] * i % mod;\n   }\n}\n\nInt pow(Int x, Int n) {\n   if( n == 0 ) return 1;\n   Int t = pow(x,n/2);\n   return n % 2 == 0 ? (t * t % mod) : (t * t % mod * x % mod);\n}\n\nInt div(Int x, Int y) {\n   return x * pow(y, mod-2) % mod;\n}\n\nInt nCr(Int n, Int r) {\n   return div(fact[n], fact[r] * fact[n-r] % mod);\n}\n\n// void solve(Int n) {\n//    std::vector<Int> xs(n-1);\n//    rep(i,n-1) {\n//       xs[i] = i;\n//    }\n//    Int res = 0;\n//    std::vector<Int> counts(n, 0);\n//    do {\n//       std::vector<bool> ys(n,false);\n//       for(Int i = 0; i < n-1; ++i) {\n//          ys[xs[i]] = ys[xs[i]+1] = true;\n//          bool end = true;\n//          for(Int k = 0; k < n; ++k) {\n//             if( not ys[k] ) end = false;\n//          }\n//          if( end ) {\n//             counts[i] += 1;\n//             if( i+1 == 4 ) {\n//                for(Int j = 0; j < n-1; ++j) {\n//                   printf(\"%ld \", xs[j]);\n//                }\n//                puts(\"\");\n//             }\n//             res += (i+1);\n//             break;\n//          }\n//       }\n//    } while( std::next_permutation(xs.begin(), xs.end()) );\n//    for(Int i = 0; i < n; ++i) {\n//       printf(\"score[%ld] : %ld\\n\", i+1, counts[i]);\n//    }\n//    printf(\"%ld\\n\", res);\n// }\n\nint main() {\n   init();\n   Int n;\n   std::cin >> n;\n   Int res = 0;\n   std::vector<Int> xs(n);\n   for(Int k = (n+1)/2; k < n; ++k) {\n      xs[k] = nCr(k-1, n-k-1) * fact[k] % mod * fact[n-1-k] % mod;\n   }\n   for(Int k = (n+1)/2; k < n; ++k) {\n      Int diff = xs[k] - xs[k-1];\n      Int t = diff * k % mod;\n      res = (res + t) % mod;\n   }\n   printf(\"%ld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <string>\n#include <utility>\n#include <map>\n#include <deque>\n\nusing namespace std;\n#define rep(i,n) for(int i=1;i<=(int)(n);i++)\n#define Rep(i,n) for(int i=0;i<=(int)(n-1);i++)\ntypedef long long ll;\ntypedef map<int,int> mint;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\ntypedef deque<pair<ll,ll>> dep;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint inf=1e9+1000;\nconst int mod=1e9+7;\nll infi=1e18+100;\n\nll N;\n\nll f(ll n){\n\tif(n==0) return 1;\n\telse return (n*frac(n))%mod;\n}\n\n\nint main(){\n\tcin>>N;\n\tll ninzuu[N+1]={};\n\tll frac[N+3]={};\n\tfor(ll i=0;i<=N;i++) frac[i]=f(i);\n\tll sum=0;\n\tif(N%2==0){\n\t\tfor(ll i=N/2;i<=N;i++){\n\t\t\tif(i==N/2) ninzuu[i]=frac[i];\n\t\t\telse{\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\t}\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t}\n\telse{\n\t\tfor(ll i=(N+1)/2;i<=N;i++){\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t\t\n\t}\n\tcout<<(sum)%mod<<endl;\n\t\n\t\n\t\n\t  return 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=1000005,M=1e9+7;\nint fac[N],inv[N],n;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\n}\nint C(int x,int y){\n\tif (x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nint w(int k){\n\tint x=n-2-k;\n\tint y=k-x;\n\treturn C(x+y,x);\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif (n==2){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M,inv[i]=ksm(fac[i],M-2);\n\tint ans=fac[n-1];\n\tfor (int i=1;i<n;i++)(ans+=(C(n-2,i)+C(n-2,i-1)-w(i-1)+M)*fac[i]%M*fac[n-i-1])%=M;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nconst int N = 5000001;\nlong long fact[N];\nlong long invfact[N];\nlong long inv[N];\nvoid init() {\n        fact[0] = fact[1] = 1;\n        for (int i = 2; i < N; i ++) fact[i] = fact[i - 1] * i % MOD;\n        inv[1] = 1;\n        for (int i = 2; i < N; i ++) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;\n        invfact[0] = invfact[1] = 1;\n        for (int i = 2; i < N; i ++) invfact[i] = invfact[i - 1] * inv[i] % MOD;\n}\nlong long C(long long n, long long r) {\n        if (r == 0) return 1;\n        if (n < 0 || r < 0 || n < r) return 0;\n        return fact[n] * invfact[n - r] % MOD * invfact[r] % MOD;\n}\n\nint main() {\n        init();\n        int n;\n        scanf(\"%d\", &n);\n        long long ans = fact[n];\n        for (int k = 1; k <= n - 1; k ++) {\n                ans -= C(k - 1, n - 1 - k) * fact[k] % MOD * fact[n - 1 - k] % MOD;\n                cerr << ans << endl;\n                if (ans < 0) ans += MOD;\n        }\n        printf(\"%lld\\n\", ans);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nll mpow(ll a, ll b){\n\tif(b==0) return 1;\n\telse if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n\telse return mpow(a,b-1) * a % MOD;\n}\nll gcd(ll a, ll b){\n\tif(b==0) return a;\n\telse return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n\tif(kaijo_memo.size() > n) return kaijo_memo[n];\n\tif(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n\twhile(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n\treturn kaijo_memo[n];\n}\nll nCr(ll n, ll r){\n\tif(n < r || r < 0) return 0;\n\tll ret = 1;\n\tret *= kaijo(n); ret %= MOD;\n\tret *= mpow(kaijo(r), MOD-2); ret %= MOD;\n\tret *= mpow(kaijo(n-r), MOD-2); ret %= MOD;\n\treturn ret;\n}\n\nint main(void){\n\tll n;\n\tcin>>n;\n\tll ans = 0;\n\tif(n==2){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\treps(k, (n-1)/2){\n\t\tll add = 1;\n\t\tadd *= nCr(n-k-2, k-1); add %= MOD;\n\t\tadd *= kaijo(k-1); add %= MOD;\n\t\tadd *= kaijo(n-k-1); add %= MOD;\n\t\tadd *= 2;\n\t\tadd *= (n-k); add %= MOD;\n\t\tadd *= k; add %= MOD;\n\t\tans += add;\n\t\tans %= MOD;\n\t}\n\n\treps(k, (n-2)/2){\n\t\tll add = 1;\n\t\tadd *= nCr(n-k-3, k-1);add%=MOD;\n\t\tadd *= kaijo(k);add%=MOD;\n\t\tadd *= kaijo(n-k-2);add%=MOD;\n\t\tadd *= n-k-1;add%=MOD;\n\t\tadd *= k+1;add%=MOD;\n\t\tans += add;\n\t\tans %=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i > 0; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main() {\n\tstd::size_t n;\n\tuint64 ans;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = N >> 1; i < N - 1; ++i) {\n\t\tans += fact.v2[i] * ifact.val[(i << 1) - N] % M;\n\t}\n\tans = (fact.val[N - 1] * (N - 1) + M - ans) % M;\n\tprintf(\"%llu\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main() {\n\tunsigned int n;\n\tuint64 ans=0;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = (N + 1) >> 1; i < N - 1; ++i) {\n\t\tans += fact.v2[i] * ifact.val[(i << 1) - N] % M;\n\t}\n\tans = (fact.val[N - 1] * (N - 1) + M - ans) % M;\n\tprintf(\"%llu\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define MAXN 100009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<\"----------------\"<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<\" = \"<< x<<endl;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nconst int N=1e6+5;\nint F[N],inv[N];\nint mod(ll x){\n\twhile(x<0)\n\t\tx+=INF;\n\treturn (x%INF);\n}\nint Fe(int x,int y){\n\tif(!y)\n\t\treturn 1;\n\tint h=Fe(x,y/2);\n\th=mod(h*1LL*h);\n\tif(y&1)\n\t\th=mod(h*1LL*x);\n\treturn h;\t\n}\nint C(int x,int y){\n\t//~ printf(\"C(%d,%d) = %d\\n\"x,y,mod(F[x]*1LL*mod(inv[y]*1LL*inv[x-y])));\n\treturn mod(F[x]*1LL*mod(inv[y]*1LL*inv[x-y]));\n}\nint main(){\n    //~ freopen(\"file.in\", \"r\", stdin);\n    int n;\n    scanf(\"%d\",&n);\n    if(n==2)\n\t\treturn 0*puts(\"1\");\n\tif(n==3)\n\t\treturn 0*puts(\"4\");\n\tinv[0]=F[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tF[i]=mod(F[i-1]*1LL*i);\n\tinv[N-2]=Fe(F[N-2],INF-2);\n\tfor(int i=N-3;i>=1;i--)\n\t\tinv[i]=mod(inv[i+1]*1LL*(i+1));\n\tint ans=F[n];\n\tfor(int k=(n+1)/2;k<n;k++)\n\t\tans=mod(ans-mod(C(k-1,n-1-k)*1LL*mod(F[k]*1LL*F[n-1-k])));\n\tprintf(\"%d\\n\",ans);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing\tnamespace\tstd;\n#define ll long long\n#define\tllu\tunsigned\tlong\tlong\n#define\tld\tdouble\n#define\tllu\tunsigned\tlong\tlong\n#define\trep(i,x,y)\t\tfor(ll\ti=x;i<y;++i)\n#define\tFor(i,x,y)\t\tfor(ll\ti=x;i<=y;++i)\n#define\tFOr(i,x,y)\t\tfor(ll\ti=(ll)(x);i>=(ll)(y);--i)\n#define\tpi\tacos(-1)\t\n#define\tmk\tmake_pair\n#define\tpa\tpair<ll,ll>\n#define\tlf\telse\tif\n#define\tIL\tinline\n#define\tmax(x,y)\t\t\t\t((x)<(y)?(y):(x))\n#define\tmin(x,y)\t\t\t\t((x)<(y)?(x):(y))\n#define\tsqr(x)\t\t\t\t\t\t((x)*(x))\n#define\tMul(x,y)\t\t\t\t((x)=1LL*(x)*(y)%mod)\n#define\tAdd(x,y)\t\t\t\t((x)=((x)+(y))%mod)\n#define\tMax(x,y)\t\t\t\t((x)=((x)<(y)?(y):(x)))\n#define\tMin(x,y)\t\t\t\t((x)=((x)>(y)?(y):(x)))\n#define\tE(x)\t\t\t\t\treturn\twriteln(x),0\n#define\tLL\t\t\t\t\t\t(long\tlong)\n#define\tp(x)\t\t\t\t\tprllf(\"~%lld~\\n\",LL(x))\n#define\tpp(x,y)\t\t\t\t\tprllf(\"~~%lld\t%lld~~\\n\",LL(x),LL(y))\n#define\tppp(x,y,z)\t\t\t\tprllf(\"~~~%lld\t%lld\t%lld~~~\\n\",LL(x),LL(y),LL(z))\n#define\tpppp(a,b,c,d)\t\t\tprllf(\"~~~%lld\t%lld\t%lld\t%lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define\tf_in(x)\t\t\t\t\tfreopen(x\".in\",\"r\",stdin)\n#define\tf_out(x)\t\t\t\tfreopen(x\".out\",\"w\",stdout)\n#define\topen(x)\t\t\t\t\tf_in(x),f_out(x)\n#define\tfi\tfirst\n#define\tse\tsecond\n#define\tGuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef\tcomplex<double>\tE;\nnamespace\tSHENZHEBEI{\n#ifdef\tLOCAL\n\t\t\t\tstruct\t_{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\t\n#define\tNEG\t1\n\t\t\t\tinline\tchar\tgc(){\treturn\tgetchar();\t}\n#if\tNEG\n\t\t\t\tinline\tll\tread(){\t\t\t\tll\tx=0,fa=1;\tchar\tch=gc();\t\t\tfor\t(;!isdigit(ch);ch=gc())\tif\t(ch=='-')\tfa=-1;\t\tfor\t(;isdigit(ch);ch=gc())\t\tx=x*10-48+ch;\t\t\treturn\tx*fa;\t}\n\t\t\t\tinline\tvoid\twrite(ll\tx){\t\t\t\tif\t(x<0)\tputchar('-'),x=-x;\t\tif\t(x>=10)\t\t\twrite(x/10);\t\t\t\tputchar(x%10+'0');\t\t}\n#else\n\t\t\t\tinline\tll\tread(){\t\t\t\tll\tx=0;\tchar\tch=gc();\t\t\tfor\t(;!isdigit(ch);ch=gc());\t\t\t\tfor\t(;isdigit(ch);ch=gc())\t\tx=x*10-48+ch;\t\t\treturn\tx;\t\t\t}\n\t\t\t\tinline\tvoid\twrite(ll\tx){\t\t\t\tif\t(x>=10)\t\t\twrite(x/10);\t\t\t\tputchar(x%10+'0');\t\t}\n#endif\n\tvoid\twriteln(ll\tx){write(x);puts(\"\");}\n}using\tnamespace\tSHENZHEBEI;\nconst ll mod=1e9+7,N=1000010;\nll f[N],ans=0,n,fac[N],inv[N],chos[N],before;\nll ppow(ll x,ll k){ll ans=1;for(;k;k>>=1,Mul(x,x))if(k&1)Mul(ans,x);return ans;}\nll C(ll n,ll k){return (n>=k)?(fac[n]*inv[k]%mod*inv[n-k]%mod):0ll;}\nint main(){\n\tn=read();\n\tfac[0]=1;For(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tinv[n]=ppow(fac[n],mod-2);FOr(i,n,1)inv[i-1]=inv[i]*i%mod;\n\tFor(i,0,n)\tf[i]=C(n-i-2,i)*fac[n-i-1]%mod*fac[i]%mod;\n\tFor(i,0,n)\tAdd(f[i],-f[i+1]);\n\tFor(i,0,n)\tAdd(ans,(n-i-1)*f[i]);\n\twriteln((ans+mod)%mod);\n}\n/*\nooooo\noo**o**\nsimga\nn/p>=i*i\nn/(i*i)>=p\nsigma(i=1..sqrt(n),i是质数)\tmin(n/i*i,sqrt(n))\n\n去掉3个合法-> \nOO**OO\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\ntypedef long long int ll;\nconst ll MODP = 1000000007LL;\n\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n\ntypedef long long int ll;\n\n\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll invMod(ll a, ll m) {\n  ll x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n  else                         return 0; // unsolvable\n}\n\n\nll powmod(ll n, ll m){ //TODO: 繰り返し二乗法に改善\n\tll ret = 1;\n\tfor(int i=0;i<m;i++){\n\t\tret = (ret * n) % MODP;\n\t}\n\treturn ret;\n}\n\n\nll comb(ll n, ll m){\n\tif (m<0 || n<m) return 0; //failsafe\n\tll ret = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tret = (ret * (n-m+i)) % MODP;\n\t\tret = (ret * invMod(i, MODP)) % MODP;\n\t}\n\treturn ret % MODP;\n}\n\n\n\nll n;\nstatic ll f[1000010];\n\nint main(void){\n\tcin >> n;\n\tf[0] = 1;\n\tfor(ll i=1;i<=n+4;i++){\n\t\tf[i] = (f[i-1] * i) % MODP;\n\t}\n\tll ans = f[n], ans2 = 0;\n\tfor(ll i=(n+1)/2;i<n;i++){\n\t\tll val = (f[i] * f[i-1]) % MODP;\n\t\t//\n\t\tval = (val * f[n-1-i]) % MODP;\n\t\tll denom = (f[2*i-n] * f[n-1-i]) % MODP;\n\t\tval = val * invMod(denom, MODP) % MODP;\n\t\tans2 = (ans2 + val) % MODP;\n\t}\n\tans = (ans - ans2 + MODP) % MODP;\n\tcout << ans << endl;\n\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nll inv(ll a, ll b){\n\treturn a-1 ? b - inv(b%a, a) * b / a : 1;\n}\n\nconst int LIM = 1e6+10;\n\nint main(){\n\tvector<ll> fs(LIM, 1), ifs(LIM);\n\trep(i,1,LIM) fs[i] = fs[i-1] * i % md;\n\trep(i,0,LIM) ifs[i] = inv(fs[i], md);\n\n\tauto choose = [&](int n, int k){\n\t\tif(k < 0 || k > n) return 0LL;\n\t\tif(n < 0) return 0LL;\n\t\treturn fs[n] * ifs[k] % md * ifs[n-k] % md;\n\t};\n\n\tauto ways = [&](int n, int k){\n\t\tll ans = choose(n-1, k);\n\t\tll cover = 0;\n\t\tint z = n-1 - k;\n\t\tif(z < 0) cover = choose(n, k);\n\t\telse cover = choose( n-2 - z, z);\n\t\tans -= cover;\n\t\tans %= md;\n\t\tif(ans < 0) ans += md;\n\t\treturn ans;\n\t};\n\t\n\tauto solve = [&](int n){\n\t\tll ans = 0;\n\t\tans += fs[n-1];\n\t\trep(k,1,n-1) ans += fs[n-1-k] * fs[k] % md * ways(n,k) % md;\n\t\tans %= md;\n\t\tif(ans < 0) ans += md;\n\t\treturn ans;\n\t};\n\n\tint n;\n\tcin >> n;\n\tcout << solve(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e6 + 10;\nconst int MOD = 1e9 + 7;\n\nint ss[MAXN], tt[MAXN];\n\nint pw(int a, int b){\n\tint ret = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tret = 1ll*ret*a%MOD;\n\t\tb >>= 1;\n\t\ta = 1ll*a*a%MOD;\n\t}\n\treturn ret;\n}\n\nint choose(int a, int b){\n\tif (min(a, b) < 0) return 0;\n\tif (b > a) return 0;\n\treturn 1ll*ss[a]*tt[b]%MOD*tt[a-b]%MOD;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tss[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) ss[i] = 1ll*ss[i-1]*i%MOD;\n\ttt[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) tt[i] = 1ll*tt[i-1]*pw(i, MOD-2) % MOD;\n\n\tint n; cin >> n;\n\tint ans = 1ll*ss[n-1]*(n-1) % MOD;\n\tfor (int k = 1; k < n-1; k++){\n\t\tint sm = n-2;\n\t\tsm -= k-1;\n\t\tif (sm < 0) continue;\n\t\tif (k-1 < sm) continue;\n\t\tint temp = choose(k-1, sm);\n\t\ttemp = 1ll*temp*ss[k]%MOD*ss[n-1-k]%MOD;\n\t\tans = (ans + MOD - temp) % MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1e9 + 7;\nconst int MX = 1e6;\nint n;\nint a[MX + 10], fac[MX + 10] = {1}, inv[MX + 10] = {1};\nint modpow(int a, long long n, int mod = MOD) {\n\tint r = 1, b = a;\n\twhile(n > 0) {\n\t\tif(n & 1) r = 1ll * r * b % mod;\n\t\tb = 1ll * b * b % mod;\n\t\tn >>= 1;\n\t}\n\treturn r;\n}\nint nCr(int n, int r) {\n\tif(r < 0 || r > n) return 0;\n\treturn 1ll * fac[n] * inv[r] % MOD * inv[n-r] % MOD;\n}\nint main() {\n\tfor(int i=1; i<=MX; i++) {\n\t\tfac[i] = 1ll * fac[i-1] * i % MOD;\n\t\tinv[i] = modpow(fac[i], MOD - 2);\n\t}\n\tscanf(\"%d\", &n);\n\tll res = 0;\n\tfor(int i=(n+1)/2; i<=n-1; i++) {\n\t\ta[i] = 1ll * nCr(i-1, n-1-i) * fac[i] % MOD * fac[n-1-i] % MOD;\n\t\tres = (res + 1ll * (a[i] - a[i-1] + MOD) % MOD * i % MOD) % MOD;\n\t}\n\tprintf(\"%lld\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pii, int > a, pair < pii, int > b)//true for a before b\n{\n\tif(a.F.F/300 < b.F.F/300)\n\t\treturn 1;\n\tif(a.F.F/300 > b.F.F/300)\n\t\treturn 0;\n\tif(a.F.S < b.F.S)\n\t\treturn 1;\n\tif(a.F.S > b.F.S)\n\t\treturn 0;\n\tif(a.F <= b.F)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (1e6) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nll fact[N], ifact[N];\n\nvoid pre()\n{\n\tint i;\n\tfact[0] = ifact[0] = 1;\n\tfo(i,1,N)\n\t{\n\t\tfact[i] = (fact[i-1] * 1LL * i)%mod;\n\t\tifact[i] = inmodx(fact[i]);\n\t}\n\treturn;\n}\n\nll choose(int n, int r)\n{\n\tif(n < 0 || r < 0 || r > n)\n\t\treturn 0LL;\n\tll ans = (fact[n]*ifact[r])%mod;\n\tans = (ans * ifact[n-r])%mod;\n\treturn ans;\n}\n\nvoid solve()\n{\n\tpre();\n\tint n, i;\n\tll ans = 0, val, sum = 0;\n\tcin >> n;\n\n\tif(n == 2)\n\t{\n\t\tcout << 1 << '\\n';\n\t\treturn;\n\t}\n\t\n\tfo(i,(n+1)/2,n)\n\t{\n\t\tval = (choose(i-1,n-1-i)*fact[i])%mod;\n\t\tval = (val * fact[n-1-i])%mod;\n\t\tans = (ans + 1LL*i*(val-sum+mod))%mod;\n\t\tsum = (sum + val)%mod;\n\t}\t\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file;\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(9);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MX 1000000\n#define mod 1000000007\nlong long fact[MX+5],inv[MX+5],dp[MX+5];\nlong long pow_log(long long x,int y)\n{\n\tif (!y)\n\treturn 1;\n\tlong long ret=pow_log(x,y/2);\n\tret=(ret*ret)%mod;\n\tif (y%2)\n\tret=(ret*x)%mod;\n\treturn ret;\n}\nlong long ncr(int n,int r)\n{\n\tif (n<r)\n\treturn 0;\n\treturn fact[n]*inv[r]%mod*inv[n-r]%mod;\n}\nint main()\n{\n\tfact[0]=1;\n\tfor (int i=1;i<=MX;i++)\n\tfact[i]=(fact[i-1]*i)%mod;\n\tinv[MX]=pow_log(fact[MX],mod-2);\n\tfor (int i=MX-1;i>=0;i--)\n\tinv[i]=(inv[i+1]*(i+1))%mod;\n\tint n;\n\tscanf(\"%d\",&n);\n\tn--;\n\tlong long ans=0;\n\tfor (int k=1;k<=n;k++)\n\t{\n\t\tdp[k]=ncr(k-1,n-k)*fact[k]%mod*fact[n-k]%mod;\n\t\tans=(ans+(dp[k]-dp[k-1]+mod)%mod*k)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, fact[10010101], ifact[10010101], ans;\nconstexpr long long int M = 1000000007;\n\nint main(){\n    scanf(\"%lld\", &N);\n    *fact = 1;\n    for(int i = 1; i < N; ++i){\n        fact[i] = fact[i - 1] * i % M;\n    }\n    long long n = M - 2, r = fact[N - 1];\n    ifact[N - 1] = 1;\n    while(n){\n        if(n & 1){\n            ifact[N - 1] = ifact[N - 1] * r % M;\n        }\n        n /= 2;\n        r = r * r % M;\n    }\n    for(int i = N - 1; i > 0; --i){\n        ifact[i - 1] = ifact[i] * i % M;\n    }\n    ans = fact[N - 1] * (N - 1);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += M - fact[i] * fact[i - 1] % M * ifact[i * 2 - N] % M;\n    }\n    ans %= M;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 2000005, MOD = 1000000007;\nint f[N], finv[N], act[N];\n\ninline void add(int &a, int b) {\n    a += b;\n    if (a >= MOD) {\n        a -= MOD;\n    }\n}\n\ninline void sub(int &a, int b) {\n    a -= b;\n    if (a < 0) {\n        a += MOD;\n    }\n}\n\ninline int mul(int a, int b) {\n    return (ll)a * b % MOD;\n}\n\nvoid precalc() {\n    f[0] = 1;\n    for (int i = 1; i < N; i++) {\n        f[i] = mul(f[i - 1], i);\n    }\n    finv[0] = finv[1] = 1;\n    for (int i = 2; i < N; i++) {\n        finv[i] = (MOD - mul(MOD / i, finv[MOD % i])) % MOD;\n    }\n    for (int i = 2; i < N; i++) {\n        finv[i] = mul(finv[i - 1], finv[i]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(cout.fixed);\n    cout.precision(20);\n    precalc();\n    int n;\n    cin >> n;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        act[k] = mul(mul(f[k - 1], f[k]), finv[2 * k - n]);\n    }\n    ll res = 0;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        int realact = act[i];\n        sub(realact, act[k - 1]);\n        add(res, mul(k, realact));\n    }\n    cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\n#define vv(a,b,c,d) vector<vector<a> >(b,vector<a>(c,d))\n#define vvv(a,b,c,d,e) vector<vector<vector<a> > >(b,vv(a,c,d,e))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate<int MOD>\nclass ModInt {\npublic:\n    ModInt() :value(0) {}\n    ModInt(long long val) :value((int)(val<0 ? MOD + val%MOD : val%MOD)) { }\n\n    ModInt& operator+=(ModInt that) {\n        value = value + that.value;\n        if (value >= MOD)value -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        value -= that.value;\n        if (value<0)value += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        value = (int)((long long)value * that.value % MOD);\n        return *this;\n    }\n    ModInt &operator/=(ModInt that) {\n        return *this *= that.inverse();\n    }\n    ModInt operator+(ModInt that) const {\n        return ModInt(*this) += that;\n    }\n    ModInt operator-(ModInt that) const {\n        return ModInt(*this) -= that;\n    }\n    ModInt operator*(ModInt that) const {\n        return ModInt(*this) *= that;\n    }\n    ModInt operator/(ModInt that) const {\n        return ModInt(*this) /= that;\n    }\n    ModInt pow(long long k) const {\n        if (value == 0)return 0;\n        ModInt n = *this, res = 1;\n        while (k) {\n            if (k & 1)res *= n;\n            n *= n;\n            k >>= 1;\n        }\n        return res;\n    }\n    ModInt inverse() const {\n        long long a = value, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n    int toi() const { return value; }\n\nprivate:\n    int value;\n};\ntypedef ModInt<1000000007> mint;\nostream& operator<<(ostream& os, const mint& x) {\n    os << x.toi();\n    return os;\n}\n\nnamespace comb {\n    const int N = 1000006;\n    mint fact[N];\n    mint rev[N];\n\n    void init() {\n        fact[0] = 1;\n        for (int i = 1; i < N; ++i)fact[i] = fact[i - 1] * i;\n        for (int i = 0; i < N; ++i)rev[i] = fact[i].inverse();\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n    using namespace comb;\n    init();\n\n    int M;\n    while (cin >> M) {\n        mint re, p;\n        for (int k = 1; k <= M - 1; ++k) {\n            int a = 2 * k - M;\n            int b = M - k - 1;\n            if (a < 0 || b < 0)continue;\n            mint q = fact[a + b] * rev[a] * rev[b] * fact[k] * fact[M - 1 - k];\n            re += (q - p)*k;\n            p = q;\n        }\n        cout << re << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nll N,inf = 1e9+7;\nll fact[1000010] = {0};\nll inv[1000010] = {0};\n\nll mult(ll n, ll m){\n\tif(m==1) return n%inf;\n\telse if(m%2==0){\n\t\tll t = mult(n,m/2);\n\t\treturn (t*t)%inf;\n\t}else{\n\t\tll t = mult(n,m-1);\n\t\treturn (t*n)%inf;\n\t}\n}\n\nvoid factorial(ll N){\n\tfor(ll i=0;i<=N;i++){\n\t\tif(i==0){\n\t\t\tfact[i] = 1;\n\t\t\tinv[i] = 1;\n\t\t}\n\t\telse{\n\t\t\tfact[i] = (i*fact[i-1])%inf;\n\t\t\tinv[i] = mult(fact[i],inf-2);\n\t\t}\n\t}\n}\n\nll comb(ll n,ll k){\n\tif(k==0 || n==k) return 1;\n\telse return (((fact[n]*inv[k])%inf)*inv[n-k])%inf;\n}\n\nll hcomb(ll n,ll k){\n\tif(n==0 && k==0) return 1;\n\treturn comb(n+k-1,k);\n}\n\nll A[1000010] = {0};\n\nint main(){\n\tcin >> N;\n\tfactorial(N);\n\tif(N==2) cout << 1 << endl;\n\telse if(N==3) cout << 4 << endl;\n\telse{\n\t\tll ans = 0;\n\t\tfor(ll i=1;i<=N-1;i++){\n\t\t\tll s = comb(i-1,N-1-i), t = (fact[i]*fact[N-1-i])%inf;\n\t\t\tA[i] = (s*t)%inf;\n\t\t\tll a = A[i]-A[i-1];\n\t\t\ta = (a+inf)%inf;\n\t\t\tans += i*a;\n\t\t\tans %= inf;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = (1LL << 32);\nconst long long MOD = 1000000007;\nconst long double PI = 3.1415926;\n#define FOR(i,r,n) for(ll i = (ll)(r); i < (ll)(n); i++)\n#define RFOR(i,r,n) for(ll i=(ll)(n-1);i>=r;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define RALL(x) x.rbegin(),x.rend()\ntypedef long long int ll;\ntypedef vector<ll> vi;\ntypedef vector<pair<ll, ll> > vp;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef list<ll> lst;\ntypedef pair<ll, ll> P;\ntemplate <class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nll n, m, k, ans = 0, sum = 0, cnt = 0;\nstring s;\n//char c;\n\n#define Endl endl\n\n/*--------------------template--------------------*/\n\n#define SIZE 2000005\nll inv[SIZE], fac[SIZE], finv[SIZE];\n\nvoid make(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    FOR(i,2,SIZE) {\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        fac[i] = fac[i - 1] * (ll)i % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nll C(ll a, ll b){\n    if(a<b) return 0;\n    return fac[a] * (finv[b] * finv[a - b] % MOD) % MOD;\n}\n\n\nint main() {\n    cin >> n;\n    if(n==2){\n        cout << 1 << endl;\n        return 0;\n    }else if(n==3){\n        cout << 4 << endl;\n        return 0;\n    }else if(n==4){\n        cout << 16 << endl;\n        return 0;\n    }\n    make();\n    ans = fac[n];\n    FOR(i,1,n) {\n        m = C(i - 1, n - 1 - i) * fac[i] % MOD * fac[n - 1 - i] % MOD;\n        //cout << \"k = \" << i << \"  \" << m << endl;\n        ans -= m;\n        if(ans<0){\n            ans += MOD;\n        }\n    }\n    cout << ans%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat pw(cat a, cat e, cat mod) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2, mod);\n\tx = (x*x) % mod;\n\tif(e&1) x = (x*a) % mod;\n\treturn x;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tif(N == 2) {\n\t\tcout << \"1\\n\";\n\t\treturn 0;\n\t}\n\tcat mod = 1000000007;\n\tvector<cat> fac(N+1, 1);\n\tfor(int i = 1; i <= N; i++) fac[i] = (i * fac[i-1]) % mod;\n\tvector<cat> inv(N+1, 1);\n\tfor(int i = 1; i <= N; i++) inv[i] = (pw(i, mod-2, mod) * inv[i-1]) % mod;\n\tcat ans = 0;\n\tfor(int i = 0; i <= N-3; i++) {\n\t\tcat cnt1 = (N-2-2*i < 0) ? 0 : (fac[N-2-i] * inv[N-2-2*i] % mod * fac[N-1-i] % mod);\n\t\tcat cnt2 = (N-2-2*(i+1) < 0) ? 0 : (fac[N-2-i-1] * inv[N-2-2*(i+1)] % mod * fac[N-2-i] % mod);\n\t\tans = (ans + (cnt1-cnt2) * (N-1-i)) % mod;\n\t}\n\tif(ans < 0) ans += mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ninline int read() {\n  int f = 1;\n  int x = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    f = (ch == '-') ? -1 : 1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return f * x;\n}\n\nconst int N = 1e6 + 5;\nconst int P = 1e9 + 7;\n\ninline int mul(int a, int b) {\n  return (long long) a * b % P;\n}\ninline int sub(int a, int b) {\n  return a - b < 0 ? a - b + P : a - b;\n}\ninline int add(int a, int b) {\n  return a + b >= P ? a + b - P : a + b;\n}\ninline int modexp(int a, int x) {\n  int ret = 1;\n  while (x) {\n    if (x & 1) {\n      ret = mul(ret, a);\n    }\n    a = mul(a, a);\n    x >>= 1;\n  }\n  return ret;\n}\n\nint n;\nint fac[N];\nint inv[N];\n\ninline int calc(int m, int n) {\n  int k = 2 * m - n;\n  if (k >= 0 && m - k >= 0) {\n    return mul(fac[m], mul(inv[k], inv[m - k]));\n  } else {\n    return 0;\n  }\n}\n\nint main() {\n  n = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  inv[n] = modexp(fac[n], P - 2);\n  for (int i = n - 1; i >= 0; --i) {\n    inv[i] = mul(inv[i + 1], i + 1);\n  }\n  int ans = 0;\n  int sum = 0;\n  for (int i = (n + 1) / 2; i < n; ++i) {\n    ans = add(ans, mul(i, sub((mul(fac[n - i - 1], mul(calc(i - 1, n - 2), fac[i]))), sum)));\n    sum = add(sum, mul(fac[n - i - 1], mul(calc(i - 1, n - 2), fac[i])));\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \n#define ll long long\n#define MOD 1000000007\n \n#define MODA(a, b) ((a + b) % MOD)\n#define MODS(a, b) (((a - b) % MOD + MOD) % MOD)\n#define MODM(a, b) (a * b % MOD)\n \nll power_mod(ll x, ll n) {\n  if (n == 0)\n    return 1;\n  else if (n % 2)\n    return MODM(x, power_mod(x, n - 1));\n  else\n    return power_mod(MODM(x, x), n / 2);\n}\n \nll facts[1000000];\nll rfacts[1000000];\n \nll comb(ll n, ll k) {\n  if (n == 0 || k == 0 || n - k == 0) return 1;\n  return MODM(MODM(facts[n], rfacts[k]), rfacts[n - k]);\n}\n \nint main() {\n  int upper = 1000000;\n \n  ll f = 1;\n  facts[0] = 1;\n  for (int i = 1; i <= upper; i++) {\n    f = MODM(f, i);\n    facts[i] = f;\n    rfacts[i] = power_mod(f, MOD - 2);\n  }\n \n  //ここでcomb()使った処理\n  int n;\n  std::cin >> n;\n \n  ll res = 0;\n  ll pre = 0;\n  for (int k = (n - 1) / 2 + 1; k < n; k++) {\n    ll cnt = MODM(MODM(comb(k - 1, n - k - 1), facts[k]), facts[n - k - 1]);\n \n    res = MODA(res, MODM(k, MODS(cnt, pre)));\n    pre = cnt;\n  }\n \n  std::cout << res << std::endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n/*#### modular_arithmetic */\nclass modular_arithmetic{\npublic:\n\tint mod;\n\tmodular_arithmetic(){\n\t\tmod = 1000000007;\n\t}\n\t//No specific settings.\n\tvoid set_mod(int _mod){mod = _mod;}\n\tint add(int x,int y){return (x+y)%mod;}\n\tint sub(int x,int y){return (x-y+mod)%mod;}\n\tint mul(int x,int y){return (int)((long long int)x*y%mod);}\n\tint pw(int x,int y){\n\t\tint r = 1;\n\t\twhile(1){\n\t\t\tif(y&1)r=mul(r,x);\n\t\t\tif(y>>=1)x=mul(x,x);else\n\t\t\t\tbreak;\n\t\t}\n\t\treturn r;\n\t}\n\t//mod must be a prime.\n\tint inv(int x){\n\t\treturn pw(x, mod-2);\n\t}\n};\n/*####*/\n\nmodular_arithmetic ma;\n\n#define ran 1000010\nint fac[ran],ifac[ran],n;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0] = 1;\n\tfor(int i=0; i<n; i++)\n\t\tfac[i+1] = ma.mul(fac[i], i+1);\n\tifac[n] = ma.inv(fac[n]);\n\tfor(int i=n-1; i>=0; i--)\n\t\tifac[i] = ma.mul(ifac[i+1], i+1);\n\tint cur = fac[(n+1)/2], step = (n+1)/2;\n\tint res = ma.mul(cur, step);\n\tint lst = cur;\n\twhile(step < n-1){\n\t\t++step;\n\t\tint d = n - step;\n\t\tcur = ma.mul(cur, fac[n-d]);\n\t\tcur = ma.mul(cur, fac[n-2*d-2]);\n\t\tcur = ma.mul(cur, ifac[n-2*d]);\n\t\tcur = ma.mul(cur, ifac[n-d-2]);\n\t\tres = ma.add(res, ma.mul(ma.sub(cur,lst), step));\n\t\tlst = cur;\n\t}\n\tprintf(\"%d\\n\",ma.mul(res, fac[(n-1)/2]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n\ntypedef long long ll;\n \ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.141592653589;\nconst int mod = 1000000007;\n// memset(a,0,sizeof(a)); →全部０にする\n \nvector<int> G[100005];\nstd::vector<P> tree[100010];\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\n\n#define p(x) cout<<x<<endl;\n \nll i,j,k,l,ii,jj;\nll n,m;\nll x,y;\nll used[200005];\nchar s[305][305];\nll ans=0;\nll v=-1,w;\nll num;\n\n\nll kai(ll n,ll x){\n\tll kei=1;\n\tfor(i=1;i<=n-x;i++){\n\t\tkei *= i;\n\t\tkei = kei%mod;\n\t}\n\treturn kei;\n\n}\nvoid kotae(ll x){\n\tfor(int i=1;i<=n;i++){\n\t\tif(!used[i]){\n\t\t\tused[i]=true;\n\t\t\tif(!used[i-1] && !used[i+1] && i>=2 && i<=n-1){\n\t\t\t\tkotae(x+1);//iminasi kakutei\n\t\t\t}else{\n\t\t\t\tans += kai(n,x);\n\t\t\t}\n\t\t\tused[i]=false;\n\t\t}\n\t}\n \n}\nint main(){\n    cin>>n;\n\t\n\n\tkotae(1);\n\t\n\tp(ans%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=1000005,mod=1000000007;\nint n,ans,f[N];\nll fac[N],ni[N];\ninline ll p(int a,int b){\n\treturn fac[a]*ni[a-b]%mod;\n}\ninline int ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=read();\n\tfor(int i=fac[0]=1;i<=n;i++)fac[i]=fac[i-1]*i%mod; ni[n]=ksm(fac[n],mod-2);\n\tfor(int i=n;i;i--)ni[i-1]=ni[i]*i%mod;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tf[i]=p(i-1,n-1-i)*fac[i]%mod;\n\t\tans=(ans+(ll)(f[i]-f[i-1])*i)%mod;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG_MODE\n#ifdef DEBUG_MODE\n\t#define _(n) n;\n#else\n\t#define _(n) ;\n#endif\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass Mod{\n    //static const int MOD = 1000000007;\npublic:\n    long long a;\n    Mod(){a = 0;}\n    Mod(long long x){a = (x % MOD + MOD) % MOD;}\n    const Mod operator+(const Mod& x) const{return Mod(a + x.a);}\n    const Mod operator-(const Mod& x) const{return Mod(a - x.a);}\n    const Mod operator*(const Mod& x) const{return Mod(a * x.a);}\n    const Mod operator/(const Mod& x) const{ //フェルマーの小定理、aとMODが互いに素の時のみ\n        if(x.a == 0)return 0;\n\t\tif(a % x.a == 0)return Mod(a/x.a);\n\t\tint b = MOD - 2;long long c = x.a;long long ret = 1;\n        while(b > 0){if(b & 1){ret *= c;ret %= MOD;}\n            c *= c;c %= MOD;b >>= 1;\n        }\n        return Mod(a * ret);\n    }\n    long long getValue(){return a;}\n};\n\nll kaijo[1111111];\n\nll combination(ll n,ll r){\n\tif(n < 0 || r < 0)return 0;\n    if(n < r)\n        return 0;\n    if(n-r < r)\n        r = n-r;\n    Mod ret = kaijo[n];\n\tMod tmp = (kaijo[r]*kaijo[n-r])%MOD;\n    ret= ret/tmp;\n\treturn ret.a;\n}\n\nll f(ll a,ll b){\n\treturn (((combination(b-1,2*b-a)*kaijo[b])%MOD)*kaijo[a-b-1])%MOD;\n}\n\n\nint main()\n{\n\tll n;cin >> n;\n\tif(n == 2){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tll ans = 0;\n\t\n\tkaijo[0] = 1;\n\tfor(int i = 1;i < 1111111;i++){\n\t\tkaijo[i] = (kaijo[i-1]*i)%MOD;\n\t}\n\t\n\tREP(i,n){\n\t\tif(i - 1 <= 0 || i * 2 - n < 0)continue;\n\t\tll A = f(n,i);\n\t\tll B = f(n,i-1);\n\t\tA -= B;\n\t\twhile(A < 0)A += MOD;\n\t\tA = (A*i)%MOD;\n\t\tans = (ans + A)%MOD;\n\t}\n\t\n\tcout << ans << endl;\n\t\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nconst long long inf = 1000000007;\n\nlong long mod_pow (long long base, long long exponent)\n{\n\tlong long ans = 1LL;\n\twhile (exponent)\n\t{\n\t\tans *= ((exponent & 1LL) ? base : 1LL);\n\t\tans %= inf;\n\n\t\texponent >>= 1;\n\t\tbase *= base;\n\t\tbase %= inf;\n\t}\n\n\treturn ans;\n}\n\nint main ()\n{\n\tlong long n;\n\tcin >> n;\n\tvector<long long> fact(n + 1);\n\tvector<long long> ifact(n + 1);\n\n\tfact[0] = 1LL;\n\tifact[0] = 1LL;\n\tfor (long long i=1; i<=n; ++i)\n\t{\n\t\tfact[i] = (i * fact[i-1]) % inf;\n\t\tifact[i] = mod_pow(fact[i], inf-2);\n\t}\n\n\tauto f = [n, fact, ifact](long long k)\n\t{\n\t\tlong long ans = fact[k-1];\n\t\tans *= ifact[n-1-k];\n\t\tans %= inf;\n\t\tans *= ifact[2*k-n];\n\t\tans %= inf;\n\t\tans *= fact[k];\n\t\tans %= inf;\n\t\tans *= fact[n-1-k];\n\t\tans %= inf;\n\t\treturn ans;\n\t};\n\n\t\n\tlong long m = (n + 1) >> 1;\n\tlong long ans = m * f(m);\n\tans %= inf;\n\tfor (long long i=m+1; i<n; ++i)\n\t{\n\t\tlong long g = f(i) - f(i-1);\n\t\tif (0 > g) g += inf;\n\t\tg %= inf;\n\t\tg *= i;\n\t\tg %= inf;\n\t\tans += g;\n\t\tans %= inf;\n\t}\n\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(int i=(a);i<=(b);++i)\n#define rep(i,n) rep2(i,0,n-1)\nint MOD=1000000000+7;\n\nusing namespace std;\nstring alphabet(\"abcdefghijklmnopqrstuvwxyz\");\nint mem[1000001][1000001]={};\nll int dp[1000001][1000001]={};\n\nint dp(int a,int b){\n    if(mem[a][b]==1) return dp[a][b];\n    if(a==2&&b==1) return 1;\n    if(a>b*2) return 0;\n    if(a<b+2) return 0;\n    mem[a][b]=1;\n    return dp[a][b]=dp[a-1][b-1]+dp[a-2][b-1];\n}\nmain(){\n    int n;\n    cin>>n;\n    ll int ans=0;\n    ll int per[1000001]={};\nper[0]=1;\nll int temp=1;\nrep2(i,1,1000000){\n    per[i]=temp;\n    temp*=(i+1);\n    temp%=MOD;\n}\n    rep2(i,n%2+1,n-1)\n    {\n        ans+=dp[n][i]*per(n-i);\n        ans%=MOD;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-4-28 22:56:15\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nconst int MAX_SIZE = 1000010;\nconst long long MOD = 1000000007;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init() {\n  inv[1] = 1;\n  for (int i=2; i<MAX_SIZE; i++) {\n    inv[i] = ((MOD - inv[MOD%i]) * (MOD/i))%MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i=1; i<MAX_SIZE; i++) {\n    fact[i] = (i * fact[i-1])%MOD;\n    factinv[i] = (inv[i] * factinv[i-1])%MOD;\n  }\n}\n\nlong long C(int n, int k) {\n  if (n >=0 && k >= 0 && n-k >= 0) {\n    return ((fact[n] * factinv[k])%MOD * factinv[n-k])%MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n) {\n  if (n == 0) {\n    return 1;\n  } else if (n%2 == 1) {\n    return (x * power(x, n-1)) % MOD;\n  } else {\n    long long half = power(x, n/2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcm(long long a, long long b) {\n  if (a < b) {\n    return gcm(b, a);\n  }\n  if (b == 0) return a;\n  return gcm(b, a%b);\n}\n\nll N;\nll Ika[200010];\n\nint main()\n{\n  init();\n  cin >> N;\n  Ika[0] = Ika[1] = 0;\n  if (N == 2)\n  {\n    cout << 1 << endl;\n    return 0;\n  }\n  for (ll A = 2; A <= N - 1; A++)\n  {\n    ll x = N - 1 - A;\n    if (x >= 0 && A >= 0)\n    {\n      Ika[A] = (((C(A - 1, N - 1 - A) * fact[x]) % MOD) * fact[A]) % MOD;\n      // cerr << \"Ika[\" << A << \"] = \" << Ika[A] << endl;\n    }\n  }\n  ll ans = 0;\n  for (ll A = 1; A <= N - 1; A++)\n  {\n    ans += (A * ((Ika[A] + MOD - Ika[A - 1]) % MOD)) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1000005;\nconst int mod = 1e9 + 7;\n\nint n, fact[N], ifact[N], f[N];\n\nint binpow(int a, int b) {\n\tint ret = 1;\n\twhile(b) {\n\t\tif (b & 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint C(int n, int k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn 1LL * fact[n] * (1LL * ifact[k] * ifact[n - k] % mod) % mod;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tifact[0] = 1;\n\tfor (int i = 1; i < N; ++i) ifact[i] = binpow(fact[i], mod - 2);\n\n\tfor (int k = 1; k <= n - 1; ++k) {\n\t\tf[k] = 1LL * C(k - 1, n - k - 1) * (1LL * fact[k] * fact[n - k - 1] % mod) % mod;\n\t}\n\n\tint res = 0;\n\tfor (int k = 1; k <= n - 1; ++k) {\n\t\tint cur = (f[k] - f[k - 1] + mod) % mod;\n\t\tres = (res + 1LL * cur * k) % mod;\n\t}\n\n\tcout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define gc getchar()\nusing namespace std;\ntypedef long long ll;\nconst int mod=1000000007;\nconst int N=1000009;\nint n,Ans,inv[N],jc[N],jc_inv[N];\nint read()\n{\n\tint x=1;\n\tchar ch;\n\twhile (ch=gc,ch<'0'||ch>'9') if (ch=='-') x=-1;\n\tint s=ch-'0';\n\twhile (ch=gc,ch>='0'&&ch<='9') s=s*10+ch-'0';\n\treturn s*x;\n}\nint C(int n,int m)\n{\n\tif (n<m||m<0) return 0;\n\treturn (ll)jc[n]*jc_inv[m]%mod*jc_inv[n-m]%mod;\n}\nint W(int k)\n{\n\treturn C(k,n-2-k);\n}\nint T(int x)\n{\n\tif (x==0) return jc[n-1];\n\treturn (ll)(C(n-2,x)+C(n-2,x-1)-W(x-1)+mod)*jc[x]%mod*jc[n-x-1]%mod;\n}\nint main()\n{\n\tjc[0]=1;\n\tfor (int i=1;i<N;i++) jc[i]=(ll)jc[i-1]*i%mod;\n\tinv[1]=1;\n\tfor (int i=2;i<N;i++) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tjc_inv[0]=1;\n\tfor (int i=1;i<N;i++) jc_inv[i]=(ll)jc_inv[i-1]*inv[i]%mod;\n\tn=read();\n\tfor (int i=0;i<n-1;i++) Ans=(Ans+T(i))%mod;\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll n,k,a[MAXN];\nll pow_mod(ll a,ll i)\n{\n\tll s=1;\n\twhile(i)\n\t{\n\t\tif(i&1) s=s*a%MOD;\n\t\ta=a*a%MOD;\n\t\ti>>=1;\n\t}\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tll ans=0;\n\tif(n&1)\n\t{\n\t\tll st=3,mult=((n+1)*(n+3)/8)%MOD,addn=7,adds=n/2+2,last=0;\n\t\tll init=2,cf=6,add=6;\n\t\tfor(ll i=5;i<=n;i+=2)\n\t\t{\n\t\t\tinit=init*cf%MOD;\n\t\t\tcf=(cf+add)%MOD;\n\t\t\tadd=add+2;\n\t\t}\n\t\t//printf(\"%lld\\n\",init);\n\t\tans+=init*((n+1)/2)%MOD;\n\t\tlast=init;\n\t\tfor(ll i=(n+1)/2+1;i<=n-1;i++)\n\t\t{\n\t\t\tinit=init*mult%MOD*pow_mod(st,MOD-2)%MOD;\n\t\t\t//printf(\"%lld\\n\",init);\n\t\t\tmult=(mult+adds)%MOD;\n\t\t\tst=(st+addn)%MOD;\n\t\t\tadds++;\n\t\t\taddn+=4;\n\t\t\tans=(ans+(init-last+MOD)*i)%MOD;\n\t\t\tlast=init;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tll st=1,mult=(n*(n+2)/8)%MOD,addn=5,adds=n/2+1,last=0;\n\t\tll init=2,cf=6,add=6;\n\t\tfor(ll i=6;i<=n;i+=2)\n\t\t{\n\t\t\tinit=init*cf%MOD;\n\t\t\tcf=(cf+add)%MOD;\n\t\t\tadd+=2;\n\t\t}\n\t\t//printf(\"%lld\\n\",init);\n\t\tans+=init*(n/2)%MOD;\n\t\tlast=init;\n\t\tfor(ll i=n/2+1;i<=n-1;i++)\n\t\t{\n\t\t\tinit=init*mult%MOD*pow_mod(st,MOD-2)%MOD;\n\t\t\t//printf(\"%lld\\n\",init);\n\t\t\tmult=(mult+adds)%MOD;\n\t\t\tst=(st+addn)%MOD;\n\t\t\tadds++;\n\t\t\taddn+=4;\n\t\t\tans=(ans+(init-last+MOD)*i)%MOD;\n\t\t\tlast=init;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <list>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <utility>\n#include <complex>\n#include <assert.h>\n#include <limits.h>\n#include <iomanip>\n//#include <bits/stdc++.h>\nusing namespace std;\n#define rank rankk\n#define mp make_pair\n#define pb push_back\n#define xo(a,b) ((b)&1?(a):0)\n#define tm tmp\n\n//#define LL ll\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll>pil;\ntypedef pair<ll,ll> pll;\n//const double INF=1e20;\nconst int INF=0x3f3f3f3f;\n//const int INF= 0x7fffffff;\n//const ll INF=0x3f3f3f3f3f3f3f3fll;\nconst ll INFF=0x3f3f3f3f3f3f3fll;\n//const ll INFF=1e14+5;\nconst int MAX=4e5+5;\n//const ll MAXN=2e8;\n//const int MAX_N=MAX;\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\n//const long double pi=acos(-1.0);\n//const double eps=0.00000001;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\n//#define double long double\ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\ninline ll powMM(ll a,ll b,ll M){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\n//const long double eps=-1.0;\n//clock_t t1 = clock();\n//fprintf(stderr, \"%ld ms\\n\", clock() - t1);\nvoid open()\n{\n    freopen(\"in2.txt\",\"r\",stdin);\n    freopen(\"out2.txt\",\"w\",stdout);\n}\nconst int MAXN=1e6+5;\nll fi[MAXN],inv[MAXN];\nll quick(ll a,ll b)\n{\n    ll an=1LL;\n    while(b)\n    {\n        if(b&1)\n        {\n            an=an*a%MOD;\n        }\n        a=a*a%MOD;\n        b/=2;\n    }\n    return an%MOD;\n}\nll C(ll a,ll b)\n{\n    if(a<0||b<0||b>a)\n        return 0LL;\n    return (fi[a]*inv[b]%MOD)*inv[a-b]%MOD;\n}\nll n;\nint main()\n{\n\n    for(ll i=0;i<=1000000;i++)\n        fi[i]=i?(fi[i-1]*i%MOD):1;\n    inv[1000000]=quick(fi[1000000],MOD-2);\n    for(ll i=1e6-1;i>=0;i--)\n        inv[i]=(i+1)*inv[i+1]%MOD;\n    scanf(\"%lld\",&n);\n    ll an=fi[n-1]*(n-1LL)%MOD;\n    for(ll k=(n+1)/2LL;k<n-1;k++)\n        an=(an+MOD-(C(k-1,n-k-1)%MOD*fi[k]%MOD*fi[n-k-1]%MOD))%MOD;\n    printf(\"%lld\\n\",an);\n\n}\n\n/*\n\n\n\n4 1 1 3 1 5 5 1 3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 1000000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(int r=0,int s=0,int c=gc()){for(;c<48||c>57;s=c,c=gc());for(;c>=48&&c<=57;(r*=10)+=c-48,c=gc());return s^'-'?r:-r;}\ninline int fxp(int s, int n=MOD-2){int a=1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\nint fac[MAXN+5], efac[MAXN+5], f[MAXN+5], s[MAXN+5], n, Ans; inline int C(int n, int k){return n<0||k<0||n<k?0:1ll*fac[n]*efac[k]%MOD*efac[n-k]%MOD;}\nint main()\n{\n\tn = read(); for(rint i = fac[0] = 1; i <= n; fac[i] = 1ll*i*fac[i-1]%MOD, i++); efac[n] = fxp(fac[n]); for(rint i = n; i; efac[i-1] = 1ll*i*efac[i]%MOD, i--);\n\tfor(rint i = 1; i <= n; f[i] = 1ll*C(i-1,n-i-1)*fac[i]%MOD*fac[n-1-i]%MOD, f[i] = (f[i]+MOD-s[i-1])%MOD, s[i] = (s[i-1]+f[i])%MOD, i++);\n\tfor(rint i = 1; i < n; Ans = (Ans+1ll*i*f[i])%MOD, i++); printf(\"%d\\n\",Ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, fact[10010101], ifact[10010101], ans;\nconstexpr long long int M = 1000000007;\n\nint main(){\n    scanf(\"%lld\", &N);\n    *fact = 1;\n    for(int i = 1; i < N; ++i){\n        fact[i] = fact[i - 1] * i % M;\n    }\n    long long n = M - 2, r = fact[N - 1];\n    ifact[N - 1] = 1;\n    while(n){\n        if(n & 1){\n            ifact[N - 1] = ifact[N - 1] * r % M;\n        }\n        n /= 2;\n        r = r * r % M;\n    }\n    for(int i = N - 1; i > 0; --i){\n        ifact[i - 1] = ifact[i] * i % M;\n    }\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += fact[i] * fact[i - 1] % M * ifact[i * 2 - N] % M;\n    }\n    ans = fact[N - 1] * (N - 1) - ans;\n    ans %= M;\n    cout << (ans < 0 ? M + ans : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename S, typename T>\nvoid incr_m(M<S, T> &m, S k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD   ((ll)pow(10LL, 9LL) + 7LL)\n\nvoid make_perms(ll perms[1000005], ll perm_invs[1000005])\n{\n    perms[0] = 1LL;\n    srep (i, 1LL, 1000005LL) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= MOD;\n    }\n\n    debug_printf(\"---- perms\\n\"); debug_print(perms, 10);\n\n    rep (i, 1000005) perm_invs[i] = mod_inv(perms[i], MOD);\n}\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n\n    if (n == 2) {\n        cout << 1 << endl;\n        return;\n    }\n    if (n == 3) {\n        cout << 2 * 2 << endl;\n        return;\n    }\n\n    static ll perms[1000005];\n    static ll perm_invs[1000005];\n    make_perms(perms, perm_invs);\n\n    static ll cnts[1000005];\n    memset(cnts, 0, sizeof(cnts));\n    rep (blackcnt, n+1LL) {\n        if (blackcnt - 1LL < n - 1LL - blackcnt) continue;\n        // (blackcnt - 1LL)_C_(n - 1LL - blackcnt)\n        cnts[blackcnt] = perms[blackcnt];\n        cnts[blackcnt] *= perm_invs[n - 1LL - blackcnt];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perm_invs[2 * blackcnt - n];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perms[blackcnt - 1LL];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perms[n - 1LL - blackcnt];\n        cnts[blackcnt] %= MOD;\n    }\n    debug_printf(\"---- cnts\\n\"); debug_print(cnts, 10);\n\n    ll ans = 0LL;\n    srep (score, 1LL, n) {\n        ll incr = cnts[score] - cnts[score-1];\n        while (incr < 0LL) incr += MOD;\n        incr *= score;\n        incr %= MOD;\n        ans += incr;\n        ans %= MOD;\n    }\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst int NUM_=1e6+10;\nll fact[NUM_+1]={},factr[NUM_+1]={},inv[NUM_+1]={};\n\nll combi(ll N_, ll C_, ll mo=MOD) {\n  auto binpow = [&](ll x, ll e) -> ll{\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % mo; e /= 2;}\n      else {a = (a*p) % mo; e--;}\n    }\n    return a;\n  };\n  if (fact[0]==0) {\n    fact[0] = factr[0] = inv[0] = 1;\n    // FOR(i, 1, NUM_+1) fact[i] = fact[i-1] * i % MOD;\n    // factr[NUM_] = binpow(fact[NUM_], mo-2);\n    // for(int i=NUM_-1; i>=0; --i) factr[i] = factr[i+1] * (i+1) % MOD;\n    FOR(i, 1, NUM_) {\n      fact[i] = fact[i-1] * i % MOD;\n      inv[i] = binpow(i, MOD-2) % MOD;\n      factr[i] = factr[i-1] * inv[i] % MOD;\n    }\n  }\n  if(C_<0 || C_>N_) return 0;\n  // 前計算 O(max(N,K)) クエリ O(1)\n  return factr[C_]*fact[N_]%MOD*factr[N_-C_]%MOD;\n  // 前計算 O(max(N,K)log(mod)) クエリ O(K)\n  // ll ret = 1;\n  // for(;C_>0;N_--,C_--) (ret *= N_%MOD) %= MOD, (ret *= inv[C_]) %= MOD;\n  // return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  if(n == 2) {\n    cout << 1 << endl;\n    return 0;\n  }\n  if(n == 3) {\n    cout << 4 << endl;\n    return 0;\n  }\n  if(n == 4) {\n    cout << 16 << endl;\n    return 0;\n  }\n  if(n == 5) {\n    cout << 84 << endl;\n    return 0;\n  }\n\n  int a = 0;\n  int ret = 0;\n  for(int i=ceil(n-4,2LL)+2; i<=n-1; ++i) {\n    int tmp = combi(i-1, n-i-1) * fact[i] % MOD * fact[n-i-1] % MOD;\n    (ret += i*(tmp-a)%MOD) %= MOD;\n    a = tmp;\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\n\n\nvector<P> v[10];\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nint l[33];\n\nint o[3000544];\nint j[41][6];\nint dx[10]={0,1,0,-1,1,1,-1,-1},dy[10]={-1,0,1,0,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z[1000100],z1[100100];\n\nP u[1000020];\nstack<int> s[2];\n//queue<int> q,q1,q2;\n//set<int> s;\nqueue<P> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<long long,long long> p;\n//list<int> l;\n//string r1,r;\nchar r[52];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y<b.y;\n}\nlong long g(long long a)\n{\n    if(a<0) return 0;\n    return z[a];\n}\n\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b/2);\n    x*=x;\n    x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nlong long f(long long x,long long y)\n{\n    if(x<y) return 0;\n    printf(\"@@%lld %lld\\n\",z1[y],p(g(y),mod-2));\n    return g(x)*p(g(y),mod-2)%mod*p(g(x-y),mod-2)%mod;\n}\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    z[0]=1;\n    z1[0]=1;\n    for(int t=1;t<=a;t++)\n        z[t]=z[t-1]*t%mod,z1[t]=p(z[t],mod-2);\n    long long n=0;\n    for(int t=2;t<a;t++)\n    {\n\n        y=x;\n        x=f(t-1,a-1-t)*g(t)%mod*g(a-1-t)%mod;\n        n+=(x-y)*t;\n        n%=mod;\n        //printf(\"@@%lld %lld\\n\",z1[t],p(g(t),mod-2));\n        //printf(\"!!%lld %lld %lld %lld\\n\",x,f(t-1,a-t-1),g(t),g(a-1-t));\n    }\n    printf(\"%lld\",n);\n}\n//128397156\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nconst ll mod = 1e9+7;\nll mul(ll a, ll b) {\n    return a * b % mod;\n}\nll mul(initializer_list<ll> t) {\n    ll res = 1;\n    each(v, t) res = mul(res, v);\n    return res;\n}\nll add(ll a, ll b) {\n    return (a + b) % mod;\n}\nll add(initializer_list<ll> t) {\n    ll res = 0;\n    each(v, t) res = add(res, v);\n    return res;\n}\nll sub(ll a, ll b) {\n    return (a - b + mod) % mod;\n}\nll sub(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = sub(res, *(it++));\n    }\n    return res;\n}\nll power(ll x, ll n) {\n    ll res = 1;\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, x);\n        x = mul(x, x);\n    }\n    return res;\n}\nll inv(ll n) {\n    return power(n, mod-2);\n}\nll divi(ll a, ll b) {\n    return mul(a, inv(b));\n}\nll divi(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = divi(res, *(it++));\n    }\n    return res;\n}\nvector<ll> fact;\nvoid init_fact(ll n) {\n    fact.assign(n+1, 1);\n    FOR(i, 1, fact.size()) {\n        fact[i] = mul(fact[i-1], i);\n    }\n}\n\nll comb(ll n, ll r) {\n    if (r < 0) return 0;\n    if (r > n) return 0;\n    return divi(fact[n], mul(fact[r], fact[n-r]));\n}\n\nusing Row = vector<ll>;\nusing Matrix = vector<Row>;\nMatrix E(ll n) {\n    Matrix res(n, Row(n, 0));\n    rep(i, n) res[i][i] = 1;\n    return res;\n}\nMatrix mul(const Matrix& A, const Matrix& B) {\n    const ll n = A.size(), m = A[0].size(), l = B[0].size();\n    assert(m == B.size());\n    Matrix res(n, Row(l, 0));\n    rep(i, n) rep(j, m) rep(k, l) {\n        res[i][k] = add(res[i][k], mul(A[i][j], B[j][k]));\n    }\n    return res;\n}\nMatrix power(Matrix A, ll n) {\n    assert(A.size() == A[0].size());\n    Matrix res = E(A.size());\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, A);\n        A = mul(A, A);\n    }\n    return res;\n}\nvoid gen_fact_result(ll d, ll num) {\n    ll x = 1;\n    cout << \"#define FACT\";\n    cout << \"vector<P> facts = {\";\n    rep(i, d*(num-1)+1) {\n        if (i % d == 0) {\n            cout << \"{\" << i << \",\" << x << \"},\";\n        }\n        x = mul(x, i+1);\n    }\n    cout << \"};\";\n}\n#define FACT\nvector<P> facts = {{0,1},{10000000,682498929},{20000000,491101308},{30000000,76479948},{40000000,723816384},{50000000,67347853},{60000000,27368307},{70000000,625544428},{80000000,199888908},{90000000,888050723},{100000000,927880474},{110000000,281863274},{120000000,661224977},{130000000,623534362},{140000000,970055531},{150000000,261384175},{160000000,195888993},{170000000,66404266},{180000000,547665832},{190000000,109838563},{200000000,933245637},{210000000,724691727},{220000000,368925948},{230000000,268838846},{240000000,136026497},{250000000,112390913},{260000000,135498044},{270000000,217544623},{280000000,419363534},{290000000,500780548},{300000000,668123525},{310000000,128487469},{320000000,30977140},{330000000,522049725},{340000000,309058615},{350000000,386027524},{360000000,189239124},{370000000,148528617},{380000000,940567523},{390000000,917084264},{400000000,429277690},{410000000,996164327},{420000000,358655417},{430000000,568392357},{440000000,780072518},{450000000,462639908},{460000000,275105629},{470000000,909210595},{480000000,99199382},{490000000,703397904},{500000000,733333339},{510000000,97830135},{520000000,608823837},{530000000,256141983},{540000000,141827977},{550000000,696628828},{560000000,637939935},{570000000,811575797},{580000000,848924691},{590000000,131772368},{600000000,724464507},{610000000,272814771},{620000000,326159309},{630000000,456152084},{640000000,903466878},{650000000,92255682},{660000000,769795511},{670000000,373745190},{680000000,606241871},{690000000,825871994},{700000000,957939114},{710000000,435887178},{720000000,852304035},{730000000,663307737},{740000000,375297772},{750000000,217598709},{760000000,624148346},{770000000,671734977},{780000000,624500515},{790000000,748510389},{800000000,203191898},{810000000,423951674},{820000000,629786193},{830000000,672850561},{840000000,814362881},{850000000,823845496},{860000000,116667533},{870000000,256473217},{880000000,627655552},{890000000,245795606},{900000000,586445753},{910000000,172114298},{920000000,193781724},{930000000,778983779},{940000000,83868974},{950000000,315103615},{960000000,965785236},{970000000,492741665},{980000000,377329025},{990000000,847549272},};\n#ifdef FACT\nll bigfact(ll n) {\n    if (n >= mod) return 0;\n    auto it = upper_bound(all(facts), P(n, linf));\n    assert(it != facts.begin());\n    --it;\n    ll s = it->first;\n    ll res = it->second;\n    rep(i, s+1, n+1) {\n        res = mul(res, i);\n    }\n    return res;\n}\n#endif\n\nll solve_naive(ll n) {\n    vector<ll> p(n-1);\n    rep(i, n-1) p[i] = i;\n    ll ans = 0;\n    do {\n        vector<bool> used(n, false);\n        ll cnt = 0;\n        rep(i, n-1) {\n            if (!used[p[i]]) {\n                used[p[i]] = true;\n                ++cnt;\n            }\n            if (!used[p[i]+1]) {\n                used[p[i]+1] = true;\n                ++cnt;\n            }\n            if (cnt == n) {\n                ans += i+1;\n                break;\n            }\n        }\n    } while ( next_permutation(all(p)) );\n    return ans;\n}\nvector<vector<ll>> dp;\nll get_dp(ll i, ll j) {\n    if (i == 0) {\n        return j == 0 ? 1 : 0;\n    }\n    else {\n        ll y = i-1, x = j-1-i;\n        return comb(y, x);\n    }\n}\nll g(ll n, ll m) {\n    return mul(get_dp(m, n), mul(fact[m], fact[n-1-m]));\n}\nvoid init_dp(ll n) {\n    dp.assign(n, vector<ll>(n+1, 0));\n    dp[0][0] = 1;\n    rep(j, 1, n) {\n        rep(i, 2, n+1) {\n            // dp[j][i] = get_dp(j, i);\n            dp[j][i] = add(dp[j-1][i-1], dp[j-1][i-2]);\n        }\n        // cout << dp[j] << endl;\n    }\n}\nll f(ll n, ll m) {\n    return sub(g(n, m), g(n, m-1));\n}\nll solve(ll n) {\n    init_fact(n+10);\n    // init_dp(n);\n    // cout << dp << endl;\n    ll ans = 0;\n    // cout << \"g\" << endl;\n    // rep(i, n) cout << g(n, i) << endl;\n    // cout << \"f\" << endl;\n    // rep(i, 1, n) cout << f(n, i) << endl;\n    rep(i, 1, n) {\n        ans = add(ans, mul(i, f(n, i)));\n    }\n    return ans;\n}\nll solve2(ll n) {\n    init_fact(n+10);\n    init_dp(n);\n    cout << dp << endl;\n    ll ans = 0;\n    cout << \"g\" << endl;\n    rep(i, n) cout << g(n, i) << endl;\n    cout << \"f\" << endl;\n    rep(i, 1, n) cout << f(n, i) << endl;\n    rep(i, 1, n) {\n        ans = add(ans, mul(i, sub(\n            mul(dp[i][n], mul(fact[i], fact[n-1-i])),\n            mul(dp[i-1][n], mul(fact[i-1], fact[n-1-(i-1)]))\n        )));\n    }\n    return ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n; cin >> n;\n    cout << solve(n) << endl;\n    // cout << solve_naive(n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long s64;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\nconst int N=1e6+5,D=1e9+7;\ns64 mi(s64 x,int y=D-2)\n{\n\ts64 ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=ans*x%D;\n\t\tx=x*x%D;y>>=1;\n\t}\n\treturn ans;\n}\n\ns64 jie[N],niv_jie[N],s[N];\n\nint main()\n{\n\tint n;cin>>n;\n\tjie[0]=1;\n\trep(i,1,n)jie[i]=jie[i-1]*i%D;\n\tniv_jie[n]=mi(jie[n]);\n\tper(i,n,1)niv_jie[i-1]=niv_jie[i]*i%D;\n\ts64 ans=0;\n\t--n;\n\trep(k,1,n)\n\tif(k*2>=n-1)\n\t{\n\t\ts[k]=jie[k-1]*jie[k]%D*niv_jie[2*k-n-1]%D;\n\t\t(ans+=k*(s[k]-s[k-1]))%=D;\n\t}\n\tcout<<(ans+D)%D;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\nconst int64_t INF=10000000000000000;\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <map>\n\nint64_t gcd(int64_t a,int64_t b){//calc gcd\n\tif(a==0){\n\t\treturn b;\n\t}else if(b==0){\n\t\treturn a;\n\t}else if(a>b){\n\t\treturn gcd(a%b,b);\n\t}else{\n\t\treturn gcd(b%a,a);\n\t}\n}\nstd::pair<int64_t,int64_t> extgcd(int64_t a,int64_t b){//a*(pair->first) + b*(pair->second) = gcd(a,b)\n\tif(a==0){\n\t\treturn std::make_pair(0,1);\n\t}else if(b==0){\n\t\treturn std::make_pair(1,0);\n\t}else{\n\t\tif(a>b){\n\t\t\tstd::pair<int64_t,int64_t> d=extgcd(a%b,b);\n\t\t\treturn std::make_pair(d.first,d.second-(a/b)*d.first);\n\t\t}else{\n\t\t\tstd::pair<int64_t,int64_t> d=extgcd(a,b%a);\n\t\t\treturn std::make_pair(d.first-(b/a)*d.second,d.second);\n\t\t}\n\t}\n\n}\nint64_t inline normalize_mod(int64_t a,int64_t m){\n\treturn (m+a%m)%m;\n}\nint64_t mod_inv(int64_t a,int64_t m){//a^-1(mod m),m is a prime number\n\tint64_t raw=extgcd(a,m).first;\n\treturn normalize_mod(raw,m);;\n}\nstd::map<int64_t,int64_t> factorization(int64_t n){\n\tstd::map<int64_t,int64_t> retval;\n\tfor(int64_t i=2;i*i<=n;i++){\n\t\tint64_t counter=0;\n\t\twhile(n%i==0){\n\t\t\tn=n/i;\n\t\t\tcounter++;\n\t\t}\n\t\tif(counter!=0){\n\t\t\tretval.emplace(i,counter);\n\t\t}\n\t}\n\treturn retval;\n}\nstd::pair<int64_t,int64_t> mod_fact(int64_t n,int64_t m){//n!=first*m^second\n\tif(n==0){\n\t\treturn std::make_pair(1,0);\n\t}else{\n\n\t\tstd::pair<int64_t,int64_t> d=mod_fact(n/m,m);\n\t\tint64_t second=d.second+n/m;\n\t\tint64_t first;\n\t\tif((n/m)%2==0){\n\t\t\tfirst=1;\n\t\t}else{\n\t\t\tfirst=m-1;\n\t\t}\n\t\tfor(int64_t i1=1;i1<=(n%m);i1++){\n\t\t\tfirst=normalize_mod(first*i1,m);\n\t\t}\n\t\treturn std::make_pair(first,second);\n\t}\n}\nint main(){\n\tconst int64_t mod=1000000007;\n\tint64_t n;\n\tcin>>n;\n\tint64_t *fact=new int64_t[n];\n\tfact[0]=1;\n\tfor(int64_t i1=1;i1<n;i1++){\n\t\tfact[i1]=(fact[i1-1]*i1)%mod;\n\t}\n\tint64_t ans=0;\n\tint64_t under_k=0;\n\tfor(int64_t k=(n+1)/2;k<n;k++){\n\t\tint64_t temp=(fact[k-1]*mod_inv(fact[n-k-1]*fact[2*k-n],mod))%mod;\n\t\ttemp=(((temp*fact[k])%mod)*fact[n-1-k])%mod;\n\t\tans=normalize_mod(ans+(temp-under_k)*k,mod);\n\t\tunder_k=temp;\n\t}\n\tcout<<ans<<endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define M 1000000007\nll n,ans,p[1000005],s;\nll pw(ll x,ll y){\n    ll res=1;\n    while(y>0){\n        if(y&1)res=(res*x)%M;\n        x=(x*x)%M;\n        y>>=1;\n    }\n    return res;\n}\nll cm(ll x,ll y){\n    return p[x]*pw(p[x-y],M-2)%M*pw(p[y],M-2)%M;\n}\nint main(void){\n    scanf(\"%lld\",&n);\n    p[0]=1;\n    for(int i=1;i<=n;i++)p[i]=(p[i-1]*i)%M;\n    for(ll k=n/2;k<=n-1;k++){\n        ll c=cm(k-1,n-1-k)*p[k]%M*p[n-1-k]%M;\n        ans=(ans+(c+M-s)%M*k%M)%M;\n        s=c;\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint fact[1000005], fact_i[1000005];\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 1000005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 1000005; i++){\n\t\tfact_i[i] = pow(fact[i], mod-2);\n\t}\n}\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_i[k], ret %= mod;\n\tret *= fact_i[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint func(llint N, llint r)\n{\n\tllint batsu = N-r;\n\treturn comb(N+1-batsu, batsu) % mod;\n}\n\nllint N;\n\nint main(void)\n{\n\tcin >> N;\n\tif(N == 2){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmake_fact();\n\t\n\tllint ans = 0;\n\tfor(llint i = N/2; i <= N-1; i++){\n\t\tllint cnt = 0;\n\t\tif(N >= 3) cnt += func(N-3, i-2) * 2;\n\t\tif(N >= 7) cnt += (func(N-7, i-5) * 2*(N-6)) % mod, cnt %= mod;\n\t\tif(N >= 6) cnt += (func(N-6, i-4) * 4*(N-5)) % mod, cnt %= mod;\n\t\tif(N >= 8) cnt += (func(N-8, i-5) * (N-7)) % mod, cnt %= mod;\n\t\tif(N >= 7) cnt += (func(N-7, i-4) * (N-6)) % mod, cnt %= mod;\n\t\tif(N == 5 && i == 3) cnt += 2;\n\t\tif(N == 6 && i == 3) cnt += 3;\n\t\tcnt *= fact[i-1] % mod, cnt %= mod;\n\t\tcnt *= fact[(N-1)-i] % mod, cnt %= mod;\n\t\tans += (cnt * i) % mod, ans %= mod;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nconst LL mods=1000000007LL;\nconst int MAXN=1000000;\nstruct M{\n\tLL x;\n\tM(){\n\t\tx=0;\n\t}\n\tM(LL angka){\n\t\tif(angka>=mods||angka<=-mods)\n\t\t\tangka%=mods;\n\t\tif(angka<0)\n\t\t\tangka+=mods;\n\t\tx=angka;\n\t}\n\t\n\tM operator + (const M &other) const{\n\t\treturn M(x+other.x);\n\t}\n\tM operator - (const M &other) const{\n\t\treturn M(x-other.x);\n\t}\n\tM operator * (const M &other) const{\n\t\treturn M(x*other.x);\n\t}\n\tM operator - () const{\n\t\treturn M(-x);\n\t}\n};\nint n;\nM fakt[MAXN+5],invfakt[MAXN+5],pways[MAXN+5],ans;\nM DnC(M angka,LL pangkat){\n\tif(pangkat==0)\n\t\treturn 1;\n\tM ret=DnC(angka,pangkat>>1);\n\tret=ret*ret;\n\tif(pangkat&1)\n\t\tret=ret*angka;\n\treturn ret;\n}\nM inv(int n,int k){\n\t//cout<<\"ngeinv \"<<n<<\" \"<<k<<endl;\n\tM ret;\n\tint i,j;\n\tfor(int ulang=0;ulang<2;ulang++)\n\t{\n\t\tif(ulang==0)\n\t\t\ti=n-2*k,j=k;\n\t\telse\n\t\t\ti=n-2*k+1,j=k-1;\n\t\tif(!(i>=0&&j>=0))\n\t\t\tcontinue;\n\t\tret=ret+fakt[i+j]*invfakt[i]*invfakt[j];\n\t}\n\treturn ret;\n}\nM ways(int i){\n\treturn inv(n-3,(n-1)-i);\n}\nvoid isipways(){\n\tM substract;\n\tfor(int i=2;i<=n-1;i++)\n\t{\n\t\t//cout<<\"untuk \"<<i<<\" caranya \"<<ways(i).x<<endl;\n\t\tpways[i]=ways(i)*fakt[i]-substract;\n\t\tsubstract=substract+pways[i];\n\t\tsubstract=substract*(n-i-1);\n\t\t//cout<<\"pways \"<<i<<\" \"<<pways[i].x<<endl;\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tif(n==2)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tif(n==3)\n\t{\n\t\tcout<<4<<endl;\n\t\treturn 0;\n\t}\n\tfakt[0]=1;\n\tinvfakt[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfakt[i]=fakt[i-1]*i;\n\t\tinvfakt[i]=DnC(fakt[i],mods-2);\n\t}\n\tisipways();\n\tfor(int i=2;i<=n-1;i++)\n\t\tans=ans+pways[i]*fakt[n-1-i]*i;\n\tprintf(\"%lld\\n\",ans.x);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1000005;\nint fact[MAX_N];\nint fact_inv[MAX_N];\nint bin_pow_mod(int x, int y) {\n      if (x == 0) return 0;\n      int prod=1;\n      while(y>0) {\n          if (y & 1) prod = (prod * x) % MOD;\n          x = (x * x) % MOD;\n          y >>= 1;\n      }\n      return prod % MOD;\n}\nstruct init_fact {\n    init_fact() {\n        fact[0] = 1, fact_inv[0] = 1;\n        for (int i = 1; i < MAX_N; ++i) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n            fact_inv[i] = bin_pow_mod(fact[i], MOD - 2);\n        }\n    }\n} init_fact;\nint combination(int n, int r) {\n    return ((fact[n] * fact_inv[n - r]) % MOD * fact_inv[r]) % MOD;\n}\nsigned main() {\n    int n;\n    cin >> n;\n    int ans = 0, pre = 0;\n    REP(i, n) {\n        if (i - 1 >= n - 1 -i) {\n            int tmp = combination(i - 1, n - 1 -i) * fact[i] % MOD * fact[n - 1 - i] % MOD;\n            ans += i * ((tmp - pre + MOD) % MOD) % MOD;\n            ans %= MOD;\n            pre = tmp;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std;\n\n#define fcout(d) cout << fixed << setprecision(d)\n#define rep(i,n) for(int (i) = 0; (i) < (n); ++(i))\n#define rep1(i,n) for(int (i) = 1; (i) <= (n); ++(i))\n#define repU(i,bottom,ceiling) for(auto (i) = (bottom); (i) <= (ceiling); ++(i))\n#define repD(i,ceiling,bottom) for(auto (i) = (ceiling); (i) >= (bottom); --(i))\n#define repS(n) for(int (s) = 0; (s) < 1 << (n); ++(s))\n#define repV(i,v) for(auto (i) = begin(v); (i) < end(v); ++(i))\n#define all(v)  begin(v),end(v)\n#define clr(v) fill(all(v),0)\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define puf push_front\n#define pub push_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define fir first\n#define sec second\n#define divceil(n,d) ((n)/(d) + ((n)%(d) > 0))\n#define parity(a,b) (((a) & 1LL)^((b) & 1LL)^1LL)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\n\nconst pair<int,int> DIR[] = { {1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,1},{-1,-1},{1,-1} };\nconst int INF_32 = -1 + (1 << 30);\nconst ll INF_64 = -1 + (1LL << 62);\nconst int MOD = (int)1e9 + 7;\n\ntemplate<class T> T gcd(T a, T b){ if(a % b){ return gcd(b, a % b); }else{ return b; } }\n\ntemplate<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\n\nll Pow(ll n, ll m, int mod = MOD){\n\tll res = 1,pow = n % mod;\n\twhile(m) {\n\t\tif(m & 1LL) res = (res * pow) % mod;\n\t\tpow = (pow * pow) % mod;\n\t\tm >>= 1;\n\t}\n\treturn res;\n}\n\nvoid Frac_table(ll *frac, int range, int mod = MOD){\n\tfrac[0] = 1;\n\trep1(i,range) frac[i] = frac[i - 1] * (ll)i % mod;\n}\n\nll Comb(int n, int m, ll *frac, int mod = MOD){\n\tif(n < m || m < 0) return 0;\n\tll rev = Pow(frac[m] * frac[n-m] % mod, mod-2, mod);\n\treturn rev * frac[n] % mod;\n}\n\nbool Prime_judge(int n){\n\tif(n <= 1 || !(n % 2)) return 0;\n\tfor(int d = 3; d * d <= n; d += 2) if(!(n % d)) return 0;\n\treturn 1;\n}\n\nvoid Prime_table(bool *is_prime, int n){\n\tfill(is_prime + 1, is_prime + n, 1);\n\trepU(i,2,n/2) is_prime[i * 2] = 0;\n\tis_prime[0] = is_prime[1] = 0;\n\tint p = 3;\n\twhile(p * p < n){\n\t\tfor(int t = p * 2; t <= n; t += p) is_prime[t] = 0;\n\t\tp += 2;\n\t\twhile(!is_prime[p]) p += 2;\n\t}\n}\n\nint main(){\n\tint N; cin>>N;\n\tll frac[1000001],cur,last = 0;\n\tll ans = 0;\n\tFrac_table(frac,N);\n\trep1(i,N - 1){\n\t\tcur = frac[i] * frac[N - i - 1] % MOD * Comb(i - 1, N - i - 1, frac) % MOD;\n\t\tans += (cur - last) * (ll)i % MOD;\n\t\tans %= MOD;\n\t\tlast = cur;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433L;\n\ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n/*\n * @title ModInt\n */\ntemplate<long long mod> class ModInt {\npublic:\n\tlong long x;\n\tconstexpr ModInt():x(0) {\n\t\t// do nothing\n\t}\n\tconstexpr ModInt(long long y) : x(y>=0?(y%mod): (mod - (-y)%mod)%mod) {\n\t\t// do nothing\n\t}\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const long long y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const int y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const long long y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const int y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt operator=(const int y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator=(const long long y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator-() const { return ModInt(-x); }\n\tModInt operator++() { \n\t\tx++;\n\t\tif(x>=mod) x-=mod;\n\t\treturn *this; \n\t}\n\tModInt operator--() { \n\t\tx--;\n\t\tif(x<0) x+=mod;\n\t\treturn *this; \n\t}\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\tModInt inv() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(long long n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tlong long t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n};\nusing modint = ModInt<MOD>;\n\n/*\n * @title CombinationMod\n */\ntemplate<long long mod> class CombinationMod {\n\tvector<long long> fac,finv,inv;\npublic:\n\tCombinationMod(int N) : fac(N + 1), finv(N + 1), inv(N + 1) {\n\t\tfac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n\t\tfor (int i = 2; i <= N; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % mod;\n\t\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n\tinline long long binom(int n, int k) {\n\t\treturn ((n < 0 || k < 0 || n < k) ? 0 : fac[n] * (finv[k] * finv[n - k] % mod) % mod);\n\t}\n\tinline long long factorial(int n) {\n\t\treturn (n<0?0:fac[n]);\n\t}\n};\n//verify https://atcoder.jp/contests/abc021/tasks/abc021_d\nint main() {\n\tint N; \n    cin >> N;\n    corner(N==2,1);\n    corner(N==3,4);\n\tCombinationMod<MOD> CM(N);\n\tvector<modint> cnt(N,0);\n\tfor(int i = 1; i <= N-1; ++i) {\n\t\tcnt[i] = 1;\n\t\tcnt[i] *= CM.binom(i-1,N-1-i);\n\t\tcnt[i] *= CM.factorial(i);\n\t\tcnt[i] *= CM.factorial(N-1-i);\n\t}\n\tmodint ans = 0;\n\tfor(int i = 1; i <= N-1; ++i) {\n\t\tans += (cnt[i]-cnt[i-1])*i;\n\t}\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1e9+7;\nconst ll MOD = 1e9+7;\n\n// n^m%MOD を求める。O( log(m) )\nll modpow(ll n, int m){\n\tll ret=1;\n\tfor(int i=1; i<=m; i<<=1, (n*=n)%=MOD){\n\t\tif( m&i ) (ret *= n) %= MOD;\n\t}\n\treturn ret;\n}\n\n// 逆元を求める\nll modinv(ll n){\n\treturn modpow( n, MOD-2 );\n}\n\n// 階乗を求める。O(1)  準備O( n*log(n) )\n// fact[n]     : nの階乗\n// fact.inv[n] : nの階乗の逆元\nclass FACTORIAL{\npublic:\n\tvector<ll> fact, inv;\n\tFACTORIAL(int MAX_NUM): fact(MAX_NUM), inv(MAX_NUM) {\n\t\tfact[0] = inv[0] = 1;\n\t\tfor(ll i=1; i<MAX_NUM; i++){\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t\tinv[i] = modinv( fact[i] );\n\t\t}\n\t}\n\tconst ll& operator [ ] ( const int i ) const {\n\t\treturn fact[i];\n\t}\n} fact(1000006); // nの最大値を指定\n\n\n// 組み合わせ(Combinationを求める) O(1)\nll cmb(unsigned int n, unsigned int r){\n\tif( n < r ) return 0;\n\treturn fact[n] * fact.inv[r] % MOD * fact.inv[n-r] % MOD;\n}\n\n\nmap<pii,ll> memo;\nll fib(int n, int k){\n\tif( k < 0 || k > n || n <= 0 ) return 0;\n\tif( k == 0 ) return 1;\n\tif( n == 1 && k == 1 ) return 1;\n\tpii p = pii(n, k);\n\tif( memo.count(p) ) return memo[p];\n\tll ret = 0;\n\tint nd = min({k, n/2, 10000});\n\trep(i,nd+1){\n\t\t//if( memo.count(pii(n-nd-i, k-nd)) ){\n\t\t//\tret += cmb(nd, i) * memo[pii(n-nd-i, k-nd)];\n\t\t//}else{\n\t\t\tret += cmb(nd, i) * fib(n-nd-i, k-nd);\n\t\t//}\n\t\tret %= MOD;\n\t}\n\treturn memo[p] = ret;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tll N, K, ans=0;\n\n\tcin >> N;\n\n\t//cout << fib(N, K) << endl;\n\tll sum = 0;\n\trep(i,N) if( i-1 >= N-1-i ){\n\t//\tll tmp = fib(N,i);\n\t\tll tmp = cmb(i-1, N-1-i);\n\t\ttmp = (tmp * fact[i]) % MOD;\n\t\ttmp = (tmp * fact[N-1-i]) % MOD;\n\t\ttmp = (tmp + MOD - sum) % MOD;\n\t\tsum = (sum + tmp) % MOD;\n\t\ttmp = (tmp * i) % MOD;\n\t\tans = (ans + tmp) % MOD;\n\t\t//cout << ans << \" \" << cmb(i-1, N-1-i) << \" \" << fact[i] << endl;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#ifndef STOPIT\n#define debug(...)\\\n  std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n#else\n#define debug 0;\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto  operator++(int) {modular result(*this); operator++(); return result;}\n    auto  operator--(int) {modular result(*this); operator--(); return result;}\n\n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs() == rhs(); }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> power (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\nusing mod_type = int;\n\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\nconstexpr int mod = 1'000'000'007;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\ntemplate < typename Value >\nclass factorials {\n    std::vector< Value > fact, finv;\n\n  public:\n    factorials()=default;\n\n    void build(int n) {\n      fact.resize(n), finv.resize(n);\n      fact.at(0) = 1;\n      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * Value(i);\n      finv.at(n - 1) = Value(1) / fact.at(n - 1);\n      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * Value(i + 1);\n    }\n    auto operator()  (int i) const {return fact.at(i);}\n    auto inv         (int i) const {return finv.at(i);}\n    auto binom(int i, int j) const {\n      assert(0 <= i);\n      if (j < 0 ||i < j) return Value(0);\n      return fact.at(i) * finv.at(j) * finv.at(i - j);\n    }\n    auto deal(int i, int j) const\n      { return binom(i + j - 1, j - 1); }\n};\n\ntemplate < typename Container,\n  typename Value = typename Container::value_type,\n  std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr\n>\nstd::istream& operator>> (std::istream& is, Container& v) {\n  for (auto & x : v) is >> x;\n  return is;\n}\n\ntemplate < typename Container,\n  typename Value = typename Container::value_type,\n  std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr\n>\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto fact =  factorials< mint >{};\n  fact.build(n + 1);\n  std::vector< mint >a(n);\n  rep(i, 1, n) {\n    a.at(i) =\n        fact.binom(i - 1, n - 1 - i)\n      * fact(i)\n      * fact(n - 1 - i);\n  }\n  std::adjacent_difference(all(a), a.begin());\n  auto iota = std::vector< mint >(n);\n  std::iota(all(iota), mint{0});\n  auto ret =  std::inner_product(all(a), iota.begin(), mint{0});\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a[3];\nint n;\nlong long mod = 1e9+7;\nint main()\n{\n    cin>>n;\n    a[0] = 1;\n    int f = 1;\n    int i = 3;\n    for(;i<=n;i++){\n        if(f==0){\n            a[0] = (a[0] + a[1] + a[2]) % mod;\n            a[0] = (a[0]*4)%mod;\n        }\n        else a[f] = (a[f-1]*4)%mod;\n        f ++;\n        f %= 3;\n    }\n    cout<<a[(f+2)%3]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k)  for(ll i=j;i<=k;++i)\n#define Dow(i,j,k)  for(ll i=k;i>=j;--i)\n#define ll long long\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read()\n{\n\tll t=0,f=1;char c=gc();\n\twhile(!isdigit(c))  {if(c=='-') f=-1;c=gc();}\n\twhile(isdigit(c))   t=t*10+c-'0',c=gc();\n\treturn t*f;\n}\ninline void write(ll x){if(x<0) {putchar('-');write(-x);return;}if(x>=10)    write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void write_p(ll x){write(x);putchar(' ');}\n\nll n,mod=1e9+7,fac[1000010],N[1000010],ans,f[1000010],sum;\nll ksm(ll x,ll y){ll ans=1;while (y){if (y&1)(ans*=x)%=mod;(x*=x)%=mod;y>>=1;}return ans;}\nll\tp(ll n,ll m){return fac[n]*N[m]%mod;}\nll C(ll n,ll m){return fac[n]*N[m]%mod*N[n-m]%mod;}\nint main()\n{\n\tn=read();\n\tif (n==2){puts(\"1\");return 0;}\n\tfac[0]=1;\n\tFor(i,1,n)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tN[n]=ksm(fac[n],mod-2);\n\tDow(i,0,n-1)N[i]=N[i+1]*(i+1)%mod;\n\tfor (ll i=1;i<n;i++)if (i*2>=n)\n\t{\n\t\tf[i]=C((n-2-(i*2-n))/2+i*2-n,i*2-n)*fac[i]%mod*fac[n-1-i]%mod;\n\t\t(ans+=(f[i]-f[i-1])*i%mod+mod);\n\t\tans%=mod;\n\t}\n\twriteln(ans);\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nlong long P = 1000000007;\n\nclass C {\npublic:\n  int n;\n  vector<long long> fac, inv, facInv;\n  long long power(long long e, long long x) {\n    if (x == 0)\n      return 1;\n    if (x == 1)\n      return e;\n    if (x % 2 == 0)\n      return power((e * e) % P, x / 2);\n    return (e * power(e, x - 1)) % P;\n  }\n  C(int n_) {\n    n = n_;\n    fac.resize(n + 1);\n    inv.resize(n + 1);\n    facInv.resize(n + 1);\n    fac[0] = 1;\n    fac[1] = 1;\n    for (int i = 2; i <= n; i++)\n      fac[i] = (i * fac[i - 1]) % P;\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      inv[i] = power(i, P - 2);\n    facInv[0] = 1;\n    facInv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      facInv[i] = (inv[i] * facInv[i - 1]) % P;\n  }\n  long long comb(int N, int K) {\n    if (N == 0 || K == 0 || K == N)\n      return 1;\n    if (N < K || K < 0 || N < 0)\n      return 0;\n    return ((fac[N] * facInv[K]) % P * facInv[N - K]) % P;\n  }\n};\n\nlong long mul(long long a, long long b) { return (a * b) % P; }\n\nlong long add(long long a, long long b) { return (a + b) % P; }\n\nint main() {\n  int n;\n  cin >> n;\n  C c(2000001);\n  if (n == 2) {\n    cout << 1 << endl;\n  } else if (n == 3) {\n    cout << 4 << endl;\n  } else {\n    long long ans = 0;\n    vector<long long> dp(2000001);\n    dp[0] = dp[1] = 0;\n    for (int i = 2; i < n; i++) {\n      dp[i] = mul(c.comb(i - 1, n - 1 - i), mul(c.fac[i], c.fac[n - i - 1]));\n    }\n    for (int i = 1; i < n; i++) {\n      ans = add(ans, mul(i, (dp[i] - dp[i - 1] + P) % P));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<cstdio>\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=1e6+7;\nint n;\nint fac[N],finv[N],f[N];\nint qread()\n{\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0' || ch>'9')ch=getchar();\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x;\n}\nint Fpow(long long b,int p)\n{\n\tlong long res=1;\n\tfor(;p;p>>=1,b=b*b%mod)\n\t\tif(p&1)res=res*b%mod;\n\treturn res;\n}\nvoid Init()\n{\n\tfac[0]=finv[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tfinv[n]=Fpow(fac[n],mod-2);\n\tfor(int i=n-1;i;i--)\n\t\tfinv[i]=1ll*finv[i+1]*(i+1)%mod;\n}\nlong long C(int n,int m)\n{\n\treturn 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tInit();\n\tint l=n+1>>1,ans=0;\n\tfor(int i=l;i<n;i++)\n\t\tf[i]=C(i-1,n-i-1)*fac[i]%mod*fac[n-i-1]%mod;\n\tfor(int i=n-1;i>=l;i--)\n\t\tf[i]=(f[i]-f[i-1]+mod)%mod;\n\tfor(int i=l;i<n;i++)\n\t\tans=(ans+1ll*f[i]*i%mod)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nconstexpr ll mod=1e9+7;\n\nll f[1000100];\nll fac[1000100];\n\nll mod_pow(ll a,ll b){\n    a%=mod;\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res=mod_pow(a,b/2)%mod;\n    res*=res; res%=mod;\n    if(b%2)res*=a;\n    return res%mod;\n}\n\nstruct perm{\nprivate:\n    int sz;\n    vector<ll> p,invp;\npublic:\n    perm(int n){\n        sz=n+1;\n        p.resize(sz),invp.resize(sz);\n        p[0]=1;\n        for(int i=1;i<=sz-1;i++){\n            p[i]=p[i-1]*i%mod;\n        }\n        invp[sz-1]=mod_pow(p[sz-1],mod-2);\n        for(int i=sz-2;i>=0;i--){\n            invp[i]=invp[i+1]*(i+1)%mod;\n        }\n    }\n    ll comb(ll x,ll y){\n        if(x<y||y<0)return 0;\n        return (p[x]*invp[x-y]%mod)*invp[y]%mod;\n    }\n};\nperm p(1<<20);\n\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll res=0;\n    ll n; cin >> n;\n    fac[0]=1;\n    for(ll i=1;i<=n;i++){\n        fac[i]=fac[i-1]*i%mod;\n    }\n    for(ll k=1;k<n;k++){\n        f[k]=p.comb(k-1,n-1-k)*fac[k]%mod*fac[n-1-k]%mod;\n    }\n    for(ll k=1;k<n;k++){\n        (res+=k*(f[k]-f[k-1])%mod)%=mod;\n    }\n    if(res<0)res+=mod;\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n//cout<<setprecision(20)\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nint LBI(vector<llint>&ar,llint in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint UBI(vector<llint>&ar,llint in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\n\nclass mint_base;\n//mint_base_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\nclass mint_base\n{\npublic:\n\tconstexpr mint_base operator+(const mint_base &other)const noexcept\n\t{auto v = *this;return v += other;}\n\tconstexpr mint_base operator-(const mint_base &other)const noexcept\n\t{auto v = *this;return v -= other;}\n\tconstexpr mint_base operator*(const mint_base &other)const noexcept\n\t{auto v = *this;return v *= other;}\n\tconstexpr auto operator/(const mint_base &other)const noexcept\n\t{auto v = *this;return v /= other;}\n\tconstexpr mint_base & operator+=(const mint_base &other) noexcept\n\t{a += other.a;if (mod <= a) { a -= mod; };return *this;}\n\tconstexpr mint_base & operator-=(const mint_base &other) noexcept\n\t{if (a >= other.a) {a -= other.a;}else {a = (a + mod) - other.a;}return *this;}\n\tconstexpr mint_base & operator*=(const mint_base &other) noexcept\n\t{a *= other.a;a %= mod;return *this;}\n\tconstexpr mint_base & operator/=(const mint_base &other) noexcept\n\t{return *this *= ~other;}\n\tconstexpr mint_base operator+()const noexcept { return *this; }\n\tconstexpr mint_base operator-()const noexcept\n\t{return{ mod - a, mod_value_tag{} };}\n\tconstexpr mint_base & operator++() noexcept\n\t{if (mod <= ++a) { a = 0; };return *this;}\n\tconstexpr mint_base & operator--() noexcept\n\t{if (a <= 0) { a = mod; };--a;return *this;}\n\tconstexpr mint_base operator++(int) noexcept\n\t{auto tmp = *this;++*this;return tmp;}\n\tconstexpr mint_base operator--(int) noexcept\n\t{auto tmp = *this;--*this;return tmp;}\n\tconstexpr mint_base operator~()const noexcept\n\t{return m_pow(*this, mod-2);}\n\tconstexpr mint_base & operator=(const mint_base &other) noexcept\n\t{a=other.a;return *this;}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{return a;}\n\tconstexpr explicit operator int()const noexcept\n\t{return a;}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{return (unsigned)a;}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{return mod;}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % mod) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tuint64_t a;\n};\n\n//mint_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x,uint64_t n)noexcept\n{\n\tmint_base res = 1;\n\twhile(n>0){\n\t\tif(n&1){res*=x;}\n\t\tx*=x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\nvector<mint_base> fla;//階乗が入る\nvoid fla_set(mint_base x)\n{\n\tfla.resize(((uint64_t)x)+1);\n\tfla[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x;i++){fla[i]=fla[i-1]*i;}\n}\nvector<mint_base> gya;//~fla[i] が入る\n\n//O(x+log mod)で求める O(xlogmod)より速い\nvoid fla_gya_set(mint_base x)\n{\n\tfla_set(x);\n\tgya.resize(((uint64_t)x)+1);\n\tgya[(uint64_t)x]=~fla[(uint64_t)x];\n\tfor(uint64_t i =(uint64_t)x;i>0;i--){gya[i-1]=gya[i]*i;}\n}\n\n//mint_base型のstreamへの出力\nstd::ostream& operator<<(std::ostream& os, mint_base i)\n{os<<(uint64_t)i;return os;}\n//mint_base型のstreamからの入力\nstd::istream& operator >> (std::istream& is, mint_base& i)\n{uint64_t tmp;is>>tmp;i=tmp;return is;}\n\n\n\nint main(void){\n\tint n,i;cin>>n;\n\tfla_gya_set(n+1);\n\tmint_base mae=0;\n\tmint_base ans=0;\n\tfor(i=(n-1)/2;i<=n-2;i++){\n\t\tmint_base now=fla[i+1]*fla[i]*gya[n-2-i]*gya[i+i-n+2];\n\t\t//cerr<<\"now=\"<<now<<endl;\n\t\tans+=mint_base(i+1)*fla[n-2-i]*(now-mae);\n\t\tmae=now*(n-2-i);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Math{\npublic:\n  typedef long long ll;\n  ll mod;\n  Math(ll mod = 1e9+7):mod(mod){}\n  \n  ll mod_pow(ll a,ll x){\n    ll res=1;\n    while(x){\n      if(x%2) res=res*a%mod;\n      a=a*a%mod;\n      x/=2;\n    }\n    return res;\n  }\n\n  //逆元\n  ll inv(ll a){return mod_pow(a,mod-2);}\n\n  //階乗関数\n  ll K(int i, int n = 1e6){\n    static vector<ll> k(n);\n    if(!k[0]){k[0]=1;for(int i=1;i<(int)k.size();i++)k[i]=i*k[i-1]%mod;}\n    return k[i];\n  }\n\n  ll nPr(ll n, ll r){return K(n) * inv(K(r)) % mod;}\n\n  //O(log(mod))  階上テーブルを使うので、k,rが大きすぎるとダメ。\n  ll nCr(ll n,ll r){\n    ll a = inv( K(r) * K(n-r) % mod);\n    return K(n) * a % mod;\n  }\n\n  //O(r + log(mod))\n  ll nCr2(ll n,ll r){\n    ll N = 1, K = 1; \n    for(int i=0;i<r;i++) N=N*((n-i)%mod)%mod;\n    for(int i=0;i<r;i++) K=K*((r-i)%mod)%mod;\n    ll R = inv(K);\n    return N*R%mod;\n  }\n  \n  /*カーマイケル数ってなんだっけ忘れた*/\n  static ll carmichaelLambda(ll n){\n    ll res = 1;\n    if(n % 8 == 0) n/=2;\n    auto lcm = [](ll a,ll b){return (a/__gcd(a,b)) * b;};\n    \n    auto compute = [&](ll i){\n      ll sub = i - 1;\n      n/=i;\n      while(n%i == 0) n/=i, sub *=i;\n      res = lcm(res,sub);\n    };\n    \n    for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n    if(n != 1) compute(n);\n    return res;\n  }\n\n  //n以下の素数を返す。  \n  static vector<int> getPrime(int n){\n    vector<bool>used(n+1,0);\n    \n    for(ll i=2;i*i<=n;i++)\n      if(!used[i]) for(int j=2;j<=n/i;j++) used[i*j]=1;\n    \n    vector<int> res;\n    for(int i=2;i<=n;i++)if(!used[i]) res.push_back(i);\n\n    return res;\n  }\n  \n  //素数判定\n  static bool isPrime(ll n){\n    if(n < 2) return 0;\n    for(ll i=2;i*i<=n;i++) if(n%i==0) return 0;\n    return 1;\n  }\n\n  //素因数分解 x == 0 || x == 1のときはその値自身を返す。\n  static vector<ll> primeFactor(ll x,int flag = 0){\n    if(flag == 0 && (x == 0 || x == 1)) return {x};\n    if(flag == 1 && (x == 0 || x == 1)) return {};\n    \n    vector<ll> res;\n    for(ll i=2;i*i <= x;i++)\n      while(x%i == 0) x/=i, res.push_back(i);\n    if(x != 1) res.push_back(x);\n    return res;\n  }\n\n  static map<ll,ll> primeFactorMap(ll x,int flag = 0){\n    map<ll,ll> res;\n    if(flag == 0 && (x == 0 || x == 1)) {res[x]++; return res;}\n    if(flag == 1 && (x == 0 || x == 1)) return res;\n    \n    for(ll i=2;i*i <= x;i++) while(x%i == 0) x/=i, res[i]++;\n    if(x != 1) res[x]++;\n    return res;\n  }\n  \n  static ll divisor_Sum(map<ll,ll> prime){ // first : prime  second : cnt\n    ll res = 1;\n    for(P p : prime){\n      ll sum = 1, mul = p.first;\n      for(ll i=0;i<p.second;i++) sum += mul, mul *= p.first;\n      res *= sum;\n    }\n    return res;\n  }\n  \n  static ll divisor_Sum(ll num){\n    return divisor_Sum(primeFactorMap(num));\n  }\n  \n  //約数列挙\n  static vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  //a * bがオーバフローするか判定\n  static bool overflow(ll a,ll b){return a > LONG_MAX/b;}\n\n};\n\nMath math;\nint n;\nint calc(int x /*動かした個数*/){\n  if(x - 1 < n - x - 1) return 0;\n  int a = math.nCr(x - 1, n - x - 1);\n  int b = math.K(x);\n  int c = math.K(n - x - 1);\n  int res = (a * b % mod) * c % mod;\n  return res;\n}\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>n;\n\n  if(n == 2){\n    cout<<\"1\"<<endl;\n    return 0;\n  }\n\n  if(n == 3){\n    cout<<\"4\"<<endl;\n    return 0;\n  }\n\n  int ans = 0;\n  for(int i=1;i<n;i++){\n    ans += i * (calc(i) - calc(i-1) + mod) % mod;\n    ans %= mod;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 1e9+7;\n\n\ntemplate <ll mod>\nstruct ModCombination{\n    ll N;\n    vector<ll> fact,inv,finv;\n\n    ModCombination(ll n):N(n){\n        fact.assign(n+1, 1);\n        inv.assign(n+1, 1);\n        finv.assign(n+1,1);\n        for(int i=1;i<n;i++){\n            fact[i+1] = fact[i]*(i+1)%mod;\n            inv[i+1] = inv[mod%(i+1)]*(mod-mod/(i+1))%mod;\n            finv[i+1] = finv[i]*inv[i+1]%mod;\n        }\n    }\n\n    ll Comb(ll n,ll k){\n      if(n<0||n<k)return 0;\n        return (fact[n]*finv[k]%mod)*finv[n-k]%mod;\n    }\n};\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N;cin>>N;\n  if(N==2){\n    cout << 1 << endl;\n  }else if(N==3){\n    cout << 4 << endl;\n  }else{\n    ModCombination<MOD> C(N);\n    ll ans = 0;\n    if(N>=4){\n      repeat(k,N-1){\n        ll K = k+1;\n        ans = (ans+((C.Comb(K-1,N-K-1)*C.fact[K]%MOD*C.fact[N-K-1]%MOD)-(C.Comb(K-2,N-K)*C.fact[K-1]%MOD*C.fact[N-K]%MOD)+MOD)%MOD*K%MOD)%MOD;\n        //debug(ans);\n      }\n    }\n    cout << ans << endl;\n\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n;\nint pw[1000010];\nint inv[1000010];\nconst int md=1e9+7;\nint qmul(int x,int p)\n{\n\tif(p==0)return 1;\n\tif(p==1)return x;\n\tint res=qmul(x,p>>1);\n\tres=1LL*res*res%md;\n\tif(p&1)res=1LL*res*x%md;\n\treturn res;\n}\nint C(int x,int y)\n{\n\tif(x<y)return 0;\n\treturn 1LL*pw[x]*inv[x-y]%md*inv[y]%md;\n}\nint ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++)pw[i]=1LL*pw[i-1]*i%md;\n\tinv[n]=qmul(pw[n],md-2);\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%md;\n\t}\n\tfor(int k=1;k<n;k++)\n\t{\n\t\tans+=1LL*C(k-1,n-1-k)*pw[k]%md*pw[n-1-k]%md;\n\t\tif(ans>=md)ans-=md;\n\t}\n\tprintf(\"%d\",(pw[n]+md-ans)%md);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nconst int N = 1e6 + 5, Mod = 1e9 + 7;\nint ml(int x, int y) { return 1ll * x * y % Mod; }\nint dc(int x, int y) { return (x - y < 0) ? (x - y + Mod) : (x - y); }\nint ad(int x, int y) { return (x + y > Mod) ? (x + y - Mod) : (x + y); }\nint n, f[N], fac[N], inv[N];\nint ksm(int x, int y) {\n\tint ret = 1;\n\tfor (; y; y >>= 1, x = ml(x, x))\n\t\tif (y & 1) ret = ml(ret, x);\n\treturn ret;\n}\nvoid Prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) fac[i] = ml(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], Mod - 2);\n\tfor (int i = n - 1; i >= 0; --i) inv[i] = ml(inv[i + 1], i + 1);\n}\nint binom(int u, int d) {\n\tif (u < 0 || d < 0) return 0;\n\tif (u < d) return 0;\n\treturn ml(fac[u], ml(inv[d], inv[u - d]));\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tPrepare();\n\tfor (int i = 1; i <= n - 1; ++i)\n\t\tf[i] = ml(binom(i - 1, n - i - 1), ml(fac[i], fac[n - i - 1]));\n\tfor (int i = n - 1; i >= 1; --i) f[i] = dc(f[i], f[i - 1]);\n\tint ans = 0;\n\tfor (int i = 1; i <= n - 1; ++i) ans = ad(ans, ml(f[i], i));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, fact[10010101], ifact[10010101], ans;\nconstexpr long long int M = 1000000007, m = 79133769, n = 536396504, mask = 1073741823;\n\ninline long long int MR(long long int A){\n    long long int ret((A + M * (m * A & mask)) >> 30);\n    return ret - (ret >= M) * M;\n}\n\ninline long long int Prod(long long int lhs, long long int rhs){\n    return MR(MR(lhs * rhs) * n);\n}\n\nint main(){\n    scanf(\"%lld\", &N);\n    *fact = 1;\n    for(int i = 1; i < N; ++i){\n        fact[i] = Prod(fact[i - 1], i);\n    }\n    long long n = M - 2, r = fact[N - 1];\n    ifact[N - 1] = 1;\n    while(n){\n        if(n & 1){\n            ifact[N - 1] = ifact[N - 1] * r % M;\n        }\n        n /= 2;\n        r = r * r % M;\n    }\n    for(int i = N - 1; i > 0; --i){\n        ifact[i - 1] = Prod(ifact[i], i);\n    }\n    ans = fact[N - 1] * (N - 1);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += M - Prod(Prod(fact[i], fact[i - 1]), ifact[i * 2 - N]);\n    }\n    ans %= M;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1000001;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nint cnt[100];\nbool cov[100];\nll fac[maxn];\nll inv[maxn];\nll rev[maxn];\nll C(ll n,ll k){\n    if (n<0)\n        return 0;\n    if (k<0)\n        return 0;\n    if (n<k)\n        return 0;\n    return fac[n]*inv[k]%MOD*inv[n-k]%MOD;\n}\nll f(ll n,ll k){\n    return C(k-1,n-k-1);\n}\nll z[maxn];\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin>>n;\n    fac[0]=1;\n    for(int i=1; i<=n; ++i)\n        fac[i]=fac[i-1]*i%MOD;\n    rev[1]=1;\n    inv[1]=1;\n    inv[0]=1;\n\n    for(int i=2; i<=n; ++i){\n        rev[i]=rev[MOD%i]*(MOD-MOD/i)%MOD;\n        inv[i]=inv[i-1]*rev[i]%MOD;\n    }\n    for(int i=1; i<=n; ++i)\n        z[i]=f(n,i);\n    ll ans=0;\n    for(int i=1; i<n; ++i){\n        //cout<<i<<\" \"<<z[i]<<endl;\n        z[i]*=fac[i];\n        z[i]%=MOD;\n        z[i]*=fac[n-1-i];\n        z[i]%=MOD;\n        //cout<<\" \"<<i<<\" \"<<z[i]<<endl;\n        //cout<<z[i]-z[i-1]<<endl;\n        ans+=(z[i]-z[i-1]+MOD)*i%MOD;\n        if (ans>=MOD)\n            ans-=MOD;\n    }\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate <uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept {return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr bool operator==(const ModInt &rhs) const noexcept {return a == rhs.a;}\n    constexpr bool operator!=(const ModInt &rhs) const noexcept {return a != rhs.a;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt rhs = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n\n    friend ostream &operator<<(ostream& os, const ModInt& rhs) noexcept {return os << rhs.a;}\n    friend istream &operator>>(istream& is, ModInt& rhs) noexcept {long long a; is >> a; rhs = a; return is;}\n};\n\nusing mint = ModInt<MOD>;\n\n\nstruct ModCombination {\n    vector<mint> Fac;\n    vector<mint> Facinv;\n\n    ModCombination(int x) {\n        Fac.resize(x+1);\n        Facinv.resize(x+1);\n        Fac[0] = 1;\n        for (int i = 0; i < x; ++i) Fac[i+1] = Fac[i]*(i+1);\n        Facinv[x] = Fac[0]/Fac[x];\n        for (int i = x; i > 0; --i) Facinv[i-1] = Facinv[i]*i;\n    }\n\n    mint get(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return Fac[n]*Facinv[k]*Facinv[n-k];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N; cin >> N;\n    ModCombination MC(N);\n\n    mint ans = 0;\n    mint S = MC.Fac[N-1];\n    for (int i = N-1; i >= (N+1)/2; i--) {\n        int k = N-i;\n        mint val = MC.get(N-2-k,k)*MC.Fac[k]*MC.Fac[N-1-k];\n        ans += (S-val)*i;\n        S = val;\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define nn 65536*16\n#define ll long long\n#define mod 1000000007\nll f[nn],rf[nn];\nll qpow(ll x,ll y)\n{\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nll C(ll x,ll y)\n{\n\tif(x<0) return 0;\n\tif(x>y) return 0;\n\treturn f[y]*rf[x]%mod*rf[y-x]%mod;\n}\nll g[nn];\nint main()\n{\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1],mod-2);\n\tfor(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\tll n;cin>>n;\n\tll ans=0;\n\tfor(int i=(n+1)/2;i<n;i++) g[i]=C(n-1-i,i-1)*f[i]%mod*f[n-i-1]%mod;\n\tfor(int i=(n+1)/2;i<n;i++) ans+=i*(g[i]-g[i-1]),ans%=mod;\n\tcout<<(ans+mod)%mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int P = 1000000007;\n\nvector<int> f0, f1, i1;\nvoid init(int n) {\n    i1.resize(n + 1);\n    i1[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        i1[i] = (ll)i1[P % i] * (P - P / i) % P;\n    }\n\n    f0.resize(n + 1);\n    f1.resize(n + 1);\n    f0[0] = f1[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        f0[i] = (ll)f0[i - 1] * i % P;\n        f1[i] = (ll)f1[i - 1] * i1[i] % P;\n    }\n}\nll fact(int k) {\n    return f0[k];\n}\nll powmod(ll n, ll k) {\n    ll r = 1, t = n % P;\n    for (; k != 0; k /= 2) {\n        if (k & 1) r = r * t % P;\n        t = t * t % P;\n    }\n    return r;\n}\nll inv(ll n) {\n    return powmod(n, P - 2);\n}\nll comb(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return (ll)f0[n] * f1[k] % P * f1[n - k] % P;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    init(n);\n\n    ll r = 0, b = 0;\n    for (int k = (n + 1) / 2; k <= n - 1; k++) {\n        ll a = comb(k - 1, n - 1 - k) * fact(k) % P * fact(n - 1 - k) % P;\n        r += (a - b) * k % P;\n        b = a;\n    }\n    r %= P; if (r < 0) r += P;\n\n    cout << r << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\ntypedef long long ll;\ntypedef double dd;\n#define For(i,j,k) for (int i=(int)j;i<=(int)k;++i)\n#define Forr(i,j,k) for (int i=(int)j;i>=(int)k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b) { return a<b?a=b,1:0; }\ntemplate<typename T>bool chkmin(T &a,T b) { return a>b?a=b,1:0; }\n\nconst int maxn=1e6+1e2;\nconst int N=1e6;\nconst int modd=1e9+7;\nint n,Ans;\nint\tfac[maxn],inv[maxn];\n\ninline void file() {\n\tfreopen(\"AGC023C.in\",\"r\",stdin);\n\tfreopen(\"AGC023C.out\",\"w\",stdout);\n}\n\ninline int quick(int a,int b) {\n\tint s=1;\n\twhile (b) {\n\t\tif (b%2==1) s=1ll*s*a%modd;\n\t\ta=1ll*a*a%modd; b/=2;\n\t}\n\treturn s;\n}\n\ninline int C(int n,int m) {\n\tif (n<m) return 0;\n\treturn 1ll*fac[n]*inv[m]%modd*inv[n-m]%modd;\n}\n\ninline void init() {\n\tfac[0]=inv[0]=1;\n\tFor (i,1,N) fac[i]=1ll*fac[i-1]*i%modd;\n\tinv[N]=quick(fac[N],modd-2);\n\tForr (i,N-1,1) inv[i]=1ll*inv[i+1]*(i+1)%modd;\n}\n\ninline void solve() {\n\tscanf(\"%d\",&n);\n\tfor (int i=(n+1)/2,lst=0;i<n;++i) {\n\t\tint ans=1ll*C(i-1,n-i-1)*fac[i]%modd*fac[n-i-1]%modd;\n\t\t(Ans+=1ll*(ans-lst+modd)*i%modd)%=modd; lst=ans;\n\t}\n\tprintf(\"%d\\n\",(Ans+modd)%modd);\n}\n\nint main() {\n//\tfile();\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 5100000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n    COMinit();\n    int N;\n    cin >> N;\n\n    vector<long long> A(N, 0);\n    for(int k = (N + 1) / 2; k < N; ++k) {\n        A[k] = (COM(k - 1, N - k - 1) * fac[k] % MOD) * fac[N - k - 1] % MOD;\n    }\n\n    long long res = 0;\n    for(long long k = (N + 1) / 2; k < N; ++k) {\n        res += k * (A[k] - A[k - 1] + MOD) % MOD;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std;\n\n#define fcout(d) cout << fixed << setprecision(d)\n#define rep(i,n) for(int (i) = 0; (i) < (n); ++(i))\n#define rep1(i,n) for(int (i) = 1; (i) <= (n); ++(i))\n#define repU(i,bottom,ceiling) for(auto (i) = (bottom); (i) <= (ceiling); ++(i))\n#define repD(i,ceiling,bottom) for(auto (i) = (ceiling); (i) >= (bottom); --(i))\n#define repS(n) for(int (s) = 0; (s) < 1 << (n); ++(s))\n#define repV(i,v) for(auto (i) = begin(v); (i) < end(v); ++(i))\n#define all(v)  begin(v),end(v)\n#define clr(v) fill(all(v),0)\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define puf push_front\n#define pub push_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define fir first\n#define sec second\n#define divceil(n,d) ((n)/(d) + ((n)%(d) > 0))\n#define parity(a,b) (((a) & 1LL)^((b) & 1LL)^1LL)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\n\nconst pair<int,int> DIR[] = { {1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,1},{-1,-1},{1,-1} };\nconst int INF_32 = -1 + (1 << 30);\nconst ll INF_64 = -1 + (1LL << 62);\nconst int MOD = 1e9 + 7;\n\ntemplate<class T> T gcd(T a, T b){ if(a % b){ return gcd(b, a % b); }else{ return b; } }\n\ntemplate<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\n\nll Pow(ll n, ll m, int mod = MOD){\n\tll res = 1,pow = n % mod;\n\twhile(m) {\n\t\tif(m & 1LL) res = (res * pow) % mod;\n\t\tpow = (pow * pow) % mod;\n\t\tm >>= 1;\n\t}\n\treturn res;\n}\n\nvoid Fact_table(ll *fact, int range, int mod = MOD){\n\tfact[0] = 1;\n\trep1(i,range) fact[i] = fact[i - 1] * i % mod;\n}\n\nll Comb(int n, int m, ll *fact, int mod = MOD){\n\tif(n < m || m < 0) return 0;\n\tll rev = Pow(fact[m] * fact[n - m] % mod, mod - 2, mod);\n\treturn rev * fact[n] % mod;\n}\n\nbool Prime_judge(int n){\n\tif(n <= 1 || !(n % 2)) return 0;\n\tfor(int d = 3; d * d <= n; d += 2) if(!(n % d)) return 0;\n\treturn 1;\n}\n\nvoid Prime_table(bool *is_prime, int n){\n\tfill(is_prime + 1, is_prime + n + 1, 1);\n\trepU(i,2,n/2) is_prime[i * 2] = 0;\n\tis_prime[0] = is_prime[1] = 0;\n\tint p = 3;\n\twhile(p * p <= n){\n\t\tfor(int t = p * 3; t <= n; t += p * 2) is_prime[t] = 0;\n\t\tp += 2;\n\t\twhile(!is_prime[p]) p += 2;\n\t}\n}\n\nint main(){\n\tint N; cin>>N;\n\tll fact[1000001],cur,last = 0;\n\tll ans = 0;\n\tFact_table(fact,N);\n\trep1(i,N - 1){\n\t\tcur = fact[i] * fact[N - i - 1] % MOD * Comb(i - 1, N - i - 1, fact) % MOD;\n\t\tans += (cur - last) * i % MOD;\n\t\tans %= MOD;\n\t\tif(ans < 0) ans += MOD;\n\t\tlast = cur;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\nconst ll MOD = (ll)(1e9 + 7);\n\nconst int SZ = 1123456;\nll inv[SZ];\nll fact[SZ];\nll fact_inv[SZ];\nll choose(int n, int r) {\n  if (n < 0 || r < 0 || n < r) return 0;\n  return fact[n] * fact_inv[n-r] % MOD * fact_inv[r] % MOD;\n}\n\nll f(ll N, ll k) {\n  ll a = 2 * k - N;\n  ll b = N - k - 1;\n  return fact[N-k-1] * fact[k] % MOD * choose(a+b, b) % MOD;\n}\n\nint main2() {\n  ll N; cin >> N;\n  ll ans = 0;\n  for (ll k = N/2; k <= N - 1; k++) {\n    ll c1 = f(N, k-1);\n    ll c2 = f(N, k);\n    ll c = (c2 - c1) % MOD;\n    ans += c * k;\n    ans = (ans % MOD + MOD) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n\n  inv[1] = 1;\n  for (int i = 2; i < SZ; i++) inv[i] = inv[(int) (MOD % i)] * (MOD - MOD / i) % MOD;\n  fact[0] = 1;\n  for (int i = 1; i < SZ; i++) fact[i] = fact[i-1] * i % MOD;\n  fact_inv[0] = 1;\n  for (int i = 1; i < SZ; i++) fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;\n\n  for (;!cin.eof();cin>>ws)\n    main2();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define inf 1000000000\nusing namespace std;\n#define N 2000005\n#define mod 1000000007\nint n,fac[N],inv[N],f[N],ans;\nint ksm(int x,int p){\n\tint ret=1;\n\tfor (; p; p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n\treturn ret;\n}\nint getinv(int x){ return ksm(x,mod-2); }\nint C(int n,int m){ return (ll)fac[n]*inv[n-m]%mod*inv[m]%mod; }\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1; rep (i,1,2*n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[2*n]=getinv(fac[2*n]); per (i,2*n-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\trep (i,(n+1)/2,n-1){\n\t\tf[i]=(ll)fac[i]*fac[n-1-i]%mod*C(2*i-n+(n-2-(2*i-n))/2,2*i-n)%mod;\n\t\tans=(ans+(ll)(f[i]-f[i-1])*i%mod)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define je 1000000007\nusing namespace std;\n\nint n;\nlong long fact[1000005];\nlong long inv[1000005];\n\nlong long ginv(long long x){\n    long long ret = 1;\n    long long gop = x;\n    int lft = je - 2;\n    while(lft){\n        if(lft&1) ret = (ret * gop) % je;\n        gop = (gop * gop) % je;\n        lft >>= 1;\n    }\n    return ret;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    fact[0] = 1; inv[0] = 1;\n    fact[1] = 1; inv[1] = 1;\n    for(int i=2;i<=n+1;i++){\n        fact[i] = (fact[i-1] * i) % je;\n        inv[i] = ginv(fact[i]);\n    }\n    long long ans = fact[n];\n    int one = n-2, two = 0;\n    for(int i=n;i>=1;i--){\n        if(one<0) break;\n        long long nCr = fact[one+two];\n        nCr = (nCr * inv[one]) % je;\n        nCr = (nCr * inv[two]) % je;\n        long long calc = (nCr * fact[i-1]) % je;\n        calc = (calc * fact[n-i]) % je;\n        ans = (ans + je - calc) % je;\n        one -= 2; two += 1;\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define ld long double\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 1e5 + 10;\nconst int M = (int) 1e6 + 10;\nconst int K = (int) 500 + 10;\nconst int INF = (int) 1e9 + 7;\nconst int mod = (int) 1e9 + 7;\nconst ld EPS = (ld) 1e-9;\nconst ll LINF = (ll) 1e18;\n\nint n;\nint f[M], inv[M];\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\tif (x < 0)\n\t\tx += mod;\n}\n\nint mult(int x, int y) {\n\treturn x * 1ll * y % mod;\n}\n\nint sum(int x, int y) {\n\tadd(x, y);\n\treturn x;\n}\n\nint bp(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y % 2) \n\t\t\tans = mult(ans, x);\n\t\tx = mult(x, x);\n\t\ty /= 2;\n\t}\n\treturn ans;\n}\n\nint cnk(int n, int k) {\n\treturn (k < 0 || k > n ? 0 : mult(f[n], mult(inv[n - k], inv[k])));\n}\n\nint calc(int k) {\n\t// k = length of A\n\t// sum of A[i] = n - 2, 1 <= A[i] <= 2\n\tint sum = n - 2 - k;\n\treturn mult(cnk(k, sum), mult(f[n - 2 - k], f[k + 1]));\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tsrand(time(0));\n\tcin >> n;\n\tfor (int i = 0; i < M; i++) {\n\t\tf[i] = i ? mult(f[i - 1], i) : 1;\n\t\tinv[i] = bp(f[i], mod - 2);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n - 2; i++) {\n\t\tint cnt = sum(calc(i), -calc(i - 1));\n\t\tadd(ans, mult(cnt, i + 1));\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T>\nT pow_ (T x, T n, T M){\n    uint64_t u = 1, xx = x;\n    while (n > 0){\n        if (n&1) u = u * xx % M;\n        xx = xx * xx % M;\n        n >>= 1;\n    }\n    return static_cast<T>(u);\n};\n\ntemplate <class T> class Factorial {\n    T mod;\n    vector<uint64_t> facts, factinv;\n\npublic:\n    Factorial(int n, T mod) : facts(static_cast<u32>(n+1)), factinv(static_cast<u32>(n+1)), mod(mod) {\n        facts[0] = 1;\n        for (int i = 1; i < n+1; ++i) facts[i] = facts[i-1]*i % mod;\n        factinv[n] = pow_(facts[n], static_cast<uint64_t>(mod - 2), static_cast<uint64_t>(mod));\n        for (int i = n-1; i >= 0; --i) factinv[i] = factinv[i+1] * (i+1) % mod;\n    }\n\n    T fact(int k) const {\n        if(k >= 0) return static_cast<T>(facts[k]);\n        else return static_cast<T>(factinv[-k]);\n    }\n\n    T operator[](const int &k) const {\n        if(k >= 0) return static_cast<T>(facts[k]);\n        else return static_cast<T>(factinv[-k]);\n    }\n\n    T C(int p, int q) const {\n        if(q < 0 || p < q) return 0;\n        return static_cast<T>(facts[p]*  factinv[q] % mod * factinv[p-q] % mod);\n    }\n\n    T P(int p, int q) const {\n        if(q < 0 || p < q) return 0;\n        return static_cast<T>((facts[p] * factinv[p-q]) % mod);\n    }\n\n    T H(int p, int q) const {\n        if(p < 0 || q < 0) return 0;\n        return static_cast<T>(q == 0 ? 1 : C(p+q-1, q));\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    Factorial<ll> f(n, MOD);\n    ll ans = f[n-1]*(n-1)%MOD;\n    for (int i = 1; i <= n-2; ++i) {\n        (ans += (MOD-f.C(i-1, n-i-1))*f[n-i-1]%MOD*f[i]) %= MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define lop(i, s, t) for (int i = s;i < (t);++i)\n#define rep(i, s, t) for (int i = s;i <= (t);++i) \n#define dec(i, s, t) for (int i = s;i >= (t);--i)\n#define cmin(a, b) (a > b ? a = b : a)\n#define cmax(a, b) (a < b ? a = b : a)\nusing namespace std; \n\n#define Pr(f,...) printf(f,##__VA_ARGS__),fflush(stdout)\n\nconst int N=1e6+60,P=1e9+7;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\n\ntypedef long long ll;\n\nint n,fac[N],inv[N],ans;\n\nint C(int n,int m){\n\tif(m<0||m>n)return 0;\n\treturn mul(fac[n],mul(inv[n-m],inv[m])); \n}\n\nint main() {\n#ifdef CURIOUSCAT\n\t//freopen(\"dat.in\",\"r\",stdin);\n\t//freopen(\"my.out\",\"w\",stdout); \n#endif\n\tscanf(\"%d\",&n); \n\tif(n==2){ return puts(\"1\"),0; }\n\tfac[0]=1; rep(i,1,n)fac[i]=mul(fac[i-1],i); \n\tinv[1]=1; rep(i,2,n)inv[i]=mul(P-P/i,inv[P%i]); \n\tinv[0]=1; rep(i,1,n)inv[i]=mul(inv[i-1],i);\n\tans=mul(n-1,fac[n-1]); \n\trep(k,1,n-2){\n\t\tint w=mul(C(k-1,n-k-1),mul(fac[k],fac[n-1-k]));\n\t\tans=sub(ans,w); \n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* main code starts from line 133. */\n\n/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<decltype((v).front())>())\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define NREP(i, n) FOR(i, 1, n + 1)\n\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); i--)\n#define RREP(i, n) RFOR(i, n - 1, 0)\n#define RNREP(i, n) RFOR(i, n, 1)\n\n// Usual REP runs from 0 to n-1 (R: n-1 to 0)\n// Natural REP runs from 1 to n (R: n to 1)\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\n#define fcout cout << fixed << setprecision(10)\n\n/* ----------- debug ---------- */\n\ntemplate <typename T, typename U>\nvoid testP2(T a, U b) {\n    cout << \"(\" << a << \", \" << b << \")\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV(T v) {\n    cout << \"[\";\n    for (auto i : v) {\n        cout << i << \", \";\n    }\n    cout << \"\\b\\b]\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV2(T v) {\n    for (auto sv : v) {\n        testV(sv);\n    }\n    cout << endl;\n    return;\n}\n\n#define GET_VAR_NAME(variable) #variable\n#define test(x) cout << GET_VAR_NAME(x) << \" = \" << x << endl;\n#define testP(p)                      \\\n    cout << GET_VAR_NAME(p) << \" = \"; \\\n    testP2(p.fst, p.snd);\n\n/* ---------- Constants ---------- */\n\nconst ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n// const ll dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const ll dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n/* ---------- Type Definition ----------- */\n\n\n/* ---------- Global Variance ----------- */\n\nconst ll MAX_V = 1000010;\n\n/* ------------- Functions -------------- */\n\nV<ll> fact(MAX_V + 1), invfact(MAX_V + 1);\n\nll calc_pow(ll n, ll k) {\n    if (k == 0) return 1;\n    if (k == 1) return n;\n\n    if (k % 2 > 0) {\n        return calc_pow(n, k - 1) * n % MOD;\n    } else {\n        return calc_pow(n * n % MOD, k / 2);\n    }\n}\n\nvoid precalc() {\n    invfact[0] = fact[0] = 1;\n    NREP(i, MAX_V) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n\n    invfact[MAX_V] = calc_pow(fact[MAX_V], MOD - 2);\n    RREP(i, MAX_V) {\n        invfact[i] = invfact[i + 1] * (i + 1) % MOD;\n    }\n    return;\n}\n\nll comb(ll a, ll b) {\n    if (a < b) return 0;\n    if (a == 0) return 1;  // a = b = 0\n\n    return fact[a] * invfact[a - b] % MOD * invfact[b] % MOD;\n}\n\n/* ----------- Main Function ------------ */\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    precalc();\n\n    ll N;\n    cin >> N;\n\n    V<ll> pat(N);\n    // pat[k] = k台以下で全部塗るパターン数\n\n    REP(k, N) {\n        pat[k] = (fact[k] * fact[N - k - 1]) % MOD * comb(k - 1, N - k - 1) % MOD;\n    }\n\n    ll ans = 0;\n    NREP(k, N - 1) {\n        ans += (pat[k] - pat[k - 1] + MOD) * k;\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt rev(Int x){\n  return mod_pow(x, MOD-2);\n}\nInt fact[1080000];\nvoid init(){\n  fact[0] = 1;\n  for(Int i = 1;i < 1080000;i++){\n    fact[i] = fact[i-1] * i % MOD;\n  }\n}\n\nInt nCk(Int n, Int k){\n  if(n < k)return 0;\n  return fact[n] * rev(fact[n-k]) %MOD  * rev(fact[k]) % MOD;\n}\n\nInt cnt[1080000];\n\nint main(){\n  init();\n  Int n, res = 0;\n  cin >> n;\n  if(n == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  n--;\n  for(Int i = 2;i <= n;i++){\n    cnt[i] =  fact[i] * fact[n-i] % MOD;\n    cnt[i] *= nCk(i-1, n-i);\n    cnt[i] %= MOD;\n  }\n  for(Int i = n;i >= 2;i--){\n    cnt[i] -= cnt[i-1];cnt[i] %= MOD;\n    res += cnt[i] * i % MOD;\n    res %= MOD;\n  }\n  if(res < 0)res += MOD;\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <unordered_map>\n\nlong long pow_mod(long long x, long long n, long long mod_num) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) { res = (res * x) % mod_num; }\n        x = (x * x) % mod_num;\n        n = (n >> 1);\n    }\n    return res;\n}\n\nclass Combi_Num {\n    public:\n    long long mod_num;\n    std::vector<long long> factorial, factorial_inv, inv;\n    Combi_Num() {}\n    Combi_Num(const int n, const long long mod_num_in) {\n        mod_num = mod_num_in;\n        factorial.resize(n+1, 0);\n        factorial_inv.resize(n+1, 0);\n        inv.resize(n+1, 0);\n        factorial[0] = 1;\n        factorial_inv[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = (factorial[i-1] * i) % mod_num;\n            inv[i] = pow_mod(i, mod_num - 2, mod_num);\n            factorial_inv[i] = (factorial_inv[i-1] * inv[i]) % mod_num;\n        }\n    }\n\n    long long calc(const int n, const int r) {\n        return (factorial[n] * ((factorial_inv[r] * factorial_inv[n-r]) % mod_num)) % mod_num;\n    }\n};\n\nconst long long MOD = 1000000007;\nconst int MAX_N = 2000050;\nint N;\n\nCombi_Num combi_num = Combi_Num(MAX_N, MOD);\nlong long all_colored_num[MAX_N] = {};\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n\n    for (int K = 1; K <= N - 1; K++) {\n        if (K - 1 >= N - 1 - K) {\n            long long tmp = (combi_num.factorial[K] * combi_num.factorial[N-1-K]) % MOD;\n            all_colored_num[K] = (tmp * combi_num.calc(K - 1, N - 1 - K)) % MOD;\n        }\n    }\n\n    long long ret = 0;\n\n    for (int K = 1; K <= N - 1; K++) {\n        long long num = (all_colored_num[K] - all_colored_num[K-1] + MOD) % MOD;\n        ret += (num * K) % MOD;\n        ret = ret % MOD;\n    }\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <random>\n#include <tuple>\n#include <iomanip>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int,int> Pint;\n//typedef pair<ll, ll> P;\ntypedef pair<ll, pair<ll, ll>> P;\n//typedef tuple<int,int,int> T;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n-1); i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nconst ll INFL = 1LL << 60;//10^18 = 2^60\nconst int INF = 1 << 30;//10^9\nconst ll MOD = 1e9 + 7;\n//ll MOD  = 998244353;\nvector<ll> dy = {0, 0, 1, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, -1, 0, 0, 1, -1, 1, -1, 0};\n\nll max(ll a, ll b){return (a > b) ? a : b;}\nll min(ll a, ll b){return (a < b) ? a : b;}\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\nll pow_mod(ll x, ll k){\n  x %= MOD; x += MOD; x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\n//最大公約数\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\n//最小公倍数\nll lcm(ll x, ll y){return x / gcd(x, y) * y;};\n\n//コンビネーション\nconst int MAXcomb = 2000100;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\n\nint main(void){\n  COMinit();\n  ll N;\n  cin >> N;\n  ll ans = 0;\n  ll ad = 0;\n  for(ll score = 1; score <= N-1; score++){\n    ans += score * (fac[score] % MOD * fac[N-1-score] % MOD * comb(score-1, N-1-score) % MOD - ad);\n    ans %= MOD;\n    ad += fac[score] % MOD * fac[N-1-score] % MOD * comb(score-1, N-1-score) % MOD - ad;\n    while(ans < 0) ans += MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nconstexpr int mod = 1e9 + 7;\n\n// mを法とするaの逆元\n// O(log a)\ninline LL invMod(LL a, LL m = mod) {\n\tLL b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tLL t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(u -= t * v, v);\n\t}\n\treturn (u % m + m) % m;\n}\n\n\n// 階乗\n// O(n)\nconstexpr int SZ = 1123456;\nLL fact[SZ];\nLL rfact[SZ];\nstruct fact_ {\n\tfact_() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i<SZ; i++)\n\t\t\tfact[i] = fact[i - 1] * i%mod;\n\t\trfact[SZ - 1] = invMod(fact[SZ - 1]);\n\t\tfor (int i = SZ - 1; i>0; i--) {\n\t\t\trfact[i - 1] = rfact[i] * i%mod;\n\t\t}\n\t}\n}fact_init;\n\n\n// 組み合わせnCk (mod mod)\n// O(1)\nLL Comb(LL n, LL k) {\n\tLL u = fact[n];\n\tLL d = (rfact[k] * rfact[n - k]) % mod;\n\treturn u * d%mod;\n}\n\n//O(1)\nLL Perm(LL n, LL k) {\n\tLL u = fact[n];\n\tLL d = rfact[n - k] % mod;\n\treturn u * d%mod;\n}\n\nLL f(int a, int b) {\n\tb -= a;\n\ta--;\n\tif (a < 0 || b < 0 || b > a)return 0;\n\telse return Comb(a, b);\n}\n\nint main() {\n\tint N;\n\twhile (cin >> N) {\n\t\tLL ret = 0;\n\t\tfor (int k : range(1, N)) {\n\t\t\tLL x = f(k, N - 1) * fact[k] % mod;\n\t\t\tLL y = f(k - 1, N - 1) * fact[k - 1] % mod;\n\t\t\ty = y * (N - k) % mod;\n\t\t\tx = (x - y + mod) % mod;\n\t\t\tx = x * fact[N - 1 - k] % mod;\n\t\t\tret += k * x%mod;\n\t\t}\n\t\tret %= mod;\n\t\tcout << ret<< endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nconst int maxn = 1e6+10;\n\nconst long long mod = 1e9+7;\n\nint Fac[maxn],inv[maxn],invFac[maxn],f[maxn],s[maxn];\ninline long long C(int n,int m)\n{\n    return 1LL*Fac[n]*invFac[m]%mod*invFac[n-m]%mod;\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    long long ans=0LL,li=(n+1LL)/2LL;\n    Fac[0]=inv[0]=inv[1]=invFac[0]=invFac[1]=1LL;\n    for(int i=1;i<=n;i++)Fac[i]=1LL*Fac[i-1]*i%mod;//阶乘表\n    for(int i=2;i<=n;i++)inv[i]=(mod-1LL*(mod/i)*inv[mod%i]%mod)%mod;//逆元表\n    for(int i=2;i<=n;i++)invFac[i]=1LL*inv[i]*invFac[i-1]%mod;//逆元阶乘表\n    for(int i=li;i<n;i++)s[i]=1LL*C(i-1,n-1-i)*Fac[i]%mod*Fac[n-1-i]%mod;//s表\n    for(int i=n-1;i>=li;i--)f[i]=(s[i]-s[i-1]+mod)%mod;//f表\n    for(int i=n-1;i>=li;i--)ans=(ans+1LL*i*f[i])%mod;//计算结果\n    cout<<ans<<endl;\n    return 0;\n}\n\n/*\n逆元表\n阶乘表\n组合数计算表\n假设需要k次完成操作的情况有s【k】种，则ans = Σ s（k） * k，(n+1)/2 <= k <= n-1\n然而，如果但求s（k）的话，选择的顺序将会是一个很麻烦的事情\n那么不如求f（k），用来表示最多k次完成操作的情况\n于是s（k） = f（k） - f（k-1）\n先排除最右边，使n-2 machine对应n-2 square， 需要k-1次操作\n相当于接下来的k-1次操作每次可以涂满一个或者两个square，总需要n-1个square\n先假设都涂了一个square，则还需n-2-（k-1） = n-k-1，即在k-1次操作中选择n-k-1次涂两个\nC（k-1，n-1-k)\n对于涂的顺序随意，于是f（k） = C（k-1，n-1-k) * （k-1）！ * （n-1-k）！\n接下来就都是表了\n*/\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using VV = vector<vector<T>>;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(),(v).end()\n#define siz(v) (ll)(v).size()\n#define rep(i,a,n) for(ll i=a;i<(ll)(n);++i)\n#define repr(i,a,n) for(ll i=n-1;(ll)a<=i;--i)\n#define ENDL '\\n'\ntypedef pair<int,int> Pi;\ntypedef pair<ll,ll> PL;\nconstexpr ll mod = 1000000007;\nconstexpr ll INF = 1000000099;\nconstexpr ll LINF = (ll)(1e18 +99);\nconst vector<ll> dx={-1,1,0,0},dy={0,0,-1,1};\ntemplate<typename T,typename U> inline bool chmin(T& t, const U& u){if(t>u){t=u;return 1;}return 0;}\ntemplate<typename T,typename U> inline bool chmax(T& t, const U& u){if(t<u){t=u;return 1;}return 0;}\ntemplate<typename T> inline T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<typename T,typename Y> inline T mpow(T a, Y n) {\n  T res = 1;\n  for(;n;n>>=1) {\n    if (n & 1) res = res * a;\n    a = a * a;\n  }\n  return res;\n}\n\nconst int MAX = 1000010;//設定して\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;//＊１\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\n\nsigned main(){\n  cin.tie(0);ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n  ll n;cin>>n;\n  COMinit();\n  V<ll> undk(n,0);\n\n  ll ans=0;\n  rep(i,1,n){\n    if(i-1<n-1-i)continue;\n\n    ll tmp=COM(i-1,n-1-i);\n    tmp%=mod;\n    tmp*=fac[i];\n    tmp%=mod;\n    tmp*=fac[n-1-i];\n    tmp%=mod;\n    undk[i]=tmp;\n  }\n\n  rep(i,1,n){\n    ans+=i*(undk[i]-undk[i-1]+mod)%mod;\n    ans%=mod;\n  }\n\n  cout<<ans<<ENDL;\n}\n//! ( . _ . ) ! \n//CHECK overflow,vector_size,what to output?"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n\n\n#define INF 4000000000000000000LL\n#define MOD 1000000007\n#define ALL(x) std::begin(x), std::end(x)\n\n\nlong long modpow(long long x, long long y)\n{\n  long long p = 1;\n\n  for ( ; y; (x *= x) %= MOD, y >>= 1)\n    if (y & 1)\n      (p *= x) %= MOD;\n\n  return p;\n}\n\nclass modint_t {\n  friend std::ostream& operator<<(std::ostream& ofs, const modint_t a);\n\npublic:\n  modint_t(long long xx = 0) : x(xx % MOD) {};\n\npublic:\n  bool operator==(long long a) const {\n    return x == a;\n  };\n\npublic:\n  long long value() const {\n    return x;\n  };\n\npublic:\n  modint_t operator+(const modint_t& a) const {\n    return (x + a.x) % MOD;\n  };\n\n  modint_t operator-(const modint_t& a) const {\n    return (x - a.x) % MOD;\n  };\n\n  modint_t operator*(const modint_t& a) const {\n    return x * a.x % MOD;\n  };\n\n  modint_t operator/(const modint_t& a) const {\n    return (*this) * a.inverse();\n  };\n\n  // Note that operator^'s priority is quite low in C++...\n  modint_t operator^(long long i) const {\n    return modint_t(modpow(x, i));\n  };\n\npublic:\n  modint_t& operator+=(const modint_t& a) {\n    (x += a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator-=(const modint_t& a) {\n    (x -= a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator*=(const modint_t& a) {\n    (x *= a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator/=(const modint_t& a) {\t// Not tested\n    (x *= a.inverse().x) %= MOD;\n\n    return *this;\n  };\n\npublic:\n  modint_t inverse() const {\n    assert(x % MOD);\n\n    return modint_t(modpow(x, MOD - 2));\n  };\n\npublic:\n  modint_t normalized() const {\n    return modint_t(x % MOD + MOD);\n  };\n\nprivate:\n  long long x;\n};\n\nmodint_t operator-(long long a, const modint_t& b)\n{\n  return modint_t(a) - b;\n}\n\nmodint_t operator*(long long a, const modint_t& b)\n{\n  return modint_t(a) * b;\n}\n\nmodint_t operator/(long long a, const modint_t& b)\n{\n  return modint_t(a) / b;\n}\n\nstd::ostream& operator<<(std::ostream& ofs, const modint_t a)\n{\n  ofs << a.x;\n\n  return ofs;\n}\n\n\nmodint_t memo[1111111], memo2[1111111];\n\n\nint main(int argc, char** argv)\n{\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n\n  std::cout << std::fixed << std::setprecision(6);\n  std::cerr << std::fixed << std::setprecision(6);\n\n  memo[0] = memo[1] = 1;\n  \n  for (int i = 2; i < 1111111; i ++)\n    memo[i] = memo[i - 1] * i;\n\n  memo2[0] = memo2[1] = 1;\n\n  for (int i = 2; i < 1111111; i ++)\n    memo2[i] = memo2[i - 1] / i;\n\n  int N;\n  \n  std::cin >> N;\n\n  if (N == 2) {\n    std::cout << 1 << std::endl;\n\n    return 0;\n  }\n  else if (N == 3) {\n    std::cout << 4 << std::endl;\n  }\n  else if (N == 4) {\n    std::cout << 16 << std::endl;\n\n    return 0;\n  }\n\n  modint_t C = 0, c = 0;\n\n  for (int K = (N + 1) / 2; K < N; K ++) {\n    modint_t k = K - 1, l = (N - 2) - k, m = k - l;\n    \n    modint_t cc = memo[(l + m).value()] * memo2[l.value()] * memo2[m.value()] * memo[K] * memo[N - 1 - K];\n\n    C += (cc - c) * K;\n\n    c = cc;\n  }\n\n  std::cout << C << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconstexpr int mod = 1000000007;\nint n, inv[1000009];\nint main() {\n\tcin >> n;\n\tinv[1] = 1;\n\tint cur = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tinv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\t\tcur = 1LL * cur * (i - 1) % mod;\n\t}\n\tint ret = 0;\n\tfor (int i = n - 1; cur != 0; i--) {\n\t\tint x = 1LL * cur * inv[i] % mod * inv[i + 1] % mod * (2 * i - n + 2) % mod * (2 * i - n + 1) % mod;\n\t\tret = (ret + 1LL * (cur - x + mod) * (i + 1)) % mod;\n\t\tcur = x;\n\t}\n\tcout << ret << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconstexpr int mod = 1000000007;\nint n, inv[1000009], val[1000009];\nint main() {\n\tcin >> n;\n\tinv[1] = 1;\n\tint cur = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tinv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\t\tcur = 1LL * cur * (i - 1) % mod;\n\t}\n\tfor (int i = n - 1; 2 * i - n >= 0; i--) {\n\t\tcur = 1LL * cur * inv[i] % mod * inv[i + 1] % mod * (2 * i - n + 2) % mod * (2 * i - n + 1) % mod;\n\t\tval[i] = cur;\n\t}\n\tint ret = 0;\n\tfor (int i = n - 1; 2 * i - n >= 0; i--) {\n\t\tret = (ret + 1LL * (val[i] - val[i - 1] + mod) * i) % mod;\n\t}\n\tcout << ret << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\nll factt[1234567];\nll ff[1000000];\n\nll calc(ll a,ll b,ll p){\n  if(b==0){\n    return 1;\n  }else if(b%2==0){\n    ll d=calc(a,b/2,p);\n    return (d*d)%p;\n  }else if(b%2==1){\n    return (a*calc(a,b-1,p))%p;\n  }\n}\nll inv(ll y){\n  return calc(y, MOD-2, MOD);\n}\n\nll comb(ll a,ll b){\n  if(a<b)return 0;\n  ll ans=(factt[a]*inv(factt[b]))%MOD;\n  ans*=inv(factt[a-b])%MOD;\n  return ans%MOD;\n}\n\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  if(n==2){\n    P(1);\n    return 0;\n  }else if(n==3){\n    P(4);\n    return 0;\n  }\n  REP(i,1000000){\n    if(i==0)factt[i]=1;\n    else factt[i]=(i*factt[i-1])%MOD;\n  }\n  // REP(i,100)P(factt[i]);\n  REP(i,1000000){\n    ff[i]=(comb(i-1,n-i-1)*factt[i])%MOD;\n    ff[i]*=factt[n-i-1];\n    ff[i]%=MOD;\n  }\n  ll ans=0;\n  for(int i=(n+1)/2;i<=n-1;i++){\n    ans+=(ff[i]-ff[i-1])*i;\n    ans%=MOD;\n  }\n  P(ans%MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint fact[1000005], fact_inv[1000005];\n\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 1000005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 1000005; i++){\n\t\tfact_inv[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint n;\n\nllint func(llint x)\n{\n\tif(x < 2) return 0;\n\tllint N = n-3;\n\tllint K = (n-1) - x;\n\t\n\tif((N+1)/2 < K) return 0;\n\tllint ret = comb(N+1-K, K);\n\tret *= fact[K], ret %= mod;\n\tret *= fact[(n-1)-K], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n;\n\tif(n == 2){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tmake_fact();\n\t\n\tllint ans = (n-1) * func(n-1) % mod;\n\tfor(int i = 1; i < n-1; i++){\n\t\tans += mod - func(i);\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Utkarsh.25dec\n#include <bits/stdc++.h>\n#include <chrono>\n#include <random>\n#define ll long long int\n#define ull unsigned long long int\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define loop(i,a,b) for(ll i=a;i<=b;i++)\n#define vi vector <int>\n#define vs vector <string>\n#define vc vector <char>\n#define vl vector <ll>\n#define all(c) (c).begin(),(c).end()\n#define max3(a,b,c) max(max(a,b),c)\n#define min3(a,b,c) min(min(a,b),c)\n#define deb(x) cerr<<#x<<' '<<'='<<' '<<x<<'\\n'\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n// ordered_set s ; s.order_of_key(val)  no. of elements strictly less than val\n// s.find_by_order(i)  itertor to ith element (0 indexed)\ntypedef vector<vector<ll>> matrix;\nll power(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll modInverse(ll a){return power(a,mod-2);}\nconst int N=1000023;\nbool vis[N];\nvector <int> adj[N];\nll fact[N];\nll invfact[N];\nll inv[N];\nvoid factorialsComputation()\n{\n    inv[0]=inv[1]=1;\n    fact[0]=fact[1]=1;\n    invfact[0]=invfact[1]=1;\n    for(int i=2;i<N;i++)\n    {\n        inv[i]=(inv[mod%i]*(mod-mod/i))%mod;\n        fact[i]=(fact[i-1]*i)%mod;\n        invfact[i]=(invfact[i-1]*inv[i])%mod;\n    }\n}\nll ncr(ll n,ll r)\n{\n    ll ans=fact[n];\n    ans*=(invfact[r]);\n    ans%=mod;\n    ans*=(invfact[n-r]);\n    ans%=mod;\n    return ans;\n}\nvoid solve()\n{\n    ll n;\n    cin>>n;\n    ll f[n+1]={0};\n    int low=(n+1)/2;\n    for(int k=low;k<=n-1;k++)\n    {\n        f[k]=(ncr(k-1,n-k-1))*fact[k];\n        f[k]%=mod;\n        f[k]*=fact[n-1-k];\n        f[k]%=mod;\n    }\n    ll ans=0;\n    for(int k=low;k<=n-1;k++)\n    {\n        ll ways=f[k]-f[k-1]+mod;\n        ways%=mod;\n        ways*=k;\n        ways%=mod;\n        ans+=ways;\n        ans%=mod;\n    }\n    cout<<ans<<'\\n';\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int T=1;\n    //cin>>T;\n    int t=0;\n    factorialsComputation();\n    while(t++<T)\n    {\n        //cout<<\"Case #\"<<t<<\":\"<<' ';\n        solve();\n        //cout<<'\\n';\n    }\n    cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << \"ms\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconstexpr int MOD = 1e9 + 7;\nll pow1(ll n, ll p){\n    ll cur, res;\n    cur = n;\n    res = 1;\n    while(p){\n        if(p & 1){\n            res *= cur;\n            res %= MOD;\n        }\n        p /= 2;\n        cur *= cur;\n        cur %= MOD;\n    }\n    return res;\n}\nll fact[1000001];\nll inv[1000001];\nll K[1000001];\nll cnk(int n, int k){\n    if(n < k)return 0;\n    return fact[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n    fact[0] = inv[0] = 1;\n    for(int i = 1;i < 1000001;i++)\n        fact[i] = fact[i-1] * i % MOD, inv[i] = pow1(fact[i], MOD - 2);\n    int n;\n    cin >> n;\n//    cout << fact[10000] * inv[9999] % MOD << endl;\n    for(int i = 1;i < n;i++){\n        K[i] = cnk(i-1, n - i - 1) * fact[i] % MOD * fact[n-1-i] % MOD;\n    }\n    ll cum = 0;\n    ll res = 0;\n//    cout << K[5] - K[4] << endl;\n    for(int i = 1;i < n;i++){\n        res += (K[i] - K[i-1]) * i % MOD;\n        cum += K[i];\n        cum %= MOD;\n        res %= MOD;\n    }\n    if(res < 0)res += MOD;\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define N 1000005\nusing namespace std;\n\ntypedef long long ll;\nll n, s, fac[N]{1, 1}, inv[N]{1, 1}, fiv[N]{1, 1};\nll M = 1e9 + 7;\nint main()\n{\n\tll i, t, old = 0;\n\tcin >> n;\n\tfor (i = 2; i <= n; i++) {\n\t\tfac[i] = fac[i - 1] * i % M;\n\t\tinv[i] = inv[M % i] * (M - M / i) % M;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % M;\n\t}\n\tfor (i = (n + 1) / 2; i < n; i++) {\n\t\tt = fac[i] * fac[i - 1] % M * fiv[2 * i - n] % M;\n\t\ts = (s + (t - old + M) * i % M) % M;\n\t\told = t;\n\t}\n    cout << s << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,ans=0;\n  cin>>N;\n  COMinit();\n  ll cnt[N];\n  REP(i,N) cnt[i]=0;\n  \n  for(ll i=1; i<=N-1; ++i){\n    cnt[i]=COM(i-1,N-1-i)*fac[i]*fac[N-1-i]%MOD;\n    ans+=(cnt[i]-cnt[i-1])*i;\n    ans%=MOD;\n  }\n  \n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 2000005, MOD = 1000000007;\nint f[N], finv[N], act[N];\n\nint mul(int a, int b) {\n    return (ll)a * b % MOD;\n}\n\nvoid precalc() {\n    f[0] = 1;\n    for (int i = 1; i < N; i++) {\n        f[i] = mul(f[i - 1], i);\n    }\n    finv[0] = finv[1] = 1;\n    for (int i = 2; i < N; i++) {\n        finv[i] = (MOD - mul(MOD / i, finv[MOD % i])) % MOD;\n    }\n    for (int i = 2; i < N; i++) {\n        finv[i] = mul(finv[i - 1], finv[i]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(cout.fixed);\n    cout.precision(20);\n    precalc();\n    int n;\n    cin >> n;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        act[k] = mul(mul(f[k - 1], f[k]), finv[2 * k - n]);\n    }\n    ll res = 0;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        res = (res + mul(k, MOD + act[k] - act[k - 1])) % MOD;\n    }\n    cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nclass comb{\npublic:    ll mod;\n    ll mx;\n    vector<ll> F;\n    vector<ll> FR;\n    \n\n    comb(ll mod=1000000007,ll mx=100000):mod(mod),mx(mx),F(mx+1,1),FR(mx+1,1){\n        mk_F();\n    }\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_F(){\n        for(ll i=1;i<=mx;i++){F[i]=F[i-1]*i%mod; FR[i]=R(F[i]);}\n    }\n    \n    ll c(ll n,ll k){\n        if(n<k){return 0;}\n        if(n==k || k==0){return 1;}\n        return F[n]*FR[n-k]%mod*FR[k]%mod;\n    }\n    \n    //mod must be prime\n    ll Lucas_C(ll n,ll m){\n        ll ret=1;\n        while(n>0 || m>0){\n            ret*=c(n%mod,m%mod);\n            ret%=mod;\n            n/=mod; m/=mod;\n        }\n        return ret;\n    }\n    \n    ll Stirling(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){\n            if((k-i)%2){ret-=c(k,i)*mod_pow(i,n)%mod;}\n            else{ret+=c(k,i)*mod_pow(i,n)%mod;}\n            ret%=mod;\n        }\n        ret*=R(F[k]);\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    ll Bell(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){ret+=Stirling(n,i); ret%=mod;}\n        return ret;\n    }\n};\n\nint main(){\n    comb C(MOD,1000010);\n    ll n;\n    cin>>n;\n    ll ans=0;\n    ll sum=0;\n    for(int i=1;i<n;i++){\n        ll cnt=C.c(i-1,n-1-i)*C.F[i]%MOD*C.F[n-1-i]%MOD-sum;\n        sum+=cnt;\n        sum%=MOD;\n        ans+=cnt*i%MOD;\n        ans%=MOD;\n    }\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 1e9 + 7;\n\nvector<long long int> inverse;\nvector<long long int> f, f_inverse;\n\nvoid factorial_Initialize(int max){\n    vector<long long int> a(max+1,1);\n    inverse = a;\n    f = a;\n    f_inverse = a;\n\n    for (int i=2; i<=max; i++){\n        inverse[i]   = MOD - inverse[MOD % i] * (MOD / i) % MOD;\n        f[i]         = f[i-1]         * i          % MOD;\n        f_inverse[i] = f_inverse[i-1] * inverse[i] % MOD;\n    }\n}\n\nlong long int nCr(int n, int r){\n    if(n < r || r < 0) return 0;\n    if (n >= f.size()){\n        factorial_Initialize(n);\n    }\n    return f[n] * f_inverse[r] % MOD * f_inverse[n-r] % MOD;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    factorial_Initialize(n);\n\n    long long int ans = 0;\n    for(int i=1; i<=n-1; i++){\n        long long int cases = (f[i]   * f[n-1-i] % MOD) * nCr(i-1, n-1-i) % MOD\n                            - (f[i-1] * f[n-i]   % MOD) * nCr(i-2, n-i)   % MOD;\n        cases = (cases % MOD + MOD) % MOD;\n        //cout << i << \" \" << cases << endl;\n        ans += i * cases % MOD;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    if(N == 2){\n        cout << 1;\n        return 0;\n    }\n    int mod = 1000000007;\n\n    Combination C(N, mod);\n    int ans = 0;\n\n    //両端以外が最後\n    FOR(k, 1, (N - 3) / 2 + 1){\n        int c = (k * C.comb(N - 3 - k, k)) % mod;\n        int tmp = (c * C.fact[N - k - 2]) % mod;\n        tmp = (tmp * 2 * C.fact[k]) % mod;\n        tmp = (tmp * (N - 1 - k)) % mod;\n        ans = (ans + tmp) % mod;\n    }\n    FOR(k, 1, (N - 4) / 2 + 1){\n        int c = (k * C.comb(N - 4 - k, k)) % mod;\n        int tmp = (c * C.fact[N - k - 3]) % mod;\n        tmp = (tmp * C.fact[k + 1]) % mod;\n        tmp = (tmp * (N - 2 - k)) % mod;\n        ans = (ans + tmp) % mod;\n    }\n\n    //両端が最後\n    FOR(k, 0, (N - 2) / 2 + 1){\n        int c = C.comb(N - k - 2, k);\n        int tmp = (c * C.fact[N - 2 - k]) % mod;\n        tmp = (tmp * C.fact[k]) % mod;\n        tmp = (tmp * (N - 1 - k)) % mod;\n        ans = (ans + 2 * tmp) % mod;\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n\n#include<cstdio>\n\n#include<cstdlib>\n\n#include<cstring>\n\n#include<cmath>\n\n#include<algorithm>\n\n#include<vector>\n\n#define re register\n\n#define il inline\n\n#define ll long long\n\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define min(a,b) ((a)<(b)?(a):(b))\n\n#define fp(i,a,b) for(re int i=a;i<=b;i++)\n\n#define fq(i,a,b) for(re int i=a;i>=b;i--)\n\nusing namespace std;\n\nconst int mod=1e9+7,N=1e6+100;\n\nll n,x,jc[N],p,ans,Need,f[N],inv[N];\n\nil ll gi()\n\n{\n\n  re ll x=0,t=1;\n\n  re char ch=getchar();\n\n  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n\n  if(ch=='-') t=-1,ch=getchar();\n\n  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();\n\n  return x*t;\n\n}\n\nil ll C(re ll x,re ll y)\n\n{\n\n  return jc[y]*inv[y-x]%mod*inv[x]%mod;\n\n}\n\nint main()\n\n{\n\n  n=gi();Need=(n+1)/2;\n\n  jc[0]=inv[0]=inv[1]=1;\n\n  fp(i,2,n) inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;//printf(\"%lld \",inv[i]);\n\n  fp(i,1,n) jc[i]=jc[i-1]*i%mod;\n\n  fp(i,2,n) inv[i]=inv[i]*inv[i-1]%mod;\n\n  fp(i,Need,n-1) f[i]=C(n-i-1,i-1)*jc[i]%mod*jc[n-i-1]%mod;\n\n  fq(i,n-1,Need) f[i]=(f[i]-f[i-1]+mod)%mod;\n\n  fp(i,Need,n-1) (ans+=(f[i]*i%mod))%=mod;\n\n  printf(\"%lld\\n\",ans);\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD ((ll)1e9+7)\nll N;\nll m,ans,F[1010101];\nll i, j, k;\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\nint main(){\n    //printf(\"%lld\\n\", MOD);\n    scanf(\"%lld\", &N);\n    F[0] = 1;\n    fornum(i,0,N+1){\n        F[i + 1] = F[i] * (i + 1) % MOD;\n    }\n    m = 0;\n    fornum(k,(N+1)/2,N){\n        ll a=moddiv(F[k-1],F[N-k-1]*F[k*2-N]);\n        a = a * F[k] % MOD;\n        a = a * F[N-1-k] % MOD;\n        ans = (ans + (MOD+a-m)%MOD*k%MOD) % MOD;\n        m = a;\n        //printf(\"%lld %lld %lld %lld\\n\",k, moddiv(F[k-1],F[N-k-1]*F[k*2-N]),F[N-1-k],ans);\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1000005,mu=1000000007;\nint inv[N],p[N],n,ans,last; \nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*1ll*x%mu)\n\t\tif (y&1) ans=1ll*ans*x%mu;\n\treturn ans;\n}\nint C(int x,int y){\n\treturn 1ll*p[x]*inv[y]%mu*inv[x-y]%mu;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tputs(\"1\");\n\t\texit(0);\n\t} \n\tif (n==3){\n\t\tputs(\"4\");\n\t\texit(0);\n\t}\n\tp[0]=1;\n\tfor (int i=1;i<=n;i++) p[i]=1ll*i*p[i-1]%mu;\n\tinv[n]=ksm(p[n],mu-2);\n\tfor (int i=n-1;i>=0;i--) inv[i]=inv[i+1]*1ll*(i+1)%mu;\n\tfor (int i=(n+1)/2;i<=n-1;i++){\n\t\tint x=C(i-1,n-i-1)*1ll*p[i]%mu*p[n-i-1]%mu;\n\t\tans=(ans+i*1ll*(x-last+mu)%mu)%mu;\n\t\tlast=x;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\n\n\nvoid go(){\n    int n=in();\n    mint ans = 0 , sum = 0;\n    calc();\n    rep2(i,1,n-1){\n        mint T = cmb(i-1,n-1-i)*prd[i]*prd[n-1-i];\n        ans += (T - sum)*i;\n        sum += T;\n        // cout<<T.a<<endl;\n    }\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define re register\n#define il inline\n#define ll long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define fp(i,a,b) for(re int i=a;i<=b;i++)\n#define fq(i,a,b) for(re int i=a;i>=b;i--)\nusing namespace std;\nconst int mod=1e9+7,N=1e6+100;\nll n,x,jc[N],p,ans,Need,f[N],inv[N];\nil ll gi()\n{\n  re ll x=0,t=1;\n  re char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n  if(ch=='-') t=-1,ch=getchar();\n  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();\n  return x*t;\n}\nil ll ksm(re ll S,re ll n)\n{\n  re ll T=S;S=1;\n  while(n)\n    {\n      if(n&1) S=S*T%mod;\n      T=T*T%mod;\n      n>>=1;\n    }\n  return S;\n}\nil ll C(re ll x,re ll y)\n{\n  return jc[y]*inv[y-x]%mod*inv[x]%mod;\n}\nint main()\n{\n  n=gi();Need=(n+1)/2;\n  jc[0]=inv[0]=inv[1]=1;\n  fp(i,2,n) inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;//printf(\"%lld \",inv[i]);\n  fp(i,1,n) jc[i]=jc[i-1]*i%mod;\n  fp(i,2,n) inv[i]=inv[i]*inv[i-1]%mod;\n  fp(i,Need,n-1) f[i]=C(n-i-1,i-1)*jc[i]%mod*jc[n-i-1]%mod;\n  fq(i,n-1,Need) f[i]=(f[i]-f[i-1]+mod)%mod;\n  fp(i,Need,n-1) (ans+=(f[i]*i%mod))%=mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 1e6 + 5;\n\nModint fact [MAX_N];\nModint invfact [MAX_N];\n\nModint choose (int n, int k) {\n  return fact[n] * invfact[n - k] * invfact[k];\n}\n\n// # of ways to use k machines to get it all-black\nModint ways [MAX_N];\n\nint main () {\n  fact[0] = Modint(1);\n  for (int i = 1; i < MAX_N; i++) {\n    fact[i] = fact[i - 1] * Modint(i);\n  }\n\n  for (int i = 0; i < MAX_N; i++) {\n    invfact[i] = inv(fact[i]);\n  }\n  \n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  if (n == 2) {\n    cout << 1 << endl;\n    return 0;\n  }\n\n  for (int l = 0; n - 2 - 2 * l >= 0; l++) {\n    ways[n - 1 - l] = choose(n - 2 - 2 * l + l, l);\n  }\n\n  for (int k = 0; k < n; k++) {\n    ways[k] *= fact[k];\n  }\n\n  for (int k = n - 1; k > 0; k--) {\n    ways[k] -= ways[k - 1] * Modint(n - k);\n  }\n\n  Modint ans (0);\n  for (int k = 0; k < n; k++) {\n    ans += Modint(k) * ways[k] * fact[n - 1 - k];\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\ntemplate <int M, bool IsPrime = false>\nclass modulo {\n    using ll = long long;\npublic:\n    modulo() : n(0) {}\n    modulo(int m) : n(m) {\n        if(n >= M) {\n            n %= M;\n        } else if(n < 0) {\n            n = (n % M + M) % M;\n        }\n    }\n    modulo(ll m) : modulo(int(m % M)) {}\n\n    explicit operator int() const { return n; }\n    explicit operator ll() const { return n; }\n\n    bool operator==(modulo const& a) const {\n        return n == a.n;\n    }\n\n    modulo& operator+=(modulo const& a) {\n        n += a.n;\n        if(n >= M) {\n            n -= M;\n        }\n        return *this;\n    }\n    modulo& operator-=(modulo const& a) {\n        n -= a.n;\n        if(n < 0) {\n            n += M;\n        }\n        return *this;\n    }\n    modulo& operator*=(modulo const& a) {\n        n = (ll(n) * a.n) % M;\n        return *this;\n    }\n    modulo operator^(int n) const {\n        if(n == 0) {\n            return modulo(1);\n        }\n        const modulo a = *this;\n        modulo res = (a * a) ^ (n / 2);\n        return n % 2 ? res * a : res;\n    }\n\n    typename std::enable_if<IsPrime, modulo>::type operator/(modulo const& a) const {\n        return *this * modulo(inv(ll(a), M));\n    }\n\nprivate:\n    ll n;\n    static typename std::enable_if<IsPrime, ll>::type inv(ll a, ll p) {\n        return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n    }\n};\n\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator+(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    return lhs += rhs;\n}\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator-(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    return lhs -= rhs;\n}\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator*(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    return lhs *= rhs;\n}\n\nconstexpr int MOD = 1000000007;\n\n// sw == false -> inv\ntemplate <int M = MOD>\nmodulo<M, true> fact(int n, bool sw = true) {\n    static std::vector<modulo<M, true>> v1 = {1}, v2 = {1};\n    if(n >= (int)v1.size()) {\n        const int from = v1.size(), to = n + 1024;\n        v1.reserve(to);\n        v2.reserve(to);\n        for(int i = from; i < to; ++i) {\n            v1.push_back(v1.back() * modulo<M, true>(i));\n            v2.push_back(v2.back() / modulo<M, true>(i));\n        }\n    }\n    return sw ? v1[n] : v2[n];\n}\n\ntemplate <int M = MOD>\nmodulo<M, true> comb(int a, int b) {\n    if(b < 0 || b > a) {\n        return fact<M>(0);\n    }\n    return fact<M>(a, true) * fact<M>(b, false) * fact<M>(a - b, false);\n}\n\nusing mod = modulo<MOD, true>;\n\nint main() {\n    int n;\n    cin >> n;\n    if(n == 2) {\n        cout << 1 << endl;\n    } else if(n == 3) {\n        cout << 4 << endl;\n    } else if(n == 4) {\n        cout << 16 << endl;\n    } else {\n        mod ans = 0;\n        mod cur = 0;\n        for(int k = (n + 1) / 2; k <= n - 1; ++k) {\n            mod t = comb(k - 1, n - 1 - k) * fact(k) * fact(n - 1 - k);\n            ans += (t - cur) * mod(k);\n            cur = t;\n        }\n        cout << (ll)ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\ntypedef long long ll;\n\n#define N_MAX 1000001\n#define P 1000000007\n\nusing namespace std;\n\nll inv[N_MAX], fac[N_MAX], finv[N_MAX];\n\nll comb(ll n, ll r){\n  ll ans = 1;\n  ans = (fac[n]*finv[n-r])%P;\n  ans = (ans*finv[r])%P;\n  if(ans < 0) ans += P;\n  return ans;\n}\n\nvoid make(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<N_MAX;i++){\n        inv[i]=P-inv[P%i]*(P/i)%P;\n        fac[i]=fac[i-1]*(ll) i%P;\n        finv[i]=finv[i-1]*inv[i]%P;\n    }\n}\n\nint main(){\n    int N;\n    //ll f[N_MAX];\n    ll ans;\n    cin >> N;\n    \n    ll s;\n    make();\n    if(N%2 == 0){\n        s = N/2;\n        ans = (((s*comb(s-1, N-s-1))%P)*((fac[s]*fac[N-s-1])%P))%P;\n        //cout << comb(s-1, N-s-1) << ' ' << fac[s] << ' ' << fac[N-s-1] << endl;\n    }else{\n        s = (N+1)/2;\n        ans = ((s*comb(s-1, N-s-1)%P)*((fac[s]*fac[N-s-1])%P))%P;\n    }\n    if(ans < 0)ans+=P;\n    \n    s++;\n    for(;s <= N-1; s++){\n        ll tmp;\n        tmp = (((s*comb(s-1, N-s-1))%P)*((fac[s]*fac[N-s-1])%P))%P - (((s*comb(s-2, N-s))%P)*((fac[s-1]*fac[N-s])%P))%P;\n        //cout << ((s*comb(s-1, N-s-1)%P)*(fac[s]*fac[N-s-1])%P)%P << endl;\n        //cout << ((s*comb(s-2, N-s)%P)*(fac[s-1]*fac[N-s])%P)%P << endl;\n        tmp = tmp%P; \n        if(tmp < 0)tmp+=P;\n        //cout << tmp << endl;\n        ans = (ans+tmp)%P;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nlong long mod_pow(long long x,long long n){\n    if(n==0) return 1;\n    long long res = mod_pow(x*x % mod, n/2);\n    if(n & 1) res = res*x % mod;\n    return res;\n}\nlong long fact[1000010];//書き換えよう!\nlong long get_nCk(long long n, long long k){\n    if(fact[0] == 0){\n        fact[0] = 1;\n        for(int i = 1; i < 1000010; i++) fact[i] = fact[i-1] * i % mod;\n    }\n    return fact[n] * mod_pow(fact[k], mod - 2) % mod * mod_pow(fact[n - k], mod - 2) % mod;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    get_nCk(1, 1);\n    int n;\n    cin >> n;\n    if(n == 2){\n        cout << 1 << endl;\n        return 0;\n    }\n    int ans = 0;\n    rep(k, 0, n / 2){\n        int tmp = fact[n - 2 - k] * min(k + 2, n - 1 - k) % mod * get_nCk(n - 3, k) % mod * (n - 1 - k) % mod;\n        ans += tmp;\n        ans %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nint f[1000001];\nint inv[10000001];\n\nint bp (int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint C (int n, int k) {\n\tif (k > n) return 0;\n\treturn (f[n] * ((inv[k] * inv[n - k]) % mod)) % mod;\n} \n\n main () {\n \tint n;\n\tcin >> n;\n\tf[0] = 1;\n\tinv[0] = 1;\n\tfor (int i = 1;i <= n;i ++) {\n\t\tf[i] = (f[i - 1] * i) % mod;\n\t\tinv[i] = bp (f[i], mod - 2);\n\t} \n\tint ans = 0;\n\tint last = 0 ;\n\tfor (int i = (n + 1) / 2;i < n;i ++) {\n\t\tint k = i;\n\t\tint cur = C (k - 1, n - k - 1);\n\t//\tcout << cur << ' ' ;\n\t\tcur = (cur * f[k]) % mod;\n\t\tcur = (cur * f[n - k - 1]) % mod;\n\t\tcur = (cur - last);\n\t\tlast = cur;\n\t\tif (cur < 0) cur += mod;\n\t\tans = (ans + ((cur * k) % mod)) % mod;\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SIZE(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nstruct ModRing {\n   int mod, x;\n   ModRing(int mod_n) : mod(mod_n), x(0) {}\n   ModRing(int a, int mod_n) : mod(mod_n) { x = ((a % mod) + mod) % mod; }\n\n   bool operator==(const ModRing& a) const {\n      return x == a.x;\n   }\n   bool operator==(int a) const {\n      return *this == ModRing(a, mod);\n   }\n   ModRing& operator=(int a) {\n      return *this = ModRing(a, mod);\n   }\n   ModRing operator-() const {\n      return ModRing((-x + mod) % mod, mod);\n   }\n   ModRing& operator+=(const ModRing& a) {\n      (x += a.x) %= mod;\n      return *this;\n   }\n   ModRing& operator-=(const ModRing& a) {\n      return *this += -a;\n   }\n   ModRing& operator*=(const ModRing& a) {\n      (x *= a.x) %= mod;\n      return *this;\n   }\n   const ModRing operator+(const ModRing& a) const {\n      return ModRing(x, mod) += a;\n   }\n   const ModRing operator-(const ModRing& a) const {\n      return ModRing(x, mod) -= a;\n   }\n   const ModRing operator*(const ModRing& a) const {\n      return ModRing(x, mod) *= a;\n   }\n   ModRing& operator+=(int a) {\n      return *this += ModRing(a, mod);\n   }\n   ModRing& operator-=(int a) {\n      return *this -= ModRing(a, mod);\n   }\n   ModRing& operator*=(int a) {\n      return *this *= ModRing(a, mod);\n   }\n   const ModRing operator+(int a) const {\n      return ModRing(x, mod) += a;\n   }\n   const ModRing operator-(int a) const {\n      return ModRing(x, mod) -= a;\n   }\n   const ModRing operator*(int a) const {\n      return ModRing(x, mod) *= a;\n   }\n   ModRing power(int n) const {\n      ModRing tmp(x, mod), res(1, mod);\n      while (n > 0) {\n         if ((n & 1) == 1) res *= tmp;\n         tmp *= tmp;\n         n >>= 1;\n      }\n      return res;\n   }\n};\nauto&operator<<(ostream&s,const ModRing&a){s<<a.x;return s;}\n\nstruct FiniteField : ModRing {\n   FiniteField(int mod_n) : ModRing(mod_n) {}\n   FiniteField(int a, int mod_n) : ModRing(a, mod_n) {}\n   FiniteField(const ModRing& a) : ModRing(a) {}\n\n   bool operator==(const FiniteField& a) const {\n      return ModRing::operator==(a);\n   }\n   bool operator==(int a) const {\n      return ModRing::operator==(a);\n   }\n   FiniteField& operator=(int a) {\n      return *this = FiniteField(ModRing::operator=(a));\n   }\n   FiniteField operator-() const {\n      return FiniteField(ModRing::operator-());\n   }\n   FiniteField& operator+=(const FiniteField& a) {\n      return *this = FiniteField(ModRing::operator+=(a));\n   }\n   FiniteField& operator-=(const FiniteField& a) {\n      return *this = FiniteField(ModRing::operator-=(a));\n   }\n   FiniteField& operator*=(const FiniteField& a) {\n      return *this = FiniteField(ModRing::operator*=(a));\n   }\n   const FiniteField operator+(const FiniteField& a) const {\n      return FiniteField(ModRing::operator+(a));\n   }\n   const FiniteField operator-(const FiniteField& a) const {\n      return FiniteField(ModRing::operator-(a));\n   }\n   const FiniteField operator*(const FiniteField& a) const {\n      return FiniteField(ModRing::operator*(a));\n   }\n   FiniteField& operator+=(int a) {\n      return *this = FiniteField(ModRing::operator+=(a));\n   }\n   FiniteField& operator-=(int a) {\n      return *this = FiniteField(ModRing::operator-=(a));\n   }\n   FiniteField& operator*=(int a) {\n      return *this = FiniteField(ModRing::operator*=(a));\n   }\n   const FiniteField operator+(int a) const {\n      return FiniteField(ModRing::operator+(a));\n   }\n   const FiniteField operator-(int a) const {\n      return FiniteField(ModRing::operator-(a));\n   }\n   const FiniteField operator*(int a) const {\n      return FiniteField(ModRing::operator*(a));\n   }\n   FiniteField power(int n) const {\n      return FiniteField(ModRing::power(n));\n   }\n\n   FiniteField inverse() const {\n      try { if (x == 0) throw \"0 have no inverse\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return power(mod-2);\n   }\n   FiniteField& operator/=(const FiniteField& a) {\n      return *this *= a.inverse();\n   }\n   const FiniteField operator/(const FiniteField& a) const {\n      return FiniteField(x, mod) /= a;\n   }\n   FiniteField& operator/=(int a) {\n      return *this /= FiniteField(a, mod);\n   }\n   const FiniteField operator/(int a) const {\n      return FiniteField(x, mod) /= a;\n   }\n};\n\nint GF_MOD = MOD_N;\nstruct GF : FiniteField {\n   GF() : FiniteField(GF_MOD) {}\n   GF(int a) : FiniteField(a, GF_MOD) {}\n   GF(const FiniteField& a) : FiniteField(a) {}\n};\n\nvector<GF> frac;\nvoid init_frac(int N) {\n   frac.resize(N+1);\n   frac[0] = 1;\n   for (int i = 1; i <= N; i++) {\n      frac[i] = frac[i-1] * i;\n   }\n}\nGF C(int n, int r) {\n   if (n < 0 || n-r < 0 || r < 0) {\n      return 0;\n   }\n   return frac[n] / (frac[n-r] * frac[r]);;\n}\n\nsigned main()\n{\n   int n; cin >> n;\n\n   init_frac(n-1);\n   V<GF> num(n);\n   FORE(k, 1, n-1) {\n      num[k] = C(k-1, n-1-k) * frac[k] * frac[n-1-k];\n   }\n   GF ans = 0;\n   FORE(k, 1, n-1) {\n      ans += (num[k] - num[k-1]) * k;\n   }\n   DUMP(ans)\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 1111111;\nconst int mod = 1000000007;\nusing li = long long;\n\nli inv[N];\nli fact[N];\nli invfact[N];\n\nli C(int n, int k) {\n\treturn fact[n] * invfact[k] % mod * invfact[n - k] % mod;\n}\n\nli g(int n, int k) {\n\treturn C((n + k)/2 - 1, k - 1);\n}\n\nli f(int n, int k) {\n\tif (2 * k <= n) {\n\t\treturn C(n, k);\n\t}\n\tli tmp = C(n, k) - g(n, 2 * k - n);\n\tif (tmp < 0) {\n\t\ttmp += mod;\n\t}\n\treturn tmp % mod;\n}\n\nint main() {\n\tint n = nxt();\n\n\tfact[0] = invfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tinv[i] = (i == 1) ? 1 : mod - (mod / i) * inv[mod % i] % mod;\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinvfact[i] = invfact[i - 1] * inv[i] % mod;\n\t}\n\n\tli ans = 0;\n\tfor (int k = 0; k <= n - 1; ++k) {\n\t\tans += f(n - 1, k) * fact[k] % mod * fact[n - 1 - k] % mod;\n\t}\n\tcout << ans % mod << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 10000000000000002\n\nint beki(long long a,long long b,int M = modulo){\n\tint x = 1;\n\twhile(b!=0){\n\t\tif(b&1){\n\t\t\tx=((long long)x*a)%M;\n\t\t}\n\t\ta=((long long)a*a)%M;\n\t\tb>>=1;\n\t}\n\treturn x;\n}\n\n\nint gyakugen(int a){\n\treturn beki(a,modulo-2);\n}\n\nstruct combi{\n\tdeque<int> kaijou;\n\tdeque<int> kaijou_;\n\t\n\tcombi(int n){\n\t\tkaijou.push_back(1);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tkaijou.push_back(mod(kaijou[i-1]*i));\n\t\t}\n\t\t\n\t\tint b=gyakugen(kaijou[n]);\n\t\t\n\t\tkaijou_.push_front(b);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint k=n+1-i;\n\t\t\tkaijou_.push_front(mod(kaijou_[0]*k));\n\t\t}\n\t}\n\t\n\tint combination(int n,int r){\n\t\tif(r>n)return 0;\n\t\tint a = mod(kaijou[n]*kaijou_[r]);\n\t\ta=mod(a*kaijou_[n-r]);\n\t\treturn a;\n\t}\n\t\n\tint junretsu(int a,int b){\n\t\tint x = mod(kaijou_[a]*kaijou_[b]);\n\t\tx=mod(x*kaijou[a+b]);\n\t\treturn x;\n\t}\n\t\n\tint catalan(int n){\n\t\treturn mod(combination(2*n,n)*gyakugen(n+1));\n\t}\n\t\n};\n\n\nint main(){\n\n\tint N;\n\tcin>>N;\n\t\n\tint ans = 0;\n\tcombi C(2000000);\n\tvector<int> cnt(N,0);\n\tfor(int i=1;i<N;i++){\n\t\tint t = C.kaijou[i];\n\t\tt = mod(C.kaijou[N-1-i] * t);\n\t\tt = mod(C.combination(i-1,N-1-i)*t);\n\t\tcnt[i] = t;\n\t\t//ans = mod(ans + t);\n\t}\n\t\n\tfor(int i=1;i<N;i++){\n\t\tans = mod(ans + mod(cnt[i]-cnt[i-1])*i);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int N = 1e6+15,mod = 1e9+7;\n\nll fac[N],inv[N];\n\nll combi(ll n,ll k){\n\tif(k>n || k<0)return 0;\n\n\tll ret= (fac[n]*inv[k])%mod;\n\tret= (ret*inv[n-k])%mod;\n\treturn ret;\n\n}\nll mypow(ll r,ll c){\n\tll ret=1;\n\twhile(c){\n\t\tif(c&1){\n\t\t\tret = (ret*r)%mod;\n\t\t}\n\t\tc/=2;\n\t\tr = (r*r)%mod;\n\t}\n\treturn ret;\n}\nll f(int n,int k){\n\n\tint a = k-1,b = n-k-1;\n\n\tif(b<0 || 2*k-n<0)return 0;\n\tll ret = (combi(a,b)*fac[k])%mod;\n\n\tret = (ret *fac[n-k-1])%mod;\n\t\n\treturn ret;\n}\n\nint main(){\n\n    //freopen(\"input.txt\",\"r\",stdin);\n\n    fac[0]= 1;inv[0]= 1;\n    int n;\n    scanf(\"%d\",&n);\n\n    if(n==2){\n\n    \tcout<<1<<endl;return 0;\n    }\n    for(int i=1;i<N;++i){\n    \tfac[i]= (fac[i-1]*i)%mod;\n    }\n    inv[n]= mypow(fac[n],mod-2);\n\n\n    for(int i=n-1;i>=1;--i){\n    \tinv[i]= (inv[i+1]*(i+1))%mod;\n    }\n\n    ll ret=0;\n\n    for(int i=1;i<n;++i){\n    \tret = (ret + (i*(f(n,i)-f(n,i-1) + mod))%mod  )%mod;\n    }\n    cout<<ret<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 1e9 + 7;\n\nvector<long long int> inverse;\nvector<long long int> f, f_inverse;\n\nvoid factorial_Initialize(int max){\n    vector<long long int> a(max+1,1);\n    inverse = a;\n    f = a;\n    f_inverse = a;\n\n    for (int i=2; i<=max; i++){\n        inverse[i]   = MOD - inverse[MOD % i] * (MOD / i) % MOD;\n        f[i]         = f[i-1]         * i          % MOD;\n        f_inverse[i] = f_inverse[i-1] * inverse[i] % MOD;\n    }\n}\n\nlong long int nCr(int n, int r){\n    if(n < r || r < 0) return 0;\n    if (n >= f.size()){\n        factorial_Initialize(n);\n    }\n    return f[n] * f_inverse[r] % MOD * f_inverse[n-r] % MOD;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    factorial_Initialize(n);\n\n    long long int ans = 0;\n    for(int i=1; i<=n-1; i++){\n        long long int cases = (f[i]   * f[n-1-i] % MOD) * nCr(i-1, n-1-i) % MOD\n                            - (f[i-1] * f[n-i]   % MOD) * nCr(i-2, n-i)   % MOD;\n        //cout << i << \" \" << cases << endl;\n        ans += i * cases % MOD;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// In the name of God\n#include <bits/stdc++.h>\n//#define int long long\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\n\n#define y1 def1\n#define X first\n#define Y second\n#define endl '\\n'\n#define all(o) o.begin(), o.end()\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\nconst int maxn = 1e6 + 10, mod = 1e9 + 7;\nint fact[maxn], inv[maxn];\ninline int ad(int x,int y){\n\tx += y;\n\tif(x < mod)\n\t\treturn x;\n\treturn x - mod;\n}\ninline int mu(int x,int y){\n\treturn 1LL * x * y % mod;\n}\ninline int bpow(int x,int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y & 1) res = mu(res, x);\n\t\tx = mu(x, x);\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nvoid prep(){\n\tfor(int i=0; i<maxn; i++)\n\t\tfact[i] = (!i ? 1 : mu(i, fact[i-1]));\n\tinv[maxn-1] = bpow(fact[maxn-1], mod - 2);\n\tfor(int i=maxn-2; i>=0; i--)\n\t\tinv[i] = mu(i+1, inv[i+1]);\n}\nint C(int r,int n){\n\tif(r > n || n < 0 || r < 0) return 0;\n\treturn mu(fact[n], mu(inv[r], inv[n-r]));\n}\nint f(int r,int n){\n\tif(r == 0) return (n == 0);\n\treturn C(r-1, n+r-1);\n}\nint a[maxn];\nint32_t main(){\n    IOS;\n\tprep();\n\tint sum = 0, ans = 0;\n\t//cout << f(2, 2) << endl;\n\tint n;\n\tcin >> n;\n\tfor(int i=n; i>=1; i--){\n\t\tif(i * 2 > n) continue;\n\t\tint tot = f(i, n-i-i);\n\t\tint aft = i-1;\n\t\tint bef = n-1-aft;\n\t\tint now = mu(fact[aft], mu(fact[bef], tot));\n\t\t//cout << \"HAHA\" << i << \" \" << now << endl;\n\t\tint bia = ad(now, mod - sum);\n\t\tans = ad(ans, mu(bef, bia));\n\t\tsum = now;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,ans=0;\n  cin>>N;\n  COMinit();\n  ll cnt[N];\n  REP(i,N) cnt[i]=0;\n  \n  for(ll i=(N+1)/2; i<=N-1; ++i){\n    cnt[i]=fac[i]*fac[i-1];\n    cnt[i]%=MOD;\n    cnt[i]*=finv[2*i-N];\n    cnt[i]%=MOD;\n    ans+=(cnt[i]-cnt[i-1])*i;\n    ans%=MOD;\n  }\n  \n  if(ans<0) ans+=MOD;\n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\n\n\nvector<P> v[10];\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nint l[33];\n\nint o[3000544];\nint j[41][6];\nint dx[10]={0,1,0,-1,1,1,-1,-1},dy[10]={-1,0,1,0,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z[1000100];\n\nP u[1000020];\nstack<int> s[2];\n//queue<int> q,q1,q2;\n//set<int> s;\nqueue<P> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<long long,int> p;\n//list<int> l;\n//string r1,r;\nchar r[52];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y<b.y;\n}\nlong long g(long long a)\n{\n    if(a<0) return 0;\n    return z[a];\n}\n\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b/2);\n    x*=x;\n    x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nlong long f(long long x,long long y)\n{\n\n    if(x<y) return 0;\n    return g(x)*p(g(y),mod-2)%mod*p(g(x-y),mod-2)%mod;\n}\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    z[0]=1;\n    for(int t=1;t<=a;t++)\n        z[t]=z[t-1]*t%mod;\n    long long n=0;\n    for(int t=2;t<a;t++)\n    {\n        y=x;\n        x=f(t-1,a-1-t)*g(t)%mod*g(a-1-t)%mod;\n        n+=(x-y)*t;\n        n%=mod;\n        //printf(\"!!%lld %lld %lld %lld\\n\",x,f(t-1,a-t-1),g(t),g(a-1-t));\n    }\n    printf(\"%lld\",n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static const AlgStruct idAdd(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static const AlgStruct idMul(Args... args) { return Operators::IdMul(args...); }\n\n    const AlgStruct operator+() const { return *this; }\n    const AlgStruct operator-() const { return Operators::Opposite(x); }\n    const AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct& operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct& operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct& operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct& operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    const AlgStruct power(LL n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& value){ s << value.x; return s; }\n\n\ntemplate<LL mod>\nstruct GaloisFieldOperators {\n    static LL Add(LL lhs, LL rhs) { return (lhs + rhs) % mod; };\n    static LL Mul(LL lhs, LL rhs) { return (lhs * rhs) % mod; };\n    static LL IdAdd() { return 0; };\n    static LL IdMul() { return 1; };\n    static LL Opposite(LL value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(LL lhs, LL rhs) { return lhs < rhs; };\n    static LL Power(LL value, LL n) {\n        LL res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static LL Reciprocal(LL value) { return Power(value, mod-2); }\n};\n\nconst LL MOD = 1e9+7;\n\nusing GaloisField = AlgStruct<LL, GaloisFieldOperators<MOD>>;\n\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring::idMul();\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\n\nsigned main()\n{\n    LL n; cin >> n;\n\n    Fact<GaloisField> fact(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * fact[k] * fact[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (LL k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nint n;\nint dp[1000005],tohop[1000005],ans;\nint pew(int x,int y,int p){\n\tint res=1;\n\tx%=p;\n\twhile(y>0){\n\t\tif(y%2) res=(res*x)%p;\n\t\ty/=2;\n\t\tx=(x*x)%p;\n\t}\n\treturn res;\n}\nint fuck(int n,int p){\n\treturn pew(n,p-2,p);\n}\nint solve(int n,int k){\n\tif(n<k) return 0;\n\tif(k==0) return 1;\n\treturn (tohop[n]*fuck(tohop[k],mod)%mod*fuck(tohop[n-k],mod)%mod)%mod;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tdp[2]=1,tohop[0]=1;\n\tfor(int i=1;i<=1000000;i++){\n\t\ttohop[i]=tohop[i-1]*i%mod;\n\t}\n\tfor(int i=n/2;i<n;i++){\n\t\tdp[i]=solve(i-1,n-i-1)*tohop[i]%mod*tohop[n-i-1]%mod;\n\t\tans=(ans+(dp[i]-dp[i-1]+mod)*i%mod)%mod;\n\t}\n\tprintf(\"%d\",ans%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <deque>\n#define INF 1e9\n#define MOD 1000000007\n#define MAX_N 1000001\n#define mod(x, M) ((x % M) + M) % M\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll M[MAX_N], S[MAX_N];\n\n\nll mod_pow(ll x, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nll frac[MAX_N];\nvoid init(ll N) {\n    frac[0] = 1;\n    for (ll i = 1; i < N; ++i) {\n        frac[i] = mod(frac[i - 1] * i, MOD);\n    }\n}\n\nll comb(ll n, ll r) {\n    return mod(frac[n] * mod_pow(mod(frac[n - r] * frac[r], MOD), MOD - 2, MOD), MOD);\n}\n\n\nint main() {\n    ll N;\n    cin >> N;\n    init(N);\n    \n    M[0] = 0;\n    for (ll i = 0; i < N; ++i) {\n        if (i - 1 < (N-1) - i) {\n            S[i] = 0;\n        } else {\n            S[i] = mod(comb(i - 1, (N-1) - i) * frac[i], MOD);\n        }\n        if (i != 0) {\n            M[i] = mod(S[i] - S[i - 1], MOD);\n        }\n    }\n    \n    ll ans = 0;\n    for (ll i = 0; i < N; ++i) {\n        ans = mod(ans + mod(mod(M[i] * frac[(N-1) - i], MOD) * i, MOD), MOD);\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+5,mod=1e9+7;\nll n,f[N];\nll powmod(ll x,ll n)\n{\n\tll s=1;\n\twhile(n)\n\t{\n\t\tif(n&1)\n\t\t\ts=(s*x)%mod;\n\t\tn>>=1;\n\t\tx=(x*x)%mod;\n\t}\n\treturn s;\n}\nll C(ll n,ll m)\n{\n\tif(n<m)\n\t\treturn 0;\n\tll a=f[n],b=(f[n-m]*f[m])%mod;\n\treturn (a*powmod(b,mod-2))%mod;\n}\nint main()\n{\n\tcin>>n;\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tf[i]=(f[i-1]*i)%mod;\n\tll res=0,pre=0;\n\tfor(int k=1;k<n;k++)\n\t{\n\t\tll tk=(f[k]*f[n-1-k])%mod;\n\t\ttk=(tk*C(k-1,n-k-1))%mod;\n\t\tll num=(tk-pre+mod)%mod;\n\t\tres=(res+(num*k)%mod)%mod;\n\t\tpre=tk;\n\t}\n\tcout<<res<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define re register\n#define il inline\n#define ll long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define fp(i,a,b) for(re int i=a;i<=b;i++)\n#define fq(i,a,b) for(re int i=a;i>=b;i--)\nusing namespace std;\nconst int mod=1e9+7,N=1e6+100;\nll n,x,jc[N],p,ans,Need,f[N],inv[N];\nil ll gi()\n{\n  re ll x=0,t=1;\n  re char ch=getchar();\n  while(ch!=‘-‘&&(ch<‘0‘||ch>‘9‘)) ch=getchar();\n  if(ch==‘-‘) t=-1,ch=getchar();\n  while(ch>=‘0‘&&ch<=‘9‘) x=x*10+ch-48,ch=getchar();\n  return x*t;\n}\nil ll C(re ll x,re ll y)\n{\n  return jc[y]*inv[y-x]%mod*inv[x]%mod;\n}\nint main()\n{\n  n=gi();Need=(n+1)/2;\n  jc[0]=inv[0]=inv[1]=1;\n  fp(i,2,n) inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;//printf(\"%lld \",inv[i]);\n  fp(i,1,n) jc[i]=jc[i-1]*i%mod;\n  fp(i,2,n) inv[i]=inv[i]*inv[i-1]%mod;\n  fp(i,Need,n-1) f[i]=C(n-i-1,i-1)*jc[i]%mod*jc[n-i-1]%mod;\n  fq(i,n-1,Need) f[i]=(f[i]-f[i-1]+mod)%mod;\n  fp(i,Need,n-1) (ans+=(f[i]*i%mod))%=mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000+7;\nconstexpr long long INF = std::numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, last, cnt, ans,sum, a[400000];\nstring str[1000], ss[1000];\nbool f;\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ -1,0 } ,{ 0,-1 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[10000];\nset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nstruct Combination {\n\tint mod;\n\tvector< int64_t > mfact, rfact;\n\n\tCombination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod) {\n\t\tmfact[0] = 1;\n\t\tfor (int i = 1; i < mfact.size(); i++) {\n\t\t\tmfact[i] = mfact[i - 1] * i % mod;\n\t\t}\n\t\trfact[sz] = inv(mfact[sz]);\n\t\tfor (int i = sz - 1; i >= 0; i--) {\n\t\t\trfact[i] = rfact[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\n\tint64_t fact(int k) const {\n\t\treturn (mfact[k]);\n\t}\n\n\tint64_t pow(int64_t x, int64_t n) const {\n\t\tint64_t ret = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) (ret *= x) %= mod;\n\t\t\t(x *= x) %= mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn (ret);\n\t}\n\n\tint64_t inv(int64_t x) const {\n\t\treturn (pow(x, mod - 2));\n\t}\n\n\tint64_t P(int n, int r) const {\n\t\tif (r < 0 || n < r) return (0);\n\t\treturn (mfact[n] * rfact[n - r] % mod);\n\t}\n\n\tint64_t C(int p, int q) const {\n\t\tif (q < 0 || p < q) return (0);\n\t\treturn (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n\t}\n\n\tint64_t H(int n, int r) const {\n\t\tif (n < 0 || r < 0) return (0);\n\t\treturn (r == 0 ? 1 : C(n + r - 1, r));\n\t}\n};\n\nint main() {\n\tcin >> n;\n\tCombination comb(1000020, MOD);\n\tn--;\n\trep(i, n) {\n\t\tif(i%2==0)\n\t\tsum += comb.mfact[n];\n\t\telse {\n\t\t\tsum += comb.mfact[n]-comb.mfact[(n+2)/2];\n\t\t}\n\t\tsum %= MOD;\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS 1e-10\n#define setNil(x) memset((x),0,sizeof(x))\n#define setINF(x) memset((x),63,sizeof(x))\n#define setNegINF(x) memset((x),192,sizeof(x)) //NegINF=-INF-1\n#define setNeg1(x) memset((x),255,sizeof(x))\nusing namespace std;\nint n;\nlong long fac[1000005],inv[1000005],ans;\ninline long long fpow(long long x,int y){\n\tif(y==1)return x;\n\tlong long t=fpow(x,y>>1);\n\t(t*=t)%=MOD;\n\tif(y&1)(t*=x)%=MOD;\n\treturn t;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n;\n\tfor(int i=fac[0]=inv[0]=1;i<=n;i++){\n\t\tfac[i]=fac[i-1]*i%MOD;\n\t\tinv[i]=fpow(fac[i],MOD-2);\n\t}\n\tfor(int i=(n+1)>>1;i<n;i++){\n\t\t(ans+=fac[i]*fac[i-1]%MOD*inv[2*i-n]%MOD)%=MOD;\n\t}\n\tcout<<(fac[n]-ans+MOD)%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=1e6+6;\nconst int32_t M=1e9+7;\nint32_t rev(int32_t x,int32_t m){\n    if(x==1)return 1;\n    return (1-(ll)rev(m%x,x)*m)/x+m;\n}\nstruct mint{\n    int32_t x;\n    mint():x(0){}\n    mint(int32_t xx):x(xx%M){if(x<0)x+=M;}\n    mint(ll xx):x(xx%M){if(x<0)x+=M;}\n    mint& operator+=(mint b){if((x+=b.x)>=M)x-=M;return *this;}\n    mint operator+(mint b){mint res=*this;res+=b;return res;}\n    mint& operator-=(mint b){if((x-=b.x)<0)x+=M;return *this;}\n    mint operator-(mint b){mint res=*this;res-=b;return res;}\n    mint& operator*=(mint b){x=(ll)x*b.x%M;return *this;}\n    mint operator*(mint b){mint res=*this;res*=b;return res;}\n    mint inverse(){return rev(x,M);}\n    mint& operator/=(mint b){x=(ll)x*rev(b.x,M)%M;return *this;}\n    mint operator/(mint b){mint res=*this;res/=b;return res;}\n    mint operator^(ll w) {mint r=1,a=*this;while(w){if(w&1)r*=a;a*=a;w/=2;}return r;}\n    mint operator^=(ll w){return *this=(*this)^w;}\n    mint operator^(mint w){return *this^w.x;}\n    mint operator^=(mint w){return *this=(*this)^w;}\n    mint operator-()const{return mint()-*this;}\n    explicit operator bool()const{return x;}\n};\nistream&operator>>(istream&is,mint&p){istream&res=is>>p.x;p.x%=M;return res;}\nostream&operator<<(ostream&os,mint p){return os<<p.x;}\ntemplate<typename T>mint operator+(T x,mint y){return mint(x)+y;}\ntemplate<typename T>mint operator-(T x,mint y){return mint(x)-y;}\ntemplate<typename T>mint operator*(T x,mint y){return mint(x)*y;}\ntemplate<typename T>mint operator/(T x,mint y){return mint(x)/y;}\ntemplate<typename T>mint operator^(T x,mint y){return mint(x)^y;}\nmint abs(mint x){return x;}\nmint fc[N],ifc[N];\nstruct pc{pc(){\n        fc[0]=1;\n        for(int i=1;i<N;++i)fc[i]=fc[i-1]*i;\n        ifc[N-1]=1/fc[N-1];\n        for(int i=N-2;i>=0;--i)ifc[i]=ifc[i+1]*(i+1);\n}}pc;\nmint bin(int n,int k){\n    if(k<0||k>n)return 0;\n    return fc[n]*ifc[k]*ifc[n-k];\n}\nint32_t main(){\n\n\tint n;\n\tcin>>n;\n\tmint ans=0,pf=0;\n\tfor(int k=1;k<n;++k){\n\t\tint a=n-1-k,b=k+k-n;\n\t\tmint f=bin(a+b,a)*fc[k]*fc[n-1-k];\n\t\tmint g=f-pf;\n\t\tans+=g*k;\n\t\tpf=f;\n\t}\n\tcout<<ans<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nint f[1000001];\nint inv[10000001];\n\nint bp (int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint C (int n, int k) {\n\tif (k > n) return 0;\n\treturn (f[n] * ((inv[k] * inv[n - k]) % mod)) % mod;\n} \n\n main () {\n \tint n;\n\tcin >> n;\n\tf[0] = 1;\n\tinv[0] = 1;\n\tfor (int i = 1;i <= n;i ++) {\n\t\tf[i] = (f[i - 1] * i) % mod;\n\t\tinv[i] = bp (f[i], mod - 2);\n\t} \n\tint ans = 0;\n\tint last = 0 ;\n\tfor (int i = (n + 1) / 2;i < n;i ++) {\n\t\tint k = i;\n\t\tint cur = C (k - 1, n - k - 1);\n\t//\tcout << cur << ' ' ;\n\t\tcur = (cur * f[k]) % mod;\n\t\tcur = (cur * f[n - k - 1]) % mod;\n\t\tcur = (cur - last + mod) % mod\t;\n\t\tlast = cur;\n\t\tans = (ans + ((cur * k) % mod)) % mod;\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <chrono>\nusing namespace std;\ntypedef long long ll;\n#define tr(container, it) \\\n\tfor (auto it = container.begin(); it != container.end(); it++)\n#define scontains(c,x) ((c).find(x) != (c).end())   //O(log n)\n#define contains(c,x) (find((c).begin(),(c).end(),x) != (c).end()) //O(n)\n#define ill(_x)  ll _x;scanf(\"%lld\",&_x);\n#define idb(_x)  double _x;scanf(\"%lf\",&_x);\n#define pll pair<ll,ll>\n#define mll map<ll,ll>\n#define vll vector<ll>\n#define sll set<ll>\n#define vs vector<string>\n#define in0(x,a,b)((x)>=a && (x)<=b\t)\n#define in1(x,a,b)((x)>a && (x)<b)\n#define  rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\nconst double pi = 3.14159265358979323846;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\n\n\nll A[200005];\nll B[200005];\nvoid _(){\n    ill(n);\n    for (int i = 0; i < n-1; ++i) {\n        A[i]=i;\n    }\n    ll s=0;\n    map<ll,ll>map1;\n    do{\n        memset(B,0,n* sizeof(ll));\n        ll a=0;bool fst=1;\n        for (int i = 0; i < n-1; ++i) {\n//            cout <<A[i] <<\"->\" ;\n            B[A[i]]=B[A[i]+1]=1;\n            if(all_of(B,B+n,[](ll aa){ return aa==1;}) &&fst){a=i+1;fst=!fst;}\n        }\n//        cout <<\"count=\" <<a <<\"\\n\";\n        s+=a;\n        map1[a]++;\n    }\n    while (next_permutation(A,A+n-1));\n//    for(auto a :map1){\n//        cout << \"times:\" << a.first << \"count:\" <<a.second <<\"\\n\";\n//    }\n    cout << s <<\"\\n\";\n}\n\n\n\n\n\nint main() {\n#if __MINGW32__\n\tfreopen(\"E:\\\\Workspace\\\\Desktop\\\\cpp\\\\IO\\\\Input.txt\", \"r\", stdin); freopen(\"E:\\\\Workspace\\\\Desktop\\\\cpp\\\\IO\\\\Output.txt\", \"w\", stdout);\n#endif\n\n\tios_base::sync_with_stdio(false);    cin.tie(NULL);\n\t_();\n\treturn 0;\n\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 1000000007LL\n#define maxn 100005\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii(1LL, 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 2000000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\ni64 f( i64 n , i64 k )\n{\n    if( k < ( n-4 +2-1 )/2 || k>(n-3) || n<0 || k<0 ) return 0LL ;\n    return C(k+1,n-3-k) ;\n}\n\nint main()\n{\n    preprocess() ;\n\n    i64 i , j , k , l , m , n ;\n\n    scanf(\"%lld\",&n) ;\n\n    if(n==2)\n    {\n        printf(\"1\\n\") ;\n        return 0 ;\n    }\n\n    i64 ans = 0LL ;\n\n    for( i64 k = (n-4 + 2-1)/2 ; k<=n-3 ; k++ )\n    {\n        i64 ret = ( fact[k+2]*f(n,k) - fact[k+1]*((f(n,k-1)*(n-k-2))%mod) )%mod ;\n        ret = (ret*fact[ n-k-3 ])%mod ;\n        ans = ( ans + ret*(k+2) )%mod ;\n  //      printf(\"%lld-->%lld\\n\",k,ans) ;\n    }\n\n    printf(\"%lld\\n\", (ans%mod + mod)%mod ) ;\n\n    return 0 ;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define PB push_back\n#define MP make_pair\n#define REP(i,a,b) for (int i = a; i <b; i++)\ntypedef long long ll;\n#define int ll\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef pair<int,int> pi;\n#define trace(x) cout<<#x<<\"=\"<<x<<\"\\n\";\n#define llp 1000000007\n#define mod 1000000007\n\n\nll power(ll x, ll y) \n{\n    ll temp;\n    if( y == 0)\n        return 1;\n    temp = power(x, y/2);\n    if (y%2 == 0)\n        return (temp*temp)%mod;\n    else\n        return (((x*temp)%mod)*temp)%mod; \n}\nint fact[1000005];\nint invfact[1000005];\nint inv(int N){\n    return power(N,mod-2);\n}\nll nCr(ll n, ll r){\n    if(r<0 || n<0)return 0;\n    if(n<r) return 0;\n    ll a=fact[n];\n    a=(a*invfact[r])%mod;\n    a=(a*invfact[n-r])%mod;\n    return a;\n}\nvoid init(){\n    fact[0]=1;\n    invfact[0]=1;\n    for(int i=1;i<1000005;i++){\n        fact[i]=(i*fact[i-1])%mod;\n        invfact[i]=inv(fact[i]);\n    }\n}\n\n\nint32_t main(){\n\tios::sync_with_stdio(false);\n    init();\n    int n;\n    cin>>n;\n    ll ans=(n-1)*fact[n-1];\n    ans=ans%mod;\n    int k=n-2;\n    for(int i=1;i*2<=k;i++){\n        int cur=fact[k-i];\n        cur=(cur*fact[n-1-i])%mod;\n        cur=(cur*invfact[k-2*i])%mod;\n        ans-=cur;\n        ans=ans%mod;\n    }\n    if(ans<0)ans+=mod;\n    cout<<ans<<\"\\n\";\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1000010, P = 1000000007;\nint n, ans, fact[maxn], finv[maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint C(int x, int y) {\n    if (x < y || y < 0) return 0;\n    return 1LL * fact[x] * finv[y] % P * finv[x - y] % P;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = fact[0] = finv[0] = 1; i <= n; i++) {\n        fact[i] = 1LL * i * fact[i - 1] % P;\n        finv[i] = qp(fact[i], P - 2);\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int t = 1LL * C(n - 2, i) * fact[i] % P;\n        t = (t + 1LL * fact[i] * C(n - 2, i - 1)) % P;\n        t = (t - 1LL * C(i - 1, i + i - n) * fact[i] % P + P) % P;\n        ans = (ans + 1LL * t * fact[n - 1 - i]) % P;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rng(i,s,n) for(int i = (s) ; i < (n) ; i++)\n#define rep(i,n) rng(i, 0, (n))\n#define mkp make_pair\n#define vec vector\n#define vi vec<int>\n#define pb emplace_back\n#define siz(a) (int)(a).size()\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) (lower_bound(all(b),(i))-(b).begin())\n#define ssp(i,n) (i==(int)(n)-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define cyes printf(\"Yes\\n\")\n#define cno printf(\"No\\n\")\n#define cdf(n) int quetimes_=(n);rep(qq123_,quetimes_)\n#define gcj printf(\"Case #%lld: \",qq123_+1)\n#define readv(a,n) a.resize(n,0);rep(i,(n)) a[i]=read()\n#define found(a,x) (a.find(x)!=a.end())\n//#define endl \"\\n\"\nconstexpr int mod = (ll)1e9 + 7;\nconstexpr int Mod = 998244353;\nconstexpr ld EPS = 1e-10;\nconstexpr ll inf = (ll)3 * 1e18;\nconstexpr int Inf = (ll)15 * 1e8;\nconstexpr int dx[] = { -1,1,0,0 }, dy[] = { 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(short g = 0) { H u; int k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g == 1) u.fs--, u.sc--; if (g == 2) u.fs--; return u; }\nbool ina(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nbool ina(int t, int l, int r) { return l <= t && t < r; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll popcount(ll x) {\n    int sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n    return sum;\n}\ntemplate<typename T>\nclass csum {\n    vec<T> v;\npublic:\n    csum(vec<T>& a) :v(a) { build(); }\n    csum(){}\n    void init(vec<T>& a) { v = a; build(); }\n    void build() {\n        for (int i = 1; i < v.size(); i++) v[i] += v[i - 1];\n    }\n    T a(int l, int r) {\n        if (r < l) return 0;\n        return v[r] - (l == 0 ? 0 : v[l - 1]);\n    }//[l,r]\n    T b(int l, int r) {\n        return a(l, r - 1);\n    }//[l,r)\n    T a(pair<int, int>t) {\n        return a(t.first, t.second);\n    }\n    T b(pair<int, int>t) {\n        return b(t.first, t.second);\n    }\n};\nclass mint {\npublic:ll v;\n      mint(ll v = 0) { s(v % mod + mod); }\n      constexpr static int mod = (ll)1e9 + 7;\n      constexpr static int fn_ = (ll)2e6 + 5;\n      static mint fact[fn_], comp[fn_];\n      mint pow(int x) const {\n          mint b(v), c(1);\n          while (x) {\n              if (x & 1) c *= b;\n              b *= b;\n              x >>= 1;\n          }\n          return c;\n      }\n      inline mint& s(int vv) {\n          v = vv < mod ? vv : vv - mod;\n          return *this;\n      }\n      inline mint inv()const { return pow(mod - 2); }\n      inline mint operator-()const { return mint() - *this; }\n      inline mint& operator+=(const mint b) { return s(v + b.v); }\n      inline mint& operator-=(const mint b) { return s(v + mod - b.v); }\n      inline mint& operator*=(const mint b) { v = v * b.v % mod; return *this; }\n      inline mint& operator/=(const mint b) { v = v * b.inv().v % mod; return *this; }\n      inline mint operator+(const mint b) const { return mint(v) += b; }\n      inline mint operator-(const mint b) const { return mint(v) -= b; }\n      inline mint operator*(const mint b) const { return mint(v) *= b; }\n      inline mint operator/(const mint b) const { return mint(v) /= b; }\n      friend ostream& operator<<(ostream& os, const mint& m) {\n          return os << m.v;\n      }\n      friend istream& operator>>(istream& is, mint& m) {\n          int x; is >> x; m = mint(x);\n          return is;\n      }\n      bool operator<(const mint& r)const { return v < r.v; }\n      bool operator>(const mint& r)const { return v > r.v; }\n      bool operator<=(const mint& r)const { return v <= r.v; }\n      bool operator>=(const mint& r)const { return v >= r.v; }\n      bool operator==(const mint& r)const { return v == r.v; }\n      bool operator!=(const mint& r)const { return v != r.v; }\n      explicit operator bool()const { return v; }\n      explicit operator int()const { return v; }\n      mint comb(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              if (k > * this - k) k = *this - k;\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp * comp[k.v];\n          }\n          return fact[v] * comp[k.v] * comp[v - k.v];\n      }//nCk\n      mint perm(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp;\n          }\n          return fact[v] * comp[v - k.v];\n      }//nPk\n      static void combinit() {\n          fact[0] = 1;\n          for (int i = 1; i < fn_; i++) fact[i] = fact[i - 1] * mint(i);\n          comp[fn_ - 1] = fact[fn_ - 1].inv();\n          for (int i = fn_ - 2; i >= 0; i--) comp[i] = comp[i + 1] * mint(i + 1);\n      }\n}; mint mint::fact[fn_], mint::comp[fn_];\n//--------------------------------------------------------------\n\n\n//---------------------------------------------------------------------\n\nint n;\nsigned main() {\n    cin >> n;\n\n    //(n+1)/2以上でしか動かない\n    mint ans = 0, pre = 0;\n    for (int i = (n + 1) / 2; i <= n - 1; i++) {\n        //埋めるには、nブロック必要\n        //何ブロックに分かれるかを見る→(2*n-(i*2))/2=n-i\n        //n-i個の区画に分かれると見てよい\n\n        int t = n - i;//区画の数\n        //最後に埋めきるのにどこを選ぶかは、長さ3以上の区画で2通り、長さ2の区画で1通り\n        //全ての区画は2個以上なので、(N-t*2)をt個の0以上にに分ける方法を考えればよい\n        //あとは、何個のブロックを置くか!\n        //最後に生贄になるブロックはドイツ？\n        //2個ブロックをj個置く場合、j+(t-j)*2\n        //Σ2*t-j = k\n\n        int g = 2 * i - n;//何個だぶりが必要か？\n        //これを3に全ぶっぱしたのが最小\n\n\n        mint res = mint(g + t - 1).comb(t - 1) * mint::fact[i] * mint::fact[n - i - 1];\n        ans += (res - pre) * i;\n        pre = res;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N;\nll f[1000001], res;\n\nll pw(ll x, int y) {\n\tll a = 1;\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\ta = a*x%mod;\n\t\t}\n\t\tx = x*x%mod;\n\t\ty /= 2;\n\t}\n\treturn a;\n}\n\nll modinv(ll x) {\n\treturn pw(x, mod - 2);\n}\n\nll comb(int n, int r) {\n\treturn f[n] * modinv(f[r]) % mod*modinv(f[n - r]) % mod;\n}\n\nint main() {\n\tcin >> N;\n\tf[0] = 1;\n\tfor (ll i = 1; i <= 1000000; ++i) {\n\t\tf[i] = f[i - 1] * i % mod;\n\t}\n\tif (N & 1) {\n\t\tres = comb((N - 1) / 2, 1)*((N - 1) / 2 + 1) % mod*f[(N - 1) / 2 + 1] % mod*f[N - 1 - ((N - 1) / 2 + 1)] % mod;\n\t\tfor (int i = 3; i < N; i += 2) {\n\t\t\tres += (comb((N - i) / 2 + i - 1, i)*f[(N - i) / 2 + i] % mod*f[N - 1 - ((N - i) / 2 + i)] % mod + mod - comb((N - i + 2) / 2 + i - 3, i - 2)*f[(N - i + 2) / 2 + i - 2] % mod*f[N - 1 - ((N - i + 2) / 2 + i - 2)] % mod)*((N - i) / 2 + i) % mod;\n\t\t\tres %= mod;\n\t\t}\n\t}\n\telse {\n\t\tres = f[N / 2] * N / 2 % mod * f[N / 2 - 1] % mod;\n\t\tfor (int i = 2; i < N; i += 2) {\n\t\t\tres += (comb(N / 2 + i / 2 - 1, i)*f[N / 2 + i / 2] % mod*f[N / 2 - i / 2 - 1] % mod + mod - comb(N / 2 + i / 2 - 2, i - 2)*f[N / 2 + i / 2 - 1] % mod*f[N / 2 - i / 2] % mod)*(N / 2 + i / 2) % mod;\n\t\t\tres %= mod;\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <string.h>\n#include <math.h>\n#include <stdio.h>\n#include <deque>\n#include <bits/stdc++.h>\n//#include \"D:\\C++\\test_lib_projects\\testlib.h\"\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n\nbool debug=true;\n/*\n   Write In New Computer\n    By XiaoGeNintendo\n\t     gwq2017\n\tType:\n*/\n\nchar c[305][305];\nint n;\nchar c2[305][305];\nbool check(int a,int b){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tc2[i][j]=c[(i+a)%n][(j+b)%n];\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(c2[i][j]!=c2[j][i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main(int argc,char* argv[]){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",c[i]);\n\t}\n\t\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tbool aa=check(0,i);\n\t\tint x=0,y=i;\n\t\twhile(x<n && y<n){\n\t\t\tans+=aa;\n\t\t\tx++;y++;\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=1;i<n;i++){\n\t\tbool aa=check(i,0);\n\t\tint x=i,y=0;\n\t\twhile(x<n && y<n){\n\t\t\tans+=aa;\n\t\t\tx++;y++;\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 1000100\n#define ll long long\n#define mod (int)(1e9+7)\nusing namespace std;\nint fac[N],inv[N],n;\nint C(int n,int m)\n{\n\tif(n<m)return 0;\n\treturn (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint ans=0;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\tfac[i]=(ll)fac[i-1]*i%mod;\n\tinv[1]=1;\n\tfor(int i=2;i<=n;i++)\n\tinv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=1;\n\tfor(int i=1;i<=n&&i<mod;i++)\n\tinv[i]=(ll)inv[i]*inv[i-1]%mod;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint now=C(i-1,n-i-1);\n\t\tans=(ans+(ll)now*fac[i]%mod*fac[n-i-1]%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",(fac[n]-ans)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=1000005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,fac[N],ifac[N];\n\ninline int C(int x,int y){\n\treturn x<y?0:(ll)fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d\",&n);fac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=exp(fac[n],mod-2);\n\tfor(int i=n;i;i--) ifac[i-1]=(ll)ifac[i]*i%mod;\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tint x=i,y=n-1-i;\n\t\tch(ans,(ll)C(x-1,y)*fac[x]%mod*fac[y]);\n\t}\n\tans=((ll)fac[n-1]*n-ans+mod)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string.h>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <assert.h>\n#include <cmath>\n#include <stack>\n#include <deque>\n#include <set>\n#include <unordered_map>\n#include <complex>\n#include <fstream>\n#include <map>\n#include <numeric>\n#include <functional>\nusing namespace std;\nconst int mxn = 1e6+10;\nconst int mod = 1e9+7;\nlong long fact[mxn], inv_fact[mxn];\n\nlong long powmod(long long a, long long b) {\n\tlong long ret = 1;\n\twhile(b) {\n\t\tif(b&1ll) ret*=a, ret%=mod;\n\t\ta*=a; a%=mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\n\nvoid pre() {\n\tfact[0] = inv_fact[0] = 1;\n\tfor(int i=1; i<mxn; i++) {\n\t\tfact[i] = fact[i-1]*i%mod;\n\t\tinv_fact[i] = powmod(fact[i], mod-2);\n\t}\n}\n\nlong long C(long long n, long long k) {\n\tif(n<k) return 0;\n\treturn fact[n]*inv_fact[k]%mod*inv_fact[n-k]%mod;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tpre();\n\n\tint n; cin>>n;\n\tif(n==2) {\n\t\tcout << 1<< '\\n'; return 0;\n\t}\n\n\tvector<long long> allBlack(n+1, 0);\n\n\tfor(int k=1; k<n; k++) {\n\t\tallBlack[k] = C(k-1, n-k-1)*fact[k]%mod*fact[n-k-1]%mod;\n\t}\n\n\tlong long ans = 0;\n\tfor(int k=1; k<n; k++) {\n\t\tans = ans+(allBlack[k]+mod-allBlack[k-1])*k%mod;\n\t\tans%=mod;\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n//comparator function in sorting\n//swapping arguments\n//missing cases in dp\n//dividing in modulo\n//Beware of overflow and modulo\n//Be mindful of overflow\n//s is a matrix but forget\n//length of ranges\n//working with bit using ull"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M=1E9+7;\n\nunsigned int doit(int i,int j){\n\tif (i==j) return 0;\n\tif (j-i==1) return 1;\n\tint mid=(i+j)/2;\n\tunsigned int ret=(doit(i,mid)+doit(mid+1,j))%M;\n\tlong long p=(1LL * (mid-i+1) * (j-mid))%M\n\tret = (ret + p)%M;\n\treturn ret;\n}\n\nint main(){\n\tint n,cin>>n;\n\tunsigned int s=doit(0,n-1);\n\tcout << s+1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T,typename U>bool chmin(T& a,const U& b){return a>b?(a=b,1):0;}\ntemplate<typename T,typename U>bool chmax(T& a,const U& b){return a<b?(a=b,1):0;}\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<uint M>\nstruct modint{\n\tuint val;\n\tmodint(uint x=0):val((x%M+M)%M){}\n\tmodint pow(uint r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tll x=1;\n\t\tfor(ll a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn (x+M)%M;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n\texplicit operator uint()const{return val;}\n};\n\ntemplate<uint M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<uint M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<uint M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<uint M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<uint M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<uint M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<uint M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nstruct Factorial{\n\tvector<mint> data,inv;\n\tFactorial(int size):data(size),inv(size){\n\t\tdata[0]=1;\n\t\trepi(i,1,size)\n\t\t\tdata[i]=mint(i)*data[i-1];\n\t\trep(i,size)\n\t\t\tinv[i]=data[i].inv();\n\t}\n\tmint Fact(int n){\n\t\treturn data[n];\n\t}\n\tmint Choose(int n,int r){\n\t\treturn data[n]*inv[n-r]*inv[r];\n\t}\n};\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tFactorial fact(1000000);\n\n\tfor(int n;cin>>n&&n;){\n\t\tif(n==2){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<mint> cs(n);\n\t\trepi(i,2,n){\n\t\t\tif(i-1<n-1-i)\n\t\t\t\tcontinue;\n\t\t\tcs[i]=fact.Fact(i)*fact.Fact(n-1-i)*fact.Choose(i-1,n-1-i);\n\t\t}\n\t\tmint res=0;\n\t\trepi(i,1,n) res+=mint(i)*(cs[i]-cs[i-1]);\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <math.h>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <time.h>\n#include <bitset>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n//#define X first\n//#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i, 0, t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n\nconst LD PI = acos(-1.0);\nconst LD EPS = 1e-6;\nconst int INF = 1000000007;\nconst LL LINF = 1e18;\nconst LL mod = 1000000007;\nconst LL MAX = 1000047;\n\nLL F[MAX], INV[MAX], FI[MAX], A[MAX];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint n;\n\tcin >> n;\n\tINV[1] = 1;\n\tF[0] = FI[0] = 1;\n\tFOR(i, 1, n)\n\t{\n\t\tif (i > 1)\n\t\t{\n\t\t\tINV[i] = (-(mod / i) * INV[mod % i]) % mod;\n\t\t\tif (INV[i] < 0)\n\t\t\t\tINV[i] += mod;\n\t\t}\n\t\tF[i] = (F[i - 1] * i) % mod;\n\t\tFI[i] = (FI[i - 1] * INV[i]) % mod;\n\t}\n\tLL ans = 0, s = 0;\n\tFOR(i, (n + 1) >> 1, n)\n\t{\n\t\tLL a = (((F[i] * F[i - 1]) % mod) * FI[(i << 1) - n]) % mod;\n\t\tans += i * (a - s);\n\t\tans %= mod;\n\t\ts += a - s;\n\t\ts %= mod;\n\t}\n\tif (ans < 0)\n\t\tans += mod;\n\tcout << ans << endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        if (n < k) return 0;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    Combination comb(n);\n    vector<ll> f(n + 1);\n\n    rep(k, 1, n) {\n        ll tmp = comb.nCk(k - 1, n - 1 - k);\n        tmp *= comb.fact[k];\n        tmp %= MOD;\n        tmp *= comb.fact[n - 1 - k];\n        tmp %= MOD;\n//        tmp *= k;\n//        tmp %= MOD;\n//        ans += tmp;\n//        ans %= MOD;\n        f[k] = tmp;\n    }\n    ll ans = 0ll;\n\n    rep(k,1,n){\n        ll tmp = f[k] - f[k-1];\n        ans += k * tmp;\n        ans %= MOD;\n    }\n\n\n    cout << ans << endl;\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<(int)n;i++)\n#define REP(i,n)\tfor(int i=0;i<=(int)n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<(int)n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=(int)n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\n#define fst\tfirst\n#define scn second\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrt(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a%b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nll fact[100010];\nll inv[100010];\nll dp[100010];\n\nll modpow(ll a, ll b) {\n\tll ret = 1;\n\twhile (b) {\n\t\tif (b & 1)\tret = (ret*a) % mod;\n\t\ta = (a*a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nll nCm(ll n, ll m) {\n\treturn fact[n] * ((inv[m] * inv[n - m]) % mod) % mod;\n}\n\nint main() {\n\tint n;\tcin >> n;\n\tif (n == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\telse if (n == 3) {\n\t\tcout << 4 << endl;\n\t\treturn 0;\n\t}\n\tfact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tSREP(i, 2, n) {\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t\tinv[i] = (inv[i - 1] * modpow(i, mod - 2)) % mod;\n\t}\n\tll ret = 0;\n\tsrep(i, 2, n) {\n\t\tif (i * 2 < n)\tcontinue;\n\t\tdp[i] = ((nCm(i - 1, n - i - 1)*fact[i]) % mod)*fact[n - i - 1] % mod;\n\t\t(ret += ((dp[i] - dp[i - 1] + mod) % mod)*i) %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define set0(x) memset(x,0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();ll f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\n\nint mod = 1000000007;\ninline int mul(int x,int y){return 1ll*x*y%mod;}\ninline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\ninline int sub(int x,int y){return x-y<0?x-y+mod:x-y;}\ninline int sq(int x){return 1ll*x*x%mod;}\nint mpow(int a,int b){return b == 0 ? 1 : ( b&1 ? mul(a,sq(mpow(a,b/2))) : sq(mpow(a,b/2)));}\n\nconst int N = 1000000;\nint fac[N+10],invfac[N+10],n,k;\n\nint C(int n,int m){\n\treturn mul(fac[n],mul(invfac[m],invfac[n-m]));\n}\n\nint main() {\n\tfac[0] = 1;\n\tfor(int i=1;i<=N;i++)fac[i] = mul(fac[i-1],i);\n\tinvfac[N] = mpow(fac[N],mod-2);\n\tfor(int i=N-1;i>=0;i--) invfac[i] = mul(invfac[i+1],i+1);\n\tread(n);\n\tint ans = fac[n];\n\tfor(int i=1;i<=n-1;i++){\n\t\tif(i*2<n)continue;\n\t\tint b0 = i*2-n,d0 = i-b0;\n\t\tassert(d0!=0);\n\t\tans = sub(ans,mul(C(i-1,d0-1),mul(fac[i],fac[n-1-i])));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nconst ll MAX_P=1e6+10;\nll extgcd(ll a, ll b, ll& x, ll&y){\n    ll d=a;\n    if(b!=0){\n        d=extgcd(b, a%b, y, x);\n        y-=(a/b)*x;\n    }\n    else {\n        x=1; y=0;\n    }\n    return d;\n}\n\nll mod_inverse(ll a, ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\n//n!modp\nll fact[MAX_P]; //0<=n<pについてn! modpのテーブルO(p)\n\n\n//n!=a p＾eとした時のa modpを求める。O(log_p n)\nll mod_fact(ll n, ll p, ll& e){\n    e=0;\n    if(n==0) return 1;\n    \n    //pの倍数の部分を計算\n    ll res=mod_fact(n/p,p,e);\n    e+=n/p;\n    \n    //(p-1)!≡-1なので(p-1)!^(n/p)はn/pの偶奇だけで計算できる\n    if(n/p%2!=0) return res*(p-fact[n%p])%p;\n    return res*fact[n%p]%p;\n}\n\n//nCk modpを求める。O(log_p n)\nll mod_comb(ll n, ll k, ll p){\n    if(n<0||k<0||n<k) return 0;\n    ll e1, e2, e3;\n    ll a1=mod_fact(n,p,e1), a2=mod_fact(k,p,e2), a3=mod_fact(n-k,p,e3);\n    if(e1>e2+e3) return 0;\n    return a1*mod_inverse(a2*a3%p,p)%p;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll N;\n    cin>>N;\n    fact[0]=fact[1]=1;\n    rep(i,2,MAX_P){\n        fact[i]=fact[i-1]*i;\n        fact[i]%=MOD;\n    }\n    ll res=0;\n    ll temp=0;\n    rep(i,1,N){\n        if(2*i>=N){\n            ll t=mod_comb(i-1, N-i-1, MOD)*fact[i]%MOD*fact[N-i-1]%MOD;\n            res+=(t-temp)*i%MOD;\n            res%=MOD;\n            temp=t;\n        }\n    }\n    cout <<(res+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6+5;\nconst ll p = 1e9+7;\n\nll exp(ll x, ll k) {\n\tif (k == 0)\n\t\treturn 1;\n\tif (k%2 == 1)\n\t\treturn x*exp(x, k-1)%p;\n\tll y = exp(x, k/2);\n\treturn y*y%p;\n}\n\nll inv(ll x) { return exp(x, p-2); }\n\nll fact[MAXN], invfact[MAXN], n;\n\nll binom(ll a, ll b) {\n\tif (a < b || a < 0 || b < 0)\n\t\treturn 0;\n\treturn fact[a]*invfact[b]%p*invfact[a-b]%p;\n}\n\nll s = 0;\n\nint main() {\n\tcin >> n;\n\tn--;\n\n\tfact[0] = invfact[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i) {\n\t\tfact[i] = i*fact[i-1]%p;\n\t\tinvfact[i] = inv(fact[i])%p;\n\t}\n\n\tfor (int k = 1; k <= n; ++k) {\n\t\ts += (p + 1 - binom(k-1, n-k)*inv(binom(n, k)));\n\t\ts %= p;\n\t}\n\n\ts++;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\ts = s*i%p;\n\tcout << s << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(ll i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst ll MAX = 1e6;\nconst ll MOD = 1e9+7;\n\nll N;\n\n//階乗とその逆元\nll fac[MAX+1],facInv[MAX+1];\n\nll power(ll e, ll x){ //e^x % MOD\n\tif (x == 0) return 1LL;\n\tif (x % 2 != 0) return ((power(e, x-1) * e) % MOD);\n\tll temp = power(e, x / 2);\n\treturn (temp * temp) % MOD;\n}\n\nll nck(ll n, ll k){\n\tif (!(n >= k && k >= 0)) return 0;\n\tll temp = (fac[n] * facInv[n-k]) % MOD;\n\treturn ((temp * facInv[k]) % MOD);\n}\n\nvoid fact(void){\n\t//階乗とその逆元\n\tfac[0] = facInv[0] = 1; //0! = 1\n\t//(x!)^(-1) ≡ (x!)^(p-2) (mod p)\n\tRep(1, MAX, i) fac[i] = (fac[i-1] * i) % MOD;\n\tfacInv[MAX] = power(fac[MAX], MOD-2);\n\tRep(1, MAX-1, i) facInv[MAX-i] = (facInv[MAX-i+1] * (MAX-i+1)) % MOD;\n}\n\nll calc(ll k) {\n\tll a = 2*k - N, b = N - k - 1LL;\n\treturn (nck(a+b, b)*fac[k]%MOD)*fac[N-k-1LL]%MOD;\n}\n\nvoid solve(void){\n\tcin >> N;\n\tfact();\n\tvector <ll> res(N);\n\trep(N, i) res[i] = calc(i);\n\tll ans = 0LL;\n\tRep(1, N-1, i) {\n\t\tans += i*(res[i]-res[i-1])%MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 1e6 + 10;\nLL n, ans, P = 1e9+7;\nLL f[N], fac[N], inv[N];\n\nLL lp(LL a, LL b) {\n\tLL ret = 1;\n\tfor(; b; b >>= 1, a = a * a % P)\n\t\tif(b & 1) ret = ret * a % P;\n\treturn ret;\n}\n\nint main() {\n\tLL i;\n\tscanf(\"%d\", &n); --n;\n\tif(n == 1) ans = 1;\n\telse {\n\t\tans = 0;\n\t\tfac[0] = 1;\n\t\trep(i, 1, n) fac[i] = fac[i-1] * i % P;\n\t\tinv[n] = lp(fac[n], P-2);\n\t\tdep(i, n, 1) inv[i-1] = inv[i] * i % P;\n\t\t\n\t\t\n\t\trep(i, 1, n) \n\t\tif(i-1 >= n-i) {\n\t\t\tf[i] = fac[i-1] /**inv[n-i]%P*/ *inv[i-1-n+i]%P *fac[i]%P /**fac[n-i]%P*/;\n\t\t\tans = (ans + i * (f[i] - f[i-1] + P) % P) % P;\n\t\t\t//if(f[i] < f[i-1]) printf(\"%lld %lld %lld\\n\", i-1, i-1-n+i, i);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int mod = 1000000007;\nconst int inf = 1ll << 61;\ntypedef pair<int, int> P;\ntypedef pair<int, P>PP;\nvector<P>v;\nint kj[1000006],kji[1000006];\nint rw[1000006];\n\nint modpow(int a,int x,int mod){\n\tint res=1;\n\twhile(x){\n\t\tif(x&1)res=res*a%mod;\n\t\ta=a*a%mod;\n\t\tx>>=1;\n\t\t}\n\treturn res;\n\t}\nvoid kjinit(){\n\tkj[0]=1;\n\tfor(int i=0;i<1000003;i++){\n\t\tkj[i+1]=kj[i]*(i+1)%mod;\n\t\tkji[i]=modpow(kj[i],mod-2,mod);\n\t\t}\n\t}\nint comb(int r,int c){\n\tint res=kj[r]*kji[c]%mod;\n\treturn res*kji[r-c]%mod;\n\t}\nsigned main(){\n\tint n;cin>>n;\n\tkjinit();\n\tint n2=(n-2)/2,n1=n&1;\n\twhile(n2>=0){\n//\t\tcout<<n1<<' '<<n2<<endl;\n\t\trw[n1+n2]=(kj[n-n2-n1-2]*comb(n1+n2,n1)%mod)*kj[n1+n2+1]%mod;\n\t\tn2--;n1+=2;\n\t\t}\n\t\t\n\tint cnt=0;\t\n\tfor(int i=n-2;i>0;i--){\n\t\trw[i]=(rw[i]-rw[i-1]+mod)%mod;\n\t\tcnt+=rw[i]*(i+1);\n\t\tcnt%=mod;\n\t\t}\t\n\tcnt+=rw[0];cnt%=mod;\t\n\tcout<<cnt<<endl;\t\n\t}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n\n\nusing namespace std;\ntypedef int status;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ull base = 343;\nconst int INF = int(1e9);\nconst ll INF1 = ll(1e18);\nconst int MAX = 1000002;\nconst int MOD = 1000000007;\n\nll A[MAX];\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    A[1] = A[0] = 1; for (int i = 2; i < MAX; ++i) A[i] = A[i - 1] * i % MOD;\n    int now = n - 1, p =  n - 1;\n    ll ans = 0;\n    while (1) {\n        if (now == 0) break;\n        if (now >= 2) {\n            ans += A[n - 2] * 2 * p;\n            ans %= MOD;\n            now -= 2;\n        }\n        else {\n            ans += A[n - 2] * p;\n            ans %= MOD;\n            now -= 1;\n        }\n        --p;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(ll i=0;i<n;i++)\n#define repp(j, n) for(ll j=0;j<n;j++)\n#define reppp(i, m, n) for(ll i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 1e-10;\n\nll comb(ll fact[], ll rfact[], ll n, ll r){\n    return (((fact[n] * rfact[r]) % MOD) * rfact[n-r]) % MOD;\n}\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    ll n;\n    cin >> n;\n    \n    ll fact[n+1], rfact[n+1];\n    fact[0] = fact[1] = 1LL;\n    rfact[0] = rfact[1] = 1LL;\n    reppp(i, 2, n+1){\n        fact[i] = (fact[i-1] * (ll)i) % MOD;\n        rfact[i] = 1LL;\n        ll k = MOD-2LL;\n        ll a = fact[i];\n        while(k > 0LL){\n            if(k & 1LL){\n                rfact[i] *= a;\n                rfact[i] %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            k  >>= 1;\n        }\n    }\n\n    ll ans = 0LL, p_prev = 0LL;\n    ll k = (n+1)/2;\n    reppp(i, k, n){\n        ll p = (((comb(fact, rfact, i-1, n-1-i) * fact[i]) % MOD) * fact[n-1-i]) % MOD;\n        ans = (ans + (i * (p - p_prev + MOD)) % MOD) % MOD;\n        p_prev = p;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MAX_N=1e6,MOD=1e9+7;\n\nll fact[MAX_N+1];\nll N;\nll mpw(ll n,ll m){\n\tif (!m){\n\t\treturn 1;\n\t}\n\tll ret=mpw(n,m/2);\n\tret*=ret;\n\tret%=MOD;\n\tif (m&1){\n\t\tret*=n;\n\t\tret%=MOD;\n\t}\n\treturn ret;\n}\n\nll inv(ll n){\n\treturn mpw(n,MOD-2);\n}\n\nll f(ll k){\n\tif (k<(N+1)/2){\n\t\treturn 0;\n\t}\n\treturn fact[k]*fact[N-k-1]%MOD*fact[k-1]%MOD*inv(fact[N-k-1])%MOD*inv(fact[2*k-N])%MOD;\n}\n\nint main(){\n\tcin>>N;\n\tll ans=0;\n\tfact[0]=1;\n\tFOR(i,1,N){\n\t\tfact[i]=(fact[i-1]*i)%MOD;\n\t}\n\tFOR(k,1,N){\n\t\tans+=(f(k)-f(k-1)+MOD)%MOD*k%MOD;\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<ld> vld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n#define REP(i,m,M) for(int i=m; i<M; i++)\n#define REPR(i,M,m) for(int i=M; i>m; i—-)\n#define REPLL(i,m,M) for(ll i=m; i<M; i++)\n#define REPLLR(i,M,m) for(ll i=M; i>m; i—-)\n#define ALL(v) v.begin(),v.end()\n\nll factTable[1000001];\nll factInvTable[1000001];\nll fact(int n){\n    if(factTable[n]!=0) return factTable[n];\n    else if (n>1) {\n        return factTable[n] = (n * fact(n-1))%MOD;\n    } else\n        return 1;\n}\nll pow(ll n, int k){\n    if (k==0) return 1;\n    if (k==1) return n % MOD;\n    if (k%2==0) {\n        ll tmp = pow(n, k/2);\n        return tmp*tmp%MOD;\n    } else {\n        ll tmp = pow(n, k/2);\n        return (tmp*tmp%MOD)*n%MOD;\n    }\n}\nll invFact(int n){\n    if(factInvTable[n]!=0) return factInvTable[n];\n    else return pow(fact(n), MOD-2);\n}\nll comb(int n, int m){\n    return (fact(n)*invFact(m)%MOD)*invFact(n-m)%MOD;\n}\nll num(int N, int K){\n    return (fact(K)*fact(N-K-1)%MOD)*comb(K-1, N-K-1)%MOD;\n}\n\nint main(int argc, const char * argv[]) {\n    int N;\n    cin >> N;\n    \n    ll res = 0;\n    for(int i=(N+1)/2; i<=N-1; ++i){\n        res += num(N, i);\n        res %= MOD;\n        //cout << res << endl;\n    }\n    cout << (fact(N)+MOD-res)%MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pd(x) cerr<<\"//\"<<(x)<<endl;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll mod = 1000000007;\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,g,h,i,j,k,ok,ng,l,q;\nll x[500005],y[500005],z[500005],w[500005];\nll banb[5005][5005],banw[5005][5005];\nchar s[500005],t[500005];\nbool flag,dame;\n\nll  fact[1200000];\nll rfact[1200000];\n\nll mpow(ll x, ll y, ll m) {\n    x %= m;\n    ll result = 1;\n    while (y > 0) {\n        if (y & 1) result = (result * x) % m;\n        x = (x * x) % m;\n        y >>= 1;\n    }\n    return result;\n}\nunsigned long long int minverse(unsigned long long int x, unsigned long long int m) {\n    return mpow(x, m-2, m);\n}\nvoid c3_init(ll m){\n    fact[0]  = rfact[0] = 1;\n    for(ll xxxx=1; xxxx<400000; xxxx++){\n        fact[xxxx] = (fact[xxxx-1]*xxxx)%m;\n        rfact[xxxx] = minverse(fact[xxxx],m);\n    }\n}\nll c3(ll n, ll abc, ll m){\n    return (((fact[n] * rfact[abc])%m) * rfact[n-abc])%m;\n}\n \nint main(){\n    cin >> n;\n\tc3_init(mod);\n\tfor(i=1;i<=n-1;i++){\n\t\t//length is i\n\t\tif(1 + (i - 1) * 2 < n - 1)continue;\n\t\t//pe(i);\n\t\tll one,two;\n\t\t\n\t\t\n\t\ttwo = n - 1 - i;\n\t\tone = i - 1 - two;\n\t\tans += ((((((c3(one+two,one,mod) * fact[i])%mod) * fact[n-1-i]) % mod + (mod - sum))%mod) * i)%mod ;\n\t\t//ans += ((c3(one+two,one,mod) * (fact[i] * fact[n-1-i]) % mod + mod - sum)%mod * i)%mod;\n\t\tans %= mod;\n\t\t//p(ans);\n\t\tif(ans < 0){\n\t\t\tp(\"Error!!\");\n\t\t\treturn 0;\n\t\t}\n\t\tsum += (((c3(one+two,one,mod) * fact[i])%mod) * fact[n-1-i])%mod;\n\t\t//sum += (c3(one+two,one,mod) * (fact[i] * fact[n-1-i])%mod)%mod;\n\t\tsum %= mod;\n\t\tif(sum < 0){\n\t\t\tp(\"Error!!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tp(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include<iostream>\n        using namespace std;\n        #define N 1000000007\n         \n        int main(){\n          long long int n;\n          cin >> n;\n          if(n == 2){\n        \tcout << 1 << endl;\n            return 0;\n          }\n          long long int s = 1;\n          for(int i = 2; i < n; i++){\n        \ts = (s*i)%N;\n          }\n          s = s*(n-1)%N;\n          long long int t = 1;\n          for(int i = 2; i <= n-2; i++){\n        \tt = t*i%N;\n          }\n          t=t*(n-3)%N;\n          long long int u = s-t;\n          if(u < 0){\n            u = u+N;\n          }\n          cout << u << endl;\n          return 0;\n        }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nusing ll = long long;\nconst ll MAX = 200000;\nconst ll mod = 1000000007;\nll fact[MAX],inv[MAX],fi[MAX];\nvoid fii(){\n    inv[1] = 1;\n    for(int i=2;i<=100000;i++){\n        inv[i] = mod - mod/i*inv[mod%i]%mod;\n    }\n    fact[0] = 1; fact[1] = 1; fi[0] = 1; fi[1] = 1;\n    for(int i=2;i<=100000;i++){\n        fact[i] = fact[i-1]*i%mod;\n        fi[i] = fi[i-1]*inv[i]%mod;\n    }\n}\n\nll nck(int n, int k){\n    if(k>n) return 0;\n    return fact[n]*fi[n-k]%mod*fi[k]%mod;\n}\n\nll dp[1000010],ans = 0;\nint main(){\n    int i,n;\n    cin >> n;\n    fii(); dp[0] = 0;\n    for(i=1;i<n;i++){\n        dp[i] = nck(i-1,n-1-i)*fact[i]%mod*fact[n-1-i];\n    }\n    for(i=1;i<n;i++){\n        (ans += (mod + dp[i]-dp[i-1])%mod*i) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define repr(i,b,e) for(int i = (b); i <= (e); i++)\n#define INF (1001001001)\n#define EPS (1e-15)\n\n#define pr(x) do{cerr << (#x) << \" = \" << (x) << endl;}while(0)\n#define pri(x,i) do{cerr << (#x) << \"[\" << i << \"] = \" << (x[i]) << endl;}while(0)\n#define pra(x) do{rep(__i,(x).size()) pri(x,__i);}while(0)\n#define pran(x,n) do{rep(__i,n) pri(x,__i);}while(0)\n#define pral(x) do{cerr << (#x) << \" =\";rep(__i,(x).size()) cerr<<\" \"<<(x[__i]);cerr<<endl;}while(0)\n#define prar(x,b,e) do{repr(__i,b,e) pri(x,__i);}while(0)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool CHMAX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool CHMIN(T &l,const T &r){return l>r?l=r,1:0;}\n\nll MOD = 1000000007;\n\nfunction<void(int,int)> tensi_no_3p=[&](int v,int d){\n};\n\nint in() {\n\tint a;\n\tscanf(\"%d \", &a);\n\treturn a;\n}\n\nll inv(ll a) {\n\tll ret = 1;\n\tll t = a;\n\tll n = MOD - 2;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1) ret = (ret * t) % MOD;\n\t\tt = t * t % MOD;\n\t\tn /= 2;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tassert(inv(42) * 42 % MOD == 1);\n\tll N;\n\tcin >> N;\n\tll minN = (N + 1) / 2;\n\tvector<ll> cums(N + 1);\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\trepr(i, 1, N) fact[i] = fact[i - 1] * i % MOD;\n\tcums[minN] = fact[minN - 1] * fact[minN] % MOD * inv(fact[2 * minN - N]) % MOD;\n\trepr(k, minN, N - 2) {\n\t\tcums[k + 1] = cums[k] * k % MOD * (k + 1) % MOD * inv(2 * k - N + 1) % MOD * inv(2 * k - N + 2) % MOD;\n\t}\n\t//pra(cums);\n\tll ans = 0;\n\trepr(k, 1, N - 1) {\n\t\tans += k * (cums[k] - cums[k - 1]) % MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\nint hoge() {\n\tint N;\n\tcin >> N;\n\tvint P(N - 1);\n\trep(i, N - 1) P[i] = i;\n\tll ans = 0;\n\tdo {\n\t\tvint box(N);\n\t\tint n = 0;\n\t\tint i;\n\t\tfor (i = 0; i < N - 1; i++) {\n\t\t\tif (box[P[i]] == 0) n++, box[P[i]]++;\n\t\t\tif (box[P[i] + 1] == 0) n++, box[P[i] + 1]++;\n\t\t\tif (n == N) break;\n\t\t}\n\t\tans = (ans + i + 1) % MOD;\n\t} while (next_permutation(P.begin(), P.end()));\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#define int long long\nusing namespace std;\nconst int mod=1e9+7;\nint lt[5000005],tlt[5000005],n,ans,cnt;\nint binpow(int a,int b){\n\tif(b==0) return 1;\n\tif(b==1) return a%mod;\n\tint mid=binpow(a,b/2);\n\tif(b%2==0) return mid*mid%mod;\n\telse return mid*mid%mod*a%mod;\n}\nint c(int n,int k){\n\tint tmp=lt[n];\n\ttmp*=tlt[k];\n\ttmp%=mod;\n\ttmp*=tlt[n-k];\n\ttmp%=mod;\n\tif(n>=k) return tmp;\n\telse return 0;\n}\nsigned main(){\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tlt[0]=1;\n\tfor(int i=0;i<5000004;i++){\n\t\tif(i) lt[i]=lt[i-1]*i%mod;\n\t\ttlt[i]=binpow(lt[i],mod-2);\n\t}\n\tcin>>n;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tint tmp=((c(i-1,n-i-1)%mod*lt[i]%mod*lt[n-i-1]%mod)%mod-cnt)%mod;\n\t\tans+=tmp*i;\n\t\tans%=mod;\n\t\tcnt+=tmp;\n\t\tcnt%=mod;\n\t}\n\tcout<<ans;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-4-28 22:56:15\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nconst int MAX_SIZE = 1000010;\nconst long long MOD = 1000000007;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init() {\n  inv[1] = 1;\n  for (int i=2; i<MAX_SIZE; i++) {\n    inv[i] = ((MOD - inv[MOD%i]) * (MOD/i))%MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i=1; i<MAX_SIZE; i++) {\n    fact[i] = (i * fact[i-1])%MOD;\n    factinv[i] = (inv[i] * factinv[i-1])%MOD;\n  }\n}\n\nlong long C(int n, int k) {\n  if (n >=0 && k >= 0 && n-k >= 0) {\n    return ((fact[n] * factinv[k])%MOD * factinv[n-k])%MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n) {\n  if (n == 0) {\n    return 1;\n  } else if (n%2 == 1) {\n    return (x * power(x, n-1)) % MOD;\n  } else {\n    long long half = power(x, n/2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcm(long long a, long long b) {\n  if (a < b) {\n    return gcm(b, a);\n  }\n  if (b == 0) return a;\n  return gcm(b, a%b);\n}\n\nll N;\nll Ika[200010];\n\nint main()\n{\n  init();\n  cin >> N;\n  Ika[0] = Ika[1] = 0;\n  if (N == 2)\n  {\n    cout << 1 << endl;\n    return 0;\n  }\n  for (auto A = 2; A <= N - 1; A++)\n  {\n    ll x = N - 1 - A;\n    if (x >= 0 && A >= 0)\n    {\n      Ika[A] = ((C(A - 1, N - 1 - A) * fact[x]) % MOD * fact[A]) % MOD;\n      if (N < 100)\n      {\n        cerr << \"Ika[\" << A << \"] = \" << Ika[A] << endl;\n      }\n    }\n  }\n  ll ans = 0;\n  for (ll A = 1; A <= N - 1; A++)\n  {\n    ans += (A * (Ika[A] + MOD - Ika[A - 1])) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\nll factt[1234567];\nll ff[1000000];\n\nll calc(ll a,ll b,ll p){\n  if(b==0){\n    return 1;\n  }else if(b%2==0){\n    ll d=calc(a,b/2,p);\n    return (d*d)%p;\n  }else if(b%2==1){\n    return (a*calc(a,b-1,p))%p;\n  }\n}\nll inv(ll y){\n  return calc(y, MOD-2, MOD);\n}\n\nll comb(ll a,ll b){\n  if(a<b)return 0;\n  ll ans=(factt[a]*inv(factt[b]))%MOD;\n  ans*=inv(factt[a-b])%MOD;\n  return ans%MOD;\n}\n\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  if(n==2){\n    P(1);\n    return 0;\n  }else if(n==3){\n    P(4);\n    return 0;\n  }\n  REP(i,1000000){\n    if(i==0)factt[i]=1;\n    else factt[i]=(i*factt[i-1])%MOD;\n  }\n  // REP(i,100)P(factt[i]);\n  REP(i,1000000){\n    ff[i]=(comb(i-1,n-i-1)*factt[i])%MOD;\n    ff[i]*=factt[n-i-1];\n    ff[i]%=MOD;\n  }\n  ll ans=0;\n  for(int i=(n+1)/2;i<=n-1;i++){\n    ans+=(ff[i]-ff[i-1]+MOD)*i;\n    ans%=MOD;\n  }\n  // REP(i,n)P(ff[i]);\n  P(ans%MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int LL;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            cout<<x<<\"/\"<<y<<endl;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n//////////////////////////\n\n\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\n\n#define N 2000004\nll kai[N];\nll kai2[N];\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    rep(i,1,N-1){\n        kai[i]=mod(kai[i-1]*i);\n    }\n    kai2[N-1]=po(kai[N-1],i_5);\n    for(ll i=N-2;i>=0;i--){\n        kai2[i]=mod(kai2[i+1]*(i+1));\n    }\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    if(n==0)return 1;\n    return mod(mod(kai[n]*kai2[n-k])*kai2[k]);\n}\n\nvoid debug(ll n){\n    ll a[n-1];rep(i,1,n-1)a[i-1]=i;\n    ll ans[n];memset(ans,0,sizeof(ans));\n    do{\n        bool used[n];memset(used,false,sizeof(used));\n        rep(i,1,n-1){\n            rep(j,0,n-2){\n                if(a[j]==i){\n                    used[j]=used[j+1]=true;\n                }\n            }\n            bool f=true;\n            rep(j,0,n-1)if(!used[j])f=false;\n            if(f){\n                ans[i]++;break;\n            }\n        }\n    }while(next_permutation(a,a+n-1));\n    rep(i,(n+1)/2,n-1)cout<<i<<\":\"<<ans[i]<<endl;\n}\n\nint main(){fastio\n    calc();\n    ll n;cin>>n;\n    //debug(n);\n    ll ans=0;\n    ll zen=0;\n    rep(k,(n+1)/2,n-1){\n        ll sum=comb(k-1,n-1-k);\n        sum=mod(sum*kai[k]);\n        sum=mod(sum*kai[n-1-k]);\n        Add(ans,(sum-zen)*k);\n       // cout<<k<<\":\"<<sum-zen<<endl;\n        zen=sum;\n    }\n    cout<<mod(ans)<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 1000100;\nconst int base = 1e9+7;\n\nint n;\nll fac[maxn],ifac[maxn];\n\nll pw(int a,int n) {\n    if (n==0) return 1ll;\n    if (n==1) return a;\n    ll tg = pw(a,n/2);\n    tg = (tg*tg) % base;\n    if (n%2) return (tg*a)%base;\n    return tg;\n}\n\nll C(int k,int n) {\n    if (k > n) return 0;\n    return (fac[n] * ifac[k] % base * ifac[n-k])%base;\n}\n\nint main() {\n    //freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    fac[0] = 1, ifac[0] = 1;\n    for (int i=1;i<maxn;i++) {\n        fac[i] = (fac[i-1]*1ll*i)%base;\n        ifac[i] = pw(fac[i],base-2);\n    }\n    //cout<<C(1,1)<<endl;\n    cin>>n;\n    ll res=fac[n];\n    for (int i=1;i<n;i++) {\n        res = (res - C(n-i-1,i-1) * fac[i] %base * fac[n-i-1] % base + base) % base;\n    }\n    cout<<res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Template\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <utility>\n#include <stack>\n#include <set>\n#include <algorithm>\n#include <bitset>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <complex>\n#include <regex>\n#include <numeric>\n#include <typeinfo>\n#include <type_traits>\n#include <fstream>\n#pragma comment(linker, \"/STACK:167772160\")\n\nusing namespace std;\n\n#ifdef LOCAL\n\ntemplate <typename T, typename Q>\nostream& operator<<(ostream& os, pair<T, Q> p)\n{\n\treturn (os << '(' << p.first << \", \" << p.second << ')');\n}\n\nint _iterable_indent = 0;\ntemplate<class T>\nstd::ostream& print_iterable(std::ostream& os, T beg, T end)\n{\n\tif (_iterable_indent > 0)\n\t\tos << \"\\n\";\n\tfor (int i = 0; i < _iterable_indent; ++i)\n\t\tos << \"\\t\";\n\tos << \"[\";\n\tfor (auto it = beg; it != end; ++it)\n\t{\n\t\tif (it != beg)\n\t\t\tos << \", \";\n\t\t++_iterable_indent;\n\t\tos << *it;\n\t\t--_iterable_indent;\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntemplate <class T >\nstd::ostream& operator << (std::ostream& os, const std::vector<T>& v)\n{\n\treturn print_iterable(os, v.begin(), v.end());\n}\ntemplate <class T >\nstd::ostream& operator << (std::ostream& os, const std::set<T>& v)\n{\n\treturn print_iterable(os, v.begin(), v.end());\n}\ntemplate <class T >\nstd::ostream& operator << (std::ostream& os, const std::multiset<T>& v)\n{\n\treturn print_iterable(os, v.begin(), v.end());\n}\ntemplate <class T >\nstd::ostream& operator << (std::ostream& os, const std::unordered_set<T>& v)\n{\n\treturn print_iterable(os, v.begin(), v.end());\n}\ntemplate <class T, class Q>\nstd::ostream& operator << (std::ostream& os, const std::map<T, Q>& v)\n{\n\treturn print_iterable(os, v.begin(), v.end());\n}\ntemplate <class T, class Q>\nstd::ostream& operator << (std::ostream& os, const std::unordered_map<T, Q>& v)\n{\n\treturn print_iterable(os, v.begin(), v.end());\n}\n\nvector<string> _split(const string& s, char c) {\n\tvector<string> v;\n\tstringstream ss(s);\n\tstring x;\n\tauto arr_skip = false;\n\twhile (getline(ss, x, c))\n\t{\n\t\twhile (x[0] == ' ')\n\t\t\tx = x.substr(1);\n\t\tif (arr_skip)\n\t\t{\n\t\t\tfor (auto h : x)\n\t\t\t\tif (h == ')')\n\t\t\t\t\tarr_skip = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x.size() >= 3 && x.substr(0, 3) == \"ARR\")\n\t\t{\n\t\t\tarr_skip = true;\n\t\t\tv.emplace_back(x.substr(4));\n\t\t}\n\t\telse\n\t\t\tv.emplace_back(x);\n\t}\n\treturn v;\n}\n\nvoid _print(vector<string>::iterator) {}\ntemplate<typename T, typename... Args>\nvoid _print(vector<string>::iterator it, T a, Args... args) {\n\tstring name = it->substr((*it)[0] == ' ', it->length());\n\tif (isalpha(name[0]))\n\t\tcerr << name << \" = \" << a << endl;\n\telse\n\t\tcerr << name << endl;\n\t_print(++it, args...);\n}\n\ntemplate<class T>\nauto _kekeke(T x)\n{\n\treturn x;\n}\n\ntemplate<class T>\nauto make_vector(T arr)\n{\n\treturn arr;\n}\n\ntemplate<class T, class... Args>\nauto make_vector(T arr, int len, Args... args)\n{\n\tauto inside = make_vector(arr[0], args...);\n\tvector<decltype(_kekeke(inside))> v;\n\tfor (int i = 0; i < len; ++i)\n\t\tv.push_back(make_vector(arr[i], args...));\n\treturn v;\n}\n\n#define dbg(...) { _print(_split(#__VA_ARGS__, ',').begin(), __VA_ARGS__); }\n#define ARR(arr, ...) make_vector(arr, __VA_ARGS__)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dbg(...) (void)0\n#define ARR(arr, ...) (void)0\n#define eprintf(...) (void)0\n#endif\n#define mp make_pair\n#define rand govno_ebanoe\n#define dbg_time() eprintf(\"\\n\\nTime: %.3lf\\n\", double(clock()) / CLOCKS_PER_SEC)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n\nconst int INF = (int)1e9 + 10;\nconst ll LINF = ll(2e18) + 10;\nconst double PI = acosl(-1);\nconst double eps = 1e-8;\n#pragma endregion\n\nconst int P = 1e9 + 7;\nint mul(int a, int b)\n{\n\treturn (ll)a * b % P;\n}\nint sum(int a, int b)\n{\n\ta += b;\n\treturn a >= P ? a - P : a;\n}\nint sub(int a, int b)\n{\n\treturn sum(a, P - b);\n}\nint bpow(int x, int p)\n{\n\tint res = 1;\n\tfor (; p > 0; p /= 2, x = mul(x, x))\n\t\tif (p % 2 == 1)\n\t\t\tres = mul(res, x);\n\treturn res;\n}\nint inv(int x)\n{\n\treturn bpow(x, P - 2);\n}\n\nconst int N = 1e6 + 10;\nint n;\nint fact[N];\nint rfact[N];\n\nint cnk(int n, int k)\n{\n\tif (k < 0 || k > n)\n\t\treturn 0;\n\treturn mul(fact[n], mul(rfact[k], rfact[n - k]));\n}\n\nvoid solve()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i)\n\t\tfact[i] = mul(fact[i - 1], i);\n\trfact[N - 1] = inv(fact[N - 1]);\n\tfor (int i = N - 2; i >= 0; --i)\n\t\trfact[i] = mul(rfact[i + 1], i + 1);\n\tscanf(\"%d\", &n);\n\t--n;\n\tint ans = mul(fact[n], n);\n\tfor (int cnt1 = 1; cnt1 < n; ++cnt1)\n\t{\n\t\tint cnt0 = n - cnt1;\n\t\tauto ls = mul(mul(cnk(cnt1 - 1, cnt0), fact[cnt1]), fact[cnt0]);\n\t\t//dbg(cnt1, ls);\n\t\tans = sub(ans, ls);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n#ifdef LOCAL\n#define ERR_CATCH\n//#define NOERR\n#endif\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n#ifdef NOERR\n\tfreopen(\"err.txt\", \"w\", stderr);\n#endif\n#else\n\t//freopen(\"sum.in\", \"r\", stdin);\n\t//freopen(\"sum.out\", \"w\", stdout);\n#endif\n\n#ifdef ERR_CATCH\n\ttry\n\t{\n#endif\n\n#ifdef ST\n\t\tios_base::sync_with_stdio(false);\n\t\twhile (true)\n\t\t\tsolve();\n#endif\n\n#ifdef CASES\n#define MULTITEST\n#endif\n\n#ifdef MULTITEST\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tchar endl1[5];\n\t\tfgets(endl1, 5, stdin);\n\t\tfor (int i = 0; i < t; ++i)\n\t\t{\n#ifdef CASES\n\t\t\tprintf(\"Case #%d: \", i + 1);\n#endif\n\t\t\tsolve();\n#ifdef CASES\n\t\t\teprintf(\"Passed case #%d:\\n\", i + 1);\n#endif\n\t\t}\n#else\n\t\tsolve();\n#endif\n\n#ifdef ERR_CATCH\n\t}\n\tcatch (logic_error e)\n\t{\n\t\tdbg(e.what());\n\t\tputs(\"___________________________________________________________________________\");\n\t\texit(0);\n\t}\n#endif\n\tdbg_time();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <utility>\n#include <memory.h>\n#include <algorithm>\n#include <cassert>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(c) (c).begin(), (c).end()\n#define sz(c) int((c).size())\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\n\n#define FNAME \"a\"\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr);\n#else\n#define eprintf(args...) ;\n#endif\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int& x, int y) {\n    ((x += y) >= MOD) && (x -= MOD);\n}\n\nvoid sub(int& x, int y) {\n    add(x, -y + MOD);\n}\n\nint mul(int x, int y) {\n    return x * 1ll * y % MOD;\n}\n\nint mpow(int a, int p) {\n    int res = 1;\n    for (; p > 0; p >>= 1, a = mul(a, a)) {\n        if  (p & 1) {\n            res = mul(res, a);\n        }\n    }\n    return res;\n}\n\nint inv(int x) {\n    int y = mpow(x, MOD - 2);\n    assert(mul(x, y) == 1);\n    return y;\n}\n\nint N;\n\nbool read() {\n    if  (!(cin >> N)) {\n        return 0;\n    }\n    return 1;\n}\n\nconst int MAXN = 2e6 + 10;\n\nint fact[MAXN];\nint inv_fact[MAXN];\n\nvoid precalc() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        fact[i] = mul(fact[i - 1], i);\n    }\n    forn(i, MAXN) {\n        inv_fact[i] = inv(fact[i]);\n    }\n}\n\nint binom(int n, int k) {\n    if  (n < k || n < 0 || k < 0) {\n        return 0;\n    }\n    return mul(fact[n], mul(inv_fact[n - k], inv_fact[k]));\n}\n\nint partition(int n, int k) {\n    // n = a1 + ... + a_{k}, a_i > 0\n    return binom(n - 1, k - 1);\n}\n\nint get(int k) {\n    // cnt sets # = k, all covered\n    if  (k < 2) {\n        return 0;\n    }\n    k = N - 1 - k;\n    assert(k >= 0);\n    assert(k <= N - 3);\n\n    return partition(N - 1 - k, k + 1);\n}\n\nint solve() {\n    if  (N == 2) {\n        return 1;\n    } \n\n    int all = mul(fact[N - 1], N);\n    forn(k, N) {\n        int cur = get(k);\n        cur = mul(cur, fact[k]);\n        cur = mul(cur, fact[N - 1 - k]);\n        sub(all, cur);\n    }\n\n    return all;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n#ifdef LOCAL\n    freopen(FNAME \".in\", \"r\", stdin);\n    freopen(FNAME \".out\", \"w\", stdout);\n#endif\n\n    precalc();\n\n    while (read()) {\n        int ans = solve();\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 1e6 + 10;\nLL n, ans, P = 1e9+7;\nLL f[N], fac[N], inv[N];\n\nLL lp(LL a, LL b) {\n\tLL ret = 1;\n\tfor(; b; b >>= 1, a = a * a % P)\n\t\tif(b & 1) ret = ret * a % P;\n\treturn ret;\n}\n\nint main() {\n\tLL i;\n\tscanf(\"%d\", &n); --n;\n\tif(n == 1) ans = 1;\n\telse {\n\t\tans = 0;\n\t\tfac[0] = 1;\n\t\trep(i, 1, n) fac[i] = fac[i-1] * i % P;\n\t\tinv[n] = lp(fac[n], P-2);\n\t\tdep(i, n, 1) inv[i-1] = inv[i] * i % P;\n\t\t//rep(i, 1, n) printf(\"%lld %lld\\n\", fac[i], fac[i] * inv[i] % P);\n\t\t\n\t\t\n\t\trep(i, 1, n) \n\t\tif(i-1 >= n-i) {\n\t\t\tf[i] = fac[i-1] *inv[n-i]%P *inv[i-1-n+i]%P *fac[i]%P *fac[n-i]%P;\n\t\t\tans = (ans + i * (f[i] - f[i-1]) % P) % P;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\n\n\nvector<P> v[10];\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nint l[33];\n\nint o[3000544];\nint j[41][6];\nint dx[10]={0,1,0,-1,1,1,-1,-1},dy[10]={-1,0,1,0,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z[1000100];\n\nP u[1000020];\nstack<int> s[2];\n//queue<int> q,q1,q2;\n//set<int> s;\nqueue<P> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<long long,int> p;\n//list<int> l;\n//string r1,r;\nchar r[52];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y<b.y;\n}\nlong long g(long long a)\n{\n    if(a<0) return 0;\n    return z[a];\n}\n\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b/2);\n    x*=x;\n    x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nlong long f(long long x,long long y)\n{\n    if(x<y) return 0;\n    return g(x)*p(g(y),mod-2)%mod*p(g(x-y),mod-2)%mod;\n}\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    z[0]=1;\n    for(int t=1;t<=a;t++)\n        z[t]=z[t-1]*t%mod;\n    long long n=0;\n    for(int t=2;t<a;t++)\n    {\n        y=x;\n        x=f(t-1,a-1-t)*g(t)%mod*g(a-1-t)%mod;\n        n+=(x-y)*t;\n        n%=mod;\n        //printf(\"!!%lld %lld %lld %lld\\n\",x,f(t-1,a-t-1),g(t),g(a-1-t));\n    }\n    //printf(\"%lld\",n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cmath>\n\n#define pf printf\n// #define DEBUG true\n#define DEBUG false\n#define IFD if(DEBUG)\n#define FOR(i,ii,n) for(long long i=ii; i<n; i++)\n#define FORREV(i,ii,n) for(long long i=n-1; i>=ii; i--)\n#define INF ((ll)1e15)\n\nusing namespace std;\ntypedef long long ll;\n\nll const NMAX = 1000001;\n// ll mod = 998244353;\nll mod = 1e9 + 7;\nll fact[NMAX];\nll finv[NMAX];\nll comb(ll n,ll a){\n\treturn fact[n] * finv[a] % mod * finv[n-a] % mod;\n}\nll pow(ll a,ll n){\n\tll prd = 1;\n\tll exp = a;\n\twhile(n > 0){\n\t\tif((n&1)==1){\n\t\t\tprd *= exp;\n\t\t\tprd %= mod;\n\t\t}\n\t\texp *= exp;\n\t\texp %= mod;\n\t\tn >>= 1;\n\t}\n\treturn prd;\n}\n\nll gcd(ll a,ll b){\n\tif(a<b){\n\t\tll tmp = b;\n\t\tb = a;\n\t\ta = tmp;\n\t}\n\tll r = a % b;\n\tif(r==0) return b;\n\treturn gcd(b,r);\n}\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\n\nll numk[NMAX];\nint main(){\n\tll N;\n\tcin >> N;\n\t// init\n\tfact[0] = 1;\n\tfinv[0] = 1;\n\tFOR(i,1,N+1){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tfinv[i] = pow(fact[i], mod-2);\n\t}\n\t// main\n\t// ll least = ceil(N*1.0/2)\n\tll least = N*1.0/2;\n\tFOR(k,least,N){\n\t\tnumk[k] = comb(k-1, N-1-k) % mod * fact[k] % mod * fact[N-1-k] % mod;\n\t}\n\tll sum = least * numk[least];\tFOR(i,least+1,N){\n\t\tsum += i * (numk[i] - numk[i-1]);\n\t\tsum %= mod;\n\t}\n\tpf(\"%lld\", sum);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-4-28 22:56:15\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nconst int MAX_SIZE = 2000010;\nconst long long MOD = 1000000007;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init() {\n  inv[1] = 1;\n  for (int i=2; i<MAX_SIZE; i++) {\n    inv[i] = ((MOD - inv[MOD%i]) * (MOD/i))%MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i=1; i<MAX_SIZE; i++) {\n    fact[i] = (i * fact[i-1])%MOD;\n    factinv[i] = (inv[i] * factinv[i-1])%MOD;\n  }\n}\n\nlong long C(int n, int k) {\n  if (n >=0 && k >= 0 && n-k >= 0) {\n    return ((fact[n] * factinv[k])%MOD * factinv[n-k])%MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n) {\n  if (n == 0) {\n    return 1;\n  } else if (n%2 == 1) {\n    return (x * power(x, n-1)) % MOD;\n  } else {\n    long long half = power(x, n/2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcm(long long a, long long b) {\n  if (a < b) {\n    return gcm(b, a);\n  }\n  if (b == 0) return a;\n  return gcm(b, a%b);\n}\n\nll N;\nll Ika[2000010];\n\nint main()\n{\n  init();\n  cin >> N;\n  Ika[0] = Ika[1] = 0;\n  if (N == 2)\n  {\n    cout << 1 << endl;\n    return 0;\n  }\n  for (ll A = 2; A <= N - 1; A++)\n  {\n    ll x = N - 1 - A;\n    if (x >= 0 && A >= 0)\n    {\n      Ika[A] = (((C(A - 1, N - 1 - A) * fact[x]) % MOD) * fact[A]) % MOD;\n      // cerr << \"Ika[\" << A << \"] = \" << Ika[A] << endl;\n    }\n  }\n  ll ans = 0;\n  for (ll A = 1; A <= N - 1; A++)\n  {\n    ans += (A * ((Ika[A] + MOD - Ika[A - 1]) % MOD)) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nusing ll = long long;\nconst ll MAX = 1000010;\nconst ll mod = 1000000007;\nll fact[MAX],inv[MAX],fi[MAX];\nvoid fii(){\n    inv[1] = 1;\n    for(int i=2;i<=MAX;i++){\n        inv[i] = mod - mod/i*inv[mod%i]%mod;\n    }\n    fact[0] = 1; fact[1] = 1; fi[0] = 1; fi[1] = 1;\n    for(int i=2;i<=MAX;i++){\n        fact[i] = fact[i-1]*i%mod;\n        fi[i] = fi[i-1]*inv[i]%mod;\n    }\n}\n\nll nck(int n, int k){\n    if(k>n) return 0;\n    return fact[n]*fi[n-k]%mod*fi[k]%mod;\n}\n\nll dp[1000010],ans = 0;\nint main(){\n    int i,n;\n    cin >> n;\n    fii(); dp[0] = 0;\n    for(i=1;i<n;i++){\n        dp[i] = nck(i-1,n-1-i)*fact[i]%mod*fact[n-1-i]%mod;\n        \n    }\n    for(i=1;i<n;i++){\n        (ans += (mod + dp[i]-dp[i-1])%mod*i) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong long omote[1000002];\nlong long gyaku[1000002];\nlong long inv(long long now) {\n\tlong long hoge = MAX_MOD - 2LL;\n\tlong long ans = 1;\n\twhile (hoge != 0) {\n\t\tif (hoge % 2 == 1) {\n\t\t\tans *= now;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\tnow *= now;\n\t\tnow %= MAX_MOD;\n\t\thoge /= 2;\n\t}\n\treturn ans;\n}\nlong long combination(long long a, long long b) {\n\tlong long ans = omote[a];\n\tans *= gyaku[b];\n\tans %= MAX_MOD;\n\tans *= gyaku[a - b];\n\tans %= MAX_MOD;\n\treturn ans;\n}\nlong long functions(long long k,long long n) {\n\tlong long a = 2 * k - n;\n\tlong long b = n - k - 1;\n\tlong long hoge = omote[a+b];\n\thoge *= gyaku[a];\n\thoge %= MAX_MOD;\n\thoge *= gyaku[b];\n\thoge %= MAX_MOD;\n\thoge *= omote[k];\n\thoge %= MAX_MOD;\n\thoge *= omote[b];\n\thoge %= MAX_MOD;\n\treturn hoge;\n}\nint main(){\n\tomote[0] = 1;\n\tgyaku[0] = 1;\n\tfor (long long i = 1; i < 1000002; ++i) {\n\t\tomote[i] = omote[i - 1] * i;\n\t\tomote[i] %= MAX_MOD;\n\t\tgyaku[i] = inv(omote[i]);\n\t}\n\tlong long n;\n\tcin >> n;\n\tlong long ans = 0;\n\tlong long geko = 0;\n\tfor (long long k = (n+1)/2; k < n; ++k) {\n\t\tif(k == (n+1)/2){\n\t\t\tans += k * functions(k, n);\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\telse {\n\t\t\tans += k * (functions(k, n) + (MAX_MOD - functions(k - 1, n)));\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define MOD 1000000007\nLL powmod(LL a, LL n){\n    if(n == 0) return 1;\n    if(n % 2) return (a*powmod(a,n-1)) % MOD;\n    LL c = powmod(a, n/2);\n    return (c*c) % MOD;\n}\nLL inv(LL a){\n    return powmod(a, MOD-2);\n}\nLL fact[1100000];\nLL invfact[1100000];\n \nvoid init(){\n    fact[0] = 1;\n    invfact[0] = 1;\n    for(LL i = 1; i < 1100000; i++){\n        fact[i] = (i*fact[i-1]) % MOD;\n        invfact[i] = inv(fact[i]);\n    }\n}\n \nint main(){\n\tinit();\n\tLL n;\n\tcin >> n;\n\tLL ans = (n-1) * fact[n-1];\n\tans %= MOD;\n\tLL k = n-2;\n\tfor(LL a = 1; a*2 <= k; a++){\n\t\tLL cur = fact[k-a];\n\t\tcur = (cur * fact[n-1-a]) % MOD;\n\t\tcur = (cur * invfact[k-2*a]) % MOD;\n\t\tans -= cur;\n\t\tans %= MOD;\n\t}\n\tif(ans < 0) ans += MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass CPaintingMachines {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      auto comb = combination(n);\n\n      mint ret = 0;\n      mint used = 0;\n      for(int k=n/2-1; k>=0; k--) {\n        int p = n-2-(k*2);\n        int c = k+p+1;\n        mint now = comb.get(k+p, p) * comb.fact[c] * comb.fact[n-1-c];\n        mint tmp = now;\n        debug(k, p, c, now.x);\n        now -= used;\n        ret += now * c;\n        used = tmp;\n      }\n      cout << ret.x << endl;\n\n    }\n};\n\nsigned main() {\n  CPaintingMachines solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\nusing namespace std;\ntypedef long long int lli;\nint main() {fio; // remove during scanf\n\tint a[] = {1, 4, 16, 84, 656, 8148, 167568, 5866452, 356855440};\n\tint n;\n\tcin >> n;\n\tcout << a[n - 1];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define mp make_pair\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\ntypedef priority_queue<ll> PQ;\ntypedef priority_queue<ll, VL, greater<ll>> PQG;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18 + 1;\nconst ll dx[] = {1, -1, 0, 0};\nconst ll dy[] = {0, 0, 1, -1};\n\nll N, M;\nstring s;\nvector<VL> G;\nvector<map<char, ll>> cnt;\n\nconst ll NMAX = 1e6;\nll fac[NMAX + 1], inv[NMAX + 1], finv[NMAX + 1];\n\nvoid cominit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    FOR(i, 2, NMAX + 1) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nll comb(ll n, ll k) {\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll modmul(ll a, ll b) { return ((a % MOD) * (b % MOD)) % MOD; }\n\nsigned main() {\n    cin >> N;\n    cominit();\n    ll ans = 0, pre = 0;\n    FOR(k, (N + 1) / 2, N) {\n        ll tmp = modmul(modmul(fac[k], fac[N - k - 1]), comb(k - 1, N - k - 1));\n        (ans += modmul(tmp - pre + MOD, k)) %= MOD;\n        pre = tmp;\n    }\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nll N,inf = 1e9+7;\nll fact[1000010] = {0};\nll inv[1000010] = {0};\n\nll mult(ll n, ll m){\n\tif(m==1) return n%inf;\n\telse if(m%2==0){\n\t\tll t = mult(n,m/2);\n\t\treturn (t*t)%inf;\n\t}else{\n\t\tll t = mult(n,m-1);\n\t\treturn (t*n)%inf;\n\t}\n}\n\nvoid factorial(ll N){\n\tfor(ll i=0;i<=N;i++){\n\t\tif(i==0){\n\t\t\tfact[i] = 1;\n\t\t\tinv[i] = 1;\n\t\t}\n\t\telse{\n\t\t\tfact[i] = (i*fact[i-1])%inf;\n\t\t\tinv[i] = mult(fact[i],inf-2);\n\t\t}\n\t}\n}\n\nll comb(ll n,ll k){\n\tif(k==0 || n==k) return 1;\n\telse return (((fact[n]*inv[k])%inf)*inv[n-k])%inf;\n}\n\nll hcomb(ll n,ll k){\n\tif(n==0 && k==0) return 1;\n\treturn comb(n+k-1,k);\n}\n\nll A[100010] = {0};\n\nint main(){\n\tcin >> N;\n\tfactorial(N);\n\tif(N==2) cout << 1 << endl;\n\telse if(N==3) cout << 4 << endl;\n\telse{\n\t\tll ans = 0;\n\t\tfor(ll i=1;i<=N-1;i++){\n\t\t\tll s = comb(i-1,N-1-i), t = (fact[i]*fact[N-1-i])%inf;\n\t\t\tA[i] = (s*t)%inf;\n\t\t\tll a = A[i]-A[i-1];\n\t\t\ta = (a+inf)%inf;\n\t\t\tans += i*a;\n\t\t\tans %= inf;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2000000000\n#define MOD 1000000007\n#define MAXN 200005\n#define REP(temp, init_val, end_val) for (int temp = init_val; temp <= end_val; ++temp)\n#define REPR(temp, init_val, end_val) for (int temp = init_val; temp >= end_val; --temp)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> intpair;\nint read(){\n    int f = 1, x = 0;\n    char c = getchar();\n    while (c < '0' || c > '9'){if(c == '-') f = -f; c = getchar();}\n    while (c >= '0' && c <= '9')x = x * 10 + c - '0', c = getchar();\n    return f * x; \n}\ninline int lowbit(int x){\n    return x & (-x);\n}\ninline int modadd(int x, int y){\n    return (x + y >= MOD ? x + y - MOD: x + y);\n}\ninline int sgn(int x){\n    return (x < 0 ? -1: (x > 0 ? 1: 0));\n}\ntemplate<typename T>\nT gcd(T a, T b){\n    return (!b) ? a: gcd(b, a % b);\n}\nint poww(int a, int b){\n    int res = 1;\n    while (b > 0){\n        if (b & 1) res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, b >>= 1;\n    }\n    return res;\n}\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int ddx[] = {-1, -1, -1, 0, 0, 1, 1, 1}, ddy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n/*--------------------------------------------------------------------*/\n/*--------------------------------------------------------------------*/\n\nint n;\nint fac[1000005], inv[1000005], invfac[1000005];\nint f[1000005] = {0};\nvoid init(){\n    n = read();\n    fac[0] = fac[1] = 1;\n    inv[1] = 1;\n    invfac[0] = invfac[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        fac[i] = 1ll * fac[i - 1] * i % MOD;\n        inv[i] = 1ll * (MOD - MOD / i) * inv[MOD % i] % MOD;\n        invfac[i] = 1ll * invfac[i - 1] * inv[i] % MOD;\n    }\n}\ninline int C(int nn, int mm){\n    return 1ll * fac[nn] * invfac[mm] % MOD * invfac[nn - mm] % MOD;\n}\nvoid solve(){\n    int hf = n >> 1;\n    f[hf] = 1ll * C(n - hf - 1, hf - 1) * fac[n - hf] % MOD;\n    for (int i = hf - 1; i >= 1; --i){\n        f[i] = 1ll * C(n - i - 1, i - 1) * fac[n - i] % MOD;\n        for (int j = i + 1; j <= hf; ++j)\n            f[i] = modadd(f[i], MOD - (1ll * f[j] * fac[j - i] % MOD));\n    }\n    int ans = 0;\n    for (int i = 1; i <= hf; ++i)\n        ans = modadd(ans, 1ll * (n - i) * f[i] % MOD);\n    printf(\"%d\\n\", ans);\n}\nint main(){\n    int T = 1;\n    while (T--){\n        init();\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\ntypedef double db;\nconst int N=1e6+5,mo=1e9+7;\nint fac[N],rev[N],i,cnt1,f[N],w[N],ans,n;\nint ksm(int x,int y)\n{\n    if (y<0) y=1ll*(-y)*(mo-2)%(mo-1);\n    int ret=1;\n    while (y)\n    {\n        if (y&1) ret=1ll*ret*x%mo;\n        y>>=1;\n        x=1ll*x*x%mo;\n    }\n    return ret;\n}\nint c(int m,int n)\n{\n    return 1ll*fac[m]*rev[n]%mo*rev[m-n]%mo;\n}\nvoid predo(int n)\n{\n    fac[0]=1;\n    fo(i,1,n) fac[i]=1ll*fac[i-1]*i%mo;\n    rev[n]=ksm(fac[n],mo-2);\n    fd(i,n,1) rev[i-1]=1ll*rev[i]*i%mo;\n}\nint calc(int x)\n{\n    //2*x-n+2=cnt1\n    cnt1=2*x-n+2;\n    if (cnt1>x||cnt1<0) return 0;\n    return c(x,cnt1);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    predo(n);\n    fo(i,0,n-2)\n    {\n        f[i]=1ll*c(n-2,i)*fac[i]%mo;\n        w[i]=calc(i-1);\n        f[i]=(f[i]+1ll*c(n-2,i-1)*fac[i]-1ll*w[i]*fac[i])%mo;\n        if (!i) f[i]=1;\n        ans=(ans+1ll*f[i]*fac[n-1-i])%mo;\n    }\n    if (ans<0) ans+=mo;\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e6 + 5;\nconst int MOD = 1e9 + 7;\n\nint N;\nint fact[MAXN], inv[MAXN];\n\ninline int add(int x, int y) {\n\tx += y;\n\tif (x >= MOD)\n\t\tx -= MOD;\n\telse if (x < 0)\n\t\tx += MOD;\n\treturn x;\n}\n\ninline int mul(int x, int y) {\n\treturn (long long)x * y % MOD;\n}\n\nint pot(int x, int y) {\n\tint res = 1;\n\tfor (; y; y /= 2) {\n\t\tif (y % 2)\n\t\t\tres = mul(res, x);\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint choose(int n, int k) {\n\tif (k < 0 || n < k)\n\t\treturn 0;\n\treturn mul(fact[n], mul(inv[k], inv[n - k]));\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\t\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfact[i] = mul(fact[i - 1], i);\n\t\tinv[i] = pot(fact[i], MOD - 2);\n\t}\n\t\n\tint sol = 0;\n\tfor (int k = 0; k < N - 1; k++)\n\t\tsol = add(sol, add(1, -mul(choose(k - 1, N - k - 1), pot(choose(N - 1, k), MOD - 2))));\n\t\n\tprintf(\"%d\\n\", mul(sol, fact[N - 1]));\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define gc getchar()\nusing namespace std;\ntypedef long long ll;\nconst int mod=1000000007;\nconst int N=1000009;\nint n,Ans,inv[N],jc[N],jc_inv[N];\nint read()\n{\n\tint x=1;\n\tchar ch;\n\twhile (ch=gc,ch<'0'||ch>'9') if (ch=='-') x=-1;\n\tint s=ch-'0';\n\twhile (ch=gc,ch>='0'&&ch<='9') s=s*10+ch-'0';\n\treturn s*x;\n}\nint C(int n,int m)\n{\n\tif (n<m||m<0) return 0;\n\treturn (ll)jc[n]*jc_inv[m]%mod*jc_inv[n-m]%mod;\n}\nint W(int k)\n{\n\treturn C(k,n-2-k);\n}\nint T(int x)\n{\n\tif (x==0) return jc[n-1];\n\treturn (ll)((ll)C(n-2,x)+C(n-2,x-1)-W(x-1)+mod)*jc[x]%mod*jc[n-x-1]%mod;\n}\nint main()\n{\n\tjc[0]=1;\n\tfor (int i=1;i<N;i++) jc[i]=(ll)jc[i-1]*i%mod;\n\tinv[1]=1;\n\tfor (int i=2;i<N;i++) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tjc_inv[0]=1;\n\tfor (int i=1;i<N;i++) jc_inv[i]=(ll)jc_inv[i-1]*inv[i]%mod;\n\tn=read();\n\tfor (int i=0;i<n-1;i++) Ans=(Ans+T(i))%mod;\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\nstruct Factorial{\n  vector<Mod> v;\n  Factorial( int max_n ){\n    v = vector<Mod>( max_n , 1 );\n    FOR( i , 1 , max_n ) v[i] = v[i-1] * i;\n  }\n  int size(){\n    return v.size();\n  }\n  Mod operator [] ( int id ){\n    return v.at(id);\n  }\n};\n\nstruct Factorial_inv{\n  vector<Mod> v;\n  Factorial_inv( Factorial &f ){\n    v = vector<Mod>( f.size() );\n    REP( i , f.size() ) v[i] = inv( f[i] );\n  }\n  Mod operator [] ( int id ){\n    return v.at(id);\n  }\n};\n\nstruct Combination{\n  Factorial *f;\n  Factorial_inv *finv;\n  Combination( Factorial &arg_f , Factorial_inv &arg_finv ){\n    f = &arg_f;\n    finv = &arg_finv;\n  }\n  Mod operator () ( int a , int b ){\n    return (*f)[a] * (*finv)[b] * (*finv)[a-b];\n  }\n};\n\nFactorial fact( 100010 );\nFactorial_inv finv( fact );\nCombination comb( fact , finv );\n\nint main(){\n  \n  int n = in();\n  Mod ans = 0;\n  Mod cur = 0;\n  FOR(i, (n+1)/2, n){\n    int cz = i * 2 - n;\n    // cout << i << \" \" << cz << endl;\n    Mod res = fact[i] * fact[n-1-i] * comb(i-1, cz);\n    // cout << i << \" \" << (res - cur).n << \" \" << res.n << \" \" << cur.n << endl;\n    ans += (res - cur) * i;\n    cur = res;\n  }\n\n  cout << ans.n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long \n#define MAX_N 400010\n#define MOD 1000000007\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    make();\n    ll n;\n    cin >> n;  \n    vector<ll> a(n);\n    rep(i,n){\n        if(i>=n-2){\n            a[i] = fac[n-1];\n            continue;\n        }\n        a[i] = comb(n-2-i,i)*fac[i]%mod;\n        a[i] *= fac[n-1-i]%mod;\n        a[i] = (fac[n-1]-a[i]+mod)%mod;\n    }\n    for(int i=n-1;i>=1;i--){\n        a[i] += mod-a[i-1];\n        a[i] %= mod;\n    }\n    //rep(i,n)cerr << a[i] << endl;\n    ll sm = 0;\n    rep(i,n){\n        sm += (n-i)*a[i]%mod;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\n\nll n, ans, jc[1001000], inv[1001000];\n\nll K(ll x,ll y=mod-2){\n  ll t=1;\n  for (;y;y>>=1, x=x*x%mod)\n    if (y&1) t=t*x%mod;\n  return t;\n}\n\nll C(int x,int y){\n  return x>=y? jc[x]*inv[y]%mod*inv[x-y]%mod: 0;\n}\n\nint main(){\n  cin>>n; --n;\n  jc[0]=1; for (int i=1;i<=n;++i) jc[i]=jc[i-1]*i%mod;\n  inv[n]=K(jc[n]); for (int i=n;i;--i) inv[i-1]=inv[i]*i%mod;\n  ans=jc[n]*n%mod;\n  for (int i=1;i<=(n-1)/2;++i){\n    ans-=C(n-1-i,i) *jc[i]%mod *jc[n-i]%mod;\n  }\n  ans=(ans%mod+mod)%mod;\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{\n\tconst vpll f;\n\tconst int M;\npublic:\n\tCombination(int n,int m):f(fact(n,m)),M(m){}\n\tCombination(int n):Combination(n,MD){}\n\tll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}\n\tll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}\n\tll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}\n\tll F(int n){return n<0?0:f[n].first;}\n};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tCombination C(N);\n\tll z=0;\n\tfr(i,N){\n\t\tz+=i*(\n\t\t\tC.C(i-1,N-1-i)*2%MD\n\t\t\t+C.C(i-2,N-1-i)*C.C(N-1-i,1)*2%MD\n\t\t\t+C.C(i-2,N-2-i)*C.C(N-2-i,1)%MD\n\t\t)%MD*C.F(i-1)%MD*C.F(N-1-i);\n\t\tz%=MD;\n\t}\n\tprint(N==2?:z);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = (1LL << 32);\nconst long long MOD = 1000000007;\nconst long double PI = 3.1415926;\n#define FOR(i,r,n) for(ll i = (ll)(r); i < (ll)(n); i++)\n#define RFOR(i,r,n) for(ll i=(ll)(n-1);i>=r;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define RALL(x) x.rbegin(),x.rend()\ntypedef long long int ll;\ntypedef vector<ll> vi;\ntypedef vector<pair<ll, ll> > vp;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef list<ll> lst;\ntypedef pair<ll, ll> P;\ntemplate <class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nll n, m, k, ans = 0, sum = 0, cnt = 0;\nstring s;\n//char c;\n\n#define Endl endl\n\n/*--------------------template--------------------*/\n\n#define SIZE 2000005\nll inv[SIZE], fac[SIZE];\n\n// O(log n)\nll powMOD(ll a, ll b)\n{\n    ll x = 1;\n    while (b > 0)\n    {\n        if (b & 1)\n        {\n            x = (x * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\nvoid make(){\n    inv[0] = fac[0] = 1;\n    FOR(i,1,SIZE) {\n        fac[i] = (fac[i - 1] * i) % MOD;\n        inv[i] = powMOD(fac[i], MOD - 2) % MOD;\n    }\n}\n\nll C(ll a, ll b){\n    if(a<b) return 0;\n    return fac[a] * inv[b] % MOD * inv[a - b] % MOD;\n}\n\n\nint main() {\n    cin >> n;\n    if(n==2){\n        cout << 1 << endl;\n        return 0;\n    }else if(n==3){\n        cout << 4 << endl;\n        return 0;\n    }else if(n==4){\n        cout << 16 << endl;\n        return 0;\n    }\n    make();\n    ans = fac[n];\n    FOR(i,1,n) {\n        m = C(i - 1, n - 1 - i) * fac[i] % MOD * fac[n - 1 - i] % MOD;\n        //cout << \"k = \" << i << \"  \" << m << endl;\n        ans -= m;\n        if(ans<0){\n            ans += MOD;\n        }\n    }\n    cout << ans%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst int mod=1e9+7;\nll kika[1000006];\nstruct Combinatorics {\n  using int64 = long long;\n  int64 mod;\n  int64 fact[202020];\n  int64 invfact[202020];\n  Combinatorics(int64 mod):mod(mod) {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < 202020; ++i) {\n      fact[i] = fact[i-1]*i%mod;\n      invfact[i] = minv(fact[i]);\n    }\n  }\n  int64 mpow(int64 x, int64 n) const {\n    int64 res = 1;\n    while(n > 0) {\n      if(n&1) res = res*x%mod;\n      x = x*x%mod;\n      n >>= 1;\n    }\n    return res;\n  }\n  int64 minv(int64 x) const {\n    return mpow(x, mod-2);\n  }\n  int64 mfact(int64 x) const {\n    return fact[x];\n  }\n  int64 C(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[r]%mod*invfact[n-r]%mod;\n  }\n  int64 P(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[n-r]%mod;\n  }\n};\n// ちょうどk回目で全て黒くなる通り数を求めるのは難しい\n// k回以下で黒くなっている通り数は求めやすい\n// k個になる個数=(k以下の個数-(k-1)以下の個数)テク\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N;cin>>N;\n  \n  Combinatorics COM(mod);\n  kika[N-1]=COM.mfact(N-1);\n  for(int k=N-2;k>=(N-1)/2;k--){\n    kika[k]=COM.mfact(k)*COM.mfact(N-1-k)%mod;\n    kika[k]=kika[k]*COM.C(k-1,N-k-1)%mod;\n  }\n  ll ans=0;\n  for(int k=N-1;k>=(N-1)/2;k--){\n    ans+=(kika[k]-kika[k-1]+mod)%mod*k;\n    ans%=mod;\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct Combinatorics {\n  using int64 = long long;\n  const int64 mod = 1e9+7;\n  int64 fact[1202020];\n  int64 invfact[1202020];\n  Combinatorics() {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < 1202020; ++i) {\n      fact[i] = fact[i-1]*i%mod;\n      invfact[i] = minv(fact[i]);\n    }\n  }\n  int64 mpow(int64 x, int64 n) const {\n    int64 res = 1;\n    while(n > 0) {\n      if(n&1) res = res*x%mod;\n      x = x*x%mod;\n      n >>= 1;\n    }\n    return res;\n  }\n  int64 minv(int64 x) const {\n    return mpow(x, mod-2);\n  }\n  int64 mfact(int64 x) const {\n    return fact[x];\n  }\n  int64 C(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[r]%mod*invfact[n-r]%mod;\n  }\n  int64 P(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[n-r]%mod;\n  }\n}C;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin >> n;\n\n  int ans = 0;\n  int prv = 0;\n  reps(i, 1, n) {\n    int tmp = C.C(i-1, n-1-i)*C.mfact(i)%mod*C.mfact(n-1-i)%mod;\n    ans += i*(tmp+mod-prv)%mod;\n    ans %= mod;\n    prv = tmp;\n  }\n  cout <<ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\nll factt[1234567];\nll ff[1000000];\n\nll calc(ll a,ll b,ll p){\n  if(b==0){\n    return 1;\n  }else if(b%2==0){\n    ll d=calc(a,b/2,p);\n    return (d*d)%p;\n  }else if(b%2==1){\n    return (a*calc(a,b-1,p))%p;\n  }\n}\nll inv(ll y){\n  return calc(y, MOD-2, MOD);\n}\n\nll comb(ll a,ll b){\n  ll ans=(factt[a]*inv(factt[b]))%MOD;\n  ans*=inv(factt[a-b])%MOD;\n  return ans%MOD;\n}\n\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  if(n==2){\n    P(1);\n    return 0;\n  }else if(n==3){\n    P(4);\n    return 0;\n  }\n  REP(i,1000000){\n    if(i==0)factt[i]=1;\n    else factt[i]=(i*factt[i-1])%MOD;\n  }\n  // REP(i,100)P(factt[i]);\n  REP(i,1000000){\n    ff[i]=(comb(i-1,n-i-1)*factt[i])%MOD;\n    ff[i]*=factt[n-i-1];\n    ff[i]%=MOD;\n  }\n  ll ans=0;\n  for(int i=(n+1)/2;i<=n-1;i++){\n    ans+=(ff[i]-ff[i-1])*i;\n  }\n  P(ans%MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\ntemplate <long long Mod = MOD>\nclass Factorial {\n public:\n  int n;\n  Factorial(long long n) : n(n), fac(n + 1), inv(n + 1) {\n    fac[0] = 1;\n    for (int i = 0; i < n; ++i) fac[i + 1] = fac[i] * (i + 1) % Mod;\n    inv[n] = modpow(fac[n], Mod - 2);\n    for (int i = n - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % Mod;\n  };\n  long long modpow(long long a, long long n, long long mod = Mod) {\n    long long i = 1, ret = 1, p = a;\n    while (i <= n) {\n      if (i & n) {\n        ret = (ret * p) % mod;\n      }\n      i = (i << 1);\n      p = (p * p) % mod;\n    }\n    return ret;\n  }\n  long long comb(int a, int b) {\n    return (fac[a] * inv[b] % Mod) * inv[a - b] % Mod;\n  }\n  long long get(int x) { return fac[x]; }\n  long long getInv(int x) { return inv[x]; }\n\n private:\n  vector<long long> fac, inv;\n};\n\nclass Solver {\n public:\n  int n;\n  Solver(LL n) : n(n){};\n\n  void solve() {\n    Modint<> ans(0);\n    Factorial<> fac(n);\n    vector<Modint<>> count(n);\n    for (int i = (n + 1) / 2; i < n; ++i) {\n      // i台以下でのマシンで全てのマスを塗る順列の数\n      // = 各要素が{1,2}で長さ(i-1)の数列で，総和が(n-2)となるものの数 *\n      // i!(i台の起動順) * (n-i)!(残りの起動順)\n      // = (i-1)C(n-i-1)*i!*(n-i)!\n      count[i] = Modint<>(fac.comb(i - 1, n - i - 1)) * fac.get(i) *\n                 fac.get(n - 1 - i);\n      ans += (count[i] - count[i - 1]) * i;\n    }\n    cout << ans << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << fixed << setprecsion(12);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\n#define per(i, a, b) for (int i = (a); i >= (b); --i)\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\n\ntemplate<typename T>\nvoid read(T& n){\n\tchar ch; int sign = 1;\n\twhile (!isdigit(ch = getchar())) if (ch == '-') sign = -1;\n\tn = ch - '0';\n\twhile (isdigit(ch = getchar())) n = n * 10 + ch - '0';\n\tn *= sign;\n}\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9 + 7;\nconst int MOD = INF;\nconst int N = 1222222;\nint n;\nll fac[N], inv[N];\n\nll C(ll n, ll m){return fac[n] * inv[m] % MOD * inv[n-m] % MOD;}\n\nint main(){\n\tread(n);\n\tfac[0] = inv[0] = inv[1] = 1; \n\trep(i, 1, N - 1) fac[i] = fac[i-1] * i % MOD;\n\trep(i, 2, N - 1) inv[i] = (MOD - MOD / i * inv[MOD%i] % MOD) % MOD;\n\trep(i, 2, N - 1) inv[i] = inv[i-1] * inv[i] % MOD;\n\tll ans = 0;\n\trep(i, n / 2, n - 1){\n\t\tll t = C(i - 1, n - 1 - i) * fac[i] % MOD * fac[n-1-i] % MOD;\n\t\t(ans += t) %= MOD;\n\t}\n\tcout << (fac[n-1] * n % MOD - ans + MOD) % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\nll factt[1234567];\nll ff[1000000];\n\nll calc(ll a,ll b,ll p){\n  if(b==0){\n    return 1;\n  }else if(b%2==0){\n    ll d=calc(a,b/2,p);\n    return (d*d)%p;\n  }else if(b%2==1){\n    return (a*calc(a,b-1,p))%p;\n  }\n}\nll inv(ll y){\n  return calc(y, MOD-2, MOD);\n}\n\nll comb(ll a,ll b){\n  ll ans=(factt[a]*inv(factt[b]))%MOD;\n  ans*=inv(factt[a-b])%MOD;\n  return ans%MOD;\n}\n\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  REP(i,1000000){\n    if(i==0)factt[i]=1;\n    else factt[i]=(i*factt[i-1])%MOD;\n  }\n  REP(i,100)P(factt[i]);\n  REP(i,1000000){\n    ff[i]=(comb(i-1,n-i-1)*factt[i])%MOD;\n    ff[i]*=factt[n-i-1];\n    ff[i]%=MOD;\n  }\n  ll ans=0;\n  for(int i=(n+1)/2;i<=n-1;i++){\n    ans+=(ff[i]-ff[i-1])*i;\n  }\n  P(ans%MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll mod = 1e9 + 7;\nll fact[1000005];\nll suffix[1000005];\nll cnt[1000005];\nll binpow(ll a, ll b){\n\tif (b == 0) return 1;\n\tll x = binpow(a, b / 2);\n\tx *= x; x %= mod;\n\tif (b % 2) return (x * a) % mod;\n\telse return x;\n}\nll bindiv(ll a, ll b){\n\tll inv = binpow(b, mod - 2);\n\treturn (a * inv) % mod;\n}\nint main(){\n\tfact[0] = 1;\n\tfor (ll i = 1; i < 1000005; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tll n; cin >> n;\n\tll ans = 0;\n\tfor (ll k = 0; k <= (n - 2) / 2; k++){\n\t\tll u = fact[n - k - 1] * fact[n - k - 2]; u %= mod;\n\t\tll d = fact[n - (2 * k) - 2]; suffix[k] = bindiv(u, d);\n\t}\n\tfor (ll k = (n - 2) / 2; k >= 1; k--) cnt[k] = (suffix[k] - suffix[k + 1] + mod) % mod;\n\tfor (ll k = 1; k <= (n - 2) / 2; k++) (ans += (cnt[k] * k)) %= mod;\n\tans = ((n - 1) * fact[n - 1] - ans) % mod; \n\tans += mod; ans %= mod; cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint fac[2000009], inv[2000009];\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=0; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nint dp[109][109][2];\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N), N --;\nPrec (N + 1);\n/*dp[1][1][1] = 1;\nfor (int i=1; i<N; i++)\n    for (int j=1; j<=i; j++)\n        for (int t=0; t<2; t++)\n            for (int t2=0; t2<2; t2++)\n                if (t2 | t)\n                    adto (dp[i + 1][j + t2][t2], dp[i][j][t]);*/\n/*for (int i=1; i<=25; i++, printf (\"\\n\"))\n    for (int j=0; j<=i; j++)\n        printf (\"%8d \", comb (i, j));*/\nint ans = fac[N];\nfor (int j=1; j<=N; j++)\n{\n    int currVal = 0;\n    if (j - 1 >= N - j)\n        currVal = comb (j - 1, N - j);\n    //printf (\"(%d, %d) \", dp[N][j][1], currVal);\n    int curr = subtract (comb (N, j), currVal);\n    curr = mul (curr, fac[j]);\n    adto (ans, mul (curr, fac[N - j]));\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef INPUT\n#include <sstream>\nstringstream input(R\"(\n2\n80 70\n)\");\n#define cin input\n#endif\n\n#include <iostream>\n#include <string>\n#include <array>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\n#define FOR(i, a, b) for(decltype(b) i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\n\nusing namespace std;\n\nll inv_mod( ll a, ll m )\n{\n  ll b, x, u, q, abs_m, tmp; \n\n  abs_m = ( m < 0 ) ? -m : m;\n  b = m; x = 1; u = 0; \n  while ( b > 0 ) {\n    q = a / b; \n    tmp = u; u = x - q * u; x = tmp;\n    tmp = b; b = a - q * b; a = tmp;\n  }\n\n  return ( x < 0 ) ? abs_m + x : x;\n}\n\nint main()\n{\n    const ll mod = 1000000007;\n\tll n;\n\tcin >> n;\n    --n;\n\n    vector<ll> frac(n + 1);\n    frac[0] = 1;\n    REP(i, n)\n        frac[i + 1] = frac[i] * (i + 1) % mod;\n\n    vector<ll> fraci(n + 1);\n    fraci[n] = inv_mod(frac[n], mod) % mod;\n    for (ll i = n; i > 0; --i)\n        fraci[i - 1] = fraci[i] * i % mod;\n\n    ll r = 0;\n    ll c = 0;\n\n    for (ll i = (n - 1) / 2; i >= 0; --i)\n    {\n        ll x = frac[n - i - 1] % mod * fraci[n - 1 - i * 2] % mod * fraci[i] % mod * frac[i] % mod * frac[n - i] % mod;\n        r += ((x + mod - c) % mod * (n - i) % mod) % mod;\n        r %= mod;\n        c += x;\n        c %= mod;\n    }\n\n\tcout << r << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int mod = 1e9+7, maxn = 1e6+5;\n\nint fac[maxn], revfac[maxn];\nint n;\ninline int fastpow(int a, int p){\n\tint ans = 1;\n\twhile(p){\n\t\tif(p&1) ans = (ans*a)%mod;\n\t\tp >>= 1;\n\t\ta = (a*a)%mod;\n\t}\n\treturn ans;\n}\ninline int rev(int a){return fastpow(a, mod-2);}\nvoid init(){\n\trevfac[0]=fac[0] = 1; \n\tfor(int i = 1; i <= n; i++){\n\t\tfac[i] = fac[i-1]*i%mod;\n\t\trevfac[i] = rev(fac[i]);\n//\t\tcout<<fac[i]<<' '<<revfac[i]<<endl;\n\t}\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*revfac[m]%mod*revfac[n-m]%mod;\n}\n\nvoid work(){\n\tint ans = 0, comb = 0, prev = 0;\n\tfor(int k = (n+1)/2; k < n; k++){\n\t\tprev = comb;\n\t\tcomb = C(k - 1, n - k - 1)%mod*fac[k]%mod*fac[n-k-1]%mod;\n\t\tans += (comb - prev+ mod)%mod *k%mod;\n\t\tans %= mod;\n//\t\tcout<<comb<<endl;\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tcin>>n;\n\tinit();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<lint>;\nconst lint MOD = 1e9 + 7;\ninline lint emod(lint x, lint p = MOD) {\n  return (x % p + p) % p;\n}\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  lint n; cin >> n;\n  lint m = n - 2;\n  VL inv(n + 1, 1);\n  for (int i = 2; i <= n; i++) {\n    inv[i] = MOD - MOD / i * inv[MOD % i] % MOD;\n  }\n  VL fac(n + 1, 1);\n  for (int i = 2; i <= n; i++) {\n    fac[i] = fac[i - 1] * i % MOD;\n  }\n  VL ifac(n + 1, 1);\n  for (int i = 2; i <= n; i++) {\n    ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  }\n  lint k = (n + 1) / 2;\n  lint res = fac[k] * fac[k - 1] % MOD * ifac[2 * k - n] % MOD * k % MOD;\n  while (k < n) {\n    k++;\n    lint b = fac[k] * fac[k - 1] % MOD * ifac[2 * k - n] % MOD;\n    lint a = fac[k - 1] * fac[k - 2] % MOD * ifac[2 * (k - 1) - n] % MOD;\n    res = (res + (b - a) * k % MOD ) % MOD;\n  }\n  cout << emod(res) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define MOD 1000000007\nLL powmod(LL a, LL n){\n    if(n == 0) return 1;\n    if(n % 2) return (a*powmod(a,n-1)) % MOD;\n    LL c = powmod(a, n/2);\n    return (c*c) % MOD;\n}\nLL inv(LL a){\n    return powmod(a, MOD-2);\n}\nLL fact[1100000];\nLL invfact[1100000];\n \nvoid init(){\n    fact[0] = 1;\n    invfact[0] = 1;\n    for(LL i = 1; i < 1100000; i++){\n        fact[i] = (i*fact[i-1]) % MOD;\n        invfact[i] = inv(fact[i]);\n    }\n}\n \nint main(){\n\tinit();\n\tLL n;\n\tcin >> n;\n\tLL ans = (n-1) * fact[n-1];\n\tans %= MOD;\n\tLL k = n-2;\n\tfor(LL a = 1; a*2 <= k; a++){\n\t\tLL cur = fact[k-a];\n\t\tcur = (cur * fact[n-1-a]) % MOD;\n\t\tcur = (cur * invfact[k-2*a]) % MOD;\n\t\tans -= cur;\n\t\tans %= MOD;\n\t}\n\tif(ans < 0) ans += MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nconst int MOD = ten(9) + 7;\n\nconst int N = ten(6) + 10;\nll inverse[N];\nvoid init_inverse() {\n\t/*\n\tM%i = M - (M/i) * i\n\t(M%i)*i^-1 = M*i^-1 - M/i (mod M)\n\t(M%i)*i^-1 = M-M/i(mod M)\n\ti^-1 = (M-M/i) * (M%i)^-1\n\t*/\n\tinverse[1] = 1;\n\tfor (int i = 2; i < N; i++) inverse[i] = (MOD - MOD / i) * inverse[MOD%i] % MOD;\n}\n\n\nll fact[N], infact[N];\nvoid init_fast_fact() {\n\tinit_inverse();\n\tfact[0] = fact[1] = 1;\n\tfor (int i = 2; i < N; i++) fact[i] = fact[i - 1] * i % MOD;\n\tinfact[0] = infact[1] = 1;\n\tfor (int i = 2; i < N; i++) infact[i] = infact[i - 1] * inverse[i] % MOD;\n}\n\nll fast_nCk(int n, int k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (k > n) return 0;\n\tll ret = fact[n] * infact[k] % MOD * infact[n - k] % MOD;\n\treturn ret;\n}\n\nll memo[2][ten(6) + 1];\n\n\nll f(int n) {\n\tll ans = 0;\n\n\tfor (int k = 1; n - 2 * k + 1 >= 0; k++) {\n\t\tconst ll base = fact[n - k + 1] * fact[k - 1] % MOD;\n\t\tconst int rem = n - 2 * k + 1;\n\t\tll add = 0;\n\t\tll cc = 0;\n\t\tfor (int m = 0; m <= k; m++) {\n\t\t\tif (rem < m) break;\n\n\t\t\tll a = (k + m);\n\t\t\tll cnt = 0;\n\t\t\tif (m == 0) {\n\t\t\t\tif (rem == 0) cnt = 1;\n\t\t\t} else {\n\t\t\t\tcnt = fast_nCk(k, m) * fast_nCk(rem + m - 1, m - 1) % MOD;\n\t\t\t}\n\n\t\t\tcc += cnt;\n\n\t\t\t(add += a * cnt) %= MOD;\n\t\t}\n\n\t\t(ans += base * add) %= MOD;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tinit_fast_fact();\n\n\tint n; reader(n);\n\tif (n < 10000) {\n\t\tcout << f(n) << endl;\n\t} \n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nconst ll MAX_P=1e6+10;\nll extgcd(ll a, ll b, ll& x, ll&y){\n    ll d=a;\n    if(b!=0){\n        d=extgcd(b, a%b, y, x);\n        y-=(a/b)*x;\n    }\n    else {\n        x=1; y=0;\n    }\n    return d;\n}\n\nll mod_inverse(ll a, ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\n//n!modp\nll fact[MAX_P]; //0<=n<pについてn! modpのテーブルO(p)\n\n\n//n!=a p＾eとした時のa modpを求める。O(log_p n)\nll mod_fact(ll n, ll p, ll& e){\n    e=0;\n    if(n==0) return 1;\n    \n    //pの倍数の部分を計算\n    ll res=mod_fact(n/p,p,e);\n    e+=n/p;\n    \n    //(p-1)!≡-1なので(p-1)!^(n/p)はn/pの偶奇だけで計算できる\n    if(n/p%2!=0) return res*(p-fact[n%p])%p;\n    return res*fact[n%p]%p;\n}\n\n//nCk modpを求める。O(log_p n)\nll mod_comb(ll n, ll k, ll p){\n    if(n<0||k<0||n<k) return 0;\n    ll e1, e2, e3;\n    ll a1=mod_fact(n,p,e1), a2=mod_fact(k,p,e2), a3=mod_fact(n-k,p,e3);\n    if(e1>e2+e3) return 0;\n    return a1*mod_inverse(a2*a3%p,p)%p;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll N;\n    cin>>N;\n    fact[0]=fact[1]=1;\n    rep(i,2,MAX_P){\n        fact[i]=fact[i-1]*i;\n        fact[i]%=MOD;\n    }\n    ll res=0;\n    ll temp=0;\n    rep(i,1,N){\n        if(2*i>=N){\n            ll t=mod_comb(i-1, N-i-1, MOD)*fact[i]%MOD*fact[N-i-1]%MOD;\n            res+=(t-temp)*i%MOD;\n            res%=MOD;\n            temp=t;\n        }\n    }\n    cout <<res<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 1000000007;\nconst int MAXN = 1000010, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll F[MAXN], I[MAXN];\nll A[MAXN];\n\nll powmod(ll a, ll b){\n\tll res=1;\n\tfor (; b; b>>=1, a=a*a%mod) if (b&1) res=res*a%mod;\n\treturn res;\n}\n\nll C(ll n, ll r){\n\tif (r<0 || r>n) return 0;\n\treturn F[n]*I[r]%mod*I[n-r]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tF[0]=1;\n\tfor (int i=1; i<MAXN; i++) F[i]=F[i-1]*i%mod;\n\tI[MAXN-1]=powmod(F[MAXN-1], mod-2);\n\tfor (int i=MAXN-1; i; i--) I[i-1]=I[i]*i%mod;\n\t\n\tcin>>n;\n\tfor (int i=1; i<n; i++){\n\t\tA[i]=C(i-1, n-i-1)*F[i]%mod;\n\t\tA[i]=A[i]*F[n-1-i]%mod;\n\t}\n\tfor (int i=1; i<n; i++) ans=(ans + i*(A[i]-A[i-1]))%mod;\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifndef LOCAL\n#define endl '\\n'\n#endif\n\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define rf(i, a, b) for(int i = a; i >= b; i--)\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define sz(x) (int)x.size()\n#define lb lower_bound\n#define ub upper_bound\n\ntypedef long long ll;\ntypedef long double f80;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint pct(int x) { return __builtin_popcount(x); }\nint pct(ll x) { return __builtin_popcountll(x); }\nint bt(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\nint bt(ll x) { return 63 - __builtin_clzll(x); } // floor(log2(x))\nint cdiv(int a, int b) { return a / b + !(a < 0 || a % b == 0); }\nll cdiv(ll a, ll b) { return a / b + !(a < 0 || a % b == 0); }\nint nxt_C(int x) { int c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\nll nxt_C(ll x) { ll c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\n\nvector<int> get_bits(int mask) {\n\tvector<int> bb;\n\twhile(mask) { int b = bt(mask); bb.pb(b); mask ^= (1 << b); }\n\treverse(all(bb));\n\treturn bb;\n}\n\nint get_mask(vector<int> v) {\n\tint mask = 0;\n\tfor(int x : v) { mask ^= (1 << x); }\n\treturn mask;\n}\n\ntemplate<typename T>\nvoid uniq(vector<T> &v) { sort(all(v)); v.resize(unique(all(v)) - v.begin()); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll rand(ll l, ll r){\n\tuniform_int_distribution<ll> uid(l, r);\n\treturn uid(rng);\n}\n\nvoid sc() {}\n\ntemplate <typename Head, typename... Tail>\nvoid sc(Head &H, Tail &... T) { cin >> H; sc(T...); }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[L:\" << __LINE__ << \"][\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// #ifndef LOCAL\n// string to_string(__int128 x) {\n// \tstring s = \"\";\n// \tbool neg = 0;\n// \tif(x < 0) { s += \"-\"; neg = 1; x = -x; }\n// \tif(!x) s += '0';\n// \twhile(x) {\n// \t\tint rem = x % 10;\n// \t\ts += to_string(rem);\n// \t\tx /= 10;\n// \t}\n// \treverse(s.begin() + neg, s.end());\n// \treturn s;\n// }\n// #endif\n\nconst int mod = 1e9 + 7; // 998244353;\n\nint pwr(int a,ll b) {\n\tint ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = (ans * 1LL * a) % mod;\n\t\ta = (a * 1LL * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\n/*\n\tLookout for overflows!!\n\tCheck array sizes!!\n\tClear before test cases!!\n\tUse the correct modulo!!\n\tCheck for corner cases!!\n\tAre you forgetting something?!\n\tRead problem statement carefully!!!\n*/\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\n*/\n\nconstexpr int md = 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint pwr(Mint a, ll k) {\n\tMint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = ans * a;\n\t\ta = a * a;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int N = 1e6 + 5;\nMint fact[N], ifact[N];\n\nMint get_c(int n,int k) {\n    if(n < k || k < 0) return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n}\n\nvoid solve() {\n    fact[0] = 1;\n    fr(i, 1, N - 1)\n        fact[i] = i * fact[i - 1];\n    ifact[N - 1] = 1 / fact[N - 1];\n    rf(i, N - 2, 0) {\n        ifact[i] = ifact[i + 1] * (i + 1);\n    }\n    int n;\n    sc(n);\n    if(n == 2) {\n        cout << 1 << endl;\n        return;\n    }\n    Mint ans = 0;\n    fr(c, 1, n) {\n        ans += c * (get_c(n - 1 - c, c - 1) + get_c(n - 2 - c, c - 1)) * fact[c - 1] * fact[n - 1 - c] * (n - c);\n    }\n    cout << ans;\n}\n\nsigned main() {\n\tios :: sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t = 1;\n\t// cin >> t;\n\tfor(int tt = 1; tt <= t; tt++) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define ff first\n#define ss second\n#define finput ifstream cin;cin.open(\"in.txt\")\n#define foutput ofstream cout;cout.open(\"out.txt\")  \n#define fast ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define mod 1000000007\n\nll gcd(ll x, ll y){ \n\tif(x<y) \n\t\tswap(x,y); \n\tif(x%y==0)\n\t\treturn y;\n\treturn gcd(y, x%y);\n}\n\nll pwm(ll a, ll n){\n\tll ans = 1;\n\twhile(n>0){\n\t\tif(n%2==1){\n\t\t\tans = (ans * a)%mod;\n\t\t}\n\t\ta = (a*a)%mod;\n\t\tn /= 2;\n\t}\n\treturn ans%mod;\n}\n\nconst int pwn = 100010;\nll pw[pwn];\nvoid pwtwo(){\n\tpw[0] = 1;\n\tfor(int i=1; i<pwn; i++){\n\t\tpw[i] = (pw[i-1]*2)%mod;\n\t}\n}\n\n\nll gcdExtended(ll a, ll b, ll *x, ll *y); \n  \nll modInverse(ll a, ll m) \n{ \t\n\tif(a==1)\n\t\treturn 1;\n\t//cout<<\"mi \"<<a<<\" \"<<m<<\" \";\n    ll x, y; \n    ll g = gcdExtended(a, m, &x, &y); \n    if (g != 1){\n        //cout << \"Inverse doesn't exist\"<<endl; \n        return -1;\n    }\n    else\n    { \n        // m is added to handle negative x \n        ll res = (x%m + m) % m; \n        //cout<<res<<endl;\n        return res;\n        // cout << \"modular multiplicative inverse is \" << res; \n    } \n} \n  \nll gcdExtended(ll a, ll b, ll *x, ll *y) \n{ \n    if (a == 0) \n    { \n        *x = 0, *y = 1; \n        return b; \n    } \n  \n    ll x1, y1;\n    ll gcd = gcdExtended(b%a, a, &x1, &y1); \n  \n    *x = y1 - (b/a) * x1; \n    *y = x1; \n  \n    return gcd; \n} \n\nll fact[1000010];\nll init(){\n\tfact[0] = 1;\n\tfor(int i=1; i<1000010; i++)\n\t\tfact[i] = (fact[i-1]*i)%mod;\n}\n\nll ncr(ll n, ll r){\n\tll ans = fact[n];\n\t// cout<<ans<<\" \";\n\tif(r>n)\n\t\treturn 0;\n\t//if(r!=0)\n\tans = (ans*modInverse(fact[r], mod))%mod;\n\t// if(n-r!=0)\n\tans = (ans*modInverse(fact[n-r], mod))%mod;\n\n\treturn ans;\n}\n\nint main(){\n\t// finput;\n\t// foutput;\n\tfast;\n\n\tll n, k, i, j, x, m, r;\n\tll ans = 0ll;\n\t// string s;\n\tcin>>n;\n\tinit();\n\tvector<int> vec;\n\t\n\ti=(n+1)/2;\n\n\tll pre = 0;\n\twhile(i<=n-1){\n\t\tr = n-1-i;\n\t\t// cout<<i<<\" \"<<n-2ll-r<< \" \"<<r<<\" \";\n\t\tx = ((ncr(n-2ll-r, r)%mod)*((fact[r]*fact[i])%mod))%mod;\n\t\t// cout<<x<<endl;\n\t\tx -= pre;\n\n\t\tpre += x;\n\t\tpre %= mod;\n\n\t\t// cout<<x;\n\t\tans += (i*x)%mod;\n\t\tans %= mod;\n\n\t\ti++;\n\t}\n\tcout<<ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\nint n;\nll fact[1000001],invfact[1000001],ans,k,suma;\nll inv(ll a)\n{\n    ll b=mod-2;\n    ll rez=1;\n    while(b)\n    {\n        if(b%2)\n            rez=(rez*a)%mod;\n        a=(a*a)%mod;\n        b/=2;\n    }\n    return rez;\n}\nll combi(ll a, ll b)\n{\n    ll rez=fact[a];\n    rez=(rez*invfact[b])%mod;\n    rez=(rez*invfact[a-b])%mod;\n    return rez;\n}\nint main()\n{\n    cin>>n;\n    fact[0]=1;\n    invfact[0]=inv(1);\n    for(int i=1;i<=n;i++)\n    {\n        fact[i]=(fact[i-1]*i)%mod;\n        invfact[i]=inv(fact[i]);\n    }\n    //suma=fact[n-1];\n    for(k=n/2;k<n;k++)\n    {\n        ll x=combi(k-1,n-k-1);\n        x=(x*fact[k])%mod;\n        x=(x*fact[n-k-1])%mod;\n        x=x-suma;\n        if(x<0)\n            x+=mod;\n        suma=(suma+x)%mod;\n        x=(x*k)%mod;\n        ans=(ans+x)%mod;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nconst int MOD = ten(9) + 7;\n\nconst int N = ten(6) + 10;\nll inverse[N];\nvoid init_inverse() {\n\t/*\n\tM%i = M - (M/i) * i\n\t(M%i)*i^-1 = M*i^-1 - M/i (mod M)\n\t(M%i)*i^-1 = M-M/i(mod M)\n\ti^-1 = (M-M/i) * (M%i)^-1\n\t*/\n\tinverse[1] = 1;\n\tfor (int i = 2; i < N; i++) inverse[i] = (MOD - MOD / i) * inverse[MOD%i] % MOD;\n}\n\n\nll fact[N], infact[N];\nvoid init_fast_fact() {\n\tinit_inverse();\n\tfact[0] = fact[1] = 1;\n\tfor (int i = 2; i < N; i++) fact[i] = fact[i - 1] * i % MOD;\n\tinfact[0] = infact[1] = 1;\n\tfor (int i = 2; i < N; i++) infact[i] = infact[i - 1] * inverse[i] % MOD;\n}\n\nll fast_nCk(int n, int k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (k > n) return 0;\n\tll ret = fact[n] * infact[k] % MOD * infact[n - k] % MOD;\n\treturn ret;\n}\n\nll memo[2][ten(6) + 1];\n\n\nll f(int n) {\n\tll ans = 0;\n\n\tfor (int k = 1; n - 2 * k + 1 >= 0; k++) {\n\t\tconst ll base = fact[n - k + 1] * fact[k - 1] % MOD;\n\t\tconst int rem = n - 2 * k + 1;\n\t\tll add = 0;\n\t\tll cc = 0;\n\t\tfor (int m = 0; m <= k; m++) {\n\t\t\tif (rem < m) break;\n\n\t\t\tll a = (k + m);\n\t\t\tll cnt = 0;\n\t\t\tif (m == 0) {\n\t\t\t\tif (rem == 0) cnt = 1;\n\t\t\t} else {\n\t\t\t\tcnt = fast_nCk(k, m) * fast_nCk(rem + m - 1, m - 1) % MOD;\n\t\t\t}\n\n\t\t\tcc += cnt;\n\n\t\t\t(add += a * cnt) %= MOD;\n\t\t}\n\n\t\t(ans += base * add) %= MOD;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tinit_fast_fact();\n\n\tint n; reader(n);\n\tif (n < 10000) {\n\t\tcout << f(n - 1) << endl;\n\t} \n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000+7;\nconstexpr long long INF = std::numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, q, last, cnt, ans, sum;\nstring str, ss;\nbool f;\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ -1,0 } ,{ 0,-1 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[10000];\nset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nstruct Combination {\n\tint mod;\n\tvector< int64_t > mfact, rfact;\n\n\tCombination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod) {\n\t\tmfact[0] = 1;\n\t\tfor (int i = 1; i < mfact.size(); i++) {\n\t\t\tmfact[i] = mfact[i - 1] * i % mod;\n\t\t}\n\t\trfact[sz] = inv(mfact[sz]);\n\t\tfor (int i = sz - 1; i >= 0; i--) {\n\t\t\trfact[i] = rfact[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\n\tint64_t fact(int k) const {\n\t\treturn (mfact[k]);\n\t}\n\n\tint64_t pow(int64_t x, int64_t n) const {\n\t\tint64_t ret = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) (ret *= x) %= mod;\n\t\t\t(x *= x) %= mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn (ret);\n\t}\n\n\tint64_t inv(int64_t x) const {\n\t\treturn (pow(x, mod - 2));\n\t}\n\n\tint64_t P(int n, int r) const {\n\t\tif (r < 0 || n < r) return (0);\n\t\treturn (mfact[n] * rfact[n - r] % mod);\n\t}\n\n\tint64_t C(int p, int q) const {\n\t\tif (q < 0 || p < q) return (0);\n\t\treturn (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n\t}\n\n\tint64_t H(int n, int r) const {\n\t\tif (n < 0 || r < 0) return (0);\n\t\treturn (r == 0 ? 1 : C(n + r - 1, r));\n\t}\n};\nint main() {\n\tcin >> n;\n\tn--;\n\tCombination comb(n+2, MOD);\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += (((comb.mfact[i] * comb.C(i - 1, n - i) % MOD)* comb.mfact[n - i]%MOD\n\t\t\t- (comb.mfact[i - 1] * comb.mfact[n - i + 1] % MOD) * comb.C(i - 2, n - i + 1)%MOD) % MOD) * i;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\nT powmod(T n, T k, T mod) {\n  if (k == 0) {\n    return 1;\n  } else if (k % 2 == 0) {\n    return powmod(n * n % mod, k / 2, mod);\n  } else {\n    return n * powmod(n, k-1, mod) % mod;\n  }\n}\n\ntemplate <typename T>\nT inv(T x, T mod = 1e9 + 7) {\n  return powmod(x, mod-2, mod);\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  const ll mod = 1e9 + 7;\n\n  int N; cin >> N;\n  vector<ll> fact(N), inv_fact(N);\n  fact[0] = fact[1] = 1;\n  inv_fact[0] = inv_fact[1] = inv(1);\n  FOR(i, 2, N) {\n    fact[i] = (fact[i - 1] * (ll)i) % mod;\n    inv_fact[i] = inv(fact[i]);\n  }\n\n  ll ans = 0, prev = 0;\n\n  REP(k, N) {\n    if (k - 1 >= 0 and N - k - 1 >= 0 and k - 1 >= N - k - 1) {\n      ll now = fact[k - 1] * inv_fact[2 * k - N] % mod * fact[k] % mod;\n      ans += (now - prev + mod) % mod * k % mod;\n      ans %= mod;\n      prev = now;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int             long long\nusing namespace std;\n\nconst int N = 1e6 + 4, MOD = 1e9 + 7;\nint n, fac[N];\n\nint nm(int ans) { return ans % MOD; }\n\nint DivMod(int val, int mod) {\n    if (mod == 0) return 1LL;\n    int tmp = DivMod(val, mod/2);\n    if (mod % 2 == 1) return ((tmp * tmp) % MOD * val) % MOD;\n    return (tmp * tmp) % MOD;\n}\n\nint C(int k, int n) {\n    return ((fac[n] * DivMod(fac[n-k], MOD-2)) % MOD * DivMod(fac[k], MOD-2)) % MOD;\n}\n\nvoid sol() {\n    fac[0] = 1;\n    for (int i = 1; i < N; ++i) fac[i] = (fac[i-1] * i) % MOD;\n\n    int res = 0, Prev = 0;\n    for (int k = 1; k < n; ++k) {\n        if (n-1-k > k-1) continue;\n\n        int Add = C(n-1-k, k-1);\n        Add = (Add * fac[k]) % MOD;\n        Add = (Add * fac[n-1-k]) % MOD;\n\n        res = (res + (Add - Prev) * k % MOD + MOD) % MOD;\n        Prev = Add;\n    }\n    cout << res;\n}\n\nmain() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n \n    cin >> n;\n\n    sol();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 10000;\nconst int mod = 1e9 + 7;\n\nint step[maxn], inv_step[maxn];\n\nint power(int x, int times) {\n\tint rt = 1, base = x;\n\twhile (times) {\n\t\tif (times & 1) rt = (long long)rt * base % mod;\n\t\tbase = (long long)base * base % mod;\n\t\ttimes >>= 1;\n\t}\n\treturn rt;\n}\n\nint C(int a, int b) {\n\tif (b < 0 || b > a) return 0;\n\treturn (long long)step[a] * inv_step[b] % mod * inv_step[a - b] % mod;\n}\n\nint f[maxn];\n\nint main() {\n\tstep[0] = 1;\n\tfor (int i = 1; i < maxn; i++) step[i] = (long long)step[i - 1] * i % mod;\n\tfor (int i = 0; i < maxn; i++) inv_step[i] = power(step[i], mod - 2);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tn--;\n\tfor (int i = 1; i <= n; i++) f[i] = C(i - 1, n - i);\n\n\n\t//for (int i = n; i >= 1; i--) f[i] = (f[i] - (long long)f[i - 1] * (n - (i - 1))) % mod;\n//\tfor (int i = 1; i <= n; i++) cout << f[i] << endl;\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans = (ans + (long long)f[i] % mod * step[i] % mod * step[n - i]) % mod;\n//\t\tcout << ans << endl;\n\t}\n\n\tans = ((long long)step[n] * (n + 1) - ans) % mod;\n\tcout << (ans + mod) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 1e6+4;\nconst int mod = 1e9+7;\nint f[N], g[N];\nint n;\n\nvoid add(int &x, int y)\n{\n\tx = (x + y) % mod;\n}\nint sub(int x,int y)\n{\n\treturn (((x-y) % mod) + mod) % mod;\n}\n\nint mul(int x,int y)\n{\n\tx = x % mod,\n\ty = y % mod;\n\treturn (x*y) % mod;\n}\n\nint binpow(int a,int b)\n{\n\tif(b == 0)\n\t\treturn 1;\n\tint res = binpow(a, b/2);\n\tif(b % 2 == 0)\n\t\treturn mul(res, res);\n\telse\n\t\treturn mul(mul(a, res), res);\n}\n\nint Ckn(int k, int n)\n{\n\treturn mul(g[n], binpow(mul(g[n-k], g[k]), mod-2) );\n}\n\nsigned main()\n{\n\tg[0] = 1;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tg[i] = mul(g[i-1], i);\n\t}\n\n\tcin >> n;\n\tfor(int i=n/2;i<=n-1;i++)\n\t{\n\t\tf[i] = mul(mul(Ckn(n-1-i, i-1), g[i]), g[n-1-i]);\n\t\t// cout<<f[i]<<' ';\n\t}\n\tf[n/2 - 1] = 0;\n\tint ans = 0;\n\tfor(int i=n/2;i<=n-1;i++)\n\t{\n\t\tadd(ans, mul(i, sub(f[i], f[i-1])));\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "    #include<bits/stdc++.h>\n    using namespace std;\n    #define int long long \n    #define pb push_back\n    #define pii pair<int,int>\n    #define mp make_pair\n    #define F first\n    #define S second\n    #define ld long double\n    int const M=1e6+10,inf=1e9+10,mod=1e9+7;\n    int fact[M],ans[M];\n    int pw(int x,int y)\n    {\n    \tif(y==0)return 1;\n    \tint tmp=pw(x,y/2);\n    \tif(y%2==0)return (tmp*tmp)%mod;\n    \treturn ((tmp*tmp)%mod*x)%mod;\n    }\n    int C(int n,int r)\n    {\n    \tint tmp=fact[r]*fact[n-r];\n    \ttmp%=mod;\n    \ttmp=pw(tmp,mod-2);\n    \ttmp*=fact[n];\n    \ttmp%=mod;\n    \treturn tmp;\n    }\n    int say(int n,int r)\n    {\n    \tint tmp=n-r;\n    \tif(tmp==0 && r==0)return 1;\n    \tif(tmp<r || r==0)return 0;\n    \treturn C(tmp-1,r-1);\n    }\n    int32_t main()\n    {\n    \tint n;\n    \tcin>>n;\n    \tfact[0]=1;\n    \t//cout<<C(5,2)<<\" \"<<pw(2,4)<<endl;\n    \tfor(int i=1;i<=n;i++)\n    \t{\n    \t\tfact[i]=fact[i-1]*i;\n    \t\tfact[i]%=mod;\n    \t}\n    \tint all=0;\n\t\tif(n==3)return cout<<4,0;\n    \tfor(int i=1;i<=n-1;i++)\n    \t{\n    \t\tif(n-i-1<0)continue;\n    \t\tint res=n-i;\n    \t\tif(n-2>=res)\n    \t\t\tans[i]=say(n-2,res);\n    \t\tans[i]*=(res*2)%mod;\n    \t\tans[i]%=mod;\n    \t\tif(n-2>=res-1){\n    \t\t\tans[i]+=say(n-2,res-1)*res;\n    \t\t\tans[i]%=mod;\n    \t\t}\n    \t\tif(n-3>=res)\n    \t\t{\n    \t\t\tint hlp=say(n-3,res-1)*2;\n    \t\t\thlp*=res;\n    \t\t\thlp%=mod;\n    \t\t\tans[i]+=hlp;\n    \t\t\tans[i]%=mod;\n    \t\t}\n    \t\tint tmp=1;\n    \t\ttmp%=mod;\n    \t\ttmp*=fact[i-1];\n    \t\ttmp%=mod;\n    \t\ttmp*=fact[n-i-1];\n    \t\ttmp%=mod;\n    \t\ttmp*=i;\n    \t\ttmp%=mod;\n    \t\ttmp*=ans[i];\n    \t\ttmp%=mod;\n    \t//\tcout<<i<<\" \"<<res<<\" \"<<tmp<<\" \"<<ans[i]<<endl;\n    \t\tall+=tmp;\n    \t\tall%=mod;\n    \t}\n    \tcout<<all;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ninline int read() {\n  int f = 1;\n  int x = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    f = (ch == '-') ? -1 : 1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return f * x;\n}\n\nconst int N = 1e6 + 5;\nconst int P = 1e9 + 7;\n\ninline int mul(int a, int b) {\n  return (long long) a * b % P;\n}\ninline int sub(int a, int b) {\n  return a - b < 0 ? a - b + P : a - b;\n}\ninline int add(int a, int b) {\n  return a + b >= P ? a + b - P : a + b;\n}\ninline int modexp(int a, int x) {\n  int ret = 1;\n  while (x) {\n    if (x & 1) {\n      ret = mul(ret, a);\n    }\n    a = mul(a, a);\n    x >>= 1;\n  }\n  return ret;\n}\n\nint n;\nint fac[N];\nint inv[N];\n\ninline int calc(int m, int n) {\n  int k = 2 * m - n;\n  if (k >= 0 && m - k >= 0) {\n    return mul(fac[m], mul(inv[k], inv[m - k]));\n  } else {\n    return 0;\n  }\n}\n\ninline int C(int n, int m) {\n  if (n < 0 || m < 0 || n < m) {\n    return 0;\n  }\n  return mul(fac[n], mul(inv[m], inv[n - m]));\n}\n\nint sum[N];\n\nint main() {\n  n = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  inv[n] = modexp(fac[n], P - 2);\n  for (int i = n - 1; i >= 0; --i) {\n    inv[i] = mul(inv[i + 1], i + 1);\n  }\n  int ans = 0;\n  for (int i = (n + 1) / 2; i < n; ++i) {\n    sum[i] = mul(fac[n - i - 1], mul(C(i - 1, n - i - 1), fac[i]));\n    ans = add(ans, mul(i, sub(sum[i], sum[i - 1])));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=1e6+5;\nbool cmax(sign &a,sign b){return (a<b)?a=b,1:0;}\nbool cmin(sign &a,sign b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin);\n\tfreopen(\"test.out\",\"w\",stdout);\n#endif\n}\nconst int mo=1e9+7;\nint n,inv[N],mc[N];\nvoid input()\n{\n\tn=read<int>();\n}\nll power(ll x,int y)\n{\n\tint res=1;\n\tfor(;y;x=x*x%mo,y>>=1)if(y&1)res=res*x%mo;\n\treturn res;\n}\nvoid init()\n{\n\tmc[0]=inv[0]=1;\n\tFor(i,1,n)mc[i]=(ll)mc[i-1]*i%mo;\n\tinv[n]=power(mc[n],mo-2);\n\tFordown(i,n-1,1)inv[i]=(ll)inv[i+1]*(i+1)%mo;\n}\nint C(int n,int m)\n{\n\tif(n<m)return 0;\n\treturn (ll)mc[n]*inv[m]%mo*inv[n-m]%mo;\n}\nint f[N];\nvoid work()\n{\n\tint ans=0;\n\tint d=(n+1)/2;\n\tFor(i,d,n-1)f[i]=1ll*C(i-1,n-i-1)*mc[i]%mo*mc[n-i-1]%mo;\n\t//For(i,d,n-1)cout<<i<<' '<<f[i]<<endl;\n\tFordown(i,n-1,d)f[i]=(f[i]-f[i-1]+mo)%mo;\n\t//For(i,d,n-1)cout<<i<<' '<<f[i]<<endl;\n\tFor(i,d,n-1)ans=(ans+1ll*f[i]*i%mo)%mo;\n\twrite(ans,'\\n');\n}\nint main()\n{\n\t\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"]\"; return os; }\n\n\n// import here\n\nconst LL MOD = 1000000007;\n\nLL mod_pow(LL v, LL n){\n    if(n <= 0) return 1;\n    LL res = mod_pow(v, n/2);\n    res = res * res % MOD;\n    if(n & 1) res = res * v % MOD;\n    return res;\n}\n\nvector<LL> mod_factorial(LL n){\n    vector<LL> res(n);\n    res[0] = 1;\n    for(LL i = 1; i <= n; ++i){\n        res[i] = res[i-1] * i % MOD;\n    }\n    return res;\n}\n\nLL permutation(LL n, LL m, vector<LL>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    LL res = factorial[n];\n    res = res * mod_pow(factorial[m-1], MOD-2) % MOD;\n    return res;\n}\n\nLL combination(LL n, LL m, vector<LL>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    LL res = permutation(n, m, factorial);\n    res = res * mod_pow(factorial[m], MOD-2) % MOD;\n    return res;\n}\n\nint main(){\n    LL n;\n    cin >> n;\n    if(n == 2){\n        cout << 1 << endl;\n        return 0;\n    }\n    if(n == 3){\n        cout << 4 << endl;\n        return 0;\n    }\n    vector<LL> factorial = mod_factorial(n+1);\n    vector<LL> equal_or_less(n+1);\n    for(LL k = 0; k < n; ++k){\n        LL part1 = factorial[k] * factorial[n-1-k] % MOD;\n        LL part2 = combination(k-1, n-1-k, factorial);\n        equal_or_less[k] = part1 * part2 % MOD;\n    }\n    LL ans = 0;\n    for(LL k = (n+1)/2; k+1 <= n; ++k){\n        assert(k-1 >= n-k-1);\n        LL part1 = (equal_or_less[k] - equal_or_less[k-1] + MOD) % MOD;\n        LL part2 = part1 * k % MOD;\n        ans = (ans + part2) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    考虑一个可以用 K ((n+1)/2 <= K < n)次染黑的方案，\n\t那么将操作前K次的机器从小到大排序，一定是:\n\ta1=1 < a2 < ...< ak=n-1\n\t并且 a[i+1]-a[i] <= 2\n\t\n\t转化模型，就是一个变量初始等于 1 ,每次操作可以 +1 或者 +2 ,\n\tk-1 次操作之后 = n-1 的方案数. \n\t\n\tC(k-1 , n-k-1) * (k!) * ((n-k-1)!)\n*/\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int ha=1e9+7,N=1e6+5,mod=ha-1;\n \ninline int add(int x,int y){ x+=y; return x>=ha?x-ha:x;}\ninline void ADD(int &x,int y){ x+=y; if(x>=ha) x-=ha;}\n \ninline int ksm(int x,int y){\n    int an=1;\n    for(;y;y>>=1,x=x*(ll)x%ha) if(y&1) an=an*(ll)x%ha;\n    return an;\n}\n \nint n,jc[N],ni[N],ans,f[N]; \n \ninline void init(){\n    jc[0]=1;\n    for(int i=1;i<=n;i++) jc[i]=jc[i-1]*(ll)i%ha;\n    ni[n]=ksm(jc[n],ha-2);\n    for(int i=n;i;i--) ni[i-1]=ni[i]*(ll)i%ha;\n}\n\ninline void solve(){\n\tfor(int k=n+1>>1;k<n;k++) f[k]=jc[k]*(ll)jc[k-1]%ha*(ll)ni[2*k-n]%ha;\n\tfor(int k=n+1>>1;k<n;k++) ADD(ans,add(f[k],ha-f[k-1])*(ll)k%ha);\n}\n\nint main(){\n\tscanf(\"%d\",&n),init();\n\tsolve(),printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst long long limit=1000000009;\nlong long sum,N;\n\nll factorial(ll n) {\n    if (n > 0) {\n        return n * factorial(n - 1)%limit;\n    } else {\n        return 1;\n    }\n}\n\n\nll Combination(ll n, ll r)\n{\n    \n    if (n - r < r) r = n - r;\n    if (r == 0) return 1;\n    if (r == 1) return n;\n\n    int* numerator = new int[r];\n    int* denominator = new int[r];\n\n    for (int k = 0; k < r; k++)\n    {\n        numerator[k] = n - r + k + 1;\n        denominator[k] = k + 1;\n    }\n\n    for (int p = 2; p <= r; p++)\n    {\n        int pivot = denominator[p - 1];\n        if (pivot > 1)\n        {\n            int offset = (n - r) % p;\n            for (int k = p - 1; k < r; k += p)\n            {\n                numerator[k - offset] /= pivot;\n                denominator[k] /= pivot;\n            }\n        }\n    }\n\n    ll result = 1;\n    for (int k = 0; k < r; k++)\n    {\n        if (numerator[k] > 1){\n            result *= numerator[k];\n            result%=limit;\n        }\n    }\n\n    return result;\n}\n\nll calc_cases(ll k,ll N){\n    return factorial(k)%limit*Combination(k-1,N-k-1)%limit;\n}\n\nll calc_ans(ll N){\n    ll sum=0;\n    if(N%2==0){\n        for(ll k=N/2;k<=N-1;++k){\n            if(k==N-1){\n            sum+=k*calc_cases(k,N)%limit;\n            sum%=limit;\n            }\n            else{\n                sum-=calc_cases(k,N);\n                sum%=limit;\n            }\n            //cout<<calc_cases(k,N)<<endl;\n        }\n    }\n    else{\n        for(ll k=(N+1)/2;k<=N-1;++k){\n            if(k==N-1){\n            sum+=k*calc_cases(k,N)%limit;\n            sum%=limit;\n            }\n            else{\n                sum-=calc_cases(k,N);\n                sum%=limit;\n            }\n            //cout<<calc_cases(k,N)<<endl;\n        }\n    }\n    return sum;\n}\n\nint main(){\n    cin>>N;\n    sum=calc_ans(N);\n    while(sum<0){\n        sum+=limit;\n    }\n    cout<<sum<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pii, int > a, pair < pii, int > b)//true for a before b\n{\n\tif(a.F.F/300 < b.F.F/300)\n\t\treturn 1;\n\tif(a.F.F/300 > b.F.F/300)\n\t\treturn 0;\n\tif(a.F.S < b.F.S)\n\t\treturn 1;\n\tif(a.F.S > b.F.S)\n\t\treturn 0;\n\tif(a.F <= b.F)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (1e6) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nll fact[N], ifact[N];\n\nvoid pre()\n{\n\tint i;\n\tfact[0] = ifact[0] = 1;\n\tfo(i,1,N)\n\t{\n\t\tfact[i] = (fact[i-1] * 1LL * i)%mod;\n\t\tifact[i] = inmodx(fact[i]);\n\t}\n\treturn;\n}\n\nll choose(int n, int r)\n{\n\tif(n < 0 || r < 0 || r > n)\n\t\treturn 0LL;\n\tll ans = (fact[n]*ifact[r])%mod;\n\tans = (ans * ifact[n-r])%mod;\n\treturn ans;\n}\n\nvoid solve()\n{\n\tpre();\n\tint n, i;\n\tll ans = 0, val, sum = 0;\n\tcin >> n;\n\n\tif(n == 2)\n\t{\n\t\tcout << 1 << '\\n';\n\t\treturn;\n\t}\n\t\n\tfo(i,(n+1)/2,n)\n\t{\n\t\tval = (choose(i-1,n-1-i)*fact[i])%mod;\n\t\tval = (val * fact[n-1-i])%mod;\n\t\tans = (ans + 1LL*i*(val-sum+mod))%mod;\n\t\tsum = val;\n\t}\t\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file;\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(9);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\n\nint p[N], inv[N], f[N];\n\nint extgcd(int a, int b, int& x, int& y){\n\tint d = a;\n\tif (b != 0){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n\telse{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nint mod_inverse(int a){\n\tint x, y, m;\n\tm = mod;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\nvoid _init(int n){\n\tp[0] = 1;\n\tfor (int i = 1; i <= n; i++) p[i] = 1LL * p[i - 1] * i % mod;\n\tfor (int i = 0; i <= n; i++) inv[i] = mod_inverse(p[i]);\n}\n\nint C(int x, int y){\n\tif (x < y) return 0;\n\tint ret;\n\tret = p[x];\n\tret = 1LL * ret * inv[y] % mod;\n\tret = 1LL * ret * inv[x - y] % mod;\n\treturn ret;\n}\n\nint main(){\n\tint n, ans;\n\tscanf(\"%d\",&n);\n\tif (n == 2){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tif (n == 3){\n\t\tprintf(\"4\\n\");\n\t\treturn 0;\n\t}\n\t_init(n);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n - 1; i++) \n\t\tf[i] = 1LL * C(i - 1, n - i - 1) * p[i] % mod * p[n - i - 1] % mod;\n\tans = 0;\n\tfor (int i = 1; i <= n - 1; i++){\n\t\tans += 1LL * (f[i] - f[i - 1] + mod) % mod * i % mod;\n\t\tans %= mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n#define MAX_N 1000000\nlong long I[MAX_N + 1], F[MAX_N + 1], IF[MAX_N + 1];\n#define MOD 1000000007LL\nlong long C[MAX_N + 1];\nlong long R;\n\nint main() {\n  cin >> N;\n  I[1] = F[0] = F[1] = IF[0] = IF[1] = 1;\n  for(int i = 2; i < N; ++i) {\n    I[i] = MOD - (MOD / i) * I[MOD % i] % MOD;\n    F[i] = i * F[i - 1] % MOD;\n    IF[i] = I[i] * IF[i - 1] % MOD;\n  }\n  long long prev = 0;\n  for(int k = (N + 1) / 2; k <= N - 1; ++k) {\n    long long cur =\n      F[k - 1] * IF[N - 1 - k] % MOD * IF[k - 1 - (N - 1 - k)] % MOD\n      * F[k] % MOD * F[N - 1 - k] % MOD;\n    (R += k * (cur + MOD - prev % MOD)) %= MOD;\n    prev = cur;\n  }\n  cout << R << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 1000000\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nint main(){\n\tinit();\n\tint n;\n\tcin>>n;\n\tvi po(n+1,1);\n\trep(i,n)po[i+1]=po[i]*(i+1)%MOD;\n\tll out=0;\n\tll sum=0;\n\tloop(i,1,n){\n\t\t(out+=i*(po[i]*po[n-1-i]%MOD*nCr(i-1,n-1-i)%MOD+MOD-sum)%MOD)%=MOD;\n\t\tsum=po[i]%MOD*po[n-1-i]%MOD*nCr(i-1,n-1-i);\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int mod = (int)(1e9 + 7)>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t n) const {\n    ModInt res(1), mul(x);\n    while (n) {\n      if (n & 1) res *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return res;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int get_mod() { return mod; }\n};\n\nstruct Combination {\n  vector<ModInt<>> _fact, _rfact, _inv;\n  Combination(long long nsize = 5000000)\n      : _fact(nsize + 1), _rfact(nsize + 1), _inv(nsize + 1) {\n    _fact[0] = _rfact[nsize] = _inv[0] = 1;\n    for (int i = 1; i <= nsize; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[nsize] /= _fact[nsize];\n    for (int i = nsize - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for (int i = 1; i <= nsize; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n  inline ModInt<> fact(int k) const { return _fact[k]; }\n\n  inline ModInt<> rfact(int k) const { return _rfact[k]; }\n\n  inline ModInt<> inv(int k) const { return _inv[k]; }\n\n  ModInt<> P(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  ModInt<> C(int p, int q) const {\n    if (q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  // n types,choose r\n  ModInt<> H(int n, int r) const {\n    if (n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\nint n;\nCombination com;\n\nModInt<> solve();\n\nint main() {\n  cin >> n;\n  cout << solve() << endl;\n  return 0;\n}\n\nModInt<> solve() {\n  ModInt<> res, bf = 0;\n  for (int i = 1; i < n; ++i) {\n    ModInt<> now = com.fact(i) * com.fact(n - 1 - i) * com.C(i - 1, n - i - 1);\n    res += (now - bf) * i;\n    bf = now;\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 2100000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nll d[1010101];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tnum--;\n\tinvinit();\n\tll ans = 0;\n\tfor (int i = 0; i <= num / 2; i++)d[i] = com(num - 1 - i, i)*kai[i] % mod*kai[num - i] % mod;\n\tfor (int i = 0; i <= num / 2; i++)ans = (ans + (d[i] + mod - d[i + 1])*(num - i)) % mod;\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"]\"; return os; }\n\n\n// import here\n\nconst LL MOD = 1000000007;\n\nLL mod_pow(LL v, LL n){\n    if(n < 0) return mod_pow(v, MOD-1 + v);\n    if(n == 0) return 1;\n    LL res = mod_pow(v, n/2);\n    res = res * res % MOD;\n    if(n & 1) res = res * v % MOD;\n    return res;\n}\n\nvector<LL> mod_factorial(LL n){\n    vector<LL> res(n);\n    res[0] = 1;\n    for(LL i = 1; i < n; ++i){\n        res[i] = res[i-1] * i % MOD;\n    }\n    return res;\n}\n\nLL permutation(LL n, LL m, vector<LL>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    LL res = factorial.at(n);\n    res = res * mod_pow(factorial.at(n-m), MOD-2) % MOD;\n    return res;\n}\n\nLL combination(LL n, LL m, vector<LL>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    LL res = permutation(n, m, factorial);\n    res = res * mod_pow(factorial.at(m), MOD-2) % MOD;\n    return res;\n}\n\nint main(){\n    LL n;\n    cin >> n;\n    if(n == 2){\n        cout << 1 << endl;\n        return 0;\n    }\n    if(n == 3){\n        cout << 4 << endl;\n        return 0;\n    }\n    vector<LL> factorial = mod_factorial(n+1);\n    vector<LL> equal_or_less(n+1);\n    for(LL k = 1; k <= n-1; ++k){\n        LL part1 = factorial[k] * factorial[n-1-k] % MOD;\n        LL part2 = combination(k-1, n-1-k, factorial);\n        equal_or_less[k] = part1 * part2 % MOD;\n    }\n    LL ans = 0;\n    for(LL k = (n+1)/2; k <= n-1; ++k){\n        assert(k-1 >= n-k-1);\n        LL part1 = (equal_or_less[k] - equal_or_less[k-1] + MOD) % MOD;\n        LL part2 = part1 * k % MOD;\n        ans = (ans + part2) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst ll N=2e6+5,mod=1e9+7;\nll fct[N],inv[N],invfct[N];\ninline void init(){\n    fct[0]=fct[1]=1;\n\tinv[1]=1;\n\tinvfct[0]=invfct[1]=1;\n\tfor(ll i=2;i<N;i++){\n\t\tfct[i]=i*fct[i-1]%mod;\n\t\tinv[i]=ll(mod-inv[mod%i])*(mod/i)%mod;\n\t\tinvfct[i]=ll(inv[i])*invfct[i-1]%mod;\n\t}\n}\ninline ll ncr(ll n,ll r){\n    if(n<r)return 0;\n    return fct[n]*(invfct[r]*invfct[n-r]%mod)%mod;\n}\nint main(){\n    cin.tie(NULL); cout.tie(NULL);\n    ios_base:: sync_with_stdio(false);\n    init();\n    ll n;cin>>n;\n    ll ans = fct[n];\n    for(ll k=1;k<n;k++){\n        ans-=ncr(k-1,n-k-1)*fct[k]%mod*fct[n-k-1]%mod;\n        if(ans<0)ans+=mod;\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 1000000007LL\n#define maxn 100005\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii(1LL, 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 2000000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\ni64 f( i64 n , i64 k )\n{\n    if( k < ( n-4 +2-1 )/2 || k>(n-3) || n<0 || k<0 ) return 0LL ;\n    return C(k+1,n-3-k) ;\n}\n\nint main()\n{\n    preprocess() ;\n\n    printf(\"%lld\\n\",f(7LL,3LL)) ;\n\n    i64 i , j , k , l , m , n ;\n\n    scanf(\"%lld\",&n) ;\n\n    if(n==2)\n    {\n        printf(\"1\\n\") ;\n        return 0 ;\n    }\n\n    i64 ans = 0LL ;\n\n    for( i64 k = (n-4 + 2-1)/2 ; k<=n-3 ; k++ )\n    {\n        i64 ret = ( fact[k+2]*f(n,k) - fact[k+1]*((f(n,k-1)*(n-k-2))%mod) )%mod ;\n        ret = (ret*fact[ n-k-3 ])%mod ;\n        ans = ( ans + ret*(k+2) )%mod ;\n  //      printf(\"%lld-->%lld\\n\",k,ans) ;\n    }\n\n    printf(\"%lld\\n\", (ans%mod + mod)%mod ) ;\n\n    return 0 ;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\nconst int maxn = 1e6;\nlong long f[maxn];\n\nlong long in(long long a, long long b) {\n    long long ans = 1;\n    while (b > 0) {\n        if (b & 1) {\n            ans = (ans * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        b >>= 1;       \n    }\n    return ans;\n}\n\nlong long dv(long long a, long long b) {\n    return (a * in(b, MOD - 2)) % MOD;\n}\n\nlong long cnk(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return dv(f[n], (f[k] * f[n - k]) % MOD);\n}\n\nlong long fun(int n, int k) {\n    return cnk(k - 1, n - k);\n}\n\nint main()\n{\n    #ifdef DEBUG\n    //freopen(\"input.txt\", \"r\", stdin);\n    #endif\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    long long n;\n    cin >> n;\n    if (n == 2) {\n        cout << 1;\n        return 0;\n    }\n    if (n == 3) {\n        cout << 4;\n        return 0;\n    }\n    n--;\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        f[i] = (f[i - 1] * i) % MOD;\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        //cerr << fun(n, i) << \"\\n\";\n        ans = (ans + f[n - i] * ((cnk(n, i) - fun(n, i)) * f[i] % MOD)) % MOD; \n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n;\nLL fact[1000005],rfac[1000005];\nLL inv(LL v){\n\tLL ret=1LL,tms=MOD1-2LL;\n\twhile(tms){\n\t\tif(tms&1) ret=(ret*v)%MOD1;\n\t\tv=(v*v)%MOD1;\n\t\ttms>>=1LL;\n\t}\n\treturn ret;\n}\nLL C(int n,int m){\n\tif(n<m || n<0 || m<0) return 0LL;\n\tLL u=fact[n],d=(rfac[m]*rfac[n-m])%MOD1;\n\treturn (u*d)%MOD1;\n}\nLL cntuni(int n,int sp){\n\treturn (((C(n-sp-1,sp-2)*fact[sp-2])%MOD1)*fact[n-sp])%MOD1;\n}\nLL cntsin(int n,int sp){\n\tif(n<2) return 0;\n\tif(n==2) return sp==2;\n\treturn ((((LL)(sp-2LL)*(LL)(sp-1LL))%MOD1)*cntuni(n-1,sp-1)%MOD1);\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    scanf(\"%d\",&n);\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tfact[0]=1LL;\n\tLL res=0LL;\n\tfor(i=1;i<=n;++i){\n\t\tfact[i]=(fact[i-1]*(LL)i)%MOD1;\n\t}\n\trfac[n]=inv(fact[n]);\n\tfor(i=n-1;i>=0;--i){\n\t\trfac[i]=(rfac[i+1]*(LL)(i+1))%MOD1;\n\t}\n\tfor(i=1;i<n;++i){\n\t\tLL dlt=cntsin(n,n-i+1)+2LL*(LL)(n-i)*cntuni(n,n-i+1);\n\t\tres=(res+(LL)i*(dlt%MOD1))%MOD1;\n\t}\n\tprintf(\"%lld\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static AlgStruct idAdd(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static AlgStruct idMul(Args... args) { return Operators::IdMul(args...); }\n\n    AlgStruct operator+() const { return *this; }\n    AlgStruct operator-() const { return Operators::Opposite(x); }\n    AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct& operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct& operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct& operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct& operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    AlgStruct power(LL n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& value){ s << value.x; return s; }\n\n\ntemplate<LL mod>\nstruct GaloisFieldOperators {\n    static LL Add(LL lhs, LL rhs) { return (lhs + rhs) % mod; };\n    static LL Mul(LL lhs, LL rhs) { return (lhs * rhs) % mod; };\n    static LL IdAdd() { return 0; };\n    static LL IdMul() { return 1; };\n    static LL Opposite(LL value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(LL lhs, LL rhs) { return lhs < rhs; };\n    static LL Power(LL value, LL n) {\n        LL res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static LL Reciprocal(LL value) { return Power(value, mod-2); }\n};\n\nconst LL MOD = 1e9+7;\n\nusing GaloisField = AlgStruct<LL, GaloisFieldOperators<MOD>>;\n\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring::idMul();\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\n\nsigned main()\n{\n    LL n; cin >> n;\n\n    Fact<GaloisField> fact(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * fact[k] * fact[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (LL k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nvector<int64_t> fac, inv;\nvoid init(int n) {\n  fac.assign(n + 1, 1);\n  inv.assign(n + 1, 1);\n\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = i * fac[i - 1] % mod;\n  }\n  for (int p = mod - 2, x = fac[n]; p; p >>= 1) {\n    if (p & 1) inv[n] = inv[n] * x % mod;\n    x = 1ll * x * x % mod;\n  }\n  for (int i = n - 1; i >= 0; --i) {\n    inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n  }\n}\n\nint64_t C(int n, int r) {\n  if (r < 0 || n < r) return 0;\n  return fac[n] * inv[r] % mod * inv[n - r] % mod;\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  init(n--);\n  int64_t ans = 0, pre = 0;\n  for (int i = n / 2; i >= 0; --i) {\n    int64_t k = C(n - 1 - i, i) * fac[i] % mod * fac[n - i] % mod;\n    (ans += (k - pre + mod) * (n - i) % mod) %= mod;\n    pre = k;\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Why am I so dumb? :c\n// chrono::system_clock::now().time_since_epoch().count()\n#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n\n#define all(x) (x).begin(), (x).end()\n\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;   \n\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)1e6 + 5;\n\nint fact[MAXN];\n\nint rev[MAXN];\n\nint cnt[MAXN];\n\nint n, ans;\n\nint binPow(int a, int b, int m = MOD) {\n    int ret = 1;\n\n    while (b > 0) {\n        if (b & 1) {\n            ret = (ret * 1ll * a) % m;\n        }\n\n        a = (a * 1ll * a) % m;\n        b >>= 1;\n    }\n\n    return ret;\n}\n\nvoid pre() {\n    fact[0] = 1;\n    rev[0] = 1;\n\n    for (int i = 1; i < MAXN; ++i) {\n        fact[i] = (fact[i - 1] * 1ll * i) % MOD;\n        rev[i] = binPow(fact[i], MOD - 2, MOD);     \n    }\n}\n\nvoid addMod(int &a, int b, int m = MOD) {\n    a += b;\n\n    if (m <= a) {\n        a -= m;\n    }\n}\n\nint C(int n, int k) {\n    if (k > n) {\n        return 0;\n    }\n\n    return fact[n] * 1ll * rev[k] % MOD * rev[n - k] % MOD;\n}\n\nvoid solve() {\n    scanf(\"%d\", &n);\n\n    for (int k = 1; k < n; ++k) {\n        cnt[k] = C(k - 1, n - k - 1) * 1ll * fact[k] % MOD * fact[n - k - 1] % MOD;\n        addMod(ans, (cnt[k] - cnt[k - 1] + MOD + 0ll) * k % MOD);        \n    }\n\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    int tt = 1;\n\n    pre();\n\n    while (tt--) {\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define MAXN 1000000\n\n#define MOD 1000000007\n\nint fact[MAXN + 1], invFact[MAXN + 1];\n\ninline int lgput(int a, int n) {\n    int r = 1;\n    while (n) {\n        if (n % 2)\n            r = 1LL * r * a % MOD;\n        n /= 2;\n        a = 1LL * a * a % MOD;\n    }\n    return r;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++)\n        fact[i] = 1LL * fact[i - 1] * i % MOD;\n    invFact[n] = lgput(fact[n], MOD - 2);\n    for (int i = n - 1; i >= 0; i--)\n        invFact[i] = 1LL * invFact[i + 1] * (i + 1) % MOD;\n\n    int k = (n - 1) / 2, last = 0, ans = 0;\n    while (k < n - 1) {\n        k++;\n        int acum = 1LL * fact[k - 1] * fact[k] % MOD * invFact[2 * k - n] % MOD;\n        ans = (ans + 1LL * (acum - last + MOD) * k) % MOD;\n        last = acum;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\n\nll fact(ll x){\n  ll res=1;\n  while(x>1){\n    res*=x;\n    res%=MOD;\n    x--;\n  }\n  return res%MOD;\n}\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  REP(i,n+1)a[i]=i;\n  int sm=0;\n  ll f=fact((n+1)/2 - 1);\n  for(int i=(n+1)/2;i<=n-1;i++){\n    f*=i;\n    sm+=(i*(n-i)*f)%MOD;\n  }\n  P(sm%MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 1000005;\nconst ll MOD = 1000000007;\n\nint n;\n\nll ans;\nll fac[MAXN];\nll inv[MAXN];\n\nll power(ll a,ll b)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\t(res *= a) %= MOD;\n\t\t(a *= a) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nvoid init()\n{\n\tfac[0] = 1;\n\tfor (int i = 1;i <= n;i++)\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\tinv[n] = power(fac[n],MOD - 2);\n\tfor (int i = n;i >= 1;i--)\n\t\tinv[i - 1] = inv[i] * i % MOD;\n}\n\nll C(int x,int y)\n{\n\treturn x < y ? 0 : fac[x] * inv[y] % MOD * inv[x - y] % MOD;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tinit();\n\tll sum = 0;\n\tfor (int i = (n + 1) / 2;i < n;i++)\n\t{\n\t\tll val = (C(i - 1,n - i - 1) * fac[i] % MOD * fac[n - i - 1] - sum) % MOD;\n\t\t(ans += val * i) %= MOD;\n\t\t(sum += val) %= MOD;\n\t}\n\tprintf(\"%lld\\n\",(ans + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nlong long mod=1000000007;\nlong long ans=0;\nint fac[2020202];\nint ifac[2020202];\nint C(int n,int m)\n{\n\tif(n<m)\n\t\treturn 0;\n\treturn (long long)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main()\n{\n\tint n,cnt,d,d1;\n\tscanf(\"%d\",&n);\n\tn--;\n\tfac[0]=1;\n\tfor(int i=1;i<=2000000;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%mod;\n\tifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2000000;i++)\n\t\tifac[i]=(long long)(mod-mod/i)*ifac[mod%i]%mod;\n\tfor(int i=2;i<=2000000;i++)\n\t\tifac[i]=(long long)ifac[i-1]*ifac[i]%mod;\n\tans=(long long)(n+1)*fac[n]%mod;\n\td=(n+1)/2;\n\tcnt=n/2+1;\n\tfor(int i=cnt;i<=n;i++)\n\t{\n\t\td1=d-(i-cnt);\n\t\t(ans-=(long long)fac[i]*C(i-d1+d1-1,d1-1)%mod*fac[n-i])%=mod;\n\t}\n\tprintf(\"%lld\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll fc[1001001]={1ll},nv[1001001]={1ll},w[1001001];\n\nll rwpw(ll a, ll p){\n\tll ret = 1ll;\n\twhile(p){\n\t\tif(p%2){\n\t\t\tmul_mod(ret,a);\n\t\t}\n\t\tmul_mod(a,a);\n\t\tp /= 2;\n\t}\n\treturn ret;\n}\n\nll comb(int n, int k){\n\tll ret = fc[n];\n\tif(n<k){\n\t\treturn 0ll;\n\t}\n\tmul_mod(ret,nv[k]);\n\tmul_mod(ret,nv[n-k]);\n\treturn ret;\n}\n\nint main(void){\n\tint n,i,p,q;\n\tll tmp,ans=0ll;\n\tcin >> n;\n\tfor(i=0; i<n; ++i){\n\t\tfc[i+1] = fc[i];\n\t\tmul_mod(fc[i+1],i+1);\n\t\tnv[i+1] = rwpw(fc[i+1],MOD-2);\n\t}\n\t--n;\n\tfor(i=1; i<=n; ++i){\n\t\tp = i; q = n-i;\n\t\tw[i] = comb(p-1,q);\n\t\tmul_mod(w[i],fc[p]);\n\t\tmul_mod(w[i],fc[q]);\n\t\ttmp = w[i];\n\t\tadd_mod(tmp,MOD-w[i-1]);\n\t\tmul_mod(tmp,i);\n\t\tadd_mod(ans,tmp);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k)  for(ll i=j;i<=k;++i)\n#define Dow(i,j,k)  for(ll i=k;i>=j;--i)\n#define ll long long\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read()\n{\n\tll t=0,f=1;char c=gc();\n\twhile(!isdigit(c))  {if(c=='-') f=-1;c=gc();}\n\twhile(isdigit(c))   t=t*10+c-'0',c=gc();\n\treturn t*f;\n}\ninline void write(ll x){if(x<0) {putchar('-');write(-x);return;}if(x>=10)    write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void write_p(ll x){write(x);putchar(' ');}\n\nll n,mod=1e9+7,fac[1000010],N[1000010],ans,f[1000010],sum;\nll ksm(ll x,ll y){ll ans=1;while (y){if (y&1)(ans*=x)%=mod;(x*=x)%=mod;y>>=1;}return ans;}\nll\tp(ll n,ll m){return fac[n]*N[m]%mod;}\nll C(ll n,ll m){return fac[n]*N[m]%mod*N[n-m]%mod;}\nint main()\n{\n\tn=read();\n\tif (n==2){puts(\"1\");return 0;}\n\tfac[0]=1;\n\tFor(i,1,n)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tN[n]=ksm(fac[n],mod-2);\n\tDow(i,0,n-1)N[i]=N[i+1]*(i+1)%mod;\n\tfor (ll i=1;i<n;i++)if (i*2>=n)\n\t{\n\t\tf[i]=C((n-2-(i*2-n))/2+i*2-n,i*2-n)*fac[i]%mod*fac[n-1-i]%mod;\n\t\t(ans+=(f[i]-f[i-1])*i%mod+mod);\n\t\tans%=mod;\n\t}\n\twriteln(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define ld long double\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 1e5 + 10;\nconst int M = (int) 1e6 + 10;\nconst int K = (int) 500 + 10;\nconst int INF = (int) 1e9 + 7;\nconst int mod = (int) 1e9 + 7;\nconst ld EPS = (ld) 1e-9;\nconst ll LINF = (ll) 1e18;\n\nint n;\nint f[M], inv[M];\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n\tif (x < 0)\n\t\tx += mod;\n}\n\nint mult(int x, int y) {\n\treturn x * 1ll * y % mod;\n}\n\nint sum(int x, int y) {\n\tadd(x, y);\n\treturn x;\n}\n\nint bp(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y % 2) \n\t\t\tans = mult(ans, x);\n\t\tx = mult(x, x);\n\t\ty /= 2;\n\t}\n\treturn ans;\n}\n\nint cnk(int n, int k) {\n\treturn (k < 0 || k > n ? 0 : mult(f[n], mult(inv[n - k], inv[k])));\n}\n\nint calc(int k) {\n\t// k = length of A\n\t// sum of A[i] = n - 2, 1 <= A[i] <= 2\n\tint sum = n - 2 - k;\n\treturn mult(cnk(k, sum), f[k + 1]);\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tsrand(time(0));\n\tcin >> n;\n\tfor (int i = 0; i <= n; i++) {\n\t\tf[i] = i ? mult(f[i - 1], i) : 1;\n\t\tinv[i] = bp(f[i], mod - 2);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n - 2; i++) {\n\t\tint cnt = sum(calc(i), -calc(i - 1));\n\t\t//cout << cnt << ' ' << mult(f[n - 2 - i], mult(cnt, i + 1)) << endl;\n\t\tadd(ans, mult(f[n - 2 - i], mult(cnt, i + 1)));\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <cmath>\n#define MOD 1000000007\n#define SIZE 2000005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[SIZE],fac[SIZE],finv[SIZE];\nvoid make()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint main()\n{\n\tmake();\n\tint n;\n\tscanf(\"%d\",&n);\n\tll ret=fac[n];\n\tfor(int k=1;k<n;k++)\n\t{\n\t\tint zan=n-k-1;\n\t\tret-=C(k-1,zan)*fac[k]%MOD*fac[n-k-1]%MOD;\n\t\tif(ret<0) ret+=MOD;\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int NMAX = 1000002;\nlong long n, fact[NMAX];\nlong long x, y, ans, last;\n\nlong long lgpow (long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1)\n      ans = ans * a % MOD;\n    b >>= 1;\n    a = a * a % MOD;\n  }\n  return ans;\n}\n\nlong long  C (long long n, long long m) {\n  long long a = fact[n], b = (fact[m] * fact[n - m]) % MOD;\n  return (a * lgpow(b, MOD - 2)) % MOD;\n}\n\nint main()\n{\n  cin >> n;\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++)\n    fact[i] = (long long)fact[i - 1] * i % MOD;\n  for (int k = (n + 1) / 2; k < n; k++) {\n    x = C(k - 1, n - 1 - k) * fact[k] % MOD * fact[n - k - 1] % MOD;\n    y = (x - last + MOD) % MOD * k % MOD;\n    ans = (ans + y) % MOD;\n    last = x;\n  }\n  cout << ans;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=(1e6)+10;\nconst ll mod=(1e9)+7;\nint n;\nll jc[maxn],ivjc[maxn],iv[maxn],ans;\nll c(ll a,ll b) {\n\tif (a<b) return 0;\n\tll res=jc[a]*ivjc[b]%mod*ivjc[a-b]%mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tjc[0]=ivjc[0]=1;\n\tfor (int i=1;i<=n;i++) {\n\t\tjc[i]=jc[i-1]*i%mod;\n\t\tiv[i]=(mod-iv[mod%i]*(mod/i))%mod;\n\t\tif (i==1) iv[1]=1;\n\t\tivjc[i]=ivjc[i-1]*iv[i]%mod;\n\t}\n\tll lst=0;\n\tfor (int s=max(1,n/2-1);s<n;s++) {\n\t\tll tmp=jc[s]*jc[n-s-1]%mod*c(s-1,n-s-1)%mod;\n\t\tans+=(tmp-lst)*s%mod;\n\t\tlst=tmp;\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<boost/multiprecision/cpp_int.hpp>\nusing namespace std;\nusing bigint = boost::multiprecision::int256_t;\n\nbigint M = 1000000007, m = 335790106025098313, n = 489373567, mask = 1152921504606846975;\n\ninline bigint MR(bigint A){\n    return (A + M * (m * A & mask)) >> 60;\n}\n\ninline bigint Prod(bigint lhs, bigint rhs){\n    return MR(MR(lhs * rhs) * n);\n}\n\nlong long int N;\nbigint fact[10010101], ifact[10010101], ans;\n\nint main(){\n    scanf(\"%lld\", &N);\n    fact[0] = 1;\n    for(int i = 1; i < N; ++i){\n        fact[i] = Prod(fact[i - 1], i);\n    }\n    bigint n = M - 2, r = fact[N - 1];\n    ifact[N - 1] = 1;\n    while(n){\n        if(n & 1){\n            ifact[N - 1] = ifact[N - 1] * r % M;\n        }\n        n /= 2;\n        r = r * r % M;\n    }\n    for(int i = N - 1; i > 0; --i){\n        ifact[i - 1] = Prod(ifact[i], i);\n    }\n    ans = fact[N - 1] * (N - 1);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += M - Prod(Prod(fact[i], fact[i - 1]), ifact[i * 2 - N]);\n    }\n    ans %= M;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e6 + 55;\n\nint per[20];\n\nint used[20];\n\nint cnt[20];\n\nint dp[30][30];\n\nint c[30][30];\n\nll f[MAXN], f_inv[MAXN];\n\nll pow_mod(ll a, ll st){\n\tll ans = 1ll;\n\tfor(; st; st /= 2){\n\t\tif (st & 1){\n\t\t\tans = (ans * a) % MOD;\n\t\t}\n\t\ta = (a * a) % MOD;\n\t}\n\treturn ans;\n}\n\nll get_c(int i, int j){\n\tif (i < 0 || j < 0 || j > i){\n\t\treturn 0ll;\n\t}\n\tll ans = (f[i] * f_inv[j]) % MOD;\n\tans = (ans * f_inv[i - j]) % MOD;\n\treturn ans;\n}\n\nll get_v(ll i, ll j){\n\treturn get_c(i - j + 1, j);\n}\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tn--;\n\tint lim = n + 10;\n\tf[0] = 1;\n\tREPN(i, 1, lim){\n\t\tf[i] = (f[i - 1] * i) % MOD;\n\t}\n\tf_inv[lim] = pow_mod(f[lim], MOD - 2);\n\tfor(int i = lim - 1; i >= 0; i--){\n\t\tf_inv[i] = (f_inv[i + 1] * (i + 1)) % MOD;\n\t}\n\t\n\tll ans = 0ll;\n\tfor(int j = n; j >= 0; j--){\n\t\tll v_cur = get_v(n - 2, j);\n\t\tll v_last = get_v(n - 2, j + 1);\n\t\tll cnt_all = v_cur * (n - j) % MOD;\n\t\tll cnt_dif = (v_last * (j + 1)) % MOD;\n\t\tll cur_cnt = (cnt_all - cnt_dif + MOD) % MOD;\n\t\t\n\t\t//cout << j << \" \" << v_cur << \" \" << v_last << \" \" << cur_cnt << endl;\n\t\tll cur_val = (cur_cnt * f[n - j]) % MOD;\n\t\tcur_val = (cur_val * f[j]) % MOD;\n\t\tans = (ans + cur_val) % MOD;\n\t\t\n\t\t//cout << n - j << \" \" << cur_val << endl;\n\t}\n\tcout << ans << endl;\n\t\n\t/*int n = 30;\n\tdp[0][0] = 1;\n\tdp[1][0] = dp[1][1] = 1;\n\tREPN(i, 2, n){\n\t\tdp[i][0] = dp[i - 1][0];\n\t\tREPN(j, 1, n){\n\t\t\tdp[i][j] = dp[i - 1][j] + dp[i - 2][j - 1];\n\t\t}\n\t}\n\tREPN(i, 0, n){\n\t\tprintf(\"%02d: \", i);\n\t\tREPN(j, 0, i){\n\t\t\tprintf(\"%06d \", dp[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}*/\n\t\n\t/*int f = 1;\n\tREPN(n, 2, 11){\n\t\tf *= (n - 1);\n\t\tint ans = 0;\n\t\tREP(i, 0, n - 1){\n\t\t\tper[i] = i;\n\t\t}\n\t\tREPN(i, 0, n){\n\t\t\tcnt[i] = 0;\n\t\t}\n\t\tREP(j, 0, f){\n\t\t\tREP(i, 0, n){\n\t\t\t\tused[i] = 0;\n\t\t\t}\n\t\t\tint cur = 0;\n\t\t\tREP(i, 0, n - 1){\n\t\t\t\tint ind = per[i];\n\t\t\t\tif (!used[ind]){\n\t\t\t\t\tused[ind] = 1;\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t\tif (!used[ind + 1]){\n\t\t\t\t\tused[ind + 1] = 1;\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t\tif (cur == n){\n\t\t\t\t\tans += i + 1;\n\t\t\t\t\tcnt[i + 1]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext_permutation(per, per + n - 1);\n\t\t}\n\t\tprintf(\"**************\\n%d %d\\n\", n, ans);\n\t\tREPN(i, 1, n){\n\t\t\tprintf(\"%d %d\\n\", i, cnt[i]);\n\t\t}\n\t}*/\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 2000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod=1e9+7;\nint iv[N],inv[N],fac[N];\ninline int C(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\tint n,sum=0; cin>>n;\n\tiv[1]=fac[0]=inv[0]=1;for(rint i=2;i<=n;i++)iv[i]=(ll)(mod-mod/i)*iv[mod%i]%mod;\n\tfor(rint i=1;i<=n;i++)fac[i]=(ll)fac[i-1]*i%mod,inv[i]=(ll)inv[i-1]*iv[i]%mod;\n\tfor(rint i=(n+1)/2;i<n-1;i++)(sum+=(ll)C(i-1,n-i-1)*fac[i]%mod*fac[n-1-i]%mod)%=mod;\n\tcout<<((ll)(n-1)*fac[n-1]%mod-sum+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\nll fac[2000005], ifac[2000005];\nll qpow(ll a, ll b){\n\tll ret = 1;\n\tfor(; b; b >>= 1, a = a * a % mod){\n\t\tif(b & 1) ret = ret * a % mod;\n\t}\n\treturn ret;\n}\nll C(ll a, ll b){\n\tif(a < b) return 0;\n\treturn fac[a] * ifac[b] % mod * ifac[a - b] % mod;\n}\nint n, m;\nll ans = 0;\nint main(){\n\tscanf(\"%d\", &n);\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n * 2; i ++) fac[i] = fac[i - 1] * i % mod;\n\tifac[n * 2] = qpow(fac[n * 2], mod - 2);\n\tfor(int i = n * 2; i >= 1; i --) ifac[i - 1] = ifac[i] * i % mod;\n\tm = n / 2 + (n % 2);\n\tll pre = 0;\n\tfor(int i = m; i < n; i ++){\n\t\tint x = i * 2 - n;\n\t\tans = (ans + (C((n - 1 + x) / 2, x) * fac[i] % mod - pre + mod) % mod * fac[n - 1 - i] % mod * i) % mod;\n\t\t\n\t\tpre = C((n - 1 + x) / 2, x) * fac[i] % mod * (n - 1 - i) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007, m = 79133769, n = 536396504, mask = 1073741823;\n \ninline long long int MR(long long int A){\n    long long int ret((A + M * (m * A & mask)) >> 30);\n    return ret - (ret >= M) * M;\n}\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  constexpr Fact() : val() {\n    val[0] = 73741817;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F * 73741817 % M;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000001>();\nconstexpr auto ifact = IFact<1000001, 397802501>();\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += MR(MR(fact.val[i] * fact.val[i - 1]) * ifact.val[i * 2 - N]);\n    }\n    ans = fact.val[N] - fact.val[N - 1] - ans;\n    ans %= M;\n    cout << MR(ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define fr(i,a,b) for (int i = b-1; i >= a; i--)\nconst ll mod = 1e9+7;\nconst int mxn = 2e6;\n\nll fact[mxn], inv[mxn];\n\nll modpow(ll a, ll b) {\n  \treturn b?modpow(a*a%mod,b/2)*(b&1?a:1)%mod:1;\n}\n\nll comb(int n, int k) {\n  \tif (n<k||k<0) return 0;\n\treturn fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nvoid add(ll &a, ll b) {\n  if (b>=mod) b%=mod;\n  a += b;\n  if (a>=mod) a-=mod;\n}\n\nint main() {\n\tint n; cin >> n;\n  \tf(i,0,mxn) fact[i] = i?fact[i-1]*i%mod:1;\n  \tinv[mxn-1] = modpow(fact[mxn-1],mod-2);\n  \tfr(i,0,mxn-1) inv[i] = inv[i+1]*(i+1)%mod;\n  \tll ans = 0;\n  \tf(k,0,n) {\n    \tll p = (mod+comb(n-1,k)-comb(k-1,n-k-1))%mod;\n      \tadd(ans,p*fact[k]%mod*fact[n-1-k]%mod);\n    }\n  \tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nvector<LL> fact;\nvector<LL> inver(1000001);\n\n\nLL combination(int n,int r){\n    if(n==0&&r==0) return 1;\n    return fact[n]%mod*inver[n-r]%mod*inver[r]%mod;\n}\n\nLL fpow(LL a, LL n){\n    int x = 1;\n    while(n > 0){\n        if(n&1){\n            x=x*a%mod;\n        }\n        a=a*a%mod;\n        n >>= 1;\n    }\n    return x;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    LL s=1;\n    fact.push_back(1);\n    for(int i=1;i<=1000000;i++){\n        s*=i;\n        s%=mod;\n        fact.push_back(s);\n    }\n    inver[1000000]=fpow(fact[1000000],mod-2);\n    for(int i=999999;i>=0;i--){\n        inver[i]=inver[i+1]*(i+1)%mod;\n    }\n    LL ans=0;\n    for(int k=1;k<N;k++){\n        if(k-1<N-1-k) continue;\n        ans+=k*(combination(k-1,N-1-k)%mod*fact[k]%mod*fact[N-1-k]%mod)%mod;\n        if(k-2<N-k) continue;\n        ans=(ans+mod-(combination(k-2,N-k)%mod*fact[k-1]%mod*fact[N-k]%mod)*k%mod)%mod;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double dbl;\ntypedef pair<int, int> pii;\n\n#define F(i, l, r) for(int i = (l); i < (r); i++)\n#define E(i, l, r) for(int i = (l); i <= (r); i++)\n#define DF(i, l, r) for(int i = (l); i >= (r); i--)\n#define I(x, a) for(auto x : (a))\n#define mp make_pair\n#define X first\n#define Y second\n#define clean(x) memset((x), 0, sizeof(x))\n#define ret return\n#define cont continue\n#define brk break\n#define ins insert\n#define all(x) (x).begin(),(x).end()\n#define sync ios_base::sync_with_stdio(false);cin.tie(0)\n#define pb push_back\n#define y1 fjfg\n\nconst int maxn = 1e6 + 6;\nconst int mod = 1000000007;\n\nint n;\nll le[maxn];\nll fac[maxn];\n\nll inv(ll a){\n\tll res = 1;\n\tll pw = mod - 2;\n\twhile(pw){\n\t\tif(pw&1)res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tpw >>= 1;\n\t}\n\tret res;\n}\n\nll C(ll A, ll B){\n\tif(B > A)return 0;\n\tll q = fac[B] * fac[A - B] % mod;\n\treturn fac[A] * inv(q) % mod;\n}\n\nll f(int len, int ones){\n\tif(len < ones)return 0;\n\tif(len == 0)return 1;\n\tif(ones == 0)return 1;\n\tif(len == 1)return 1;\n\t//ret (f(len - 2, ones - 1) + f(len - 1, ones))%mod;\n\tret C(len - (ones - 1), ones);\n}\n\nint main(){\n\tsync;\n\tfac[0] = 1;\n\tF(i, 1, maxn)fac[i] = fac[i - 1] * i % mod;\n\tcin >> n;\n\tif(n == 2){cout << 1; return 0;}\n\tle[0] = 0;\n\t//ll ans = fac[n - 1] * 1ll * (n) % mod;\n\tll ans = 0;\n\tF(i, 1, n){\n\t\tle[i] = fac[n - 1 - i] * fac[i] % mod;\n\t\tle[i] *= f(n - 3, n - 1 - i);\n\t\tle[i] %= mod;\n\t\tans += i * 1ll * (le[i] - le[i - 1]) % mod;\n\t}\n\t//F(i, 1, n){\n//\t\tans -= le[i];\n//\t\tans %= mod;\n//\t}\n/*\tF(ones, 0, 20){\n\t\tF(len, 0, 20)\n\t\t\tcout << f(len, ones) << ' ';\n\t\tcout << endl;\n\t}\n*/\n\tans = (ans%mod + mod)%mod;\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <assert.h>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1000000007;\nconst int N = 1000010;\nll fact[N], invf[N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nll nPr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(fact[n], invf[n-r]);\n}\n\nll nCr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(mul(fact[n], invf[r]), invf[n-r]);\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    fact[0] = invf[0] = 1;\n    FOR(i,1,N-1){\n        fact[i] = (fact[i-1] * i) % mod;\n        invf[i] = divll(invf[i-1], i);\n    }\n\n    VL way(n);\n    ll ans = 0;\n    REP(k,n){\n        ll tmp = (fact[k] * fact[n-1-k]) % mod;\n        tmp = (tmp * nCr(k-1, n-k-1)) % mod;\n        way[k] = tmp;\n        if (k > 0) way[k] = (way[k] - way[k-1] + mod) % mod;\n        ans = (ans + k * way[k]) % mod;\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nconst ll MOD = 1e9+7;\n\nmap<int,int> memo;\nint fact(int n){\n    n%=MOD;\n    if(memo.count(n))return memo[n];\n    else return memo[n] = (fact(n-1)*n)%MOD;\n}\n\nll power(ll a,ll b){\n    ll ret=1;\n    if(b>0){\n        ret = power(a,b/2);\n        if(b%2==0)ret = (ret*ret)%MOD;\n        else ret = (((ret*ret)%MOD)*a)%MOD;\n    }\n    return ret;\n}\n\n\nint inv(int p){\n    return power(p,MOD-2);\n}\n\nint f(int n, int k){\n    int a = 2*k-n;\n    int b = n-k-1;\n    if(a<0 || b<0)return 0;\n    \n    return ((((fact(a+b) * inv(fact(a)))%MOD * inv(fact(b)))%MOD * fact(k))%MOD * fact(n-k-1))%MOD;\n}\n\nsigned main(){\n    memo[0] = 1;\n    int n;\n    cin>>n;\n    \n    int ans = 0;\n    for(int k=1; k<=n-1; k++){\n        (ans += k*(f(n,k)-f(n,k-1)))%=MOD;\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iomanip>\n#include <climits>\n#include <functional>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<string> VS;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<PII> VPI;\ntypedef vector<PLL> VPL;\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pf push_front\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define ub upper_bound\n#define lb lower_bound\n\nconst int MAX=1001001;\nconst int mod=1000000007;\nll fac[MAX],finv[MAX],inv[MAX];\n\nll modpow(ll a,ll n){\n  ll res=1;\n  while(n){\n    if(n&1) res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll modinv(ll a){\n  return modpow(a,mod-2);\n}\n\nvoid init(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  rep(i,MAX){\n    if(i>1){\n      fac[i]=fac[i-1]*i%mod;\n      inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n      finv[i]=finv[i-1]*inv[i]%mod;\n    }\n  }\n}\n\nll com(int n,int k){\n  if(n<k) return 0;\n  if(n<0||k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%mod)%mod;\n}\n\nint main(){\n  int N;\n  cin>>N;\n  ll ans=0;\n  ll mod=1e9+7;\n  init();\n  ll sum=0;\n  ll tmp=0;\n  rep(i,N){\n    ll tmp=com(i-1,N-1-i)%mod*fac[i]%mod*fac[N-1-i]%mod;\n    (ans+=(tmp+mod-sum)%mod*i%mod)%=mod;\n    sum=tmp;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\nint n;\nll fact[1000001],invfact[1000001],ans,k,suma;\nll inv(ll a)\n{\n    ll b=mod-2;\n    ll rez=1;\n    while(b)\n    {\n        if(b%2)\n            rez=(rez*a)%mod;\n        a=(a*a)%mod;\n        b/=2;\n    }\n    return rez;\n}\nll combi(ll a, ll b)\n{\n    ll rez=fact[a];\n    rez=(rez*invfact[b])%mod;\n    rez=(rez*invfact[a-b])%mod;\n    return rez;\n}\nint main()\n{\n    cin>>n;\n    fact[0]=1;\n    invfact[0]=inv(1);\n    for(int i=1;i<=n;i++)\n    {\n        fact[i]=(fact[i-1]*i)%mod;\n        invfact[i]=inv(fact[i]);\n    }\n    //suma=fact[n-1];\n    for(k=n/2;k<n;k++)\n    {\n        ll x=combi(k-1,n-k-1);\n        x=(x*fact[k])%mod;\n        x=(x*fact[n-k-1])%mod;\n        x=x-suma;\n        if(x<0)\n            x+=mod;\n        suma+=x;\n        x=(x*k)%mod;\n        ans=(ans+x)%mod;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5,mod=1e9+7;\ntypedef long long ll;\nll inv(ll x){return x==1?x:(mod-mod/x)*inv(mod%x)%mod;}\nll f[N],invf[N],s[N];\nll C(int n,int m)\n{\n    return f[n]*invf[n-m]%mod*invf[m]%mod;\n}\nint main()\n{\n    f[0]=invf[0]=f[1]=invf[1]=1;\n    for(int i=2;i<N;i++) f[i]=f[i-1]*i%mod,invf[i]=(mod-mod/i)*invf[mod%i]%mod;\n    for(int i=2;i<N;i++) invf[i]=invf[i-1]*invf[i]%mod;\n    int n;scanf(\"%d\",&n);\n    ll ans=0;\n    for(int k=(n+1)/2;k<n;k++)\n        s[k]=C(k-1,n-k-1)*f[k]%mod*f[n-1-k]%mod;\n    for(int k=(n+1)/2;k<n;k++)\n        ans=(ans+(s[k]-s[k-1])*k)%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\ntypedef long long ll ;\nconst int N = 1e6 + 5;\nll MOD = 1e9 + 7 ;\nll fact[N] , inv[N] ;\nll ways[N] ;\n\nll BigMod (ll b , ll p) {\n    if (p == 0) return 1LL ;\n    ll t = BigMod(b,p/2) ;\n    t = (t*t)%MOD ;\n    if (p&1) return (t*b)%MOD ;\n    return t ;\n}\n\n\nint main () {\n\n    fact[0] = inv[0] = 1;\n    for (ll i = 1; i < N ; i++) {\n        fact[i] = (fact[i-1]*i)%MOD ;\n        inv[i] = BigMod(fact[i],MOD-2) ;\n    }\n    ll n ;\n    cin >> n ;\n    ll ans = 0 ;\n    for (ll K = (n+1)/2 ; K < n ; K++) {\n        ll cur = ( fact[K-1]*fact[K] ) % MOD ;\n        cur *= inv[2*K-n] ;\n        cur %= MOD ;\n        ways[K] = cur ;\n    }\n    ll subs = 0 ;\n    for (ll i = (n+1)/2 ; i < n ; i++) {\n        ll cur_way = ways[i] - subs ;\n        cur_way %= MOD ;\n        subs += cur_way ; subs %= MOD ;\n        ll cur = cur_way*i ;\n        cur %= MOD ;\n        ans += cur ;\n        ans %= MOD ;\n    }\n    ans += MOD ;\n    ans %= MOD ;\n    cout << ans ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T,typename U>bool chmin(T& a,const U& b){return a>b?(a=b,1):0;}\ntemplate<typename T,typename U>bool chmax(T& a,const U& b){return a<b?(a=b,1):0;}\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<uint M>\nstruct modint{\n\tuint val;\n\tmodint(uint x=0):val((x%M+M)%M){}\n\tmodint pow(uint r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tll x=1;\n\t\tfor(ll a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn (x+M)%M;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n\texplicit operator uint()const{return val;}\n};\n\ntemplate<uint M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<uint M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<uint M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<uint M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<uint M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<uint M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<uint M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nstruct Factorial{\n\tvector<mint> data,inv;\n\tFactorial(int size):data(size),inv(size){\n\t\tdata[0]=1;\n\t\trepi(i,1,size)\n\t\t\tdata[i]=mint(i)*data[i-1];\n\t\trep(i,size)\n\t\t\tinv[i]=data[i].inv();\n\t}\n\tmint Fact(int n){\n\t\treturn data[n];\n\t}\n\tmint Choose(int n,int r){\n\t\treturn data[n]*inv[n-r]*inv[r];\n\t}\n};\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tFactorial fact(1000000);\n\n\tfor(int n;cin>>n&&n;){\n\t\tif(n==2){\n\t\t\tcout<<2<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<mint> cs(n);\n\t\trepi(i,2,n){\n\t\t\tif(i-1<n-1-i)\n\t\t\t\tcontinue;\n\t\t\tcs[i]=fact.Fact(i)*fact.Fact(n-1-i)*fact.Choose(i-1,n-1-i);\n\t\t}\n\t\tmint res=0;\n\t\trepi(i,1,n) res+=mint(i)*(cs[i]-cs[i-1]);\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Code be weshen zyk :'(\n * I won't surrender quietly\n */\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <bits/stdc++.h>\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate<class T> using orderd_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define S second\n#define F first\n#define pb push_back\n\nusing ii = pair<int, int>;\nusing ll = long long;\nusing db = long double;\n\nconst int N = 1e6 + 5, K = 12, MOD = 1e9 + 7;\nconst ll MX = 1e15;\nll fast(ll b, ll e){\n\tif(!e)\n\t\treturn 1;\n\tif(e & 1)\n\t\treturn b * fast(b, e - 1) % MOD;\n\treturn fast(b * b % MOD, e >> 1);\n}\nll F[N], iF[N];\nvoid init(){\n\tF[0] = iF[0] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tF[i] = F[i-1] * i % MOD;\n\t\tiF[i] = fast(F[i], MOD - 2);\n\t}\n}\nll C(int n, int k){\n\tif(k > n || k < 0)\n\t\treturn 0;\n\treturn F[n] * iF[k] % MOD * iF[n-k] % MOD;\n}\nint main() {\n#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n#endif\n\tinit();\n\tint n;\t\n\tcin >> n;\n\tll ans = 0, cur = 0;\n\n\tfor(int i = 1; i < n; i++){\n\t\tll num = C(i - 1, n - i - 1) * F[i] % MOD * F[n - i - 1] % MOD;\n\t\tnum = (num - cur + MOD) % MOD;\n\t\tcur = (cur + num) % MOD;\n\t\tans = (ans + num * i % MOD) % MOD;\n\t}\n\n\tcout << ans << '\\n';\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 1000005;\nconst int MMAX = 100005;\nconst int KMAX = 1005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n#define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define fi first\n#define se second\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> lp;\ntypedef pair<ll, ll> llp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\ntypedef unordered_map<ll, ll> umap;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// dump vector\n#ifdef DEBUG\n#define DUMPV(v, c) do{       \\\n  printf(\"%s: \", #v);         \\\n  for (int i = 0; i < (c); ++i) \\\n  {                           \\\n  cout << (v)[i] << \" \";      \\\n  }                           \\\n  cout << endl;               \\\n} while(0)\n#else\n#define DUMPV(v,c)\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll ok, ll ng, bool (*f)(ll)){\n  ll mid;\n  while(abs(ok - ng) > 1LL) {\n    mid =  (ok + ng) / 2LL;\n    if(f(mid)) {\n      debug(\"BSearch: f(%d) == true\\n\", mid);\n      ok = mid;\n    }\n    else\n    {\n      debug(\"BSearch: f(%d) == false\\n\", mid);\n      ng = mid;\n    }\n  }\n  return ok;\n}\n\nll NUM_TEST_CASE = 1;\n\nll N,M,K,A,B,C,D,E;\nint dp[NMAX] = {};\n\nstring S;\nvec v;\n\nll ans = {};\n\nll facto[NMAX], inv[NMAX];\n\nll biExp(ll x, int power){\n  if(power == 0) return 1;\n  ll xx = biExp(x, power / 2);\n  xx = xx * xx % MOD;\n  if(power % 2) xx = xx * x % MOD;\n  return xx;\n}\n\nll calcComb(int n, int r){\n  if(r > n || r < 0) return 0;\n  if(n == r || r == 0) return 1;\n  return facto[n] * inv[r] % MOD * inv[n-r] % MOD;\n}\n\nll solve(){\n  // main algorithm\n  if(N == 2) return 1;\n  if(N == 3) return 4;\n  if(N == 4) return 16;\n  // calc facto\n  facto[0] = 1;\n  for (int i = 1; i <= N; ++i)\n  {\n    facto[i] = facto[i - 1] * i % MOD;\n  }\n  // calc inv\n  inv[N] = biExp(facto[N], MOD - 2);\n  for (int i = N; i > 0; --i)\n  {\n    inv[i - 1] = inv[i] * i % MOD;\n  }\n\n  // calc sum for all k\n  ll sum = 0, preCount = 0, count = 0;\n  for (int k = N / 2; k < N; ++k)\n  {\n    count = calcComb(k - 1, N - 1 - k) * facto[k] % MOD\n          * facto[N - 1 - k] % MOD;\n    sum = (sum + (count - preCount) * k % MOD) % MOD;\n    preCount = count;\n  }\n  return sum;\n}\nvoid debug(){\n  // output debug information\n\n}\nvoid answer(){\n  // output answer\n  cout << ans << endl;\n}\nvoid init(){\n  // initialize for each test case\n  // Fill(dp, -1);\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n\n  // cin >> NUM_TEST_CASE;\n\n  for (int test_case = 0; test_case < NUM_TEST_CASE; ++test_case)\n  {\n    init();\n\n    cin >> N;\n    ans = solve();\n    #ifdef DEBUG\n    debug();\n    #endif\n    answer();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i=(l),i##end=(r);i<=i##end;i++)\n#define Fordown(i,r,l) for(int i=(r),i##end=(l);i>=i##end;i--)\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9;\nconst int mod=1e9+7;\nconst int N=1e6+10;\nint fac[N],inv[N],val[N];\ninline int read(){\n\tint x=0,flag=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')flag=-1,ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x*flag;\n}\ninline int fpm(int a,int b){\n\tint res=1;\n\twhile(b){\n\t\tif(b & 1)res=1ll*res*a%mod;\n\t\ta=1ll*a*a%mod,b/=2;\n\t}\n\treturn res;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tFor(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=fpm(fac[n],mod-2);\n\tFordown(i,n-1,0)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tint n=read();\n\tinit(n+5);\n\tFor(i,0,(n-2)/2)val[i]=1ll*C(n-2-i,i)*fac[n-1-i]%mod*fac[i]%mod;\n\tint ans=0;\n\tFor(i,0,(n-2)/2)ans=(ans+1ll*(val[i]-val[i+1])*(n-1-i))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 1e-10;\n\nll comb(ll fact[], ll rfact[], ll n, ll r){\n    return (((fact[n] * rfact[r]) % MOD) * rfact[n-r]) % MOD;\n}\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    ll n;\n    cin >> n;\n    \n    ll fact[n+1], rfact[n+1];\n    fact[0] = fact[1] = 1LL;\n    rfact[0] = rfact[1] = 1LL;\n    reppp(i, 2, n+1){\n        fact[i] = (fact[i-1] * (ll)i) % MOD;\n        rfact[i] = 1LL;\n        ll k = MOD-2;\n        ll a = fact[i];\n        while(k > 0){\n            if(k & 1){\n                rfact[i] *= a;\n                rfact[i] %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            k  >>= 1;\n        }\n    }\n\n    ll ans = 0LL, p_prev = 0LL;\n    ll k = (n+1)/2;\n    reppp(i, k, n){\n        ll p = (((comb(fact, rfact, i-1, n-1-i) * fact[i]) % MOD) * fact[n-1-i]) % MOD;\n        ans = (ans + (i * (p - p_prev)) % MOD) % MOD;\n        p_prev = p;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n; cin >> n;\n    bc.init(2002000);\n    mint ans = 0;\n    for(int k = 1; k <= n - 1; ++ k) {\n        ans += (bc.com(n - 1, k) - bc.com(k - 1, n - 1 - k)) * bc.fact(k) * bc.fact(n - 1 - k);\n        //cerr << (bc.com(n - 1, k) - bc.com(k - 1, n - 1 - k)) * bc.fact(k) * bc.fact(n - 1 - k) << endl;\n    }\n    cout << ans + bc.fact(n - 1) << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <locale>\nusing namespace std;\n#define MS0(I) memset(I, 0, sizeof(I));\n#define MS1(I) memset(I, -1, sizeof(I));\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, s, n) for(int i = (s); i < (n); ++i)\n#define per1(i, a, b) for(int i = a; i >= b; --i)\n#define DRI(A) int A; scanf(\"%d\", &A);\n#define DRII(A, B) int A, B; scanf(\"%d %d\", &A, &B);\n#define DRIII(A, B, C) int A, B, C; scanf(\"%d %d %d\", &A, &B, &C);\n#define MP make_pair \n#define pb push_back\n#define F first\n#define S second\n#define ALL(I) (I).begin(), (I).end()\ntypedef const void CV;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9+7;\nconst int MAX = (int)1e6+5;\nLL val[MAX], re_val[MAX];\ninline LL mypow(LL v, LL t){\n\tLL res = 1;\n\twhile(t){\n\t\tif(t & 1) res = res*v%mod;\n\t\tv = v*v%mod;\n\t\tt>>=1;\n\t}\n\treturn res;\n}\nvoid build(){\n\tLL v = val[0] = 1;\n\trep1(i, 1, MAX){\n\t\tv = v*i%mod;\n\t\tval[i] = v;\n\t}\n\trep(i, MAX) re_val[i] = mypow(val[i], mod-2);\n\treturn ;\n}\nint main(void){\n\tbuild();\n\tDRI(n);\n\tif(n == 2){\n\t\tputs(\"1\"); return 0;\n\t}\n\tint s = (n+1)>>1;\n\tLL ans = 0;\n\tLL num = 0;\n\tfor(LL i = s; i < n; ++i){\n\t\tLL v = val[i-1];\n\t\tv = v*re_val[n-i-1]%mod;\n\t\tv = v*re_val[2*i-n]%mod;\n\t\tv = v*val[i]%mod;\n\t\tv = v*val[n-i-1]%mod;\n\t\tans = (ans + ( ( (v - num)%mod + mod)%mod)*i )%mod;\n\t\tnum = v;\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//雪花飄飄北風嘯嘯\n//天地一片蒼茫\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl;\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nll MAX(ll a){return a;}\nll MIN(ll a){return a;}\ntemplate<typename... Args>\nll MAX(ll a,Args... args){return max(a,MAX(args...));}\ntemplate<typename... Args>\nll MIN(ll a,Args... args){return min(a,MIN(args...));}\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nconst int MOD=1000000007;\n\nll qexp(ll b,ll p,int m){\n    ll res=1;\n    while (p){\n        if (p&1) res=(res*b)%m;\n        b=(b*b)%m;\n        p>>=1;\n    }\n    return res;\n}\n\nll inv(ll i){\n\treturn qexp(i,MOD-2,MOD);\n}\n\nll fac[1000005];\nll ifac[1000005];\n\nll nCk(int i,int j){\n\treturn fac[i]*ifac[j]%MOD*ifac[i-j]%MOD;\n}\n\nll fix(ll i){\n\ti%=MOD;\n\t\n\tif (i<0) i+=MOD;\n\t\n\treturn i;\n}\n\nint n;\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tfac[0]=1;\n\trep(x,1,1000005) fac[x]=fac[x-1]*x%MOD;\n\trep(x,0,1000005) ifac[x]=inv(fac[x]);\n\t\n\tcin>>n;\n\tn--;\n\t\n\tll prev=0,curr=0;\n\tll ans=0;\n\t\n\trep(x,(n+1)/2,0){\n\t\tcurr=nCk(n-x-1,x)*fac[n-x]%MOD*fac[x]%MOD;\n\t\t\n\t\tans=fix(ans+(curr-prev)*(n-x));\n\t\t\n\t\t//cout<<curr<<endl;\n\t\tprev=curr;\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=1000005,mod=1000000007;\nconst ll mod2=(ll)mod*mod;\nint n,f[N];\nll fac[N],ni[N],ans;\ninline ll p(int a,int b){\n\treturn fac[a]*ni[a-b]%mod;\n}\ninline int ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=read();\n\tfor(int i=fac[0]=1;i<=n;i++)fac[i]=fac[i-1]*i%mod; ni[n]=ksm(fac[n],mod-2);\n\tfor(int i=n;i;i--)ni[i-1]=ni[i]*i%mod;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tf[i]=p(i-1,n-1-i)*fac[i]%mod;\n\t\tans=ans+(ll)(f[i]-f[i-1]+mod)*i; if(ans>=mod2)ans-=mod2;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 1000010;\nconst int moder = 1e9 + 7;\n\nint powermod(int a, int exp){\n    int ret = 1;\n    for ( ; exp > 0; exp >>= 1){\n        if (exp & 1){\n            ret = 1ll * ret * a % moder;\n        }\n        a = 1ll * a * a % moder;\n    }\n    return ret;\n}\n\nint fac[N];\nint inv[N];\nint ans[N];\n\nint comb(int n, int m){\n    if (n < m || m < 0) return 0;\n    return 1ll * fac[n] * inv[m] % moder * inv[n - m] % moder;\n}\n\nint main(){\n    fac[0] = 1;\n    for (int i = 1; i < N; ++ i){\n        fac[i] = 1ll * fac[i - 1] * i % moder;\n    }\n    inv[N - 1] = powermod(fac[N - 1], moder - 2);\n    for (int i = N - 1; i; -- i){\n        inv[i - 1] = 1ll * inv[i] * i % moder;\n    }\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= n - 1; ++ i){\n        ans[i] = 1ll * comb(i - 1, n - i - 1) * fac[i] % moder * fac[n - i - 1] % moder;\n    }\n    int ret = 0;\n    for (int i = 1; i <= n - 1; ++ i){\n        ret = (ret + 1ll * (ans[i] - ans[i - 1]) * i) % moder;\n        ret += ret < 0 ? moder : 0;\n    }\n    printf(\"%d\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll n,k,a[MAXN];\nll pow_mod(ll a,ll i)\n{\n\tll s=1;\n\twhile(i)\n\t{\n\t\tif(i&1) s=s*a%MOD;\n\t\ta=a*a%MOD;\n\t\ti>>=1;\n\t}\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tll ans=0;\n\tif(n&1)\n\t{\n\t\tll st=3,mult=(n+1)*(n+3)/8,addn=7,adds=n/2+2,last=0;\n\t\tll init=2,cf=6,add=6;\n\t\tfor(ll i=5;i<=n;i+=2)\n\t\t{\n\t\t\tinit=init*cf%MOD;\n\t\t\tcf=(cf+add)%MOD;\n\t\t\tadd=add+2;\n\t\t}\n\t\t//printf(\"%lld\\n\",init);\n\t\tans+=init*((n+1)/2)%MOD;\n\t\tlast=init;\n\t\tfor(ll i=(n+1)/2+1;i<=n-1;i++)\n\t\t{\n\t\t\tinit=init*mult%MOD*pow_mod(st,MOD-2)%MOD;\n\t\t\t//printf(\"%lld\\n\",init);\n\t\t\tmult=(mult+adds)%MOD;\n\t\t\tst=(st+addn)%MOD;\n\t\t\tadds++;\n\t\t\taddn+=4;\n\t\t\tans=(ans+(init-last+MOD)*i)%MOD;\n\t\t\tlast=init;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tll st=1,mult=(n)*(n+2)/8,addn=5,adds=n/2+1,last=0;\n\t\tll init=2,cf=6,add=6;\n\t\tfor(ll i=6;i<=n;i+=2)\n\t\t{\n\t\t\tinit=init*cf%MOD;\n\t\t\tcf=(cf+add)%MOD;\n\t\t\tadd+=2;\n\t\t}\n\t\t//printf(\"%lld\\n\",init);\n\t\tans+=init*(n/2)%MOD;\n\t\tlast=init;\n\t\tfor(ll i=n/2+1;i<=n-1;i++)\n\t\t{\n\t\t\tinit=init*mult%MOD*pow_mod(st,MOD-2)%MOD;\n\t\t\t//printf(\"%lld\\n\",init);\n\t\t\tmult=(mult+adds)%MOD;\n\t\t\tst=(st+addn)%MOD;\n\t\t\tadds++;\n\t\t\taddn+=4;\n\t\t\tans=(ans+(init-last+MOD)*i)%MOD;\n\t\t\tlast=init;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool p(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 100)sum += (x % poow(sinsuu, i + 1)) / (poow(sinsuu, i));\n\treturn sum;\n}\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[1114514];\nsigned main(){\n\tic(n)\n\tint k=1;\n\trep(2,i,n){\n\t\tif(i==2)k*=i;\n\t\telse k*=(i-1);\n\t\tk%=mod;\n\t}\n\ta[0]=k;\n\tint j=1;\n\tint l=n-3;\n\tint t=1;\n\trep(1,i,n/2){\n\t\tint bu=(sankaku(i+1)-1+(n-i*2-2)*i)%mod;\n\t\ta[i]=gyakugen(a[i-1],j*bu%mod)*(((l*2-t+mod)%mod*(sankaku(i)%mod))%mod)%mod;\n\t\tif(i<n/2-1){\n\t\t\tj=gyakugen(j,i)*(n-i*2)%mod;\n\t\t\tj=gyakugen(j,n-i-1)*(n-i*2-1)%mod;\n\t\t\tl=gyakugen(l,i+1)*(n-i*2-2)%mod;\n\t\t\tl=gyakugen(l,n-i-2)*(n-i*2-3)%mod;\n\t\t\tt=gyakugen(t,i)*(n-i*2-2)%mod;\n\t\t\tt=gyakugen(t,n-i-3)*(n-i*2-3)%mod;\n\t\t}\n\t\t\n\t}\n\tint ans=0;\n\trep(0,i,n){\n\t\tans+=a[i]*i;\n\t\tans%=mod;\n\t}\n\tint m=n-1;\n\trep(1,i,n){\n\t\tm*=i;\n\t\tm%=mod;\n\t}\t\n\tc((m+mod-ans)%mod)\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <utility>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\n#define init() ios::sync_with_stdio(false); cin.tie();\n#define for0(i, n) for (int i=0; i<n; i++)\n#define for1(i, n) for (int i=1; i<=n; i++)\n#define for2(i, a, b) for (int i=a; i<=b; i++)\n#define bac0(i, n) for (int i=n-1; i>=0; i--)\n#define bac1(i, n) for (int i=n; i>0; i--)\n#define bac2(i, a, b) for (int i=a; i>=b; i--)\n#define PB push_back\n#define MOD 1000000007\n#define S second\n#define F first\n#define B 99997LL\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, char> ic;\n\nconst int N = (int) (1e6 + 5);\n\nint n;\nll f[N];\n\nvoid add(ll &a, ll b) {\n    a = (a + b) % MOD;\n}\n\nll mult(ll a, ll b) {\n    return (a * b) % MOD;\n}\n\nll powmod(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1) res = mult(res, a);\n        b >>= 1, a = mult(a, a);\n    }\n    return res;\n}\n\nll inv(ll a) {\n    return powmod(a, MOD - 2);\n}\n\nll C(ll n, ll k) {\n    if (n < k) return 0;\n    return mult(f[n], inv(mult(f[k], f[n - k])));\n}\n\nint main() {\n    init()\n\n    cin >> n;\n    f[0] = 1;\n    for (ll i = 1; i <= n; i++) f[i] = mult(f[i - 1], i);\n    --n;\n\n    ll sum = 0, res = 0;\n    for (ll i = (n + 1) / 2; i <= n; i++) {\n        ll k = n - i;\n        ll value = mult(C(n - 2 - k + 1, k), mult(f[i], f[k]));\n        res = (res + mult((value - sum + MOD) % MOD, i)) % MOD;\n        sum = value;\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rnd(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\nnamespace mod_op {\n\n\tconst ll MOD = (ll)1e9 + 7;\n\n\tclass Extended_Euclid {\n\tprivate:\n\t\tll m, n;\n\t\tvvll mx_multiply(vvll mx1, vvll mx2) {\n\t\t\tvvll ret(mx1.size(), vll(mx2[0].size(), 0));\n\t\t\tLoop(i, mx1.size()) {\n\t\t\t\tLoop(j, mx1[0].size()) {\n\t\t\t\t\tLoop(k, mx2[0].size()) {\n\t\t\t\t\t\tret[i][j] += mx1[i][k] * mx2[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\tpublic:\n\t\t// solve x, y s.t. mx + ny = gcd(m,n)\n\t\tll x, y, gcd;\n\t\tExtended_Euclid(ll M, ll N) {\n\t\t\tm = M;\n\t\t\tn = N;\n\t\t\tvll r(100), k(100);\n\t\t\tbool swapflag = false, m_negflag = false, n_negflag = false;\n\t\t\tif (m < n) { swap(m, n); swapflag = true; }\n\t\t\tif (m < 0) { m *= -1; m_negflag = true; }\n\t\t\tif (n < 0) { n *= -1; n_negflag = true; }\n\t\t\tr[0] = m;\n\t\t\tr[1] = n;\n\t\t\tint h = 1;\n\t\t\twhile (1) {\n\t\t\t\tk[h - 1] = r[h - 1] / r[h];\n\t\t\t\tr[h + 1] = r[h - 1] % r[h];\n\t\t\t\tif (r[h + 1] == 0) break;\n\t\t\t\th++;\n\t\t\t}\n\t\t\tgcd = r[h];\n\t\t\tvvll mx1 = { { 0, 1 },{ 1, (-1) * k[h - 1] } };\n\t\t\tLoopr(i, h - 1) {\n\t\t\t\tvvll mx2 = { { 0, 1 },{ 1, (-1) * k[i] } };\n\t\t\t\tmx1 = mx_multiply(mx1, mx2);\n\t\t\t}\n\t\t\tx = mx1[0][0];\n\t\t\ty = mx1[0][1];\n\t\t\tif (n_negflag) { n *= -1; y *= -1; }\n\t\t\tif (m_negflag) { m *= -1; x *= -1; }\n\t\t\tif (swapflag) { swap(m, n); swap(x, y); }\n\t\t}\n\t};\n\n\tclass modll {\n\tprivate:\n\t\tll val;\n\t\tinline ll modify(ll x) { ll ret = x % MOD; if (ret < 0) ret += MOD; return ret; }\n\t\tinline ll inv(ll x) { if (x == 0) return 1 / x; Extended_Euclid ee(x, -MOD); return modify(ee.x); }\n\tpublic:\n\t\tmodll(ll init = 0) { val = modify(init); return; }\n\t\tmodll(const modll& another) { val = another.val; return; }\n\t\tinline modll& operator=(const modll &another) { val = another.val; return *this; }\n\t\tinline modll operator+(const modll &x) { return (val + x.val) % MOD; }\n\t\tinline modll operator-(const modll &x) { return (val - x.val) % MOD; }\n\t\tinline modll operator*(const modll &x) { return (val * x.val) % MOD; }\n\t\tinline modll operator/(const modll &x) { return (val * inv(x.val)) % MOD; }\n\t\tinline modll& operator+=(const modll &x) { val = (val + x.val) % MOD; return *this; }\n\t\tinline modll& operator-=(const modll &x) { val = (val - x.val) % MOD; return *this; }\n\t\tinline modll& operator*=(const modll &x) { val = (val * x.val) % MOD; return *this; }\n\t\tinline modll& operator/=(const modll &x) { val = (val * inv(x.val)) % MOD; return *this; }\n\t\tfriend inline istream& operator >> (istream &is, modll& x) { is >> x.val; return is; }\n\t\tfriend inline ostream& operator << (ostream &os, modll& x) { os << x.val; return os; }\n\t\tll get_val() { return val; }\n\t};\n\n\tmodll pow(modll n, ll p) {\n\t\tmodll ret;\n\t\tif (p == 0) ret = 1;\n\t\telse if (p == 1) ret = n;\n\t\telse {\n\t\t\tret = pow(n, p / 2);\n\t\t\tret *= ret;\n\t\t\tif (p % 2 == 1) ret *= n;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvector<modll> facts;\n\n\tinline void make_facts(int n) {\n\t\tif (facts.empty()) facts.push_back(modll(1));\n\t\tfor (int i = facts.size(); i <= n; ++i) facts.push_back(modll(facts.back() * (ll)i));\n\t\treturn;\n\t}\n\n\tvector<modll> ifacts;\n\tvector<modll> invs;\n\n\tinline void make_invs(int n) {\n\t\tif (invs.empty()) {\n\t\t\tinvs.push_back(modll(0));\n\t\t\tinvs.push_back(modll(1));\n\t\t}\n\t\tfor (int i = invs.size(); i <= n; ++i) {\n\t\t\tinvs.push_back(invs[(int)MOD % i] * ((int)MOD - (int)MOD / i));\n\t\t}\n\t\treturn;\n\t}\n\n\tinline void make_ifacts(int n) {\n\t\tmake_invs(n);\n\t\tif (ifacts.empty()) ifacts.push_back(modll(1));\n\t\tfor (int i = ifacts.size(); i <= n; ++i) ifacts.push_back(modll(ifacts.back() * invs[i]));\n\t\treturn;\n\t}\n\n\t//nCr\n\tmodll combination(ll n, ll r, bool make_ifacts_flag = false) {\n\t\tif (n < r || n < 0) return 0;\n\t\tmodll ret;\n\t\tmake_facts((int)n);\n\t\tif (make_ifacts_flag) {\n\t\t\tmake_ifacts((int)n);\n\t\t\tret = facts[(unsigned)n] * ifacts[(unsigned)r] * ifacts[(unsigned)(n - r)];\n\t\t}\n\t\telse {\n\t\t\tret = facts[(unsigned)n] / (facts[(unsigned)r] * facts[(unsigned)(n - r)]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tmodll get_fact(ll n) {\n\t\tmake_facts((int)n);\n\t\treturn facts[(int)n];\n\t}\n\n\tvector<vector<modll>> Stirling_nums2;\n\tvector<vector<modll>> Stirling_nums2_sum;\n\n\tvoid make_Stirling_nums2(int n) {\n\t\tfor (int i = Stirling_nums2.size(); i <= n; ++i) {\n\t\t\tStirling_nums2.push_back(vector<modll>(i + 1));\n\t\t\tStirling_nums2_sum.push_back(vector<modll>(i + 1, 0));\n\t\t\tLoop(j, i + 1) {\n\t\t\t\tif (j == 0) Stirling_nums2[i][j] = 0;\n\t\t\t\telse if (j == 1) Stirling_nums2[i][j] = 1;\n\t\t\t\telse if (j == i) Stirling_nums2[i][j] = 1;\n\t\t\t\telse Stirling_nums2[i][j] = Stirling_nums2[i - 1][j - 1] + Stirling_nums2[i - 1][j] * modll(j);\n\t\t\t\tif (j > 0) Stirling_nums2_sum[i][j] = Stirling_nums2_sum[i][j - 1] + Stirling_nums2[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tmodll get_Stirling_num2(ll n, ll r) {\n\t\tif (n < r) return 0;\n\t\telse {\n\t\t\tmake_Stirling_nums2((int)n);\n\t\t\treturn Stirling_nums2[(int)n][(int)r];\n\t\t}\n\t}\n\n\tmodll get_Stirling_num2_sum(ll n, ll r) {\n\t\tif (n < r) return 0;\n\t\telse {\n\t\t\tmake_Stirling_nums2((int)n);\n\t\t\treturn Stirling_nums2_sum[(int)n][(int)r];\n\t\t}\n\t}\n\n\tvector<vector<modll>> partition_nums;\n\tvector<vector<modll>> partition_nums_sum;\n\n\tvoid make_partition_nums(int n) {\n\t\tfor (int i = partition_nums.size(); i <= n; ++i) {\n\t\t\tpartition_nums.push_back(vector<modll>(i + 1));\n\t\t\tpartition_nums_sum.push_back(vector<modll>(i + 1, 0));\n\t\t\tLoop(j, i + 1) {\n\t\t\t\tif (j == 0) partition_nums[i][j] = 0;\n\t\t\t\telse if (j == 1) partition_nums[i][j] = 1;\n\t\t\t\telse if (j == i) partition_nums[i][j] = 1;\n\t\t\t\telse partition_nums[i][j] = partition_nums[i - 1][j - 1] + (i >= j * 2 ? partition_nums[i - j][j] : 0);\n\t\t\t\tif (j > 0) partition_nums_sum[i][j] = partition_nums_sum[i][j - 1] + partition_nums[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmodll get_partition_num(ll n, ll r) {\n\t\tif (n < r) return 0;\n\t\telse {\n\t\t\tmake_partition_nums((int)n);\n\t\t\treturn partition_nums[(int)n][(int)r];\n\t\t}\n\t}\n\n\tmodll get_partition_num_sum(ll n, ll r) {\n\t\tif (n < r) return 0;\n\t\telse {\n\t\t\tmake_partition_nums((int)n);\n\t\t\treturn partition_nums_sum[(int)n][(int)r];\n\t\t}\n\t}\n\n\t//a^x=b, if x does not exist, return -1\n\tll disc_log(modll a, modll b) {\n\t\tll ret = -1;\n\t\tll m = ceilsqrt(MOD);\n\t\tunordered_map<ll, ll> mp;\n\t\tmodll x = 1;\n\t\tLoop(i, m) {\n\t\t\tmp[x.get_val()] = i;\n\t\t\tx *= a;\n\t\t}\n\t\tx = modll(1) / pow(a, m);\n\t\tmodll k = b;\n\t\tLoop(i, m) {\n\t\t\tif (mp.find(k.get_val()) == mp.end()) k *= x;\n\t\t\tret = i * m + mp[k.get_val()];\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nusing namespace mod_op;\ntypedef vector<modll> vmodll;\ntypedef vector<vector<modll>> vvmodll;\n\n// the number of methods of dividing n factors into r groups\nmodll grouping(ll n, ll r, bool distinct_n, bool distinct_r, bool enable_empty_r) {\n\tint mode = (distinct_n ? 0b100 : 0) + (distinct_r ? 0b010 : 0) + (enable_empty_r ? 0b001 : 0);\n\tif (n <= 0 || r <= 0) return 0;\n\tswitch (mode) {\n\tcase 0b000:\n\t\treturn get_partition_num(n, r);\n\tcase 0b001:\n\t\treturn get_partition_num_sum(n, r);\n\tcase 0b010:\n\t\treturn combination(n - 1, r - 1);\n\tcase 0b011:\n\t\treturn combination(n + r - 1, r - 1);\n\tcase 0b100:\n\t\treturn get_Stirling_num2(n, r);\n\tcase 0b101:\n\t\treturn get_Stirling_num2_sum(n, r);\n\tcase 0b110:\n\t\treturn get_Stirling_num2(n, r) * get_fact(r);\n\tcase 0b111:\n\t\treturn pow(modll(r), n);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint main() {\n\tll n; cin >> n;\n\tmodll ans = 0;\n\tif (n == 2) {\n\t\tcout << 1 << endl;\n\t}\n\telse {\n\t\tvector<modll> buf(n, 0);\n\t\tLoop1(k, n - 1) {\n\t\t\tbuf[k] = combination(k - 1, n - k - 1, true) * get_fact(k) * get_fact(n - 1 - k);\n\t\t}\n\t\tLoop1(k, n - 1) {\n\t\t\tans += (buf[k] - buf[k - 1]) * k;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\ntypedef long long ll;\nconst int N=2001000,MOD=1000000007;\n\nll qpow(ll a,ll b){ll c=1;for(;b;b>>=1,a=a*a%MOD)if(b&1)c=c*a%MOD;return c;}\n\nint fact[N],ifact[N];\n\nint C(int n,int m)\n{\n\tif(n<m)return 0;\n\treturn (ll)fact[n]*ifact[m]%MOD*ifact[n-m]%MOD;\n}\n\nint f(int n,int k)\n{\n\treturn C(n-k+1,k);\n}\n\nint n;\n\nint main()\n{\n\tfact[0]=1;\n\tfor(int i=1;i<N;i++)fact[i]=(ll)fact[i-1]*i%MOD;\n\tifact[N-1]=qpow(fact[N-1],MOD-2);\n\tfor(int i=N-1;i;i--)ifact[i-1]=(ll)ifact[i]*i%MOD;\n\n\tscanf(\"%d\",&n);\n\n\tint ans=(ll)fact[n-1]*(n-1)%MOD;\n\n\tfor(int k=1;k<n;k++)\n\t{\n\t\tans=(ans-(ll)f(n-3,k)*fact[n-k-1]%MOD*fact[k]%MOD)%MOD;\n\t}\n\n\tans=(ans+MOD)%MOD;\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int maxN = 1e6 + 5;\nconst int mod = 1e9 + 7;\nll frac[maxN];\nll inv[maxN];\nll f[maxN];\nll pw(ll a, ll b) {\n    ll ans = 1;\n    while (b) {\n        if (b&1) ans = ans * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ans;\n}\nvoid init() {\n    frac[0]= 1;\n    inv[0] = 1;\n    for (int i = 1; i <= maxN; i++) {\n        frac[i] = frac[i-1] * i % mod;\n        inv[i] = pw(frac[i], mod-2);\n    }\n}\nll c(ll m, ll n) {\n    if (m < n) return 0;\n    if (n == 0) return 1;\n    return frac[m] * inv[n] % mod * inv[m-n] % mod;\n}\nint main() {\n    int n;\n    cin >> n;\n    init();\n    f[2] = 1;\n    ll ans = 0;\n    for (ll i = n/2; i < n; i++) {\n        f[i] = c(i-1, n-1-i) * frac[i] % mod * frac[n-1-i] % mod;\n        //cout << f[i] << \"\\n\";\n        ans = (ans + (f[i] - f[i-1] + mod) % mod * i) % mod;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5,mod=1e9+7;\ntypedef long long ll;\nll inv(ll x){return x==1?x:(mod-mod/x)*inv(mod%x)%mod;}\nll f[N],invf[N],s[N];\nll C(int n,int m)\n{\n    return f[n]*invf[n-m]%mod*invf[m]%mod;\n}\nint main()\n{\n    f[0]=invf[0]=f[1]=invf[1]=1;\n    for(int i=2;i<N;i++) f[i]=f[i-1]*i%mod,invf[i]=(mod-mod/i)*invf[mod%i]%mod;\n    for(int i=2;i<N;i++) invf[i]=invf[i-1]*invf[i]%mod;\n    int n;scanf(\"%d\",&n);\n    ll ans=0;\n    for(int k=(n+1)/2;k<n;k++)\n        s[k]=C(k-1,n-k-1)*f[k]%mod*f[n-1-k]%mod;\n    for(int k=(n+1)/2;k<n;k++)\n        ans=(ans+(s[k]-s[k-1])*k)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n// a>=0, b>=0, x*a+y*b=gcd>=0, a>0,b>0=>abs(y)<=a,abs(x)<=b\nLL gcdex(LL a,LL b,LL& x, LL& y){\n\tLL ax=1,ay=0;\n\tLL bx=0,by=1;\n\twhile(b){\n\t\tLL r=a/b;\n\t\tLL t=a-r*b; a=b; b=t;\n\t\tLL tx=ax-r*bx; ax=bx; bx=tx;\n\t\tLL ty=ay-r*by; ay=by; by=ty;\n\t}\n\tx=ax;\n\ty=ay;\n\treturn a;\n}\nLL modinv(LL a, LL mod){\n\tLL x,y;\n\tgcdex(a,mod,x,y);\n\tif(x<0){\n\t\tx+=mod;\n\t}\n\treturn x;\n}\n\nconst int N=1e6;\nconst int M=1e9+7;\ntemplate<int S>\nstruct Comb\n{\n\tLL f[S+1];\n\tLL r[S+1];\n\tLL mod;\n\tComb(int m)\n\t{\n\t\tmod=m;\n\t\tf[0]=1;\n\t\tr[0]=1;\n\t\tfor(LL i=1;i<=S;i++){\n\t\t\tf[i]=i*f[i-1]%m;\n\t\t\tr[i]=modinv(i,m)*r[i-1]%m;\n\t\t}\n\t}\n\tLL c(int n,int i){\n\t\tif(i<0||n<i)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn f[n]*r[i]%mod*r[n-i]%mod;\n\t}\n};\nComb<N> comb(M);\nint main() {\n\tLL N;\n\tcin >> N;\n\tLL pre=0;\n\tLL ret=0;\n\tfor(LL K=1;K<=N-1;K++){\n\t\tLL v=0;\n\t\tif(2*K-N>=0){\n\t\t\tv=comb.c(K-1,2*K-N)*comb.f[K]%M*comb.f[N-1-K]%M;\n\t\t}\n\t\t//cerr << K << \", \" << v << endl;\n\t\tret+=(v+M-pre)%M*K%M;\n\t\tret%=M;\n\t\tpre=v;\n\t}\n\tcout << ret << endl;\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i] * i % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main() {\n\tunsigned int n;\n\tuint64 ans=0;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = (N + 1) >> 1; i < N - 1; ++i) {\n\t\tans += fact.v2[i] * ifact.val[(i << 1) - N] % M;\n\t}\n\tans %= M;\n\tlong long unsigned int o = fact.val[N - 1] < ans ? fact.val[N - 1] + M - ans : fact.val[N - 1] - ans;\n\tprintf(\"%llu\\n\", o);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\n#define N 1000010\nusing namespace std;\nint n,m,cnt,ans,mo=1e9+7;\nint fac[N],ine[N],f[N];\nvoid add(int &a,int b){a+=b;if(a>=mo)a-=mo;}\nint cc(int a,int b)\n{\n\tif(a<0 || b<0 || a<b)return 0;\n\treturn (ll)fac[a]*ine[b]%mo*ine[a-b]%mo;\n}\nint pw(int i,int k)\n{\n\tint a=1;\n\twhile(k)\n\t{\n\t\tif(k&1)a=(ll)a*i%mo;\n\t\ti=(ll)i*i%mo;k>>=1;\n\t}\n\treturn a;\n} \nint main()\n{\n\tint i,s,a,b,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1,fac[0]=ine[0]=1;i<=n;i++)fac[i]=(ll)fac[i-1]*i%mo;\n\tine[n]=pw(fac[n],mo-2);\n\tfor(i=n-1;i;i--)ine[i]=(ll)ine[i+1]*(i+1)%mo;\n\tfor(i=1;i<n;i++)f[i]=(ll)cc(i-1,n-i-1)*fac[i]%mo*fac[n-1-i]%mo,add(ans,(ll)(f[i]-f[i-1]+mo)*i%mo);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<stack>\n\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\ntypedef long long ll;\nusing namespace std;\n\nll const MAX = 1000006;\nll d[MAX];\nlong long const MOD = 1000000007;\nlong long mod_m(long long x, long long y) {\n\treturn x * y % MOD;\n}\nlong long mod_p(long long x, long long y) {\n\treturn (x + y) % MOD;\n}\n\n//ax+by = (gcd of x and y)となるようにa,bを変更する\nlong long extgcd(long long x, long long y, long long &a, long long &b) {\n\tif (y == 0) {\n\t\ta = 1; b = 0;\n\t\treturn x;\n\t}\n\telse {\n\t\tlong long q = x / y; long long r = x % y;\n\t\tlong long s;\n\t\tlong long d = extgcd(y, r, s, a);\n\t\tb = s - a * q;\n\t\treturn d;\n\t}\n}\n\nlong long mod_inverse(long long x) {\n\tx %= MOD;\n\tlong long a, b;\n\ta = b = 0;\n\tif (extgcd(x, MOD, a, b) != 1) {\n\t\treturn -1;\n\t}\n\telse {\n\t\treturn (MOD + a % MOD) % MOD;\n\t}\n}\n//階乗をここに記憶\nlong long mod_fact[MAX];\nlong long mod_inv_fact[MAX];\n\nvoid prep_fact(long long n) {\n\tmod_fact[0] = 1;\n\tfor (long long i = 1; i <= n; i++) {\n\t\tmod_fact[i] = (mod_fact[i - 1] * i) % MOD;\n\t}\n}\nvoid prep_inv(long long n) {\n\tfor (long long i = 0; i <= n; i++) {\n\t\tmod_inv_fact[i] = mod_inverse(mod_fact[i]);\n\t}\n}\n\nlong long nCr(long long n, long long r) {\n\tif (r<0 || r>n || n < 0) {\n\t\treturn 0;\n\t}\n\treturn (((mod_fact[n] * mod_inv_fact[r]) % MOD)*mod_inv_fact[n - r]) % MOD;\n}\n\nvoid prep_d(ll n) {\n\tREP(k, 0, n) {\n\t\tif (n - k - 1 < 0) {\n\t\t\td[k] = 0;\n\t\t}\n\t\telse {\n\t\t\td[k] = nCr(k - 1, n - k - 1) * mod_fact[k] % MOD*mod_fact[n - k - 1] % MOD;\n\t\t}\n\t}\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tprep_fact(MAX - 1);\n\tprep_inv(MAX - 1);\n\tprep_d(n);\n\tll cnt = 0;\n\tREP(k, 1, n-1) {\n\t\tcnt = mod_p(cnt, mod_m(k, mod_p(MOD, d[k] - d[k - 1])));\n\t}\n\tcout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Code be weshen zyk :'(\n * I won't surrender quietly\n */\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <bits/stdc++.h>\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate<class T> using orderd_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define S second\n#define F first\n#define pb push_back\n\nusing ii = pair<int, int>;\nusing ll = long long;\nusing db = long double;\n\nconst int N = 1e6 + 5, K = 12, MOD = 1e9 + 7;\nconst ll MX = 1e15;\nll fast(ll b, ll e){\n\tif(!e)\n\t\treturn 1;\n\tif(e & 1)\n\t\treturn b * fast(b, e - 1) % MOD;\n\treturn fast(b * b % MOD, e >> 1);\n}\nll F[N], iF[N];\nvoid init(){\n\tF[0] = iF[0] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tF[i] = F[i-1] * i % MOD;\n\t\tiF[i] = fast(F[i], MOD - 2);\n\t}\n}\nll C(int n, int k){\n\tif(k > n || k < 0)\n\t\treturn 0;\n\treturn F[n] * iF[k] % MOD * iF[n-k] % MOD;\n}\nint main() {\n#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n#endif\n\tinit();\n\tint n;\t\n\tcin >> n;\n\tll ans = 0, cur = 0;\n\n\tfor(int i = 1; i < n; i++){\n\t\tll num = C(i - 1, n - i - 1) * F[i] % MOD * F[n - i - 1] % MOD;\n\t\tnum = (num - cur + MOD) % MOD;\n\t\tcur = (cur + num) % MOD;\n\t\tans = (ans + num * i % MOD) % MOD;\n\t}\n\n\tcout << ans << '\\n';\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long \n#define MAX_N 2000010\n#define MOD 1000000007\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a==0&&b==0)return 1;\n    if(a<=0)return 0;\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    make();\n    ll n;\n    cin >> n;  \n    vector<ll> a(n);\n    rep(i,n){\n        if(i>=n-1){\n            a[i] = fac[n-1];\n            continue;\n        }\n        a[i] = comb(n-2-i,i)*fac[i]%mod;\n        a[i] *= fac[n-1-i]%mod;\n        a[i] = (fac[n-1]-a[i]+mod)%mod;\n    }\n    for(int i=n-1;i>=1;i--){\n        a[i] += mod-a[i-1];\n        a[i] %= mod;\n    }\n    //rep(i,n)cerr << a[i] << endl;\n    ll sm = 0;\n    rep(i,n){\n        sm += (n-i)*a[i]%mod;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T>void gi(T &x){\n    int f;char c;\n    for(f=1,c=getchar();c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n    for(x=0;c<='9'&&c>='0';c=getchar())x=x*10+(c&15);x*=f;\n}\nconst int N=1e6+10,mod=1e9+7;\nint Fac[N],inv[N],n,f[N];\ninline int C(int n,int m){\n    return 1ll*Fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n  cin>>n;\n  int ans=0,li=(n+1)/2;\n  Fac[0]=inv[0]=inv[1]=1;\n  for(int i=1;i<=n;i++)Fac[i]=1ll*Fac[i-1]*i%mod;\n  for(int i=2;i<=n;i++)inv[i]=(mod-1ll*(mod/i)*inv[mod%i]%mod)%mod;\n  for(int i=2;i<=n;i++)inv[i]=1ll*inv[i]*inv[i-1]%mod;\n  for(int i=li;i<n;i++)f[i]=1ll*C(i-1,n-1-i)*Fac[i]%mod*Fac[n-1-i]%mod;\n  for(int i=n-1;i>=li;i--)f[i]=(f[i]-f[i-1]+mod)%mod;\n  for(int i=n-1;i>=li;i--)ans=(ans+1ll*i*f[i])%mod;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Code be weshen zyk :'(\n * I won't surrender quietly\n */\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <bits/stdc++.h>\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate<class T> using orderd_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define S second\n#define F first\n#define pb push_back\n\nusing ii = pair<int, int>;\nusing ll = long long;\nusing db = long double;\n\nconst int N = 2e5 + 5, K = 12, MOD = 1e9 + 7;\nconst ll MX = 1e15;\nll fast(ll b, ll e){\n\tif(!e)\n\t\treturn 1;\n\tif(e & 1)\n\t\treturn b * fast(b, e - 1) % MOD;\n\treturn fast(b * b % MOD, e >> 1);\n}\nll F[N], iF[N];\nvoid init(){\n\tF[0] = iF[0] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tF[i] = F[i-1] * i % MOD;\n\t\tiF[i] = fast(F[i], MOD - 2);\n\t}\n}\nll C(int n, int k){\n\tif(k > n || k < 0)\n\t\treturn 0;\n\treturn F[n] * iF[k] % MOD * iF[n-k] % MOD;\n}\nint main() {\n#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n#endif\n\tinit();\n\tint n;\n\tcin >> n;\n\tll ans = 0, cur = 0;\n\n\tfor(int i = 1; i < n; i++){\n\t\tll num = C(i - 1, n - i - 1) * F[i] % MOD * F[n - i - 1] % MOD;\n\t\tnum = (num - cur + MOD) % MOD;\n\t\tcur = (cur + num) % MOD;\n\t\tans = (ans + num * i % MOD) % MOD;\n\t}\n\n\tcout << ans << '\\n';\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define REP(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\t\t\t\t\t\t   \n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\nbool compare_by_b(pair<ll, ll> a, pair<ll, ll> b) {//降順second\n\tif (a.second != b.second) {\n\t\treturn a.second < b.second;\n\t}\n\telse {\n\t\treturn a.first > b.first;\n\t}\n}\n\nbool compare_by_a(pair<ll, ll> a, pair<ll, ll> b) {//降順first\n\tif (a.first != b.first) {\n\t\treturn a.first > b.first;\n\t}\n\telse {\n\t\treturn a.second > b.second;\n\t}\n}\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix& A, const Matrix& B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k]%MOD) * (B[k][j]%MOD))%=MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) : \n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n;\n\tcin >> n;\n\tif (n == 3) {\n\t\tcout << 4;\n\t\treturn 0;\n\t}\n\telse if(n == 2) {\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tCombination comb(n, MOD);\n\tll ans = 0;\n\tll last = 0;\n\tREP(i, n) {\n\t\tif (i - 1 >= n - 1 - i) {\n\t\t\tll temp = comb.nCr(i - 1, n - 1 - i);\n\t\t\t(temp *= comb.fact[i]) %= MOD;\n\t\t\t(temp *= comb.fact[n - 1 - i]) %= MOD;\t\t\t\n\t\t\t(ans += ((temp+MOD-last)*i)%MOD) %= MOD;\n\t\t\tlast = temp;\n\t\t}\n\t}\n\tcout << ans;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1000000007;\nlong long modsub(long long a, long long b){\n\ta %= MOD;\n\tb %= MOD;\n\tif (a >= b){\n\t\treturn (a - b) % MOD;\n\t} else {\n\t\treturn MOD - (b - a) % MOD;\n\t}\n}\nlong long modpow(long long a, long long b){\n\ta %= MOD;\n\tlong long res = 1;\n\twhile (b > 0){\n\t\tif (b % 2 == 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tb = b / 2;\n\t}\n\treturn res;\n}\nlong long modinv(long long a){\n\treturn modpow(a, MOD - 2);\n}\nvector<long long> mf;\nlong long modfact(long long n){\n\tif (n < mf.size()){\n\t\treturn mf[n];\n\t} else {\n\t\tif (mf.empty()) mf.push_back(1);\n\t\tlong long res = mf.back();\n\t\tfor (int i = mf.size(); i <= n; i++){\n\t\t\tres = res * i % MOD;\n\t\t\tmf.push_back(res);\n\t\t}\n\t\treturn res;\n\t}\n}\nlong long modbinom(long long n, long long r){\n\tlong long res;\n\tres = modfact(n);\n\tres = res * modinv(modfact(r)) % MOD;\n\tres = res * modinv(modfact(n - r)) % MOD ;\n\treturn res;\n}\nint main(){\n  int N;\n  cin >> N;\n  long long ans = modfact(N - 1) * (N - 1) % MOD;\n  for (int i = 1; i <= N / 2 - 1; i++){\n    long long tmp1 = modfact(N - 1 - i) * modfact(i) % MOD;\n    long long tmp2 = modbinom(N - 2 - i, i);\n    long long tmp = tmp1 * tmp2 % MOD;\n    ans = modsub(ans, tmp);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\n\nint p[N], inv[N], f[N];\n\nint extgcd(int a, int b, int& x, int& y){\n\tint d = a;\n\tif (b != 0){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n\telse{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nint mod_inverse(int a){\n\tint x, y, m;\n\tm = mod;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\nvoid _init(int n){\n\tp[0] = 1;\n\tfor (int i = 1; i <= n; i++) p[i] = 1LL * p[i - 1] * i % mod;\n\tfor (int i = 0; i <= n; i++) inv[i] = mod_inverse(p[i]);\n}\n\nint C(int x, int y){\n\tif (x < y) return 0;\n\tint ret;\n\tret = p[x];\n\tret = 1LL * ret * inv[y] % mod;\n\tret = 1LL * ret * inv[x - y] % mod;\n\treturn ret;\n}\n\nint main(){\n\tint n, ans;\n\tscanf(\"%d\",&n);\n\tif (n == 2){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tif (n == 3){\n\t\tprintf(\"4\\n\");\n\t\treturn 0;\n\t}\n\t_init(n);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n - 1; i++) \n\t\tf[i] = 1LL * C(i - 1, n - i - 1) * p[i] % mod * p[n - i - 1] % mod;\n\tans = 0;\n\tfor (int i = 1; i <= n - 1; i++){\n\t\tans += 1LL * (f[i] - f[i - 1] + mod) % mod * i % mod;\n\t\tans %= mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<map>\n#include<bitset>\n#include<math.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for(int i=m;i<(int)(n);i++)\ntypedef pair<int,int> pint;\ntypedef long long ll;\nconst ll mod= 1e9+7;\nconst ll  longinf = 1LL<<60;\nint dx[4]={1,0,-1,0}, dy[4]={0,1,0,-1};\n\nll fact[1010101],invfact[1010101];\n\nll comb(int n,int k){\n  if(k<0||k>n)return 0;\n  ll ret=fact[n]*invfact[k]%mod;\n  return ret*invfact[n-k]%mod;\n  }\n\nll inv(ll n){\n  ll ret=1,k=mod-2;\n  while(k>0){\n    if(k&1)ret=ret*n %mod;\n    n=n*n %mod;\n    k/=2;\n    }\n  return ret;\n  }\n\nint main(){\n  ll n;\n  cin>>n;\n  fact[0]=invfact[0]=1;\n  rep(i,n)fact[i+1]=fact[i]*(i+1) %mod;\n  invfact[n]=inv(fact[n]);\n  rep(i,n)invfact[n-i-1]=invfact[n-i]*(n-i)%mod;\n  ll ans=fact[n-1]*(n-1) %mod;\n  for(ll i=n-2;i>=n-i;i--){\n    ll res=fact[i]*comb(i-1,n-1-i) %mod;\n    ans=(ans+mod-res)%mod;\n    }\n  cout<<ans<<endl;\n  return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\nstruct S\n{\n    int x,y,z;\n\n    bool operator<(const S &a)const{\n              return x<a.x;\n    }\n};\n\nvector<int> v;\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nlong long l[1114000];\n\nlong long o[1114211];\nint j[2];\nint dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z;\n\nP u[555320];\n//stack<int> s;\n\n//set<int> s;\nqueue<int> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<int,int> p;\n//list<int> l;\n//string r1,r;\n//char r[1152][1111];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y>b.y;\n}\n\nlong long f(int a)\n{\n    if(a<0) return 0;\n    else\n    return o[a];\n}\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b>>1);\n    x*=x,x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nlong long g(int a,int b)\n{\n    if(b<a) return 0;\n    return f(b)*(p(f(a),mod-2)*p(f(b-a,mod-2))%mod)%mod;\n}\n\n\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    o[0]=1;\n    for(int t=1;t<=a;t++)\n        o[t]=o[t-1]*t%mod;\n    //l[0]=1;\n    //for(int t=1;t<=a;t++)\n     //   l[t]=p(o[t],mod-2);\n    for(int t=2;t<a;t++)\n    {\n        y=x;\n        x=f(a-t-1)*f(t)%mod*g(a-t-1,t-1)%mod;\n        z+=(x-y+mod)%mod*t%mod;\n        z%=mod;\n        //printf(\"##%lld\\n\",x);\n        //printf(\"%lld %lld %lld\\n\",f(a-t-1),f(t),g(a-t-1,t-1));\n    }\n    printf(\"%lld\",z);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std;\n\n#define fcout(d) cout << fixed << setprecision(d)\n#define rep(i,n) for(int (i) = 0; (i) < (n); ++(i))\n#define rep1(i,n) for(int (i) = 1; (i) <= (n); ++(i))\n#define repU(i,bottom,ceiling) for(auto (i) = (bottom); (i) <= (ceiling); ++(i))\n#define repD(i,ceiling,bottom) for(auto (i) = (ceiling); (i) >= (bottom); --(i))\n#define repS(n) for(int (s) = 0; (s) < 1 << (n); ++(s))\n#define repV(i,v) for(auto (i) = begin(v); (i) < end(v); ++(i))\n#define all(v)  begin(v),end(v)\n#define clr(v) fill(all(v),0)\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define puf push_front\n#define pub push_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define fir first\n#define sec second\n#define divceil(n,d) ((n)/(d) + ((n)%(d) > 0))\n#define parity(a,b) (((a) & 1LL)^((b) & 1LL)^1LL)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\n\nconst pair<int,int> DIR[] = { {1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,1},{-1,-1},{1,-1} };\nconst int INF_32 = -1 + (1 << 30);\nconst ll INF_64 = -1 + (1LL << 62);\nconst int MOD = (int)1e9 + 7;\n\ntemplate<class T> T gcd(T a, T b){ if(a % b){ return gcd(b, a % b); }else{ return b; } }\n\ntemplate<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\n\nll Pow(ll n, ll m, int mod = MOD){\n\tll res = 1,pow = n % mod;\n\twhile(m) {\n\t\tif(m & 1) res = (res * pow) % mod;\n\t\tpow = (pow * pow) % mod;\n\t\tm >>= 1;\n\t}\n\treturn res;\n}\n\nvoid Frac_table(ll frac[], int range, int mod = MOD){\n\tfrac[0] = 1;\n\trep1(i,range) frac[i] = frac[i - 1] * i % mod;\n\treturn;\n}\n\nll Comb(int n, int m, ll frac[], int mod = MOD){\n\tif(n < m || m < 0) return 0;\n\tll rev = Pow(frac[m] * frac[n-m] % mod, mod-2, mod);\n\treturn rev * frac[n] % mod;\n}\n\nbool Prime_judge(int n){\n\tif(n <= 1 || !(n % 2)) return 0;\n\tfor(int d = 3; d * d <= n; d += 2) if(!(n % d)) return 0;\n\treturn 1;\n}\n\nvoid Prime_table(bool is_prime[], int n){\n\tfill(is_prime + 1, is_prime + n, 1);\n\trepU(i,2,n/2) is_prime[i * 2] = 0;\n\tis_prime[0] = is_prime[1] = 0;\n\tint p = 3;\n\twhile(p * p < n){\n\t\tfor(int t = p * 2; t <= n; t += p) is_prime[t] = 0;\n\t\tp += 2;\n\t\twhile(!is_prime[p]) p += 2;\n\t}\n}\n\nint main(){\n\tint N; cin>>N;\n\tll frac[1000001],cur,last = 0;\n\tll ans = 0;\n\tFrac_table(frac,N);\n\trep1(i,N - 1){\n\t\tcur = frac[i] * frac[N - i - 1] % MOD * Comb(i - 1, N - i - 1, frac) % MOD;\n\t\tans += (cur - last) * i % MOD;\n\t\tans %= MOD;\n\t\tlast = cur;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n\n\n#define INF 4000000000000000000LL\n#define MOD 1000000007\n#define ALL(x) std::begin(x), std::end(x)\n\n\nlong long modpow(long long x, long long y)\n{\n  long long p = 1;\n\n  for ( ; y; (x *= x) %= MOD, y >>= 1)\n    if (y & 1)\n      (p *= x) %= MOD;\n\n  return p;\n}\n\nclass modint_t {\n  friend std::ostream& operator<<(std::ostream& ofs, const modint_t a);\n\npublic:\n  modint_t(long long xx = 0) : x(xx % MOD) {};\n\npublic:\n  bool operator==(long long a) const {\n    return x == a;\n  };\n\npublic:\n  long long value() const {\n    return x;\n  };\n\npublic:\n  modint_t operator+(const modint_t& a) const {\n    return (x + a.x) % MOD;\n  };\n\n  modint_t operator-(const modint_t& a) const {\n    return (x - a.x) % MOD;\n  };\n\n  modint_t operator*(const modint_t& a) const {\n    return x * a.x % MOD;\n  };\n\n  modint_t operator/(const modint_t& a) const {\n    return (*this) * a.inverse();\n  };\n\n  // Note that operator^'s priority is quite low in C++...\n  modint_t operator^(long long i) const {\n    return modint_t(modpow(x, i));\n  };\n\npublic:\n  modint_t& operator+=(const modint_t& a) {\n    (x += a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator-=(const modint_t& a) {\n    (x -= a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator*=(const modint_t& a) {\n    (x *= a.x) %= MOD;\n\n    return *this;\n  };\n\n  modint_t& operator/=(const modint_t& a) {\t// Not tested\n    (x *= a.inverse().x) %= MOD;\n\n    return *this;\n  };\n\npublic:\n  modint_t inverse() const {\n    assert(x % MOD);\n\n    return modint_t(modpow(x, MOD - 2));\n  };\n\npublic:\n  modint_t normalized() const {\n    return modint_t(x % MOD + MOD);\n  };\n\nprivate:\n  long long x;\n};\n\nmodint_t operator-(long long a, const modint_t& b)\n{\n  return modint_t(a) - b;\n}\n\nmodint_t operator*(long long a, const modint_t& b)\n{\n  return modint_t(a) * b;\n}\n\nmodint_t operator/(long long a, const modint_t& b)\n{\n  return modint_t(a) / b;\n}\n\nstd::ostream& operator<<(std::ostream& ofs, const modint_t a)\n{\n  ofs << a.x;\n\n  return ofs;\n}\n\n\nmodint_t memo[1111111], memo2[1111111];\n\n\nint main(int argc, char** argv)\n{\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(0);\n\n  std::cout << std::fixed << std::setprecision(6);\n  std::cerr << std::fixed << std::setprecision(6);\n\n  memo[0] = memo[1] = 1;\n  \n  for (int i = 2; i < 1111111; i ++)\n    memo[i] = memo[i - 1] * i;\n\n  memo2[0] = memo2[1] = 1;\n\n  for (int i = 2; i < 1111111; i ++)\n    memo2[i] = memo2[i - 1] / i;\n\n  int N;\n  \n  std::cin >> N;\n\n  if (N == 2) {\n    std::cout << 1 << std::endl;\n\n    return 0;\n  }\n  else if (N == 3) {\n    std::cout << 4 << std::endl;\n  }\n  else if (N == 4) {\n    std::cout << 16 << std::endl;\n\n    return 0;\n  }\n\n  modint_t C = 0, c = 0;\n\n  for (int K = (N + 1) / 2; K < N; K ++) {\n    modint_t k = K - 1, l = (N - 2) - k, m = k - l;\n    \n    modint_t cc = memo[(l + m).value()] * memo2[l.value()] * memo2[m.value()] * memo[K] * memo[N - 1 - K];\n\n    C += (cc - c) * K;\n\n    c = cc;\n  }\n\n  std::cout << C.normalized() << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 5100000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n    COMinit();\n    int N;\n    cin >> N;\n\n    vector<long long> A(N, 0);\n    for(int k = (N + 1) / 2; k < N; ++k) {\n        A[k] = (COM(k - 1, N - k - 1) * fac[k] % MOD) * fac[N - k - 1] % MOD;\n    }\n\n    long long res = 0;\n    for(int k = (N + 1) / 2; k < N; ++k) {\n        res += k * (A[k] - A[k - 1]) % MOD;\n        res %= MOD;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 1000000;\nconst int MOD = 1e9 + 7;\n\nint inv(int a)\n{\n    return a == 1 ? 1 : 1LL * (MOD - MOD / a) * inv(MOD % a) % MOD;\n}\n\nint solve(int n)\n{\n    if (n == 2) {\n        return 1;\n    }\n    static int fact[N];\n    fact[0] = 1;\n    for (int i = 1; i < n; ++ i) {\n        fact[i] = 1LL * fact[i - 1] * i % MOD;\n    }\n    int result = 1LL * n * fact[n - 1] % MOD;\n    for (int k = 2; k < n; ++ k) {\n        if (k + k >= n) {\n            int ways = 1LL * fact[k - 1] * inv(fact[k + k - n]) % MOD * fact[k] % MOD;\n            result += MOD - ways;\n            if (result >= MOD) {\n                result -= MOD;\n            }\n        }\n    }\n    return result;\n\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\\n\", solve(n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define rep(i, n) for(int i=0;i<n;i++)\n#define pb(x) push_back(x)\n#define all(x) (x).begin(), (x).end()\n#define szz(x) (int)(x).size()\n#define Fi first\n#define Se second\ntypedef long double ldouble;\n\nconst ll MOD = 1e9 + 7;\n\nll pw(ll x, ll y = MOD - 2) {\n\tll res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll F[2000020];\n\nll nCr(int n, int r) { return F[n] * pw(F[r]) % MOD * pw(F[n-r]) % MOD; }\n\nvoid solve(){\n\tF[0] = 1;\n\tfor(int i=1;i<2000020;i++) F[i] = i * F[i-1] % MOD;\n\tint n; scanf(\"%d\", &n);\n\tll ans = F[n-1];\n\tfor(int i=1;i<n-1;i++) {\n\t\tll val = nCr(n-1, i);\n\t\tif(2*i-1 >= n-1) {\n\t\t\tval -= nCr(i-1, n-1-i);\n\t\t\tif(val < 0) val += MOD;\n\t\t}\n\t\tval = val * F[i] % MOD * F[n-1-i] % MOD;\n\t\tans = (ans + val) % MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\t//DM(); return 0;\n\tint tc = 1; // scanf(\"%d\", &tc);\n\tfor(int t=1;t<=tc;t++) {\n\t//\tprintf(\"Case #%d: \", t);\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define INF 1000000001\n#define INFL (1LL << 60)\n#define MOD 1000000007\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n#define ll long long int\n#define P pair<ll, ll>\n\nll fac[1000001];\nll pat[1000001] = { };\n\nll POW(ll a, ll b){\n  if(b == 0) return 1;\n  if(b == 1) return a;\n  if(b%2 == 1) return (a*POW(a, b-1))%MOD;\n  ll x = POW(a, b/2);\n  return (x*x)%MOD;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  n--;\n  fac[0] = 1;\n  REP(i, 1000000) fac[i+1] = (fac[i] * (i+1))%MOD;\n  FOR(i, n/2+1, n+1){\n    pat[i] = fac[i-1];\n    (pat[i] *= fac[i]) %= MOD;\n    (pat[i] *= POW(fac[2*i-n-1], MOD-2)) %= MOD;\n  }\n  ll ans = 0;\n  FOR(i, 1, n+1){\n    (ans += (i*(pat[i]-pat[i-1] + MOD))) %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1000000\n#define mod 1000000007\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\ninline void Add(int &x,int y)\n{\n\tx+=y; if(x>=mod) x-=mod; \n\tif(x<0) x+=mod;\n}\ninline int qpow(int bas,int pw)\n{\n\tint ret=1; for(;pw;pw>>=1,bas=1ll*bas*bas%mod)\n\t\tif(pw&1) ret=1ll*ret*bas%mod; return ret;\n}\nint fac[N+10],inv[N+10],n,Ans,per,cur;\ninline int C(int n,int m)\n{\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n\tfac[0]=1; for(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tinv[N]=qpow(fac[N],mod-2);\n\tfor(int i=N-1;i>=0;i--)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tcin >> n; for(int i=(n+1)/2;i<n;i++)\n\t{\n\t\tper=cur;\n\t\tcur=1ll*C(i-1,n-i-1)*fac[i]%mod*fac[n-i-1]%mod;\n\t\tAdd(Ans,1ll*(cur-per)*i%mod);\n\t}\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef INPUT\n#include <sstream>\nstringstream input(R\"(\n2\n80 70\n)\");\n#define cin input\n#endif\n\n#include <iostream>\n#include <string>\n#include <array>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\n#define FOR(i, a, b) for(decltype(b) i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\n\nusing namespace std;\n\nll inv_mod( ll a, ll m )\n{\n  ll b, x, u, q, abs_m, tmp; \n\n  abs_m = ( m < 0 ) ? -m : m;\n  b = m; x = 1; u = 0; \n  while ( b > 0 ) {\n    q = a / b; \n    tmp = u; u = x - q * u; x = tmp;\n    tmp = b; b = a - q * b; a = tmp;\n  }\n\n  return ( x < 0 ) ? abs_m + x : x;\n}\n\nint main()\n{\n    const ll mod = 1000000007;\n\tll n;\n\tcin >> n;\n    --n;\n\n    vector<ll> frac(n + 1);\n    frac[0] = 1;\n    REP(i, n)\n        frac[i + 1] = frac[i] * (i + 1) % mod;\n\n    vector<ll> fraci(n + 1);\n    fraci[n] = inv_mod(frac[n], mod);\n    for (int i = n; i > 0; --i)\n        fraci[i - 1] = fraci[i] * i % mod;\n\n    ll r = 0;\n    ll c = 0;\n\n    for (int i = (n - 1) / 2; i >= 0; --i)\n    {\n        ll x = (frac[n - i - 1] * (fraci[n - 1 - i * 2] % mod * fraci[i] % mod)) % mod * (frac[i] * frac[n - i] % mod) % mod;\n        r += (x + mod - c) % mod * (n - i) % mod;\n        r %= mod;\n        c += (x + mod - c) % mod;\n        c %= mod;\n    }\n\n\tcout << r << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=1000000007; //1000000000000000003LL\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//[HEAD_OF_JKI'S_HEADER_\n\n    //TYPEDEF\n    typedef long long lld;\n    typedef unsigned long long u64;\n    typedef pair<int, int> pii;\n\n    //COMPARE\n    template<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n    template<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n    template<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n    template<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n    //STL\n    template<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n    template<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n    template<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n    //BIT\n    inline int BINT(const int x){ return 1<<x; }\n    inline lld BLLD(const int x){ return 1LL<<x; }\n    inline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n    inline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n    template<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n    template<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n    //CONST VALUE\n    const double PI=acos(-1.0);\n    const double EPS=1e-5;\n\n    //CALCULATE\n    template<class T> inline T SQR(const T x){ return x*x; }\n    template<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n        if(!y)return 1;else if((y&1)==0){\n            return SQR(POW(x, y>>1));\n        }else return POW(x, y^1)*x;\n    }\n\n    //NUMBERIC\n    template<class T> inline T GCD(const T x, const T y){\n        if(x<0)return GCD(-x, y);\n        if(y<0)return GCD(x, -y);\n        return (!y)?x:GCD(y, x%y);\n    }\n    template<class T> inline T LCM(const T x, const T y){\n        if(x<0)return LCM(-x, y);\n        if(y<0)return LCM(x, -y);\n        return x*(y/GCD(x, y));\n    }\n    template<class T> inline T EEA(const T a, const T b, T &x, T &y){\n        /* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n        if(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n        if(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n        if(!b){\n            x=1; y=0; return a;\n        }else{\n            T d=EEA(b, a%b, x, y);\n            T t=x; x=y; y=t-(a/b)*y;\n            return d;\n        }\n    }\n    template<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n        vector<pair<T, int> > ret;\n        if(x<0)x=-x;\n        for (T i=2;x>1;){\n            if(x%i==0){\n                int count=0;\n                for(;x%i==0;x/=i)count++;\n                ret.push_back(MP(i, count));\n            }\n            i++;if(i>x/i)i=x;\n        }\n        return ret;\n    }\n    template<class T> inline int ISPRIME(const T x){\n        if(x<=1)return 0;\n        for(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n        return 1;\n    }\n    template<class T> inline T EULARFUNCTION(T x){\n        vector<pair<T, int> > f=FACTORIZE(x);\n        for(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n            x=x/it->first*(it->first-1);\n        }\n        return x;\n    }\n    template<class T> inline T INVERSEE(const T a, const T b=MOD){\n        T x, y;\n        EEA(a, b, x, y);\n        return x?x:1;\n    }\n    int *PRIMELIST(const int til, int *length=NULL){\n        int *foo=(int*)malloc(sizeof(int)*(til+1));\n        int len=0;\n        memset(foo, 0, sizeof(int)*(til+1));\n        for(int i=2; i<=til; i++){\n            if(!foo[i])foo[len++]=i;\n            for(int j=0; j<len && foo[j]<=til/i; j++){\n                foo[foo[j]*i]=1;\n                if(i%foo[j]==0)break;\n            }\n        }\n        if(length!=NULL){\n            *length=len;\n        }\n        foo[len++]=0;\n        foo=(int*)realloc(foo, sizeof(int)*len);\n        return foo;\n    }\n\n    //REMINDER-LIZATION\n    template<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n    template<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n    template<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n    template<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n    template<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n    template<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n    template<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n        if(y==0)return 1%m;else if((y&1)==0){\n            T1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n        }else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n    }\n    inline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n        MOD_STD(&x, m);\n        MOD_STD(&y, m);\n        if(x<y)swap(x, y);\n        lld z=0LL;\n        while(y>0){\n            if(y&1){\n                MOD_ADD(&z, x, m);\n            }\n            MOD_ADD(&x, x, m);\n            y>>=1;\n        }\n        return z;\n    }\n    inline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n        if(y==0LL)return 1LL%m;else if((y&1)==0LL){\n            lld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n        }else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n    }\n\n    //General\n    template<class T> class cycleq_t{\n        private:\n        size_t cnt, cap;\n        size_t lef, rig;\n        T *que;\n        public:\n        cycleq_t(const size_t size){\n            this->cap=size;\n            this->que=(T*)malloc(sizeof(T)*size);\n            this->clear();\n        }\n        ~cycleq_t(){\n            free(this->que);\n        }\n        inline void clear(){\n            this->lef=this->rig=0;\n            this->cnt=0;\n        }\n        inline void put(const T &obj){\n            assert(this->cnt<this->cap);\n            this->que[this->rig++]=obj;\n            if(this->rig==this->cap)\n                this->rig=0;\n            this->cnt++;\n        }\n        inline void put_back(const T &obj){\n            this->put(obj);\n        }\n        inline void put_front(const T &obj){\n            assert(this->cnt<this->cap);\n            this->lef--;\n            if(!~this->lef)\n                this->lef=this->cap-1;\n            this->que[this->lef]=obj;\n            this->cnt++;\n        }\n        inline T pop(){\n            assert(this->cnt>0);\n            T res=this->que[this->lef++];\n            if(this->lef==this->cap)\n                this->lef=0;\n            this->cnt--;\n            return res;\n        }\n        inline T pop_front(){\n            return this->pop();\n        }\n        inline T pop_back(){\n            assert(this->cnt>0);\n            this->rig--;\n            if(!~this->rig)\n                this->rig=this->cap-1;\n            this->cnt--;\n            return this->que[this->rig];\n        }\n        inline T get(int64_t offset=0){\n            if(offset>=0){\n                assert(offset<this->cnt);\n                offset+=this->lef;\n                if(offset>this->cap)\n                    offset-=this->cap;\n                return this->que[offset];\n            }else{\n                assert(offset>=-this->cnt);\n                offset+=this->rig;\n                if(offset<0)\n                    offset+=this->cap;\n                return this->que[offset];\n            }\n        }\n    };\n\n    //MATRIX\n    template<class T> class MATX{\n        private:\n            unsigned long hig, wid;\n            T *data;\n\n            void __init(){\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                memset(this->data, 0, sizeof(T)*this->hig*this->wid);\n            }\n\n        public:\n            MATX(){ \n                this->hig=this->wid=1;\n                __init();\n            }\n            MATX(const unsigned long _len){\n                this->hig=this->wid=_len;\n                __init();\n            }\n            MATX(const unsigned long _hig, const unsigned long _wid){\n                this->hig=_hig;\n                this->wid=_wid;\n                __init();\n            }\n            MATX(const MATX &rhs){\n                this->hig=rhs.hig;\n                this->wid=rhs.wid;\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n            }\n            ~MATX(){\n                free(this->data);\n            }\n\n            T & operator()(const unsigned long x, const unsigned long y){\n                if(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n                return this->data[x*this->wid+y];\n            }\n\n            T * operator[](const unsigned long x){\n                if(x>=this->hig)return (T*)NULL;\n                return this->data+(x*this->wid);\n            }\n\n            MATX & operator=(const MATX &rhs){\n                if(this->hig!=rhs.hig || this->wid!=rhs.wid){\n                    free(this->data);\n                    this->hig=rhs.hig;\n                    this->wid=rhs.wid;\n                    this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                }\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n                return *this;\n            }\n\n            const MATX operator+(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]+=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator-(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]-=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator*(const MATX &opn) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.hig);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            ret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n                return ret;\n            }\n\n            const MATX mul(const MATX &opn) const{ return *this*opn; }\n            template<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.wid);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            MOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n                return ret;\n            }\n\n            MATX & operator +=(const MATX &rhs){\n                *this=*this+rhs;\n                return *this;\n            }\n            MATX & operator -=(const MATX &rhs){\n                *this=*this-rhs;\n                return *this;\n            }\n            MATX & operator *=(const MATX &rhs){\n                *this=*this*rhs;\n                return *this;\n            }\n\n            const MATX pow(const unsigned long p) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret*=buff;\n                    buff*=buff;\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n            template<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret=ret.mul(buff, m);\n                    buff=buff.mul(buff, m);\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n\n\n            const T at(const unsigned long x, const unsigned long y) const{\n                if(x>=this->hig || y>=this->wid)return 0;\n                return this->data[x*wid+y];\n            }\n\n            void show() const{\n                for(unsigned long x=0; x<this->hig; x++){\n                    for(unsigned long y=0; y<this->wid; y++)\n                        cout<<this->at(x, y)<<\" \";\n                    cout<<endl;\n                }\n            }\n\n            void set_one(){\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=(x==y)?1:0;\n            }\n\n    };\n\n    //Complex\n    template<class T> class complex_t{\n        public:\n        T r, i;//real part & imaginary part; x+yi\n        complex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n        complex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n        complex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n        complex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n    };\n\n    template<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n        for(int i=1, j=len>>1; i<len-1; i++){\n            if(i<j)swap(f[i], f[j]);\n            int k=len>>1;\n            while(j>=k){\n                j-=k;\n                k>>=1;\n            }\n            if(j<k)j+=k;\n        }\n        for(int h=2; h<=len; h<<=1){\n            complex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n            for(int i=0; i<len; i+=h){\n                complex_t<T> wm(1.0, 0.0);\n                for(int j=i; j<i+(h>>1); j++){\n                    complex_t<T> u = f[j];\n                    complex_t<T> t = wm*f[j+(h>>1)];\n                    f[j] = u+t;\n                    f[j+(h>>1)] = u-t;\n                    wm = wm*wn;\n                }\n            }\n        }\n        if(!is_dft){\n            for(int i=0; i<len; i++)\n                f[i].r/=len*1.0;\n        }\n    }\n\n    //MILLERRABIN\n    class MILLERRABIN{\n        private:\n        static const int prime_table[12];\n        int witness(lld a, lld d, lld s, lld n){\n            lld r=MODL_POW(a, d, n);\n            if(r==1 || r==n-1)return 0;\n            for(int i=0; i<s-1; i++){\n                r = MODL_MUL(r, r, n);\n                if(r==1)return 1;\n                if(r==n-1)return 0;\n            }\n            return 1;\n        }\n        public:\n        int test(const lld n){\n            if(n<=2LL) return 0;\n            lld p=n-1LL, s=0LL;\n            while(!(p&1)){ p>>=1;s++; }\n            for(int i=0; i<12 && this->prime_table[i]<n; i++){\n                if(witness(this->prime_table[i], p, s, n))return 0;\n            }\n            return 1;\n        }\n    };\n    const int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n    //Computational Geometry\n\n    template<class T> inline int fsign(const T x){\n        if(x>-eps && x<eps)return 0;\n        return (x<0.0)?-1:1;\n    }\n\n    template<class T> class point_t{\n        public:\n        T x, y;\n        point_t (){\n            this->x=0.0;\n            this->y=0.0;\n        }\n        point_t (const T _x, const T _y){\n            this->x=_x;\n            this->y=_y;\n        }\n        point_t operator - (const point_t &rhs) const{\n            return point_t(this->x-rhs.x, this->y-rhs.y);\n        }\n        T operator ^ (const point_t &rhs) const{\n            return this->x*rhs.y - this->y*rhs.x;\n        }\n        T operator * (const point_t &rhs) const{\n            return this->x*rhs.x + this->y*rhs.y;\n        }\n        bool operator < (const point_t &rhs) const{\n            if(fsign(this->y-rhs.y)!=0)\n                return fsign(this->y-rhs.y)<0;\n            return fsign(this->x-rhs.x)<0;\n        }\n        T cross(const point_t &p, const point_t &q) const{\n            return (p-*this)^(q-*this);\n        }\n        void rotate(const double radian){\n            T x0=x, y0=y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr;\n            y=x0*sinr+y0*cosr;\n        }\n        void rotate(const point_t &p, const double radian){\n            T x0=x-p.x, y0=y-p.y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr+p.x;\n            y=x0*sinr+y0*cosr+p.y;\n        }\n        T dist2(const point_t &lhs, const point_t &rhs) const{\n            return (lhs-rhs)*(lhs-rhs);\n        }\n        T dist2(const point_t &rhs) const{\n            return (*this-rhs)*(*this-rhs);\n        }\n        T dist(const point_t &lhs, const point_t &rhs) const{\n            return sqrt((lhs-rhs)*(lhs-rhs));\n        }\n        T dist(const point_t &rhs) const{\n            return sqrt((*this-rhs)*(*this-rhs));\n        }\n    };\n\n    template<class T> class segment_t{\n        public:\n        point_t<T> p, q;\n        segment_t (){\n            this->p.x=this->p.y=0.0;\n            this->q.x=this->q.y=0.0;\n        }\n        template<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n            this->p.x=_p.x;\n            this->p.y=_p.y;\n            this->q.x=_q.x;\n            this->q.y=_q.y;\n        }\n        segment_t (const T px, const T py, const T qx, const T qy){\n            this->p.x=px;\n            this->p.y=py;\n            this->q.x=qx;\n            this->q.y=qy;\n        }\n        T length() const{\n            return this->p.dist(this->q);\n        }\n        T length2() const{\n            return this->p.dist2(this->q);\n        }\n        int contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n            if(ignore_endpoint){\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n            }else{\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n            }\n        }\n        int intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n            if(!ignore_endpoint){\n                if(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n                    return 1;\n            }\n            return fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n                && fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n        }\n        int intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n            return this->intersection(*this, rhs, ignore_endpoint);\n        }\n    };\n\n    #ifndef __APPLE__\n    template<class T> static int compare_pas(const void *x, const void *y, void *z){\n    #else\n    template<class T> static int compare_pas(void *z, const void *x, const void *y){\n    #endif\n        const point_t<T> *p1 = (point_t<T>*)x;\n        const point_t<T> *p2 = (point_t<T>*)y;\n        const point_t<T> *p0 = (point_t<T>*)z;\n        int sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n        if(sgn!=0)return -sgn;\n        return fsign(p0->dist2(*p1)-p0->dist2(*p2));\n    }\n    template<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n        int p=0;\n        for(int i=1; i<n; i++){\n            if(pnts[p]<pnts[i])p=i;\n        }\n        swap(pnts[0], pnts[p]);\n        #ifndef __APPLE__\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n        #else\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), pnts, compare_pas<T>);\n        #endif\n    }\n\n    template<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n        polar_angle_sort(pnts, n);\n        m=0;\n        if(n<3)return;\n        idx[m++]=0;\n        idx[m++]=1;\n        for(int i=2; i<n; i++){\n            while(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n            idx[m++]=i;\n        }\n    }\n\n    //Graph\n    template<class T> class maxflow_c{\n        private:\n        size_t capv, cape;\n        size_t cntv, cnte;\n        struct mf_edge_t;\n        struct mf_vertex_t{\n            mf_edge_t *head, *hold;\n            size_t idx, hig;\n        } *vertex, **vhead, **vtail, **vque;\n        struct mf_edge_t{\n            mf_vertex_t *src, *dst;\n            mf_edge_t *nxt, *rsv;\n            T cap, cur;\n        } *edge_pool, *edge_tail, **esup;\n        struct dncnode_t{\n            mf_vertex_t *vtx;\n            T precap, reflux;\n        } *dinic_stack_pool;\n        size_t *dcnt;\n        size_t higlev(size_t src, size_t trm, const int reverse=0){\n            if(reverse)\n                swap(src, trm);\n            if(this->vque==NULL)\n                this->vque=(mf_vertex_t**)malloc(sizeof(mf_vertex_t*)*this->capv);\n            size_t lef=0, rig=0;\n            for(mf_vertex_t **vtxp=this->vhead; vtxp!=this->vtail; vtxp++)\n                (*vtxp)->hig=numeric_limits<size_t>::max();\n            this->vertex[src].hig=0;\n            this->vque[rig++]=&this->vertex[src];\n            this->vertex[trm].hig=numeric_limits<size_t>::max();\n            for(; lef<rig; lef++){\n                mf_vertex_t *vtx=this->vque[lef];\n                for(mf_edge_t *edge=vtx->head; edge!=NULL; edge=edge->nxt){\n                    if(!reverse){\n                        if(edge->cur<edge->cap && edge->dst->hig>vtx->hig+1){\n                            edge->dst->hig=vtx->hig+1;\n                            this->vque[rig++]=edge->dst;\n                        }\n                    }else{\n                        if(edge->rsv->cur<edge->rsv->cap && edge->dst->hig>vtx->hig+1){\n                            edge->dst->hig=vtx->hig+1;\n                            this->vque[rig++]=edge->dst;\n                        }\n                    }\n                }\n            }\n            this->vque[rig++]=NULL;\n            return this->vertex[trm].hig;\n        }\n        T isap_augment(const size_t src, const size_t trm){\n            T inc=numeric_limits<T>::max();\n            for(size_t i=trm; i!=src; i=this->esup[i]->src->idx){\n                UPDMIN(inc, this->esup[i]->cap-this->esup[i]->cur);\n            }\n            for(size_t i=trm; i!=src; i=this->esup[i]->src->idx){\n                this->esup[i]->cur+=inc;\n                this->esup[i]->rsv->cur-=inc;\n            }\n            return inc;\n        }\n        size_t isap_retreat(size_t &i, const size_t src){\n            size_t best=numeric_limits<size_t>::max();\n            for(mf_edge_t *edge=this->vertex[i].head; edge!=NULL; edge=edge->nxt){\n                if(edge->cur<edge->cap){\n                    UPDMIN(best, edge->dst->hig+1);\n                }\n            }\n            size_t rep=--this->dcnt[this->vertex[i].hig];\n            this->vertex[i].hig=best;\n            if(best<this->cntv){\n                this->dcnt[best]++;\n            }\n            if(i!=src)\n                i=this->esup[i]->src->idx;\n            return rep;\n        }\n        public:\n        maxflow_c(const size_t numv, const size_t nume){\n            this->capv=numv;\n            this->cape=nume;\n            this->vertex=(mf_vertex_t*)malloc(sizeof(mf_vertex_t)*numv);\n            for(size_t i=0; i<numv; i++){\n                this->vertex[i].idx=i;\n            }\n            this->vhead=(mf_vertex_t**)malloc(sizeof(mf_vertex_t*)*numv);\n            this->vtail=this->vhead;\n            this->vque=NULL;\n            this->edge_pool=(mf_edge_t*)malloc(sizeof(mf_edge_t)*(nume<<1));\n            this->dinic_stack_pool=NULL;\n            this->esup=NULL;\n            this->dcnt=NULL;\n            this->reset();\n        };\n        ~maxflow_c(){\n            if(this->dcnt!=NULL)\n                free(this->dcnt);\n            if(this->esup!=NULL)\n                free(this->esup);\n            if(this->dinic_stack_pool!=NULL)\n                free(this->dinic_stack_pool);\n            free(this->edge_pool);\n            if(this->vque!=NULL)\n                free(this->vque);\n            free(this->vhead);\n            free(this->vertex);\n        }\n        void reset(){\n            for(size_t i=0; i<this->capv; i++)\n                this->vertex[i].head=NULL;\n            this->vtail=this->vhead;\n            this->edge_tail=this->edge_pool;\n            this->cntv=0;\n            this->cnte=0;\n        }\n        void add_edge(const size_t u, const size_t v, const T c, const T r=0){\n            assert(u<this->capv && v<this->capv);\n            assert(this->cnte<this->cape);\n            this->edge_tail->nxt=this->vertex[u].head;\n            this->edge_tail->rsv=this->edge_tail+1;\n            this->edge_tail->src=&this->vertex[u];\n            this->edge_tail->dst=&this->vertex[v];\n            this->edge_tail->cap=c;\n            this->edge_tail->cur=0;\n            if(this->vertex[u].head==NULL){\n                *this->vtail++=&this->vertex[u];\n                this->cntv++;\n            }\n            this->vertex[u].head=this->edge_tail++;\n            this->edge_tail->nxt=this->vertex[v].head;\n            this->edge_tail->rsv=this->edge_tail-1;\n            this->edge_tail->src=&this->vertex[v];\n            this->edge_tail->dst=&this->vertex[u];\n            this->edge_tail->cap=r;\n            this->edge_tail->cur=0;\n            if(this->vertex[v].head==NULL){\n                *this->vtail++=&this->vertex[v];\n                this->cntv++;\n            }\n            this->vertex[v].head=this->edge_tail++;\n            this->cnte++;\n        }\n        T dinic(const size_t src, const size_t trm){\n            assert(src<this->capv && trm<this->capv && src!=trm);\n            T foo=0;\n            if(this->dinic_stack_pool==NULL)\n                this->dinic_stack_pool=(dncnode_t*)malloc(sizeof(dncnode_t)*this->capv);\n            while(higlev(src, trm)<numeric_limits<size_t>::max()){\n                for(size_t i=0; this->vque[i]!=NULL; i++){\n                    this->vque[i]->hold=this->vque[i]->head;\n                }\n                dncnode_t *top=this->dinic_stack_pool;\n                top->vtx=&this->vertex[src];\n                top->precap=numeric_limits<T>::max();\n                top->reflux=0;\n                while(this->vertex[src].hold!=NULL){\n                    if(top->vtx->idx!=trm && top->vtx->hold!=NULL && top->vtx->hold->cur<top->vtx->hold->cap && top->vtx->hold->src->hig+1==top->vtx->hold->dst->hig){\n                        dncnode_t *prv=top++;\n                        top->vtx=prv->vtx->hold->dst;\n                        top->precap=MIN(prv->precap-prv->reflux, prv->vtx->hold->cap-prv->vtx->hold->cur);\n                        top->reflux=0;\n                    }else if(top->vtx->idx==trm){\n                        T inc=top->precap;\n                        foo+=inc;\n                        while(top->precap==top->reflux+inc){\n                            inc+=top->reflux;\n                            top--;\n                            top->vtx->hold->cur+=inc;\n                            top->vtx->hold->rsv->cur-=inc;\n                        }\n                        top->reflux+=inc;\n                    }else{\n                        if(top->vtx->hold==NULL){\n                            T ref=top->reflux;\n                            top--;\n                            top->vtx->hold->cur+=ref;\n                            top->vtx->hold->rsv->cur-=ref;\n                            top->reflux+=ref;\n                        }\n                        top->vtx->hold=top->vtx->hold->nxt;\n                    }\n                }\n            }\n            return foo;\n        }\n        T isap(const size_t src, const size_t trm){\n            assert(src<this->capv && trm<this->capv && src!=trm);\n            T foo=0;\n            if(higlev(src, trm, 1)<numeric_limits<size_t>::max()){\n                if(this->dcnt==NULL)this->dcnt=(size_t*)malloc(sizeof(size_t)*this->capv);\n                if(this->esup==NULL)this->esup=(mf_edge_t**)malloc(sizeof(mf_edge_t*)*this->capv);\n                for(size_t i=0; i<this->cntv; i++)this->dcnt[i]=0;\n                for(size_t i=0; this->vque[i]!=NULL; i++){\n                    this->vque[i]->hold=this->vque[i]->head;\n                    this->dcnt[this->vque[i]->hig]++;\n                }\n                size_t i=src;\n                while(this->vertex[src].hig<this->cntv){\n                    mf_edge_t *edge=this->vertex[i].hold;\n                    while(edge!=NULL && !(edge->cur<edge->cap && edge->src->hig==edge->dst->hig+1)){\n                        edge=edge->nxt;\n                    }\n                    if(edge!=NULL){\n                        this->vertex[i].hold=edge;\n                        this->esup[edge->dst->idx]=edge;\n                        i=edge->dst->idx;\n                        if(i==trm){\n                            foo+=isap_augment(src, trm);\n                            i=src;\n                        }\n                    }else{\n                        this->vertex[i].hold=this->vertex[i].head;\n                        if(isap_retreat(i, src)==0)\n                            break;\n                    }\n                }\n            }\n            return foo;\n        }\n    };\n\n//]TAIL_OF_JKI'S_HEADER\n\nint f[1100000];\nint g[1100000];\n\ninline int bcoe(const int x, const int y){\n    assert(x>=0);\n    assert(y>=0);\n    assert(y<=x);\n    return MOD_MUL(MOD_MUL(f[x], g[x-y]), g[y]);\n}\n\nint main(){\n    f[0]=1;\n    for(int i=1; i<=1000000; i++)f[i]=MOD_MUL(f[i-1], i);\n    for(int i=0; i<=1000000; i++)g[i]=INVERSEE(f[i]);\n    int n;\n    while(scanf(\"%d\", &n)!=EOF){\n        int foo=0;\n        int neg=0;\n        for(int k=1; k<n; k++){\n            if(k+k<n)continue;\n            int tmp=MOD_MUL(MOD_MUL(bcoe(k-1, n-k-1), f[k]), f[n-k-1]);\n            MOD_ADD(&tmp, -neg);\n            MOD_ADD(&foo, MOD_MUL(tmp, k));\n            MOD_ADD(&neg, tmp);\n            //fprintf(stderr, \"k=%d, sample=%d\\n\", k,  MOD_STD(tmp));\n        }\n        MOD_STD(&foo);\n        printf(\"%d\\n\", foo);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll F[1000010] = {1},R[1000010];\nll mem[1000010];\nll mod = 1000000007;\nll ans;\n\nll pow_mod(ll a,ll b)\n{\n    if(b == 0)return 1;\n    ll res = pow_mod(a * a % mod, b / 2);\n    if(b & 1)res = res * a % mod;\n    return res;\n}\n\nll con(int a,int b)\n{\n    if(a < b)return 0;\n    return F[a] * R[b] % mod * R[a - b] % mod;\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n\n    if(N == 2)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    for(int i = 1; i < 1000010; i++)F[i] = F[i - 1] * i % mod;\n    for(int i = 0; i < 1000010; i++)R[i] = pow_mod(F[i],mod - 2);\n\n    for(int i = 0; i < N; i++)\n    {\n        if((N + 1) / 2 > i)continue;\n        mem[i] = con(i - 1,N - 1 - i) * F[i] % mod * F[N - 1 - i] % mod;\n        ans += (mem[i] - mem[i - 1]) * (ll)i % mod;\n        ans = (ans + mod) % mod;\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n\ni64 MOD = 1e9 + 7;\ni64 inv_mod(i64 a, i64 m = MOD) {\n  i64 b, x, u, q, abs_m, tmp;\n\n  abs_m = (m < 0) ? -m : m;\n  b = m;\n  x = 1;\n  u = 0;\n  while (b > 0) {\n    q = a / b;\n    tmp = u;\n    u = x - q * u;\n    x = tmp;\n    tmp = b;\n    b = a - q * b;\n    a = tmp;\n  }\n\n  return (x < 0) ? abs_m + x : x;\n}\nint main(){\n  int N;\n  cin >> N;\n\n  if(N == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  else if(N == 3){\n    cout << 4 << endl;\n    return 0;\n  }\n\n  vector<i64> fact(1010101,0);\n  fact[0] = 1;\n  rep(i,1,1010100){\n    fact[i] = (fact[i - 1] * i) % MOD;\n  }\n  vector<i64> inv_fact(1010101,0);\n  inv_fact[1010100] = inv_mod(fact[1010100]);\n  for(int i = 1010100 - 1;i >= 0;i--){\n    inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n  }\n  i64 ans = 0;\n\n  i64 before = 0;\n  rep(i,1,N - 1){\n    i64 p = fact[i] * fact[N - i - 1];\n    p %= MOD;\n    int n = i - 1;\n    int r = N - i - 1;\n    if(n < r) continue;\n    i64 q = (fact[n] * inv_fact[r]) % MOD ;\n    q = (q * inv_fact[n - r]) % MOD;\n    ans = (ans + ((p * q % MOD + MOD - before) % MOD) * i) % MOD;\n    before = q * p % MOD;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define queue QQQ\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e6+233; \nconst int mod = 1e9+7;\nint fac[maxn],inv[maxn],f[maxn],n;\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\ninline int C(int n,int m){\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n-m] % mod;\n}\nint main(){\n\tn=rd();\n\tfac[0] = 1;\n\tRep(i,1,n) fac[i] = 1ll * fac[i-1] * i % mod;\n\tinv[n] = qpow(fac[n],mod-2);\n\tDep(i,n-1,0) inv[i] = 1ll * inv[i+1] * (i+1) % mod;\n\tDep(i,n-1,(n+1)/2){\n\t\tf[i] = 1ll * C(i-1,n-1-i) * fac[i] % mod * fac[n-1-i] % mod;\n\t\tf[i+1] = (f[i+1] - f[i] + mod) % mod;\n\t}\n\tint ans = 0;\n\tDep(i,n-1,(n+1)/2) ans = (ans + 1ll * i * f[i] % mod) % mod;\n\twriteln(ans);\n}\n//f[i]表示答案小于等于i的方案数：i步可以完成\n//也就是相当于有i个变量 \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,ans=0;\n  cin>>N;\n  COMinit();\n  ll cnt[N];\n  REP(i,N) cnt[i]=0;\n  \n  for(ll i=1; i<=N-1; ++i){\n    cnt[i]=COM(i-1,N-1-i)*fac[i];\n    cnt[i]%=MOD;\n    cnt[i]*=fac[N-1-i];\n    cnt[i]%=MOD;\n    ans+=(cnt[i]-cnt[i-1])*i;\n    ans%=MOD;\n  }\n  \n  if(ans<0) ans+=MOD;\n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(long long int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\n\nint main(void) {\n\tlong long int n;\n\tlong long int count = 1;\n\tlong long int big = 0;\n\n\tcin >> n;\n\n\tif (n % 2 == 1) {\n\t\tFOR(i, 1, n-2) {\n\t\t\tcount *= i;\n\t\t\tcount%=MOD;\n\t\t}\n\t\tbig = pow(n, 2) - 3 * n + 4;\n\t\tbig %= MOD;\n\t\tcount *= big;\n\t\tcount %= MOD;\n\t}\n\telse {\n\t\tFOR(i, 1, n - 2) {\n\t\t\tcount *= i;\n\t\t\tcount %= MOD;\n\t\t}\n\t\tcount /= 2;\n\t\tbig = 1;\n\t\tFOR(i, 1, n / 2) {\n\t\t\tbig *= i;\n\t\t\tbig %= MOD;\n\t\t}\n\t\tbig *= (n / 2);\n\t\tbig %= MOD;\n\t\tcount += big;\n\t\tcount %= MOD;\n\t}\n\tcout << count << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int mod = 1e9+7, maxn = 1e5+5;\n\nint fac[maxn], revfac[maxn];\nint n;\ninline int fastpow(int a, int p){\n\tint ans = 1;\n\twhile(p){\n\t\tif(p&1) ans = (ans*a)%mod;\n\t\tp >>= 1;\n\t\ta = (a*a)%mod;\n\t}\n\treturn ans;\n}\ninline int rev(int a){return fastpow(a, mod-2);}\nvoid init(){\n\trevfac[0]=fac[0] = 1; \n\tfor(int i = 1; i <= n; i++){\n\t\tfac[i] = fac[i-1]*i%mod;\n\t\trevfac[i] = rev(fac[i]);\n//\t\tcout<<fac[i]<<' '<<revfac[i]<<endl;\n\t}\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*revfac[m]%mod*revfac[n-m]%mod;\n}\n\nvoid work(){\n\tint ans = 0, comb = 0, prev = 0;\n\tfor(int k = (n+1)/2; k < n; k++){\n\t\tprev = comb;\n\t\tcomb = C(k - 1, n - k - 1)%mod*fac[k]%mod*fac[n-k-1]%mod;\n\t\tans += (comb - prev+ mod)%mod *k%mod;\n\t\tans %= mod;\n//\t\tcout<<comb<<endl;\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tcin>>n;\n\tinit();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MN = 1000100;\nconst ll M = 1e9+7;\nll mul(ll a, ll b) {\n\treturn (a*b)%M;\n}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll inv(ll v) {return bp(v,M-2);}\nll fp[MN];\nll fac(ll n) {\n\tif(n <= 1) {return 1;}\n\tif(n >= 10000) {fac(n-10000);}\n\tif(fp[n] != -1) {return fp[n];}\n\treturn fp[n] = mul(n,fac(n-1));\n}\nll ch(ll n, ll k) {\n\treturn mul(fac(n),mul(inv(fac(k)),inv(fac(n-k))));\n}\nint main() {\n\tll n;\n\tcin >> n;\n\tmemset(fp,-1,sizeof(fp));\n\tll res = 0;\n\tll rs = 0;\n\tfor(int i=0;i<=n-2;i++) {\n\t\tif(i >= n-i-2) {\n\t\t\tll ro = ch(i,n-i-2);\n\t\t\tro = mul(ro,fac(i+1));\n\t\t\tro = mul(ro,fac(n-2-i));\n\t\t\tro -= rs;\n\t\t\tif(ro < 0) {ro += M;}\n\t\t\trs += ro;\n\t\t\tif(rs >= M) {rs -= M;}\n\t\t\tres += mul(ro,i+1);\n\t\t}\n\t}\n\tres %= M;\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <assert.h>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1000000007;\nconst int N = 1000010;\nll fact[N], invf[N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nll nPr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(fact[n], invf[n-r]);\n}\n\nll nCr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(mul(fact[n], invf[r]), invf[n-r]);\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    fact[0] = invf[0] = 1;\n    FOR(i,1,N-1){\n        fact[i] = (fact[i-1] * i) % mod;\n        invf[i] = divll(invf[i-1], i);\n    }\n\n    VL way(n);\n    ll ans = 0;\n    FOR(k,1,n-1){\n        ll tmp = (fact[k] * fact[n-1-k]) % mod;\n        tmp = (tmp * nCr(k-1, n-k-1)) % mod;\n        way[k] = tmp;\n    }\n\n    FORR(k,n-1,1) way[k] = (way[k] - way[k-1] + mod) % mod;\n    REP(i,n) ans = (ans + i * way[i]) % mod;\n\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n9999G99X999999999999999X9X999X9X9X9X9X9X999X9X9X99999999G9GX99G9GG9S9M9SS9SHG9G9GGGG999999G99X9X9999999X99999X99999X999X9X999X9X99999999999X999X999X99\n9XX9X9XXX9XXSXSXSSSXSXSXSXSXSSHSHXSXSXXXSXSXSXX9SXX99X522sssrsrrrsr:isirrrrH9SX9XHsss25S2X59SX99999XXXX9XXX9X9S9SXSXSXSSSXSXS9XXSXSXSXX9SXXXSXSXSXSXSS\n9X99999X999X9X9S9X9X9X9X9X9X9X9X9XXSXX9XXX999X9X9SXXXssiiii:i::::,: ,,,,,,:irisrri::i;riss2SXSSSXSGGGG9X9X9X9X9X99999X9X9X9X9X9999999X9X9X9X999X9X9X9S\n9X99X999X999X9X9X9X9X9X9X9X9X9SXXXX9X9X9X99GX222sriii::::i:ii;irrri:,,,,,,,,,,,,,:,:::,:::iirri;i;rs299G99999XH9S999S9X9X9X9XXSXX9X999X9X9X9X9X99999XX\n9S9X999X9X9XXS9X9XXX9XXX9X9X9S9X9X9XXX9X9XXXHsr:::::,,,:::::irrssssr:,:,::,,:,:::::::::::::,:,:,:,,,:isHX9G9XS9X9SXX9XXX9XXSXX9X9X9X9X9X999X9999999X9S\nXX9999X999X9X9X9X9S9X9X9X9SXXXX9X9SXX9X999SSsr:::i:::,,,,,,::;rss2si::,::i:::::::iiii::iii:i:i::::::,,,::;rss5SHXXX9XHX9X9X9X999X9X9X999X9X999X9X9X9XX\n9X9X9X9X9X999X9X9XXX9X9X9X9SXX9X9X9X9X99X9Xr:::ir:, ,,,,,,,:iirsssr:iii:::i:::i:iiiii:i:iiriiii:i::::,,,, ,,:::issSSHSG99X9999999X9999999999999X999X9X\n99X9X999X9X9X9X9999999X9X9X9X9X9X9S9XX99X9s::i;ri:,,,,,,::rssssririiiiiiiiiiiiiiiii;iiii;;iriii;iiii::::,,,:ii::::irsX999999XX99X9X99999X999999999X9X9\n9X999X9X9X9X9X9X99999X9SXX9S9X9X9X9X9XX99s,:rrsrrri::::;ss252ss;iiiiriiiiiiirrrrrir;rirrr;ii;iiiiiii::i:::iissrri::,:is2SH9X9X9X9X9X999X9X99999999999X\n9X99X99999X9X999X999X9X9XX99S9XXX9X9X9X9s::rrsssssrrrsssssrssrirrr;r;;iiiiirrrrrrri;:iirrriirrir;riiii:::::irssrrr;i::,:is2999X9X9X99999X9999999X99999\n9X9999999X99999XXX99999X9X999X9X9X9X99G9s:irss22sssss25siirrrrrir;ri;iii;rrrr;;;rii::iiriiiiiirrri;i;ii:::::rssssrri;i:,,:sSG99X9X9X9X9X999999999X9999\n9XX9X99999XXX9X9S9X999X9X9X9SXS9S9XX9GSs:irsrssSHSH5ssrrrsssrrrrrr;;ii;rrri;iii;ii::ii:;rriiirii;r;;i;iiii:::;ssr;iiiiii:,,r9G99X9X999X9999999X9999999\n9S999X9X9X9X9X9X999X9X9X9X9X9SXSXX9XGXr:irsssssssrrs25S22ssrrrrrrrrrrrr;ririiiri:ii:i:iirii:;iirrrrrr;ririi:iirii::ii:ii;:,:2S99999X9X9X9X9999999X9999\nXXX9X9999999X9X9X9X9X9X9X999XXXXX9X99s:irsssssssr;r2522srr;rirrrirrr;rrrrri;irir:iiriir;ii:::ii;i;rrrrrr;iiiiiir;i:::::iii:,:s255XX9999999999G9G9G9G99\n9S9999G9G9999X9X9X9X9X9X999X9X999X999i:irrsssssr;r22ssrrri;irrrrriii;irrr;rrr;ri;iriiiri::iii:iii:iirrrrrrr;;iiirrr;::iii;i,isHS9X9X9X999999G9G99999G9\n9X99999G99X999X9XXXXX9X999X9X999999Gsi:rrrsss22ssssri;irir;rrririi:r;ririiirirrrirriiriiiriri;iiii;rrrssrrrrrriiirssrrirrri:rSS9XXX9X99G9G99999G9G9GGG\n9S9999999X9X9X9X9S9X9X9XXXXX999X99G92iirrrss2sssrrri;iiirir;;iiiiirirrr;;irirrrrrri;riiir;i:iirir;r;rrrrsssrrri:i:;rssssssr:sSXX99G9GGGGMGMGGGGGMGMMMG\nXX99999G99999999X9X9S9X9X9X99999X99GXrirssssrii::iiiirrrrrrrirrrirrrrrisrr;i;rrrrrrsriirr;ir;rriiiiiiiirrrrsrrrrr;iis222ssriH@M@B@B@B@@@B@B@B@MMMGGG9X\n9S999999G99X9X999X9X9X9X9XXXXX999X99Sirsssr::,::i;rirrrrrrri;rrrrrrirrrirrrr;irrrrrr;;rrrrrrrri;rriii:ii;rrrrrrii:i;s2S22srrMB@B@B@B@B@B@B@BBMMGG999XH\n999999999999X999X9XXSXSXSXS9X9X9S99G9srr;i:::::i:iiiirriiiirirrri;rrrsrrrsrssrrrrrrrrsssrrrrrirr;rrrrriiirrrrrrr;;irrs22ssr9B@B@B@B@BBMBMBBBMBMMGG99XX\n999999G9G9999X9X9X9SXX9X9X9SXX9X9X9X2::::::i;i::::riiirrrrrrrirrrrrrrrrrrrrrsrsrsssrsssrrrsrrrrrrrrrri;i;iiirrrir;r;;isssrrX@BBB@BBMBBBMBMBB@BBMMGG99S\n999G999G9999X9X9S9X9SXSXSXSXX9XXX9X9Hi,:,::i:::::ii;iririri;irrsrrrrrrrsrrrssrssrrrrrsrrssrsrrrri;rrrrrrrri;;rrriiiiiirsr;sMBBM@B@MBMBMBMBMBB@BBMMGG99\n9X9X9X99999X9XXSXS9XXXXSXX9999GGGGGBBi,,::::::::::iii:i;r:iirrrrsrrrsrsrsssssrrrssrrrrsssrrssrrrrrrrrirrrii:::ii;ii:i:;ss;2M@B@BBBBMBMBMBMMMBBBBBMBMMG\n99X9X9999999999G9GGGGGGGGMMBB@B@B@B@M,,,,:::,:,::::iiiiri;;;i;riir;rrsssrss2srssrrsrisrrrsssssrrrrrsrrr;iiii:::i:ii::::i;;S@B@B@BBMBB@MBMBM@MBM@B@@@BM\nMGMGMGMMBMBMBB@B@B@B@B@B@B@B@B@B@B@Si,,,:,,,,,,,:::irrrrrrrrr;rii;rrsssssrssrsrrrssrssrrrrsssrssssrrrrririiiri;ii:::::::,r@B@B@B@BBBBB@@@BBB@B@@@B@B@B\nB@B@B@B@B@B@B@B@B@B@B@B@B@B@@@MGGSi  ,,,,,,,,,,,,::rrsrrrrrri;iiirrs29995srrrs;rsssrssrrrrrrrrrsssssssrrrririiirr;:i:i:: r@@@@B@B@B@B@B@BBMBMBMMMMMMGG\n@B@B@@@B@@@B@B@B@B@B@B@B@G2ri:,,:    ,,,,,,,,,,,:::iirrrsssr;irsss2XG9GGXsss2sss222srrsssr;irrrrsrrrrrrrrrrrrrrrrr;::::, s@B@B@B@MBMMMMMMGMGG9999XX5Hs\nB@@@B@B@B@B@B@BMMBB@B@B@Ss:,        ,,,,,,,,,,,,:::iiii;rsrrrss22222ss2925S999S2S92srrsrr;rri;rsssrrirrsrrrsrrrrii:i::,,i@BBMMMMGMGG99999XSXHS5222ssss\n@BMGGGBB@B@B@MM999GM@B@M2i:,   ,, ,,,,,,,,,,,,,,::::iirsss22ssrrrii:i;2sssssHX9X925ssirrr:iirrrssssrr;rrrrrrrrrrrii::,,:M@BMMGGGG99X9XS5S5H2522s2s2sss\nBM9G9MMBB@B@B@BGX9SX5S2sri,,,,,,,,,, ,,,,,,,,,,,,::i;ss22H2s;irrrssS9SXHsssssH2S22sS2ss2sssss2sssrrsrr;r;rirrrrrrii:,,,5B@MG9G9999X9HX5S222222sssssssr\n@BMGGGMM@B@B@BM92ssii::,,,,,,,,,, ,   ,,,,,,,,,,,::irrrirrr;sXBB@B@B@BBG9SG52s2SS2SSXXXSS52ssssssssssrrrsrrrssrrri:,,,,rSG9XXSS2H2222ssssssrrrr;ri;i;:\nMMG99XX9XX2H22ssri:,,,,,,,,,           ,,,,,,,,,::::::::::,,rMB@B@9G@@BBSGMM2s2HHSs52Xsrrrrss2222SX2s222ssssrrrrr;:::,,,,:rsssrrrriri;iii:::::,:,:::,,\nX5S22ssssrrrriiii::,::i:,,,   ,,,       ,,,,,,:::::,,,,,::,,:2MB@B@B@B@95MM92sSSXH2ss59ss2SGBB@BBB@@M999S2sssssrsri:i::,, ,::::::,:::,:,:,:,,,,,,,,,,,\n22ssssssssrsrrrrrrrs22i,,,,,,,,,,,,,,,,,,,,,,,,,,,,, , ,,::::isMB@@@BM22B@MGXSGM995sr2B@B@9GB@B@B@BM9Ssss222ssri:i::,,,,,,,,,,,,,,,,,,,:,,,,,,,,,,,::,\n9HXSSSXS9X9999GGMB@@X:, , ,,,,,,,,,,,,,,,,,,,,,,,,,,, , ,,,,::ir22SXSHB@@M9MMGM99S2rrsMBBMrr@B@B@B92srrssssrrri,:,,       ,,,,,,,,,,,,:,,,,,,,,,,,,,,,\nBBB@B@B@B@@@B@B@B@Gs   , ,   , , ,,,,:,:,,,,,,,,,,,,,,,,,,,,,,,,:isS992srrii:iir::i;;sS9MMGGB@BG5srrirrri:::,,,,           ,,:,,,,,,,,,,,,,,,:,,,,,,,,\n@B@B@@@B@B@B@B@B9:              , ,,,,::i::,,,,,,,,,,,,,,,,,,,,,,:sri, ,,,,,,:::i:,,:::rSMG55srii;r:ii:,,,,                 ,,,,,,,,,,,,,,,,,,,,,,,,,,\n@@B@B@MBMMMMGM9r                   ,,,:i:iri,,,,,,,:::,:,,,,,,,,::,,,,,,,,,:::,,,,,,,i::,rGSsrii:::::,,,                   ,,,,,,,,,,,,,,,,,,,,,,,,:,,\nG99SS5522s2ssi                      ,,::rrss:,, ,,::i:i,,,:,,:rsrir:,,:,is2SX5sssr:,,,:,,,r92i:,,:i,,                      ,,,:,,,:,:,,,:,,,,,,,,,,,,\nsrrrrrrrrrrr:      ,                 ,,;srs2sssr:,,::iii:i:::rri:i:, ,,:sM9X2s5H2GG2:,,,,,,r25ssss,                        ,,:,,,,,,,,,,,,,,,,,,,,,,,\ni:i:ii;ii:i:                      , ,,,:sss2SS99Hr:,:iri;:::i:,,, ,    ,s9SBBs2s99XMr ,,,,;rs9X9s:,                        ,i,,,,,,,,,,,,,,,,,,,, ,,,\n:::i:i:::::,                       ,,,,:is25HHS9992r:::i:iii,,,,    ,,  :MM@MG9GBM92,  ,,irsssS9i,     ,      ,,       ,  ,;::,,,:,,,, ,,,,,,,,,,, ,,,\n:,:::,::::,                       ,,,,:::r2SSH99MM@MXsi:::i:i:, , ,     ,9@BMMMM@BS,,   ,,irirXM2,        :r:,,,:;:  ,issrsr:,,,,,, ,,,,,,,,, ,,,,,,,\n:,,:,:,,,:,                      ,,,,,:r:rS99GM@@@B@M9sii:,,:i:,,  , , ,isXM@@MBM2,:,, ,,,,,:5M@BBHi,ri,,iX9r:::rMS22GSssr,      ,  ,,,,,,,,,,,,,,,,,,\n:,:,,,:,,,,                     , , ,,iir2BB@BBMGsrrrrsssri:::iii::,::irsssrsssii:,,, ,,,:isGBM9229929S;2GMssir;;rri,,      ,,,  ,,,, ,,, ,,,,,,,,,,,\n:,:,,,,:,:,                    ,  ,,,isSG@BM92sri::irssSSX25HHS9XSH9X22HSG9BG9XXXSssssrrrssr:,     ,                     ,,,,,,,,,,,,,       ,,,,,,,\n,,,,:,,,,,:                 , ,  ,:i5GM9Hr:,,,,,,,,,::::::iisrss2s299XS9G9GGSS92ss2sr,,,,             ,    ,, ,  ,,  ,,,, ,    ,, ,,, ,,,   ,,,,,,  ,\n:,,:,,,,,,:, ,,,       ,:, ,:;sssXss2s:        , ,     ,             ,,                  , , , ,,,,,,, , , ,,, ,,,,,   ,,,  ,, ,,,   ,,, , ,   ,,, ,,,\n, ,,,,:,:,:irsX2srsssrr2S22ssss:ii,       , , , ,,, ,,, ,,    , ,                   , ,,, , , ,,,  ,,,   ,,  ,,,, , ,,,,,,,,, , ,,, ,,,   ,,, ,,,,,,,,\n, ,:,,,,,,,,:i:i;r;r::,,,,,,         ,,,,,,,,,,, ,,,,,  ,,,,  ,, , ,,, ,, ,  , , , ,  ,, ,,,,,,, ,,,,,    ,, ,    ,,,,,,,, , ,,, ,,,,, ,,, ,,,,, ,:,,\n, ,,,,,,,,,,                    , ,,,,,,,,, ,,, ,,,,, ,  ,,, ,,,, ,      ,, , ,,,, ,, , , ,,  ,    ,, , ,  ,,,, ,,,   ,,, ,,, , ,,,   ,,, ,,,,, ,,,,,,\n, ,,,,,,,,,,,,,,,,,, , ,,, ,,,,,,, ,,,  ,, ,, ,, ,,,   ,,,,,  ,, ,   ,,,,, , ,,  ,     ,,    , ,,, ,,,,, ,,, ,,,,,   ,,, ,,,,,,,,, ,,,,,,,,,,, ,,,,,,,\n, ,,,,,,,,,,, , ,,,,,,, ,,, ,,,,,,, ,   ,   ,,,,,,, ,,,,, ,   , ,  ,,   ,       ,   , ,,,,,   , ,   ,,,,,,, ,,,,    ,,  ,,  ,,,,,,, , ,,,,,,,, ,, ,,,\n,  ,,,,,,,,, ,,,,,,,,, ,,, ,,,   ,,,,, ,,, , , , ,,  ,,,    ,, ,, ,,       , , ,,,,, ,,, ,,, ,         , , ,     , , ,  ,, ,,, ,,,,,  ,,,,,,,, ,, ,,,\n, ,,,,,,, ,,,,, ,,, , ,,  ,,, , ,,,,, ,  ,,,,  ,,   , ,,, , ,       ,   , ,     , , , ,   , , , ,,, , , , , ,,, ,,, ,,, ,,,,  ,,,,,,,,,,, ,,,, ,, ,,,\n, ,,,,,,,,,,,,,,,,,,,,,  ,,,,,,, ,,    ,,,   , ,,,,, ,  ,,,, , ,   ,,, ,   , , , ,   , ,,,   ,,,,, , ,,,    ,,,, , ,  ,,,, ,,,,,,,,,,,,, ,,,,,,,,,,,,,\n: ,,,,,,,,,,,,,,,,,,, ,,,,,,,,,,,,,,,,,,,,, ,,,,,,,,,   ,,, ,,,,,,,,, ,,, ,,,,,,, , ,   ,,,,, , ,,, , ,,,,,,, ,,,,, ,,:,:,:,:::i:::i:::::::,::::::,,,,\n, ,,          ,,   ,   ,                                                                                        , , , ,    ,, ,   , ,\n*/\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define LL long long\n#define ll   long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define PB pop_back\n#define p push\n#define P pop\n#define INF 2147483647\n#define ull unsigned long long\n#define vi vector < int >\n#define vpii vector < pii >\n#define pq priority_queue\n#define rep(i,n) for (int (i)=0;(i)<n;(i)++)\n#define End return 0\n#define mi multiset <int>\n#define si set <int>\n#define sll set<ll>\n#define mll multiset<ll>\n#define vll vector <ll>\n#define Rep(i,a,b) for (int (i)=(a);(i)<=(b);(i)++)\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int Maxn=1e6+5;\nconst LL mod=1e9+7;\nLL fact[Maxn];\nLL qp(LL x,LL p){\n\tLL ans=1;\n\twhile (p){\n\t\tif (p & 1){\n\t\t\tans=ans*x%mod;\n\t\t} \n\t\tx=x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn ans;\n} \nLL inv(LL x){\n\treturn qp(x,mod-2);\n}\nLL C(LL x,LL y){\n\tif (x<y) return 0;\n\treturn fact[x]*inv(fact[y])%mod*inv(fact[x-y])%mod;\n}\nLL d[Maxn];\nint main(){\n\tfact[0]=1;\n\tfor (int i=1;i<Maxn;i++){\n\t\tfact[i]=fact[i-1]*(LL)i%mod;\n\t}\n\tint n;\n\tscanf(\"%d\",&n);\n\tLL ans=0;\n\tfor (int i=1;i<=n-1;i++){\n\t\td[i]=C(i-1,n-1-i)*fact[i]%mod*fact[n-i-1]%mod;\n\t\td[i]=(d[i]%mod+mod)%mod; \n\t}\n\tfor (int i=1;i<=n-1;i++){\n\t\tans=ans+(d[i]-d[i-1])*i%mod;\n\t\tans=(ans%mod+mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ninline int read() {\n  int f = 1;\n  int x = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    f = (ch == '-') ? -1 : 1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return f * x;\n}\n\nconst int N = 1e6 + 5;\nconst int P = 1e9 + 7;\n\ninline int mul(int a, int b) {\n  return (long long) a * b % P;\n}\ninline int sub(int a, int b) {\n  return a - b < 0 ? a - b + P : a - b;\n}\ninline int add(int a, int b) {\n  return a + b >= P ? a + b - P : a + b;\n}\ninline int modexp(int a, int x) {\n  int ret = 1;\n  while (x) {\n    if (x & 1) {\n      ret = mul(ret, a);\n    }\n    a = mul(a, a);\n    x >>= 1;\n  }\n  return ret;\n}\n\nint n;\nint fac[N];\nint inv[N];\n\ninline int calc(int m, int n) {\n  int k = 2 * m - n;\n  if (k >= 0 && m - k >= 0) {\n    return mul(fac[m], mul(inv[k], inv[m - k]));\n  } else {\n    return 0;\n  }\n}\n\ninline int C(int n, int m) {\n  return mul(fac[n], mul(inv[m], inv[n - m]));\n}\n\nint main() {\n  n = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  inv[n] = modexp(fac[n], P - 2);\n  for (int i = n - 1; i >= 0; --i) {\n    inv[i] = mul(inv[i + 1], i + 1);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    ans = add(ans, mul(fac[n - i - 1], mul(sub(C(n - 1, i), C(i - 1, n - i - 1)), fac[i])));\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"\n#define cout(n) cout<<fixed<<setprecision(n)\n\nll ext_gcd(ll a, ll b, ll&x, ll&y){\n  if(b==0){\n    x=1;y=0;return a;\n  }\n  ll q=a/b;\n  ll g=ext_gcd(b,a-q*b,x,y);\n  ll z=x-q*y;\n  x=y;y=z;\n  return g;\n}\n\nll invmod(ll a, ll m){\n  ll x,y;\n  ext_gcd(a,m,x,y);\n  x%=m;\n  if(x<0)x+=m;\n  return x;\n}\n\n\nint main(){\n  int N;\n  cin>>N;\n\n  vector<ll> comb(N,1);\n  vector<ll> perm(N,1);\n\n  ll z=1000000007;\n  FOR(i,1,N){\n    perm[i]=perm[i-1]*i%z;\n  }\n  FOR(i,0,N){\n    if(2*i-N<0) comb[i]=0;\n    else if(2*i-N==1)comb[i]=i-1;\n    else if(2*i-N==0)comb[i]=1;\n    else comb[i]=perm[i-1]*invmod(perm[N-i-1],z)%z*invmod(perm[2*i-N],z)%z;\n  }\n\n//  coutv(comb,0,N);\n  ll res=0;\n  FOR(i,1,N){\n//    cout<<res<<endl;\n    res += (comb[i]*perm[i]%z*perm[N-1-i]%z-comb[i-1]*perm[i-1]%z*perm[N-i]%z+z)%z*i%z;\n\n  // cout<<comb[i]*perm[i]%z*perm[N-i-1]%z<<endl;\n    //cout<<comb[i-1]*perm[i-1]%z*perm[N-i]%z<<endl;\n    //cout<<i<<endl;\n  }\n  cout<<res%z<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N=2e6+10;\nconst int MOD=1e9+7;\n\nll fac[N],rev[N],revfac[N];\n\nll A(int n,int k){\n        if (k>n||k<0) return 0;\n        return fac[n]*revfac[n-k]%MOD;\n}\nll C(int n,int k){\n        if (k>n||k<0) return 0;\n        return A(n,k)*revfac[k]%MOD;\n}\nvoid prepare(){\n        fac[0]=1;\n        for(int i=1;i<N;i++) fac[i]=fac[i-1]*i%MOD;\n        rev[1]=1;\n        for(int i=2;i<N;i++) rev[i]=MOD-(MOD/i)*rev[MOD%i]%MOD;\n        revfac[0]=1;\n        for(int i=1;i<N;i++) revfac[i]=revfac[i-1]*rev[i]%MOD;\n}\nint main(){\n        prepare();\n        int n;\n        cin>>n;\n        if (n==2){\n                cout<<1;\n                return 0;\n        }\n        ///last move\n        n--;\n        ll ans=fac[n];\n        for(int i=1;i<=n;i++) {\n                ///no left tail and no right tail\n                ans=(ans+A(n-2,i)*fac[n-i])%MOD;\n                ///no left or no right tail\n                ans=ans+2*A(n-2,i-1)*i%MOD*fac[n-i]%MOD;\n        }\n        for(int i=1;i<=n;i++){\n                ///force to have both head and tail\n                ll way=A(n-2,i-2)*fac[n-i]%MOD*A(i,2)%MOD;\n                ///minus some states\n                way=(way-fac[i]*C(i-1,n-i)%MOD*fac[n-i])%MOD;\n                ans=(ans+way)%MOD;\n        }\n        cout<<(ans+MOD)%MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define MOD 1000000007LL\nusing namespace std;\n\nlong long int inv(long long int x){\n\tlong long int xpow[30], c[30];\n\tfor(int i=0; i<30; i++){\n\t\tif(i==0){\n\t\t\txpow[i]=x;\n\t\t\tc[i]=1;\n\t\t}else{\n\t\t\txpow[i]=xpow[i-1]*xpow[i-1]%MOD;\n\t\t\tc[i]=c[i-1]*2;\n\t\t}\n\t}\n\tlong long int r=MOD-2, xinv=1;\n\tfor(int i=29;i>=0; i--){\n\t\tif(r>=c[i]){\n\t\t\txinv=xinv*xpow[i]%MOD;\n\t\t}\n\t\tr=r%c[i];\n\t}\n\treturn xinv;\n}\n\nint main()\n{\n\tlong long int n;\n\tscanf(\"%lld\", &n);\n\tlong long int f[1000001], invf[1000001];\n\tf[0]=1, invf[0]=1;\n\tfor(long long int i=1; i<=n; i++){\n\t\tf[i]=f[i-1]*i%MOD;\n\t\tinvf[i]=inv(f[i]);\n\t}\n\tlong long int x[500002];\n\tfor(long long int i=1; i<=n/2; i++){\n\t\tx[i]=f[n-i]*f[n-i-1]%MOD*invf[n-2*i]%MOD*invf[i-1]%MOD*f[i-1]%MOD;\n\t}\n\tx[n/2+1]=0;\n\tlong long int ans=0;\n\tfor(long long int i=1; i<=n/2; i++){\n\t\tans=(ans+(n-i)*(x[i]-x[i+1]+MOD)%MOD)%MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<ll,ll> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-3;\nint dx[4]={0,1,0,1};\nint dy[4]={0,0,1,1};\nll f[1001000],fi[1001000];\nll mod_pow(ll x,ll n,ll mod){\n    ll ret=1;\n    while(n>0){\n        if(n&1){\n            ret=(ret*x)%mod;\n        }\n        x=(x*x)%mod;\n        n>>=1;\n    }\n    return ret;\n}\n \nvoid fact(ll n){\n\tf[0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tf[i]=(f[i-1]*i)%MOD;\n\t}\n\tfi[n]=mod_pow(f[n],MOD-2,MOD);\n\tfor(ll i=n-1;i>=0;i--){\t\t\n\t\tfi[i]=(fi[i+1]*(i+1))%MOD;\n\t}\n}\n \n  \nll ncr(ll n,ll r){\n\tif(r==0){\n\t\treturn 1;\n\t}else if(n<r){\n\t\treturn 0;\n\t}else{\n\t\treturn ((f[n]*fi[r])%MOD*fi[n-r])%MOD;\n\t}\n}\n\nint main(){\n\tll n;cin>>n;n--;\n\tfact(1000010);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tll ans=(2*f[n])%MOD;\n\tfor(ll i=1;i<n;i++){\n\t\tans+=((ncr(n-1-i,i)%MOD*f[n-i])%MOD*(n-i))%MOD;\n\t\tans%=MOD;\n\t}\n\tcout<<ans%MOD<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>  // abs() for integer 絶対値求めやつ\n#include <cmath>    // abs() for float, and fabs()\n#include <algorithm>\n#include <vector>\n#include <string>\n#define rep(i,n) for(int i = 0; i< (n);i++)\n#define SORT(a) sort((a).begin(),(a).end());\n#define che(a,string) cout<<string<<\":\"<<(a)<<endl;\n#define ch(a,string) cout<<string<<\":\"<<(a)<<\" \";\nusing namespace std;\ntypedef pair<int,int> p;\nint main(){\nint n;cin>>n;\nvector<long long> A(n);\nrep(i,n){\n\tcin>>A[i];\n  }\nvector<long long> B(n+1);\nB[0]=0;\nrep(i,n){\n\tB[i+1]=B[i]+A[i];\n  }\n  int ans = 0;\n  SORT(B);\n  rep(i,n){\n\tif(B[i]==B[i+1]){\n\t\tans++;\n\t  }\n  }\n\tcout <<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=1000005,mod=1000000007;\nconst ll mod2=(ll)mod*mod;\nint n,ans,f[N];\nll fac[N],ni[N];\ninline ll p(int a,int b){\n\treturn fac[a]*ni[a-b]%mod;\n}\ninline int ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=read();\n\tfor(int i=fac[0]=1;i<=n;i++)fac[i]=fac[i-1]*i%mod; ni[n]=ksm(fac[n],mod-2);\n\tfor(int i=n;i;i--)ni[i-1]=ni[i]*i%mod;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tf[i]=p(i-1,n-1-i)*fac[i]%mod;\n\t\tans=ans+(ll)(f[i]-f[i-1]+mod)*i; if(ans>=mod2)ans-=mod2;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tconstexpr auto pow_mod = [](int64_t a, int64_t n, int64_t mod) {\n\t\tint64_t r = 1;\n\t\tfor (; n; n >>= 1)\n\t\t{\n\t\t\tif (n & 1)\n\t\t\t{\n\t\t\t\t(r *= a) %= mod;\n\t\t\t}\n\t\t\t(a *= a) %= mod;\n\t\t}\n\t\treturn r;\n\t};\n\tint64_t n, mod = 1000000007;\n\tcin >> n;\n\tint64_t fact[n + 1], fact_rev[n + 1];\n\tfact[0] = 1;\n\tfor (int64_t i = 1; i <= n; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t}\n\tfact_rev[n] = pow_mod(fact[n], mod - 2, mod);\n\tfor (int64_t i = n - 1; 0 <= i; i--)\n\t{\n\t\tfact_rev[i] = fact_rev[i + 1] * (i + 1) % mod;\n\t}\n\tint64_t f[n + 1]{};\n\tfor (int64_t k = 1; k <= n; k++)\n\t{\n\t\tint64_t a = 2 * k - n, b = n - k - 1;\n\t\tif (a < 0 || b < 0 || n - k - 1 < 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tf[k] = fact[a + b] * fact_rev[a] % mod * fact_rev[b] % mod * fact[k] % mod * fact[n - k - 1] % mod;\n\t}\n\tint64_t ans = 0;\n\tfor (int64_t k = 1; k <= n; k++)\n\t{\n\t\tif (f[k] < f[k - 1])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t(ans += k * (f[k] - f[k - 1]) % mod) %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#pragma GCC optimize(\"O3\")\n#include <vector>\n#include <algorithm>\n#include <vector>\n//#include <random>\n#include <fstream>\n#include <map>\n#include <string>\n#include <deque>\n#include <set>\n#include <ctime>\n#include <exception>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n//const int size2 = 6e5;\nconst int size1 = 1e6 + 500;\nconst long long INF = 1e9 + 10;\nconst long long mod = 1e9 + 7;\nconst long double eps = 1e-7;\nconst long double pi = 3.1415926535;\nconst int erat = 1e6 + 500;\n\nlong long pow1(long long a, long long deg)\n{\n\tif (deg == 0)\n\t{\n\t\treturn 1;\n\t}\n\tif (deg == 1)\n\t{\n\t\treturn a % mod;\n\t}\n\tlong long res = pow1(a, deg / 2);\n\tres = (res * res) % mod;\n\tif (deg % 2 == 1)\n\t{\n\t\tres = (res * a) % mod;\n\t}\n\treturn res;\n}\n\nlong long obr(long long a)\n{\n\treturn pow1(a, mod - 2);\n}\n\nstatic long long fact[size1];\n\nlong long c_n_k(long long n, long long k)\n{\n\treturn ((fact[n] * obr(fact[k])) % mod * obr(fact[n - k])) % mod;\n}\n\n\nint main()\n{\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n;\n\tcin >> n;\n\tn--;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t}\n\tint pok = n / 2 + 1;\n\tlong long ans = 0;\n\tlong long prev_kol = 0;\n\t//long long ans = (fact[n] * (pok - 1)) % mod;\n\tfor (int i = pok; i <= n; i++)\n\t{\n\t\tint kol_pov = 2 * (i - 1) - (n - 1);\n\t\tlong long kol = ((c_n_k(i - 1, kol_pov) * fact[n - i]) % mod * fact[i]) % mod;\n\n\t\t//cout << kol << endl;\n\t\t//cout << kol << endl;\n\t\tans = (ans + (i * (((kol - prev_kol) % mod + mod) % mod) % mod)) % mod;\n\t\t//cout << ans << endl;\n\t\tprev_kol = kol;\n\t\t//ans = (fact[n] - c_n_k(i, kol_pov)) % mod;\n\t\t//с_i_kol_pov\n\t}\n\tcout << ans;\n\t//cout << (ans + fact[n]) % mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\n#include<unordered_set>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 0x2aaaaaaa; // 715,827,882\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\nll fc[2000006];\nll ifc[2000006];\n\n\ntemplate <typename Int, Int MOD, int N>\nstruct comb_util {\n\t// std::array<Int, N + 1> fc, ifc;\n\tcomb_util() {\n\t\tfc[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) fc[i] = fc[i - 1] * i % MOD;\n\t\tifc[N] = inv(fc[N]);\n\t\tfor (int i = N - 1; i >= 0; i--) ifc[i] = ifc[i + 1] * (i + 1) % MOD;\n\t}\n\tInt fact(Int n) { return fc[n]; }\n\tInt inv_fact(Int n) { return ifc[n]; }\n\tInt inv(Int n) { return pow(n, MOD - 2); }\n\tInt pow(Int n, Int a) {\n\t\tInt res = 1, exp = n;\n\t\tfor (; a; a /= 2) {\n\t\t\tif (a & 1) res = res * exp % MOD;\n\t\t\texp = exp * exp % MOD;\n\t\t}\n\t\treturn res;\n\t}\n\tInt perm(Int n, Int r) {\n\t\tif (r < 0 || n < r)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn fc[n] * ifc[n - r] % MOD;\n\t}\n\tInt binom(Int n, Int r) {\n\t\tif (n < 0 || r < 0 || n < r) return 0;\n\t\treturn fc[n] * ifc[r] % MOD * ifc[n - r] % MOD;\n\t}\n};\n\nconst ll M = 1000000007;\nusing comb = comb_util<long long, M, 1000006>;\n\ncomb c;\n\nint main() {\n\tll n;\n\tcin >> n;\n\n\tll ret = 0;\n\t\n\tll a = 0;\n\trepfT(i, (n + 1) / 2, n - 1) {\n\t\tll b = c.fact(i) * c.fact(n - i - 1) % M * c.binom(i - 1, n - i - 1) % M;\n\t\tret += (b - a + M) * i % M;\n\t\t// cout << b << \" \" << a << \"  \" << (b - a + M) * i % M << endl;\n\t\tret %= M;\n\t\ta = b;\n\t}\n\tcout << ret << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"Segment_Tree.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\ntemplate <class T>\nauto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nint main() {\n\tint N;\n\tcin >> N;\n\n\t--N;\n\tMInt sum = N * MInt::Fact(N);\n\tREP(k, 1, (N + 1) / 2) {\n\t\tsum -= MInt::Combi(N - (k + 1), k) * MInt::Fact(N - k) * MInt::Fact(k);\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long LL;\nconst LL mo=1e9+7;\nconst int N=1e6;\nint n;\nLL fac[N+10],inv[N+10],f[N+10];\nLL mul(LL x,LL y) {\n    LL z=1;\n    while (y) {\n\tif (y&1) z=z*x%mo;\n\tx=x*x%mo;\n\ty>>=1;\n    }\n    return z;\n}\nvoid pre() {\n    fac[0]=1;\n    for (int i=1;i<=N;i++) fac[i]=fac[i-1]*i%mo;\n    inv[N]=mul(fac[N],mo-2);\n    for (int i=N-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mo;\n}\nLL C(int x,int y) {\n    if (y>x) return 0;\n    return fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nint main() {\n    pre();\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n\tf[i]=C(n-i-2,i)*fac[n-1-i]%mo*fac[i]%mo;\n    LL ans=0;\n    for (int i=0;i<n;i++) {\n\tLL nowx=f[i]-f[i+1];\n\tans=(ans+nowx*(n-i-1))%mo;\n    }\n    ans=(ans%mo+mo)%mo;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\nstruct mint {\n    lint v;\n    lint _mod;\n    mint() : v(0) {}\n    mint(signed v, lint _mod = mod) : v(v), _mod(_mod) {}\n    mint(lint t, lint _mod = mod) : _mod(_mod) {\n        v = t % _mod;\n        if (v < 0)\n            v += _mod;\n    }\n\n    mint pow(lint k) {\n        mint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static mint add_identity() { return mint(0); }\n    static mint mul_identity() { return mint(1); }\n    mint inv() { return pow(_mod - 2); }\n\n    mint &operator+=(mint a) {\n        v += a.v;\n        if (v >= _mod)\n            v -= _mod;\n        return *this;\n    }\n    mint &operator-=(mint a) {\n        v += _mod - a.v;\n        if (v >= _mod)\n            v -= _mod;\n        return *this;\n    }\n    mint &operator*=(mint a) {\n        v = v * a.v % _mod;\n        return *this;\n    }\n    mint &operator/=(mint a) { return (*this) *= a.inv(); }\n\n    mint operator+(mint a) const { return mint(v) += a; };\n    mint operator-(mint a) const { return mint(v) -= a; };\n    mint operator*(mint a) const { return mint(v) *= a; };\n    mint operator/(mint a) const { return mint(v) /= a; };\n\n    mint operator-() const { return v ? mint(_mod - v) : mint(v); }\n\n    bool operator==(const mint a) const { return v == a.v; }\n    bool operator!=(const mint a) const { return v != a.v; }\n    bool operator<(const mint a) const { return v < a.v; }\n};\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nstruct Combination {\n    vector<lint> fac, finv, inv;\n    Combination(lint maxN) : fac(maxN + 100), finv(maxN + 100), inv(maxN + 100) {\n        maxN += 100; // for safety\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1]            = 1;\n        for (lint i = 2; i <= maxN; ++i) {\n            fac[i]  = fac[i - 1] * i % mod;\n            inv[i]  = mod - inv[mod % i] * (mod / i) % mod;\n            finv[i] = finv[i - 1] * inv[i] % mod;\n        }\n    }\n    lint operator()(lint n, lint k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    lint n;\n    cin >> n;\n    Combination nCk(1000000);\n    vector<mint> facto(1000001, 0);\n    facto[0] = 1;\n    facto[1] = 1;\n    for (int i = 2; i <= 1000000; ++i) {\n        facto[i] = facto[i - 1] * i;\n    }\n    if (n < 4) {\n        if (n == 2) {\n            cout << 1 << \"\\n\";\n        } else if (n == 3) {\n            cout << 4 << \"\\n\";\n        }\n        return 0;\n    }\n    mint ret  = 0;\n    mint prev = 0;\n    for (int i = (n - 4) / 2 + 2; i < n; ++i) {\n        ret += mint(i) * ((mint)nCk(i - 1, n - 1 - i) * facto[i] * facto[n - 1 - i] - prev);\n        prev += ((mint)nCk(i - 1, n - 1 - i) * facto[i] * facto[n - 1 - i] - prev);\n    }\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 1000111;\nll n, fac[maxn], ifac[maxn], inv[maxn];\nll C(int x, int y) {return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nint main()\n{\n\tcin>>n;\n\tif (n==2)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfac[0] = 1;\n\tfor (int i=1; i<=n; i++) fac[i] = fac[i-1]*i%mod;\n\tinv[1] = 1;\n\tfor (int i=2; i<=n; i++) inv[i] = mod-1ll*(mod/i)*inv[mod%i]%mod;\n\tifac[0] = 1;\n\tfor (int i=1; i<=n; i++) ifac[i] = ifac[i-1]*inv[i]%mod;\n\tll ans = fac[n-1]*(n-1);\n\tfor (int i=1; i+1<n; i++)\n\t{\n\t\tif (i*2<n) continue;\n\t\tans += -C(i-1, n-2-(i-1))*fac[i]%mod*fac[n-1-i]%mod;\n\t}\n\tcout<<(ans%mod+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define MOD 1000000007\n\n\nLL bigmod(LL a,LL p)\n{\n    LL ret=1;\n    while(p>0)\n    {\n        if(p&1)ret=(ret*a)%MOD;\n        p>>=1;\n        a=(a*a)%MOD;\n    }\n    return ret;\n}\n\nLL modinverse(LL x)\n{\n    return bigmod(x,MOD-2);\n}\n\nLL fact[1000009],inv[1000009];\n\nint main()\n{\n    LL n;\n    cin>>n;\n    n--;\n    if(n==1)\n    {\n        cout<<1<<endl;\n        return 0;\n    }\n    LL ans=0,cnt=0,x;\n    if((n+1)%2)x=(n+2)/2;\n    else x=(n+1)/2;\n    fact[0]=inv[0]=1;\n    for(LL i=1;i<=n;i++)\n    {\n        fact[i]=(i*fact[i-1])%MOD;\n        inv[i]=modinverse(fact[i]);\n    }\n    LL tmp;\n    for(;x<=n;x++)\n    {\n        tmp=(((fact[x-1]*fact[x])%MOD)*inv[2*x-n-1])%MOD;\n        tmp=(tmp-cnt+MOD)%MOD;\n        cnt=(cnt+tmp)%MOD;\n        ans=(ans+x*tmp)%MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <string>\n#include <utility>\n#include <map>\n#include <deque>\n\nusing namespace std;\n#define rep(i,n) for(int i=1;i<=(int)(n);i++)\n#define Rep(i,n) for(int i=0;i<=(int)(n-1);i++)\ntypedef long long ll;\ntypedef map<int,int> mint;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\ntypedef deque<pair<ll,ll>> dep;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint inf=1e9+1000;\nconst int mod=1e9+7;\nll infi=1e18+100;\n\nll N;\n\nll f(ll n){\n\tif(n==0) return 1;\n\telse return (n*f(n-1))%mod;\n}\n\n\nint main(){\n\tcin>>N;\n\tll ninzuu[N+1]={};\n\tll frac[N+3]={};\n\tfor(ll i=0;i<=N;i++) frac[i]=f(i);\n\tll sum=0;\n\tif(N%2==0){\n\t\tfor(ll i=N/2;i<=N;i++){\n\t\t\tif(i==N/2) ninzuu[i]=frac[i];\n\t\t\telse{\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\t}\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t}\n\telse{\n\t\tfor(ll i=(N+1)/2;i<=N;i++){\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t\t\n\t}\n\tcout<<(sum)%mod<<endl;\n\t\n\t\n\t\n\t  return 0;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nconst int mod=1e9+7;\nint mi[1000010],ni[1000010];\nint ans,n,num[1000010];\nint fast_pow(int x,int a)\n{\n\tint ans=1;\n\tfor (;x;x>>=1,a=1ll*a*a%mod)\n\t\tif (x&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint C(int n,int m)\n{\n\treturn 1ll*mi[n]*ni[m]%mod*ni[n-m]%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);mi[0]=1;\n\tfor (int i=1;i<=n;i++) mi[i]=1ll*mi[i-1]*i%mod;\n\tni[n]=fast_pow(mod-2,mi[n]);\n\tfor (int i=n-1;i>=0;i--) ni[i]=1ll*ni[i+1]*(i+1)%mod;\n\tfor (int i=(n+1)/2;i<n;i++) num[i]=1ll*C(i-1,n-2-(i-1))*mi[i]%mod*mi[n-1-i]%mod;\n\tfor (int i=(n+1)/2;i<n;i++)\n\t{\n\t\tans=(1ll*ans+1ll*i*(num[i]-num[i-1]+mod))%mod;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long i64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e6+5, P = 1e9+7;\nint n, ans; i64 fac[N], ifac[N], f[N];\ni64 inv(int i) { return i == 1?1:P-(P/i)*inv(P%i)%P; }\ni64 C(int n, int m) { return 0 <= m&&m <= n?fac[n]*ifac[m]%P*ifac[n-m]%P:0; }\nint main()\n{\n    n = read(), fac[0] = 1;\n    for(int i = 1; i <= n; ++i) fac[i] = fac[i-1]*i%P;\n    ifac[n] = inv(fac[n]); for(int i = n; i; --i) ifac[i-1] = ifac[i]*i%P;\n    for(int i = 1; i < n; ++i) f[i] = C(i-1, n-i-1)*fac[i]%P*fac[n-1-i]%P;\n    for(int i = n/2; i < n; ++i) ans = (ans+(f[i]-f[i-1]+P)%P*i%P)%P;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000005;\nconst int mod = 1e9 + 7;\n\nint prd[N];\nint inv[N];\n\nint binPow(int x, int y) {\n\tif (!y) return 1;\n\tint ret = binPow(x, y >> 1); ret = 1LL * ret * ret % mod;\n\tif (y & 1) ret = 1LL * ret * x % mod; return ret;\n}\n\ninline int C(int n, int k) {\n\tif (n < k || k < 0) return 0;\n\treturn 1LL * prd[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nint main() {\n\tint n; cin >> n;\n\tprd[0] = 1;\n\tfor (int i = 1; i <= n; ++i) prd[i] = 1LL * prd[i - 1] * i % mod; \n\tinv[n] = binPow(prd[n], mod - 2);\n\tfor (int i = n; i >= 1; --i) inv[i - 1] = 1LL * inv[i] * i % mod;\n\tint res = 0, v0 = 0;\n\tfor (int i = n & 1; i <= n - 2; i += 2) {\n\t\tint j = (n - 2 - i) / 2;\n\t\tint v1 = 1LL * C(i + j, i) * prd[i + j + 1] % mod * prd[n - 2 - i - j] % mod;\n\t\tint v2 = v1 - v0; if (v2 < 0) v2 += mod;\n\t\tv0 = v1;\n\t\t// cout << v2 << ' ' << i << ' ' << j << '\\n';\n\t\tres = (res + 1LL * v2 * (i + j + 1)) % mod;\n\t}\n\tcout << res;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nLL fac[SIZE],inv[SIZE];\nLL mypow(LL x,LL y){\n    LL res=1;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nLL C(int x,int y){\n    if(y<0||y>x)return 0;\n    return fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nvoid build(){\n    assert(MOD>=SIZE);\n    fac[0]=1;\n    REPP(i,1,SIZE)fac[i]=fac[i-1]*i%MOD;\n    inv[SIZE-1]=mypow(fac[SIZE-1],MOD-2);\n    for(int i=SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%MOD;\n}\nint main(){\n    build();\n    int N; R(N);\n    if(N==2)W(1);\n    else if(N==3)W(4);\n    else if(N==4)W(16);\n    else{\n        LL res[3]={};\n        LL an=0;\n        for(int w=0;w<N-1;w++){\n            if(w<=N-4){\n                ADD(res[0],C(N-1-2-w-1,w+1)*2%MOD*(w+1)%MOD*(N-1-w-1)%MOD*fac[N-1-w-2]%MOD*fac[w+1]);\n            }\n            if(w<=N-5){\n                ADD(res[1],C(N-1-3-w-1,w+1)*(w+1)%MOD*(N-1-w-2)%MOD*fac[N-1-w-3]%MOD*fac[w+2]);\n            }\n            ADD(res[2],C(N-1-w-1,w)*2%MOD*(N-1-w)%MOD*fac[N-1-w-1]%MOD*fac[w]);\n        }\n        REP(i,3)ADD(an,res[i]);\n        W(an);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\ntypedef long long ll;\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define ALL(a) (a).begin(), (a).end()\n#define MOD 1000000007\nusing namespace std;\n\nint N;\nll fact[1000001];\nll fact_i[1000001];\n\nll pow_binary(int x, int y) {\n    if (y == 0) return 1;\n\n    ll p = pow_binary(x, y >> 1);\n    if (y % 2 == 0) return p * p % MOD;\n    else            return p * p % MOD * x % MOD;\n}\n\nll ncr(int n, int r) {\n    return fact[n] * fact_i[n - r] % MOD * fact_i[r] % MOD;\n}\n\nint main() {\n    cin >> N;\n    fact[0] = fact[1] = 1;\n    FOR(i, 2, N + 1) fact[i] = fact[i - 1] * i % MOD;\n    fact_i[N] = pow_binary(fact[N], MOD - 2);\n    REP(i, N) fact_i[N - i - 1] = fact_i[N - i] * (N - i) % MOD;\n\n    ll ans = 0;\n    ll count_before = 0;\n    FOR(i, (N + 1) / 2, N) {\n        ll count = ncr(i - 1, N - i - 1) * fact[i] % MOD * fact[N - i - 1] % MOD;\n        ans = (ans + i * (MOD + count - count_before) % MOD ) % MOD;\n        count_before = count;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 1e-10;\n\nstruct ModInt {\n    ll x;\n\n    ModInt(){\n        x = 0LL;\n    }\n\n    ModInt(ll x) {\n        if(x < 0LL) x += MOD * (abs(x)/MOD + 1LL);\n        this->x = x;\n        if(x > MOD) this->x %= MOD;\n    }\n    \n    ModInt pow(ll t) const {\n        ModInt ret = ModInt(1LL), a = ModInt(this->x);\n        while(t){\n            if(t & 1LL){\n                ret = ret * a;\n            }\n            a = a * a;\n            t >>= 1;\n        }\n        return ModInt(ret);\n    }\n\n    ModInt pow(ModInt r) const {\n        return this->pow(r.x);\n    }\n    \n   \n    ModInt operator+(const ModInt& r) const {\n        return ModInt(this->x+r.x);\n    }\n    \n    ModInt operator-(const ModInt& r) const {\n        return ModInt(this->x-r.x);\n    }\n    \n    ModInt operator*(const ModInt& r) const {\n        return ModInt(this->x*r.x);\n    }\n    \n    ModInt operator/(const ModInt& r) const {\n        return ModInt(this->x * r.pow(MOD-2).x);\n    }\n};\n\nModInt comb(vector<ModInt> fact, vector<ModInt> rfact, int n, int r){\n    return fact[n] * rfact[r] * rfact[n-r];\n}\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    ll n;\n    cin >> n;\n    \n    vector<ModInt> fact(n+1);\n    vector<ModInt> rfact(n+1);\n    fact[0] = fact[1] = ModInt(1LL);\n    rfact[0] = rfact[1] = ModInt(1LL);\n    reppp(i, 2, n+1){\n        fact[i] = fact[i-1] * ModInt((ll)i);\n        rfact[i] = ModInt(1LL);\n        ll k = MOD-2LL;\n        ModInt a = fact[i];\n        while(k > 0){\n            if(k & 1) rfact[i] = rfact[i] * a;\n            a = a * a;\n            k >>= 1;\n        }\n    }\n\n    ModInt ans = ModInt(0LL);\n    ModInt p_cnt = ModInt(0LL);\n    reppp(k, n/2, n){\n        if(k-1 < n-1-k) continue;\n        ModInt p = comb(fact, rfact, k-1, n-1-k) * fact[k] * fact[n-1-k];\n        ans = ans + ModInt((ll)k) * (p-p_cnt);\n        p_cnt = p_cnt + p;\n    }\n    cout << ans.x << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 1000005;\n\ntemplate <uint mod>\nclass ModInt {\nprivate:\n    uint v;\n    static uint norm(const uint& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const uint& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static uint inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    uint operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        uint v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i);\n\t\tfac[i] = fac[i-1] * i;\n\t\tfinv[i] = finv[i-1] * inv[i];\n\t}\n}\n\nmod comb(int a, int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a] * finv[b] * finv[a-b];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    make();\n    mod sm = 0;\n    rep(i,n){\n        if(2*i < n) continue;\n        sm += comb(i-1, n-1-i) * fac[i] * fac[n-1-i];\n    }\n    cout << fac[n] - sm << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\n\nconst int N = 500000;\nconst long long MOD = 1e9 + 7;\n\nlong long n;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout << 656;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int N = 1000 * 1000 + 5;\nconst int mod = 1000 * 1000 * 1000 + 7;\n\nlong long fac[N];\nlong long a[N];\nlong long ps[N];\nint po(int x, int y) {\n\tif (y == 0)\n\t\treturn 1;\n\tlong long ans = po(x, y / 2);\n\tans *= ans;\n\tans %= mod;\n\tif (y % 2 == 1) {\n\t\tans *= x;\n\t\tans %= mod;\n\t}\n\treturn ans;\n}\nint chs(int x, int y) {\n\tif (x < y || y < 0)\n\t\treturn 0;\n\tlong long ans = fac[x];\n\tans *= po(fac[y], mod - 2);\n\tans %= mod;\n\tans *= po(fac[x - y], mod - 2);\n\tans %= mod;\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tif (n == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tlong long ans = 0;\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac[i] = fac[i - 1] * i;\n\t\tfac[i] %= mod;\n\t}\n//\tcout << chs(4, 2) << endl;\n\tfor (int i = 2; i < n; i++) {\n\t\ta[i] = chs(i - 1, n - 1 - i);\n\t\ta[i] *= fac[n - i - 1];\n\t\ta[i] %= mod;\n\t\ta[i] *= fac[i];\n\t\ta[i] %= mod;\n\t//\tcout << i << \" \" << chs(i - 1, n - 1 - i) << \" \" << a[i] << endl;\n\t\ta[i] -= ps[i - 1];\n\t\ta[i] += mod;\n\t\ta[i] %= mod;\n\t\tps[i] = ps[i - 1] + a[i];\n\t\tps[i] %= mod;\n\t\tans += a[i] * i;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\nconst int MAX = 1000111;\nMint inv[MAX+1], fact[MAX+1], fact_inv[MAX+1];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i=2; i<=MAX; i++) inv[i] = inv[MOD%i] * (MOD-MOD/i);\n\n    fact[0] = fact_inv[0] = 1;\n    for (int i=1; i<=MAX; i++) {\n\tfact[i] = fact[i-1] * i;\n\tfact_inv[i] = fact_inv[i-1] * inv[i];\n    }\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nint N;\nMint F(int K) {\n    assert(K-1 >= N-1-K);\n    return nCk(K-1, N-1-K) * fact[K] * fact[N-1-K];\n}\n\nvoid MAIN() {\n    init();\n    scanf(\"%d\", &N);\n\n    Mint ans =0 ;\n    Mint prv = 0;\n    for (int k=(N+1)/2; k<=N-1; k++) {\n\tMint nxt = F(k);\n\tans += (nxt - prv) * k;\n\tprv = nxt;\n    }\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n/*\n * Dependencies: typedef long long ll\n * Headers: iostream\n * Verified by: ARC099-F\n *              https://beta.atcoder.jp/contests/arc099/submissions/2743855\n */\n\ntemplate<ll mod = (ll)1e9 + 7>\nstruct ModInt {\n  ll x;\n  ModInt(void): x(0) {}\n  ModInt(ll x): x(x % mod){}\n  ModInt(const ModInt &x): x(x.x) {}\n  ModInt operator+(ModInt o) const {\n    ll y = x + o.x;\n    if (y >= mod) y -= mod;\n    return ModInt(y);\n  }\n  ModInt operator-(ModInt o) const {\n    ll y = x - o.x + mod;\n    if (y >= mod) y -= mod;\n    return ModInt(y);\n  }\n  ModInt operator*(ModInt o) const {\n    return ModInt((x * o.x) % mod);\n  }\n  void operator+=(ModInt o) { *this = *this + o; }\n  void operator-=(ModInt o) { *this = *this - o; }\n  void operator*=(ModInt o) { *this = *this * o; }\n  ModInt operator-(void) const { return ModInt() - *this; }\n  ll to_ll() const {\n    return x;\n  }\n  bool operator<(ModInt o) const {\n    return x < o.x;\n  }\n  ModInt pow(ll e) {\n    assert (e >= 0);\n    ModInt sum = 1;\n    ModInt cur = *this;\n    while (e > 0) {\n      if (e % 2) {\n        sum = sum * cur;\n      }\n      cur = cur * cur;\n      e /= 2;\n    }\n    return sum;\n  }\n  ModInt inv(void) {\n    return pow(mod - 2);\n  }\n};\n\ntemplate<ll mod>\nostream &operator<<(ostream &os, ModInt<mod> mi) {\n  return os << mi.x;\n}\n\n\n#define TEST 0\n\n#if TEST\n\nint main(void) {\n  int n;\n  cin >> n;\n  VI a(n - 1);\n  REP(i, 0, n - 1) a[i] = i;\n  VI ans(n);\n  do {\n    int sc = 0;\n    VI tmp(n);\n    REP(i, 0, n - 1) {\n      sc += 1 - tmp[a[i]];\n      tmp[a[i]] = 1;\n      sc += 1 - tmp[a[i] + 1];\n      tmp[a[i] + 1] = 1;\n      if (sc == n) {\n\tans[i + 1] += 1;\n\tbreak;\n      }\n    }\n  } while (next_permutation(a.begin(), a.end()));\n  ll fac = 1;\n  REP(i, 0, (n + 1) / 2) {\n    fac *= i + 1;\n  }\n  cerr << \"factor = \" << fac << endl;\n  REP(i, 0, n) {\n    cerr << \" \" << ans[i] / fac;\n  }\n  cerr << endl;\n}\n\n\n#else\n\nconst int N = 1001000;\nModInt<> fac[N], invfac[N];\nvoid init(void) {\n  fac[0] = 1;\n  REP(i, 1, N) fac[i] = fac[i - 1] * i;\n  invfac[N - 1] = fac[N - 1].inv();\n  for (int i = N - 2; i >= 0; --i) invfac[i] = invfac[i + 1] * (i + 1);\n}\n\nModInt<> comb(int x, int y) {\n  assert (x >= 0);\n  if (y < 0 || y > x) return 0;\n  return fac[x] * invfac[y] * invfac[x - y];\n}\n\nint main(void) {\n  init();\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n;\n  cin >> n;\n  // Place \"10\" * (n - 1 - i) and \"1\" * (2 * i - n), and place \"1\", forming a string of length n - 1\n  vector<ModInt<> > a(n);\n  REP(i, 1, n) {\n    a[i] = comb(i - 1, n - 1 - i) * fac[i] * fac[n - i - 1];\n  }\n  for (int i = n - 1; i >= 1; --i) a[i] -= a[i - 1];\n  ModInt<> tot;\n  REP(i, 0, n) {\n    tot += a[i] * i;\n  }\n  cout << tot << endl;\n}\n\n#endif\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \n/*\n// ordered_set \n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n# define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n*/\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define Sort(x)                                         sort(all(x))\n# define InTheNameOfGod                                  ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 1e6 + 10;\nconst int xm = - 20 + 10;\nconst int SQ = 320;\nconst int sq = 320 + 10;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst int mod = 1e9 + 7;\nconst int TM = 3;\nconst int base = 257;\n\nll n, ans, fact[xn], inv[xn], res;\n\nll C(ll r, ll n){\n\tif (r < 0 || r > n) return 0;\n\treturn fact[n] * inv[r] % mod * inv[n - r] % mod;\n}\n\nint main(){\n    InTheNameOfGod;\n    \n    cin >> n, -- n;\n    fact[0] = inv[0] = 1;\n    for (int i = 1; i < xn; ++ i){\n    \tfact[i] = fact[i - 1] * i % mod;\n    \tinv[i] = power(fact[i], mod - 2, mod);\n\t}\n\tans = fact[n];\n\tfor (int i = 1; i <= n; ++ i){\n\t\tres = C(n - i, i - 1);\n\t\tres = (C(i, n) - res + mod) % mod;\n\t\tres = res * fact[i] % mod;\n\t\tres = res * fact[n - i] % mod;\n\t\tans = (ans + res) % mod;\n\t}\n\tcout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2000100;\nconst int M=1e9+7;\nint fac[N],n,ans,inv[N],f[N];\nint fp(int x,int y){\n\tint ret=1;\n\tfor (; y; y>>=1,x=(long long)x*x%M) if (y&1) ret=(long long)ret*x%M;\n\treturn ret;\n}\nint c(int x,int y){\n\tif (x>y) return 0;\n\treturn (long long)fac[y]*inv[x]%M*inv[y-x]%M;\n}\nint calcg(int deep,int x){\n\treturn c(x,deep-x+1);\n}\nint main(){\n\tfac[0]=1; for (int i=1; i<=2000000; ++i) fac[i]=(long long)fac[i-1]*i%M;\n\tinv[2000000]=fp(fac[2000000],M-2); for (int i=1999999; i>=0; --i) inv[i]=(long long)inv[i+1]*(i+1)%M;\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<n; ++i){\n\t\tf[i]=(long long)calcg(n-3,n-1-i)*fac[n-1-i]%M*fac[i]%M;\n\t\t(ans+=(long long)((f[i]-f[i-1]+M)%M)*i%M)%=M;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long int;\n\n#define REP(i, N) for (int i = 0; i < (N); ++i)\n#define scanInt(x) int x; scanf(\"%d\", &(x)); getchar();\n#define scanLLInt(x) ll x; scanf(\"%lld\", &(x)); getchar();\n#define scanVecInt(A, N) vector<int> A(N); REP(i, N){scanf(\"%d\", &(A[i])); getchar();}\n#define scanVecLLInt(A, N) vector<ll> A(N); REP(i, N){scanf(\"%lld\", &(A[i])); getchar();}\n\nconstexpr uint mod = 1000000007;\n\n// modをとった和を返す\ninline\nuint modPlus(uint a, uint b){return (a + b) % mod;}\n\n// modをとった差を返す\ninline\nuint modMinus(uint a, uint b){return (mod + a - b) % mod;}\n\n// modをとった積を返す\ninline\nuint modMultiple(uint a, uint b){return (static_cast<long long>(a) * b) % mod;}\n\n\n// 階乗数n!を最初に計算して、呼ばれた時に返す\nclass Factorial {\n    std::vector<uint> table;\npublic:\n    Factorial(uint max) : table(max) // max:テーブルのサイズ\n    {\n        if (max == 0) return;\n        table[0] = 1;\n        for (uint i = 1; i < max; ++i){\n            table[i] = modMultiple(table[i - 1], i + 1);\n        }\n    }\n\n    uint operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\n// 階上数n!の逆数（逆元）を最初に計算して、呼ばれた時に返す\nclass FactorialInverse {\n    std::vector<uint> table;\n    Factorial& fact;\npublic:\n    FactorialInverse(uint max, Factorial fact) : table(max), fact(fact) // max:テーブルのサイズ\n    {\n        if (max == 0) return;\n        uint digit  = 0;\n        {\n            uint temp = mod - 2;\n            while (temp > 0){\n                temp >>= 1;\n                ++digit;\n            }\n        }\n        uint origin = fact(max);\n        std::vector<uint> powerorigin2(digit);\n        powerorigin2[0] = origin;\n        for (uint i = 1; i < digit; ++i){\n            powerorigin2[i] = modMultiple(powerorigin2[i - 1], powerorigin2[i - 1]);\n        }\n        {\n            uint table_max = 1;\n            uint temp = mod - 2;\n            for (uint i = 0; temp > 0; ++i, temp >>= 1){\n                if (!(temp & 1)) continue;\n                table_max = modMultiple(table_max, powerorigin2[i]);\n            }\n            table[max - 1] = table_max; // origin^(mod - 2)\n        }\n        for (int i = max - 2; i >= 0; --i){\n            table[i] = modMultiple(table[i + 1], i + 2);\n        }\n    }\n\n    uint operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        return table[n - 1];\n    }\n};\n\n// N^(2 ^ i)を最初に計算して、呼ばれた時にN^xを計算して返す\nclass PowerN {\n    std::vector<uint> table;\npublic:\n    PowerN(uint N, uint max) // max:使いたい引数nの最大\n    {\n        if (max == 0) return;\n        table.resize(static_cast<uint>(floor(log2f(max))) + 1);\n        table[0] = N;\n        for (uint i = 1; i < table.size(); ++i){\n            table[i] = modMultiple(table[i - 1], table[i - 1]); // N ^ (2 ^ i)\n        }\n    }\n\n    int operator () (int n)\n    {\n        if (n < 0) return 0;\n        if (n == 0) return 1;\n        int result = 1;\n        for (int i = 0; n; ++i, n >>= 1){\n            if (!(n & 1)) continue;\n            result = modMultiple(result, table[i]);\n        }\n        return result;\n    }\n};\n\n// uint nCr = [&](uint n, uint r){\n//     return modMultiple(modMultiple(fact(n), factinv(r)), factinv(n - r));\n// };\n\n\nint sg(int i);\nint db(int i);\n\nnamespace {\n    vector<int> vs;\n    vector<int> vd;\n    int N;\n}\n\nint sg(int i){\n    vs[0] = 0;\n    vs[1] = 1;\n    if (vs[i] != -1) return vs[i];\n    vs[i] = modPlus(vs[i], i);\n    REP(j, N){\n        vs[i] = modPlus(vs[i], modMultiple(vs[j], db(i - 2 - j)));\n    }\n    return vs[i];\n}\n\nint db(int i){\n    if (i == -1) return 0;\n    vd[0] = 0;\n    vd[1] = 2;\n    vd[i] = modPlus(vd[i], i + 1);\n    vd[i] = modPlus(vd[i], modMultiple(sg(i - 1), 2));\n    REP(j, N){\n        vd[i] = modPlus(vd[i], modMultiple(vd[j], db(i - 2 - j)));\n    }\n    return vd[i];\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    vs.resize(N, -1);\n    vd.resize(N, -1);\n    int result = 0;\n    REP(i, N - 1){\n        result = modPlus(result, modMultiple(sg(i), sg(N - 2 - i)));\n    }\n    cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nlong long nn;\nlong long kaik[2000000];\nlong long kai(long long a){\n    if(a==0)return 1;\n    else return (a*kai(a-1))%nn;\n}\nlong long rui(long long a,long long b){\n    if(b==0)return 1;\n    if(b==1)return a%nn;\n    if(b>1){\n        if(b%2==0)return (rui(a,b/2)*rui(a,b/2))%nn;\n        if(b%2==1)return (rui(a,(b+1)/2)*rui(a,(b-1)/2))%nn;\n    }\n}\nlong long c(long long n,long long m){\n    long long x;\n    x=(kaik[n-m]*kaik[m])%nn;\n    long long y;\n    y=(kaik[n]*rui(x,nn-2))%nn;\n    return y;\n}\n\nint main(void){\n    long long i,j,k,x,y,z,n,m,w;\n    nn=1000000007;\n    kaik[0]=1;\n    for(i=1;i<2000000;i++){\n        kaik[i]==(kaik[i-1]*i)%nn;\n    }\n    scanf(\"%lld\",&n);\n    x=(kaik[n-1]*(n-1))%nn;\n    m=(n-2)/2;\n    for(i=1;i<=m;i++){\n        z=(c(n-i-2,n-2*i-2)*kaik[n-1-i])%nn;\n        w=(z*kaik[i])%nn;\n        x-=w;\n        if(x<0)x+=nn;\n    }\n    printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define inf 1000000000\nusing namespace std;\n#define N 1000005\n#define mod 1000000007\nint n,fac[N],inv[N],f[N],ans;\nint ksm(int x,int p){\n\tint ret=1;\n\tfor (; p; p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n\treturn ret;\n}\nint getinv(int x){ return ksm(x,mod-2); }\nint C(int n,int m){ return (ll)fac[n]*inv[n-m]%mod*inv[m]%mod; }\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1; rep (i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=getinv(fac[n]); per (i,n-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\trep (i,(n+1)/2,n-1){\n\t\tf[i]=(ll)fac[i]*fac[n-1-i]%mod*C(2*i-n+(n-2-(2*i-n))/2,2*i-n)%mod;\n\t\tans=(ans+(ll)(f[i]-f[i-1])*i%mod)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static AlgStruct id_add(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static AlgStruct id_mul(Args... args) { return Operators::IdMul(args...); }\n\n    AlgStruct operator+() const { return *this; }\n    AlgStruct operator-() const { return Operators::Opposite(x); }\n    AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    AlgStruct power(LL n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& a){ s << a.x; return s; }\n\n\ntemplate<LL mod>\nstruct GaloisFieldOperators {\n    static LL Add(LL lhs, LL rhs) { return (lhs + rhs) % mod; };\n    static LL Mul(LL lhs, LL rhs) { return (lhs * rhs) % mod; };\n    static LL IdAdd() { return 0; };\n    static LL IdMul() { return 1; };\n    static LL Opposite(LL value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(LL lhs, LL rhs) { return lhs < rhs; };\n    static LL Power(LL value, LL n) {\n        LL res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static LL Reciprocal(LL value) { return Power(value, mod-2); }\n};\n\nconst LL MOD = 1e9+7;\n\nusing GaloisField = AlgStruct<LL, GaloisFieldOperators<MOD>>;\n\n\ntemplate<typename Ring>\nstruct Frac {\n    vector<Ring> frac;\n    Frac(int n) {\n        frac.resize(n+1);\n        frac[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            frac[i] = frac[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return frac[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Frac<Field> frac;\n    Comb(int n) : frac(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return frac[n] / (frac[n-r] * frac[r]);\n    }\n};\n\nsigned main()\n{\n    LL n; cin >> n;\n\n    Frac<GaloisField> frac(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * frac[k] * frac[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (LL k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n    friend istream& operator << (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(int e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n};\nusing mn = modnum<1'000'000'007>;\nusing vmn = vector<mn>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    vmn fact(N + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++)\n        fact[i] = i * fact[i - 1];\n\n    auto ncr = [&fact](int n, int r) {\n        if (r < 0 || n < r) return mn(0);\n        return fact[n] / (fact[r] * fact[n-r]);\n    };\n\n    vmn matl(N);\n    for (int miss = 0; miss <= N - 3; miss++) {\n        mn pick = ncr(N - 2 - miss, miss);\n        matl[miss] = pick * fact[N - 1 - miss] * fact[miss];\n    }\n\n    mn ans = 0;\n    for (int miss = 0; miss <= N - 3; miss++) {\n        ans += (matl[miss] - matl[miss + 1]) * mn(N - 1 - miss);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int mod=1e9+7;\n\nll quick_pow(ll a,ll b){\n\tll ans=1;\n\twhile(b){\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nconst int maxn=2e6+7;\nll fac[maxn],inv[maxn],f[maxn];\n\nll C(ll n,ll m){\n\tif(n<m)  return 0;\n\tif(m==0) return 1;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main (){\n\tint n;cin>>n;\n\tfac[0]=1;fac[1]=1;\n\tfor(int i=2;i<=maxn;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[maxn]=quick_pow(fac[maxn],mod-2);\n\tfor(int i=maxn-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tll ans=fac[n];\n\tfor(int k=1;k<n;k++){\n\t\tans-=C(k-1,n-k-1)*fac[k]%mod*fac[n-k-1]%mod;\n\t\tif(ans<0) ans+=mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nll fact[2000000];\nll ppow(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=(res*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nll C(ll n,ll k){\n\treturn fact[n]*ppow(fact[k],MOD-2)%MOD*ppow(fact[n-k],MOD-2)%MOD;\n}\n\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"1\");return 0;\n\t}\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++)fact[i]=(fact[i-1]*i)%MOD;\n\tll cnt=0,ans=0;\n\tfor(int k=2;k<=n-1;k++){\n\t\tif(k-1<n-k-1)continue;\n\t\tll a=C(k-1,n-k-1)*fact[k]%MOD*fact[n-k-1]%MOD;\n\t\t(ans+=k*(a+MOD-cnt)%MOD)%=MOD;\n\t\tcnt=a;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n;\nconst long long int mod = 1000000007;\nlong long int fct[1001000];\nlong long int ifct[1001000];\nlong long int mpow(long long int x, long long int y) {\n\tif (y == 0)return 1;\n\tlong long int r = mpow(x, y / 2);\n\tr *= r;\n\tr %= mod;\n\tif (y % 2 == 1) {\n\t\tr *= x;\n\t\tr %= mod;\n\t}\n\treturn r;\n}\nlong long int comb(int x, int y) {\n\treturn (fct[x] * ifct[y] % mod)*ifct[x - y] % mod;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfct[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfct[i] = fct[i - 1] * i % mod;\n\t}\n\tifct[n] = mpow(fct[n], mod - 2);\n\tfor (int i = n; i > 0; i--) {\n\t\tifct[i - 1] = ifct[i] * i % mod;\n\t}\n\tlong long int ans = 0;\n\tfor (int i = (n + 1) / 2; i < n; i++) {\n\t\tans += comb(i - 1, 2 * i - n)*fct[i] % mod * fct[n - 1 - i] % mod;\n\t\tans %= mod;\n\t}\n\tans = fct[n] + (mod - ans);\n\tans %= mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define N 1000005\nusing namespace std;\n\ntypedef long long ll;\nll M = 1e9 + 7;\nll n, ans, fac[N] = {1, 1}, inv[N] = {1, 1}, fin[N] = {1, 1};\nint main()\n{\n\tll i;\n\tcin >> n;\n\tfor (i = 2; i <= n; i++) {\n\t\tfac[i] = fac[i - 1] * i % M;\n\t\tinv[i] = inv[M % i] * (M - M / i) % M;\n\t\tfin[i] = fin[i - 1] * inv[i] % M;\n\t}\n\tfor (i = (n + 1) / 2; i < n; i++) {\n\t\tans = (ans + fac[i] * fac[i - 1] % M * fin[i * 2 - n]) % M;\n\t}\n\tcout << (fac[n] - ans + M) % M;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\nusing namespace std;\nint main(void){\n    int n=0,i=0,buf1=0,buf2=0,buf3=0;\n    cin >> n;\n    if(n>1000000||n<2){\n    \texit(0);\n    }\n    buf3=n;\n    n=n-1;\n    vector<long long int> v(n);\n    iota(v.begin(),v.end(),1);\n    do {\n        for(auto x : v)cout << x << \" \";cout << \"\\n\";i++;\n    }while(next_permutation(v.begin(),v.end()));\n    if(buf3%2==0){\n        buf1=(i-2)*3+(2*2);\n    }\n    else{\n        buf1=(i-(buf3%2+buf3/2))*n;\n        /*+((buf3%2+buf3/2)*2)*/\n    }\n    \n    buf2=1000000000+7;\n    cout << i<< endl;\n    cout  << buf1%buf2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> II;\ntypedef pair<long long, int> LLI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<II> VII;\n\n#define For(i,a,b) for(int i = a;i <= b; i++)\n#define Rep(i,a,b) for(int i = a;i >= b; i--)\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, f) for(auto i : f)\n#define fi first\n#define se second\n#define pb push_back\n#define sz(s) int(s.size())\n#define reset(f, x) memset(f, x, sizeof(f))\n#define all(x) x.begin(), x.end()\n#define two(x) (1LL << x)\n#define getbit(x, i) ((x >> (i-1)) & 1LL)\n#define onbit(x, i) (x | (1LL << (i-1)))\n#define offbit(x, i) (x & ~(1 << (i-1)))\n\nconst int M = 1e9 + 7;\nconst int N = 1e6 + 1;\n\nint n;\nLL f[N], res, g[N];\n\nLL pw(LL a, int n) {\n    LL res = 1;\n    while (n) {\n        if (n & 1) res = (res*a) % M;\n        a = (a*a) % M;\n        n >>= 1;\n    }\n    return res;\n}\n\nLL C(int k, int n) {\n    LL res = (g[n]*pw(g[k], M-2)) % M;\n    res = (res*pw(g[n-k], M-2)) % M;\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    cin >> n;\n    g[0] = g[1] = 1;\n    For(i, 2, n) g[i] = (g[i-1]*i) % M;\n    //cout << C(1, 2) << \"\\n\";\n    for(int k = (n+1)/2; k < n; k++) {\n        f[k] = (C(n-k-1, k-1)*g[k]) % M;\n        f[k] = (f[k]*g[n-1-k]) % M;\n        res = (res + ((f[k] - f[k-1])*k) % M) % M;\n    }\n    cout << res;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#include <numeric>\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if ((ll)v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\tstatic int div(int p, int q, int N) {\n\t\tll t=0,nt=1,r=N,nr=q;\n\t\twhile(nr){ ll q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r) { return 0; }\n\t\treturn (int)(((ll)t*(ll)p/r)%N);\n\t}\n};\n#endif\n\n\nclass C {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        auto F = FieldMod::fact(N);\n        auto I = FieldMod::invfact(N);\n\n        FieldMod ans = F[N-1] * (N-1);\n\n        FieldMod tot = 0;\n        for (int i = 1; ; ++i) {\n            if (N-2-i < i) break;\n\n            ans -= F[N-2-i] * I[N-2-i-i] * F[N-1-i];\n\n        }\n\n\n        cout << ans << endl;\n\n//        int ans = 0;\n//        vector<int> P(N-1);\n//        iota(P.begin(),P.end(),0);\n//        do {\n//            vector<bool> S(N, true);\n//            int c = N;\n//            for (int i = 0; i < N-1; ++i) {\n//                c -= S[P[i]];\n//                c -= S[P[i]+1];\n//                S[P[i]] = false;\n//                S[P[i]+1] = false;\n//                if (c == 0) { ans += i+1; break; }\n//            }\n//        } while (next_permutation(P.begin(),P.end()));\n//        cout << ans << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tC solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n\ntypedef long long ll;\n \ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.141592653589;\nconst int mod = 1000000007;\n// memset(a,0,sizeof(a)); →全部０にする\n \nvector<int> G[100005];\nstd::vector<P> tree[100010];\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\n\n#define p(x) cout<<x<<endl;\n \nll i,j,k,l,ii,jj;\nll n,m;\nll x,y;\nll used[200005];\nchar s[305][305];\nll ans=0;\nll v=-1,w;\nll num;\n\n\nll kai(ll n,ll x){\n\tll kei=1;\n\tfor(i=1;i<=n-x;i++){\n\t\tkei *= i;\n\t\tkei = kei%mod;\n\t}\n\treturn kei;\n\n}\nvoid kotae(ll x){\n\tfor(int i=1;i<=n;i++){\n\t\tif(!used[i]){\n\t\t\tused[i]=true;\n\t\t\tif(!used[i-1] && !used[i+1] && i>=2 && i<=n-1){\n\t\t\t\tkotae(x+1);//iminasi kakutei\n\t\t\t}else{\n\t\t\t\tans += kai(n,x);\n\t\t\t}\n\t\t\tused[i]=false;\n\t\t}\n\t}\n \n}\nint main(){\n    cin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tused[i]=true;\n\t\tkotae(1);\n\t\tused[i]=false;\n\n\t}\n\tp(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\n\nint bad(int n) {\n\tstd::vector<int> v(n - 1);\n\tstd::iota(ALL(v), 0);\n\n\tint res = 0;\n\tdo {\n\t\tstd::vector<bool> a(n, false);\n\t\tint rest = n;\n\t\tREP(i, n - 1) {\n\t\t\tif (!a[v[i]]) {\n\t\t\t\t--rest;\n\t\t\t\ta[v[i]] = true;\n\t\t\t}\n\t\t\tif (!a[v[i] + 1]) {\n\t\t\t\t--rest;\n\t\t\t\ta[v[i] + 1] = true;\n\t\t\t}\n\t\t\tif (rest == 0) {\n\t\t\t\tres += i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (std::next_permutation(ALL(v)));\n\treturn res;\n}\n\nint f(int k, int n) {\n\treturn Combination(n - k, k);\n}\n\nint solve(int n) {\n\tint sum = 0;\n\tint res = 0;\n\tFOR(k, (n + 1) / 2, n) {\n\t\tint t = 1;\n\t\t(t *= f(n - k - 1, n - 2)) %= MOD;\n\t\t(t *= fact[k]) %= MOD;\n\t\t(t *= fact[n - k - 1]) %= MOD;\n\t\t(t -= sum) %= MOD;\n\t\tif (t < 0) t += MOD;\n\t\t(sum += t) %= MOD;\n\t\t(t *= k) %= MOD;\n\t\t(res += t) %= MOD;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\t//OUT(bad(n))BR;\n\tOUT(solve(n))BR;\n\n\treturn 0;\n}\n/*\nscore(P) = x\n→ ... [x] [x+1以上] ...\n\nΣ_{k=[ceil(N/2), N-1]}(kをN-k個に分割して並べる場合の数)×(k)!(N-k-1)!\n\n(kをN-k個に分割して並べる場合の数)\n=(N-k-1個をN-1-2個のマスに隣接しないように置く場合の数)\n=(N-k-1個の横の長さ2マスのブロックをN-2個のマスに置く場合の数)\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass mint{\n\tstatic const int MOD=1e9+7;\n\tint x;\npublic:\n\tmint():x(0){}\n\tmint(long long y){ x=y%MOD; if(x<0) x+=MOD; }\n\n\tmint& operator+=(const mint& m){ x+=m.x; if(x>=MOD) x-=MOD; return *this; }\n\tmint& operator-=(const mint& m){ x-=m.x; if(x<   0) x+=MOD; return *this; }\n\tmint& operator*=(const mint& m){ x=1LL*x*m.x%MOD; return *this; }\n\tmint& operator/=(const mint& m){ return *this*=inverse(m); }\n\tmint operator+(const mint& m)const{ return mint(*this)+=m; }\n\tmint operator-(const mint& m)const{ return mint(*this)-=m; }\n\tmint operator*(const mint& m)const{ return mint(*this)*=m; }\n\tmint operator/(const mint& m)const{ return mint(*this)/=m; }\n\tmint operator-()const{ return mint(-x); }\n\n\tfriend mint inverse(const mint& m){\n\t\tint a=m.x,b=MOD,u=1,v=0;\n\t\twhile(b>0){ int t=a/b; a-=t*b; swap(a,b); u-=t*v; swap(u,v); }\n\t\treturn u;\n\t}\n\n\tfriend istream& operator>>(istream& is,mint& m){ long long t; is>>t; m=mint(t); return is; }\n\tfriend ostream& operator<<(ostream& os,const mint& m){ return os<<m.x; }\n\tint to_int()const{ return x; }\n};\n\nmint operator+(long long x,const mint& m){ return mint(x)+m; }\nmint operator-(long long x,const mint& m){ return mint(x)-m; }\nmint operator*(long long x,const mint& m){ return mint(x)*m; }\nmint operator/(long long x,const mint& m){ return mint(x)/m; }\n\nmint fact(int n){\n\tstatic vector<mint> memo={1};\n\tif(memo.size()<=n){\n\t\tint k=memo.size();\n\t\tmemo.resize(n+1);\n\t\tfor(;k<=n;k++) memo[k]=memo[k-1]*k;\n\t}\n\treturn memo[n];\n}\n\nmint fact_inverse(int n){\n\tstatic vector<mint> memo={1};\n\tif(memo.size()<=n){\n\t\tint k=memo.size();\n\t\tmemo.resize(n+1);\n\t\tmemo[n]=inverse(fact(n));\n\t\tfor(int i=n;i>k;i--) memo[i-1]=memo[i]*i;\n\t}\n\treturn memo[n];\n}\n\nmint choose(int n,int k,int type=0){\n\tif(k==0) return 1;\n\tif(n< k) return 0;\n\tif(type==0){\n\t\treturn fact(n)*fact_inverse(k)*fact_inverse(n-k);\n\t}\n\telse{\n\t\tif(k>n-k) k=n-k;\n\t\tmint res=fact_inverse(k);\n\t\trep(i,k) res*=n-i;\n\t\treturn res;\n\t}\n}\n\nmint multichoose(int n,int k,int type=0){\n\treturn choose(n+k-1,k,type);\n}\n\nint main(){\n\tint n; cin>>n;\n\n\tmint ans=0;\n\tfor(int k=n-1;k>0;k--){\n\t\tans+=fact(n-1);\n\t\tif(2*k-n-2>=0) ans-=multichoose(n-k+1,2*k-n-2)*fact(n-k)*fact(k-1);\n\t}\n\tcout<<ans<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/*\n\n\"\"\"\n2 1 1\n3 4 2\n4 16 8/3\n5 84 7/2\n6 516 43/10\n7 3696 77/15\n8 30096 209/35\n9 275040 191/28\n10 2786400 215/28\n11 31000320 299/35\n\nif n odd, try multiplying the fraction by (n-1)(n+3)\n\"\"\"\n\nimport sys\nsys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\n\"\"\"\nimport itertools,fractions\nfor n in range(8,9):\n    tot=0\n    cnt=0\n    arrt=[0]*n\n    for p in itertools.permutations(range(n-1)):\n        cnt+=1\n        arr=[1]*n\n        tmp=0\n        rem=n\n        for i in p:\n            tmp+=1\n            if arr[i]:\n                arr[i]=0\n                rem-=1\n            if arr[i+1]:\n                arr[i+1]=0\n                rem-=1\n            if rem==0: break\n        tot+=tmp\n        arrt[tmp]+=1\n        if tmp==3: print(p)\n    print(arrt)\n    print(n,tot,fractions.Fraction(tot*(n-1)*(n+3))/fractions.Fraction(cnt),tot/cnt)\n\"\"\"\n\n# O(N log MOD)?\n# dp[i] = number of ways to get n-2 letters using i-1 words (a word is A or BB)\n\n\nn=int(input())\nfac=[1]*(n+1)\n\ndef choose(i,j):\n    # i choose j\n    if j<0 or j>i: return 0\n    return fac[i]//fac[j]//fac[i-j]\n\nfor i in range(2,n+1):\n    fac[i]=fac[i-1]*i\n\ndp=[0]*(n+1)\nans=0\ncarry=0\nfor i in range(1,n+1):\n    dp[i]=choose((i-1),(n-2)-(i-1))*fac[i]*fac[n-1-i]\n    if not dp[i]: continue\n    ans+=(dp[i]-dp[i-1])*i\nprint(ans%(10**9+7))\n#print(dp)\n\n*/\n\n#include <stdio.h>\n\nconst int MOD=1000000007;\ntypedef long long ll;\n\nint n;\nll fac[1000005];\nll invfac[1000005];\n\nll powmod(ll a,int b)\n{\n    if (b==1) return a;\n    if (b&1) return (a*powmod((a*a)%MOD,b/2))%MOD;\n    return powmod((a*a)%MOD,b/2);\n}\n\nll inv(int i)\n{\n    return powmod(i,MOD-2);\n}\n\nll choose(int i,int j)\n{\n    if (j<0 || j>i) return 0;\n    return (((fac[i]*invfac[j])%MOD)*invfac[i-j])%MOD;\n}\n\nll dp[1000005];\nll ans=0;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d\",&n);\n    fac[0]=1;\n    invfac[0]=1;\n    fac[1]=1;\n    invfac[1]=1;\n    for (int i=2; i<=n; i++) {\n        fac[i]=(fac[i-1]*i)%MOD;\n        invfac[i]=(invfac[i-1]*inv(i))%MOD;\n    }\n    for (int i=1; i<=n; i++) {\n        dp[i]=(((choose(i-1,n-2-(i-1))*fac[i])%MOD)*fac[n-1-i])%MOD;\n        if (!dp[i]) continue;\n        ans+=(dp[i]-dp[i-1])*i;\n        ans%=MOD;\n    }\n    printf(\"%lld\\n\",(ans+MOD)%MOD);     // negative ans is possible\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst int SIZE = 1000000;\n\nll kai[1000001];\nll dp[1000001];\nll n;\n\nll mod_pow (ll x, ll y) {\n    ll ret = 1;\n    while (y) {\n        if (y&1) ret = ret*x%MOD;\n        x = x * x % MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nll conb (ll x, ll y) {\n    y = kai[y]*kai[x-y]%MOD;\n    y = mod_pow(y, MOD-2);\n    return kai[x]*y%MOD;\n}\n\nvoid init() {\n    kai[0] = 1;\n    for (ll i = 1; i <= SIZE; i++) kai[i] = kai[i-1]*i%MOD;\n}\n\nint main() {\n    init();\n    cin >> n;\n    if (n == 2) {\n        cout << 1 << endl;\n        return 0;\n    }\n    if (n == 3) {\n        cout << 4 << endl;\n        return 0;\n    }\n    ll ans = 0;\n    for (ll k = 2; k <= n-1; k++) {\n        if (k-1 < n-1-k) continue;\n        ll add = kai[k]*kai[n-1-k]%MOD;\n        add = (add * conb(k-1, n-1-k))%MOD;\n        dp[k] = add;\n        ans = (ans+(dp[k]-dp[k-1]+MOD)*k)%MOD;\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <string>\n#include <utility>\n#include <map>\n#include <deque>\n\nusing namespace std;\n#define rep(i,n) for(int i=1;i<=(int)(n);i++)\n#define Rep(i,n) for(int i=0;i<=(int)(n-1);i++)\ntypedef long long ll;\ntypedef map<int,int> mint;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\ntypedef deque<pair<ll,ll>> dep;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint inf=1e9+1000;\nconst int mod=1e9+7;\nll infi=1e18+100;\n\nll N;\n\nll frac(ll n){\n\tif(n==0) return 1;\n\telse return (n*frac(n))%mod;\n}\n\n\nint main(){\n\tcin>>N;\n\tll ninzuu[N+1]={};\n\tll frac[N+3];\n\tRep(i,N+1) frac[i]=frac(i);\n\tll sum=0;\n\tif(N%2==0){\n\t\tfor(int i=N/2;i<=N;i++){\n\t\t\tif(i==N/2) ninzuu[i]=frac[i];\n\t\t\telse{\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\t}\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=(N+1)/2;i<=N;i++){\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t\t\n\t}\n\tcout<<(sum)%mod<<endl;\n\t\n\t\n\t\n\t  return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define N 1000000007\n\nint main(){\n  int n;\n  cin << n;\n  if(n == 2){\n\tcout << 1 << endl;\n    return 0;\n  }\n  int s = 1;\n  for(int i = 2; i < n; i++){\n\ts = (s*i)%N;\n  }\n  s = s*(n-1)%N;\n  int t = 1;\n  for(int i = 2; i <= n-2; i++){\n\tt = t*i%N;\n  }\n  t=t*(n-3)%N;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n# define IL inline\n# define RG register\n# define Fill(a, b) memset(a, b, sizeof(a))\nusing namespace std;\ntypedef long long ll;\n\nIL int Input(){\n    RG char c = getchar(); RG int x = 0, z = 1;\n    for(; c < '0' || c > '9'; c = getchar()) z = c == '-' ? -1 : 1;\n    for(; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n    return x * z;\n}\n\nconst int maxn(1e6 + 5);\nconst int mod(1e9 + 7);\n\nint n, fac[maxn], ifac[maxn], ans, f[maxn];\n\nIL int Pow(RG ll x, RG int y){\n\tRG ll ret = 1;\n\tfor(; y; x = x * x % mod, y >>= 1)\n\t\tif(y & 1) ret = ret * x % mod;\n\treturn ret;\n}\n\nIL int C(RG int x, RG int y){\n\tif(y > x) return 0;\n\treturn 1LL * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nIL void Upd(RG int &x, RG int y){\n\tx += y;\n\tif(x >= mod) x -= mod;\n}\n\nint main(RG int argc, RG char* argv[]){\n\tn = Input(), fac[0] = ifac[0] = 1;\n\tfor(RG int i = 1; i <= n; ++i) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tifac[n] = Pow(fac[n], mod - 2);\n\tfor(RG int i = n - 1; i; --i) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % mod;\n\tfor(RG int i = (n + 1) >> 1; i < n; ++i) f[i] = 1LL * C(i - 1, n - i - 1) * fac[i] % mod * fac[n - i - 1] % mod;\n\tfor(RG int i = n - 2, l =(n + 1) >> 1; i >= l; --i) Upd(f[i + 1], mod - f[i]);\n\tfor(RG int i = (n + 1) >> 1; i < n; ++i) Upd(ans, 1LL * f[i] * i % mod);\n\tprintf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nusing ll = long long;\nconst ll MAX = 1000010;\nconst ll mod = 1000000007;\nll fact[MAX],inv[MAX],fi[MAX];\nvoid fii(){\n    inv[1] = 1;\n    for(int i=2;i<=100000;i++){\n        inv[i] = mod - mod/i*inv[mod%i]%mod;\n    }\n    fact[0] = 1; fact[1] = 1; fi[0] = 1; fi[1] = 1;\n    for(int i=2;i<=100000;i++){\n        fact[i] = fact[i-1]*i%mod;\n        fi[i] = fi[i-1]*inv[i]%mod;\n    }\n}\n\nll nck(int n, int k){\n    if(k>n) return 0;\n    return fact[n]*fi[n-k]%mod*fi[k]%mod;\n}\n\nll dp[1000010],ans = 0;\nint main(){\n    int i,n;\n    cin >> n;\n    fii(); dp[0] = 0;\n    for(i=1;i<n;i++){\n        dp[i] = nck(i-1,n-1-i)*fact[i]%mod*fact[n-1-i]%mod;\n    }\n    for(i=1;i<n;i++){\n        (ans += (mod + dp[i]-dp[i-1])%mod*i) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<stack>\n#include<set>\n#include<map>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<algorithm>\n#include<list>\n#include<functional>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define INF 1987654321\n#define PI 3.14159265358979323846264\n#define fup(i,a,b,c) for(int (i)=(a);(i)<=(b);(i)+=(c))\n#define fdn(i,a,b,c) for(int (i)=(a);(i)>=(b);(i)-=(c))\n#define MEM0(a) memset(a,0,sizeof(a));\n#define MEM_1(a) memset(a,-1,sizeof(a));\n#define ALL(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<double> Vd;\ntypedef vector<Pi> VPi;\ntypedef vector<Pll> VPll;\ntypedef vector<Pd> VPd;\ntypedef tuple<int, int, int> iii;\ntypedef tuple<ll, ll, ll> LLL;\ntypedef vector<iii> Viii;\ntypedef vector<LLL> VLLL;\ntypedef complex<double> base;\nll MOD = 1000000007;\nll POW(ll a, ll b, ll MMM = MOD) { ll ret = 1; for (; b; b >>= 1, a = (a*a) % MMM)if (b & 1)ret = (ret*a) % MMM; return ret; }\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\nll lcm(ll a, ll b) { if (a == 0 || b == 0)return a + b; return a*(b / gcd(a, b)); }\nint dx[] = { 0,-1,1,0 }, dy[] = { 1,0,0,-1 };\nint ddx[] = { 0,0,1,1,1,-1,-1,-1 }, ddy[] = { 1,-1,1,0,-1,1,0,-1 };\n\nll fac[1000001];\nll inv[1000001];\nll nCr(int n, int r)\n{\n\tll c = fac[n];\n\tc = (c*inv[r]) % MOD;\n\tc = (c*inv[n - r]) % MOD;\n\treturn c;\n}\nint n;\nll res(int k)\n{\n\tll c = fac[k];\n\tc = (c*fac[n - 1 - k]) % MOD;\n\tc = (c*nCr(k - 1, n - 1 - k)) % MOD;\n\treturn c;\n}\nint main() {\n\tfac[0] = inv[0] = 1;\n\tfup(i, 1, 1000000, 1)\n\t\tfac[i] = (fac[i - 1] * i) % MOD;\n\tinv[1000000] = POW(fac[1000000], MOD - 2);\n\tfdn(i, 999999, 1, 1)\n\t\tinv[i] = (inv[i + 1] * (i+1)) % MOD;\n\tscanf(\"%d\", &n);\n\tll ans = 0;\n\tll pre = 0;\n\tfup(k, (n - 1) / 2 + 1, n - 1, 1)\n\t{\n\t\tll t = res(k);\n\t\tans = (ans + k*((t-pre+MOD)%MOD)) % MOD;\n\t\tpre = t;\n\t}\n\tprintf(\"%lld\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\ntemplate <class T, std::size_t N>\nclass factorials {\npublic:\n  using value_type = T;\n  static constexpr std::size_t size = N;\n\npublic:\n  std::array<value_type, size + 1> fact{};\n  std::array<value_type, size + 1> fact_inv{};\n\n  factorials() {\n    fact.front() = value_type(1);\n    for (std::size_t i = 1; i <= size; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv.back() = ~fact.back();\n    for (std::size_t i = size; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (std::size_t n, std::size_t r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modular<1000000007>;\nfactorials<modint, 1000000> fact;\n\nint main() {\n  int N;\n  std::cin >> N;\n  if (N == 2) {\n    std::cout << \"1\\n\";\n    return 0;\n  }\n  auto calc = [&](int black, int white) {\n    if (black < 0 || white < 0) return modint(0);\n    if (white > black + 1) return modint(0);\n    return fact(black + 1, white);\n  };\n  auto expected1 = [&](int black, int white) {\n    if (black < 2 || white < 0) return modint(0);\n    return modint(black) * modint(black - 1) * fact.fact[black + white - 2] * fact.fact_inv[black + white];\n  };\n  auto expected2 = [&](int black, int white) {\n    if (black < 1 || white < 0) return modint(0);\n    return modint(black) * fact.fact[black + white - 1] * fact.fact_inv[black + white];\n  };\n  modint ans;\n  for (int put: range(2, N)) {\n    int empty = N - put - 1;\n    modint coeff(2 * empty + 2);\n    coeff -= modint(put - 2) * expected1(empty, put - empty - 1);\n    coeff -= modint(2) * expected2(empty, put - empty - 1);\n    ans += coeff * calc(put - 2, empty) * fact.fact[put] * fact.fact[empty];\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\n\nll fact(ll x){\n  ll res=1;\n  while(x>1){\n    res*=x;\n    res%=MOD;\n    x--;\n  }\n  return res%MOD;\n}\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  REP(i,n+1)a[i]=i;\n  int sm=0;\n  for(int i=(n+1)/2;i<=n-1;i++){\n    sm+=(i*(n-i)*fact(i))%MOD;\n  }\n  P(sm);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 1000001, md = 1000000007;\n\nlong long f[MX], inv[MX], f_inv[MX];\n\nint main() {\n\tf[0] = f[1] = inv[1] = f_inv[0] = f_inv[1] = 1;\n\tfor (int i = 2; i < MX; i++) {\n\t\tf[i] = f[i - 1] * i % md;\n\t\tinv[i] = md - (md / i) * inv[md % i] % md;\n\t\tf_inv[i] = f_inv[i - 1] * inv[i] % md;\n\t}\n\t\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\t\n\tif (n == 2) {\n\t\tprintf(\"%d\\n\", 1);\n\t\treturn 0;\n\t}\n\t\n\tint ans = 0, sum = 0;\n\tfor (int k = 2; k < n; k++) {\n\t\tif (n - 1 - k > k - 1) continue;\n\t\t\n\t\tint x = f[k - 1] * f[k] % md * f_inv[2 * k - n] % md;\n\t\tans = (ans + (x - sum) * (long long)(k)) % md;\n\t\tsum = x;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <istream>\n\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nnamespace asl\n{\n    \n    void asl_assert(bool condition)\n    {\n\n    }\n} \n\n#include <experimental/optional>\n\nnamespace asl\n{\n    \n    const int m1000000007 = 1000000007;\n    \n    int MOD = m1000000007;\n\n    void set_mod(int mod)\n    {\n        MOD = mod;\n    }\n\n    class Mint\n    {\n    public:\n        int val;\n\n        Mint(long long v = 0)\n        {\n            if (v >= 0)\n            {\n                if (v < MOD)\n                    val = v;\n                else\n                    val = v % MOD;\n            }\n            else\n            {\n                if (v >= -MOD)\n                {\n                    val = v + MOD;\n                }\n                else\n                {\n                    v %= MOD;\n                    if (v < 0)\n                        v += MOD;\n                    val = v;\n                }\n            }\n        }\n\n        Mint &operator+=(const Mint &other)\n        {\n            val += other.val;\n            if (val >= MOD)\n                val -= MOD;\n            return *this;\n        }\n\n        Mint &operator-=(const Mint &other)\n        {\n            val -= other.val;\n            if (val < 0)\n                val += MOD;\n            return *this;\n        }\n\n        static unsigned fast_mod(uint64_t x, unsigned m = MOD)\n        {\n#if !defined(_WIN32) || defined(_WIN64)\n            return x % m;\n#endif\n            \n            unsigned x_high = x >> 32, x_low = (unsigned)x;\n            unsigned quot, rem;\n            asm(\"divl %4\\n\"\n                : \"=a\"(quot), \"=d\"(rem)\n                : \"d\"(x_high), \"a\"(x_low), \"r\"(m));\n            return rem;\n        }\n\n        Mint &operator*=(const Mint &other)\n        {\n            val = fast_mod((uint64_t)val * other.val);\n            return *this;\n        }\n\n        friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }\n        friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }\n        \n        friend std::ostream &operator<<(std::ostream &stream, const Mint &m)\n        {\n            return stream << m.val;\n        }\n\n    };\n \n    std::vector<Mint> inv = {0, 1}, factorial = {1, 1}, inv_factorial = {1, 1};\n\n    void prepare_factorials(int maximum)\n    {\n        factorial.resize(maximum + 1);\n        inv.resize(maximum + 1);\n        inv_factorial.resize(maximum + 1);\n\n        for (int p = 2; p * p <= MOD; p++)\n            asl_assert(MOD % p != 0);\n\n        for (int i = 2; i <= maximum; ++i)\n        {\n            factorial[i] = i * factorial[i - 1];\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n            inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n        }\n    }\n\n    Mint choose(long long n, long long r)\n    {\n        asl_assert(n < inv_factorial.size());\n        asl_assert(n < factorial.size());\n\n        if (r < 0 || r > n)\n            return 0;\n        return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n    }\n\n} \n\n#include <random>\n\n#define endl '\\n'\n\nusing namespace std;\nusing namespace asl;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    set_mod(m1000000007);\n\n    int n;\n    cin >> n;\n\n    if (n == 2)\n    {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    prepare_factorials(n + 1);\n\n    Mint ans, prev;\n\n    for (int k = 2; k <= n - 1; ++k)\n    {\n        Mint cur = choose(k - 1, n - k - 1) * factorial[k] * factorial[n - 1 - k];\n        ans += (cur - prev) * k;\n        prev = cur;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nlong long nn;\nlong long kai(long long a){\n    if(a==0)return 1;\n    else return (a*kai(a-1))%nn;\n}\nlong long rui(long long a,long long b){\n    if(b==0)return 1;\n    if(b==1)return a%nn;\n    if(b>1){\n        if(b%2==0)return (rui(a,b/2)*rui(a,b/2))%nn;\n        if(b%2==1)return (rui(a,(b+1)/2)*rui(a,(b-1)/2))%nn;\n    }\n}\nlong long c(long long n,long long m){\n    long long x;\n    x=(kai(n-m)*kai(m))%nn;\n    long long y;\n    y=(kai(n)*rui(x,nn-2))%nn;\n    return y;\n}\n\nint main(void){\n    long long i,j,k,x,y,z,n,m,w;\n    nn=1000000007;\n    scanf(\"%lld\",&n);\n    x=(kai(n-1)*(n-1))%nn;\n    m=(n-2)/2;\n    for(i=1;i<=m;i++){\n        z=(c(n-i-2,n-2*i-2)*kai(n-1-i))%nn;\n        w=(z*kai(i))%nn;\n        x-=w;\n        if(x<0)x+=nn;\n    }\n    printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\nstruct Factorial{\n  vector<Mod> v;\n  Factorial( int max_n ){\n    v = vector<Mod>( max_n , 1 );\n    FOR( i , 1 , max_n ) v[i] = v[i-1] * i;\n  }\n  int size(){\n    return v.size();\n  }\n  Mod operator [] ( int id ){\n    return v.at(id);\n  }\n};\n\nstruct Factorial_inv{\n  vector<Mod> v;\n  Factorial_inv( Factorial &f ){\n    v = vector<Mod>( f.size() );\n    REP( i , f.size() ) v[i] = inv( f[i] );\n  }\n  Mod operator [] ( int id ){\n    return v.at(id);\n  }\n};\n\nstruct Combination{\n  Factorial *f;\n  Factorial_inv *finv;\n  Combination( Factorial &arg_f , Factorial_inv &arg_finv ){\n    f = &arg_f;\n    finv = &arg_finv;\n  }\n  Mod operator () ( int a , int b ){\n    return (*f)[a] * (*finv)[b] * (*finv)[a-b];\n  }\n};\n\nFactorial fact( 1000010 );\nFactorial_inv finv( fact );\nCombination comb( fact , finv );\n\nint main(){\n  \n  int n = in();\n  Mod ans = 0;\n  Mod cur = 0;\n  FOR(i, (n+1)/2, n){\n    int cz = i * 2 - n;\n    // cout << i << \" \" << cz << endl;\n    Mod res = fact[i] * fact[n-1-i] * comb(i-1, cz);\n    // cout << i << \" \" << (res - cur).n << \" \" << res.n << \" \" << cur.n << endl;\n    ans += (res - cur) * i;\n    cur = res;\n  }\n\n  cout << ans.n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007;\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  long long int v2[N];\n  constexpr Fact() : val(), v2() {\n    val[0] = 1;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n    for(int i = 1; i < N; ++i)v2[i] = val[i - 1] * val[i] % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000001>();\nconstexpr auto ifact = IFact<1000001, 397802501>();\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += fact.v2[i] * ifact.val[i * 2 - N] % M;\n    }\n    ans = fact.val[N] - fact.val[N - 1] - ans;\n    ans %= M;\n    printf(\"%lld\\n\",(ans > 0 ? ans : M + ans));\n    //cout << (ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename S, typename T>\nvoid incr_m(M<S, T> &m, S k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD   ((ll)pow(10LL, 9LL) + 7LL)\n\nvoid make_perms(ll perms[1000005], ll perm_invs[1000005])\n{\n    perms[0] = 1LL;\n    srep (i, 1LL, 100004LL) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= MOD;\n    }\n\n    debug_printf(\"---- perms\\n\"); debug_print(perms, 10);\n\n    rep (i, 1000005) perm_invs[i] = mod_inv(perms[i], MOD);\n}\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n\n    if (n == 2) {\n        cout << 1 << endl;\n        return;\n    }\n    if (n == 3) {\n        cout << 2 * 2 << endl;\n        return;\n    }\n\n    static ll perms[1000005];\n    static ll perm_invs[1000005];\n    make_perms(perms, perm_invs);\n\n    static ll cnts[1000005];\n    memset(cnts, 0, sizeof(cnts));\n    rep (blackcnt, n+1LL) {\n        if (blackcnt - 1LL < n - 1LL - blackcnt) continue;\n        // (blackcnt - 1LL)_C_(n - 1LL - blackcnt)\n        cnts[blackcnt] = perms[blackcnt];\n        cnts[blackcnt] *= perm_invs[n - 1LL - blackcnt];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perm_invs[2 * blackcnt - n];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perms[blackcnt - 1LL];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perms[n - 1LL - blackcnt];\n        cnts[blackcnt] %= MOD;\n    }\n    debug_printf(\"---- cnts\\n\"); debug_print(cnts, 10);\n\n    ll ans = 0LL;\n    srep (score, 1LL, n) {\n        ll incr = cnts[score] - cnts[score-1];\n        while (incr < 0LL) incr += MOD;\n        incr *= score;\n        incr %= MOD;\n        ans += incr;\n        ans %= MOD;\n    }\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX = 1e6 + 10;\n\ntemplate<int mod>\nclass ModCalc {\nprivate:\n    const int defnum = -1;\npublic:\n    ModCalc() { }\n    int add(int a, int b) {\n        a += b;\n        while (a < 0) a += mod;\n        while (a >= mod) a -= mod;\n        return a;\n    }\n    int mul(int a, int b) {\n        return (long long)a * b % mod;\n    }\n    int pow(int a, int p) {\n        int res = 1;\n        while (p > 0) {\n            if (p & 1) res = this->mul(res, a);\n            a = this->mul(a, a);\n            p >>= 1;\n        }\n        return res;\n    }\n    int inverse(int a) {\n        return this->pow(a, mod - 2);\n    }\n};\n\nModCalc<MOD> mc;\nint memoFact[MAX], memoInvFact[MAX];\n\nint fact(int n) {\n    if (memoFact[n] != -1) return memoFact[n];\n    return memoFact[n] = (n == 0 ? 1 : mc.mul(n, fact(n - 1)));\n}\n\nint invFact(int n) {\n    if (memoInvFact[n] != -1) return memoInvFact[n];\n    return memoInvFact[n] = mc.inverse(fact(n));\n}\n\nlong long Perm(int n, int r) {\n    return mc.mul(fact(n), invFact(n - r));\n}\n\nlong long comb(int n, int r) {\n    return mc.mul(mc.mul(fact(n), invFact(r)), invFact(n - r));\n}\n\n// M個の物をN人で分ける\nlong long combWithRepetition(int M, int N) {\n    return comb(M + N - 1, N - 1);\n}\n\n//最初に呼んで♪\nvoid init() {\n    memset(memoFact, -1, sizeof(memoFact));\n    memset(memoInvFact, -1, sizeof(memoInvFact));\n    for (int i = 0; i < MAX; i++) {\n        fact(i);\n        invFact(i);\n    }\n}\n\nint N;\n\nint main(void) {\n    init();\n    cin >> N;\n    LL ans = 0;\n    LL foo = 0;\n    const int mi = (N + 1) / 2;\n    FOR(i, mi, N) {\n        const auto bar = mc.add(mc.mul(fact(i), mc.mul(fact(N - 1 - i), comb(i - 1, N - 1 - i))), -foo);\n        ans = mc.add(ans, mc.mul(bar, i));\n        foo = mc.add(foo, bar);\n        //DEBUG(ans)\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong m=1e9+7,n;\nlong fac[1<<20],inv[1<<20];\nlong p(long a,long b){return b?p(a*a%m,b/2)*(b%2?a:1)%m:1;}\nlong c(int a,int b){return fac[a]*inv[b]%m*inv[a-b]%m;}\nmain()\n{\n\tcin>>n;\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%m;\n\tinv[n]=p(fac[n],m-2);\n\tfor(int i=n;i--;)inv[i]=inv[i+1]*(i+1)%m;\n\tlong ans=fac[n];\n\tfor(int k=(n+1)/2;k<n;k++)\n\t{\n\t\tans=(ans-c(k-1,n-k-1)*fac[k]%m*fac[n-k-1]%m+m)%m;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#define for1(i,l,r) for(int i=(l);i<(r);i++)\n#define for2(i,l,r) for(int i=(l);i>(r);i--)\n#define int long long\nusing namespace std;\nconst int mod=1e9+7;\nint lt[2000005],tlt[2000005],n,ans,cnt;\nint binpow(int a,int b){\n\tif(b==0) return 1;\n\tif(b==1) return a;\n\tint mid=binpow(a,b/2);\n\tif(b%2==0) return mid*mid%mod;\n\telse return mid*mid%mod*a%mod;\n}\nint c(int n,int k){\n\tint tmp=lt[n];\n\ttmp*=tlt[k];\n\ttmp%=mod;\n\ttmp*=tlt[n-k];\n\ttmp%=mod;\n\tif(n>=k) return tmp;\n\telse return 0;\n}\nsigned main(){\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tlt[0]=1;\n\tfor(int i=0;i<2000004;i++){\n\t\tif(i) lt[i]=lt[i-1]*i%mod;\n\t\ttlt[i]=binpow(lt[i],mod-2);\n\t}\n\tcin>>n;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tint tmp=(c(i-1,n-i-1)*lt[i]%mod*lt[n-i-1]%mod-cnt%mod)%mod;\n\t\ttmp%=mod;\n\t\tans+=tmp*i;\n\t\tans%=mod;\n\t\tcnt+=tmp;\n\t\tcnt%=mod;\n\t}\n\tcout<<ans;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb(x) push_back(x)\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\n\nconst int MAX_N = 1e6;\nll fac[MAX_N+1], ifac[MAX_N+1], inv[MAX_N+1];\n\nll mpow(ll x, ll n){\n    ll res = 1, now = x;\n    while(n > 0){\n        if(n & 1) res *= now, res %= MOD;\n        now *= now, now %= MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nvoid init(){\n    rep2(i, 1, MAX_N){\n        inv[i] = mpow(i, MOD-2);\n    }\n    //i!とi!の逆元\n    fac[0] = 1, ifac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = (fac[i-1]*i) % MOD;\n        ifac[i] = (ifac[i-1]*inv[i]) % MOD;\n    }\n}\n\nll comb(int n, int k){\n    ll c = fac[n];\n    c *= ifac[n-k], c %= MOD;\n    c *= ifac[k], c %= MOD;\n    return c;\n}\n\nll perm(int n, int k){\n    return(fac[n]*ifac[n-k])%MOD;\n}\n\nint main(){\n    init();\n    int N;\n    cin >> N;\n    //num[i]:=スコアがi以下になるような並べ方の数\n    ll ans = 0, num[N];\n    //i個のマシンで全てを黒にする場合\n    rep(i, N){\n        if(2*i < N) {num[i] = 0; continue;}\n        num[i] = fac[i]*fac[N-1-i]%MOD;\n        num[i] *= comb(i-1, N-i-1), num[i] %= MOD;\n        ans = ans+(MOD+num[i]-num[i-1])*i, ans %= MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nconst ll mod = 1000000007LL;\n\nll I[1000010];\nvoid inv_table(int n){I[1]=1LL;rep(i,2,n+1) I[i]=I[mod%i]*(mod-mod/i) % mod;}\n\nll F[1000010],IF[1000010];\nvoid fact_table(int n){F[0]=IF[0]=1LL; rep(i,1,n+1) F[i]=F[i-1]*i % mod,IF[i]=IF[i-1]*I[i]%mod;}\n\ninline ll comb(int n,int k){\n\tif(n < 0 or k < 0 or n-k < 0) return 0;\n\treturn F[n]*IF[k] % mod *IF[n-k] % mod;\n}\n\nll val[1000010];\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\tinv_table(n);\n\tfact_table(n);\n\n\tll ans = 0LL;\n\n\t// 1 | 2 | 3 | 4 | ... | n\n\n\trep(k,n) val[k] = F[k] * F[n-1-k] % mod * comb(k-1,n-1-k) % mod;\n\n\trep(k,1,n){\n\t\tll cur = val[k] - val[k-1] + mod % mod;\n\t\tans += 1LL * k * cur % mod;\n\t\tans %= mod;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint fact[1000005], fact_i[1000005];\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 1000005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 1000005; i++){\n\t\tfact_i[i] = pow(fact[i], mod-2);\n\t}\n}\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_i[k], ret %= mod;\n\tret *= fact_i[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint func(llint N, llint r)\n{\n\tllint batsu = N-r;\n\treturn comb(N+1-batsu, batsu) % mod;\n}\n\nllint N;\n\nint main(void)\n{\n\tcin >> N;\n\tif(N == 2){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmake_fact();\n\t\n\tllint ans = 0;\n\tfor(int i = N/2; i <= N-1; i++){\n\t\tllint cnt = 0;\n\t\tif(N >= 3) cnt += func(N-3, i-2) * 2;\n\t\tif(N >= 7) cnt += (func(N-7, i-5) * 2*(N-6)) % mod, cnt %= mod;\n\t\tif(N >= 6) cnt += (func(N-6, i-4) * 4*(N-5)) % mod, cnt %= mod;\n\t\tif(N >= 8) cnt += (func(N-8, i-5) * (N-7)) % mod, cnt %= mod;\n\t\tif(N >= 7) cnt += (func(N-7, i-4) * (N-6)) % mod, cnt %= mod;\n\t\tif(N == 5 && i == 3) cnt += 2;\n\t\tif(N == 6 && i == 3) cnt += 3;\n\t\tcnt *= fact[i-1] % mod, cnt %= mod;\n\t\tcnt *= fact[(N-1)-i] % mod, cnt %= mod;\n\t\tans += (cnt * i) % mod, ans %= mod;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <string>\n#include <utility>\n#include <map>\n#include <deque>\n\nusing namespace std;\n#define rep(i,n) for(int i=1;i<=(int)(n);i++)\n#define Rep(i,n) for(int i=0;i<=(int)(n-1);i++)\ntypedef long long ll;\ntypedef map<int,int> mint;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\ntypedef deque<pair<ll,ll>> dep;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint inf=1e9+1000;\nconst int mod=1e9+7;\nll infi=1e18+100;\n\nll N;\n\nll frac(ll n){\n\tif(n==0) return 1;\n\telse return (n*frac(n))%mod;\n}\n\n\nint main(){\n\tcin>>N;\n\tll ninzuu[N+1]={};\n\tll frac[N+3];\n\tfor(ll i=0;i<=N;i++) frac[i]=frac(i);\n\tll sum=0;\n\tif(N%2==0){\n\t\tfor(ll i=N/2;i<=N;i++){\n\t\t\tif(i==N/2) ninzuu[i]=frac[i];\n\t\t\telse{\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\t}\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t}\n\telse{\n\t\tfor(ll i=(N+1)/2;i<=N;i++){\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t\t\n\t}\n\tcout<<(sum)%mod<<endl;\n\t\n\t\n\t\n\t  return 0;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 1000100\n#define mod 1000000007\nusing namespace std;\nint fac[maxn],inv[maxn],A[10010];\nint qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint C(int x,int y){\n\tif(y<0||y>x)return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tinv[0]=1,fac[0]=1;\n\tfor(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=qpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tint ans=0;\n\tfor(int i=0;i<n;++i)\n\t\tans=(ans+1ll*(C(n-1,i)-C(i-1,n-i-1)+mod)*fac[i]%mod*fac[n-i-1]%mod)%mod;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\nconst int MOD = (int) 1e9 + 7;\n\nint Pow(int x, int y) {\n    int ret = 1;\n    for (;y > 0; y /= 2) {\n        if (y & 1) {\n            ret = ret * (int64_t) x % MOD;\n        }\n        x = x * (int64_t) x % MOD;\n    }\n    return ret;\n}\n\nint invMod(int x) {\n    return Pow(x, MOD - 2);\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << 1 << '\\n';\n    } else if (n == 3) {\n        cout << 4 << '\\n';\n    } else {\n        vector<int> fact(n + 1, 1);\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i - 1] * (int64_t) i % MOD;\n        }\n        vector<int> inv(n + 1, 0);\n        inv[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            inv[i] = (MOD - MOD / i) * (int64_t) inv[MOD % i] % MOD;\n        }\n        vector<int> ifact(n + 1, 1);\n        for (int i = 1; i <= n; ++i) {\n            ifact[i] = ifact[i - 1] * (int64_t) inv[i] % MOD;\n        }\n        auto comb = [&](int n, int k) -> int {\n            if (n < 0 || k < 0 || k > n) {\n                return 0;\n            }\n            return fact[n] * (int64_t) ifact[n - k]  % MOD * ifact[k] % MOD;\n        };\n        int ans = fact[n - 1] * (int64_t) n % MOD;\n        for (int k = 0; k < n; ++k) {\n            int v = comb(n - 1 - k - 1, k);\n            v = v * (int64_t) fact[k] % MOD;\n            v = v * (int64_t) fact[n - k - 1] % MOD;\n            ans = (ans - v + MOD) % MOD;\n        }\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 34; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long Div(long long a, long long b, long long m) {\n\treturn (a*modpow(b, m - 2, m)) % m;\n}\n\nlong long N, fact[1000009], factinv[1000009], inv[1000009], mod = 1000000007;\nconst int MAX_N = 1000006;\n\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= MAX_N; i++) { fact[i] = 1LL * fact[i - 1] * i; fact[i] %= mod; }\n\tfor (int i = 0; i <= MAX_N; i++) factinv[i] = Div(1, fact[i], mod);\n\tfor (int i = 1; i <= MAX_N; i++) inv[i] = Div(1, i, mod);\n}\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\tlong long R = factinv[r] * factinv[n - r]; R %= mod;\n\treturn (R*fact[n]) % mod;\n}\n\nint main() {\n\tcin >> N;\n\tif (N == 2) { cout << \"1\" << endl; return 0; }\n\tif (N == 3) { cout << \"4\" << endl; return 0; }\n\tif (N == 4) { cout << \"16\" << endl; return 0; }\n\n\tlong long sum = 0; init();\n\n\tfor (int i = 3; i <= N; i++) {\n\t\tlong long E = 2 * (i - 1) - (N - 2);\n\t\tlong long V = ncr(i - 1, E);\n\t\tlong long U = E*(E - 1); U %= mod;\n\t\tU *= inv[i - 1]; U %= mod;\n\t\tU *= inv[i - 2]; U %= mod;\n\t\tU = (mod + 1 - U); U %= mod;\n\t\tU *= (i - 2); U %= mod; U += 2; U %= mod;\n\n\t\tV *= U; V %= mod;\n\t\tV *= (fact[i - 1] * fact[N - 1 - i]) % mod; V %= mod;\n\t\tsum += (V*i) % mod; sum %= mod;\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1000000007, MAXN = 1000 * 1000 + 100;\n\nint ans[MAXN], fact[MAXN], inv[MAXN];\n\nvoid PreWorks();\nint power(int a, int b);\nint chose(int k, int n);\n\nint main() {\n\tPreWorks();\n\tint n;\n\tll all = 0;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++)\n\t\tans[i] = (ll)chose(n - i - 1, i - 1) * fact[i] % MOD * fact[n - i - 1] % MOD;\n\tfor (int i = 1; i < n; i++) {\n\t\tall += (ll)(ans[i] - ans[i - 1]) * i % MOD;\n\t\t//cerr << ans[i] << ' ';\n\t\tall %= MOD;\n\t}\n\t//cerr << endl;\n\tcout << all % MOD;\n}\n\nint power(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\tint t = power(a, b / 2);\n\treturn b % 2? (ll)t * t % MOD * a % MOD: (ll)t * t % MOD;\n} \n\nvoid PreWorks() {\n\tfact[0] = 1;\n\tinv[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\tinv[i] = power(fact[i], MOD - 2);\n\t}\n}\n\nint chose(int k, int n) {\n\treturn (ll)fact[n] * inv[n - k] % MOD * inv[k] % MOD * (k >= 0 && n >= k);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing pi = pair<ll, ll>;\nusing vi = vector<ll>;\nconst int maxn = 1e6 + 55, mod = 1e9 + 7;\nint fact[maxn], inv[maxn];\nint mul(int x, int y) {\n\treturn x*1ll*y%mod;\n}\nvoid setup() {\n\tfact[0] = inv[0] = 1;\n\tfor(int i = 1; i < maxn; i++) {\n\t\tfact[i] = mul(fact[i-1], i);\n\t\tinv[i] = i > 1 ? (mod - mul(mod/i, inv[mod%i]))%mod : 1;\n\t}\n\tfor(int i = 1; i < maxn; i++) inv[i] = mul(inv[i], inv[i-1]);\n}\nint n;\nint nck(int n, int k) {\n\tif(k>n) return 0;\n\treturn mul(mul(fact[n], inv[k]), inv[n-k]);\n}\nint f(int k) {\n\treturn mul(mul(nck(k-1, n-1-k), fact[n-1-k]), fact[k]);\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tsetup();\n\tcin >> n;\n\tint ans = 0;\n\tfor(int i = 1; i < n; i++) {\n\t\tint t = (mod + f(i) - f(i-1))%mod;\n\t\tans = (ans + 1ll * t * i)%mod;\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 1200000\n\nconst LL mod=1000000007;\nLL n,fac[N],ifac[N],ans,f[N];\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nLL inv(LL x){\n\treturn x==1?1:(mod-mod/x)*inv(mod%x)%mod;\n}\n\nLL C(LL x,LL y){\n\treturn x<y||y<0?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfac[0]=1; for (LL i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;\n\tifac[n]=inv(fac[n]); for (LL i=n-1;~i;--i) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tfor (LL i=1;i<n;++i){\n\t\tf[i]=C(i-1,n-1-i)*fac[i]%mod*fac[n-i-1]%mod;\n\t\tupd(ans,(f[i]-f[i-1])*i);\n\t}\n\tupd(ans,mod);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int L = 1e6 + 10;\nconst int M = 1e9 + 7;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint fact[L];\nint rfact[L];\n\nint ncr(int n, int k) {\n    if (k < 0 || k > n)\n        return 0;\n    return (ll) fact[n] * rfact[k] % M * rfact[n - k] % M;\n}\n\nconst int N = 15;\n\nint f[N][N];\n\nvoid smain() {\n\n    fact[0] = 1;\n    for (int i = 1; i < L; ++i) {\n        fact[i] = (ll) fact[i - 1] * i % M;\n    }\n    rfact[L - 1] = pw(fact[L - 1]);\n    for (int i = L - 2; i >= 0; --i) {\n        rfact[i] = (ll) rfact[i + 1] * (i + 1) % M;\n    }\n\n//    f[1][1] = 1;\n//    for (int i = 2; i < N; ++i) {\n//        for (int j = 2; j < N; ++j) {\n//            f[i][j] = f[i - 1][j - 1] + f[i - 2][j - 1];\n//            cout << f[i][j] - 1 * ncr(j - 1, i - j) << ' ';\n//        }\n//        cout << '\\n';\n//    }\n\n\n\n\n    int n;\n    cin >> n;\n    n--;\n    vi g(n + 1);\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        g[i] = ncr(i - 1, n - i);\n//        g[i] = f[n][i];\n        g[i] = (ll) g[i] * fact[i] % M * fact[n - i] % M;\n        for (int j = 1; j < i; ++j) {\n            g[i] = (g[i] - g[j] + M) % M;\n        }\n//        cerr << \"g[\" << i << \"] = \" << g[i] << endl;\n        int cur = (ll) g[i] * i % M;\n        ans = (ans + cur) % M;\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n \ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define in(x, a, b) a <= x && x < b\nconst int inf = 1000000001;\nconst ll INF = 2e18;\nconst ll MOD = 1000000007;\n//const ll mod = 1000000009;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p <<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\n\nconst int MAXN = 1000010;\n\n\nvll part(MAXN + 1, vl(MAXN + 1));\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n\tfact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n\tfor (ll i = 2; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % M;\n\t\trfact[i] = mod_inverse(fact[i], M);\n\t}\n}\n\nll nCr(ll n, ll r, ll M = MOD) {\n\tll ret = fact[n];\n\tret = (ret*rfact[r]) % M;\n\tret = (ret*rfact[n - r]) % M;\n\treturn ret;\n}\n\n\nint main() {\n  ll n;\n  cin >> n;\n  set_fact(n);\n  vl num(n);\n  rep1(k, n - 1) {\n    if (k - 1 < n - 1 - k) {\n      continue;\n    }\n    num[k] = nCr(k - 1, n - 1 - k);\n  }\n  vl num2(n);\n  rep1(k, n - 1) {\n    num2[k] = (num[k]) % MOD * fact[k] % MOD * fact[n - 1 - k] % MOD;\n  }\n     \n  //DEBUG_VEC(num2);\n  ll ans = 0;\n  rep1(k, n - 1) {\n    ans += (num2[k] - num2[k - 1]) % MOD * k % MOD;\n    ans %= MOD;\n  }\n  while (ans < 0) {\n    ans += MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n \nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n \ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a ? gcd (b % a, a) : b; }\n\nconst int mod = 1000*1000*1000+7;\n\nconst int N = 1000100;\n \nint n;\nint m;\nint f[N + 1];\nint rf[N + 1];\n\nint power (int a, int b) {\n    int c = 1;\n    while (b) {\n        if (b & 1) c = ((ll)c * a) % mod;\n        a = ((ll)a * a) % mod;\n        b /= 2;\n    }\n    re c;\n}\n\nint cnk (int n, int k) {\n    if (n < 0 || k < 0 || k > n) re 0;\n    re ((ll)f[n] * rf[k] % mod * rf[n - k]) % mod;\n}\n\nint fab (int a, int b) {\n    if (b == 0) re f[a];\n    if (a < b + 1) re 0;\n    a -= b + 1;\n    re ((ll)cnk (a + b, b) * f[a + b + 1] % mod * f[b]) % mod;\n}\n\nint calc (int n) {\n    int ans = 0;\n    int cur = 0;\n    for (int i = 0; i < n; i++) {\n        int tmp = fab (i, n - i - 1);\n        ans = (ans + (ll)(tmp - cur + mod) % mod * i) % mod;\n        cur = tmp;\n    }\n    re ans;\n}\n \nint main () {\n    f[0] = rf[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        f[i] = ((ll)f[i - 1] * i) % mod;\n        rf[i] = power (f[i], mod - 2);\n    } \n    cin >> n;\n    cout << calc (n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nlong long mod_pow(long long x,long long n){\n    if(n==0) return 1;\n    long long res = mod_pow(x*x % mod, n/2);\n    if(n & 1) res = res*x % mod;\n    return res;\n}\nlong long fact[1000010];//書き換えよう!\nlong long get_nCk(long long n, long long k){\n    if(fact[0] == 0){\n        fact[0] = 1;\n        for(int i = 1; i < 1000010; i++) fact[i] = fact[i-1] * i % mod;\n    }\n    if(k < 0 || k > n) return 0;\n    return fact[n] * mod_pow(fact[k], mod - 2) % mod * mod_pow(fact[n - k], mod - 2) % mod;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    get_nCk(1, 1);\n    int n;\n    cin >> n;\n    if(n == 2){\n        cout << 1 << endl;\n        return 0;\n    }\n    int ans = 0;\n    rep(k, (n + 1) / 2, n){\n        int tmp = fact[k] * fact[n - 1 - k] % mod * get_nCk(k - 1, n - 1 - k) % mod;\n        int tmp2 = fact[k - 1] * fact[n - k] % mod * get_nCk(k - 2, n  -  k) % mod;\n        int tmp3 = (tmp - tmp2 + mod) % mod * k % mod;\n        (ans += tmp3) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#ifdef DEBUG\n#include \"cout11.h\"\n#undef NDEBUG\n#endif\n#include <cassert>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n\n\nll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\n\nconst ll M=1000000007LL;\n\nll ADD(ll x, ll y) { return (x+y) % M; }\nll SUB(ll x, ll y) { return (x-y+M) % M; }\nll MUL(ll x, ll y) { return x*y % M; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { assert(y%M!=0); return MUL(x, POW(y, M-2)); }\n// ll comb(ll n, ll k) { ll v=1; for(ll i=1; i<=k; i++) v = DIV(MUL(v, n-i+1),i); return v; }\n\n\nint N;\n\n\nll _fact[1000001];\n\nvoid _prepare_fact(){\n    _fact[0] = _fact[1] = 1LL;\n    for(int i=2; i<=N; ++i) {\n        _fact[i] = MUL(_fact[i-1], i);\n    }\n}\n\ninline ll fact(int x){\n    assert(IN(x,0,N));\n    return _fact[x];\n}\n\n\nll sub(int k) {\n    // k回以内で\n    // a +  b = k - 1\n    // a + 2b = N - 2\n    int a = k*2 - N;\n    if (a < 0) return 0;\n    int b = N - k - 1;\n    // fprintf(stderr, \" // N=%d, k=%d; a=%d, b=%d;; %d %d %d %d %d\\n\", N,k,a,b, a+b, a,b,k,N-1-k);\n    assert(a+b == k-1);\n    assert(a+b*2 == N-2);\n\n    return MUL(\n            DIV(fact(a+b),\n                MUL(fact(a), fact(b))),\n            MUL(fact(k), fact(N-1-k))\n        );\n}\n\nll solve() {\n    ll total = 0;\n    ll last = 0;\n    for (int k=1; k<=N-1; ++k) {\n        ll a = sub(k), x = SUB(a, last);\n        total = ADD(total, MUL(x, k));\n        // fprintf(stderr, \"<=k=%d: %lld ; x=%lld\\n\", k,a, x);\n        last = a;\n    }\n    return total;\n}\n\nint main() {\n    cin >> N;\n    assert(IN(N,2,1000000));\n\n    _prepare_fact();\n\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<boost/multiprecision/cpp_int.hpp>\nusing namespace std;\nusing bigint = boost::multiprecision::cpp_int;\n\nbigint M = 1000000007, m = 335790106025098313, n = 489373567, mask = 1152921504606846975;\n\ninline bigint MR(bigint A){\n    return (A + M * (m * A & mask)) >> 60;\n}\n\ninline bigint Prod(bigint lhs, bigint rhs){\n    return MR(MR(lhs * rhs) * n);\n}\n\nlong long int N;\nbigint fact[10010101], ifact[10010101], ans;\n\nint main(){\n    scanf(\"%lld\", &N);\n    fact[0] = 1;\n    for(int i = 1; i < N; ++i){\n        fact[i] = Prod(fact[i - 1], i);\n    }\n    bigint n = M - 2, r = fact[N - 1];\n    ifact[N - 1] = 1;\n    while(n){\n        if(n & 1){\n            ifact[N - 1] = ifact[N - 1] * r % M;\n        }\n        n /= 2;\n        r = r * r % M;\n    }\n    for(int i = N - 1; i > 0; --i){\n        ifact[i - 1] = Prod(ifact[i], i);\n    }\n    ans = fact[N - 1] * (N - 1);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += M - Prod(Prod(fact[i], fact[i - 1]), ifact[i * 2 - N]);\n    }\n    ans %= M;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res=res*x%MOD;\n        k>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nll modInv(ll x){\n    return powm(x,MOD-2);\n}\nint main(){\n    int n;\n    cin>>n;\n    vector<ll> fact(n+1);\n    fact[0]=1;\n    for(int i=1;i<=n;i++){\n        fact[i]=fact[i-1]*i%MOD;\n    }\n    vector<ll> factInv(n+1);\n    factInv[n]=modInv(fact[n]);\n    for(int i=n-1;i>=0;i--){\n        factInv[i]=factInv[i+1]*(i+1)%MOD;\n    }\n    vector<ll> pow2(n+1);\n    pow2[0]=1;\n    for(int i=1;i<=n;i++){\n        pow2[i]=pow2[i-1]*2%MOD;\n    }\n    ll res=fact[n-1];\n    auto comb=[&](int n,int k){\n        return fact[n]*factInv[k]%MOD*factInv[n-k]%MOD;\n    };\n    auto cnt=[&](int k){\n        int q=n-2-(k-1);\n        int p=2*(k-1)-(n-2);\n        if(q<=0) return 0LL;\n        else if(p<0) return comb(n-1,k);\n        else return ((comb(n-1,k)-comb(p+q,p))%MOD+MOD)%MOD;\n    };\n    for(int k=1;k<=n-1;k++){\n        res+=cnt(k)*fact[n-1-k]%MOD*fact[k]%MOD;\n        res%=MOD;\n    }\n    cout<<res<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) { }\n\tModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b; std::swap(a, b);\n\t\t\tu -= t * v; std::swap(u, v);\n\t\t}\n\t\tif (u < 0) u += Mod;\n\t\tModInt res; res.x = (unsigned)u;\n\t\treturn res;\n\t}\n\n\tbool operator==(ModInt that) const { return x == that.x; }\n\tbool operator!=(ModInt that) const { return x != that.x; }\n\tModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile (k) {\n\t\tif (k & 1) r *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\ntypedef ModInt<1000000007> mint;\n\nvector<mint> fact, factinv;\nvoid nCr_computeFactinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1); factinv.resize(N + 1);\n\tfact[0] = 1;\n\tfor (int i = 1; i <= N; ++ i)\n\t\tfact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor (int i = N; i >= 1; i --) factinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif (n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) * nCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nint main() {\n\tint N;\n\twhile (~scanf(\"%d\", &N)) {\n\t\tif (N == 2) {\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tnCr_computeFactinv(N);\n\t\tmint ans = fact[N - 1] * (N - 1);\n\t\tfor (int i = 1; i <= N - 3; ++ i) {\n\t\t\tans -= nCr(N - 3 - i + 1, i) * fact[i] * fact[N - 1 - i];\n\t\t}\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define mod 1000000007\nlong long inv[1000010];\n\nvoid getinv(){\n  for (int i = 1; i <= 1000010; i++) {\n    if (i == 1) inv[i] = 1;\n    else {\n      inv[i] = (mod - (mod / i) * inv[mod % i]) % mod;\n      if (inv[i] < 0) inv[i] += mod;\n    }\n  }\n}\n\nint main(){\n  int n; cin >> n;\n  long long c = 1;\n  getinv();\n  for (int i = 1; i < n; i++) {\n    c *= i;\n    c %= mod;\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n - 3; i++) {\n    c *= (n-2-2*i-1);\n    c %= mod;\n    c *= (n-2-2*i-1);\n    c %= mod;\n    c *= inv[i+1];\n    c %= mod;\n    c *= inv[n-2-i];\n    c %= mod;\n    c *= inv[n-i];\n    c %= mod;\n    ans += c;\n    ans %= mod;\n    //(n-2-i)_C_i * (n-i-1)! % mod;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint N;\nconst int MOD = 1000000007;\nint Fact[1000005], Inv[1000005];\nint V[1000005];\nint power(int n, int p)\n{\n    int sol = 1;\n    while(p)\n    {\n        if((p & 1))\n        {\n            sol = (1LL * sol * n) % MOD;\n        }\n        n = (1LL * n * n) % MOD;\n        p /= 2;\n    }\n    return sol;\n}\nvoid precalcFact()\n{\n    Fact[0] = 1;\n    for(int i = 1; i <= N; i++)\n    {\n        Fact[i] = (1LL * Fact[i - 1] * i) % MOD;\n    }\n    Inv[N] = power(Fact[N], MOD - 2);\n    for(int i = N - 1; i >= 0; i--)\n    {\n        Inv[i] = (1LL * Inv[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nint Comb(int n, int k)\n{\n    return (((1LL * Fact[n] * Inv[k]) % MOD) * Inv[n - k]) % MOD;\n}\ninline void Add(int& x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\ninline void Sub(int& x, int y)\n{\n    x -= y;\n    if(x < 0)\n        x += MOD;\n}\nvoid Solve()\n{\n    --N;\n    for(int i = 1; i <= N; i++)\n    {\n        if(i < N - i)\n            continue;\n        int aux = Comb(i - 1, N - i);\n        aux = (1LL * aux * Fact[i]) % MOD;\n        aux = (1LL * aux * Fact[N - i]) % MOD;\n        V[i] = aux;\n    }\n    int ans = 0;\n    for(int i = N; i >= 1; i--)\n    {\n        Sub(V[i], V[i - 1]);\n        Add(ans, (1LL * V[i] * i) % MOD);\n    }\n    cout << ans << \"\\n\";\n}\nint main()\n{\n    cin >> N;\n    precalcFact();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cmath>\n\n#define pf printf\n// #define DEBUG true\n#define DEBUG false\n#define IFD if(DEBUG)\n#define FOR(i,ii,n) for(long long i=ii; i<n; i++)\n#define FORREV(i,ii,n) for(long long i=n-1; i>=ii; i--)\n#define INF ((ll)1e15)\n\nusing namespace std;\ntypedef long long ll;\n\nll const NMAX = 1000001;\n// ll mod = 998244353;\nll mod = 1e9 + 7;\nll fact[NMAX];\nll finv[NMAX];\nll comb(ll n,ll a){\n\treturn fact[n] * finv[a] % mod * finv[n-a] % mod;\n}\nll pow(ll a,ll n){\n\tll prd = 1;\n\tll exp = a;\n\twhile(n > 0){\n\t\tif((n&1)==1){\n\t\t\tprd *= exp;\n\t\t\tprd %= mod;\n\t\t}\n\t\texp *= exp;\n\t\texp %= mod;\n\t\tn >>= 1;\n\t}\n\treturn prd;\n}\n\nll gcd(ll a,ll b){\n\tif(a<b){\n\t\tll tmp = b;\n\t\tb = a;\n\t\ta = tmp;\n\t}\n\tll r = a % b;\n\tif(r==0) return b;\n\treturn gcd(b,r);\n}\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\n\nll numk[NMAX];\nint main(){\n\tll N;\n\tcin >> N;\n\t// init\n\tfact[0] = 1;\n\tfinv[0] = 1;\n\tFOR(i,1,N+1){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tfinv[i] = pow(fact[i], mod-2);\n\t}\n\t// main\n\t// ll least = ceil(N*1.0/2)\n\tll least = ceil(N*1.0/2);\n\tFOR(k,least,N){\n\t\tnumk[k] = comb(k-1, N-1-k) % mod * fact[k] % mod * fact[N-1-k] % mod;\n\t}\n\tll sum = least * numk[least];\tFOR(i,least+1,N){\n\t\tsum += i * (numk[i] - numk[i-1]);\n\t\tsum %= mod;\n\t}\n\tif(sum < 0) sum+=mod;\n\tpf(\"%lld\", sum);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*input\n100000\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=1000005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll f[maxn]={1};\nll inv[maxn];\n\nll cnt[maxn];\n\nint main()\n{\n\tIOS;\n\tint n;\n\tcin>>n;\n\n\tfor(int i=1;i<maxn;i++) f[i]=f[i-1]*i%MOD;\n\tfor(int i=0;i<maxn;i++) inv[i]=mypow(f[i],MOD-2);\n\n\tfor(int i=1;i<=n;i++){\n\t\tif(i+i<n) cnt[i]=0;\n\t\telse cnt[i]=f[i]*f[i-1]%MOD*inv[i+i-n]%MOD;\n\t}\n\tll ans=0;\n\n\tfor(int i=1;i<=n;i++){\n\t\tans+=i*(cnt[i]-cnt[i-1]+MOD)%MOD;\n\t\tif(ans>=MOD) ans-=MOD;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e6 + 5;\nconst ll p = 1e9 + 7;\nll exp(ll x, ll k) {\n  if (k == 0)\n    return 1;\n  if (k % 2 == 1)\n    return x * exp(x, k - 1) % p;\n  ll y = exp(x, k / 2);\n  return y * y % p;\n}\nll inv(ll x) { return exp(x, p - 2); }\nll fact[MAXN], invfact[MAXN], n;\nll binom(ll a, ll b) {\n  if (a < b || a < 0 || b < 0)\n    return 0;\n  return fact[a] * invfact[b] % p * invfact[a - b] % p;\n}\nll s = 0;\nint main() {\n  cin >> n;\n  n--;\n  fact[0] = invfact[0] = 1;\n  for (int i = 1; i < MAXN; ++i) {\n    fact[i] = i * fact[i - 1] % p;\n    invfact[i] = inv(fact[i]) % p;\n  }\n  for (int k = 1; k <= n; ++k) {\n    s += (p + 1 - binom(k - 1, n - k) * fact[k] * fact[n-1-k]);\n    s %= p;\n  }\n  s++;\n  for (int i = 1; i <= n; ++i)\n    s = s * i % p;\n  cout << s << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long int\n#define mod 1000000007 \n#define pb push_back\n//#define mp make_pair\n#define INF 2000000011LL\n#define INFLL 1000000000000000011LL\n#define eps 1e-9\n#define pp pair < pair<ll,ll> , ll> \n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define foll(i,j,k) for(ll i=j;i<=k;i++)\n#define clr(a) memset(a,0,sizeof(a))\n#define vi vector<int>\n#define vll vector<ll>\n#define sz(a) a.size()\n#define len(a) a.length()\n#define all(a) a.begin(),a.end()\n#define io_file freopen(\"Contest/input_file.in\", \"r\", stdin); freopen(\"Contest/output_file.in\", \"w\", stdout)\n\nconst int MAXN = 2e5+5;\nusing namespace std;\nll power(ll x, ll y)\n{\n  ll res = 1;\n  while(y>0)\n  {\n    if(y&1)\n       {\n         res = (res*x)%mod;\n        }\n     x = (x*x)%mod;\n     y = y>>1;\n  }\n    return res;\n}\n// std::vector<ll> divi[100004];\n// void divisor(int n)\n// {\n//    for(ll i=1;i<=n;i++)\n//    {\n//      for(ll j=i;j<=n;j+=i)\n//      {\n//        divi[j].pb(i);\n//      }\n//    }\n// }\n\n\n\nll n;\nll fact[1000005];\nll rev[1000005];\n\nll factorial(int x)\n{\n  if(x < 0) return 0;\n  return fact[x];\n}\nll revfact(int x)\n{\n  if(x< 0) return 0;\n  return rev[x];\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    fact[0] = 1;\n    rev[0] = 1;\n    int n;\n    cin>>n;\n    for(int i=1;i<1000005;i++)\n    {\n      fact[i] = (fact[i-1]*(ll)i)%mod;\n      rev[i] = (rev[i-1]*power((ll)i,mod-2))%mod;\n    }\n    ll ans = ((n-1)*fact[n-1])%mod;\n    for(int i = 2;i<=n;i++)\n    {\n\n      ans = (ans - (((factorial(n-i)*factorial(n-i-1))%mod)*revfact(n-2*i))%mod + mod)%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M=1E9+7;\n\nunsigned int doit(int i,int j){\n\tif (i==j) return 0;\n\tif (j-i==1) return 1;\n\tint mid=(i+j)/2;\n\tunsigned int ret=(doit(i,mid)+doit(mid+1,j))%M;\n\tlong long p = (1LL * (mid-i+1) * (j-mid))%M;\n\tret = (ret + p)%M;\n\treturn ret;\n}\n\nint main(){\n\tint n,cin>>n;\n\tunsigned int s=doit(0,n-1);\n\tcout << s+1;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=1e6+2;\nconst int mod=1e9+7;\nint fact[N],inv[N];\nint binpow(int x,int y){\n\tint tich=1;\n\twhile(y){\n\t\tif((y&1)){\n\t\t\ttich*=x;\n\t\t\ttich%=mod;\n\t\t}\n\t\tx*=x;\n\t\tx%=mod;\n\t\ty>>=1;\n\t}\n\treturn tich;\n}\nint C(int x,int y){\n\treturn ((fact[y]*inv[y-x])%mod*inv[x])%mod;\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,now=0,ans=0;\n\tcin>>n;\n\tfact[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tfact[i]=(fact[i-1]*i)%mod;\n\t\t//cout<<fact[i]<<endl;\n\t}\n\tinv[n]=binpow(fact[n],mod-2);\n\tfor(i=n;i>=1;i--){\n\t\tinv[i-1]=(inv[i]*i)%mod;\n\t\t//cout<<inv[i-1]<<endl;\n\t}\n\tfor(i=(n+1)/2;i<n;i++){\n\t\tj=((C(n-i-1,i-1)*fact[i])%mod*fact[n-1-i])%mod;\n\t\t//cout<<i<<\" \"<<j<<endl;\n\t\tans+=((j-now)*i)%mod;\n\t\tans%=mod;\n\t\tnow=j%mod;\n\t\t//cout<<ans<<endl;\n\t}\n\tif(ans<0){\n\t\tans+=mod;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "//ΔAGC023C\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 1e6+16;\nconst int mod = 1e9+7;\nint fpow(int x,int y=mod-2){\n\tif(!y)\n\t\treturn 1;\n\tLL z=fpow(x,y>>1);\n\tz=z*z%mod;\n\tif(y&1)\n\t\tz=z*x%mod;\n\treturn z;\n}\nint fac[N],inv[N];\nint n,f[N];\nint main()\n{\n\tint i,x,ans=0;\n\tcin>>n;\n\tif(n==2){\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tif(n==3){\n\t\tcout<<4;\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(i=1;i<=n;i=i+1)\n\t\tfac[i]=(LL)fac[i-1]*i%mod;\n\tinv[n]=fpow(fac[n]);\n\tfor(i=n;i;i=i-1)\n\t\tinv[i-1]=(LL)inv[i]*i%mod;\n\tn--;\n\tf[0]=fac[n];\n\tfor(i=1;i<=n-i+1;i=i+1){\n\t\tif(i>n-i-1)\n\t\t\tf[i]=0;\n\t\telse\n\t\t\tf[i]=(LL)fac[n-i-1]*inv[n-i-i-1]%mod*fac[n-i]%mod;\n\t\tx=(f[i-1]-f[i]+mod)%mod;\n\t\tans+=(LL)x*(n-i+1)%mod;\n\t\tans%=mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define MOD 1000000007\nLL powmod(LL a, LL n){\n    if(n == 0) return 1;\n    if(n % 2) return (a*powmod(a,n-1)) % MOD;\n    LL c = powmod(a, n/2);\n    return (c*c) % MOD;\n}\nLL inv(LL a){\n    return powmod(a, MOD-2);\n}\nLL fact[1100000];\nLL invfact[1100000];\n\nLL ncr(LL n, LL r){\n    if(r < 0 || n < 0) return 0;\n    if(n < r) return 0;\n    LL a = fact[n];\n    a = (a * invfact[r]) % MOD;\n    a = (a * invfact[n-r]) % MOD;\n    return a;\n}\nvoid init(){\n    fact[0] = 1;\n    invfact[0] = 1;\n    LL inv2 = inv(2);\n    for(LL i = 1; i < 1100000; i++){\n        fact[i] = (i*fact[i-1]) % MOD;\n        invfact[i] = inv(fact[i]);\n    }\n}\n\n// call init();\n\nint main(){\n\tinit();\n\tLL n;\n\tcin >> n;\n\tLL ans = (n-1) * fact[n-1];\n\tans %= MOD;\n\tLL k = n-2;\n\tfor(LL a = 1; a*2 <= k; a++){\n\t\tLL cur = fact[k-a];\n\t\tcur = (cur * fact[n-1-a]) % MOD;\n\t\tcur = (cur * invfact[k-2*a]) % MOD;\n\t\tans -= cur;\n\t\tans %= MOD;\n\t}\n\tif(ans < 0) ans += MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nconstexpr int MN = 1000001;\nconstexpr ll MOD = 1e9+7;\n\nll fact[MN] = { 1 }, ifact[MN] = { 1 };\n\ninline ll pw(ll base, ll exp) {\n\tll res = 1;\n\twhile (exp) {\n\t\tif (exp & 1) (res *= base) %= MOD;\n\t\texp >>= 1, (base *= base) %= MOD;\n\t}\n\treturn res;\n}\n\ninline ll inv(ll x) { return pw(x, MOD - 2); }\n\ninline ll nCr(int n, int k) { return fact[n]*ifact[k]%MOD*ifact[n-k]%MOD; }\n\nint main() {\n    if (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    int N; cin >> N;\n\n    for (int i = 0; i < N; ++i) fact[i+1] = (i+1ll)*fact[i]%MOD, ifact[i+1] = inv(fact[i+1]);\n    \n    ll sum = 0, ans = 0;\n    for (int i = N/2; i < N; ++i) {\n        ll tmp = nCr(i-1, N-i-1)*fact[i]%MOD*fact[N-i-1]%MOD;\n        (ans += i*(tmp-sum+MOD)) %= MOD;\n        sum = tmp;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool p(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 100)sum += (x % poow(sinsuu, i + 1)) / (poow(sinsuu, i));\n\treturn sum;\n}\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[1114514];\nsigned main(){\n\tic(n)\n\tint k=1;\n\trep(2,i,n){\n\t\tif(i==2)k*=i;\n\t\telse k*=(i-1);\n\t\tk%=mod;\n\t}\n\ta[0]=k;\n\tint j=1;\n\tint l=n-3;\n\tint t=1;\n\trep(1,i,n/2){\n\t\tint bu=(sankaku(i+1)-1+(n-i*2-2)*i)%mod;\n\t\ta[i]=gyakugen(a[i-1],j*bu%mod)*(((l*2-t+mod)%mod*sankaku(i)%mod)%mod)%mod;\n\t\tif(i<n/2-1){\n\t\t\tj=gyakugen(j,i)*(n-i*2)%mod;\n\t\t\tj=gyakugen(j,n-i-1)*(n-i*2-1)%mod;\n\t\t\tl=gyakugen(l,i+1)*(n-i*2-2)%mod;\n\t\t\tl=gyakugen(l,n-i-2)*(n-i*2-3)%mod;\n\t\t\tt=gyakugen(t,i)*(n-i*2-2)%mod;\n\t\t\tt=gyakugen(t,n-i-3)*(n-i*2-3)%mod;\n\t\t}\n\t\t\n\t}\n\tint ans=0;\n\trep(0,i,n){\n\t\tans+=a[i]*i;\n\t\tans%=mod;\n\t}\n\tint m=n-1;\n\trep(1,i,n){\n\t\tm*=i;\n\t\tm%=mod;\n\t}\t\n\tc((m+mod-ans)%mod)\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\nll modpow(ll x, ll n, ll mod = MOD) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nll f[1000005], fi[1000005];\n\nll comb(int r, int c) {\n    if (r < c) return 0;\n    return f[r] * fi[c] % MOD * fi[r - c] % MOD;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << 1 << endl;\n        return 0;\n    } else if (n == 3) {\n        cout << 4 << endl;\n        return 0;\n    }\n\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) f[i] = f[i - 1] * i % MOD;\n\n    fi[n] = modpow(f[n], MOD - 2);\n    for (int i = n; i > 0; i--) {\n        fi[i - 1] = fi[i] * i % MOD;\n    }\n\n    ll ans = 0, prv = 0;\n    for (int i = 1; i < n; i++) {\n        ll cur = comb(i - 1, n - 1 - i) * f[i] % MOD * f[n - 1 - i] % MOD;\n        (ans += (cur + MOD - prv) * i % MOD) %= MOD;\n        prv = cur;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long \n#define MAX_N 400010\n#define MOD 1000000007\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    make();\n    ll n;\n    cin >> n;  \n    vector<ll> a(n);\n    rep(i,n){\n        if(i>=n-2){\n            a[i] = fac[n-1];\n        }\n        a[i] = comb(n-2-i,i)*fac[i]%mod;\n        a[i] *= fac[n-1-i]%mod;\n        a[i] = (fac[n-1]-a[i]+mod)%mod;\n    }\n    for(int i=n-1;i>=1;i--){\n        a[i] += mod-a[i-1];\n        a[i] %= mod;\n    }\n    //rep(i,n)cerr << a[i] << endl;\n    ll sm = 0;\n    rep(i,n){\n        sm += (n-i)*a[i]%mod;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433L;\n\ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n/*\n * @title ModInt\n */\ntemplate<long long mod> class ModInt {\npublic:\n\tlong long x;\n\tconstexpr ModInt():x(0) {\n\t\t// do nothing\n\t}\n\tconstexpr ModInt(long long y) : x(y>=0?(y%mod): (mod - (-y)%mod)%mod) {\n\t\t// do nothing\n\t}\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const long long y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const int y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const long long y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const int y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt operator=(const int y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator=(const long long y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator-() const { return ModInt(-x); }\n\tModInt operator++() { \n\t\tx++;\n\t\tif(x>=mod) x-=mod;\n\t\treturn *this; \n\t}\n\tModInt operator--() { \n\t\tx--;\n\t\tif(x<0) x+=mod;\n\t\treturn *this; \n\t}\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\tModInt inv() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(long long n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tlong long t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n};\nusing modint = ModInt<MOD>;\n\n/*\n * @title CombinationMod\n */\ntemplate<long long mod> class CombinationMod {\n\tvector<long long> fac,finv,inv;\npublic:\n\tCombinationMod(int N) : fac(N + 1), finv(N + 1), inv(N + 1) {\n\t\tfac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n\t\tfor (int i = 2; i <= N; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % mod;\n\t\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n\tinline long long binom(int n, int k) {\n\t\treturn ((n < 0 || k < 0 || n < k) ? 0 : fac[n] * (finv[k] * finv[n - k] % mod) % mod);\n\t}\n\tinline long long factorial(int n) {\n\t\treturn (n<0?0:fac[n]);\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc021/tasks/abc021_d\nCombinationMod<MOD> CM(1000000);\nint N; \nmodint f(int l,int r) {\n    modint sum = 0;\n    for(int i=0;i<=l+r;++i) {\n        int use=i;\n        use += (l&1?(l-1)/2+1:l/2);\n        use += (r&1?(r-1)/2+1:r/2);\n        int res=N-1-(use+1);\n        int can=0;\n        can += (l&1?(l-3)/2:max(0,(l-2)/2));\n        can += (r&1?(r-3)/2:max(0,(r-2)/2));\n        modint cnt = 1;\n        cnt *= CM.factorial(use);\n        cnt *= CM.factorial(res);\n        cnt *= CM.binom(can,i);\n        cnt *= use+1;\n        sum += cnt;\n    }\n    return sum;\n}\nint main() {\n    cin >> N;\n    corner(N==2,1);\n    corner(N==3,4);\n    modint ans = 0;\n    for(int i = 1; i+1<=N; ++i) {\n        {\n            int l = i-1,r=N-(i+1);\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n        {\n            int l = i-1,r=N-i;\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n        {\n            int l = i,r=N-(i+1);\n            modint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n            ans += coe*f(l,r);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\ninline int mul(int x, int y) {return (ll)x * y % mod;}\ninline int inc(int x, int y) {x += y; return x >= mod ? x - mod : x;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = (ll)x * x % mod)\n\t\tif (y & 1) res = (ll)res * x % mod;\n\treturn res; \n}\nconst int MAXN = 1e6 + 10;\nint n, fac[MAXN], inv[MAXN];\ninline int binom(int x, int y) {return y < 0 || y > x ? 0 : mul(fac[x], mul(inv[y], inv[x - y]));}\n\nint main()\n{\n\tcin >> n;\n\tif (n == 2) return puts(\"1\");\n\tif (n == 3) return puts(\"2\");\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tinv[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n; i >= 2; i --)\n\t\tinv[i - 1] = mul(inv[i], i);\n\tint ans = fac[n - 1];\n\tfor (int i = 1; i < n; i ++)\n\t{\n\t\tint cnt = binom(i - 1, n - i - 1);\n\t\tcnt = mul(cnt, fac[i]);\n\t\tcnt = mul(cnt, fac[n - i - 1]);\n\t\tcnt = inc(fac[n - 1], mod - cnt);\n\t\tans = inc(ans, cnt);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\nconst int MOD = (int) 1e9 + 7;\n\nint Pow(int x, int y) {\n    int ret = 1;\n    for (;y > 0; y /= 2) {\n        if (y & 1) {\n            ret = ret * (int64_t) x % MOD;\n        }\n        x = x * (int64_t) x % MOD;\n    }\n    return ret;\n}\n\nint invMod(int x) {\n    return Pow(x, MOD - 2);\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << 1 << '\\n';\n    } else if (n == 3) {\n        cout << 4 << '\\n';\n    } else {\n        vector<int> fact(n + 1, 1);\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i - 1] * (int64_t) i % MOD;\n        }\n        vector<int> inv(n + 1, 0);\n        inv[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            inv[i] = (MOD - MOD / i) * (int64_t) inv[MOD % i] % MOD;\n        }\n        vector<int> ifact(n + 1, 1);\n        for (int i = 1; i <= n; ++i) {\n            ifact[i] = ifact[i - 1] * (int64_t) inv[i] % MOD;\n        }\n        auto comb = [&](int n, int k) -> int {\n            if (n < 0 || k < 0 || k > n) {\n                return 0;\n            }\n            return fact[n] * (int64_t) ifact[n - k]  % MOD * ifact[k] % MOD;\n        };\n        int ans = fact[n - 1] * (int64_t) n % MOD;\n        for (int k = 0; k < n; ++k) {\n            int v = comb(n - 1 - k - 1, k);\n            v = v * (int64_t) fact[k] % MOD;\n            v = v * (int64_t) fact[n - k - 1] % MOD;\n            ans = (ans - v + MOD) % MOD;\n        }\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v((a %= mod) < 0 ? a + mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    bool operator!= ( const ModInt &b ) const {return !(*this == b); }\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nModInt<mod> pow(ModInt<mod> n, ll k) {\n    return ModInt<mod>(n.mod_pow(n.v, k));\n}\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\n// 各種組み合わせを求めるライブラリ\ntemplate <typename NumType>\nstruct Combination {\n    int LIMIT;\n    vector<NumType> fact_, finv_;\n\n    Combination() {}\n    Combination(int LIMIT_) : LIMIT(LIMIT_), fact_(LIMIT+1), finv_(LIMIT+1) {\n        fact_[0] = finv_[LIMIT] = NumType(1);\n        for(int i=1; i<=LIMIT; i++) {\n            fact_[i] = fact_[i-1] * NumType(i);\n        }\n        \n        finv_[LIMIT] /= fact_[LIMIT];\n        for(int i=LIMIT-1; i>=0; i--) {\n            finv_[i] = finv_[i+1] * NumType(i+1);\n        }\n    }\n\n    inline NumType fact(int k) const { return fact_[k]; }\n    inline NumType finv(int k) const { return finv_[k]; }\n    NumType P(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r];\n    }\n    NumType C(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r] * finv_[r];\n    }\n    // 重複組み合わせ\n    NumType H(int n, int r) const {\n        if(n < 0 or r < 0) return NumType(0);\n        return r == 0 ? NumType(1) : C(n + r - 1, r);\n    }\n    // ベル数 (区別できる n 個のボールを区別できない k 個以下の箱に分割)\n    // B(n, n) := n 個のボールを任意個のグループに分割する場合の数\n    NumType B(int n, int k) const {\n        if(n == 0) return NumType(1);\n        k = min(n, k);\n        NumType ret(0);\n        vector<NumType> pref(k + 1); pref[0] = NumType(1);\n        for(int i=1; i<=k; i++) {\n            if(i & 1) pref[i] = pref[i-1] - finv_[i];\n            else pref[i] = pref[i-1] + finv_[i];\n        }\n        for(int i=1; i<=k; i++) {\n            // 累乗が必要なので適宜書き換える？\n            // ModInt 使うならこれでいい\n            ret += NumType(i).pow(n) * finv_[i] * pref[k-i];\n        }\n        return ret;\n    }\n    // スターリング数 (区別できる n 個のボールを区別できない k 個の箱に分割)\n    NumType S(int n, int k) const {\n        if(n < k) return NumType(0);\n        NumType ans(0);\n        for(int i=0; i<=k; i++) {\n            NumType val = C(k, i) * NumType(i).pow(n);\n            if((k - i) % 2) ans -= val;\n            else ans += val;\n        }\n        return ans * finv_[k];\n    }\n\n    // ランダムウォーク: 左に X 回、右に Y 回進むとき、\n    // 移動途中・終了時に座標 K を超えないものを数える\n    // K が非負なら左側、負なら右側領域 (？) のランダムウォーク\n    NumType walk(int X, int Y, int K) {\n        if(K < 0) return walk(Y, X, -K);\n        if(Y <= K) return C(X+Y, X); // 引っかからない\n        if(Y - X > K) return NumType(0); // そもそも合計が超える\n        \n        int A = Y - K - 1, B = X + K + 1;\n        return C(X+Y, X) - C(A+B, A);\n    }\n};\n\n// P(n, k) := n の k 分割 (k 個の 0 以上の整数の和)\ntemplate <typename NumType, int LIMIT = 3010>\nstruct Partition {\n    vector< vector<NumType> > dp;\n    Partition() : dp(LIMIT, vector<NumType>(LIMIT)) {\n        for(int k=0; k<LIMIT; k++) dp[0][k] = NumType(1);\n        for(int i=1; i<LIMIT; i++) {\n            for(int j=1; j<LIMIT; j++) {\n                dp[i][j] += dp[i][j-1];\n                if(i-j >= 0) dp[i][j] += dp[i-j][j];\n            }\n        }\n    }\n    inline NumType get(int n, int k) {\n        if(n < 0 or k < 0) return NumType(0);\n        return dp[n][k];\n    }\n};\n\nusing mint = ModInt<MOD>;\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    Combination<mint> comb(2000010);\n\n    vector<mint> rec(N+1);\n    mint sum(0);\n    for(int i=1; i<N; i++) {\n        rec[i] = comb.C(i-1, N-1-i) * comb.fact(i) * comb.fact(N-1-i);\n        rec[i] -= sum;\n        sum += rec[i];\n    }\n\n    mint ans(0);\n    for(int i=1; i<N; i++) {\n        ans += mint(i) * rec[i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <map>\n#include <set>\n#include <bitset>\n#include <sstream>\n#include <cstdlib>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <climits>\n#include <cstdio>\n#include <ctype.h>\n#include <time.h>\nusing namespace std;\n\n#define PI acos(-1.0)\n#define EPS 1e-8\n#define MOD 1000000007\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define fi first\n#define se second\n#define go(i, a, b) for(int i = a; i <= b; ++i)\n#define gorev(i, a, b) for(int i = a; i >= b; --i)\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\ntemplate <class L, class R> ostream &operator <<(ostream &os, pair<L, R> P){\n    return os << \"(\" << P.fi << \",\" << P.se << \")\";\n}\ntemplate <class T> ostream &operator <<(ostream &os, vector<T> V){\n    os << \"[\"; for (auto vv: V) os << vv << \",\"; return os << \"]\";\n}\ntemplate <class L, class R> ostream &operator <<(ostream &os, map<L, R> M){\n    os << \"[\"; for (auto pr: M) os << pr.fi << \"->\" << pr.se << \",\"; return os << \"]\";\n}\ntemplate <class L, class R> ostream &operator <<(ostream &os, unordered_map<L, R> M){\n    os << \"[\"; for (auto pr: M) os << pr.fi << \"->\" << pr.se << \",\"; return os << \"]\";\n}\n\nstruct Matrix {\n    vvi data;\n    int r, c;\n    Matrix(int row, int col, bool identity = false) : r(row), c(col) {\n        data.assign(row, vector<int>(col, 0));\n        if (identity) {\n            for (int i = 0; i < r; ++i) {\n                data[i][i] = 1;\n            }\n        }\n    }\n    Matrix operator * (Matrix& other) {\n        int m = r, n = c, p = other.c;\n        Matrix res(m, p);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < p; ++j) {\n                for (int k = 0; k < n; ++k) {\n                    res.data[i][j] += data[i][k] * other.data[k][j];\n                }\n            }\n        }\n        return res;\n    }\n};\n\nvector<int> extendGcd(int a, int b) {\n    if (b == 0) {\n        return {1, 0, a};\n    } else {\n        vector<int> tmp = extendGcd(b, a % b);\n        return {tmp[1], tmp[0] - (a / b) * tmp[1], tmp[2]};\n    }\n}\n\nMatrix matrix_power(Matrix base, ll exp) {\n    int n = base.r;\n    Matrix res(n, n, true);\n    while (exp) {\n        if (exp & 1) {\n            res = res * base;\n        }\n        base = base * base;\n        exp >>= 1;\n    }\n    return res;\n}\n\n/******************************** template ********************************/\n#define N 1000010\nint n;\nll p[N];\nll dp[N];\n\nll mul(ll a, ll b) {\n    return a * b % MOD;\n}\n\nll add(ll a, ll b) {\n    ll res = (a + b) % MOD;\n    if (res < 0) res += MOD;\n    return res;\n}\n\nll power_mod(ll base, int exp) {\n    ll res = 1;\n    while (exp) {\n        if (exp & 1) res = res * base % MOD;\n        base = base * base % MOD;\n        exp >>= 1;\n    }\n    return res;\n}\n\nll inv(ll a) {\n    return power_mod(a, MOD - 2);\n}\n\nll combine(ll a, ll b) {\n    if (a < b) return 0;\n    return mul(p[a], mul(inv(p[b]), inv(p[a - b])));\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(10);\n    cout << fixed;\n#ifdef ZYC_LOCAL\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n    p[0] = p[1] = 1;\n    for (int i = 2; i < N; ++i) {\n        p[i] = mul(p[i - 1], i);\n    }\n    cin >> n;\n    ll res = 0;\n    ll tmp = 0;\n    go(i, (n + 1) / 2, n - 1) {\n        ll foo = mul(inv(p[2 * i - n]), mul(p[i - 1], p[i]));\n        res += mul(add(foo, -tmp), i);\n        tmp = foo;\n        res %= MOD;\n    }\n    cout << res;\n\n#ifdef ZYC_LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n\nint mod = 1e9 + 7;\n\n// mod_power.cc\nll po(ll k, ll x) {\n  if (x == 0) {\n    return 1;\n  }\n  if (x == 1) {\n    return k % mod;\n  }\n  ll y = po(k, x/2);\n  y = y * y % mod;\n  if (x % 2 == 1) {\n    y = y * k % mod;\n  }\n  return y;\n}\n\nvll factorial;\nvll inv_fact;\nll comb(ll x, ll y) {\n  if (x < 0 || x < y) {\n    return 0;\n  }\n  y = min(y, x-y);\n  if (y == 0) {\n    return 1;\n  }\n  ll ret = 1;\n  ret = ret * factorial[x] % mod;\n  ret = ret * inv_fact[y] % mod;\n  ret = ret * inv_fact[x-y] % mod;\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  if (n <= 3) {\n    int ans = 0;\n    if (n == 2) {\n      ans = 1;\n    } else if (n == 3) {\n      ans = 4;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n  }\n\n  factorial.assign(n+1, 0);\n  inv_fact.assign(n+1, 0);\n  factorial[0] = 1;\n  inv_fact[0] = 1;\n  rep (i, n) {\n    factorial[i+1] = factorial[i] * (i+1) % mod;\n    inv_fact[i+1] = po(factorial[i+1], mod-2) % mod;\n    assert(factorial[i+1] * inv_fact[i+1] % mod == 1);\n  }\n  ll ans = 0;\n  ll prev_cnt = 0;\n  FOR (i, 2, n) {\n    ll cnt = 1;\n    cnt = cnt * comb(i-1, n-1-i) % mod;\n    cnt = cnt * factorial[i] % mod;\n    cnt = cnt * factorial[n-1-i] % mod;\n    ll add = (cnt + mod - prev_cnt) * i % mod;\n    prev_cnt = cnt;\n    ans = (ans + add) % mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int P = 1000000007;\n\nvector<int> f;\nvoid init(int n) {\n    f.resize(n + 1);\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        f[i] = (ll)f[i - 1] * i % P;\n    }\n}\nll fact(int k) {\n    return f[k];\n}\nll powmod(ll n, ll k) {\n    ll r = 1, t = n % P;\n    for (; k != 0; k /= 2) {\n        if (k & 1) r = r * t % P;\n        t = t * t % P;\n    }\n    return r;\n}\nll inv(ll n) {\n    return powmod(n, P - 2);\n}\nll comb(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return (ll)f[n] * inv((ll)f[k] * f[n - k]) % P;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    init(n);\n\n    ll r = 0, b = 0;\n    for (int k = (n + 1) / 2; k <= n - 1; k++) {\n        ll a = comb(k - 1, n - 1 - k) * fact(k) % P * fact(n - 1 - k) % P;\n        r += (a - b) * k % P;\n        b = a;\n    }\n    r %= P; if (r < 0) r += P;\n\n    cout << r << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1000005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N;cin>>N;\n    make();\n    \n    ll sum=0;\n    ll pas=0;\n    \n    for(ll i=1;i<=N-1;i++){\n        sum+=(fac[i]*fac[N-1-i]%mod*comb(i-1,N-1-i)%mod-pas+mod)%mod*i%mod;\n        sum%=mod;\n        \n        pas=fac[i]*fac[N-1-i]%mod*comb(i-1,N-1-i)%mod;\n        \n        //cout<<pas<<endl;\n    }\n    \n    cout<<sum<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int inv(int n, int p) {\n\tint i = 1;\n\tfor (int r = n; r > 1; r = p % r)\n\t\ti = p / r * long(p - i) % p;\n\treturn i;\n}\nint f[1111111], g[1111111];\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint p = 1e9 + 7;\n\tf[0] = 1, g[n - 1] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tf[i] = long(i)*f[i - 1] % p;\n\t\tg[n - 1 - i] = long(n - 1 - i)*g[n - i] % p;\n\t}\n\tint a = 0;\n\tfor (int i = (n + 1) / 2; i < n - 1; i++)\n\t\ta = (a + (long(f[i])*f[i - 1]) % p*g[i * 2 - n + 1]) % p;\n\tcout << (long(n - 1)*f[n - 1] + long(p - a)*inv(f[n - 2], p)) % p << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define inf 1000000000\nusing namespace std;\n#define N 1000005\n#define mod 1000000007\nint n,fac[N],inv[N],f[N],ans;\nint ksm(int x,int p){\n\tint ret=1;\n\tfor (; p; p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n\treturn ret;\n}\nint getinv(int x){ return ksm(x,mod-2); }\nint C(int n,int m){ return (ll)fac[n]*inv[n-m]%mod*inv[m]%mod; }\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1; rep (i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=getinv(fac[n]); per (i,n-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\trep (i,(n+1)/2,n-1){\n\t\tf[i]=(ll)fac[i]*fac[n-1-i]%mod*C(2*i-n+(n-2-(2*i-n))/2,2*i-n)%mod;\n\t\tans=(ans+(ll)(f[i]+mod-f[i-1])*i%mod)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define inf 1000000000\nusing namespace std;\n#define N 1000005\n#define mod 1000000007\nint n,fac[N],inv[N],f[N],ans;\nint ksm(int x,int p){\n\tint ret=1;\n\tfor (; p; p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n\treturn ret;\n}\nint getinv(int x){ return ksm(x,mod-2); }\nint C(int n,int m){ return (ll)fac[n]*inv[n-m]%mod*inv[m]%mod; }\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1; rep (i,1,2*n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=getinv(fac[n]); per (i,n-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\trep (i,(n+1)/2,n-1){\n\t\tf[i]=(ll)fac[i]*fac[n-1-i]%mod*C(2*i-n+(n-2-(2*i-n))/2,2*i-n)%mod;\n\t\tans=(ans+(ll)(f[i]-f[i-1])*i%mod)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\ntypedef pair<int,int> ii;\n\nint fact[2000005];\nint mod = 1000000007;\nlong long qexp(long long b, long long p){\n    long long res = 1;\n    while(p){\n        if(p&1) res = (res * b) % mod;\n        b = (b * b) % mod;\n        p >>= 1;\n    }\n    return res;\n}\nint inv(long long b){ return qexp(b, mod-2); }\nint choose(int N, int C){\n\tif(N < C) return 0;\n\tint res = fact[N];\n\tres *= inv(fact[C]);\n\tres %= mod;\n\tres *= inv(fact[N-C]);\n\tres %= mod;\n\treturn res;\n}\n\nint ans = 0;\nvoid fix(int &x){\n\tx %= mod;\n\tif(x < 0) x += mod;\n}\n\nsigned main(){\n\t//freopen(\"i.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\t\n\tfact[0] = 1;\n\tfor(int i = 1;i <= 2000000;i++) fact[i] = (fact[i-1] * i) % mod;\n\t\n\tint N; cin >> N;\n\tans = (N-1)*fact[N-1];\n\tfix(ans);\n\t\n\tfor(int len = 2;len < N-1;len++){\n\t\tint places = N - 3;\n\t\tint take = len - 2;\n\t\tint notake = places - take;\n\t\t\n\t\tint ways = choose(take + 1, notake);\n\t\tif(ways == 0) continue;\n\t\tfix(ways);\n\t\t\n\t\t\n\t\t\n\t\tways *= fact[len];\n\t\tways %= mod;\n\t\tways *= fact[N-1-len];\n\t\tways %= mod;\n\t\t\n\t\t//cout << len << \" \" << ways << \"\\n\";\n\t\t\n\t\tint loss = ways;\n\t\tloss %= mod;\t\n\t\t\n\t\tans -= loss;\n\t\tans %= mod;\n\t\tif(ans < 0) ans += mod;\n\t}\n\t\n\tcout << ans;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Combination {\n\npublic:\n    vector<ll> fact;\n\n    Combination(int max_n) {\n        //1 ~ n!までの階乗modを求める\n        int n = max_n;\n        vector<ll> fact(n + 1);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n        }\n        this->fact = fact;\n    }\n\n    template<typename T>\n    //templateをつかってみｔか\n    ll pow(T x, int y) {\n        if (y == 0) return 1;\n        if (y == 1) return x;\n        if (y == 2) return (x * x) % MOD;\n//        if (y % 2 == 1) return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        if (y % 2 == 1) return pow(pow(x, y / 2), 2) * x % MOD;\n//        return pow(x, y / 2) * pow(x, y / 2) % MOD;\n        return pow(pow(x, y / 2), 2) % MOD;\n    }\n\n    ll nCk(int n, int k) {\n//        return (fact[n] * pow(fact[n-k],MOD-2) * pow(fact[k],MOD-2)) % MOD;\n        if (n < k) return 0;\n        return (((fact[n] * pow(fact[n - k], MOD - 2)) % MOD) * pow(fact[k], MOD - 2)) % MOD;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    Combination comb(n);\n    vector<ll> f(n + 1);\n\n    rep(k, 1, n) {\n        ll tmp = comb.nCk(k - 1, n - 1 - k);\n        tmp *= comb.fact[k];\n        tmp %= MOD;\n        tmp *= comb.fact[n - 1 - k];\n        tmp %= MOD;\n//        tmp *= k;\n//        tmp %= MOD;\n//        ans += tmp;\n//        ans %= MOD;\n        f[k] = tmp;\n    }\n    ll ans = 0ll;\n\n    rep(k,1,n){\n        ll tmp = f[k] - f[k-1];\n        if(tmp < MOD) tmp += MOD;\n        ans += k * tmp;\n        ans %= MOD;\n    }\n\n\n    cout << ans << endl;\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(ll i=0;i<n;i++)\n#define repp(j, n) for(ll j=0;j<n;j++)\n#define reppp(i, m, n) for(ll i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 1e-10;\n\nll comb(ll fact[], ll rfact[], ll n, ll r){\n    return (((fact[n] * rfact[r]) % MOD) * rfact[n-r]) % MOD;\n}\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    ll n;\n    cin >> n;\n    \n    ll fact[n+1], rfact[n+1];\n    fact[0] = fact[1] = 1LL;\n    rfact[0] = rfact[1] = 1LL;\n    reppp(i, 2, n+1){\n        fact[i] = (fact[i-1] * (ll)i) % MOD;\n        rfact[i] = 1LL;\n        ll k = MOD-2LL;\n        ll a = fact[i];\n        while(k > 0LL){\n            if(k & 1LL){\n                rfact[i] *= a;\n                rfact[i] %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            k  >>= 1;\n        }\n    }\n\n    ll ans = 0LL, p_prev = 0LL;\n    ll k = (n+1)/2;\n    reppp(i, k, n){\n        ll p = (((comb(fact, rfact, i-1, n-1-i) * fact[i]) % MOD) * fact[n-1-i]) % MOD;\n        ans = (ans + (i * (p - p_prev)) % MOD) % MOD;\n        p_prev = p;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nconst int MAX = 2000000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(){\n  int N; cin >> N; ll fact[N+10]; fact[0] = 1;\n  rep(i, N+9){\n    fact[i+1] = fact[i]*(i+1)%mod;\n  }\n  COMinit();\n  ll ans = fact[N-1]*(N-1)%mod;\n  if(N%2==0){\n    int k = 1;\n    for(int i=(N-3); i>=(N-2)/2; i--){\n      ans-=((COM(i, k)*fact[i+1])%mod)*fact[N-i-2]%mod; \n      if(ans<0) ans+=mod; ans%=mod; k++;\n    }\n    cout << ans << endl; return 0;\n  }\n  int k = 1;\n  for(int i=(N-3); i>=N/2; i--){\n    ans-=((COM(i, k)*fact[i+1])%mod)*fact[N-i-2]%mod;\n    if(ans<0) ans+=mod; ans%=mod; k++;\n  }\n  cout << ans << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=1e6+100,mod=1e9+7;\nll fac[N];\nll fm[N];\nll power(ll n,ll k){\n    if (k==0) return 1;\n    if (k%2==1){\n        ll x=power(n,k/2);\n        return x*x%mod*n%mod;\n    }\n    ll x=power(n,k/2);\n    return x*x%mod;\n}\nll ent(ll k,ll n){\n    if (k<0 || k>n) return 0;\n    if (k==0 || k==n) return 1;\n    return fac[n]*fm[k]%mod*fm[n-k]%mod;\n}\nll dp[N];\nint32_t main(){\n    fac[0]=1;\n    fm[0]=1;\n    for (int i=1;i<N;i++){\n        fac[i]=fac[i-1]*i%mod;\n        fm[i]=power(fac[i],mod-2);\n    }\n    ll n;\n    cin >> n;\n    n--;\n    for (int i=0;i<=n;i++){\n        dp[i]=ent(i,n-i-1)*fac[i]%mod*fac[n-i]%mod;\n    }\n    ll ans=0;\n    for (int i=0;i<N-1;i++){\n        dp[i]-=dp[i+1];\n        dp[i]+=mod;\n        dp[i]%=mod;\n        ans+=dp[i]*(n-i)%mod;\n        ans%=mod;\n    }\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n\nusing namespace std;\n\nint n;\nlong long ans = 0;\nconst long long N = 1e6 + 5;\nconst long long mod = 1e9 + 7;\nlong long fact[3 * N];\nlong long a[N];\nlong long ps[N];\n\nvoid pre()\n{\n\tfact[0] = 1;\n\tfor (long long i = 1; i < N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i;\n\t\tfact[i] = fact[i] % mod;\n\t}\n}\n\nlong long power(long long a, long long b)\n{\n\tif (b == 0)\n\t{\n\t\treturn 1;\n\t}\n\tlong long ans = power(a, b / 2);\n\tans = ans * ans;\n\tans = ans % mod;\n\tif (b % 2)\n\t{\n\t\tans = ans * a;\n\t}\n\tans = ans % mod;\n\treturn ans;\n}\n\nlong long choose(long long a, long long b)\n{\n\tif (b < 0 || a < b)\n\t{\n\t\treturn 0;\n\t}\n\tlong long ans = fact[a];\n\tans = ans * power(fact[b], mod - 2);\n\tans = ans % mod;\n\tans = ans * power(fact[a - b], mod - 2);\n\tans = ans % mod;\n\treturn ans;\n}\n\n\n\nint main() \n{\n\tif (n == 2)\n\t{\n\t\tcout << 1;\n\t\texit(0);\n\t}\n\tpre();\n\tcin >> n;\n\tfor (int i = 2; i < n; i++) \n\t{\n\t\ta[i] = choose(i - 1, n - 1 - i);\n\t\ta[i] *= fact[n - i - 1];\n\t\ta[i] %= mod;\n\t\ta[i] *= fact[i];\n\t\ta[i] %= mod;\n\t\ta[i] -= ps[i - 1];\n\t\ta[i] += mod;\n\t\ta[i] %= mod;\n\t\tps[i] = ps[i - 1] + a[i];\n\t\tps[i] %= mod;\n\t\tans += a[i] * i;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\n\n\n\n\t\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e9+7)\nll N;\nll m,ans,F[1010101];\nll i, j, k;\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\nint main(){\n    scanf(\"%lld\", &N);\n    F[0] = 1;\n    fornum(i,0,N+1){\n        F[i + 1] = F[i] * (i + 1) % MOD;\n    }\n    m = 0;\n    fornum(k,(N+1)/2,N){\n        ll a=moddiv(F[k-1],F[N-k-1]*F[k*2-N]);\n        a = a * F[k] % MOD;\n        a = a * F[N-1-k] % MOD;\n        ans = (ans + (MOD+a-m)*k%MOD) % MOD;\n        m = (a + m) % MOD;\n        //printf(\"%lld %lld %lld %lld\\n\",k, moddiv(F[k-1],F[N-k-1]*F[k*2-N]),F[N-1-k],ans);\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1001000;\nconst long long md=1e9+7;\nlong long fac[maxn],inv[maxn];\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nlong long f[maxn];\nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%md*inv[x-y]%md;\n}\nlong long multiC(int x,int y){\n\treturn C(x+y-1,y);\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tn--;\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[n]=powd(fac[n],md-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tfor(int i=1;i<=n;i++){\n\t\tif(n-i+1>i) continue;\n\t\tf[i]=multiC(n-i+1,i-(n-i+1));\n\t}\n\tlong long ans=0;\n\tfor(int i=0;i<=n;i++)\n\t\tans=(ans+(C(n,i)-f[i]+md)*fac[i]%md*fac[n-i])%md;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll N;\nint NMAX = 1000000;\nconst ll MOD = 1000000007;\n\nlong long exgcd(long long a, long long b, long long &x, long long &y)\n{\n    int d = a;\n    if (b != 0)\n    {\n        d = exgcd(b, a % b, y, x);\n        y -= a / b * x;\n    }\n    else\n    {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n\nint main()\n{\n    cin >> N;\n    ll Mmin = (N + 1) / 2;\n\n    vector<long long> factorial(N);\n    vector<long long> inverse(N);\n    factorial[0] = 1;\n    for (int i = 1; i < N; i++)\n    {\n        factorial[i] = (factorial[i - 1] * i) % MOD;\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        long long tmp1, tmp2;\n        exgcd(MOD, factorial[i], tmp1, tmp2);\n        inverse[i] = (tmp2 + MOD) % MOD;\n    }\n\n    ll comb_m = 0;\n    ll ans = 0;\n    for (ll m = Mmin; m < N; m++)\n    {\n        ll comb_m_new;\n        comb_m_new = ((factorial[m - 1] * inverse[N - m - 1] % MOD) * inverse[2 * m - N]) % MOD;\n        comb_m_new = (comb_m_new * (factorial[m] * factorial[N - 1 - m] % MOD)) % MOD;\n        ans += (((comb_m_new - comb_m + MOD) % MOD) * m) % MOD;\n        comb_m = comb_m_new;\n        ans %= MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x%mod;\n\t\tx = x * x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint main() {\n\tll n; ll i;\n\tcin >> n;\n\tll t = (n - 2) / 2;\n\tll pm[1000001]; pm[0] = (ll)1;\n\tfor (i = 1; i < 1000001; i++) {\n\t\tpm[i] = pm[i - 1] * i % MOD;\n\t}\n\tll inv[1000001]; inv[0] = 1;\n\tfor (i = 1; i < 1000001; i++) {\n\t\tinv[i] = mod_pow(pm[i], MOD - 2, MOD);\n\t}\n\tll csum[1000001];\n\tll sum = 0;\n\tfor (i = t; i >= 0; i--) {\n\t\tcsum[t - i] = (pm[n - 1 - i] * pm[n - 2 - i] % MOD)*inv[n - 2 - 2 * i] % MOD;\n\t\tif (i == t) {\n\t\t\tsum = sum+(csum[t - i] * (n - 1 - i) % MOD)%MOD;\n\t\t}\n\t\telse {\n\t\t\tsum = (sum+((csum[t- i] - csum[t - 1 - i] + MOD) % MOD)*(n - i - 1) % MOD)%MOD;\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<int SZ> struct Combo {\n    ll fac[SZ+1], ifac[SZ+1];\n    \n    Combo() {\n        fac[0] = ifac[0] = 1;\n    \tFOR(i,1,SZ+1) {\n    \t    fac[i] = i*fac[i-1] % MOD;\n    \t    ifac[i] = inv(fac[i]);\n    \t}\n    }\n    \n    ll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\n    ll inv (ll b) { return po(b,MOD-2); }\n    \n    ll comb(ll a, ll b) {\n        if (a < b || b < 0 || a < 0) return 0;\n        ll tmp = fac[a]*ifac[b] % MOD;\n        tmp = tmp*ifac[a-b] % MOD;\n        return tmp;\n    }\n};\n\nCombo<1000005> C;\n\nint ad(int a, int b) { return (a+b)%MOD; }\nint sub(int a, int b) { return (a-b+MOD)%MOD; }\nint mul(int a, int b) { return (ll)a*b%MOD; }\n\nll dp[1000][1000], ans;\nint N; \n\nll complete(ll x) {\n    return C.comb(x-1,N-x);\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    dp[0][0] = 1;\n    FOR(i,1,1000) FOR(j,1,i+1) {\n        dp[i][j] = dp[i-1][j-1]+(i > 2 ? dp[i-2][j-1] : 0);\n        // cout << i << \" \" << j << \" \" << dp[i][j] << \"\\n\";\n    }\n    cin >> N; N--;\n    FOR(i,1,N+1) {\n        ans = ad(ans,C.fac[N]);\n        ans = sub(ans,mul(C.fac[N+1-i],mul(C.fac[i-1],complete(i-1))));\n    }\n    cout << ans;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (1000006)\nll n,f[MAXN],inv[MAXN],mod=1e9+7,ans;\nint main(){\n\tFAST\n\tcin>>n;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\twhile(e){\n\t\t\tif(e&1) sum*=x, sum%=mod;\n\t\t\tx*=x,x%=mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn sum;\n\t};\n\tauto C=[&](ll n,ll k){\n\t\treturn n < k ? 0 : f[n]*inv[k]%mod*inv[n-k]%mod;\n\t};\n\tf[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1] = qexp(f[MAXN-1], mod-2); DEC(i,MAXN-2,0) inv[i]=inv[i+1] * (i+1) % mod;\n\tFOR(k,2,n-2){\n\t\tans -= C(k-1,n-k-1) * f[k] % mod * f[n-1-k] % mod, ans += mod, ans %= mod;\n\t}\n\tans += f[n-1] * (n-1) % mod, ans %= mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define N 1000001\n#define int long long\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\t\n}\nusing namespace std;\nconst int mod=1000000007;\nint n,ans,jc[N],sum[N],inv[N];\nmain()\n{\n\tre(n);\t\n\tjc[0]=1;\n\tinv[0]=inv[1]=1;\n\tfor(int i=1;i<=n;++i)jc[i]=i*jc[i-1]%mod;\n\tfor(int i=2;i<=n;++i)\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=(n+1)/2,x=(n-1)/2,y=1,j=jc[x];i<n;++i)\t\n\t{\n\t\tsum[i]=j*jc[i]%mod;\n\t\tans=(ans+i*(sum[i]-sum[i-1]))%mod;\n\t\tif(i+2<n)j=1ll*j*(++x)%mod;\n\t\tif(y<x)j=1ll*j*inv[++y]%mod;\n\t\tif(i+2<n && n-3-y>(n-i-2)*2-1)j=1ll*j*inv[++y]%mod;\n\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e6 + 6, mod = 1e9 + 7;\n\nlong long powmod(long long b, long long p){\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nlong long fac[N], inv[N];\n\nlong long C(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return (fac[n] * inv[k] % mod) * inv[n-k] % mod;\n}\n\nint main() {\n  fac[0] = inv[0] = 1;\n  for (int i = 1; i < N; ++i)\n    fac[i] = fac[i-1] * i % mod;\n  inv[N-1] = powmod(fac[N-1], mod-2);\n  for (int i = N-2; i > 0; --i) {\n    inv[i] = inv[i+1] * (i+1) % mod;\n    assert((inv[i] * fac[i] % mod) == 1);\n  }\n  int n;\n  scanf(\"%d\", &n);\n  --n;\n  long long ans = fac[n] * n % mod;\n  for (int i = 1; i <= n; ++i) {\n    int sela = i+1;\n    int ada = n - sela;\n    long long cur = C(ada, i) * fac[n-i] % mod;\n    cur = (cur * fac[i]) % mod;\n    ans = (ans + mod - cur) % mod;\n  } \n  if (ans < 0) ans += mod;\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n// 217\n// 44\n\nusing namespace std;\n\nconst int MOD = (int) 1e9 + 7;\nconst int MAXN = (int) 1e6;\n\nint fact[MAXN + 1], invfact[MAXN + 1];\n\ninline int lgput(int a, int b) {\n    int ans = 1;\n    while(b > 0) {\n        if(b & 1)\n            ans = (1LL * ans * a) % MOD;\n        b >>= 1;\n        a = (1LL * a * a) % MOD;\n    }\n    return ans;\n}\n\ninline int comb(int n, int k) {\n    return (1LL * fact[n] * ((1LL * invfact[k] * invfact[n - k]) % MOD)) % MOD;\n}\n\ninline void mod(int &x) {\n    if(x >= MOD)\n        x -= MOD;\n    if(x < 0)\n        x += MOD;\n}\n\nint main() {\n    //ifstream cin(\"A.in\");\n    //ofstream cout(\"A.out\");\n    int i, n;\n    ios::sync_with_stdio(false);\n    cin >> n;\n    fact[0] = 1;\n    for(i = 1; i <= n; i++) {\n        fact[i] = (1LL * fact[i - 1] * i) % MOD;\n    }\n    invfact[n] = lgput(fact[n], MOD - 2);\n    for(i = n - 1; i >= 0; i--) {\n        invfact[i] = (1LL * invfact[i + 1] * (i + 1)) % MOD;\n    }\n    int ans = 0, val = 0, sum = 0;\n    for(i = (n + 1) / 2; i <= n - 1; i++) {\n        sum += val;\n        mod(sum);\n        val = (1LL * ((1LL * comb(i - 1, n - i - 1) * fact[i]) % MOD) * fact[n - i - 1]) % MOD - sum;\n        mod(val);\n        ans = (ans + 1LL * val * i) % MOD;\n    }\n    cout << ans;\n    //cin.close();\n    //cout.close();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MD 1000000007\nvoid *wmem;\ntemplate<class T> void walloc1d(T **arr, int x, void **mem = &wmem){\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\nstruct mint{\n  static unsigned R, RR, Rinv, W, md, mdninv;\n  unsigned val;\n  mint(){\n  }\n  mint(int a){\n    val = mulR(a);\n  }\n  mint(unsigned a){\n    val = mulR(a);\n  }\n  mint(long long a){\n    val = mulR(a);\n  }\n  mint(unsigned long long a){\n    val = mulR(a);\n  }\n  int get_inv(long long a, int md){\n    long long e, s=md, t=a, u=1, v=0;\n    while(s){\n      e=t/s;\n      t-=e*s;\n      u-=e*v;\n      swap(t,s);\n      swap(u,v);\n    }\n    if(u<0){\n      u+=md;\n    }\n    return u;\n  }\n  void setmod(unsigned m){\n    int i;\n    unsigned t;\n    W = 32;\n    md = m;\n    R = (1ULL << W) % md;\n    RR = (unsigned long long)R*R % md;\n    switch(m){\n      case 104857601:\n      Rinv = 2560000;\n      mdninv = 104857599;\n      break;\n      case 998244353:\n      Rinv = 232013824;\n      mdninv = 998244351;\n      break;\n      case 1000000007:\n      Rinv = 518424770;\n      mdninv = 2226617417U;\n      break;\n      case 1000000009:\n      Rinv = 171601999;\n      mdninv = 737024967;\n      break;\n      case 1004535809:\n      Rinv = 234947584;\n      mdninv = 1004535807;\n      break;\n      case 1007681537:\n      Rinv = 236421376;\n      mdninv = 1007681535;\n      break;\n      case 1012924417:\n      Rinv = 238887936;\n      mdninv = 1012924415;\n      break;\n      case 1045430273:\n      Rinv = 254466304;\n      mdninv = 1045430271;\n      break;\n      case 1051721729:\n      Rinv = 257538304;\n      mdninv = 1051721727;\n      break;\n      default:\n      Rinv = get_inv(R, md);\n      mdninv = 0;\n      t = 0;\n      for(i=0;i<(int)W;i++){\n        if(t%2==0){\n          t+=md;\n          mdninv |= (1U<<i);\n        }\n        t /= 2;\n      }\n    }\n  }\n  unsigned mulR(unsigned a){\n    return (unsigned long long)a*R%md;\n  }\n  unsigned mulR(int a){\n    if(a < 0){\n      a = a%md+md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned mulR(unsigned long long a){\n    return mulR((unsigned)(a%md));\n  }\n  unsigned mulR(long long a){\n    a %= md;\n    if(a < 0){\n      a += md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned reduce(unsigned T){\n    unsigned m=T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned reduce(unsigned long long T){\n    unsigned m=(unsigned)T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned get(){\n    return reduce(val);\n  }\n  mint &operator+=(mint a){\n    val += a.val;\n    if(val >= md){\n      val -= md;\n    }\n    return *this;\n  }\n  mint &operator-=(mint a){\n    if(val < a.val){\n      val = val + md - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  mint &operator*=(mint a){\n    val = reduce((unsigned long long)val*a.val);\n    return *this;\n  }\n  mint &operator/=(mint a){\n    return *this *= a.inverse();\n  }\n  mint operator+(mint a){\n    return mint(*this)+=a;\n  }\n  mint operator-(mint a){\n    return mint(*this)-=a;\n  }\n  mint operator*(mint a){\n    return mint(*this)*=a;\n  }\n  mint operator/(mint a){\n    return mint(*this)/=a;\n  }\n  mint operator+(int a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(int a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(int a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(int a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator+(long long a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(long long a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(long long a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(long long a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator-(void){\n    mint res;\n    if(val){\n      res.val=md-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  operator bool(void){\n    return val!=0;\n  }\n  operator int(void){\n    return get();\n  }\n  operator long long(void){\n    return get();\n  }\n\n  mint inverse(){\n    int a = val, b = md, u = 1, v = 0, t;\n    mint res;\n    while(b){\n      t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    if(u < 0) u += md;\n    res.val = (unsigned long long)u*RR % md;\n    return res;\n  }\n\n  mint pw(unsigned long long b){\n    mint a(*this), res;\n    res.val = R;\n    while(b){\n      if(b&1) res *= a;\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n\n  bool operator==(int a){return mulR(a)==val;}\n  bool operator!=(int a){return mulR(a)!=val;}\n};\nunsigned mint::md, mint::W, mint::R, mint::Rinv, mint::mdninv, mint::RR;\nmint operator+(int a, mint b){return mint(a)+=b;\n}\nmint operator-(int a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(int a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(int a, mint b){\n  return mint(a)/=b;\n}\nmint operator+(long long a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(long long a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(long long a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(long long a, mint b){\n  return mint(a)/=b;\n}\nvoid rd(int &x){\n  int k, m=0;\n  x=0;\n  for(;;){\n    k = getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\nvoid wt_L(int x){\n  char f[10];\n  int m=0, s=0;\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\nvoid wt_L(mint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\nstruct combination_mint{\n  mint *fac, *ifac;\n  void init(int n, void **mem = &wmem){\n    int i;\n    walloc1d(&fac, n, mem);\n    walloc1d(&ifac, n, mem);\n    fac[0] = 1;\n    for(i=1;i<n;i++){\n      fac[i] = fac[i-1] * i;\n    }\n    ifac[n-1] = 1 / fac[n-1];\n    for(i=n-2;i>=0;i--){\n      ifac[i] = ifac[i+1] * (i+1);\n    }\n  }\n  mint C(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    return fac[a]*ifac[b]*ifac[a-b];\n  }\n  mint P(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    return fac[a]*ifac[a-b];\n  }\n  mint H(int a, int b){\n    if(a==0 && b==0){\n      return 1;\n    }\n    if(a<=0 || b<0){\n      return 0;\n    }\n    return C(a+b-1, b);\n  }\n}\n;\nchar memarr[96000000];\nmint val[1000000];\nint main(){\n  combination_mint comb;\n  int N, i, j, k;\n  mint res, tmp;\n  wmem = memarr;\n  {\n    mint x;\n    x.setmod(MD);\n  }\n  rd(N);\n  comb.init(2000000);\n  res = 0;\n  for(i=0;i<N;i++){\n    val[N-i-1] = comb.P(i,i) * comb.P(N-1-i,N-1-i);\n    val[N-i-1] *= comb.C(N-i,i);\n  }\n  tmp = 0;\n  for(i=0;i<N;i++){\n    val[i] -= tmp;\n    tmp += val[i];\n  }\n  for(i=0;i<N;i++){\n    res += (i+1) * val[i];\n  }\n  wt_L(res);\n  putchar_unlocked('\\n');\n  return 0;\n}\n// cLay varsion 20180303-1 [beta]\n\n// --- original code ---\n// mint val[1d6];\n// \n// {\n//   int i, j, k, N;\n//   mint res, tmp;\n//   combination_mint comb;\n// \n//   rd(N);\n//   \n//   comb.init(2d6);\n//   res = 0;\n// \n//   rep(i,N){\n//     val[N-i-1] = comb.P(i,i) * comb.P(N-1-i,N-1-i);\n//     val[N-i-1] *= comb.C(N-i,i);\n//   }\n// \n//   tmp = 0;\n//   rep(i,N){\n//     val[i] -= tmp;\n//     tmp += val[i];\n//   }\n// \n//   rep(i,N) res += (i+1) * val[i];\n//   wt(res);\n// }\n// \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define maxn 1000009\n#define mod 1000000007\nusing namespace std;\nLL jc[maxn],ny[maxn],f[maxn];\ninline LL C(int n,int m){\n  if(n<m) return 0;\n  return jc[n]*ny[m]%mod*ny[n-m]%mod;\n}\ninline int qpow(LL x,int y){\n  LL ans=1;\n  while(y){\n    if(y&1) ans=ans*x%mod;\n    y>>=1,x=x*x%mod;\n  }\n  return ans;\n}\nint main(){\n  int n,m;LL ans=0;\n  scanf(\"%d\",&n);\n  m=(n+1)/2;jc[0]=ny[0]=1;\n  for(int i=1;i<=n;i++) jc[i]=jc[i-1]*i%mod,ny[i]=qpow(jc[i],mod-2);\n  for(int i=m;i<n;i++) f[i]=C(i-1,n-i-1)*jc[i]%mod*jc[n-i-1]%mod;\n  for(int i=n-1;i>=m;i--) f[i]=(f[i]-f[i-1]+mod)%mod,ans+=f[i]*i%mod,ans%=mod;\n  printf(\"%lld\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ff first\n#define ss second\n#define szof(_x) ((int) (_x).size())\n#define TASK_NAME \"\"\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9 + 7;\nconst ll INFL = 1e18 + 123;\nconst double PI = atan2(0, -1);\nmt19937 tw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(tw) % (y - x + 1) + x; }\n\n//#define USE_ASM_MULTIPLICATION\n\ntemplate<int prime, int phi>\nstruct mod_int {\n\tstatic int const modulo = prime;\n\tstatic int const phi_modulo = phi;\n\n\tunsigned int by_modulo(unsigned long long num) const {\n\t\t#ifdef USE_ASM_MULTIPLICATION\n\t\t    unsigned long long x = num;\n\t\t    unsigned int xh = x >> 32, xl = x, q, r;\n\t\t\t#ifdef __GNUC__\n\t\t\t    asm(\n\t\t\t        \"divl %4; \\n\\t\"\n\t\t\t        : \"=a\" (q), \"=d\" (r)\n\t\t\t        : \"d\" (xh), \"a\" (xl), \"r\" (modulo)\n\t\t\t    );\n\t\t\t#else\n\t\t\t    __asm {\n\t\t\t        mov edx, dword ptr[xh];\n\t\t\t        mov eax, dword ptr[xl];\n\t\t\t        div dword ptr[mod];\n\t\t\t        mov dword ptr[q], eax;\n\t\t\t        mov dword ptr[r], edx;\n\t\t\t    };\n\t\t\t#endif\n\t\t    return r;\n\t\t#else\n\t\t    return num % modulo;\n\t\t#endif\n\t}\n\n\n\tmod_int(int _value) : value(_value), inv_(-1) {\n\t\tif (value < 0 || value >= modulo) {\n\t\t\tvalue %= modulo;\n\t\t\tif (value < 0) {\n\t\t\t\tvalue += modulo;\n\t\t\t}\n\t\t}\n\t}\n\n\tmod_int(long long _value) : value(_value % prime), inv_(-1) {\n\t\tif (value < 0) {\n\t\t\tvalue += modulo;\n\t\t}\n\t}\n\n\tmod_int() : value(0), inv_(-1) {}\n\n\tmod_int<prime, phi>& operator+=(mod_int<prime, phi> const& a) {\n\t\tvalue += a.value;\n\t\tif (value >= prime) {\n\t\t\tvalue -= prime;\n\t\t}\n\t\tinv_ = -1;\n\t\treturn *this;\n\t}\n\n\tmod_int<prime, phi>& operator-=(mod_int<prime, phi> const& a) {\n\t\tvalue -= a.value;\n\t\tif (value < 0) {\n\t\t\tvalue += prime;\n\t\t}\n\t\tinv_ = -1;\n\t\treturn *this;\n\t}\n\n\tmod_int<prime, phi>& operator*=(mod_int<prime, phi> const& a) {\n\t\tvalue = by_modulo((long long) value * a.value);\n\t\tif (inv_ != -1 && a.inv_ != -1) {\n\t\t\tinv_ = by_modulo((long long) inv_ * a.inv_);\n\t\t} else {\n\t\t\tinv_ = -1;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmod_int<prime, phi> &operator/=(mod_int<prime, phi> a) {\n\t\tassert(a.value != 0);\n\t\tvalue = by_modulo((long long) value * a.inv().value);\n\t\tif (inv_ != -1) {\n\t\t\tinv_ = by_modulo((long long) inv_ * a.value);\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmod_int<prime, phi> inv() const {\n\t\tassert(value != 0);\n\t\tif (inv_ == -1 && value != 0) {\n\t\t\tinv_ = pow(phi - 1).value;\n\t\t}\n\t\treturn inv_;\n\t}\n\n\tmod_int<prime, phi> pow(int p) const {\n\t\tint res = 1;\n\t\tint a = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) {\n\t\t\t\tres = by_modulo((long long) res * a);\n\t\t\t}\n\t\t\ta = by_modulo((long long) a * a);\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tmod_int<prime, phi> pow(long long p) const {\n\t\tif (phi + 1 == prime && p > phi_modulo) {\n\t\t\tp %= phi_modulo;\n\t\t}\n\t\tint res = 1;\n\t\tint a = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) {\n\t\t\t\tres = by_modulo((long long) res * a);\n\t\t\t}\n\t\t\ta = by_modulo((long long) a * a);\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\texplicit operator int() const {\n\t\treturn value;\n\t}\n\n\tint value;\n\tmutable int inv_;\n};\n\ntemplate<int p, int q> mod_int<p, q> operator+(mod_int<p, q> a, auto const& b) { return a += b; }\ntemplate<int p, int q> mod_int<p, q> operator-(mod_int<p, q> a, auto const& b) { return a -= b; }\ntemplate<int p, int q> mod_int<p, q> operator*(mod_int<p, q> a, auto const& b) { return a *= b; }\ntemplate<int p, int q> mod_int<p, q> operator/(mod_int<p, q> a, auto const& b) { return a /= b; }\ntemplate<int p, int q> bool operator==(mod_int<p, q> const& a, auto const& b) { return a.value == b.value; };\ntemplate<int p, int q> bool operator!=(mod_int<p, q> const& a, auto const& b) { return a.value != b.value; };\ntemplate<int p, int q> ostream &operator<<(ostream &os, mod_int<p, q> const& m) { return os << m.value; }\ntemplate<int p, int q> istream &operator>>(istream &is, mod_int<p, q>& m) { \n\tlong long tmp;\n\tis >> tmp;\n\tm = mod_int<p, q>(tmp);\n\treturn is; \n}\n\nconst int MOD = 1000000007;\ntypedef mod_int<MOD, MOD - 1> mint;\n\nvector<mint> factorial;\n\nmint cnk(int n, int k) {\n\treturn factorial[n] / factorial[k] / factorial[n - k];\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\n\tfactorial = {1};\n\n\tfor (int i = 1; i < n + 10; ++i) {\n\t\tfactorial.push_back(factorial.back() * i);\n\t}\n\n\tmint ans = 0;\n\tmint prev = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (0 <= n - 1 - i && n - i - 1 <= i - 1) {\n\t\t\tmint cur = cnk(n - 1 - (n - 1 - i) - 1, n - 1 - i) * factorial[i] * factorial[n - 1 - i];\n\t\t\tans += (cur - prev) * i;\n\t\t\tprev = cur;\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n}\n\n\nint main() {\n\t//freopen(TASK_NAME \".in\", \"r\", stdin);\n\t//freopen(TASK_NAME \".out\", \"w\", stdout);\n\tcerr << fixed << setprecision(15);\n\tcout << fixed << setprecision(15);\n\tios::sync_with_stdio(false);\n\n\tint tests = 1;\n\t// cin >> tests;\n\tfor (int it = 1; it <= tests; ++it) {\n\t\tsolve();\n\t}\n\t\n\t#ifdef LOCAL\n\t\tcerr << \"time: \" << clock() << \" ms\\n\";\n\t#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nInt mod = 1000000007;\n\nInt fact[1123456];\n\nvoid init() {\n   fact[0] = 1;\n   for(Int i = 1; i < 1123456; ++i) {\n      fact[i] = fact[i-1] * i % mod;\n   }\n}\n\nInt pow(Int x, Int n) {\n   if( n == 0 ) return 1;\n   Int t = pow(x,n/2);\n   return n % 2 == 0 ? (t * t % mod) : (t * t % mod * x % mod);\n}\n\nInt div(Int x, Int y) {\n   return x * pow(y, mod-2) % mod;\n}\n\nInt nCr(Int n, Int r) {\n   return div(fact[n], fact[r] * fact[n-r] % mod);\n}\n\n// void solve(Int n) {\n//    std::vector<Int> xs(n-1);\n//    rep(i,n-1) {\n//       xs[i] = i;\n//    }\n//    Int res = 0;\n//    std::vector<Int> counts(n, 0);\n//    do {\n//       std::vector<bool> ys(n,false);\n//       for(Int i = 0; i < n-1; ++i) {\n//          ys[xs[i]] = ys[xs[i]+1] = true;\n//          bool end = true;\n//          for(Int k = 0; k < n; ++k) {\n//             if( not ys[k] ) end = false;\n//          }\n//          if( end ) {\n//             counts[i] += 1;\n//             if( i+1 == 4 ) {\n//                for(Int j = 0; j < n-1; ++j) {\n//                   printf(\"%ld \", xs[j]);\n//                }\n//                puts(\"\");\n//             }\n//             res += (i+1);\n//             break;\n//          }\n//       }\n//    } while( std::next_permutation(xs.begin(), xs.end()) );\n//    for(Int i = 0; i < n; ++i) {\n//       printf(\"score[%ld] : %ld\\n\", i+1, counts[i]);\n//    }\n//    printf(\"%ld\\n\", res);\n// }\n\nint main() {\n   init();\n   Int n;\n   std::cin >> n;\n   Int res = 0;\n   std::vector<Int> xs(n);\n   for(Int k = n/2; k < n; ++k) {\n      xs[k] = nCr(k-1, n-k-1) * fact[k] % mod * fact[n-1-k] % mod;\n   }\n   for(Int k = n/2; k < n; ++k) {\n      Int diff = xs[k] - xs[k-1];\n      Int t = diff * k % mod;\n      res = (res + t) % mod;\n   }\n   printf(\"%ld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nlong long nn;\nlong long kaik[2000000];\nlong long j(long long a){\n    return (a*a)%nn;\n}\nlong long rui(long long a,long long b){\n    if(b==0)return 1;\n    if(b==1)return a%nn;\n    if(b>1){\n        if(b%2==0)return j(rui(a,b/2));\n        if(b%2==1)return (j(rui(a,(b-1)/2))*a)%nn;\n    }\n}\nlong long c(long long n,long long m){\n    long long x;\n    x=(kaik[n-m]*kaik[m])%nn;\n    long long y;\n    y=(kaik[n]*rui(x,nn-2))%nn;\n    return y;\n}\n\nint main(void){\n    long long i,j,k,x,y,z,n,m,w;\n    nn=1000000007;\n    kaik[0]=1;\n    for(i=1;i<2000000;i++){\n        kaik[i]=(kaik[i-1]*i)%nn;\n    }\n    scanf(\"%lld\",&n);\n    x=(kaik[n-1]*(n-1))%nn;\n    m=(n-2)/2;\n    for(i=1;i<=m;i++){\n        z=(c(n-i-2,n-2*i-2)*kaik[n-1-i])%nn;\n        w=(z*kaik[i])%nn;\n        x-=w;\n        if(x<0)x+=nn;\n    }\n    printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 1000100;\nconst int base = 1e9+7;\n\nint n;\nll fac[maxn],ifac[maxn];\n\nll pw(int a,int n) {\n    if (n==0) return 1ll;\n    if (n==1) return a;\n    ll tg = pw(a,n/2);\n    tg = (tg*tg) % base;\n    if (n%2) return (tg*a)%base;\n    return tg;\n}\n\nll C(int k,int n) {\n    if (k > n) return 0;\n    return (fac[n] * ifac[k] % base * ifac[n-k])%base;\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    fac[0] = 1, ifac[0] = 1;\n    for (int i=1;i<maxn;i++) {\n        fac[i] = (fac[i-1]*1ll*i)%base;\n        ifac[i] = pw(fac[i],base-2);\n    }\n    //cout<<C(1,1)<<endl;\n    cin>>n;\n    ll res=0;\n    ll pre=0;\n    for (int i=(n+1)/2;i<n;i++) {\n        ll now = C(n-i-1,i-1) * fac[i] %base * fac[n-i-1] % base;\n        res = (res + 1ll*i*(now-pre)%base + base)%base;\n        pre = now;\n    }\n    cout<<res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing I = long long;\nconst I M = 1e9+7;\n\nvector<I> factorial(auto n) {\n  vector<I> f(n, 1);\n  for(auto i=1; i<n; ++i) f[i] = f[i-1] * i % M;\n  return f;\n}\n\nI power(I m, I n) {\n  if(!n) return 1;\n  return (n & 1) ? (power(m, n - 1) * m % M) : power(m * m % M, n >> 1);\n}\nI inverse(I n) {\n  return power(n, M - 2);\n}\nI combination(I n, I r, auto& f) {\n  if(!n) return 1;\n  if(n < r) return 0;\n  return (f[n] * inverse(f[n - r]) % M) * inverse(f[r]) % M;\n}\n\nI solve(auto N) {\n  if(N==2) return 1;\n  if(N==3) return 4;\n  auto f = factorial(1e6+1);\n  I res = 0;\n  I last = 0;\n  for(auto K=(N+1)/2; K<N; ++K) {\n    auto cnt = combination(K-1, N-1-K, f);\n    cnt *= f[K] * f[N-1-K] % M;\n    cnt %= M;\n    res += K * (cnt - last) % M;\n    res = (res + M) % M;\n    last = cnt;\n  }\n  return res;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  cout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e6+5;\nconst int mo = 1e9+7;\n\nint n;\nLL f[N];\nLL js[N],inv[N];\n\nLL calc(int n,int m){return js[n]*inv[m]%mo*inv[n-m]%mo;}\n\nint main(){\n\tn=get();\n\tif (n==2)return printf(\"1\\n\"),0;\n\tjs[0]=js[1]=1;\n\tfo(i,2,n)js[i]=js[i-1]*i%mo;\n\tinv[0]=inv[1]=1;\n\tfo(i,2,n)inv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\tfo(i,2,n)inv[i]=inv[i]*inv[i-1]%mo;\n\tfo(d,1,n-2){\n\t\tint c1=n-d*2,c2=d-1;\n\t\tif (c1<0)continue;\n\t\tLL tmp=calc(c1+c2,c1)*js[n-d]%mo*js[d-1]%mo;\n\t\tf[n-d]=tmp;\n\t}\n\tfd(i,n-1,2)f[i]=(f[i]+mo-f[i-1])%mo;\n\tLL ans=0;\n\tfo(i,1,n-1)ans=(ans+f[i]*i%mo)%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename S, typename T>\nvoid incr_m(M<S, T> &m, S k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD   ((ll)pow(10LL, 9LL) + 7LL)\n\nvoid make_perms(ll perms[100005], ll perm_invs[100005])\n{\n    perms[0] = 1LL;\n    srep (i, 1LL, 100004LL) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= MOD;\n    }\n\n    debug_printf(\"---- perms\\n\"); debug_print(perms, 10);\n\n    rep (i, 100005) perm_invs[i] = mod_inv(perms[i], MOD);\n}\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n\n    if (n == 2) {\n        cout << 1 << endl;\n        return;\n    }\n    if (n == 3) {\n        cout << 2 * 2 << endl;\n        return;\n    }\n\n    static ll perms[100005];\n    static ll perm_invs[100005];\n    make_perms(perms, perm_invs);\n\n    static ll cnts[100005];\n    memset(cnts, 0, sizeof(cnts));\n    rep (blackcnt, n+1LL) {\n        if (blackcnt - 1LL < n - 1LL - blackcnt) continue;\n        // (blackcnt - 1LL)_C_(n - 1LL - blackcnt)\n        cnts[blackcnt] = perms[blackcnt];\n        cnts[blackcnt] *= perm_invs[n - 1LL - blackcnt];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perm_invs[2 * blackcnt - n];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perms[blackcnt - 1LL];\n        cnts[blackcnt] %= MOD;\n        cnts[blackcnt] *= perms[n - 1LL - blackcnt];\n        cnts[blackcnt] %= MOD;\n    }\n    debug_printf(\"---- cnts\\n\"); debug_print(cnts, 10);\n\n    ll ans = 0LL;\n    srep (score, 1LL, n) {\n        ll incr = cnts[score] - cnts[score-1];\n        while (incr < 0LL) incr += MOD;\n        incr *= score;\n        incr %= MOD;\n        ans += incr;\n        ans %= MOD;\n    }\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\ntemplate <class T>\nclass factorials {\npublic:\n  using value_type = T;\n\npublic:\n  std::vector<value_type> fact, fact_inv;\n\n  factorials(int size_ = 200000): fact(size_ + 1), fact_inv(size_ + 1) {\n    fact[0] = value_type(1);\n    for (int i = 1; i <= size_; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv[size_] = ~fact[size_];\n    for (int i = size_; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (int n, int r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modular<1000000007>;\nfactorials<modint> fact(1000000);\n\nint main() {\n  int N;\n  std::cin >> N;\n  if (N == 2) {\n    std::cout << \"1\\n\";\n    return 0;\n  }\n  auto calc = [&](int black, int white) {\n    if (black < 0 || white < 0) return modint(0);\n    if (white > black + 1) return modint(0);\n    return fact(black + 1, white);\n  };\n  auto expected1 = [&](int black, int white) {\n    if (black < 2 || white < 0) return modint(0);\n    return modint(black) * modint(black - 1) * fact.fact[black + white - 2] * fact.fact_inv[black + white];\n  };\n  auto expected2 = [&](int black, int white) {\n    if (black < 1 || white < 0) return modint(0);\n    return modint(black) * fact.fact[black + white - 1] * fact.fact_inv[black + white];\n  };\n  modint ans;\n  for (int put: range(2, N)) {\n    int empty = N - put - 1;\n    modint coeff(2 * empty + 2);\n    coeff -= modint(put - 2) * expected1(empty, put - empty - 1);\n    coeff -= modint(2) * expected2(empty, put - empty - 1);\n    ans += coeff * calc(put - 2, empty) * fact.fact[put] * fact.fact[empty];\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<cctype>\n#include<ctime>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<bitset>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<utility>\nusing namespace std;\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define il inline\n#define rg register\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define rep(i,st,ed) for(rg int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(rg int i=(ed);i>=(st);--i)\n#define rep0(i,n) for(rg int i=0;i<(n);++i)\n#define per0(i,n) for(rg int i=(n)-1;i>=0;--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &x,const T &y){return x<y?x:y;}\ntemplate<typename T> il T qmax(const T &x,const T &y){return x>y?x:y;}\ntemplate<typename T> il void getmin(T &x,const T &y){if(y<x) x=y;}\ntemplate<typename T> il void getmax(T &x,const T &y){if(y>x) x=y;}\nil void fileio(const string &s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e18+7;\nconst int N=1e6+7,mod=(int)1e9+7;\n\nll fac[N],inv[N];\nint n;\n\nil ll C(const int &n,const int &k){\n\tif(k>n||k<0) return 0;\n\tif(k==n) return 1;\n\treturn fac[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tinv[1]=1;\n\trep(i,2,N-1) inv[i]=mod-(mod/i)*inv[mod%i]%mod;\n\tfac[0]=inv[0]=1;\n\trep(i,1,N-1){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=inv[i-1]*inv[i]%mod;\n\t}\n\tscanf(\"%d\",&n);\n\tint ans=fac[n-1]*(n-1)%mod;\n\trep(i,1,n){\n\t\tif(n-2-i<i) break;\n\t\tans=(ans-C(n-2-i,i)*fac[n-1-i]%mod*fac[i]%mod+mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define MAXN 1000005\n#define PLI pair<long long,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define ha 99994711\n#define ba 823\n#define MOD 1000000007\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\nint64 fac[MAXN],invfac[MAXN],ans;\nint N;\nint64 fpow(int64 x,int64 c) {\n\tint64 res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = res * t % MOD;\n\t\tt = t * t % MOD;\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nint64 C(int n,int m) {\n\tif(n < m) return 0;\n\treturn fac[n] * invfac[m] % MOD * invfac[n - m] % MOD;\n}\nint64 W(int k) {\n\tint x = N - 2 - k;\n\tint y = k - x;\n\treturn fac[k] * invfac[y] % MOD * invfac[x] % MOD;\n}\nvoid Solve() {\n\tscanf(\"%d\",&N);\n\tif(N == 2) {\n\t\tputs(\"1\");\n\t\treturn;\n\t}\n\tfac[0] = invfac[0] = 1;\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t}\n\tinvfac[N] = fpow(fac[N],MOD - 2);\n\tfor(int i = N - 1 ; i >= 1 ; --i) {\n\t\tinvfac[i] = invfac[i + 1] * (i + 1) % MOD;\n\t}\n\tans += fac[N - 1];\n\tfor(int i = 1 ; i < N - 1 ; ++i) {\n\t\tans += (C(N - 2,i) + C(N - 2,i - 1) + MOD - W(i - 1))* fac[i] % MOD * fac[N - 1 - i] % MOD;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define inf 1000000000\nusing namespace std;\n#define N 2000005\n#define mod 1000000007\nint n,fac[N],inv[N],f[N],ans;\nint ksm(int x,int p){\n\tint ret=1;\n\tfor (; p; p>>=1,x=(ll)x*x%mod) if (p&1) ret=(ll)ret*x%mod;\n\treturn ret;\n}\nint getinv(int x){ return ksm(x,mod-2); }\nint C(int n,int m){ return (ll)fac[n]*inv[n-m]%mod*inv[m]%mod; }\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1; rep (i,1,2*n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=getinv(fac[n]); per (i,n-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\trep (i,(n+1)/2,n-1){\n\t\tf[i]=(ll)fac[i]*fac[n-1-i]%mod*C(2*i-n+(n-2-(2*i-n))/2,2*i-n)%mod;\n\t\tans=(ans+(ll)(f[i]-f[i-1])*i%mod)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ff first\n#define ss second\n#define szof(_x) ((int) (_x).size())\n#define TASK_NAME \"\"\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9 + 7;\nconst ll INFL = 1e18 + 123;\nconst double PI = atan2(0, -1);\nmt19937 tw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(tw) % (y - x + 1) + x; }\n\ntemplate<int prime, int phi>\nstruct mod_int {\n  static int const modulo = prime;\n  static int const phi_modulo = phi;\n\n  mod_int(int value)\n    : value(value)\n    , inv_(-1)\n  {\n    assert(value >= 0 && value < prime);\n  }\n\n  mod_int(long long value)\n    : value((value % prime + prime) % prime)\n    , inv_(-1)\n  {}\n\n  mod_int()\n    : value(0)\n    , inv_(-1)\n  {}\n\n  mod_int<prime, phi> &operator+=(mod_int<prime, phi> const &a) {\n    value += a.value;\n    if (value >= prime) {\n      value -= prime;\n    }\n    inv_ = -1;\n    return *this;\n  }\n\n  mod_int<prime, phi> &operator-=(mod_int<prime, phi> const &a) {\n    value -= a.value;\n    if (value < 0) {\n      value += prime;\n    }\n    inv_ = -1;\n    return *this;\n  }\n\n  mod_int<prime, phi> &operator*=(mod_int<prime, phi> const &a) {\n    value = (long long) value * a.value % prime;\n    if (inv_ != -1 && a.inv_ != -1) {\n      inv_ = (long long) inv_ * a.inv_ % prime;\n    } else {\n      inv_ = -1;\n    }\n    return *this;\n  }\n\n  mod_int<prime, phi> &operator/=(mod_int<prime, phi> a) {\n    assert(a.value != 0);\n    value = (long long) value * a.inv().value % prime;\n    if (inv_ != -1) {\n      inv_ = (long long) inv_ * a.value % prime;\n    }\n    return *this;\n  }\n\n  mod_int<prime, phi> inv() const {\n    if (inv_ == -1 && value != 0) {\n      inv_ = pow(phi - 1).value;\n    }\n    return inv_;\n  }\n\n  mod_int<prime, phi> pow(long long ind) const {\n    int res = 1;\n    int a = value;\n    for (; ind > 0; ind >>= 1) {\n      if (ind & 1) {\n        res = (long long) res * a % prime;\n      }\n      a = (long long) a * a % prime;\n    }\n    return mod_int<prime, phi>(res);\n  }\n\n  explicit operator int() const {\n    return value;\n  }\n\n  int value;\n  mutable int inv_;\n};\n\ntemplate<int p, int q> mod_int<p, q> operator+(mod_int<p, q> a, mod_int<p, q> const &b) { return a += b; }\ntemplate<int p, int q> mod_int<p, q> operator-(mod_int<p, q> a, mod_int<p, q> const &b) { return a -= b; }\ntemplate<int p, int q> mod_int<p, q> operator*(mod_int<p, q> a, mod_int<p, q> const &b) { return a *= b; }\ntemplate<int p, int q> mod_int<p, q> operator/(mod_int<p, q> a, mod_int<p, q> const &b) { return a /= b; }\ntemplate<int p, int q> bool operator==(mod_int<p, q> const &a, mod_int<p, q> const &b) { return a.value == b.value; };\ntemplate<int p, int q> bool operator!=(mod_int<p, q> const &a, mod_int<p, q> const &b) { return a.value != b.value; };\ntemplate<int p, int q> ostream &operator<<(ostream &os, mod_int<p, q> const &m) { return os << m.value; }\ntemplate<int p, int q> istream &operator>>(istream &is, mod_int<p, q> &m) { m.inv_ = -1; return is >> m.value; }\n\nconst int MOD = 1000000007;\ntypedef mod_int<1000000007, 1000000007 - 1> mint;\n\nvector<mint> factorial;\n\nmint cnk(int n, int k) {\n\treturn factorial[n] / factorial[k] / factorial[n - k];\n}\n\n\nvoid solve() {\n\t/*\n\tfor (int q = 2; q < 10; ++q) {\n\t\tvector<int> order(q - 1);\n\t\tiota(order.begin(), order.end(), 0);\n\n\t\tint sum = 0;\n\t\tdo {\n\t\t\tvector<int> arr(q);\n\t\t\tfor (int i = 0; i < szof(order); ++i) {\n\t\t\t\tarr[order[i]] = arr[order[i] + 1] = 1;\n\t\t\t\tif (*min_element(arr.begin(), arr.end()) == 1) {\n\t\t\t\t\tsum += i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (next_permutation(order.begin(), order.end()));\n\t\tcerr << sum << \" \";\n\t}\n\t*/\n\t/*\n\tvector<vector<int>> v = {{1}, {1, 1}};\n\tfor (int i = 0; i < 10; ++i) {\n\t\tvector<int> next = v.back();\n\t\tfor (int j = 0; j < szof(v[szof(v) - 2]); ++j) {\n\t\t\tnext[j] += v[szof(v) - 2][j];\n\t\t}\n\t\tnext.insert(next.begin(), 0);\n\t\tfor (int num : next) {\n\t\t\tcerr << num << \" \";\n\t\t}\n\t\tcerr << endl;\n\t\tv.push_back(next);\n\n\t}\n\t*/\n\n\tint n;\n\tcin >> n;\n\n\tfactorial = {1};\n\n\tfor (int i = 1; i < n + 10; ++i) {\n\t\tfactorial.push_back(factorial.back() * mint(i));\n\t}\n\n\tmint ans = 0;\n\tmint prev = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (0 <= n - 1 - i && n - i - 1 <= i - 1) {\n\t\t\tmint cur = cnk(n - 1 - (n - 1 - i) - 1, n - 1 - i) * factorial[i] * factorial[n - 1 - i];\n\t\t\tans += (cur - prev) * mint(i);\n\t\t\tprev = cur;\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\t//freopen(TASK_NAME \".in\", \"r\", stdin);\n\t//freopen(TASK_NAME \".out\", \"w\", stdout);\n\tcerr << fixed << setprecision(15);\n\tcout << fixed << setprecision(15);\n\tios::sync_with_stdio(false);\n\n\tint tests = 1;\n\t// cin >> tests;\n\tfor (int it = 1; it <= tests; ++it) {\n\t\tsolve();\n\t}\n\t\n\t#ifdef LOCAL\n\t\tcerr << \"time: \" << clock() << \" ms\\n\";\n\t#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\n#define ll long long\nconst ll MAX = 1000050;\nconst ll MOD = 1e9 + 7;\n\nll fac[MAX],invfac[MAX],f[MAX];\nll n;\nll pow_mod(ll a,ll n){\n\tll ans = 1;\n\ta %= MOD;\n\twhile(n){\n\t\tif(n&1)ans = (ans * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\nll inv(ll a){\n\treturn pow_mod(a,MOD-2);\n}\nvoid init(){\n\tfac[0] = 1;\n\tfor(int i = 1;i <= n; i++)\n\t\tfac[i] = fac[i - 1]*i%MOD; \n\t\t\n\tinvfac[n] = inv(fac[n]);\n\t\n\tfor(int i=n-1;i>=0;--i)\n\t\tinvfac[i] = invfac[i+1]*(i+1)%MOD;\n\t\n}\n\n\nll C(ll n,ll m){\n\tif(n < m || m <0)return 0;\n\treturn fac[n] * invfac[n-m] %MOD * invfac[m] % MOD;\n}\nint main(){\n\tcin>>n;\n\tinit();\n\tfor(int i=1;i<n;i++)\n\t\tf[i] = C(i-1,n-1-i) * fac[i]%MOD * fac[n-1-i]%MOD;\n\t\n\tint ans = 0;\n\tfor(int i=1;i<n;i++)\n\t\tans = (ans + (f[i] - f[i-1] + MOD)%MOD * i)%MOD;\n\t\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n _   ________   ___       __ ___   _           _  _\n| | / /|  _  \\ / _ \\     / // _ \\ | |         | |(_)\n| |/ / | | | |/ /_\\ \\   / // /_\\ \\| | __ __ _ | | _\n|    \\ | | | ||  _  |  / / |  _  || |/ // _` || || |\n| |\\  \\| |/ / | | | | / /  | | | ||   <| (_| || || |\n\\_| \\_/|___/  \\_| |_//_/   \\_| |_/|_|\\_\\\\__,_||_||_|\n*/\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\nconst int N = 1e6+50;\nconst int mod = 1e9+7;\nconst int in = 1e9+9;\ntypedef pair<int,int> ii;\nint n, ans = 0;\nint fact[N],inv[N];\n#define fi first\n#define se second\nint binpow(int a,int n){\n\tif(n==1) return a%mod;\n\tif(n%2==1) return (binpow(a,n-1)*a)%mod;\n\tint res = binpow(a,n/2)%mod;\n\treturn (res*res)%mod;\n}\nvoid Init(){\n\tfact[0] = 1;\n\tfor (int i=1;i<=n;i++) fact[i] = fact[i - 1] * i % mod;\n\tinv[n] = binpow(fact[n],mod-2);\n\tfor (int i=n;i>=1;i--) inv[i-1] = inv[i]*i % mod;\n}\n \nint C(int n,int k){\n\treturn n<k?0:(fact[n]%mod*inv[k]%mod*inv[n-k]%mod)%mod;\n}\nsigned main(){\n\tcin >> n;\n\tInit();\n\tint tmp = 0;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tint res = ((C(i-1,n-i-1)%mod*fact[i]%mod*fact[n-i-1]%mod)%mod-tmp+mod)%mod;\n\t\t(ans += res*i) %= mod;\n\t\t(tmp += res) %= mod;\n\t}\n\tcout << ans%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& vec) {\n    out << \"[\";\n    for (int x : vec) out << x << \", \";\n    out << \"]\";\n    return out;\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    #define dbg_var(x) cerr << #x << \": \" << x << endl;\n#endif\ntypedef unsigned long long ULL;\n\nconst LL MOD = 1000000007;\n\nLL modpow(LL a, LL b){\n    if(b == 0) return 1;\n    LL k = modpow(a, b/2);\n    k = k*k%MOD;\n    if(b%2) k = k*a%MOD;\n    return k;\n}\n\nLL inversem(LL x){\n    return modpow(x, MOD - 2);\n}\n\nLL factt[1000100];\nLL ifactt[1000100];\nLL p[1000100];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int n; cin >> n;\n    \n    factt[0] = 1;\n    for(int i=1; i<=n + 50; i++) factt[i] = factt[i-1] * i % MOD;\n    for(int i=0; i<=n + 50; i++) ifactt[i] = inversem(factt[i]);\n    \n    for(int k=(n+1)/2; k<n; k++) p[k] = factt[k-1] * factt[k] % MOD * ifactt[2*k-n] % MOD;\n    \n    //~ for(int k=1; k<n; k++) cout << k << ' ' << p[k] - p[k-1] << endl;\n    \n    LL ans = 0;\n    for(int k=1; k<n; k++) ans = (ans + (p[k] + MOD - p[k-1]) * k % MOD) % MOD;\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll; \nll fact[1000005], inv[1000005]; \ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD; \n\t\ta = a * a % MOD; \n\t\tn >>= 1; \n\t}\n\treturn res; \n}\ninline ll C(int n, int m)\n{\n\treturn fact[n] * inv[m] % MOD * inv[n - m] % MOD; \n}\nint main()\n{\n\t// freopen(\"AGC023-C.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d\", &n); \n\tll ans = 0; \n\tfact[0] = 1; \n\tfor (int i = 1; i <= n; i++)\n\t\tfact[i] = fact[i - 1] * i % MOD; \n\tinv[n] = quick_pow(fact[n], MOD - 2); \n\tfor (int i = n; i; i--)\n\t\tinv[i - 1] = inv[i] * i % MOD; \n\tfor (int k = 1; k < n; k++)\n\t\t(ans += C(k - 1, n - k - 1) * fact[k] % MOD * fact[n - k - 1]) %= MOD; \n\tprintf(\"%lld\\n\", (fact[n - 1] * n - ans + MOD) % MOD);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define repr(i,b,e) for(int i = (b); i <= (e); i++)\n#define INF (1001001001)\n#define EPS (1e-15)\n\n#define pr(x) do{cerr << (#x) << \" = \" << (x) << endl;}while(0)\n#define pri(x,i) do{cerr << (#x) << \"[\" << i << \"] = \" << (x[i]) << endl;}while(0)\n#define pra(x) do{rep(__i,(x).size()) pri(x,__i);}while(0)\n#define pran(x,n) do{rep(__i,n) pri(x,__i);}while(0)\n#define pral(x) do{cerr << (#x) << \" =\";rep(__i,(x).size()) cerr<<\" \"<<(x[__i]);cerr<<endl;}while(0)\n#define prar(x,b,e) do{repr(__i,b,e) pri(x,__i);}while(0)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool CHMAX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool CHMIN(T &l,const T &r){return l>r?l=r,1:0;}\n\nll MOD = 1000000007;\n\nfunction<void(int,int)> tensi_no_3p=[&](int v,int d){\n};\n\nint in() {\n\tint a;\n\tscanf(\"%d \", &a);\n\treturn a;\n}\n\nll inv(ll a) {\n\tll ret = 1;\n\tll t = a;\n\tll n = MOD - 2;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1) ret = (ret * t) % MOD;\n\t\tt = t * t % MOD;\n\t\tn /= 2;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tassert(inv(42) * 42 % MOD == 1);\n\tll N;\n\tcin >> N;\n\tll minN = (N + 1) / 2;\n\tvector<ll> cums(N + 1);\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\trepr(i, 1, N) fact[i] = fact[i - 1] * i % MOD;\n\tcums[minN] = fact[minN - 1] * fact[minN] % MOD * inv(fact[2 * minN - N]) % MOD;\n\trepr(k, minN, N - 2) {\n\t\tcums[k + 1] = cums[k] * k % MOD * (k + 1) % MOD * inv(2 * k - N + 1) % MOD * inv(2 * k - N + 2) % MOD;\n\t}\n\t//pra(cums);\n\tll ans = 0;\n\trepr(k, 1, N - 1) {\n\t\tans += k * (cums[k] - cums[k - 1] + MOD) % MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\nint hoge() {\n\tint N;\n\tcin >> N;\n\tvint P(N - 1);\n\trep(i, N - 1) P[i] = i;\n\tll ans = 0;\n\tdo {\n\t\tvint box(N);\n\t\tint n = 0;\n\t\tint i;\n\t\tfor (i = 0; i < N - 1; i++) {\n\t\t\tif (box[P[i]] == 0) n++, box[P[i]]++;\n\t\t\tif (box[P[i] + 1] == 0) n++, box[P[i] + 1]++;\n\t\t\tif (n == N) break;\n\t\t}\n\t\tans = (ans + i + 1) % MOD;\n\t} while (next_permutation(P.begin(), P.end()));\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  comb c(n+100);\n  mint ans = 0;\n\n  rep(i,n) {\n    mint x = 0;\n    int k = n-1-i;\n    int s = n-1-k*2-1;\n    if (s < 0) {\n      x = 0;\n    } else {\n      x = c.c(s+k,k);\n    }\n    x = c.c(n-1,i)-x;\n    ans += x*c.f[i]*c.f[k];\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nusing ll = long long;\nconst ll MAX = 200000;\nconst ll mod = 1000000007;\nll fact[MAX],inv[MAX],fi[MAX];\nvoid fii(){\n    inv[1] = 1;\n    for(int i=2;i<=100000;i++){\n        inv[i] = mod - mod/i*inv[mod%i]%mod;\n    }\n    fact[0] = 1; fact[1] = 1; fi[0] = 1; fi[1] = 1;\n    for(int i=2;i<=100000;i++){\n        fact[i] = fact[i-1]*i%mod;\n        fi[i] = fi[i-1]*inv[i]%mod;\n    }\n}\n\nll nck(int n, int k){\n    if(k>n) return 0;\n    return fact[n]*fi[n-k]%mod*fi[k]%mod;\n}\n\nll dp[1000010],ans = 0;\nint main(){\n    int i,n;\n    cin >> n;\n    fii(); dp[0] = 0;\n    for(i=1;i<n;i++){\n        dp[i] = nck(i-1,n-1-i)*fact[i]%mod*fact[n-1-i]%mod;\n    }\n    for(i=1;i<n;i++){\n        (ans += (mod + dp[i]-dp[i-1])%mod*i) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ld long double\n\nusing namespace std;\n\nconst int mod = (int)1e9 + 7;\nconst int maxn = (int)2e6;\nint fac[maxn];\n\n\nint binpow(int a, int p){\n    if(p == 0)return 1;\n    if(p % 2 == 0){\n        int k = binpow(a, p / 2);\n        return (k * k) % mod;\n    } else {\n        return (a * binpow(a, p - 1)) % mod;\n    }\n}\n\nvoid prepare(){\n    fac[0] = 1;\n    for(int i = 1; i < maxn; ++i){\n        fac[i] = (fac[i - 1] * i) % mod;\n    }\n}\n\ninline int rev(int a){\n    return binpow(a, mod - 2);\n}\n\n\nint c(int n, int k){\n    //cerr << n << \" \" << k << \"\\n\";\n    assert(n >= 0 && k >= 0 && n - k >= 0);\n    return ((fac[n] * rev(fac[n - k])) % mod * rev(fac[k]) % mod);\n}\n\n\n\n\n\nvoid solve(){\n    prepare();\n    int n;\n    cin >> n;\n    if(n == 2){\n        cout << 1 << \"\\n\";\n        return;\n    }\n    int ans = 0;\n    int prv = 0;\n    int num = 0;\n    vector < int > a(n);\n    for(int i = (n + 1) / 2; i <= n - 1; ++i){\n        a[i] = (c(i - 1, n - i - 1) * ((fac[i] * fac[n - i - 1]) % mod)) % mod;\n    }\n    for(int i = (n + 1) / 2; i <= n - 1; ++i){\n        ans = ((ans + ((a[i] - a[i - 1] + mod) % mod) * i) % mod) % mod;\n    }\n    cout << ans << \"\\n\";\n}\n\n\n\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t = 1;\n    #ifdef DEBUG\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n        cin >> t;\n    #endif\n    for(int i = 0; i < t; ++i){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int uint;\ntypedef pair <int, int> pii;\ntypedef unsigned long long uLL;\n\ntemplate <typename T> inline void Read(T &x) {\n  char c = getchar();\n  bool f = false;\n  for (x = 0; !isdigit(c); c = getchar()) {\n    if (c == '-') {\n      f = true;\n    }\n  }\n  for (; isdigit(c); c = getchar()) {\n    x = x * 10 + c - '0';\n  }\n  if (f) {\n    x = -x;\n  }\n}\n\ntemplate <typename T> inline bool CheckMax(T &a, const T &b) {\n  return a < b ? a = b, true : false;\n}\n\ntemplate <typename T> inline bool CheckMin(T &a, const T &b) {\n  return a > b ? a = b, true : false;\n}\n\nconst int N = 1000005;\nconst int mod = 1e9 + 7;\n\nint n, ans[N], fac[N], inv[N];\n\ninline int F(int x, int y) {\n  if (x < y) {\n    return 0;\n  }\n  return 1LL * fac[x] * inv[x - y] % mod;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"d.in\", \"r\", stdin);\n#endif\n  Read(n), fac[0] = fac[1] = inv[0] = inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n    inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n  }\n  for (int i = 2; i <= n; ++i) {\n    inv[i] = 1LL * inv[i - 1] * inv[i] % mod;\n  }\n  for (int i = 1; i < n; ++i) {\n    ans[i] = 1LL * fac[i] * F(i - 1, n - i - 1) % mod;\n  }\n  int ret = 0;\n  for (int i = n - 1; i; --i) {\n    ans[i] = (ans[i] - ans[i - 1] + mod) % mod;\n    ret = (1LL * ans[i] * i + ret) % mod;\n  }\n  printf(\"%d\\n\", ret);\n#ifdef wxh010910\n  Debug(\"My Time: %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\n#define MAX_N 1000010\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n\tlong long d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nlong long mod_inverse(long long a, long long m) {\n\tlong long x, y;\n\tif(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n\telse return -1;\n}\nvector<long long> fact(MAX_N+1, INF);\nlong long mod_fact(long long n, long long& e) {\n\tif(fact[0] == INF) {\n\t\tfact[0]=1;\n\t\tif(MAX_N != 0) fact[1]=1;\n\t\tfor(ll i = 2; i <= MAX_N; ++i) {\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t}\n\t}\n\te = 0;\n\tif(n == 0) return 1;\n\tlong long res = mod_fact(n / MOD, e);\n\te += n / MOD;\n\tif((n / MOD) % 2 != 0) return (res * (MOD - fact[n % MOD])) % MOD;\n\treturn (res * fact[n % MOD]) % MOD;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n\tif(n < 0 || k < 0 || n < k) return 0;\n\tlong long e1, e2, e3;\n\tlong long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n\tif(e1 > e2 + e3) return 0;\n\treturn (a1 * mod_inverse((a2 * a3) % MOD, MOD)) % MOD;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll n;\n\tcin>>n;\n\tll buf=1;\n\tREP(i,n-1) {\n\t\tbuf*=(i+1);\n\t\tbuf%=MOD;\n\t}\n\tbuf*=(n-1);\n\tbuf%=MOD;\n\tll ans=buf;\n\tbuf=1;\n\tvector<ll> fact(n+10,1);\n\tFOR(i,1,n+10) {\n\t\tbuf*=i;\n\t\tbuf%=MOD;\n\t\tfact[i]=buf;\n\t}\n\tfor(ll i=n-1; i>=0; i--) {\n\t\tll c1=i,c2=(n-1)-i;\n\t\tif(c2>=c1) continue;\n\t\tans-=((mod_comb(c1-1,c2)*fact[i])%MOD)*fact[n-1-i];\n\t\tans%=MOD;\n\t}\n\tcout<<((ans+fact[n-1])%MOD+MOD)%MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nLL MOD = 1000000007;\nLL fact[1000001];\nLL inv_fact[1000001];\nLL comb(LL n, LL k) {\n\tif (n < k) return 0;\n\tLL ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nLL mod_pow(LL a, LL b) {\n\tif (b == 0) return 1;\n\tif (b % 2 == 0) {\n\t\tLL x = mod_pow(a, b / 2);\n\t\treturn (x*x) % MOD;\n\t}\n\treturn (mod_pow(a, b - 1)*a) % MOD;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfact[i] = fact[i - 1];\n\t\t(fact[i] *= i) %= MOD;\n\t\tinv_fact[i] = inv_fact[i - 1];\n\t\t(inv_fact[i] *= mod_pow(i, MOD - 2)) %= MOD;\n\t}\n\tLL ans = 0;\n\tLL prev = 0;\n\tLL now = 0;\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tLL ret = comb(i - 1, N - 1 - i);\n\t\t(ret *= fact[i]) %= MOD;\n\t\t(ret *= fact[N - 1 - i]) %= MOD;\n\t\tnow = ret;\n\t\tret = (ret - prev + MOD) % MOD;\n\t\t(ret *= i) %= MOD;\n\t\t(ans += ret) %= MOD;\n\t\tprev = now;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\n\nconst long long MOD = 1e9 + 7;\nconst int N = 2000005;\nint n;\n\nlong long fact[N + 1];\nlong long ufact[N + 1];\nlong long r[N + 1];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nlong long ans = 0;\nlong long w[N + 1];\n\nlong long cnk(long long n, long long k)\n{\n    if (k < 0 || k > n) return 0;\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    fact[0] = 1, ufact[0] = 1, r[1] = 1;\n    for (int i = 2; i <= N; i++) r[i] = (MOD - (MOD / i) * r[MOD % i] % MOD) % MOD;\n    for (int i = 1; i <= N; i++) fact[i] = fact[i - 1] * i % MOD, ufact[i] = ufact[i - 1] * r[i] % MOD;\n    //for (int i = 0; i <= n; i++) cout << inq(fact[i], MOD - 2) << \" \" << ufact[i] << \"\\n\";\n    for (int i = 1; i <= n - 1; i++)\n    {\n        w[i] = cnk(i - 1, n - i - 1) * fact[i] % MOD * fact[n - i - 1] % MOD;\n    }\n    long long si = 0;\n    for (int i = 1; i <= n - 1; i++)\n    {\n        ans = (ans + (w[i] - w[i - 1] + MOD) * i) % MOD;\n        si = (si + w[i]) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst int N=1000005;\nconst int MOD=1e9+7;\nint add (int x,int y)   {x=x+y;return x>=MOD?x-MOD:x;}\nint mul (int x,int y)   {return (LL)x*y%MOD;}\nint dec (int x,int y)   {x=x-y;return x<0?x+MOD:x;}\nint Pow (int x,int y)\n{\n\tif (y==0) return 1;\n\tif (y==1) return x;\n\tint lalal=Pow(x,y>>1);\n\tlalal=mul(lalal,lalal);\n\tif (y&1) lalal=mul(lalal,x);\n\treturn lalal;\n}\nint n;\nint JC[N],inv[N];\nvoid Init (int n)\n{\n\tJC[0]=1;for (int u=1;u<=n;u++) JC[u]=mul(JC[u-1],u);\n\tinv[n]=Pow(JC[n],MOD-2);\n\tfor (int u=n-1;u>=0;u--) inv[u]=mul(inv[u+1],u+1);\n}\nint C (int x,int y)\t{return mul(JC[x],mul(inv[y],inv[x-y]));}\nint f[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tInit(n);\n\tint ans=0;\n\tfor (int u=(n+1)/2;u<n;u++)\n\t{\n\t\tf[u]=mul(mul(C(u-1,n-u-1),JC[u]),JC[n-1-u]);\n\t\tans=add(ans,mul(u,dec(f[u],f[u-1])));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rng(i,s,n) for(int i = (s) ; i < (n) ; i++)\n#define rep(i,n) rng(i, 0, (n))\n#define mkp make_pair\n#define vec vector\n#define vi vec<int>\n#define pb emplace_back\n#define siz(a) (int)(a).size()\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) (lower_bound(all(b),(i))-(b).begin())\n#define ssp(i,n) (i==(int)(n)-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define cyes printf(\"Yes\\n\")\n#define cno printf(\"No\\n\")\n#define cdf(n) int quetimes_=(n);rep(qq123_,quetimes_)\n#define gcj printf(\"Case #%lld: \",qq123_+1)\n#define readv(a,n) a.resize(n,0);rep(i,(n)) a[i]=read()\n#define found(a,x) (a.find(x)!=a.end())\n//#define endl \"\\n\"\nconstexpr int mod = (ll)1e9 + 7;\nconstexpr int Mod = 998244353;\nconstexpr ld EPS = 1e-10;\nconstexpr ll inf = (ll)3 * 1e18;\nconstexpr int Inf = (ll)15 * 1e8;\nconstexpr int dx[] = { -1,1,0,0 }, dy[] = { 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(short g = 0) { H u; int k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g == 1) u.fs--, u.sc--; if (g == 2) u.fs--; return u; }\nbool ina(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nbool ina(int t, int l, int r) { return l <= t && t < r; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll popcount(ll x) {\n    int sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n    return sum;\n}\ntemplate<typename T>\nclass csum {\n    vec<T> v;\npublic:\n    csum(vec<T>& a) :v(a) { build(); }\n    csum(){}\n    void init(vec<T>& a) { v = a; build(); }\n    void build() {\n        for (int i = 1; i < v.size(); i++) v[i] += v[i - 1];\n    }\n    T a(int l, int r) {\n        if (r < l) return 0;\n        return v[r] - (l == 0 ? 0 : v[l - 1]);\n    }//[l,r]\n    T b(int l, int r) {\n        return a(l, r - 1);\n    }//[l,r)\n    T a(pair<int, int>t) {\n        return a(t.first, t.second);\n    }\n    T b(pair<int, int>t) {\n        return b(t.first, t.second);\n    }\n};\nclass mint {\npublic:ll v;\n      mint(ll v = 0) { s(v % mod + mod); }\n      constexpr static int mod = (ll)1e9 + 7;\n      constexpr static int fn_ = (ll)2e6 + 5;\n      static mint fact[fn_], comp[fn_];\n      mint pow(int x) const {\n          mint b(v), c(1);\n          while (x) {\n              if (x & 1) c *= b;\n              b *= b;\n              x >>= 1;\n          }\n          return c;\n      }\n      inline mint& s(int vv) {\n          v = vv < mod ? vv : vv - mod;\n          return *this;\n      }\n      inline mint inv()const { return pow(mod - 2); }\n      inline mint operator-()const { return mint() - *this; }\n      inline mint& operator+=(const mint b) { return s(v + b.v); }\n      inline mint& operator-=(const mint b) { return s(v + mod - b.v); }\n      inline mint& operator*=(const mint b) { v = v * b.v % mod; return *this; }\n      inline mint& operator/=(const mint b) { v = v * b.inv().v % mod; return *this; }\n      inline mint operator+(const mint b) const { return mint(v) += b; }\n      inline mint operator-(const mint b) const { return mint(v) -= b; }\n      inline mint operator*(const mint b) const { return mint(v) *= b; }\n      inline mint operator/(const mint b) const { return mint(v) /= b; }\n      friend ostream& operator<<(ostream& os, const mint& m) {\n          return os << m.v;\n      }\n      friend istream& operator>>(istream& is, mint& m) {\n          int x; is >> x; m = mint(x);\n          return is;\n      }\n      bool operator<(const mint& r)const { return v < r.v; }\n      bool operator>(const mint& r)const { return v > r.v; }\n      bool operator<=(const mint& r)const { return v <= r.v; }\n      bool operator>=(const mint& r)const { return v >= r.v; }\n      bool operator==(const mint& r)const { return v == r.v; }\n      bool operator!=(const mint& r)const { return v != r.v; }\n      explicit operator bool()const { return v; }\n      explicit operator int()const { return v; }\n      mint comb(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              if (k > * this - k) k = *this - k;\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp * comp[k.v];\n          }\n          return fact[v] * comp[k.v] * comp[v - k.v];\n      }//nCk\n      mint perm(mint k) {\n          if (k > * this) return mint();\n          if (!fact[0]) combinit();\n          if (v >= fn_) {\n              mint tmp(1);\n              for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);\n              return tmp;\n          }\n          return fact[v] * comp[v - k.v];\n      }//nPk\n      static void combinit() {\n          fact[0] = 1;\n          for (int i = 1; i < fn_; i++) fact[i] = fact[i - 1] * mint(i);\n          comp[fn_ - 1] = fact[fn_ - 1].inv();\n          for (int i = fn_ - 2; i >= 0; i--) comp[i] = comp[i + 1] * mint(i + 1);\n      }\n}; mint mint::fact[fn_], mint::comp[fn_];\n//--------------------------------------------------------------\n\n\n//---------------------------------------------------------------------\n\nint n;\nsigned main() {\n    cin >> n;\n\n    //(n+1)/2以上でしか動かない\n    mint ans = 0, pre = 0;\n    for (int i = (n + 1) / 2; i <= n - 1; i++) {\n        //埋めるには、nブロック必要\n        //何ブロックに分かれるかを見る→(2*n-(i*2))/2=n-i\n        //n-i個の区画に分かれると見てよい\n\n        int t = n - i;//区画の数\n        //最後に埋めきるのにどこを選ぶかは、長さ3以上の区画で2通り、長さ2の区画で1通り\n        //全ての区画は2個以上なので、(N-t*2)をt個の0以上にに分ける方法を考えればよい\n        //あとは、何個のブロックを置くか!\n        //最後に生贄になるブロックはドイツ？\n        //2個ブロックをj個置く場合、j+(t-j)*2\n        //Σ2*t-j = k\n\n        int g = 2 * i - n;//何個だぶりが必要か？\n        //これを3に全ぶっぱしたのが最小\n\n\n        mint res = mint(i - 1).comb(n - 1 - i) * mint::fact[i] * mint::fact[n - i - 1];\n        ans += (res - pre) * i;\n        pre = res;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1e9+7;\nconst double PI=3.14159265359;\n\n\n\nint n,k1,k2;\n\nint main(){\n    \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int n;\n    cin>>n;\n    if(n==2){\n        cout<<1;\n        return 0;\n    }\n    if(n==3){\n        cout<<4;\n        return 0;\n    }\n    //long long ct1m1=0;\n    long long ct1m1=0, ct0=1, ct1=1, dp0=2, dp1=2;\n    \n    for(long long i=4; i<=n; i++){\n        long long dp1c=(i-1)*(ct0+ct1);\n        long long ct1c=ct0+ct1;\n        \n        long long dp0c=(i-2)*dp1+(i-2)*(dp0+ct0);\n        long long ct0c=(i-2)*(ct0+ct1);\n        \n        //ct1m1=ct1;\n        dp1c%=MOD;\n        ct1c%=MOD;\n        dp0c%=MOD;\n        ct0c%=MOD;\n        \n        ct0=ct0c;\n        ct1=ct1c;\n        dp0=dp0c;\n        dp1=dp1c;\n    }\n    //cout<<ct0<<\" \"<<ct1<<endl;\n    //cout<<dp0<<\" \"<<dp1<<endl;\n    cout<<(dp0+dp1)%MOD;\n    \n    \n    return 0;\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\nusing namespace std;\nint main(void){\n    int n=0,i=0,buf1=0,buf3=0,buf;\n    cin >> n;\n    if(n>1000000||n<2){\n    \texit(0);\n    }\n    buf3=n;\n    n=n-1;\n    vector<long long int> v(n);\n    vector<long long int> buf2;\n    iota(v.begin(),v.end(),1);\n    do {\n        for(auto x : v)buf2.push_back(x);i++;\n    }while(next_permutation(v.begin(),v.end()));\n    if(buf3%2==0){\n        buf1=(i-2)*3+(2*2);\n    }\n    else{\n        buf1=(i-(buf3%2+buf3/2))*n;\n        /*+((buf3%2+buf3/2)*2)*/\n    }\n    cout  << buf1%(1000000000+7);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst int NUM_=1e6+10;\nll fact[NUM_+1]={},factr[NUM_+1]={},inv[NUM_+1]={};\n\nll combi(ll N_, ll C_, ll mo=MOD) {\n  auto binpow = [&](ll x, ll e) -> ll{\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % mo; e /= 2;}\n      else {a = (a*p) % mo; e--;}\n    }\n    return a;\n  };\n  if (fact[0]==0) {\n    fact[0] = factr[0] = inv[0] = 1;\n    // FOR(i, 1, NUM_+1) fact[i] = fact[i-1] * i % MOD;\n    // factr[NUM_] = binpow(fact[NUM_], mo-2);\n    // for(int i=NUM_-1; i>=0; --i) factr[i] = factr[i+1] * (i+1) % MOD;\n    FOR(i, 1, NUM_) {\n      fact[i] = fact[i-1] * i % MOD;\n      inv[i] = binpow(i, MOD-2) % MOD;\n      factr[i] = factr[i-1] * inv[i] % MOD;\n    }\n  }\n  if(C_<0 || C_>N_) return 0;\n  // 前計算 O(max(N,K)) クエリ O(1)\n  return factr[C_]*fact[N_]%MOD*factr[N_-C_]%MOD;\n  // 前計算 O(max(N,K)log(mod)) クエリ O(K)\n  // ll ret = 1;\n  // for(;C_>0;N_--,C_--) (ret *= N_%MOD) %= MOD, (ret *= inv[C_]) %= MOD;\n  // return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  if(n == 2) {\n    cout << 1 << endl;\n    return 0;\n  }\n  if(n == 3) {\n    cout << 4 << endl;\n    return 0;\n  }\n  if(n == 4) {\n    cout << 16 << endl;\n    return 0;\n  }\n  if(n == 5) {\n    cout << 84 << endl;\n    return 0;\n  }\n\n  int a = 0, ret = 0;\n  REP(i, n) {\n    int tmp = combi(i-1, n-i-1) * fact[i] % MOD * fact[n-i-1] % MOD;\n    (ret += i*(tmp-a)%MOD) %= MOD;\n    a = tmp;\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = (1LL << 32);\nconst long long MOD = 1000000007;\nconst long double PI = 3.1415926;\n#define FOR(i,r,n) for(ll i = (ll)(r); i < (ll)(n); i++)\n#define RFOR(i,r,n) for(ll i=(ll)(n-1);i>=r;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define RALL(x) x.rbegin(),x.rend()\ntypedef long long int ll;\ntypedef vector<ll> vi;\ntypedef vector<pair<ll, ll> > vp;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef list<ll> lst;\ntypedef pair<ll, ll> P;\ntemplate <class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nll n, m, k, ans = 0, sum = 0, cnt = 0;\nstring s;\n//char c;\n\n#define Endl endl\n\n/*--------------------template--------------------*/\n\n// O(log n)\nll powMOD(ll a, ll b)\n{\n    ll x = 1;\n    while (b > 0)\n    {\n        if (b & 1)\n        {\n            x = (x * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\nll nCk(ll a, ll b)\n{\n    ll x = 1;\n    REP(i, b)\n    {\n        x *= (a - i);\n        x %= MOD;\n    }\n    ll y = 1;\n    for (int i = b; i >= 2; i--)\n    {\n        y *= i;\n        y %= MOD;\n    }\n    return (x * powMOD(y, MOD - 2) % MOD) % MOD;\n}\n\n\n\nvi kaijo(ll n){\n    vi ret(n+1);\n    ret[0] = 1;\n    FOR(i,1,n+1) {\n        ret[i] = ret[i - 1] * i;\n        ret[i] %= MOD;\n    }\n    return ret;\n}\n\n\nint main() {\n    cin >> n;\n    if(n==2){\n        cout << 1 << endl;\n        return 0;\n    }else if(n==3){\n        cout << 4 << endl;\n        return 0;\n    }else if(n==4){\n        cout << 16 << endl;\n        return 0;\n    }\n    vi v = kaijo(n);\n    ans = v[n];\n    FOR(i,1,n) {\n        m = nCk(i - 1, n - 1 - i) * v[i] * v[n - 1 - i];\n        //cout << \"k = \" << i << \"  \" << m << endl;\n        ans -= m;\n        if(ans<0){\n            ans += MOD;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int \n#define ll long long \nusing namespace std;\nconst int mod = 1e9+7;\nll ksm(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y>>=1;\n\t}return res;\n}\nll fac[3000100],Ifac[3010000];\ninline ll C(ll x,ll y){\n\treturn fac[x]*Ifac[y]%mod*Ifac[x-y]%mod;\n}\nint n;\nint main(){\n\tcin>>n;\n\tfac[0]=Ifac[0]=1;\n\tfor(rint i=1;i<=2*n;++i) fac[i]=fac[i-1]*i%mod;\n\tIfac[2*n]=ksm(fac[2*n],mod-2);\n\tfor(rint i=2*n-1;i;--i) Ifac[i]=Ifac[i+1]*(i+1)%mod;\n\tll ans=0,las=0;\n\tfor(rint i=(n+1)/2;i<=n-1;++i) {\n\t\tll tmp=1ll*C(i-1,n-i-1)*fac[i]%mod*fac[n-1-i]%mod;\n\t\tans=ans+(tmp-las)*i%mod+mod;\n\t\tans%=mod;\n\t\tlas=tmp; \n\t}cout<<ans;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int m=1e9+7;\nint f[1000001]={1,1},inv[1000001]={1,1},invf[1000001]={1,1},n;\nsigned main()\n{\n\tcin>>n;\n\tfor(int i=2;i<=n;i++)f[i]=f[i-1]*i%m,inv[i]=(m-m/i)*inv[m%i]%m,invf[i]=invf[i-1]*inv[i]%m;\n\tint ans=0;\n\tfor(int i=(n+1)/2;i<n;i++)ans+=f[i]*f[i-1]%m*invf[2*i-n]%m;\n\tcout<<(m+f[n]-ans%m)%m<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 28.04.2018 15:08:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n#if !defined(_WIN32) || defined(_WIN64)\n  return (int) ((long long) a * b % md);\n#endif\n  unsigned long long x = (long long) a * b;\n  unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n  asm(\n    \"divl %4; \\n\\t\"\n    : \"=a\" (d), \"=d\" (m)\n    : \"d\" (xh), \"a\" (xl), \"r\" (md)\n  );\n  return m;\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> fact(n + 1), inv_fact(n + 1);\n  fact[0] = inv_fact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fact[i] = mul(fact[i - 1], i);\n    inv_fact[i] = inv(fact[i]);\n  }\n  int ans = 0;\n  for (int k = (n + 1) / 2; k <= n - 1; k++) {\n    int cur = mul(fact[k - 1], mul(inv_fact[n - 1 - k], inv_fact[k - 1 - (n - 1 - k)]));\n    cur = mul(cur, mul(fact[k], fact[n - 1 - k]));\n    add(ans, cur);\n  }\n  int actual = mul(fact[n - 1], n);\n  sub(actual, ans);\n  cout << actual << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<ll,ll> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-3;\nint dx[4]={0,1,0,1};\nint dy[4]={0,0,1,1};\nll f[1001000],fi[1001000];\nll mod_pow(ll x,ll n,ll mod){\n    ll ret=1;\n    while(n>0){\n        if(n&1){\n            ret=ret*x%mod;\n        }\n        x=x*x%mod;\n        n>>=1;\n    }\n    return ret;\n}\n\nvoid fact(ll n){\n\tf[0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tf[i]=f[i-1]*i%MOD;\n\t}\n\tfi[n]=mod_pow(f[n],MOD-2,MOD);\n\tfor(ll i=n-1;i>=0;i--){\t\t\n\t\tfi[i]=fi[i+1]*(i+1)%MOD;\n\t}\n}\n\nll ncr(ll n,ll k){\n\tif(n<k)return 0;\n\tif(k==0){\n\t\treturn 1;\n\t}else{\n\t\treturn f[n]*fi[k]%MOD*fi[n-k]%MOD;\n\t}\n}\n\nint main(){\n\tll n;cin>>n;n--;\n\tfact(1000010);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tll ans=f[n+1];\n    for(ll i=0;i<n;i++){\n\t\tans-=((ncr(n-i-1,i)%MOD*f[i])%MOD*f[n-i])%MOD;\n\t\t(ans+=MOD)%=MOD;\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define MAXN 1000005\n#define PLI pair<long long,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define ha 99994711\n#define ba 823\n#define MOD 1000000007\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\nint64 fac[MAXN],invfac[MAXN],ans;\nint N;\nint64 fpow(int64 x,int64 c) {\n\tint64 res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = res * t % MOD;\n\t\tt = t * t % MOD;\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nint64 C(int n,int m) {\n\tif(n < m) return 0;\n\treturn fac[n] * invfac[m] % MOD * invfac[n - m] % MOD;\n}\nint64 W(int k) {\n\tint x = N - 2 - k;\n\tint y = k - x;\n\tif(x < 0 || y < 0) return 0;\n\treturn fac[k] * invfac[y] % MOD * invfac[x] % MOD;\n}\nvoid Solve() {\n\tscanf(\"%d\",&N);\n\tif(N == 2) {\n\t\tputs(\"1\");\n\t\treturn;\n\t}\n\tfac[0] = invfac[0] = 1;\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t}\n\tinvfac[N] = fpow(fac[N],MOD - 2);\n\tfor(int i = N - 1 ; i >= 1 ; --i) {\n\t\tinvfac[i] = invfac[i + 1] * (i + 1) % MOD;\n\t}\n\tans += fac[N - 1];\n\tfor(int i = 1 ; i < N - 1 ; ++i) {\n\t\tans += (C(N - 2,i) + C(N - 2,i - 1) + MOD - W(i - 1))* fac[i] % MOD * fac[N - 1 - i] % MOD;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    考虑一个可以用 K ((n+1)/2 <= K < n)次染黑的方案，\n\t那么将操作前K次的机器从小到大排序，一定是:\n\ta1=1 < a2 < ...< ak=n-1\n\t并且 a[i+1]-a[i] <= 2\n\t\n\t转化模型，就是一个变量初始等于 1 ,每次操作可以 +1 或者 +2 ,\n\tk-1 次操作之后 = n-1 的方案数. \n\t\n\tC(k-1 , n-k-1) * (k!) * ((n-k-1)!)\n*/\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int ha=1e9+7,N=1e6+5,mod=ha-1;\n \ninline int add(int x,int y){ x+=y; return x>=ha?x-ha:x;}\ninline void ADD(int &x,int y){ x+=y; if(x>=ha) x-=ha;}\n \ninline int ksm(int x,int y){\n    int an=1;\n    for(;y;y>>=1,x=x*(ll)x%ha) if(y&1) an=an*(ll)x%ha;\n    return an;\n}\n \nint n,jc[N],ni[N],ans,f[N]; \n \ninline void init(){\n    jc[0]=1;\n    for(int i=1;i<=n;i++) jc[i]=jc[i-1]*(ll)i%ha;\n    ni[n]=ksm(jc[n],ha-2);\n    for(int i=n;i;i--) ni[i-1]=ni[i]*(ll)i%ha;\n}\n\ninline void solve(){\n\tfor(int k=n+1>>1;k<n;k++) f[k]=jc[k]*(ll)jc[k-1]%ha*(ll)ni[2*k-n]%ha;\n\tfor(int k=n+1>>1;k<n;k++) ADD(ans,add(f[k],ha-f[k-1])*(ll)k%ha);\n}\n\nint main(){\n\tscanf(\"%d\",&n),init();\n\tsolve(),printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int N = 1e6 + 1, mod = 1e9 + 7;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nI int pow_mod(reg a, reg k) {reg ans = 1; for(; k; k >>= 1, a = (LL)a * a % mod) if(k & 1) ans = (LL)ans * a % mod; return ans;}\n\nint jc[N], inv[N], f[N];\n\nI int C(int n, int m) {return (LL)jc[n] * inv[m] % mod * inv[n - m] % mod;}\n\nint main() {\n\treg n = read();\n\tjc[0] = 1; fo(i, 1, n) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[n] = pow_mod(jc[n], mod - 2); fd(i, n, 1) inv[i - 1] = (LL)inv[i] * i % mod;\n\treg d = (n + 1) / 2;\n\tfo(i, d, n - 1) f[i] = (LL)C(i - 1, n - i - 1) * jc[i] % mod * jc[n - i - 1] % mod;\n\treg ans = 0;\n\tfo(i, d, n - 1) ans = (ans + (LL)i * (f[i] - f[i - 1])) % mod;\n\tpr2(ans < 0 ? ans + mod : ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 10 , mod = 1e9 + 7;\nint fac[maxn] , inv[maxn] , ifac[maxn];\nint n;\nvoid init(){\n\tfac[0] = fac[1] = 1;\n\tfor(int i = 2 ; i <= 1000000 ; ++ i)\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2 ; i <= 1000000 ; ++ i)\n\t\tinv[i] = mod - 1ll * (mod / i) * inv[mod % i] % mod;\n\tifac[0] = 1;\n\tfor(int i = 1 ; i <= 1000000 ; ++ i)\n\t\tifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;\n}\nint C(int x , int y){\n\tif(x < y) return 0;\n\treturn 1ll * fac[x] * ifac[x - y] % mod * ifac[y] % mod;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin >> n;\n\tn --;\n\tinit();\n\tint ans = 0;\n\tint last = 0;\n\tfor(int i = n - 1 ; i >= 0 ; -- i){\n\t\tint cur = 1ll * C(n - i - 1 , i) * fac[i] % mod * fac[n - i] % mod;\n\t\tans = (ans + 1ll * (cur + mod - last) * (n - i) % mod) % mod;\n\t\tlast = cur;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL MOD;\nLL mod(LL x, LL m = MOD) { return (x % m + m) % m; }\npair<LL, LL> ex_gcd(LL a, LL b) {\n\tif(b == 0) { return MP(1, 0); }\n\tauto p = ex_gcd(b, a % b);\n\treturn MP(p.SE, p.FI - (a / b) * p.SE);\n}\nLL inv(LL x, LL m = MOD) {\n\tassert(gcd(x, m) == 1);\n\tauto p = ex_gcd(x, m);\n\treturn mod(p.FI, m);\n}\nLL promod(LL x, LL y, LL m = MOD) { return mod((x % m) * (y % m), m); }\nLL divmod(LL x, LL y, LL m = MOD) { return promod(x, inv(y, m), m); }\n\n// ----\n\nstruct CombMod {\n\tLL lim = 0, mod;\n\tLL * fact; // fact[i]: i の階乗\n\tLL * finv; // finv[i]: i の階乗の逆元\n\t\n\tCombMod() { }\n\tCombMod(LL lim, LL mod = MOD) { init(lim, mod); }\n\tvoid init(LL arg_lim, LL arg_mod = MOD) {\n\t\tlim = arg_lim;\n\t\tmod = arg_mod;\n\t\tfact = new LL[lim + 1];\n\t\tfinv = new LL[lim + 1];\n\t\tfact[0] = 1;\n\t\tinc1(i, lim) { fact[i] = promod(fact[i - 1], i, mod); }\n\t\tfinv[lim] = inv(fact[lim], mod);\n\t\tdec(i, lim) { finv[i] = promod(finv[i + 1], i + 1, mod); }\n\t}\n\tLL P(LL a, LL b) {\n\t\tassert(inII(a, 0, lim) && inII(b, 0, lim));\n\t\treturn (a < b ? 0 : promod(fact[a], finv[a - b], mod));\n\t}\n\tLL C(LL a, LL b) {\n\t\tassert(inII(a, 0, lim) && inII(b, 0, lim));\n\t\treturn (a < b ? 0 : promod(P(a, b), finv[b], mod));\n\t}\n\tLL H(LL a, LL b) {\n\t\tassert(inII(a, 0, lim) && inII(b, 0, lim) && inII(a + b - 1, -1, lim));\n\t\treturn (a == 0 ? (b == 0) : C(a + b - 1, b));\n\t}\n};\n\n// ----\n\nLL n;\n\nint main() {\n\tcin >> n;\n\t\n\tMOD = 1e9 + 7;\n\tCombMod cm(n);\n\t\n\tLL ans = cm.fact[n - 1] * (n - 1) % MOD, s = 0;\n\tincID(i, 1, n - 1) {\n\t\tint j = n - 1 - i;\n\t\tif(i - 1 < j) { continue; }\n\t\t(s += cm.C(i - 1, j) * cm.fact[i] % MOD * cm.fact[j]) %= MOD;\n\t}\n\t(ans += MOD - s) %= MOD;\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst int mod=1e9+7;\nll kika[1000006];\nstruct Combinatorics {\n  using int64 = long long;\n  int64 mod;\n  int64 fact[1000006];\n  int64 invfact[1000006];\n  Combinatorics(int64 mod):mod(mod) {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < 1000006; ++i) {\n      fact[i] = fact[i-1]*i%mod;\n      invfact[i] = minv(fact[i]);\n    }\n  }\n  int64 mpow(int64 x, int64 n) const {\n    int64 res = 1;\n    while(n > 0) {\n      if(n&1) res = res*x%mod;\n      x = x*x%mod;\n      n >>= 1;\n    }\n    return res;\n  }\n  int64 minv(int64 x) const {\n    return mpow(x, mod-2);\n  }\n  int64 mfact(int64 x) const {\n    return fact[x];\n  }\n  int64 C(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[r]%mod*invfact[n-r]%mod;\n  }\n  int64 P(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[n-r]%mod;\n  }\n};\n// ちょうどk回目で全て黒くなる通り数を求めるのは難しい\n// k回以下で黒くなっている通り数は求めやすい\n// k個になる個数=(k以下の個数-(k-1)以下の個数)テク\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N;cin>>N;\n  if(N==2){\n    cout<<1<<endl;\n    return 0;\n  }\n  Combinatorics COM(mod);\n  kika[N-1]=COM.mfact(N-1);\n  for(int k=N-2;k>=(N-1)/2;k--){\n    kika[k]=(COM.mfact(k)*COM.mfact(N-1-k))%mod;\n    kika[k]=(kika[k]*COM.C(k-1,N-k-1))%mod;\n  }\n  ll ans=0;\n  for(int k=N-1;k>=(N-1)/2;k--){\n    ans=ans+((kika[k]-kika[k-1]+mod)%mod)*k%mod;\n    ans%=mod;\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll n,k,a[MAXN];\nll pow_mod(ll a,ll i)\n{\n\tll s=1;\n\twhile(i)\n\t{\n\t\tif(i&1) s=s*a%MOD;\n\t\ta=a*a%MOD;\n\t\ti>>=1;\n\t}\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tll ans=0;\n\tif(n&1)\n\t{\n\t\tll st=3,mult=(n+1)*(n+3)/8,addn=7,adds=n/2+2,last=0;\n\t\tll init=2,cf=6,add=6;\n\t\tfor(ll i=5;i<=n;i+=2)\n\t\t{\n\t\t\tinit=init*cf%MOD;\n\t\t\tcf=(cf+add)%MOD;\n\t\t\tadd=add+2;\n\t\t}\n\t\t//printf(\"%lld\\n\",init);\n\t\tans+=init*((n+1)/2)%MOD;\n\t\tlast=init;\n\t\tfor(ll i=(n+1)/2+1;i<=n-1;i++)\n\t\t{\n\t\t\tinit=init*mult%MOD*pow_mod(st,MOD-2)%MOD;\n\t\t\tprintf(\"%lld\\n\",init);\n\t\t\tmult=(mult+adds)%MOD;\n\t\t\tst=(st+addn)%MOD;\n\t\t\tadds++;\n\t\t\taddn+=4;\n\t\t\tans=(ans+(init-last+MOD)*i)%MOD;\n\t\t\tlast=init;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tll st=1,mult=(n)*(n+2)/8,addn=5,adds=n/2+1,last=0;\n\t\tll init=2,cf=6,add=6;\n\t\tfor(ll i=6;i<=n;i+=2)\n\t\t{\n\t\t\tinit=init*cf%MOD;\n\t\t\tcf=(cf+add)%MOD;\n\t\t\tadd+=2;\n\t\t}\n\t\t//printf(\"%lld\\n\",init);\n\t\tans+=init*(n/2)%MOD;\n\t\tlast=init;\n\t\tfor(ll i=n/2+1;i<=n-1;i++)\n\t\t{\n\t\t\tinit=init*mult%MOD*pow_mod(st,MOD-2)%MOD;\n\t\t\t//printf(\"%lld\\n\",init);\n\t\t\tmult=(mult+adds)%MOD;\n\t\t\tst=(st+addn)%MOD;\n\t\t\tadds++;\n\t\t\taddn+=4;\n\t\t\tans=(ans+(init-last+MOD)*i)%MOD;\n\t\t\tlast=init;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define F first\n#define S second\n#define ld long double\nint const M=1e6+10,inf=1e9+10,mod=1e9+7;\nint fact[M],ans[M];\nint pw(int x,int y)\n{\n\tif(y==0)return 1;\n\tint tmp=pw(x,y/2);\n\tif(y%2==0)return (tmp*tmp)%mod;\n\treturn ((tmp*tmp)%mod*x)%mod;\n}\nint C(int n,int r)\n{\n\tint tmp=fact[r]*fact[n-r];\n\ttmp%=mod;\n\ttmp=pw(tmp,mod-2);\n\ttmp*=fact[n];\n\ttmp%=mod;\n\treturn tmp;\n}\nint say(int n,int r)\n{\n\treturn C(n-1,r-1);\n}\nint32_t main()\n{\n\tint n;\n\tcin>>n;\n\tfact[0]=1;\n\t//cout<<C(5,2)<<\" \"<<pw(2,4)<<endl;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfact[i]=fact[i-1]*i;\n\t\tfact[i]%=mod;\n\t}\n\tint all=0;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tif(n-i-1<0)continue;\n\t\tint res=n-i;\n\t\tif(i-1>=res)\n\t\t\tans[i]=say(i-1,res);\n\t\t//cout<<i<<\" \"<<ans[i]<<endl;\n\t\tint tmp=res*2;\n\t\ttmp%=mod;\n\t\ttmp*=fact[i-1];\n\t\ttmp%=mod;\n\t\ttmp*=fact[n-i-1];\n\t\ttmp%=mod;\n\t\ttmp*=i;\n\t\ttmp%=mod;\n\t\ttmp*=ans[i];\n\t\ttmp%=mod;\n\t//\tcout<<i<<\" \"<<res<<\" \"<<tmp<<\" \"<<ans[i]<<endl;\n\t\tall+=tmp;\n\t\tall%=mod;\n\t}\n\tcout<<all;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e6 + 5, MOD = 1e9 + 7;\nint fac[N], inv[N];\n\nint mul(int a, int b) {return 1ll * a * b % MOD;}\nint Pow(int a, int b) {\n    int res = 1;\n    for (; b; b>>=1, a = mul(a, a)) if (b&1) res = mul(res, a);\n    return res;\n}\nint C(int n, int k) {\n    if (k > n || k < 0 || n < 0) return 0;\n    return mul(fac[n], mul(inv[k], inv[n - k]));\n}\n\nint main() {\n    int n; cin >> n;\n    fac[0] = 1;\n    for (int i = 1; i <= n; i++) fac[i] = mul(fac[i - 1], i);\n    inv[n] = Pow(fac[n], MOD - 2);\n    for (int i = n - 1; i >= 0; i--) inv[i] = mul(inv[i + 1], i + 1);\n    int ans = fac[n];\n    for (int k = 1; k < n; k++) ans = (ans - mul(C(k - 1, n - k - 1), mul(fac[n - k - 1], fac[k])) + MOD) % MOD;\n    cout << ans << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    if(N == 2){\n        cout << 1;\n        return 0;\n    }\n    int mod = 1000000007;\n\n    Combination C(N, mod);\n    int ans = 0;\n\n    vec F(N);\n    REP(k, N){\n        int tmp = C.fact[k] * C.fact[N - 1 - k];\n        tmp %= mod;\n        tmp *= C.comb(k - 1, N - 1 - k);\n        tmp /= mod;\n        F[k] = tmp;\n    }\n\n    FOR(k, 1, N){\n        ans += k * (F[k] - F[k - 1] + mod);\n        ans / mod;\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing Pl = pair<ll, ll>;\nusing Tl = tuple<ll, ll, ll>;\n\nconst ll INF = 1e15;\nconst ld eps = 1e-6;\nconst ll MOD = 1e9+7;\n\n\nll gcd (ll a, ll b){\n  if(a%b==0)\n    return b;\n  else\n    return gcd(b,a%b);\n}\n\nll extgcd(ll a, ll b){\n  if(b%a==0)\n    return 1;\n  else{\n    return (1-b*extgcd(b%a, a))/a;\n  }\n}\n\nvector<ll> fact;\nvector<ll> factinv;\n\nll comb(ll n, ll r){\n  return fact[n] * factinv[n-r] % MOD * factinv[r] % MOD;\n}\n\n\nint main(){\n  ll N;\n  cin >> N;\n  if(N == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  fact.assign(N + 2, 1);\n  factinv.assign(N+2, 1);\n  for(ll i=1;i<fact.size();i++){\n    fact[i] = fact[i - 1] * i % MOD;\n    factinv[i] = (extgcd(fact[i], MOD) + MOD) % MOD;\n    assert(factinv[i] >= 0);\n    assert(factinv[i] * fact[i] % MOD == 1);\n  }\n  ll ans = 0;\n  /*\n    xo ooo ox\n    xo o ox\n    N - 3\n    1以上でunuse個にN-2を振り分ける -> N-2-unuseを0以上unuse種で振り分ける-> (N-2-unuse + unuse) C unuse\n    unuse個に振り分ける\n   */\n  ll before = 0;\n  for(ll use = (N + 1) / 2; use <= N  - 1; use++){\n    ll unuse = N - 1 - use;\n    ll now = (fact[use] * comb(N - 3, unuse) % MOD - before + MOD) % MOD;\n    before = now;\n    ans = (ans + use * now % MOD * fact[unuse] % MOD) % MOD;\n    //cout << use << \" \" << ans << endl;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\nCopy\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <boost/math/special_functions/factorials.hpp>\n \nint64_t score(int n) {\n  if (n == 2)\n    return 1;\n  if (n == 3)\n    return 4;\n  if (n == 4)\n    return 16;\n  return ((boost::math::factorial(n-2) + score(n-1)) * (n-1) -2 * boost::math::factorial(n-3)) % (10000000007);\n}\n \nint main() {\n  int n;\n  std::cin >> n;\n  std::cout << score(n) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define MAXN 2000005\n#define LL long long\n#define mod 1000000007\nusing namespace std;\n\nint n;\nLL fac[MAXN], inv[MAXN], ans, last;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    fac[0]=fac[1]=1; inv[0]=inv[1]=1;\n    for(int i=2; i<=n; i++) fac[i]=(fac[i-1]*i)%mod;\n    for(int i=2; i<=n; i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2; i<=n; i++) inv[i]=inv[i-1]*inv[i]%mod;\n    for(int i=(n+1)/2; i<n; i++)\n    {\n        LL com=fac[i-1]*inv[n-i-1]%mod*inv[2*i-n]%mod;\n        LL temp=com*fac[i]%mod*fac[n-i-1]%mod;\n        ans=(ans+(temp-last)*i%mod)%mod;\n        last=temp;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n# define IL inline\n# define RG register\n# define Fill(a, b) memset(a, b, sizeof(a))\nusing namespace std;\ntypedef long long ll;\n\nIL int Input(){\n    RG char c = getchar(); RG int x = 0, z = 1;\n    for(; c < '0' || c > '9'; c = getchar()) z = c == '-' ? -1 : 1;\n    for(; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n    return x * z;\n}\n\nconst int maxn(1e6 + 5);\nconst int mod(1e9 + 7);\n\nint n, fac[maxn], ifac[maxn], ans, f[maxn];\n\nIL int Pow(RG ll x, RG int y){\n\tRG ll ret = 1;\n\tfor(; y; x = x * x % mod, y >>= 1)\n\t\tif(y & 1) ret = ret * x % mod;\n\treturn ret;\n}\n\nIL int C(RG int x, RG int y){\n\tif(y > x) return 0;\n\treturn 1LL * fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nIL void Upd(RG int &x, RG int y){\n\tx += y;\n\tif(x >= mod) x -= mod;\n}\n\nint main(RG int argc, RG char* argv[]){\n\tn = Input(), fac[0] = ifac[0] = 1;\n\tfor(RG int i = 1; i <= n; ++i) fac[i] = 1LL * fac[i - 1] * i % mod;\n\tifac[n] = Pow(fac[n], mod - 2);\n\tfor(RG int i = n - 1; i; --i) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % mod;\n\tfor(RG int i = (n + 1) >> 1; i < n; ++i) f[i] = 1LL * C(i - 1, n - i - 1) * fac[i] % mod * fac[n - i - 1] % mod;\n\tfor(RG int i = n - 2, l =(n + 1) >> 1; i >= l; --i) Upd(f[i + 1], mod - f[i]);\n\tfor(RG int i = (n + 1) >> 1; i < n; ++i) Upd(ans, 1LL * f[i] * i % mod);\n\tprintf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\n#define PROBLEM_NAME \"c\"\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) (debug(x, #x))\n#define C(x...) CHECK(x)\n#else\n#define L(x, ...) (x)\n#define C(x, ...) ;\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ii = pair<int,int>; using vii = vector<ii>;\nusing l = long long; using vl = vector<l>; using vvl = vector<vl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = acos(-1);\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n\nl const MOD = e9 + 7;\n\nl brute(l n) {\n  vl v(n - 1);\n  iota(all(v), 0);\n  l z = 0;\n  do {\n    l m = 0;\n    l s = 0;\n    for (auto x : v) {\n      s++;\n      m = (m | (3 << x));\n      if (m == (l(1) << n) - 1) break;\n    }\n    z += s;\n  } while (next_permutation(all(v)));\n  return z;\n}\n\nl sign(l n) {\n  if (n < 0) return -1;\n  if (n == 0) return 0;\n  return 1;\n}\n\n// conruent modulo, works for negative\nl cong(l x, l mod) {\n  return (x % mod + mod) % mod;\n}\n\n// (a * b) % mod, safe for l near max\nl mult_mod(l a, l b, l mod) {\n  l x = 0;\n  while (b) {\n    if (b % 2) x = (x + a) % mod;\n    a = (a * 2) % mod;\n    b /= 2;\n  }\n  return x;\n}\n\n// (base^power) % mod, safe for l near max\nl pow_mod(l base, l power, l mod) {\n  l r = 1;\n  while (power) {\n    if (power % 2) r = mult_mod(r, base, mod);\n    base = mult_mod(base, base, mod);\n    power /= 2;\n  }\n  return r;\n}\n\nl divup(l a, l b) { // ceil div\n  return (a + b - 1) / b;\n}\n\n// return gcd(a, b) and set x, y: a * x + b * y = gcd(a, b)\nl extended_euclid(l a, l b, l& x, l& y) {\n  if (b == 0) { x = 1; y = 0; return a; }\n  l d = extended_euclid(b, a % b, x, y);\n  l t = y;\n  y = x - (a / b) * y;\n  x = t;\n  return d;\n}\n\n// return b: a * b = 1 (mod n)\nl inverse_mod(l a, l n) {\n  l x, y;\n  l d = extended_euclid(a, n, x, y);\n  if (d != 1) return 0;\n  return cong(x, n);\n}\n\n// single combintions k from n\nl nCr(l n, l k, l mod) {\n  l a = 1;\n  for (l i = n; i > n - k; i--) a = mult_mod(a, i, mod);\n  l b = 1;\n  F(i, 1, k + 1) b = mult_mod(b, i, mod);\n  b = inverse_mod(b, mod);\n  return mult_mod(a, b, mod);\n}\n\n// precompute all combinations up to (n n)\nvvl combinations(l n, l mod) {\n  vvl c(n + 1, vl(n + 1));\n  F(i, 0, n + 1) {\n    c[i][0] = 1;\n    F(j, 1, i + 1) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n  }\n  return c;\n}\n\nl fast(l n) {\n  vl f(n), g(n);\n  f[0] = 1;\n  F(i, 1, n) f[i] = (i * f[i - 1]) % MOD;\n  F(i, 0, n) g[i] = inverse_mod(f[i], MOD);\n  l z = 0;\n  l s = 0;\n  F(k, (n + 1) / 2, n) {\n    l t = cong(f[k] * f[k - 1], MOD);\n    t = cong(t * g[2 * k - n], MOD);\n    t = cong(t - s, MOD);\n    z = cong(z + k * t, MOD);\n    s = cong(s + t, MOD);\n  }\n  return z;\n}\n\nvoid solve(istream& cin, ostream& cout) {\n  // F(i, 2, 8) L(i, brute(i), fast(i));\n  l n; cin >> n;\n  cout << fast(n) << lf;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int L = 1e6 + 10;\nconst int M = 1e9 + 7;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint fact[L];\nint rfact[L];\n\nint ncr(int n, int k) {\n    if (k < 0 || k > n)\n        return 0;\n    return (ll) fact[n] * rfact[k] % M * rfact[n - k] % M;\n}\n\nconst int N = 15;\n\nint f[N][N];\n\nvoid smain() {\n\n    fact[0] = 1;\n    for (int i = 1; i < L; ++i) {\n        fact[i] = (ll) fact[i - 1] * i % M;\n    }\n    rfact[L - 1] = pw(fact[L - 1]);\n    for (int i = L - 2; i >= 0; --i) {\n        rfact[i] = (ll) rfact[i + 1] * (i + 1) % M;\n    }\n\n    f[1][1] = 1;\n    for (int i = 2; i < N; ++i) {\n        for (int j = 2; j < N; ++j) {\n            f[i][j] = f[i - 1][j - 1] + f[i - 2][j - 1];\n            cout << f[i][j] - 1 * ncr(j - 1, i - j) << ' ';\n        }\n        cout << '\\n';\n    }\n\n\n\n\n    int n;\n    cin >> n;\n    n--;\n    vi g(n + 1);\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        g[i] = ncr(i - 1, n - i);\n//        g[i] = f[n][i];\n        g[i] = (ll) g[i] * fact[i] % M * fact[n - i] % M;\n        for (int j = 1; j < i; ++j) {\n            g[i] = (g[i] - g[j] + M) % M;\n        }\n//        cerr << \"g[\" << i << \"] = \" << g[i] << endl;\n        int cur = (ll) g[i] * i % M;\n        ans = (ans + cur) % M;\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing Pl = pair<ll, ll>;\nusing Tl = tuple<ll, ll, ll>;\n\nconst ll INF = 1e15;\nconst ld eps = 1e-6;\nconst ll MOD = 1e9+7;\n\n\nll gcd (ll a, ll b){\n  if(a%b==0)\n    return b;\n  else\n    return gcd(b,a%b);\n}\n\nll extgcd(ll a, ll b){\n  if(b%a==0)\n    return 1;\n  else{\n    return (1-b*extgcd(b%a, a))/a;\n  }\n}\n\nvector<ll> fact;\nvector<ll> factinv;\n\nll comb(ll n, ll r){\n  return fact[n] * factinv[n-r] % MOD * factinv[r] % MOD;\n}\n\n\nint main(){\n  ll N;\n  cin >> N;\n  if(N == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  fact.assign(N + 2, 1);\n  factinv.assign(N+2, 1);\n  for(ll i=1;i<fact.size();i++){\n    fact[i] = fact[i - 1] * i % MOD;\n    factinv[i] = (extgcd(fact[i], MOD) + MOD) % MOD;\n    assert(factinv[i] >= 0);\n    assert(factinv[i] * fact[i] % MOD == 1);\n  }\n  ll ans = 0;\n  /*\n    xo ooo ox\n    xo o ox\n    N - 3\n    1以上でunuse個にN-2を振り分ける -> N-2-unuseを0以上unuse種で振り分ける-> (N-2-unuse + unuse) C unuse\n    unuse個に振り分ける\n   */\n  ll before = 0;\n  for(ll use = (N + 1) / 2; use <= N  - 1; use++){\n    ll unuse = N - 1 - use;\n    ll now = (fact[use] * comb(N - 3 - unuse + 1, unuse) % MOD - before + MOD) % MOD;\n    ans = (ans + use * now % MOD * fact[unuse] % MOD) % MOD;\n    //cout << \"before\" << before << \" fact\" << fact[use] << \" now\" << now <<  \" comb\" << comb(N - 3 - unuse + 1, unuse) << \" use\" << use << \" ans\" << ans << endl;\n    before = (now * unuse + before * unuse) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nint n;\n\n\nconst int mod = 1e9 + 7;\nconst int maxn = 1e6 + 5;\n\nint fac[maxn], inv[maxn];\n\nint qpow(int a, int n){\n    int ret = 1;\n    while(n > 0){\n        if(n & 1){\n            ret = 1LL * ret * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nvoid pre_comb(){\n    fac[0] = 1;\n    for(int i = 1;i < maxn;i++){\n        fac[i] = 1LL * fac[i - 1] * i % mod;\n    }\n    inv[maxn - 1] = qpow(fac[maxn - 1], mod - 2);\n    for(int i = maxn - 2;i >= 0;i--){\n        inv[i] = 1LL * inv[i + 1] * (i + 1) % mod;\n    }\n}\n\nint comb(int n, int m){\n    if(m > n or m < 0) return 0;\n    return 1LL * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint dp[maxn];\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    pre_comb();\n    cin >> n; \n    if(n == 2){\n        cout << 1 << endl;\n    }else if(n == 3){\n        cout << 4 << endl;\n    }else{\n        for(int i = 0;i <= n - 1;i++){\n            dp[i] = 1LL * comb(i - 1, n - 1 - i) * fac[i] % mod * fac[n - 1 - i] % mod;\n        } \n        int ans = 0;\n        for(int i = n - 1;i >= 1;i--){\n            dp[i] = (dp[i] - dp[i - 1] + mod) % mod;\n            ans = (ans + 1LL * i * dp[i]) % mod;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// <=k を考えて差分。long long にしないと死ぬ。\n#include <cstdio>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n\n// a+b=k-1\n// a+2b=n-2\n// b = n-k-1\n// a = 2k-n\n// (k-1)!/(2k-n)!(n-k-1)!\n\nusing ll = long long;\nconstexpr int MAX_N = 1000001;\nconstexpr ll mod = 1000000007;\n\nint N;\nll fact[MAX_N], inv[MAX_N];\nll f[MAX_N];\n\nll powMod( ll x, ll y )\n{\n    ll ret = 1;\n\n    while( y > 0 )\n    {\n        if( y & 1 )\n            ret = (ret * x) % mod;\n\n        y >>= 1;\n        x = (x*x)%mod;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    scanf( \"%d\", &N );\n\n    fact[0] = 1;\n    rep( i, N )\n        fact[i+1] = fact[i]*(i+1)%mod;\n\n    rep( i, N+1 )\n        inv[i] = powMod( fact[i], mod-2 );\n\n    // (k-1)!/(2k-n)!(n-k-1)!\n    repi( k, 1, N )\n        f[k] = fact[k-1]*inv[2*k-N]%mod*inv[N-k-1]%mod*fact[k]%mod*fact[N-k-1]%mod;\n\n    ll ans = 0;\n    repi( k, 1, N )\n        ans = (ans + (f[k]-f[k-1])*k%mod) % mod;\n\n    printf( \"%lld\\n\", ans );\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n    vector<long long> inv(1000001);\n\tvector<long long> fact(1000001);\n\tvector<long long> factInv(1000001);\n\tfor(int i=0;i<2;i++) inv[i] = fact[i] = factInv[i] = 1;\n\tfor(int i=2;i<inv.size();i++){\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tfactInv[i] = factInv[i-1] * inv[i] % MOD;\n\t}\n\tauto comb = [&](int n, int r){\n\t\tif(n < r) return 0LL;\n\t\treturn fact[n] * factInv[n-r] % MOD * factInv[r] % MOD;\n\t};\n    int N;\n    while(cin >> N){\n        long long res = 0;\n        long long sum = 0;\n        --N;\n        for(int i=1;i<=N;i++){\n            long long c = comb(i-1, N-i);\n            long long cur = c * fact[i] % MOD * fact[N-i] % MOD;\n            cur = (cur + MOD - sum) % MOD;\n            sum = (sum + cur) % MOD;\n            res = (res + i * cur) % MOD;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 1000005\n#define ll long long\n#define upperlimit 1000100\n#define INF 1e18\n#define eps 1e-8\n#define endl '\\n'\n#define pcc pair<char,char>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)\n#define MOD 1000000007LL\n#define slld(t) scanf(\"%lld\",&t)\n#define sd(t) scanf(\"%d\",&t)\n#define pd(t) printf(\"%d\\n\",t)\n#define plld(t) printf(\"%lld\\n\",t)\n#define mp(a,b) make_pair(a,b)\n#define FF first\n#define SS second\n#define pb(x) push_back(x)\n#define vi vector<int>\n#define vll vector<ll>\n#define clr(a) memset(a,0,sizeof(a))\n#define debug(a) printf(\"check%d\\n\",a)\n#define csl ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\n \nll gcd(ll n1,ll n2){\n\tif(n2==0)\n\t\treturn n1;\n\tif(n1%n2==0)return n2;\n\treturn gcd(n2,n1%n2);\n}\nll powmod(ll base,ll exponent)\n{\n\tif(exponent<0) exponent+=MOD-1;\n\tll ans=1;\n\twhile(exponent){\n\t\tif(exponent&1)ans=(ans*base)%MOD;\n\t\tbase=(base*base)%MOD;\n\t\texponent/=2;\n\t}\n\treturn ans;\n}\nll fact[MAX],ifact[MAX];\nint main()\n{\n\tfact[0]=1;\n\tifact[0]=1;\n\tfor(int i=1;i<MAX;i++)\n\t{\n\t\tfact[i]=(i*1LL*fact[i-1])%MOD;\n\t\tifact[i]=powmod(fact[i],-1);\n\t}\n\tll ans=0;\n\tint n;\n\tcin>>n;\n\tll prev=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i-1>=n-i-1)\n\t\t{\n\t\t\tll temp=fact[i-1]*ifact[n-i-1];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=ifact[i-1-n+i+1];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=fact[i];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=fact[n-i-1];\n\t\t\ttemp%=MOD;\n\t\t\tans+=MOD-prev;\n\t\t\tprev=temp;\n\t\t\t//cout<<i<<\" \"<<temp<<endl;\n\t\t\tans%=MOD;\n\t\t}\n\t\tans+=fact[n-1];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst ll MOD=1000000007;\nconst ll MAX=2000002;\nll n,fin,fac[MAX],use[MAX],cum[MAX],sum;\nll power(ll x,ll y){\n    if(y==0) return 1;\n    ll t=power(x,y/2);\n    if(y%2) return t*t%MOD*x%MOD;\n    return t*t%MOD;\n}\nll comb(ll x,ll y){\n    return fac[x]*power(fac[y],MOD-2)%MOD*power(fac[x-y],MOD-2)%MOD;\n}\nint main(){\n    scanf(\"%lld\",&n);\n    fac[0]=1;\n    for(ll i=1;i<=n;i++) fac[i]=fac[i-1]*i%MOD;\n    for(ll i=(n+1)/2;i<=n-1;i++) use[i]=comb(i-1,2*i-n)*fac[i]%MOD*fac[n-1-i]%MOD;\n    for(ll i=(n+1)/2;i<=n-1;i++) cum[i]=use[i]-use[i-1],sum+=cum[i]*i,sum%=MOD;\n    printf(\"%lld\\n\",sum);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pd(x) cerr<<\"//\"<<(x)<<endl;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll mod = 1000000007;\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,g,h,i,j,k,ok,ng,l,q;\nll x[500005],y[500005],z[500005],w[500005];\nll banb[5005][5005],banw[5005][5005];\nchar s[500005],t[500005];\nbool flag,dame;\n\nll  fact[1200000];\nll rfact[1200000];\n\nll mpow(ll x, ll y, ll m) {\n    x %= m;\n    ll result = 1;\n    while (y > 0) {\n        if (y & 1) result = (result * x) % m;\n        x = (x * x) % m;\n        y >>= 1;\n    }\n    return result;\n}\nunsigned long long int minverse(unsigned long long int x, unsigned long long int m) {\n    return mpow(x, m-2, m);\n}\nvoid c3_init(ll m){\n    fact[0]  = rfact[0] = 1;\n    for(ll xxxx=1; xxxx<400000; xxxx++){\n        fact[xxxx] = (fact[xxxx-1]*xxxx)%m;\n        rfact[xxxx] = minverse(fact[xxxx],m);\n    }\n}\nll c3(ll n, ll abc, ll m){\n    return (((fact[n] * rfact[abc])%m) * rfact[n-abc])%m;\n}\n \nint main(){\n    cin >> n;\n\tc3_init(mod);\n\tfor(i=1;i<=n-1;i++){\n\t\t//length is i\n\t\tif(1 + (i - 1) * 2 < n - 1)continue;\n\t\t//pe(i);\n\t\tll one,two;\n\t\t\n\t\t\n\t\ttwo = n - 1 - i;\n\t\tone = i - 1 - two;\n\t\tans += ((((((c3(one+two,one,mod) * fact[i])%mod) * fact[n-1-i]) % mod + (mod - sum))%mod) * i)%mod ;\n\t\t//ans += ((c3(one+two,one,mod) * (fact[i] * fact[n-1-i]) % mod + mod - sum)%mod * i)%mod;\n\t\tans %= mod;\n\t\t//p(ans);\n\t\t\n\t\tsum += (((((c3(one+two,one,mod) * fact[i])%mod) * fact[n-1-i]) % mod + (mod - sum))%mod);\n\t\t//sum += (c3(one+two,one,mod) * (fact[i] * fact[n-1-i])%mod)%mod;\n\t\tsum %= mod;\n\t\tassert(ans >= 0);\n\t\tassert(sum >= 0);\n\t}\n\tp(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nint f[1000001];\nint inv[10000001];\n\nint bp (int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint C (int n, int k) {\n\tif (k > n) return 0;\n\treturn (f[n] * ((inv[k] * inv[n - k]) % mod)) % mod;\n} \n\n main () {\n \tint n;\n\tcin >> n;\n\tf[0] = 1;\n\tinv[0] = 1;\n\tfor (int i = 1;i <= n;i ++) {\n\t\tf[i] = (f[i - 1] * i) % mod;\n\t\tinv[i] = bp (f[i], mod - 2);\n\t} \n\tint ans = 0;\n\tint last = 0 ;\n\tfor (int i = (n + 1) / 2;i < n;i ++) {\n\t\tint k = i;\n\t\tint cur = C (k - 1, n - k - 1);\n\t//\tcout << cur << ' ' ;\n\t\tcur = (cur * f[k]) % mod;\n\t\tcur = (cur * f[n - k - 1]) % mod;\n\t\tint cur1 = cur;\n\t\tcur = (cur - last + mod) % mod;\n\t//\tcout << cur << ' ' ;\n\t\tlast = cur1;\n\t\tans = (ans + ((cur * k) % mod)) % mod;\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=1e6+5;\nconst int MOD=1e9+7;\ntypedef long long LL; \ntypedef long double LD;\n\nLL fac[MAX];\nLL ifac[MAX];\nLL val[MAX];\n\nint add(int a, int b, int c) {\n    int res = a + b;\n    return (res >= c ? res - c : res);\n}\n\nint mod_neg(int a, int b, int c) {\n    int res; if(abs(a-b) < c) res = a - b;\n    else res = (a-b) % c;\n    return (res < 0 ? res + c : res);\n}\n\nint mul(int a, int b, int c) {\n    LL res = (LL)a * b;\n    return (res >= c ? res % c : res);\n}\n\ntemplate <typename T>T power(T e, T n, T m) {\n    T x = 1, p = e;\n    while(n) {\n        if(n & 1) x = mul(x, p, m);\n        p = mul(p, p, m);\n        n >>= 1;\n    }\n    return x;\n}\n\ntemplate<typename T> T extended_euclid(T a, T b, T &x, T &y) {\n    T xx = 0, yy = 1; y = 0; x = 1;\n    while(b) {\n        T q = a / b, t = b;\n        b = a % b; a = t;\n        t = xx; xx = x - q * xx;\n        x = t; t = yy;\n        yy = y - q * yy; y = t;\n    }\n    return a;\n}\n\ntemplate<typename T> T mod_inverse(T a, T n) {\n    T x, y, z = 0; \n    T d = extended_euclid(a, n, x, y);\n    return (d > 1 ? -1 : mod_neg(x, z, n));\n}\n\nLL ncr(int n,int r)\n{\n    if(n<0||r<0||r>n)\n    {\n        return 0ll;\n    }\n    return ((((fac[n]*ifac[r])%MOD)*ifac[n-r])%MOD);\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    fac[0]=1;\n    ifac[0]=1;\n    for(int i=1;i<=n;i++)\n    {\n        fac[i]=(fac[i-1]*i)%MOD;\n        ifac[i]=mod_inverse(fac[i],1ll*MOD);\n    }\n    LL ans=0;\n    for(int i=(n+1)/2;i<n;i++)\n    {\n        LL cur=(ncr(i-1,n-i-1)*fac[i])%MOD;\n        cur*=fac[n-i-1];\n        cur%=MOD;\n        val[i]=cur;\n        cur-=val[i-1];\n        cur+=MOD;\n        cur%=MOD;\n        cur*=i;\n        cur%=MOD;\n       // printf(\"%lld\\n\",cur);\n        ans+=cur;\n        ans%=MOD;\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 1000010\nll inv[N],fact[N],invfact[N];\nvoid Pre(){\n    inv[1]=fact[0]=invfact[0]=1;\n    for(int i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfact[i]=fact[i-1]*i%mod;\n\tinvfact[i]=invfact[i-1]*inv[i]%mod;\n    }\n}\nll C(ll n,ll k){\n    if(n<0||k<0||n<k)return 0;\n    return fact[n]*invfact[n-k]%mod*invfact[k]%mod;\n}\nint main(){\n    Pre();\n    ll n;cin>>n;n--;\n    ll ans=0,bef=0;\n    for(ll k=1;k<=n;k++){\n\tll cur=C(k-1,n-k)*fact[k]%mod*fact[n-k]%mod;\n\tans+=(cur-bef)*k;ans%=mod,bef=cur;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nconstexpr int MN = 1000001;\nconstexpr ll MOD = 1e9+7;\n\nll fact[MN] = { 1 }, ifact[MN] = { 1 };\n\ninline ll pw(ll base, ll exp) {\n\tll res = 1;\n\twhile (exp) {\n\t\tif (exp & 1) (res *= base) %= MOD;\n\t\texp >>= 1, (base *= base) %= MOD;\n\t}\n\treturn res;\n}\n\ninline ll inv(ll x) { return pw(x, MOD - 2); }\n\ninline ll nCr(int n, int k) { return fact[n]*ifact[k]%MOD*ifact[n-k]%MOD; }\n\nint main() {\n    if (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    int N; cin >> N;\n\n    for (int i = 0; i < N; ++i) fact[i+1] = (i+1ll)*fact[i]%MOD, ifact[i+1] = inv(fact[i+1]);\n    \n    ll sum = 0, ans = 0;\n    for (int i = N/2; i < N; ++i) {\n        ll tmp = nCr(i-1, N-i-1)*fact[i]%MOD*fact[N-i-1]%MOD;\n        (ans += i*(tmp-sum+MOD)) %= MOD;\n        sum = tmp;\n    }\n    cout << ans;\n\n    /*for (int N = 2; N <= 10; ++N) {\n        //int N = 7;\n        vector<int> P(N-1);\n        iota(begin(P), end(P), 0);\n        vector<int> ans(N-1);\n        do {\n            vector<bool> A(N, 0);\n            ll cnt = 0;\n            for (int i = 0; i < N-1; ++i) {\n                A[P[i]] = A[P[i]+1] = 1;\n                if (count(begin(A), end(A), 1) == N) {\n                    ++ans[i];\n                    if (i == 3) {\n                        for (int x : P) cout << x << ' ';\n                        cout << '\\n';\n                    }\n                    break;\n                }\n            }\n        } while (next_permutation(begin(P), end(P)));\n        for (int x : ans) cout << setw(6) << x << ' ';\n        cout << '\\n';\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n[ Found a recurrence relation ]\n- order 3\n- degree 3\n- verified up to a(999) (number of non-trivial terms: 982)\n{\n  {1, 0, 0, 0},\n  {333333332, 333333334, 0, 0},\n  {333333338, 666666673, 333333336, 0},\n  {666666682, 666666682, 333333339, 333333336}\n}\n*/\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nV<mint> fact,ifact;\nmint Choose(int x,int y){\n\tif(y<0 || x-y<0) return 0;\n\treturn fact[x] * ifact[y] * ifact[x-y];\n}\nvoid InitFact(){\n\tconst int N = 1000100;\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1]*i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nmint solve(int N){\n\tif(N==2){\n\t\treturn 1;\n\t}\n\tV<mint> p(N);\n\tfor(int t=2;t<=N-1;t++){\n\t\tp[t] = Choose(t-1,N-(t+1)) / Choose(N-1,t);\n\t}\n\tmint res = 0;\n\trep1(t,N-1) res += (p[t]-p[t-1]) * t;\n\tres *= fact[N-1];\n\treturn res;\n}\nint main(){\n\tInitFact();\n\tint N;\n\tcin>>N;\n\tcout<<solve(N)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// <=k を考えて差分。long long にしないと死ぬ。\n#include <cstdio>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n\n// a+b=k-1\n// a+2b=n-2\n// b = n-k-1\n// a = 2k-n\n// (k-1)!/(2k-n)!(n-k-1)!\n\nusing ll = long long;\nconstexpr int MAX_N = 1000001;\nconstexpr ll mod = 1000000007;\n\nint N;\nll fact[MAX_N], inv[MAX_N];\nll f[MAX_N];\n\nll powMod( ll x, ll y )\n{\n    ll ret = 1;\n\n    while( y > 0 )\n    {\n        if( y & 1 )\n            ret = (ret * x) % mod;\n\n        y >>= 1;\n        x = (x*x)%mod;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    scanf( \"%d\", &N );\n\n    fact[0] = 1;\n    rep( i, N )\n        fact[i+1] = fact[i]*(i+1)%mod;\n\n    rep( i, N+1 )\n        inv[i] = powMod( fact[i], mod-2 );\n\n    // (k-1)!/(2k-n)!(n-k-1)!\n    repi( k, 1, N )\n        f[k] = fact[k-1]*inv[2*k-N]%mod*inv[N-k-1]%mod*fact[k]%mod*fact[N-k-1]%mod;\n\n    ll ans = 0;\n    repi( k, 1, N )\n        ans = (ans + (f[k]-f[k-1])*k%mod) % mod;\n\n    while( ans < 0 )\n        ans = (ans+mod)%mod;\n\n    printf( \"%lld\\n\", ans );\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n#define MOD 1000000007\n\nlong sum(long a, long b) { return (a + b) % MOD; }\n\nlong mult(long a, long b) { return (a * b) % MOD; }\n\nlong pow(long a, long b) {\n    long res = 1;\n    while (b > 0) {\n        if (b & 1) {\n            res = mult(res, a);\n        }\n        a = mult(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nlong inv(long a) {\n    return pow(a, MOD - 2);\n}\n\nvector<long> fact_precalc(1, 1);\nvector<long> inv_fact_precalc(1, 1);\n\nvoid ensure_fact(int n) {\n    while (n >= fact_precalc.size()) {\n        fact_precalc.push_back(mult(fact_precalc.back(), fact_precalc.size()));\n        inv_fact_precalc.push_back(inv(fact_precalc.back()));\n    }\n}\n\nlong fact(int n) {\n    ensure_fact(n);\n    return fact_precalc[n];\n}\n\nlong inv_fact(int n) {\n    ensure_fact(n);\n    return inv_fact_precalc[n];\n}\n\nlong calc_c(int n, int k) {\n    long res = fact(n);\n    res = mult(res, inv_fact(k));\n    res = mult(res, inv_fact(n - k));\n    return res;\n}\n\n// @author: pashka\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    if (n == 2) {\n        cout << 1;\n        return 0;\n    }\n    long res = 0;\n    for (int i = 2; i < n; i++) {\n        {\n            int s = n - 2 - 3;\n            int k = i - 3;\n            if (k >= 0 && s >= k && s - k <= k) {\n                long q = i;\n                q = mult(q, calc_c(k, s - k));\n                q = mult(q, fact(i - 1));\n                q = mult(q, 2);\n                q = mult(q, fact(n - 1 - i));\n                q = mult(q, i - 2);\n//                cout << i << \" 1 \" << q << \"\\n\";\n                res = sum(res, q);\n            }\n        }\n        {\n            int s = n - 2 - 4;\n            int k = i - 3;\n            if (k >= 0 && s >= k && s - k <= k) {\n                long q = i;\n                q = mult(q, calc_c(k, s - k));\n                q = mult(q, fact(i - 1));\n                q = mult(q, fact(n - 1 - i));\n                q = mult(q, i - 2);\n//                cout << i << \" 2 \" << q << \"\\n\";\n                res = sum(res, q);\n            }\n        }\n        {\n            int s = n - 2;\n            int k = i - 1;\n            if (k >= 0 && s >= k && s - k <= k) {\n                long q = i;\n                q = mult(q, calc_c(k, s - k));\n                q = mult(q, fact(i - 1));\n                q = mult(q, fact(n - 1 - i));\n                q = mult(q, 2);\n//                cout << i << \" 3 \" << q << \"\\n\";\n                res = sum(res, q);\n            }\n        }\n    }\n\n    cout << res << \"\\n\";\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n    static const auto MOD = _MOD;\n    template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n    int x;\n    constexpr ModInt() : x() {}\n    template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n        x = _x % MOD;\n        if (x < 0) x += MOD;\n    }\n    ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n    ModInt& operator+=(ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (long long)x * rhs.x % MOD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        // should work for non-prime MOD if gcd(x, MOD) = 1\n        int a = x, b = MOD, u = 1, v = 0;\n        while (b != 0) {\n            int t = a / b;\n            a -= t * b;\n            u -= t * v;\n            swap(a, b);\n            swap(u, v);\n        }\n        return u;\n    }\n    template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n        ModInt r = 1, p = *this;\n        while (e) {\n            if (e & 1) r *= p;\n            p *= p;\n            e >>= 1;\n        }\n        return r;\n    }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    bool operator<(ModInt rhs) const { return x < rhs.x; }\n    bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n    bool operator>(ModInt rhs) const { return x > rhs.x; }\n    bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n    friend string to_string(ModInt i) { return to_string(i.x); }\n    friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nconst int MOD=1e9+7;\nusing mint=ModInt<MOD>;\n\nconst int N=1e6+10;\nmint inv[N],fac[N],ifac[N];\nvoid predo() {\n    inv[1]=1;\n    REP1(i,2,N-1) inv[i]=inv[MOD%i]*(MOD-MOD/i);\n    fac[0]=1;\n    REP1(i,1,N-1) fac[i]=fac[i-1]*i;\n    ifac[0]=1;\n    REP1(i,1,N-1) ifac[i]=ifac[i-1]*inv[i];\n}\n\nmint C( int n, int m ) {\n    return fac[n]*ifac[m]*ifac[n-m];\n}\n\nvoid main() {\n    predo();\n    int n;\n    R(n);\n    if ( n==2 ) {\n        W(1);\n        return;\n    }\n    mint ans=0,pre=0;\n    REP1(i,2,n-1) {\n        if ( i-1<n-i-1 ) continue;\n        mint now=C(i-1,n-i-1)*fac[i]*fac[n-1-i];\n        ans+=(now-pre)*i;\n        pre=now;\n    }\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 5;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nint sbinom(int cnt, int sum) {\n\tassert(cnt != 0);\n\tif (sum < 0) return 0;\n\telse return binom(sum + cnt - 1, cnt - 1);\n}\nint main() {\n\tint n, ans = 0;\n\tread(n), init(n);\n\tupdate(ans, fac[n - 1]);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint cnt = binom(n - 1, i), lft = n - 1 - i;\n\t\tupdate(cnt, P - sbinom(lft + 1, n - 1 - 2 * lft));\n\t\tif (lft) update(cnt, sbinom(lft, n - 1 - 2 * lft));\n\t\tupdate(ans, 1ll * cnt * fac[i] % P * fac[n - 1 - i] % P);\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nclass inverse {\n    public:\n    inverse(int n, int mod);\n    ~inverse();\n    long long get_inv(int x);\n    long long get_fact(int x);\n    long long get_invfact(int x);\n    long long get_comb(int x, int y);\n    \n    private:\n    int mod;\n    long long* inv;\n    long long* fact;\n    long long* invfact;\n};\n\ninverse::inverse(int n, int mod) : mod(mod) {\n    inv = (long long *)malloc(sizeof(long long) * (n + 1));\n    fact = (long long *)malloc(sizeof(long long) * (n + 1));\n    invfact = (long long *)malloc(sizeof(long long) * (n + 1));\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n    fact[0] = invfact[0] = 1;\n    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    for (int i = 1; i <= n; i++) invfact[i] = invfact[i - 1] * inv[i] % mod;\n}\n\ninverse::~inverse() {\n    free(inv);\n    free(fact);\n    free(invfact);\n}\n\nlong long inverse::get_inv(int x) {\n    return inv[x];\n}\n\nlong long inverse::get_fact(int x) {\n    return fact[x];\n}\n\nlong long inverse::get_invfact(int x) {\n    return invfact[x];\n}\n\nlong long inverse::get_comb(int x, int y) {\n    return fact[x] * invfact[y] % mod * invfact[x - y] % mod;\n}\n\nint main() {\n    int n, m = 1000000007, i, j;\n    long long ans;\n    \n    scanf(\"%d\", &n);\n    \n    inverse inv(n, m);\n    \n    ans = inv.get_fact(n - 1) * (n - 1) % m;\n    \n    for (i = 1; i < n / 2; i++) {\n        int x = n - 1 - i;\n        long long p = inv.get_comb(x - 1, i) * inv.get_fact(x) % m * inv.get_fact(i) % m;\n        \n        ans -= p;\n        if (ans < 0) ans += m;\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int DIV=1000000000+7;\nlong myPow(long x, long n, long m){\n  if(n == 0)\n    return 1;\n  if(n % 2 == 0)\n    return myPow(x * x % m, n / 2, m);\n  else\n    return x * myPow(x, n - 1, m) % m;\n}\n\nlong myFact(long i,long j){//i*i+1*....*i+j-1\n    if(j==0)\n        return 1;\n    else\n        return myFact(i,j-1)*(i+j-1)%DIV;\n}\n\n\nint main(){\n    long N;\n    cin >> N;\n    \n    long m;\n    if(N%2==0)\n        m=N/2;\n        \n    else\n        m=(N-1)/2;\n    long A[m];\n    long fact[N];\n    long invfact[N];\n//    long kaijo = fact(1,N-m-1);\n//    A[0] = fact(1,N-1);\n//    A[1] = A[0];\n//    cout << A[1]<<endl;\n//    A[1] /=  (N-1)*(N-2);\n//    cout << A[1]<<endl;\n//    A[1] *= (N-2)*(N-3);\n//    cout << A[1]<<endl;\n//    B[1] = fact(1,N-2) *fact(N-3,1);\n//    cout << A[1]<<endl;\n//    cout <<B[1]<<endl;\n//    A[m-1] = kaijo*kaijo*(N-m);\n    fact[0]=1;\n    for(int i=0;i<N-1;i++){\n        fact[i+1]=fact[i]*(i+1)%DIV;\n    }\n    invfact[N-1] = myPow(fact[N-1],DIV-2,DIV);\n    for(int i=N-1;i>0;i--){\n        invfact[i-1]=invfact[i] * i % DIV;\n    //    cout << invfact[i-1]*fact[i-1]%DIV <<endl;\n    }\n    for(long i=0;i<m;i++){\n        A[i] = (fact[N-i-1]*fact[N-i-2]%DIV) * invfact[N-i-i-2] % DIV;\n//        cout<<\"myFact:\"<<myFact(1,N-i-1)*myFact(N-i-i-1,i)%DIV <<\"Ai:\"<<A[i]<<endl;\n    }\n    long ret;\n//    for(int i=0;i<m;i++){\n//        A[i] %= DIV;\n//        if (0<i&&i<10) cout<<(B[i]-A[i])%DIV<<endl;\n//    }\n    ret = A[0] * (N-1) % DIV;\n    for(int i=1;i<m;i++){\n        ret += DIV;\n        ret -= A[i];\n//        cout<<\"i:\"<<i<<endl;\n    }\n    ret %= DIV;\n    cout << ret << endl;\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define NUM 1000000007\n\ntypedef long long ll;\n\nusing namespace std;\n\nvector<ll> memo;\n\nll factorial(int n) {\n    if (memo.at(n)) return memo.at(n);\n    ll ans = 1;\n    for (int i = 1; i <= n; i++) ans *= i;\n    memo.at(n) = ans;\n    return ans;\n}\n\nll combination(int n, int r) {\n    return factorial(n) / (factorial(r) * factorial(n - r));\n}\n\nint main() {\n    int n;\n    cin >> n;\n    memo.resize(n);\n    fill(memo.begin(), memo.end(), 0);\n    int l = n / 2;\n    int r = (n - 1) / 2;\n    int initr = r;\n    ll prev = 0;\n    ll now = 0;\n    ll ans = 0;\n    for (int i = l; i < n; i++, l++, r--) {\n        now = factorial(l) * factorial(r) * combination(initr, r);\n        ans += l * (now - prev);\n        ans %= NUM;\n        prev = now;\n    }\n    cout << ans % NUM << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int maxn = 2000009;\nconst int mod = 1e9+7;\n\nll f[maxn],sum[maxn],fib[maxn],fac[maxn],nfac[maxn],inv[maxn];\nint n;\nll ans;\n\nll C(int x,int y)\n{\n\tif(x<y) return 0;\n\treturn fac[x]*nfac[y]%mod*nfac[x-y]%mod;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfib[0]=1;fib[1]=2;fac[0]=nfac[0]=inv[1]=1;\n\tfor(int i=2;i<=n*2;i++) fib[i]=(fib[i-1]+fib[i-2])%mod;\n\tfor(int i=1;i<=n*2;i++) fac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<=n*2;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=n*2;i++) nfac[i]=nfac[i-1]*inv[i]%mod;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint zero=n-1-i,one=i;\n\t\tll tmp=C(n-3+1-zero,zero)*fac[zero]%mod*fac[one]%mod;\n\t\ttmp=(tmp-sum[i-1]+mod)%mod;\n\t\tans=(ans+tmp*i)%mod;\n\t\tsum[i]=(sum[i-1]+tmp)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n\n\nusing namespace std;\ntypedef int status;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ull base = 343;\nconst int INF = int(1e9);\nconst ll INF1 = ll(1e18);\nconst int MAX = 1000002;\nconst int MOD = 1000000007;\n\nll A[MAX];\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    A[1] = A[0] = 1; for (int i = 2; i < MAX; ++i) A[i] = A[i - 1] * i % MOD;\n    int now = n - 1, p =  n - 1;\n    ll ans = 0;\n    while (1) {\n        if (now == 0) break;\n        if (now >= 2) {\n            ans += A[n - 2] * 2 * p;\n            ans %= MOD;\n            now -= 2;\n        }\n        else {\n            ans += A[n - 2] * p;\n            ans %= MOD;\n            now -= 1;\n        }\n        --p;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 2000005, MOD = 1000000007;\nint f[N], finv[N], act[N];\n\ninline void add(int &a, int b) {\n    a += b;\n    if (a >= MOD) {\n        a -= MOD;\n    }\n}\n\ninline void sub(int &a, int b) {\n    a -= b;\n    if (a < 0) {\n        a += MOD;\n    }\n}\n\ninline int mul(int a, int b) {\n    return (ll)a * b % MOD;\n}\n\nvoid precalc() {\n    f[0] = 1;\n    for (int i = 1; i < N; i++) {\n        f[i] = mul(f[i - 1], i);\n    }\n    finv[0] = finv[1] = 1;\n    for (int i = 2; i < N; i++) {\n        finv[i] = (MOD - mul(MOD / i, finv[MOD % i])) % MOD;\n    }\n    for (int i = 2; i < N; i++) {\n        finv[i] = mul(finv[i - 1], finv[i]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(cout.fixed);\n    cout.precision(20);\n    precalc();\n    int n;\n    cin >> n;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        act[k] = mul(mul(f[k - 1], f[k]), finv[2 * k - n]);\n    }\n    int res = 0;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        int realact = act[k];\n        sub(realact, act[k - 1]);\n        add(res, mul(k, realact));\n    }\n    cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nInt mod = 1000000007;\n\nInt fact[1123456];\n\nvoid init() {\n   fact[0] = 1;\n   for(Int i = 1; i < 1123456; ++i) {\n      fact[i] = fact[i-1] * i % mod;\n   }\n}\n\nInt pow(Int x, Int n) {\n   if( n == 0 ) return 1;\n   Int t = pow(x,n/2);\n   return n % 2 == 0 ? (t * t % mod) : (t * t % mod * x % mod);\n}\n\nInt div(Int x, Int y) {\n   return x * pow(y, mod-2) % mod;\n}\n\nInt nCr(Int n, Int r) {\n   if( r < 0 or n < r ) return 0;\n   return div(fact[n], fact[r] * fact[n-r] % mod);\n}\n\nint main() {\n   init();\n   Int n;\n   std::cin >> n;\n   Int res = 0;\n   std::vector<Int> xs(n);\n   for(Int k = 0; k < n; ++k) {\n      xs[k] = nCr(k-1, n-k-1) * fact[k] % mod * fact[n-1-k] % mod;\n   }\n   for(Int k = 0; k < n; ++k) {\n      Int diff = (xs[k] - xs[k-1] + mod) % mod;\n      Int t = diff * k % mod;\n      res = (res + t) % mod;\n   }\n   printf(\"%ld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define zeros(x) x^(x-1)&x\n#define pii pair<ll,ll>\n#define cd complex<double>\n#define dbg(x) cerr<<x<<endl;\n#define Nmax 1000005\n#define MOD 1000000007\nusing namespace std;\n\nll n;\n\ntemplate<typename T = long long>\nT _pow(T a, T b){\n    T ans = 1;\n    for (; b; b >>= 1){\n        if (b % 2) ans = ans * a % MOD;\n        a = a * a % MOD;\n    }\n    return ans;\n}\n\nlong long P[Nmax], inv[Nmax];\ntemplate<typename T = long long>\nT comb(T n, T m){\n    if (P[1] == 0) cerr << \"Apeleaza functia prec!\\n\";\n    if (m > n) return 0;\n    return P[n] * inv[m] % MOD * inv[n-m] % MOD;\n}\n\ntemplate<typename T = long long>\nvoid add(T &a, T b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n}\n\nvoid prec(int n = Nmax-1){\n    P[0] = inv[0] = 1;\n    for (int i=1;i<=n;i++){\n        P[i] = P[i-1] * i % MOD;\n        inv[i] = _pow(P[i], MOD - 2LL);\n    }\n}\n\nll ans[Nmax];\nint main()\n{\n    cin >> n;\n    prec();\n\n    for (int i=n-1;i>=1;i--){\n        ans[i] = 1LL * comb(i - 1LL, n - i - 1LL) * P[n-i-1] % MOD * P[i] % MOD;\n        if (i<n) add(ans[i+1], -ans[i]);\n    }\n\n    ll fin = 0;\n    for (int i=1;i<n;i++){\n        fin = (fin + 1LL * i * ans[i]) % MOD;\n    }\n\n    cout << fin << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10, mod = 1e9 + 7;\nint ans[N], fc[N], ifc[N], n, rtr;\nint power(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\tint rtr = power(a, b / 2);\n\tif (b % 2) \n\t\treturn 1ll * rtr * rtr % mod * a % mod;\n\treturn 1ll * rtr * rtr % mod;\n}\nvoid getFc() {\n\tfc[0] = ifc[0] = 1;\n\tfor (int i = 1; i < N - 5; i++) {\n\t\tfc[i] = 1ll * fc[i - 1] * i % mod;\n\t\tifc[i] = 1ll * ifc[i - 1] * power(i, mod - 2) % mod;\n\t}\n}\nint ch(int y, int x) {\n\treturn 1ll * fc[x] * ifc[y] % mod * ifc[x - y] % mod;\n}\nint main() {\n\tgetFc();\n\tcin >> n;\n\tfor (int i = 0; i <= (n - 2) / 2; i++)\n\t\tans[i] = 1ll * ch(i, n - 3 - i + 1) * fc[i] % mod * fc[n - 1 - i] % mod;\n\tfor (int i = 0; i <= (n - 2) / 2; i++) \n\t\trtr = (rtr + 1ll * (ans[i] - ans[i + 1] + mod) % mod * (n - 1 - i)) % mod; \n\tcout << rtr;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\nstruct S\n{\n    int x,y,z;\n\n    bool operator<(const S &a)const{\n              return x<a.x;\n    }\n};\n\nvector<int> v;\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nlong long l[1114000];\n\nlong long o[1114211];\nint j[2];\nint dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z;\n\nP u[555320];\n//stack<int> s;\n\n//set<int> s;\nqueue<int> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<int,int> p;\n//list<int> l;\n//string r1,r;\n//char r[1152][1111];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y>b.y;\n}\n\nlong long f(int a)\n{\n    if(a<0) return 0;\n    else\n    return o[a];\n}\n\nlong long g(int a,int b)\n{\n    if(b<a) return 0;\n    return f(b)*(l[a]*l[b-a]%mod)%mod;\n}\n\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b>>1);\n    x*=x,x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    o[0]=1;\n    for(int t=1;t<=a;t++)\n        o[t]=o[t-1]*t%mod;\n    l[0]=1;\n    for(int t=1;t<=a;t++)\n        l[t]=p(o[t],mod-2);\n    for(int t=2;t<a;t++)\n    {\n        y=x;\n        x=f(a-t-1)*f(t)%mod*g(a-t-1,t-1)%mod;\n        z+=(x-y)*t%mod;\n        z%=mod;\n        //printf(\"%lld %lld %lld\\n\",f(a-t-1),f(t),g(a-t-1,t-1));\n    }\n    printf(\"%lld\",z);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 1e9+7;\n\nlong long ways[1000005];\nlong long invFact[1000005];\nlong long fact[1000005];\nlong long inv[1000005];\nlong long prefixSum[1000005];\n\nlong long ncr(int n, int r){\n    return (fact[n]*invFact[n-r]%MOD)*invFact[r]%MOD;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    inv[1] = 1;\n    for(int i = 2; i <= N; i ++){\n        inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;\n    }\n\n    fact[0] = 1;\n    invFact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = i*fact[i-1]%MOD;\n        invFact[i] = inv[i]*invFact[i-1]%MOD;\n    }\n\n    int n = N-1;\n    for(int k = 1+n/2; k <= n; k ++){\n        int l = n-k; // remaining to put at the back\n        // (5 choose 3)*(6!)*(2!)\n\n        // 2*x + 1*(k-1-x) = n-1\n        // 2*x + k-1-x = n-1\n        // 2*x + k-x = n\n        // x + k = n\n        // x = n-k\n        prefixSum[k] = ((ncr(k-1, n-k)*fact[k]%MOD)*fact[l])%MOD; // have to exclude 1 and n, which is a must\n        //printf(\"k=%d n=%d prefixSum[%d]=%lld\\n\", k, n, k, prefixSum[k]);\n    }\n\n    long long ans = 0;\n    for(int i = n; i >= 1; i --){\n        ans += i*(prefixSum[i]-prefixSum[i-1]+MOD)%MOD;\n        //printf(\"%7d \", prefixSum[i]);\n    }\n\n    ans %= MOD;\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <set>\n#include <sys/timeb.h>\n#include <fstream>\n#include <random>\n#include <regex>\n#include <chrono>\n#include <bitset>\n#include <cassert>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\n#define DEBUG_\n\n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\n\n#ifdef DEBUG_\n#define DEB\n#else\n#define DEB if(false)\n#endif\n\n#ifdef DEBUG_\n#define dump(...) DUMPOUT<<\"  \"; \\\ndump_func(string(#__VA_ARGS__) + \":\", \"[\" + to_string(__LINE__) + \":\" + __FUNCTION__ + \"]\"); \\\nDUMPOUT<<\"    \"; \\\ndump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<Pll> vPll;\ntypedef vector<Pd>vPd;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef vector<vector<vector<int> > > vvvi;\ntypedef vector<vector<vector<ll> > > vvvll;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n\treturn \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n\tDUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& head, Tail&&... tail) {\n\tDUMPOUT << head;\n\tif (sizeof...(Tail) <= 1) {\n\t\tDUMPOUT << \" \";\n\t}\n\telse {\n\t\tDUMPOUT << \", \";\n\t}\n\tdump_func(std::move(tail)...);\n}\n\n// vector\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec) is >> x;\n\treturn is;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// vector\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& vec) {\n\tos << \"{\";\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tos << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// map\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, map<T, U>& map_var) {\n\tos << \"{\";\n\trepi(itr, map_var) {\n\t\tos << \"(\" << itr->first << \",\" << itr->second << \")\";\n\t\titr++;\n\t\tif (itr == map_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// set\ntemplate<typename T>\nostream& operator << (ostream& os, set<T>& set_var) {\n\tos << \"{\";\n\trepi(itr, set_var) {\n\t\tos << \"  \" << *itr << endl;\n\t\titr++;\n\t\tif (itr == set_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\nstring YN(bool y, int id = 0) { if (id)cout << id; return (y ? \"YES\" : \"NO\"); }\nstring yn(bool y, int id = 0) { if (id)cout << id; return (y ? \"Yes\" : \"No\"); }\nstring ON(bool y, int id = 0) { if (id)cout << id; return (y ? \"OK\" : \"NG\"); }\n\nint dir4[4][2] = { { 0,-1 },{ -1,0 },{ 1,0 },{ 0,1 } };\nint dir8[8][2] = { { -1,-1 },{ 0,-1 },{ 1,-1 },{ -1,0 },{ 1,0 },{ -1,1 },{ 0,1 },{ 1,1 } };\n\n// [a,b)\nint irand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_int_distribution<int> dist(a, b - 1);\n\treturn dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_real_distribution<double> dist(a, b);\n\treturn dist(Rand);\n}\nstruct Edge {\n\tint from, to, cost;\n};\nusing Graph = vec<vec<Edge>>;\n\n//======================================================\n\n// 1～nのmod逆元を計算する(modは素数), O(n)\nvoid ModInv(int n, vector<ll> &inv, int mod) {\n\tinv[0] = 0;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tinv[i] = mod - ((mod / i) * inv[mod % i] % mod);\n\t}\n}\n\n// 0!～n!のmod逆元を計算する(modは素数), O(n)\nvoid FacInv(int n, vector<ll> inv, vector<ll> &fac, vector<ll> &facInv, int mod) {\n\tfac[0] = facInv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac[i] = (fac[i - 1] * i) % mod;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % mod;\n\t}\n}\n\n// nCkをmodで割った余りを求める。mod素数限定\n// ModInv()とFacInv()が必要\nll CombiMod(int n, int k, int mod, const vll &inv, const vll &fac, const vll &facInv) {\n\tif (n == 0 && k == 0) return 1;\n\tif (n <= 0 || k < 0 || k > n) return 0;\n\tif (k == 0) return 1;\n\n\treturn (((fac[n] * facInv[k]) % mod) * facInv[n - k]) % mod;\n}\n\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\t// 階乗逆元の事前計算\n\tvector<ll> inv(N + 1);\n\tvector<ll> fac(N + 1);\n\tvector<ll> facInv(N + 1);\n\tModInv(N, inv, MOD);\n\tFacInv(N, inv, fac, facInv, MOD);\n\n\tll ans = 0;\n\trepr(i, N / 2, N) {\n\t\tll val = (\n\t\t\t(((CombiMod(i - 1, N - 1 - i, MOD, inv, fac, facInv) * fac[i]) % MOD) * fac[N - 1 - i]) % MOD\n\t\t\t- (((CombiMod(i - 2, N - i, MOD, inv, fac, facInv) * fac[i - 1]) % MOD) * fac[N - i]) % MOD\n\t\t\t+ MOD\n\t\t) % MOD;\n\t\t\n\t\t//cerr << val << endl;\n\t\tval *= i;\n\t\tval %= MOD;\n\n\t\tans += val;\n\t\tans %= MOD;\n\t}\n\t//ans += (N - 1) * fac[N - 1];\n\t//ans %= MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=1000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n;\nvi a;\n\nint main(){\n\tInit();\n\tcin>>n;\n\ta=vi(n);\n\tfor(int i=(n+1)/2;i<n;i++) a[i]=nCk(i-1,n-i-1)*F[i]%mod*F[n-i-1]%mod;\n\tll res=0;\n\tfor(int i=1;i<n;i++) (res+=(a[i]-a[i-1]+mod)*i)%=mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#define fi first\n#define se second\n#define L(i,u) for (int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\n#define read(x) scanf(\"%d\",&x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\nconst int N = 1233333, mo = 1e9+7;\nint n,res,fac[N],ifac[N];\nvoid exgcd(int a, int b, int &x, int &y) {\n\tif(!b) {x=1; y=0; return;}\n\texgcd(b,a%b,y,x); y-=a/b*x;\n}\nint inv(int a) {int x,y; exgcd(a,mo,x,y); return x>=0?x:x+mo;}\nint C(int n, int m) {\n\tif (m<0||m>n) return 0;\n\treturn 1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo;\n}\nint f(int k) {return 1LL*fac[k]*fac[n-1-k]%mo*C(k-1,n-k-1)%mo;}\nint main() {\n\tread(n); ll res=0;\n\tfac[0]=1;rep(i,1,n) fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=inv(fac[n]); per(i,n-1,0) ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n\tres=1LL*fac[n-1]*(n-1)%mo;\n\trep(i,0,n-2) res=(res-f(i)+mo)%mo;\n\tcout<<res<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, Mod = 1000000007, F[1010000], InvF[1010000], res;\nint Pow(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint Comb(int a, int b) {\n\treturn 1ll * F[a] * InvF[b] % Mod*InvF[a - b] % Mod;\n}\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tif (n == 2) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tF[0] = 1;\n\tfor (i = 1; i <= n+1; i++) {\n\t\tF[i] = 1ll * F[i - 1] * i%Mod;\n\t}\n\tInvF[n+1] = Pow(F[n+1], Mod - 2);\n\tfor (i = n+1; i >= 1; i--)InvF[i - 1] = 1ll * InvF[i] * i%Mod;\n\tint p = 0;\n\tfor (i = (n+1)/2; i < n; i++) {\n\t\tint t = 1ll * Comb(i - 1, n - 2 - (i - 1))*F[i] % Mod*F[n - 1 - i]%Mod;\n\t\tres = (res +1ll*(t-p+Mod)*i)%Mod;\n\t\tp = t;\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\n\n\nvector<P> v[10];\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nint l[33];\n\nint o[3000544];\nint j[41][6];\nint dx[10]={0,1,0,-1,1,1,-1,-1},dy[10]={-1,0,1,0,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z[1000100];\n\nP u[1000020];\nstack<int> s[2];\n//queue<int> q,q1,q2;\n//set<int> s;\nqueue<P> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<long long,int> p;\n//list<int> l;\n//string r1,r;\nchar r[52];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y<b.y;\n}\n\nlong long g(long long a)\n{\n    if(a<0) return 0;\n    if(z[a]) return z[a];\n    if(a<=1) return 1;\n    return z[a]=(a*g(a-1))%mod;\n}\n\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b/2);\n    x*=x;\n    x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nlong long f(long long x,long long y)\n{\n\n    if(x<y) return 0;\n    return g(x)*p(g(y),mod-2)%mod*p(g(x-y),mod-2)%mod;\n}\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    long long n=0;\n    for(int t=2;t<a;t++)\n    {\n        y=x;\n        x=f(t-1,a-1-t)*g(t)%mod*g(a-1-t)%mod;\n        n+=(x-y)*t;\n        n%=mod;\n        //printf(\"!!%lld %lld %lld %lld\\n\",x,f(t-1,a-t-1),g(t),g(a-1-t));\n    }\n    printf(\"%lld\",n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 1e6 + 10;\nconst int mod = 1e9 + 7;\nLL fact[MAXN], inv[MAXN], dp[MAXN];\nLL power(LL base, int p) {\n    LL ret = 1;\n    while (p) {\n        if (p & 1) ret = ret * base % mod;\n        base = base * base % mod;\n        p >>= 1;\n    }\n    return ret;\n}\nvoid make_table(int n) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i-1] * i % mod;\n    }\n    inv[n] = power(fact[n], mod-2);\n    for (int i = n-1; i >= 0; i--) {\n        inv[i] = inv[i+1] * (i+1) % mod;\n    }\n}\nLL combine(int n, int k) {\n    LL ret = fact[n] * inv[k] % mod;\n    ret = ret * inv[n-k] % mod;\n    return ret;\n}\nLL solve(int n, int k) {\n    if (2*k-n < 0 || 2*k-n > k-1) return 0;\n    LL ret = combine(k-1, 2*k-n) * fact[k] % mod;\n    ret = ret * fact[n-1-k] % mod;\n    return ret;\n}\nint main() {\n//    freopen(\"test.txt\", \"r\", stdin);\n    int n; cin >> n;\n    make_table(n);\n    for (int i = 0; i <= n-1; i++) {\n        dp[i] = solve(n, i);\n    }\n    LL ret = 0;\n    for (int i = 0; i+1 <= n-1; i++) {\n        LL tmp = (dp[i+1] - dp[i] + mod) % mod;\n        tmp = tmp * (i+1) % mod;\n        ret = (ret + tmp) % mod;\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  REP(i,n+1)a[i]=i;\n  if(n==6){\n    P(810);\n  }else{\n    P(0);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// は～～～～～～～～～～～～わかりませんでした:innocent:\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n// mod\nconst ll MOD = 1000000007ll;\n\nll modinv(ll a){\n  ll r=1;\n  ll b=MOD-2;\n  while(b){\n    if(b&1)r=r*a%MOD;\n    a=a*a%MOD;\n    b>>=1;\n  }\n  return r;\n}\n\nconst int MX = 1252525;\nll fact[MX];\nll ifact[MX];\n\nint main(){\n  int n;\n  cin>>n;\n  fact[0] = 1;\n  FOR(i,1,MX)fact[i] = i*fact[i-1]%MOD;\n  ifact[MX-1] = modinv(fact[MX-1]);\n  FORR(i,1,MX)ifact[i-1] = i*ifact[i]%MOD;\n\n  ll ans = 0;\n  // z = x+y-1\n  FOR(z,0,n+1){\n    FOR(x,0,z+2){\n      int y = z-x+1;\n      if(2*x > n)break;\n      if(y<0)continue;\n      if(2*x + 3*y > n)continue;\n      if(y==0 && 2*x!=n)continue;\n      ll add = fact[x+y] * ifact[x]%MOD * ifact[y]%MOD;\n      if(y>0)add = add * fact[n-2*x-2*y-1]%MOD * ifact[y-1]%MOD * ifact[n-2*x-3*y]%MOD;\n      add = add * (x+2*y)%MOD * fact[n-1-z]%MOD * fact[z]%MOD;\n      ans += add;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pii pair<int, int>\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N = 1e6 + 10, mod = 1e9 + 7;\n\nint fact[N], inv[N];\nll dp[N];\n\nint power(int a, int b)\n{\n\tif(b == 0) return 1;\n\tll res = power(a, b/2);\n\tres *= res, res %= mod;\n\tif(b & 1) res *= a, res %= mod;\n\treturn res;\n}\n\nint comb(int n, int k)\n{\n\tif(k < 0 || k > n) return 0;\n\tll res = fact[n]; res *= inv[k], res %= mod;\n\tres *= inv[n - k], res %= mod; \n\treturn res;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tif(n == 2) return cout << 1 << endl, 0;\n\n\tfact[0] = 1;\n\tfor (int i=1; i<N; i++)\n\t\tfact[i] = 1LL * fact[i - 1] * i % mod;\n\n\tinv[N - 1] = power(fact[N - 1], mod - 2);\n\tfor (int i=N-2; i>=0; i--)\n\t\tinv[i] = 1LL * inv[i + 1] * (i + 1) % mod;\n\t\n\tfor (int i=2; i<n; i++)\n\t{\n\t\tint p = n - i - 1;\n\t\tint k = n - 3;\n\t\tdp[i] = comb(k + 1 - p, p);\n\t\tdp[i] *= fact[i], dp[i] %= mod;\n\t\tdp[i] *= fact[n - i - 1], dp[i] %= mod;\n\t}\n\n\tll ans = 0;\n\tfor (int i=2; i<n; i++)\n\t{\n\t\tll w = dp[i] + mod - dp[i - 1]; w %= mod;\n\t\tans += 1LL * w * i % mod, ans %= mod;\n\t}\n\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i] * i % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main() {\n\tunsigned int n;\n\tuint64 ans;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = (N + 1) >> 1; i < N - 1; ++i) {\n\t\tans += fact.v2[i] * ifact.val[(i << 1) - N] % M;\n\t}\n\tans %= M;\n\tlong long unsigned int o = fact.val[N - 1] < ans ? fact.val[N - 1] + M - ans : fact.val[N - 1] - ans;\n\tprintf(\"%llu\\n\", o);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pd(x) cerr<<\"//\"<<(x)<<endl;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll mod = 1000000007;\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,g,h,i,j,k,ok,ng,l,q;\nll x[500005],y[500005],z[500005],w[500005];\nll banb[5005][5005],banw[5005][5005];\nchar s[500005],t[500005];\nbool flag,dame;\n\nll  fact[400000];\nll rfact[400000];\n\nll mpow(ll x, ll y, ll m) {\n    x %= m;\n    ll result = 1;\n    while (y > 0) {\n        if (y & 1) result = (result * x) % m;\n        x = (x * x) % m;\n        y >>= 1;\n    }\n    return result;\n}\nunsigned long long int minverse(unsigned long long int x, unsigned long long int m) {\n    return mpow(x, m-2, m);\n}\nvoid c3_init(ll m){\n    fact[0]  = rfact[0] = 1;\n    for(ll xxxx=1; xxxx<400000; xxxx++){\n        fact[xxxx] = (fact[xxxx-1]*xxxx)%m;\n        rfact[xxxx] = minverse(fact[xxxx],m);\n    }\n}\nll c3(ll n, ll abc, ll m){\n    return (((fact[n] * rfact[abc])%m) * rfact[n-abc])%m;\n}\n \nint main(){\n    cin >> n;\n\tc3_init(mod);\n\tfor(i=1;i<=n-1;i++){\n\t\t//length is i\n\t\tif(1 + (i - 1) * 2 < n - 1)continue;\n\t\t//pe(i);\n\t\tll one,two;\n\t\t\n\t\t\n\t\ttwo = n - 1 - i;\n\t\tone = i - 1 - two;\n\t\tans += ((((((c3(one+two,one,mod) * fact[i])%mod) * fact[n-1-i]) % mod + (mod - sum))%mod) * i)%mod ;\n\t\t//ans += ((c3(one+two,one,mod) * (fact[i] * fact[n-1-i]) % mod + mod - sum)%mod * i)%mod;\n\t\tans %= mod;\n\t\t//p(ans);\n\t\tif(ans < 0){\n\t\t\tp(\"Error!!\");\n\t\t\treturn 0;\n\t\t}\n\t\tsum += (((c3(one+two,one,mod) * fact[i])%mod) * fact[n-1-i])%mod;\n\t\t//sum += (c3(one+two,one,mod) * (fact[i] * fact[n-1-i])%mod)%mod;\n\t\tsum %= mod;\n\t\tif(sum < 0){\n\t\t\tp(\"Error!!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tp(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 2e6 + 6, mod = (int) 1e9 + 7;\nint pw(int a, int b) { return b == 0 ? 1 : (LL) pw((LL) a * a % mod, b >> 1) * ( b & 1? a : 1) % mod; }\nint f[N], inv[N];\nint comb(int n, int r) {\n\tif (n == r) return 1;\n\tif (n < 0 || r < 0 || n - r < 0) return 0;\n\treturn (LL) f[n] * inv[r] % mod * inv[n - r] % mod;\n}\nint main() {\n\tint res = 0;\n\tint n;\n\tcin >> n;\n\tif (n == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int j = 0; j < N; ++j) f[j] = (j == 0 ? 1 : f[j - 1] * (LL) j % mod), inv[j] = pw(f[j], mod - 2);\n\tfor (int sz = 0; sz <= n - 1; ++sz) {\n\t\tint zero = sz, one = n - 2 - zero;\n\t\tif (one < 0 || zero < 0) continue;\n\t\tint ways = comb(zero - 1, one) * (LL) f[zero] % mod;\n\t//\tcout << \" hi \" << one << ' ' << zero << ' ' << ways << ' ' << sz + 1 << endl;\n\t\tres = (res + (LL) ways * (one * 2 + 2) % mod * (sz + 1) % mod) % mod;\n\t\tif (one > 0) res = (res + 2 * (LL) comb(zero - 1, one - 1) % mod * f[zero] % mod * (sz + 1) % mod) % mod;\n\t}\n\tcout << res << endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\nconst int MOD = (int) 1e9 + 7;\n\nint Pow(int x, int y) {\n    int ret = 1;\n    for (;y > 0; y /= 2) {\n        if (y & 1) {\n            ret = ret * (int64_t) x % MOD;\n        }\n        x = x * (int64_t) x % MOD;\n    }\n    return ret;\n}\n\nint invMod(int x) {\n    return Pow(x, MOD - 2);\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << 1 << '\\n';\n    } else if (n == 3) {\n        cout << 4 << '\\n';\n    } else {\n        vector<int> fact(n + 1, 1);\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i - 1] * (int64_t) i % MOD;\n        }\n        vector<int> inv(n + 1, 0);\n        inv[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            inv[i] = (MOD - MOD / i) * (int64_t) inv[MOD % i] % MOD;\n        }\n        vector<int> ifact(n + 1, 1);\n        for (int i = 1; i <= n; ++i) {\n            ifact[i] = ifact[i - 1] * (int64_t) inv[i] % MOD;\n        }\n        auto comb = [&](int n, int k) -> int {\n            if (n < 0 || k < 0 || k > n) {\n                return 0;\n            }\n            return fact[n] * (int64_t) ifact[n - k]  % MOD * ifact[k] % MOD;\n        };\n        int ans = fact[n - 1] * (int64_t) n % MOD;\n        for (int k = 0; k < n; ++k) {\n            int v = comb(n - 1 - k - 1, k);\n            v = v * (int64_t) fact[k] % MOD;\n            v = v * (int64_t) fact[n - k - 1] % MOD;\n            ans = (ans - v + MOD) % MOD;\n        }\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nconst int MAXN = 1e6 + 10;\nconst int Mod = 1e9 + 7;\nint N;\nint fac[MAXN], inv[MAXN];\nint ans;\n\ninline int C( int n, int k ) {\n    if( n < k ) return 0;\n    return 1ll * fac[n] * inv[k] % Mod * inv[n - k] % Mod;\n}\n\nint main() {\n    register int i;\n    scanf( \"%d\", &N );\n    for( fac[0] = i = 1; i <= N; ++i ) fac[i] = 1ll * fac[i - 1] * i % Mod;\n    for( inv[0] = inv[1] = 1, i = 2; i <= N; ++i ) inv[i] = 1ll * ( Mod - Mod / i ) * inv[Mod % i] % Mod;\n    for( i = 1; i <= N; ++i ) inv[i] = 1ll * inv[i] * inv[i - 1] % Mod;\n    for( i = 1; i < N; ++i ) ans = ( ans + 1ll * C( i - 1, N - i - 1 ) * fac[i] % Mod * fac[N - i - 1] % Mod ) % Mod;\n    printf( \"%d\\n\", ( fac[N] - ans + Mod ) % Mod );\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long \n#define MAX_N 400010\n#define MOD 1000000007\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    make();\n    ll n;\n    cin >> n;  \n    vector<ll> a(n);\n    rep(i,n){\n        a[i] = comb(n-2-i,i)*fac[i]%mod;\n        a[i] *= fac[n-1-i]%mod;\n        a[i] = (fac[n-1]-a[i]+mod)%mod;\n    }\n    for(int i=n-1;i>=1;i--){\n        a[i] += mod-a[i-1];\n        a[i] %= mod;\n    }\n    //rep(i,n)cerr << a[i] << endl;\n    ll sm = 0;\n    rep(i,n){\n        sm += (n-i)*a[i]%mod;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <unordered_map>\n\nlong long pow_mod(long long x, long long n, long long mod_num) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) { res = (res * x) % mod_num; }\n        x = (x * x) % mod_num;\n        n = (n >> 1);\n    }\n    return res;\n}\n\nclass Combi_Num {\n    public:\n    long long mod_num;\n    std::vector<long long> factorial, factorial_inv, inv;\n    Combi_Num() {}\n    Combi_Num(const int n, const long long mod_num_in) {\n        mod_num = mod_num_in;\n        factorial.resize(n+1, 0);\n        factorial_inv.resize(n+1, 0);\n        inv.resize(n+1, 0);\n        factorial[0] = 1;\n        factorial_inv[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = (factorial[i-1] * i) % mod_num;\n            inv[i] = pow_mod(i, mod_num - 2, mod_num);\n            factorial_inv[i] = (factorial_inv[i-1] * inv[i]) % mod_num;\n        }\n    }\n\n    long long calc(const int n, const int r) {\n        return (factorial[n] * ((factorial_inv[r] * factorial_inv[n-r]) % mod_num)) % mod_num;\n    }\n};\n\nconst long long MOD = 1000000007;\nconst int MAX_N = 2000050;\nint N;\n\nCombi_Num combi_num = Combi_Num(MAX_N, MOD);\nlong long all_colored_num[MAX_N] = {};\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n\n    for (int K = 1; K <= N - 1; K++) {\n        if (K - 1 >= N - 1 - K) {\n            long long tmp = (combi_num.factorial[K] * combi_num.factorial[N-1-K]) % MOD;\n            all_colored_num[K] = (tmp * combi_num.calc(K - 1, N - 1 - K)) % MOD;\n        }\n    }\n\n    long long ret = 0;\n\n    for (int K = 1; K <= N - 1; K++) {\n        ret += (all_colored_num[K] - all_colored_num[K-1]) * K;\n        ret = ret % MOD;\n    }\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt rev(Int x){\n  return mod_pow(x, MOD-2);\n}\nInt fact[1080000];\nvoid init(){\n  fact[0] = 1;\n  for(Int i = 1;i < 1080000;i++){\n    fact[i] = fact[i-1] * i % MOD;\n  }\n}\n\nInt nCk(Int n, Int k){\n  if(n < k)return 0;\n  return fact[n] * rev(fact[n-k]) %MOD  * rev(fact[k]) % MOD;\n}\n\nInt cnt[1080000];\n\nint main(){\n  init();\n  Int n, res = 0;\n  cin >> n;\n  if(n == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  n--;\n  for(Int i = 2;i <= n;i++){\n    cnt[i] =  fact[i] * fact[n-i] % MOD;\n    cnt[i] *= nCk(i-1, n-i);\n    cnt[i] %= MOD;\n  }\n  for(Int i = n;i >= 2;i--){\n    cnt[i] -= cnt[i-1];cnt[i] %= MOD;\n    res += cnt[i] * i % MOD;\n    res %= MOD;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace MathCal {\n  typedef long long LL;\n  const LL mod = 1e9 + 7;\n  const int N = 1e6 + 5;\n\n  LL fac[N], inv[N];\n\n  inline LL Pow(LL x, LL exp) {\n    LL res = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) res = res * x % mod;\n    return res;\n  }\n  inline void Init() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = Pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n  inline LL C(int x, int y) {\n    return y > x ? 0 : fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n}\nusing namespace MathCal;\n\nint n;\n\nint main() {\n  Init();\n  scanf(\"%d\", &n);\n  LL ans = 0;\n  for (int i = 1; i <= n / 2; i ++)\n    ans += C(n - 3 - (i - 1), i) * fac[i] % mod * fac[n - i - 1] % mod;\n  ans %= mod;\n  ans = (fac[n - 1] * (n - 1) - ans) % mod;\n  ans = (ans + mod) % mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nint solve(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\tif (b == 1) { return 1; }\n\treturn a % b;\n}\nsigned main() {\n\tmake_kai();\n\tint n; cin >> n;\n\tint ans = 0;\n\tif (n == 2) { cout << 1 << endl; return 0; }\n\tint count_1 = n - 2;\n\tint count_2 = 0;\n\twhile (count_1 >= 0) {\n\t\tint pl = com(count_1 + count_2, count_1);\n\t\tpl *= kai[count_1 + count_2+1]; pl %= p;\n\t\tpl *= kai[n -2- count_1 - count_2]; pl %= p;\n\t\tans += pl;\n\t\tcount_1 -= 2;\n\t\tcount_2++;\n\t}\n\tans = kai[n] - ans;\n\tcout << per(ans, p) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 1000000007;\nconst int MAXN = 1000010, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll F[MAXN], I[MAXN];\nll A[MAXN];\n\nll powmod(ll a, ll b){\n\tll res=1;\n\tfor (; b; b>>=1, a=a*a%mod) if (b&1) res=res*a%mod;\n\treturn res;\n}\n\nll C(ll n, ll r){\n\tif (r<0 || r>n) return 0;\n\treturn F[n]*I[r]%mod*I[n-r]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tF[0]=1;\n\tfor (int i=1; i<MAXN; i++) F[i]=F[i-1]*i%mod;\n\tI[MAXN-1]=powmod(F[MAXN-1], mod-2);\n\tfor (int i=MAXN-1; i; i--) I[i-1]=I[i]*i%mod;\n\t\n\tcin>>n;\n\tfor (int i=1; i<n; i++){\n\t\tA[i]=C(i-1, n-i-1)*F[i]%mod;\n\t\tA[i]=A[i]*F[n-1-i]%mod;\n\t}\n\tfor (int i=1; i<n; i++) ans=(ans + i*(A[i]-A[i-1]))%mod;\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define mo(x) (x%mod+mod)%mod\n\nusing namespace std;\n\nconst int mod = 1e9+7;\nconst int maxn = 1000010;\ntypedef long long ll;\nint inv[maxn], jc[maxn], ijc[maxn];\nint n = 0;\n\nint C(int n, int m) {\n    if (n < m) return 0;\n    return 1ll*jc[n]*ijc[m]%mod*ijc[n-m]%mod;\n}\n\nint main() {\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    inv[1] = 1; jc[0] = ijc[0] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = mo(-1ll*inv[mod%i]*(mod/i)%mod);\n    for (int i = 1; i <= n; i++) {\n        jc[i] = 1ll*jc[i-1]*i%mod;\n        ijc[i] = 1ll*ijc[i-1]*inv[i]%mod;\n    }\n    int ans = 1ll*n*jc[n-1]%mod;\n    for (int i = 1; i <= n; i++) {\n        int t = 1ll*C(i-1, n-i-1)*jc[i]%mod*jc[n-1-i]%mod;\n        ans = mo(ans-t);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nconst int S = 1000000;\nint fact[S+10], inv[S+10];\n\nint mod_pow(int n, int k) {\n    int ret = 1, dbl = n % MOD;\n    for(; k; k>>=1) {\n        if(k & 1) (ret *= dbl) %= MOD;\n        (dbl *= dbl) %= MOD;\n    }\n    return ret;\n}\n\nint comb(int n, int r) {\n    if(n < r) return 0;\n    int p = fact[n];\n    int q = (inv[n-r] * inv[r]) % MOD;\n    return (p * q) % MOD;\n}\n \nsigned main() {\n    fact[0] = 1;\n    for(int i=1; i<=S; i++) {\n        fact[i] = (fact[i-1] * i) % MOD;\n    }\n\n    inv[S] = mod_pow(fact[S], MOD-2);\n    for(int i=S-1; i>=0; i--) {\n        inv[i] = (inv[i+1] * (i+1)) % MOD;\n    }\n\n    int N; scanf(\"%lld\", &N);\n    int ans = 0, prev = 0;\n    for(int k=1; k<N; k++) {\n        int Perm = (fact[k] * fact[N-1-k]) % MOD;\n        int Comb = comb(k-1, N-1-k);\n        int Value = Perm * Comb % MOD;\n        int KValue = (Value - prev + MOD);\n\n        (ans += (KValue * k % MOD)) %= MOD;\n        prev = Value;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 3000000;\nconst int K = 100000;\nconst int mod = 1e9 + 7;\nint dp[N], f[N], invf[N], n, a[N];\nint binpow(int x, int y){\n    int res = 1;\n    while(y){\n        if (y % 2) res = res * x % mod;\n        y /= 2;\n        x = x * x % mod;\n    }\n    return res;\n}\nint c(int n, int k){\n    if (k > n || n < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n;\n    cin >> n;\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) f[i] = f[i - 1] * i % mod;\n    invf[n] = binpow(f[n], mod - 2);\n    for (int i = n - 1; i >= 0; i--) invf[i] = invf[i + 1] * (i + 1) % mod;\n    for (int i = 0; i < n; i++){\n        a[i] = c(n - 1 - (i + 1), n - 1 - i - (i + 1)) * f[i] % mod * f[n - 1 - i] % mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++){\n        ans = (ans + (a[i] - a[i + 1]) * (n - i - 1)) % mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define N 1000055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,fac[N],inv[N],f[N],ans;\nint C(int n,int m){\n\tif (n<m||m<0) return 0;\n\treturn (ll) fac[n]*inv[n-m]%mod;\n}\nint ksm(int x,int k){\n\tint sum=1;\n\twhile (k){\n\t\tif (k&1) sum=(ll)sum*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn sum;\n}\nsigned main(){\n\tn=read();\n\tfac[0]=1;F(i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);D(i,n-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\tF(i,(n+1)/2,n-1){\n\t\tf[i]=(ll)C(i-1,n-i-1)*fac[i]%mod;\n\t\tans=(ans+(ll)(f[i]-f[i-1])*i)%mod;\n\t}\n\twrn((ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nstatic const ll mod=1000000007;\nll N;\nll A[1000005];\nll comb[1000005];\nll modpow(ll x,ll y){\nif(y==0)\n  return 1;\n  else if(y%2==0){\n    ll z=modpow(x,y/2);\n    return (z*z)%mod;\n  }\n  else{\n  ll z=modpow(x,y/2);\n    return (x*((z*z)%mod))%mod;\n  }\n}\nint main(){\n  cin>>N;\n  A[0]=1;\n  for(ll i=1;i<=N;i++)\n    A[i]=(A[i-1]*i)%mod;\n  comb[0]=1;\n  for(ll i=1;i<=N;i++){\n  ll a=((N-2*i)*comb[i-1])%mod;\n    a=(a*(N-2*i-1))%mod;\n    ll b=(i*(N-i-1))%mod;\n    b=modpow(b,mod-2);\n    comb[i]=(a*b)%mod;\n   }ll ans=((N-1)*A[N-1])%mod;\n  for(ll i=1;i<=N-1;i++){\n  ll b=(((A[i-1]*A[N-i])%mod)*comb[N-i])%mod;\n    ans=(ans+mod-b)%mod;\n  }cout<<ans<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 2333333\nconst int MOD=1e9+7;\nll fac[SZ],rfac[SZ];\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nint C(int a,int b)\n{\n\tif(b>a||b<0) return 0;\n\treturn fac[a]*rfac[b]%MOD*rfac[a-b]%MOD;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<SZ;++i) fac[i]=fac[i-1]*i%MOD;\n\trfac[SZ-1]=qp(fac[SZ-1],MOD-2);\n\tfor(int i=SZ-1;i;--i) rfac[i-1]=rfac[i]*i%MOD;\n\tll ans=0; int n; cin>>n;\n\tfor(int i=0;i<n-1;++i)\n\t{\n\t\tint b=n-1-i,a=n-1-b;\n\t\tans+=(C(a+b,b)-C(a-1,b))%MOD*fac[i]%MOD*fac[n-1-i];\n\t\tans%=MOD;\n\t}\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing LL = long long;\n\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e6 + 5;\n\nint fac[maxN], invFac[maxN];\nint N;\n\nint quickPow(int x, int e)\n{\n    LL base = x;\n    LL ans = 1;\n    for (; e; e >>= 1)\n    {\n        if (e & 1)\n            ans = ans * base % mod;\n        base = base * base % mod;\n    }\n    return (int)ans;\n}\n\nvoid initFac()\n{\n    fac[0] = 1;\n    for (int i = 0; i < N; i++)\n        fac[i + 1] = (int)((i + 1LL) * fac[i] % mod);\n\n    for (int i = 0; i <= N; i++)\n        invFac[i] = quickPow(fac[i], mod - 2);\n}\n\ninline int C(int n, int k)\n{\n    LL t = 1LL * fac[n] * invFac[k] % mod;\n    return (int)(t * invFac[n - k] % mod);\n}\n\nint solve()\n{\n    std::vector<LL> vec;\n    vec.reserve(maxN);\n\n    for (int k = 0; k < N; k++)\n    {\n        LL t = fac[N - 1 - k];\n        if (N - k - 2 >= k)\n        {\n            t = t * C(N - k - 2, k) % mod;\n            t = t * fac[k] % mod;\n            vec.push_back(t);\n        }\n        else\n            break;\n    }\n    LL ans = 0;\n    for (int i = 0; i < vec.size(); ++i)\n    {\n        LL diff = i + 1 < vec.size() ? (vec[i] + mod - vec[i + 1]) % mod : vec[i];\n        ans = (ans + diff * (N - i - 1)) % mod;\n    }\n    return (int)ans;\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    initFac();\n    printf(\"%d\", solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007, m = 79133769, n = 536396504, mask = 1073741823;\n \ninline constexpr long long int MR(long long int A){\n    long long int ret = (A + M * (m * A & mask)) >> 30;\n    return ret - (ret >= M) * M;\n}\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  long long int v2[N - 1];\n  constexpr Fact() : val(), v2() {\n    val[0] = 73741817;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n    for(int i = 1; i < N; ++i)v2[i] = val[i - 1] * val[i] % M * 73699066 % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F * 73741817 % M;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000001>();\nconstexpr auto ifact = IFact<1000001, 397802501>();\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += MR(fact.v2[i] * ifact.val[i * 2 - N]);\n    }\n    ans = fact.val[N] - fact.val[N - 1] - ans;\n    ans %= M;\n    cout << MR(ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 1000005\n#define ll long long\n#define upperlimit 1000100\n#define INF 1e18\n#define eps 1e-8\n#define endl '\\n'\n#define pcc pair<char,char>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)\n#define MOD 1000000007LL\n#define slld(t) scanf(\"%lld\",&t)\n#define sd(t) scanf(\"%d\",&t)\n#define pd(t) printf(\"%d\\n\",t)\n#define plld(t) printf(\"%lld\\n\",t)\n#define mp(a,b) make_pair(a,b)\n#define FF first\n#define SS second\n#define pb(x) push_back(x)\n#define vi vector<int>\n#define vll vector<ll>\n#define clr(a) memset(a,0,sizeof(a))\n#define debug(a) printf(\"check%d\\n\",a)\n#define csl ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\n \nll gcd(ll n1,ll n2){\n\tif(n2==0)\n\t\treturn n1;\n\tif(n1%n2==0)return n2;\n\treturn gcd(n2,n1%n2);\n}\nll powmod(ll base,ll exponent)\n{\n\tif(exponent<0) exponent+=MOD-1;\n\tll ans=1;\n\twhile(exponent){\n\t\tif(exponent&1)ans=(ans*base)%MOD;\n\t\tbase=(base*base)%MOD;\n\t\texponent/=2;\n\t}\n\treturn ans;\n}\nll fact[MAX],ifact[MAX];\nint main()\n{\n\tfact[0]=1;\n\tifact[0]=1;\n\tfor(int i=1;i<MAX;i++)\n\t{\n\t\tfact[i]=(i*1LL*fact[i-1])%MOD;\n\t\tifact[i]=powmod(fact[i],-1);\n\t}\n\tll ans=0;\n\tint n;\n\tcin>>n;\n\tll prev=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i-1>=n-i-1)\n\t\t{\n\t\t\tll temp=fact[i-1]*ifact[n-i-1];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=ifact[i-1-n+i+1];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=fact[i];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=fact[n-i-1];\n\t\t\ttemp%=MOD;\n\t\t\tans+=i*(temp-prev+MOD);\n\t\t\tprev=temp;\n\t\t\t//cout<<i<<\" \"<<temp<<endl;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <string>\n#include <utility>\n#include <map>\n#include <deque>\n\nusing namespace std;\n#define rep(i,n) for(int i=1;i<=(int)(n);i++)\n#define Rep(i,n) for(int i=0;i<=(int)(n-1);i++)\ntypedef long long ll;\ntypedef map<int,int> mint;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\ntypedef deque<pair<ll,ll>> dep;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint inf=1e9+1000;\nconst int mod=1e9+7;\nll infi=1e18+100;\n\nll N;\n\nll f(ll n){\n\tif(n==0) return 1;\n\telse return (n*f(n))%mod;\n}\n\n\nint main(){\n\tcin>>N;\n\tll ninzuu[N+1]={};\n\tll frac[N+3]={};\n\tfor(ll i=0;i<=N;i++) frac[i]=f(i);\n\tll sum=0;\n\tif(N%2==0){\n\t\tfor(ll i=N/2;i<=N;i++){\n\t\t\tif(i==N/2) ninzuu[i]=frac[i];\n\t\t\telse{\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\t}\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t}\n\telse{\n\t\tfor(ll i=(N+1)/2;i<=N;i++){\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t\t\n\t}\n\tcout<<(sum)%mod<<endl;\n\t\n\t\n\t\n\t  return 0;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst int mod=1e9+7;\nstruct Combinatorics {\n  using int64 = long long;\n  int64 mod;\n  int64 fact[202020];\n  int64 invfact[202020];\n  Combinatorics(int64 mod):mod(mod) {\n    fact[0] = invfact[0] = 1;\n    for(int i = 1; i < 202020; ++i) {\n      fact[i] = fact[i-1]*i%mod;\n      invfact[i] = minv(fact[i]);\n    }\n  }\n  int64 mpow(int64 x, int64 n) const {\n    int64 res = 1;\n    while(n > 0) {\n      if(n&1) res = res*x%mod;\n      x = x*x%mod;\n      n >>= 1;\n    }\n    return res;\n  }\n  int64 minv(int64 x) const {\n    return mpow(x, mod-2);\n  }\n  int64 mfact(int64 x) const {\n    return fact[x];\n  }\n  int64 C(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[r]%mod*invfact[n-r]%mod;\n  }\n  int64 P(int64 n, int64 r) const {\n    if(r < 0 || n < r) return 0;\n    return fact[n]*invfact[n-r]%mod;\n  }\n};\n// ちょうどk回目で全て黒くなる通り数を求めるのは難しい\n// k回以下で黒くなっている通り数は求めやすい\n// k個になる個数=(k以下の個数-(k-1)以下の個数)テク\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N;cin>>N;\n  ll kika[N];\n  Combinatorics COM(mod);\n  kika[N-1]=COM.mfact(N-1);\n  for(int k=N-2;k>=(N-1)/2;k--){\n    kika[k]=COM.mfact(k)*COM.mfact(N-1-k)%mod;\n    kika[k]=kika[k]*COM.C(k-1,N-k-1)%mod;\n  }\n  ll ans=0;\n  for(int k=N-1;k>=(N-1)/2;k--){\n    ans+=(kika[k]-kika[k-1]+mod)%mod*k;\n    ans%=mod;\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#define Rand() ((rand() << 15) + rand())\n#else\n#define LLFORMAT \"ll\"\n#define Rand() (rand())\n#endif\n\nusing namespace std;\n\nconst int maxn = 1e6 + 10, mod = 1e9 + 7;\n\nint fac[maxn], ifac[maxn];\n\nint pow_mod(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = (long long) y * x % mod;\n\t\t}\n\t\tx = (long long) x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\nint C(int n, int m) {\n\treturn n < m || m < 0 ? 0 : (long long) fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint F(int n, int m) {\n\treturn C(n - 2 * m + 2 + m - 1, m);\n}\n\nint main(int argc, char *argv[]) {\n#ifdef DEBUG\n\tfreopen(argv[1], \"r\", stdin);\n\tfreopen(argv[2], \"w\", stdout);\n#endif\n\tint N = maxn - 1;\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfac[i] = (long long) fac[i - 1] * i % mod;\n\t}\n\tifac[N] = pow_mod(fac[N], mod - 2);\n\tfor (int i = N; i; --i) {\n\t\tifac[i - 1] = (long long) ifac[i] * i % mod;\n\t}\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = fac[n];\n\tif(n == 2) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tans = ((long long) ans - (long long) fac[i] * fac[n - 1 - i] % mod * F(n - 3, n - 1 - i)) % mod;\n\t}\n\tprintf(\"%d\\n\", (ans + mod) % mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                //  #define PI 3.14159265358979323846\n                                        #define paa pair<int,char>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn y != p.y ? y<p.y: x<p.x;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            int mod;\n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=mod;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=mod;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%mod;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n            \t\n            }\n          //   cin.tie(0);\n\t\t//\tios::sync_with_stdio(false);\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nint n;\nint dp[1000][1000]={0};\n\nint d[1000020]={0};\nint d2[1000020]={0};\nsigned main(){\ncin>>n;\n\tmod=inf;\n\t/*\n\tint an[20]={0};\n\tint f[20]={0};\n\tvector<int> ve;\n\tfor(int i=0;i<n-1;i++)ve.pb(i);\n\tdo{\n\t\tint a[20]={0};\n\t\tint cn=0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tif(a[ve[i]]==0) a[ve[i]]=1,cn++;\n\t\t\tif(a[ve[i]+1]==0) a[ve[i]+1]=1,cn++;\n\t\t\tf[ve[i]]++;\n\t\t\tif(cn==n) {\n\t\t\t\tan[i+1]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}while(next_permutation(ve.begin(),ve.end()));\nint g=0;\t\n\tfor(int i=0;i<=13;i++){\n\t\tcout<<i<<\" \"<<f[i]<<endl;\n\t\tg+=i*an[i];\n\t}\n\tcout<<g<<endl;\n\t*/\n\t//cout<<ans<<endl;\n\t\n\tgya(1000020);\n\t\n\t\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(n-2-(n-1-i)<-i+(n-1)) break;\n\t\td[i]=comb(n-2-(n-1-i),-i+(n-1));\n\t//\tcout<<n-2+(n-1-i)<<\" \"<<i-(n-1)<<endl;\n\t\t\n\t\td[i] *= pr[i];\n\t\td[i]%=inf;\n\t\td[i] *=pr[n-1-i];\n\t\td[i]%=inf;\n\t\td2[i]=d[i];\n\t//\tcout<<i<<\" \"<<d[i]<<endl;\n\t}\n\tfor(int i=1;i<=n-1;i++){\n\t\td[i]=(d[i]-d2[i-1]+inf)%inf;\n\t//\tcout<<i<<\" \"<<d[i]<<endl;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n-1;i++){\n\t\tans+=(i*d[i])%inf;\n\t\tans%=inf;\n\t}\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n        }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e9+7)\nll N;\nll m,ans,F[1010101];\nll i, j, k;\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\nint main(){\n    scanf(\"%lld\", &N);\n    F[0] = 1;\n    fornum(i,0,N+1){\n        F[i + 1] = F[i] * (i + 1) % MOD;\n    }\n    m = 0;\n    fornum(k,(N+1)/2,N){\n        ll a=moddiv(F[k-1],F[N-k-1]*F[k*2-N]);\n        a = a * F[k] % MOD;\n        a = a * F[N-1-k] % MOD;\n        ans = (ans + (MOD+a-m)%MOD*k%MOD) % MOD;\n        m = (a + m) % MOD;\n        //printf(\"%lld %lld %lld %lld\\n\",k, moddiv(F[k-1],F[N-k-1]*F[k*2-N]),F[N-1-k],ans);\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10,mod=1e9+7;\nint Fac[N],inv[N],n,f[N];\n\ninline int C(int n,int m){\n    return 1ll*Fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main(){\n  cin>>n;\n  int ans=0,li=(n+1)/2;\n  Fac[0]=inv[0]=inv[1]=1;\n  for(int i=1;i<=n;i++)Fac[i]=1ll*Fac[i-1]*i%mod;\n  for(int i=2;i<=n;i++)inv[i]=(mod-1ll*(mod/i)*inv[mod%i]%mod)%mod;\n  for(int i=2;i<=n;i++)inv[i]=1ll*inv[i]*inv[i-1]%mod;\n  for(int i=li;i<n;i++)f[i]=1ll*C(i-1,n-1-i)*Fac[i]%mod*Fac[n-1-i]%mod;\n  for(int i=n-1;i>=li;i--)f[i]=(f[i]-f[i-1]+mod)%mod;\n  for(int i=n-1;i>=li;i--)ans=(ans+1ll*i*f[i])%mod;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N;\nll fact[1000006];\nll init[1000006];\n\nll f(ll x){\n    ll ret = fact[x];\n    ret *= (x-1);\n    ret %= mod;\n    return ret;\n}\n\nint main(){\n    cin >> N;\n    assert(N%2==1);\n    if(N==2){\n        cout << 1 << endl;\n        return 0;\n    }\n    fact[1] = 1;\n    for(int i=2;i<=N;i++) fact[i] = fact[i-1] * i % mod;\n\n    // calc init\n    init[3] = 2;\n    for(ll i=5;i<=N+2;i+=2){\n        ll index = (i -3) / 2 + 2;\n        ll tmp = index * (index-1) % mod;\n        init[i] = init[i-2] * tmp % mod;\n    }\n    for(int i=3;i<=11;i+=2) cout << \"init \" << i << \"  --> \" << init[i] << endl;\n\n    ll ans;\n    if(N%2==1) ans = init[N];\n    else ans = init[N-1];\n\n    ans %= mod;\n\n    for(ll i=(N+1)/2+1;i<=N-1;i++){\n        ans += f(i);\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e6 + 5;\n\nint F[N], I[N];\n\nint Power(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1LL * a * a % MOD) if (b & 1) res = 1LL * res * a % MOD;\n\treturn res;\n}\nint C(int n, int k) { return k > n || k < 0 || n < 0 ? 0 : 1LL * I[k] * I[n - k] % MOD * F[n] % MOD; }\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\t\n\tF[0] = 1;\n\tfor (int i = 1; i < N; i++) F[i] = 1LL * F[i - 1] * i % MOD;\n\tI[N - 1] = Power(F[N - 1], MOD - 2);\n\tfor (int i = N - 1; i > 0; i--) I[i - 1] = 1LL * I[i] * i % MOD;\n\tint n; cin >> n;\n\tint ans = F[n];\n\tfor (int i = 1; i < n; i++) ans = (ans - 1LL * F[i] * F[n - 1 - i] % MOD * C(i - 1, n - 1 - i) % MOD + MOD) % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <string>\n#include <stack>\n#include <set>\n#include <sstream>\n#include <iomanip>\n#include <limits>\n#include <cstring>\n\nusing namespace std;\nusing ll = long long;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double >pd;\ntypedef pair<string, string> sP;\ntypedef pair<ll, pair<ll, ll>> PP;\n\n\nconst ll mod = 1e4;\nconst ll MOD = 1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll INF = 1 << 30;\nconst ll INF2 = 9e18;\nconst double INF3 = 9e14;\nconst double eps = 1e-10;\nconst double PI = 3.14159265358979323846;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nconst int tx[8] = { -1,0,1,-1,1,-1,0,1 }, ty[8] = { -1,-1,-1,0,0,1,1,1 };\n\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define pb push_back\n#define eb emplace_back\n#define fr first\n#define sc second\n\nll FACT[1001100] = { 0 }, IFACT[1001100] = { 0 };\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n\tll g = a;\n\tx = 1;\n\ty = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\nll invMod(ll a, ll m) {\n\tll x, y;\n\tif (extgcd(a, m, x, y) == 1) return (x + m) % m;\n\telse                         return 0;\n}\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x%MOD;\n\t\tx = x * x%MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nvoid inverse(ll N) {\n\tFACT[0] = 1;\n\tIFACT[0] = 1;\n\tfor (int i = 1;i <= N;i++) {\n\t\tFACT[i] = FACT[i - 1] * i % MOD;\n\t\tIFACT[i] = invMod(FACT[i], MOD);\n\t}\n}\nll combi(ll n, ll r) {\n\tif (n < 0 || r < 0 || r > n)return 0;\n\tif (r > n / 2)r = n - r;\n\treturn FACT[n] * IFACT[n - r] % MOD*IFACT[r] % MOD;\n}\n\nint main() {\t\n\tll n, ans = 0;\n\tcin >> n;\n\tinverse(n);\n\tif (n == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (n == 3) {\n\t\tcout << 4 << endl;\n\t\treturn 0;\n\t}\n\tll now = 0;\n\tfor (int i = (n + 1) / 2;i <= n - 1;i++) {\n\t\tll x= ((((combi(i - 1, n - i - 1)*FACT[i]) % MOD) * FACT[n - i - 1]) % MOD);\n\t\t//動かさない要素の選び方　動かす要素の順番　動かさない要素の順番\n\t\tans += (x - now + MOD)*i % MOD;\n\t\tnow = x;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// FUCKED UP FUCKED UP FUCKED UP FUCKED UP FUCKED UP\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=2e3+10, maxm=5e4+10, lg=21, mod=1e9+7, inf=1e18;\n\nstring s,t;\nll n,L[3*maxn],R[3*maxn];\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tmemset(L,69,sizeof(L)),memset(R,69,sizeof(R));\n\tcin>>s>>t; n=SZ(s);\n\tt=t+t+t;\n\tfor(int i=0;i<3*n;i++) L[i]=(t[i]=='1' ? 0:L[i-1]+1);\n\tfor(int i=3*n-1;i>=0;i--) R[i]=(t[i]=='1' ? 0:R[i+1]+1);\n\tif(R[0]>=inf){\n\t\tfor(int i=0;i<n;i++)if(s[i]=='1') return cout<<-1,0;\n\t\treturn cout<<0,0;\n\t}\n\tll ans=inf;\n\tfor(int d=-n;d<=n;d++){\n\t\tvector<pll> bb;\n\t\tll ek=0; for(int i=n;i<2*n;i++)if(s[i-n]!=t[i+d]) bb.pb({max(L[i]+min(d,0),0ll),max(R[i]-max(d,0),0ll)}), ek++;\n\t\tsort(all(bb));\n\t\tll mx=0; for(int i=SZ(bb)-1;i>=0;i--){\n\t\t\tans=min(ans,ek+2*(bb[i].F+mx)+abs(d));\n\t\t\tmx=max(mx,bb[i].S);\n\t\t}\n\t\tans=min(ans,ek+2*mx+abs(d));\n\t}\n\tcout<<ans;\n\t\n\treturn 0;\n}\n\n\n\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <string>\n#include <utility>\n#include <map>\n#include <deque>\n\nusing namespace std;\n#define rep(i,n) for(int i=1;i<=(int)(n);i++)\n#define Rep(i,n) for(int i=0;i<=(int)(n-1);i++)\ntypedef long long ll;\ntypedef map<int,int> mint;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\ntypedef deque<pair<ll,ll>> dep;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint inf=1e9+1000;\nconst int mod=1e9+7;\nll infi=1e18+100;\n\nll N;\n\n\nint main(){\n\tcin>>N;\n\tll ninzuu[N+1]={};\n\tll frac[N+3]={};\n\tfrac[0]=1;\n\tfor(ll i=1;i<=N;i++) frac[i]=i*frac[i-1];\n\tll sum=0;\n\tif(N%2==0){\n\t\tfor(ll i=N/2;i<=N-1;i++){\n\t\t\tif(i==N/2) ninzuu[i]=frac[i];\n\t\t\telse{\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\t}\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t}\n\telse{\n\t\tfor(ll i=(N+1)/2;i<=N-1;i++){\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t\t\n\t}\n\tcout<<(sum)%mod<<endl;\n\t\n\t\n\t\n\t  return 0;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<ll,ll> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-3;\nint dx[4]={0,1,0,1};\nint dy[4]={0,0,1,1};\nll f[1001000],fi[1001000];\nll mod_pow(ll x,ll n,ll mod){\n    ll ret=1;\n    while(n>0){\n        if(n&1){\n            ret=ret*x%mod;\n        }\n        x=x*x%mod;\n        n>>=1;\n    }\n    return ret;\n}\n \nvoid fact(ll n){\n\tf[0]=1;\n\tfor(ll i=1;i<=n;i++){\n\t\tf[i]=f[i-1]*i%MOD;\n\t}\n\tfi[n]=mod_pow(f[n],MOD-2,MOD);\n\tfor(ll i=n-1;i>=0;i--){\t\t\n\t\tfi[i]=fi[i+1]*(i+1)%MOD;\n\t}\n}\n \n \nll ncr(ll n,ll r){\n\tif(r==0){\n\t\treturn 1;\n\t}else{\n\t\treturn ((f[n]*fi[r])%MOD*fi[n-r])%MOD;\n\t}\n}\n\nint main(){\n\tll n;cin>>n;n--;\n\tfact(1000010);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tll ans=2*f[n]%MOD;\n\tll a=(n-2)/2;\n\tll b=(n-2)-a;\n\tfor(ll i=1;i<=max(a,b);i++){\n\t\tans+=(ncr(a,i)%MOD+ncr(b,i)%MOD)%MOD*f[n-i]%MOD*(n-i)%MOD;\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n\ntypedef long long ll;\n \ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.141592653589;\nconst int mod = 1000000007;\n// memset(a,0,sizeof(a)); →全部０にする\n \nvector<int> G[100005];\nstd::vector<P> tree[100010];\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\n\n#define p(x) cout<<x<<endl;\n \nll i,j,k,l,ii,jj;\nll n,m;\nll x,y;\nll used[200005];\nchar s[305][305];\nll ans=0;\nll v=-1,w;\nll num;\n\n\nll kai(ll n,ll x){\n\tll kei=1;\n\tfor(i=1;i<=n-x;i++){\n\t\tkei *= i;\n\t\tkei = kei%mod;\n\t}\n\treturn kei;\n\n}\nvoid kotae(ll x){\n\tfor(int i=1;i<=n;i++){\n\t\tif(!used[i]){\n\t\t\tused[i]=true;\n\t\t\tif(!used[i-1] && !used[i+1] && i>=2 && i<=n-1){\n\t\t\t\tkotae(x+1);//iminasi kakutei\n\t\t\t}else{\n\t\t\t\tans += kai(n,x);\n\t\t\t}\n\t\t\tused[i]=false;\n\t\t}\n\t}\n \n}\nint main(){\n    cin>>n;\n\t\n\n\tkotae(0);\n\t\n\tp(ans%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=1e6+10,mod=1e9+7;\nint n;\nll ans,fac[maxn],finv[maxn];\n\ninline ll c(ll n,ll m){\n\tif(n<0||m<0||n-m<0)\n\t\treturn 0;\n\treturn fac[n]*finv[m]%mod*finv[n-m]%mod;\n}\ninline ll calc(int x){\n\treturn c(x-1,n-1-x)*fac[x]%mod*fac[n-1-x]%mod;\n}\n\nint main(){\n\tcin>>n;\n\tfac[0]=1;for(int i=1;i<=n;++i)fac[i]=fac[i-1]*i%mod;\n\tfinv[0]=finv[1]=1;for(int i=2;i<=n;++i)finv[i]=(mod-mod/i)*finv[mod%i]%mod;\n\tfor(int i=1;i<=n;++i)finv[i]=finv[i-1]*finv[i]%mod;\n\tfor(int i=1;i<=n-1;++i)\n\t\t(ans+=(calc(i)-calc(i-1)+mod)%mod*i)%=mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\nSXR0aXAkI0JwbXptI3FhI3Z3I293bCNqY2IjUG0jMCNicG0jVHFkcXZvLyNCcG0jQW10bjBhY2phcWFicXZvLyNNYm16dml0MSNWdyNhdGN1am16I2tpdiNhbXF9bSNQcXUjVnd6I0F0bW14MSNQcWEjaXptI2l0dCNicHF2b2EjUXYjYnBtI3BtaWRtdmEjaXZsI3d2I21pemJwMSNFcHcjcWEjYnBtem0ja2l2I3F2Ym16a21sbSNRdiNQcWEjeHptYW12a20jbXtrbXhiI0lhI3BtI3htenVxYmJtYnBHI1BtI3N2d2VtYnAjRXBpYiMraXh4bWl6bWJwI2J3I1BxYSNrem1pYmN6bWEjSWEsI0ptbnd6bSN3eiNJbmJteiN3eiNKbXBxdmwjYnBtdTEjVnd6I2FwaXR0I2JwbXwja3d1eGlhYSNJY29wYiN3biNwcWEjc3Z3ZXRtbG9tI017a214YiNpYSNQbSNlcXR0bWJwMSNQcWEjYnB6d3ZtI2x3YnAjbXtibXZsI1dkbXojYnBtI3BtaWRtdmEjSXZsI3d2I21pemJwLyNpdmwjUG0jbm1tdG1icCNWdyNuaWJxb2NtI3F2I29jaXpscXZvI0l2bCN4em1hbXpkcXZvI2JwbXUvI053eiNQbSNxYSNicG0jVXdhYiNQcW9wMSNCcG0jQWN4em11bSMrcXYjb3R3enwsMQ==\n*/\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\n#define F first\n#define S second\n#define endl '\\n'\n#define deb(x) cout<<#x<<' '<<x<<endl;\n#define pb push_back\n\n\n#ifdef IZI_KATKA\n#define int __int64_t\n#else\n#define int __int64_t\n#endif\n\nconst long long MOD = 1e9 + 7;\nconst long long MAXN = 2e6 + 1;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n\nlong long readInt() {\n    bool minus1 = false;\n    long long result = 0;\n    char ch;\n    ch = getchar();\n    while (true) {\n        if (ch == '-') break;\n        if (ch >= '0' && ch <= '9') break;\n        ch = getchar();\n    }\n    if (ch == '-') minus1 = true; else result = ch-'0';\n    while (true) {\n        ch = getchar();\n        if (ch < '0' || ch > '9') break;\n        result = result*10 + (ch - '0');\n    }\n    if (minus1)\n        return -result;\n    else\n        return result;\n}\n\n\nint mul(int a, int b)\n{\n\treturn (ll)a * b % MOD;\n}\n\n\nint binpow(int a, int n) {\n\tif (n == 1){ \n\t\treturn a;\n\t}\n\tif (n % 2 == 0) {\n\t\tint x = binpow(a, n / 2);\n\t\treturn mul(x, x);\n\t}\n\treturn mul(a, binpow(a, n - 1));\n}\n\nint fact[MAXN];\n\n\n\nint C(int n, int k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (k > n) return 0;\n\tint res = mul(fact[n - k], fact[k]);\n\treturn mul(fact[n], binpow(res, MOD - 2));\n}\n\nmain() {\n\t#ifdef IZI_KATKA\n\tassert(freopen(\"input\", \"r\", stdin));\n    assert(freopen(\"output\", \"w\", stdout));\n    #endif\n    int n = readInt();\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n\t\tfact[i] = mul(fact[i - 1], i);\n\t}\n    n--;\n    int ans = mul(n, fact[n]);\n    for (int i = 1; i < n; i++) {\n\t\tans -= mul(mul(fact[i], fact[n - i]), C(i - 1, n - i));\n    \tif (ans < 0)\n    \tans+= MOD;\n    }\n    cout << (ans+MOD)%MOD;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 1e6 + 5;\ntypedef long long ll;\n\nint inm(int x, int y, int z=1) { return (ll)x*y%Mod*z%Mod; }\nvoid inm_to(int &x, int y) { x = (ll)x*y%Mod; }\nvoid add_to(int &x, int y) { x+=y; if(x>=Mod) x-=Mod; }\n\nint fact[Nmax], ifact[Nmax], dp[Nmax];\nint n, i;\n\n\nint power(int a, int b)\n{\n    int ans = 1;\n    while(b)\n    {\n        if(b&1) inm_to(ans, a);\n        inm_to(a, a); b >>= 1;\n    }\n    return ans;\n}\n\nint comb(int n, int k)\n{\n    if(n < 0 || n < k || k < 0) return 0;\n    return inm(fact[n], ifact[k], ifact[n-k]);\n}\n\nint main()\n{\n //   freopen(\"input\", \"r\", stdin);\n\n    cin >> n;\n\n    fact[0] = ifact[0] = 1;\n    for(i=1; i<=n; ++i) fact[i] = inm(fact[i-1], i);\n    ifact[n] = power(fact[n], Mod-2);\n    for(i=n-1; i; --i) ifact[i] = inm(ifact[i+1], i+1);\n\n    for(i=1; i<n; ++i)\n    {\n        dp[i] = comb(i-1, 2*i-n);\n        inm_to(dp[i], inm(fact[i], fact[n-i-1]));\n    }\n\n\n    for(i=n-1; i; --i)\n        add_to(dp[i], Mod - dp[i-1]);\n\n    int ans = 0;\n    for(i=1; i<n; ++i)\n        add_to(ans, inm(dp[i], i));\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll p=1e9+7;\nll n,ans,jc[1000010],ny[1000010],f[1000010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nll C(ll x,ll y){\n\tif(x<y)return 0;\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nint main(){\n\tll i;\n\tscanf(\"%lld\",&n);\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=n;i++)jc[i]=jc[i-1]*i%p;\n\tny[n]=ksm(jc[n],p-2);\n\tfor(i=n-1;i;i--)ny[i]=ny[i+1]*(i+1)%p;\n\tn--;\n\tfor(i=1;i<=n;i++){\n\t\tf[i]=C(i-1,n-i)*jc[i]%p*jc[n-i]%p;\n\t}\n\tfor(i=n;i;i--){\n\t\tf[i]=(f[i]-f[i-1]+p)%p;\n\t\tans=(ans+f[i]*i)%p;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int N=1e6+5, mod=1e9+7;\nLL n,fac[N],inv[N],tot,Ans;\n\nLL qpow(LL x,int y)\n{\n\tLL ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod, y>>=1;\n\t}\n\treturn ret; \n}\nLL C(int x,int y) {return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nLL calc(int x) {return C(n-2-x,x)%mod*fac[n-1-x]%mod*fac[x]%mod;}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n < 5)\n\t{\n\t\tif(n == 2) puts(\"1\");\n\t\tif(n == 3) puts(\"4\");\n\t\tif(n == 4) puts(\"16\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<N;++i) fac[i]=fac[i-1]*i%mod;\n\tinv[N-1]=qpow(fac[N-1],mod-2);\n\tfor(int i=N-2;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;\n\tint tmp=(n-2)/2;\n\tfor(int i=tmp;i>=0;--i)\n\t{\n\t\ttot=calc(i)-calc(i+1);\n\t\tAns+=tot*(n-i-1)%mod, Ans%=mod;\n\t}\n\t//cout<<Ans<<endl;\n\tAns+=mod, Ans%=mod;\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint fact[1000005], fact_i[1000005];\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 1000005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 1000005; i++){\n\t\tfact_i[i] = pow(fact[i], mod-2);\n\t}\n}\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_i[k], ret %= mod;\n\tret *= fact_i[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint func(llint N, llint r)\n{\n\tllint batsu = N-r;\n\treturn comb(N+1-batsu, batsu) % mod;\n}\n\nllint N;\n\nint main(void)\n{\n\tcin >> N;\n\tif(N == 2){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmake_fact();\n\t\n\tllint ans = 0;\n\tfor(int i = N/2; i <= N-1; i++){\n\t\tllint cnt = 0;\n\t\tif(N >= 3) cnt += func(N-3, i-2) * 2;\n\t\tif(N >= 7) cnt += (func(N-7, i-5) * 2*(N-6)) % mod, cnt %= mod;\n\t\tif(N >= 6) cnt += (func(N-6, i-4) * 4*(N-5)) % mod, cnt %= mod;\n\t\tif(N >= 8) cnt += (func(N-8, i-5) * (N-7)) % mod, cnt %= mod;\n\t\tif(N >= 7) cnt += (func(N-7, i-4) * 2*(N-6)) % mod, cnt %= mod;\n\t\tif(N == 5 && i == 3) cnt += 2;\n\t\tif(N == 6 && i == 3) cnt += 3;\n\t\tcnt *= fact[i-1] % mod, cnt %= mod;\n\t\tcnt *= fact[(N-1)-i] % mod, cnt %= mod;\n\t\tans += (cnt * i) % mod, ans %= mod;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\nusing namespace std;\n\nlong long modinv(long long a, long long m) {\n    long long x = m, y = a, p = 1, q = 0, r = 0, s = 1;\n    while (y != 0) {\n        long long u = x / y;\n        long long x0 = y; y = x - y * u; x = x0;\n        long long r0 = p - r * u, s0 = q - s * u;\n        p = r; r = r0; q = s; s = s0;\n    }\n    return q < 0 ? q + m : q;\n}\n\nint main() {\n    int n; cin >> n;\n    const int M = 1000000007;\n    long long f[n+1], fi[n+1];\n    f[0] = fi[0] = 1;\n    for (int i = 1; i <= n; i++)\n        f[i] = i * f[i-1] % M;\n    fi[n] = modinv(f[n], M);\n    for (int i = n-1; i > 0; i--)\n        fi[i] = (i+1) * fi[i+1] % M;\n    long long ans = (n - 1) * f[n-1] % M;\n    for (int k = 1; 2 * (k + 1) <= n; k++) {\n        ans -= f[n-k-2] * fi[n-2*k-2] % M * f[n-k-1] % M;\n    }\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<boost/multiprecision/cpp_int.hpp>\nusing namespace std;\nusing bigint = boost::multiprecision::int128_t;\n\nbigint M = 1000000007, m = 335790106025098313, n = 489373567, mask = 1152921504606846975;\n\ninline bigint MR(bigint A){\n    return (A + M * (m * A & mask)) >> 60;\n}\n\ninline bigint Prod(bigint lhs, bigint rhs){\n    return MR(MR(lhs * rhs) * n);\n}\n\nlong long int N;\nbigint fact[10010101], ifact[10010101], ans;\n\nint main(){\n    scanf(\"%lld\", &N);\n    fact[0] = 1;\n    for(int i = 1; i < N; ++i){\n        fact[i] = Prod(fact[i - 1], i);\n    }\n    bigint n = M - 2, r = fact[N - 1];\n    ifact[N - 1] = 1;\n    while(n){\n        if(n & 1){\n            ifact[N - 1] = ifact[N - 1] * r % M;\n        }\n        n /= 2;\n        r = r * r % M;\n    }\n    for(int i = N - 1; i > 0; --i){\n        ifact[i - 1] = Prod(ifact[i], i);\n    }\n    ans = fact[N - 1] * (N - 1);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += M - Prod(Prod(fact[i], fact[i - 1]), ifact[i * 2 - N]);\n    }\n    ans %= M;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\n// using mint = ld;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\nstruct Factorial {\n  const int MAX;\n  vector<mint> fac, finv;\n  Factorial(int M) : MAX(M), fac(M, 1), finv(M, 1) {\n    rep2(i, 2, MAX) fac[i] = fac[i-1] * i;\n    finv[MAX-1] /= fac[MAX-1];\n    drep2(i, MAX, 3) finv[i-1] = finv[i] * i;\n  }\n};\nFactorial fc(int(1e6)+3);\n\nmint binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fc.fac[n] * fc.finv[k] * fc.finv[n-k];\n}\n\n\n\nint main() {\n  int n; cin >> n;\n\n  mint ans = 0;\n  rep2(m, 1, n) {\n    mint res = 0;\n    rep(l, min(m+1, n-m)) res += binom(n-m-1, l) * binom(m+1, l+1) / (l+m+1);\n    if (m&1) ans += res;\n    else ans -= res;\n  }\n  if (n&1) ans += mint(1) / n;\n  else ans -= mint(1) / n;\n\n\n\n  rep2(i, 1, n+1) ans *= i;\n\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int L = 1e6 + 10;\nconst int M = 1e9 + 7;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint fact[L];\nint rfact[L];\n\nint ncr(int n, int k) {\n    if (k < 0 || k > n)\n        return 0;\n    return (ll) fact[n] * rfact[k] % M * rfact[n - k] % M;\n}\n\nconst int N = 15;\n\nint f[N][N];\n\nvoid smain() {\n\n    fact[0] = 1;\n    for (int i = 1; i < L; ++i) {\n        fact[i] = (ll) fact[i - 1] * i % M;\n    }\n    rfact[L - 1] = pw(fact[L - 1]);\n    for (int i = L - 2; i >= 0; --i) {\n        rfact[i] = (ll) rfact[i + 1] * (i + 1) % M;\n    }\n\n//    f[1][1] = 1;\n//    for (int i = 2; i < N; ++i) {\n//        for (int j = 2; j < N; ++j) {\n//            f[i][j] = f[i - 1][j - 1] + f[i - 2][j - 1];\n//            cout << f[i][j] - 1 * ncr(j - 1, i - j) << ' ';\n//        }\n//        cout << '\\n';\n//    }\n\n\n\n\n    int n;\n    cin >> n;\n    n--;\n    vi g(n + 1);\n    int ans = 0;\n    ll sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        g[i] = ncr(i - 1, n - i);\n//        g[i] = f[n][i];\n        g[i] = (ll) g[i] * fact[i] % M * fact[n - i] % M;\n//        for (int j = 1; j < i; ++j) {\n//            g[i] = (g[i] - g[j] + M) % M;\n//        }\n        g[i] = (g[i] - sum) % M;\n        sum = (sum + g[i]) % M;\n//        cerr << \"g[\" << i << \"] = \" << g[i] << endl;\n        int cur = (ll) g[i] * i % M;\n        ans = (ans + cur) % M;\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=1000000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 1000000007\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n    #define N 1000000\n\n    int fac[N+100],invfac[N+100];\n\n    int add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n    int dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n    int mul(int x,int y) {return 1ll*x*y%maxd;}\n    ll qpow(ll x,int y)\n    {\n        ll ans=1;\n        while (y)\n        {\n            if (y&1) ans=mul(ans,x);\n            x=mul(x,x);y>>=1;\n        }\n        return ans;\n    }\n    int getinv(int x) {return qpow(x,maxd-2);}\n\n    int C(int n,int m)\n    {\n        if ((n<m) || (n<0) || (m<0)) return 0;\n        return mul(mul(fac[n],invfac[m]),invfac[n-m]);\n    }\n\n    void math_init()\n    {\n        fac[0]=invfac[0]=1;\n        rep(i,1,N) fac[i]=mul(fac[i-1],i);\n        invfac[N]=getinv(fac[N]);\n        per(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n    }\n    #undef N\n}\nusing namespace My_Math;\n\nint n,f[N],g[N];\n\nint main()\n{\n    n=read();\n    math_init();\n    rep(i,(n+1)>>1,n-1) f[i]=mul(C(i-1,n-i-1),mul(fac[i],fac[n-1-i]));\n    int ans=0;\n    rep(i,1,n-1) g[i]=dec(f[i],f[i-1]);\n    rep(i,1,n-1) ans=add(ans,mul(i,g[i]));\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2000 * 1000 + 17;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\nint n;\nlong long a[N], r[N], F[N], rF[N];\n\nbool read() {\n    if (!(cin >> n))\n        return false;\n\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n\n    return true;\n}\n\nvoid solve() {\n    F[0] = rF[0] = F[1] = rF[1] = r[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        r[i] = (MOD - (MOD / i) * r[MOD % i] % MOD) % MOD;\n        F[i] = i * F[i - 1] % MOD;\n        rF[i] = r[i] * rF[i - 1] % MOD;\n    }\n\n    auto ans = 0ll;\n\n    for (int k = (n + 1) / 2; k < n; ++k)\n        ans += F[k] * F[k - 1] % MOD * rF[2 * k - n] % MOD;\n\n    cout << (MOD + F[n] - ans % MOD) % MOD << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define pii pair<ll,ll>\n#define mkp make_pair\n#define fi first\n#define sc second\n#define gc getchar\n#define pb push_back\nusing namespace std;\nconst int N=1e6+10,mod=1e9+7;\ntypedef double db;\n\nint n,frc[N],nv[N],ans;\n\ninline void ad(int &x,int y){x+=y;if(x>=mod) x-=mod;}\ninline int dc(int x,int y){x-=y;return x<0?x+mod:x;} \n\ninline int C(int n,int m)\n{\n\tif(m<0 || m>n) return 0;\n\tif(n==m || m==0) return 1;\n\treturn (ll)frc[n]*nv[m]%mod*(ll)nv[n-m]%mod;\n}\n\nint main(){\n\tint i,j,x;frc[0]=frc[1]=nv[0]=nv[1]=1;\n    scanf(\"%d\",&n);\n    for(i=2;i<=n;++i) \n\t  frc[i]=(ll)frc[i-1]*i%mod,\n\t  nv[i]=(ll)(mod-mod/i)*nv[mod%i]%mod;\n\tfor(i=2;i<=n;++i) nv[i]=(ll)nv[i]*nv[i-1]%mod;\n\tans=frc[--n];\n\tfor(i=1;i<n;++i){\n\t\tad(ans,(ll)dc(C(n,i),C(i-1,(i<<1)-n-1))*frc[i]%mod*(ll)frc[n-i]%mod);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ninline int read() {\n  int f = 1;\n  int x = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    f = (ch == '-') ? -1 : 1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return f * x;\n}\n\nconst int N = 1e6 + 5;\nconst int P = 1e9 + 7;\n\ninline int mul(int a, int b) {\n  return (long long) a * b % P;\n}\ninline int sub(int a, int b) {\n  return a - b < 0 ? a - b + P : a - b;\n}\ninline int add(int a, int b) {\n  return a + b >= P ? a + b - P : a + b;\n}\ninline int modexp(int a, int x) {\n  int ret = 1;\n  while (x) {\n    if (x & 1) {\n      ret = mul(ret, a);\n    }\n    a = mul(a, a);\n    x >>= 1;\n  }\n  return ret;\n}\n\nint n;\nint fac[N];\nint inv[N];\n\ninline int calc(int m, int n) {\n  int k = 2 * m - n;\n  if (k >= 0 && m - k >= 0) {\n    return mul(fac[m], mul(inv[k], inv[m - k]));\n  } else {\n    return 0;\n  }\n}\n\ninline int C(int n, int m) {\n  return mul(fac[n], mul(inv[m], inv[n - m]));\n}\n\nint main() {\n  n = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  inv[n] = modexp(fac[n], P - 2);\n  for (int i = n - 1; i >= 0; --i) {\n    inv[i] = mul(inv[i + 1], i + 1);\n  }\n  int ans = mul(fac[n - 1], n);\n  for (int i = (n + 1) / 2; i < n; ++i) {\n    ans = sub(ans, mul(fac[n - i - 1], mul(C(i - 1, n - i - 1), fac[i])));\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long ll;\n \ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.141592653589;\nconst int mod = 1000000007;\n// memset(a,0,sizeof(a)); →全部０にする\n \nvector<int> G[100005];\nstd::vector<P> tree[100010];\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\n \n#define p(x) cout<<x<<endl;\n \nll i,j,k,l,ii,jj;\nll n,m;\nll x,y;\nll used[200005];\nchar s[305][305];\nll ans=0;\nll v=-1,w;\nll num;\n \n \nll kai(ll n,ll x){\n\tll kei=1;\n\tfor(i=1;i<=n-x;i++){\n\t\tkei *= i;\n\t\tkei = kei%mod;\n\t}\n\treturn kei;\n \n}\nvoid kotae(ll x){\n\tfor(int i=1;i<=n;i++){\n\t\tif(used[i])continue;\n\t\telse{\n\t\t\tused[i]=true;\n\t\t\tif(!used[i-1] && !used[i+1] && i>=2 && i<=n-1){\n\t\t\t\tkotae(x+1);//iminasi kakutei\n\t\t\t}else{\n\t\t\t\tans += kai(n,x);\n\t\t\t}\n\t\t\tused[i]=false;\n\t\t}\n\t}\n \n}\nint main(){\n    cin>>n;\n\t\n\tfor(i=1;i<=n;i++){\n\t\tused[i]=true;\n\t\tkotae(1);\n\t\tused[i]=false;\n \n\t}\n\tp(ans%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long \nusing namespace std;\nconst int MAXN = 1e6 + 10, INF = 1e9 + 7, mod = 1000000007;\ntemplate<typename A, typename B> inline void chmax(A &x, B y) {\n\tx = x > y ? x : y;\n}\ntemplate<typename A, typename B> inline void chmin(A &x, B y) {\n\tx = x < y ? x : y;\n}\ntemplate<typename A, typename B> inline int mul(A x, B y) {\n\treturn 1ll * x * y % mod;\n}\ntemplate<typename A, typename B> inline void add2(A &x, B y) {\n\tif(x + y < 0) x = x + y + mod;\n\telse x = (x + y >= mod ? x + y - mod : x + y);\n}\ntemplate<typename A, typename B> inline int add(A x, B y) {\n\tif(x + y < 0) return x + y + mod;\n\telse return x + y >= mod ? x + y - mod : x + y;\n}\ntemplate<typename A, typename B> inline int fp(A a, B p) {\n\tint base = 1;\n\twhile(p) {\n\t\tif(p & 1) base = mul(base, a);\n\t\ta = mul(a, a); p >>= 1;\n\t}\n\treturn base;\n}\ninline int read() {\n\tchar c = getchar(); int x = 0, f = 1;\n\twhile(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * f;\n}\nint N, fac[MAXN], ifac[MAXN], f[MAXN];\nint C(int N, int M) {\n\tif(M > N) return 0;\n\treturn mul(fac[N], mul(ifac[M], ifac[N - M]));\n}\nint main() {\n\tN = read(); fac[0] = 1;\n\tfor(int i = 1; i <= N; i++) fac[i] = mul(i, fac[i - 1]);\n\tifac[N] = fp(fac[N], mod - 2);\n\tfor(int i = N; i >= 1; i--) ifac[i - 1] = mul(ifac[i], i);\n\tint down = N / 2 + (N & 1);\n\tfor(int i = down; i < N; i++) \n\t\tf[i] = mul(mul(C(i - 1, N - i - 1), fac[i]), fac[N - i - 1]);\n\tint ans = 0;\n\tfor(int i = down; i < N; i++) add2(ans, mul(i, add(f[i], -f[i - 1])));\n\tcout << ans;\n\treturn 0;\n}\n/*\n3\n0 1 1\n5 7 3\n*/"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst int NUM_=1e6+10;\nll fact[NUM_+1]={},factr[NUM_+1]={},inv[NUM_+1]={};\n\nll combi(ll N_, ll C_, ll mo=MOD) {\n  auto binpow = [&](ll x, ll e) -> ll{\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % mo; e /= 2;}\n      else {a = (a*p) % mo; e--;}\n    }\n    return a;\n  };\n  if (fact[0]==0) {\n    fact[0] = factr[0] = inv[0] = 1;\n    // FOR(i, 1, NUM_+1) fact[i] = fact[i-1] * i % MOD;\n    // factr[NUM_] = binpow(fact[NUM_], mo-2);\n    // for(int i=NUM_-1; i>=0; --i) factr[i] = factr[i+1] * (i+1) % MOD;\n    FOR(i, 1, NUM_) {\n      fact[i] = fact[i-1] * i % MOD;\n      inv[i] = binpow(i, MOD-2) % MOD;\n      factr[i] = factr[i-1] * inv[i] % MOD;\n    }\n  }\n  if(C_<0 || C_>N_) return 0;\n  // 前計算 O(max(N,K)) クエリ O(1)\n  return factr[C_]*fact[N_]%MOD*factr[N_-C_]%MOD;\n  // 前計算 O(max(N,K)log(mod)) クエリ O(K)\n  // ll ret = 1;\n  // for(;C_>0;N_--,C_--) (ret *= N_%MOD) %= MOD, (ret *= inv[C_]) %= MOD;\n  // return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  if(n == 2) {\n    cout << 1 << endl;\n    return 0;\n  }\n  if(n == 3) {\n    cout << 4 << endl;\n    return 0;\n  }\n  if(n == 4) {\n    cout << 16 << endl;\n    return 0;\n  }\n\n  int a = 0, ret = 0;\n  REP(i, n) {\n    int tmp = combi(i-1, n-i-1) * fact[i] % MOD * fact[n-i-1] % MOD;\n    tmp -= a;\n    tmp = (tmp%MOD+MOD)%MOD;\n    (ret += i*tmp%MOD) %= MOD;\n    (a += tmp) %= MOD;\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n\nusing namespace std;\n\nint n;\nlong long ans = 0;\nconst long long N = 1e6 + 5;\nconst long long mod = 1e9 + 7;\nlong long fact[3 * N];\nlong long a[N];\nlong long ps[N];\n\nvoid pre()\n{\n\tfact[0] = 1;\n\tfor (long long i = 1; i < N; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i;\n\t\tfact[i] = fact[i] % mod;\n\t}\n}\n\nlong long power(long long a, long long b)\n{\n\tif (b == 0)\n\t{\n\t\treturn 1;\n\t}\n\tlong long ans = power(a, b / 2);\n\tans = ans * ans;\n\tans = ans % mod;\n\tif (b % 2)\n\t{\n\t\tans = ans * a;\n\t}\n\tans = ans % mod;\n\treturn ans;\n}\n\nlong long choose(long long a, long long b)\n{\n\tif (b < 0 || a < b)\n\t{\n\t\treturn 0;\n\t}\n\tlong long ans = fact[a];\n\tans = ans * power(fact[b], mod - 2);\n\tans = ans % mod;\n\tans = ans * power(fact[a - b], mod - 2);\n\tans = ans % mod;\n\treturn ans;\n}\n\n\n\nint main() \n{\n\n\tpre();\n\tcin >> n;\n\tif (n == 2)\n\t{\n\t\tcout << 1;\n\t\texit(0);\n\t}\n\tfor (int i = 2; i < n; i++) \n\t{\n\t\ta[i] = choose(i - 1, n - 1 - i);\n\t\ta[i] *= fact[n - i - 1];\n\t\ta[i] %= mod;\n\t\ta[i] *= fact[i];\n\t\ta[i] %= mod;\n\t\ta[i] -= ps[i - 1];\n\t\ta[i] += mod;\n\t\ta[i] %= mod;\n\t\tps[i] = ps[i - 1] + a[i];\n\t\tps[i] %= mod;\n\t\tans += a[i] * i;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\n\n\n\n\t\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint MOD = 1000000007;\nvector<int> fact;\nint pw(int a, int b){\n    if (b==0) return 1;\n    if (b==1) return a%MOD;\n    if (b%2){\n        int rs = pw(a, b-1);\n        return (a*rs) %MOD;\n    }\n    int rs = pw(a, b/2);\n    return (rs*rs) %MOD;\n}\nint C(int n, int k){\n    int X = fact[n];\n    int Y = (fact[k] * fact[n-k]) % MOD;\n    return (X*pw(Y, MOD-2)) % MOD;\n}\nint calc(int n){\n    vector<int> v;\n    for (int i=0; i < n-1; i++) v.push_back(i);\n    int ans =0 ;\n    vector<int> st(n);\n    do {\n        vector<bool> x(n);\n        fill(x.begin(), x.end(), false);\n        int k = n;\n        for (int i=0; i < n; i++){\n            if (!x[v[i]]) k--;\n            if (!x[v[i] + 1]) k--;\n            x[v[i]] = true;\n            x[v[i]+1] = true;\n            if (!k){\n                ans += i+1;\n                st[i+1]++;\n                if (i+1==3){\n                    cout << v[0] << \" \" << v[1] << \" \" << v[2] << endl;\n                }\n                break;\n            }\n        }\n    }\n    while (next_permutation(v.begin(), v.end()));\n    for (int i=0; i < n; i++) cout << st[i]*i << \" \";\n    cout << endl;\n    return ans;\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    //cout << calc(n) << endl;\n    fact.push_back(1);\n    for (int i=1; i < 2e6; i++) fact.push_back((fact.back() * i) % MOD);\n    if (n==2){\n        cout << 1 << endl;\n        return 0;\n    }\n    int nole = 1;\n    int ans = 0;\n    while (true){\n        if (n-1-2*nole <= 0) break;\n        int X = C(n-3-nole, nole-1) * (nole+1);\n        if (n-2-2*nole > 0) X += C(n-3-nole, nole) * (nole+1) * 2;\n        X %= MOD;\n        X *= fact[n-2-nole];\n        X %= MOD;\n        X *= (n-1-nole);\n        X %= MOD;\n        X *= fact[nole];\n        X %= MOD;\n        ans += X;\n        nole++;\n    }\n    ans += 2 * fact[n-1];\n    ans %= MOD;\n    cout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: Dynamic JQ\n\nProblem:\n\nTime & Date(start):\n\nVerdict:\n\nTags:\n*/\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nLL fac[1000005];\nLL inv(LL x)\n{\n\tint t = MOD - 2;\n\tLL ret = 1LL;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = ret * x % MOD;\n\t\tx = x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tLL ans = 0LL;\n\tscanf(\"%d\", &n);\n\tn --;\n\tfac[0] = 1LL; rep1(i, n) fac[i] = fac[i - 1] * i % MOD;\n\tfor(int i = 0; i * 2 <= n - 3; i ++)\n\tans = (ans + (n - 2 - i) * ((fac[n - 3 - i] * fac[n - 1 - i] % MOD) * inv(fac[n - 3 - 2 * i]) % MOD)) % MOD;\n\tans = (fac[n] * n - ans + MOD) % MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\n#define mod 1000000007\n\nlong long inv[1000010];\nlong long fac[1000010];\nlong long invfac[1000010];\n\nlong long x[1000010];\n\nvoid getinv(){\n  for (int i = 1; i < 1000010; i++) {\n    if (i == 1) inv[i] = 1;\n    else {\n      inv[i] = (mod - (mod / i) * inv[mod % i]) % mod;\n      if (inv[i] < 0) inv[i] += mod;\n    }\n  }\n}\n\nvoid getfac(){\n  fac[0] = 1; invfac[0] = 1;\n  for (int i = 1; i < 1000010; i++) {\n    fac[i] = fac[i-1] * i; invfac[i] = invfac[i-1] * inv[i];\n    fac[i] %= mod; invfac[i] %= mod;\n    if (invfac[i] < 0 || fac[i] < 0) cout << \"a\" << endl;\n  }\n}\n\nint main(){\n  int n; cin >> n;\n  getinv();\n  getfac();\n  int m = n - 1;\n  long long s = 0;\n  for (int i = 1; i <= m; i++) {\n    if (i - 1 < m - i) x[i] = 0;\n    else {\n      x[i] = fac[i-1] * invfac[m-i];\n      x[i] %= mod;\n      x[i] *= invfac[2*i-m-1];\n      x[i] %= mod;\n      x[i] *= fac[i];\n      x[i] %= mod;\n      x[i] *= fac[m-i];\n      x[i] %= mod;\n    }\n    x[i] += mod - s; x[i] %= mod;\n    s += x[i]; s %= mod;\n    //printf(\"%d\\t%lld\\n\", i, x[i]);\n  }\n  long long ans = 0;\n  for (int i = 1; i <= m; i++) {\n    ans += (x[i] * i) % mod;\n    ans %= mod;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\n#include<unordered_set>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 0x2aaaaaaa; // 715,827,882\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\nll solve(int n) {\n\tint p[20];\n\tbool u[20];\n\trep(i, n-1) p[i] = i;\n\tll ret = 0;\n\tdo {\n\t\tmemset(u, 0, n);\n\t\tint c = 0;\n\t\trep(i, n - 1) {\n\t\t\tif (!u[p[i]]) {\n\t\t\t\tu[p[i]] = true; ++c;\n\t\t\t}\n\t\t\tif (!u[p[i]+1]) {\n\t\t\t\tu[p[i]+1] = true; ++c;\n\t\t\t}\n\t\t\tif (c == n) {\n\t\t\t\tret += i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (next_permutation(p, p+n-1));\n\treturn ret;\n}\n\n\n\n\nll ret[] = {\n\t0,\n\t0\t\t\t,\n\t1\t\t\t,\n\t4\t\t\t,\n\t16\t\t\t,\n\t84\t\t\t,\n\t516\t\t\t,\n\t3696\t\t,\n\t30096\t\t,\n\t275040\t\t,\n\t2786400\t\t,\n\t31000320\t,\n\t375736320\t,\n\t4928152320\t,\n\t69545952000LL\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tif (n > 13) cout << ret[1145141919] << endl;\n\telse cout << ret[n]%1000000007 << endl;\n\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nconst int MAX = 2000000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(){\n  int N; cin >> N; ll fact[N+10]; fact[0] = 1;\n  rep(i, N+9){\n    fact[i+1] = fact[i]*(i+1)%mod;\n  }\n  COMinit();\n  ll ans = fact[N-1]*(N-1)%mod;\n  if(N%2==0){\n    int k = 0;\n    for(int i=(N-3); i>=(N-2)/2; i--){\n      ans-=((COM(i, k)*fact[i+1])%mod)*fact[N-i-2]%mod; \n      if(ans<0) ans+=mod; ans%=mod; k++;\n    }\n    cout << ans << endl; return 0;\n  }\n  int k = 1;\n  for(int i=(N-3); i>=N/2; i--){\n    ans-=((COM(i, k)*fact[i+1])%mod)*fact[N-i-2]%mod;\n    if(ans<0) ans+=mod; ans%=mod; k++;\n  }\n  cout << ans << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 1000000007\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\nint main(int argc, char const *argv[]) {\n  init();\n  // dp[i][j] := iまで塗った時点でjグループ(何個使ったかわかる)\n  // x = (i-j)\n  // 使った数、 最後の一つの候補、 fact、 余り\n  ll n;std::cin >> n;\n  ll ans = 0;\n\n  if(n>10000) exit(1);\n  for(ll g=1;g<=n/2;g++){\n    ll x = n - g;\n    ll ml = pp(pp(x, fac[x-1]), fac[n-1-x]);\n    ll las = 0;\n\n    // 使った数、順番の自由なx-1個、 余ったもの * ∑[全パターン] last候補\n    //0がいくつあるか\n    for(int j=0;j<=g;j++){\n      ll num = n - 2*g;\n      ll amari = g - j;\n      ll tmp;\n      if(n==2*j&&j==g) tmp = j;\n      else{\n        if(amari==0) continue;\n        num -= amari;\n        //num個をamari個の0以上のものに分ける\n        tmp = comb(num+amari-1, num);\n        tmp = pp(tmp, comb(g, j));\n        tmp = pp(tmp, 2*amari+j);\n      }\n      las = (las + tmp)%P;\n    }\n    ans = (ans + pp(ml, las))%P;\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static const AlgStruct idAdd(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static const AlgStruct idMul(Args... args) { return Operators::IdMul(args...); }\n\n    const AlgStruct operator+() const { return *this; }\n    const AlgStruct operator-() const { return Operators::Opposite(x); }\n    const AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct& operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct& operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct& operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct& operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    const AlgStruct power(long long n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& value){ s << value.x; return s; }\n\n\ntemplate<typename T, T mod>\nstruct GaloisFieldOperators {\n    static T Add(T lhs, T rhs) { return (lhs + rhs) % mod; };\n    static T Mul(T lhs, T rhs) { return (lhs * rhs) % mod; };\n    static T IdAdd() { return 0; };\n    static T IdMul() { return 1; };\n    static T Opposite(T value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(T lhs, T rhs) { return lhs < rhs; };\n    static T Power(T value, long long n) {\n        T res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static T Reciprocal(T value) { return Power(value, mod-2); }\n};\n\nconst long long MOD = 1e9+7;\nusing GaloisField = AlgStruct<long long, GaloisFieldOperators<long long, MOD>>;\n\n\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring::idMul();\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\n\n\nint main()\n{\n    long long n; cin >> n;\n\n    Fact<GaloisField> fact(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * fact[k] * fact[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (long long k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#ifdef MAROON_LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\" SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\twhile(p){\n\t\tif(p&1)mult(s,a);\n\t\tmult(a,a);\n\t\tp>>=1;\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Vmax=1000010;\nint fact[Vmax],factInv[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1];\n\t\tmult(fact[i],i);\n\t}\n\tfactInv[Vmax-1]=modInv(fact[Vmax-1]);\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1];\n\t\tmult(factInv[i],i+1);\n\t}\n}\nint Choose(int n,int k){\n\treturn ll(fact[n])*factInv[n-k]%mod*factInv[k]%mod;\n}\nint Binom(int a,int b){\n\treturn ll(fact[a+b])*factInv[a]%mod*factInv[b]%mod;\n}\n\nsigned main(){\n\tInitFact();\n\tint n=read();\n\tint ans=fact[n-1];\n\tmult(ans,n-1);\n\tFOR(k,2,n-1){\n\t\tint l=n-1-k;\n\t\tif(l<=k-1){\n\t\t\tint w=Choose(k-1,l);\n\t\t\tmult(w,fact[k]);\n\t\t\tmult(w,fact[l]);\n\t\t\tsub(ans,w);\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint n;\n\nint main() {\n  cin >> n;\n  Mint res = 0;\n  vector<Mint> p(n + 1);\n  p[0] = 1;\n  range(i, 1, n + 1) p[i] = p[i - 1] * i;\n  auto c = [&](int x, int y) {\n    if(y < 0) {\n      x = -x;\n      y = -y;\n    }\n    if(y > x) return Mint(0);\n    return p[x] / (p[y] * p[x - y]);\n  };\n  range(i, 0, n) {\n    // x1 + x2 + ... + x_(n - i) = i;\n    res += (c(n - 1, i) - c(i - 1, n - i - 1)) * p[i] * p[n - 1 - i];\n  }\n  cout << res;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n// a>=0, b>=0, x*a+y*b=gcd>=0, a>0,b>0=>abs(y)<=a,abs(x)<=b\nLL gcdex(LL a,LL b,LL& x, LL& y){\n\tLL ax=1,ay=0;\n\tLL bx=0,by=1;\n\twhile(b){\n\t\tLL r=a/b;\n\t\tLL t=a-r*b; a=b; b=t;\n\t\tLL tx=ax-r*bx; ax=bx; bx=tx;\n\t\tLL ty=ay-r*by; ay=by; by=ty;\n\t}\n\tx=ax;\n\ty=ay;\n\treturn a;\n}\nLL modinv(LL a, LL mod){\n\tLL x,y;\n\tgcdex(a,mod,x,y);\n\tif(x<0){\n\t\tx+=mod;\n\t}\n\treturn x;\n}\n\nconst int N=1e6;\nconst int M=1e9+7;\ntemplate<int S>\nstruct Comb\n{\n\tLL f[S+1];\n\tLL r[S+1];\n\tLL mod;\n\tComb(int m)\n\t{\n\t\tmod=m;\n\t\tf[0]=1;\n\t\tr[0]=1;\n\t\tfor(LL i=1;i<=S;i++){\n\t\t\tf[i]=i*f[i-1]%m;\n\t\t\tr[i]=modinv(i,m)*r[i-1]%m;\n\t\t}\n\t}\n\tLL c(int n,int i){\n\t\tif(i<0||n<i)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn f[n]*r[i]%mod*r[n-i]%mod;\n\t}\n};\nComb<N> comb(M);\nint main() {\n\tLL N;\n\tcin >> N;\n\tLL pre=0;\n\tLL ret=0;\n\tfor(int K=1;K<=N-1;K++){\n\t\tLL v=0;\n\t\tif(N-K-1>=0){\n\t\t\tv=comb.c(K-1,N-K-1)*comb.f[K]%M*comb.f[N-K-1]%M;\n\t\t}\n\t\t//cerr << K << \", \" << v << endl;\n\t\tret+=(v-pre)*K%M;\n\t\tret%=M;\n\t\tpre=v;\n\t}\n\tcout << ret << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) begin(x), end(x)\n#define allR(x) rbegin(x), rend(x)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) {\n    using S = typename iterator_traits<It>::value_type;\n    using T = conditional_t<is_signed_v<S>,i64,u64>;\n    return accumulate(b,e,T{});\n}\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\ni64 irand(i64 a, i64 b) { return rand<i64>(a,b); }\nu64 urand(u64 a, u64 b) { return rand<u64>(a,b); }\n// <<<\n// >>> modint\ntemplate <uint32_t md>\nclass modint {\n    static_assert(md < (1u<<31), \"\");\n    using M = modint;\n    using i64 = int64_t;\n    uint32_t x;\npublic:\n    static constexpr uint32_t mod = md;\n    constexpr modint(i64 x = 0) : x((x%=md) < 0 ? x+md : x) { }\n    constexpr i64 val() const { return x; }\n    constexpr explicit operator i64() const { return x; }\n    constexpr bool operator==(M r) const { return x == r.x; }\n    constexpr bool operator!=(M r) const { return x != r.x; }\n    constexpr M operator+() const { return *this; }\n    constexpr M operator-() const { return M()-*this; }\n    constexpr M& operator+=(M r) { x += r.x; x = (x < md ? x : x-md); return *this; }\n    constexpr M& operator-=(M r) { x += md-r.x; x = (x < md ? x : x-md); return *this; }\n    constexpr M& operator*=(M r) { x = (uint64_t(x)*r.x)%md; return *this; }\n    constexpr M& operator/=(M r) { return *this *= r.inv(); }\n    constexpr M operator+(M r) const { return M(*this) += r; }\n    constexpr M operator-(M r) const { return M(*this) -= r; }\n    constexpr M operator*(M r) const { return M(*this) *= r; }\n    constexpr M operator/(M r) const { return M(*this) /= r; }\n    friend constexpr M operator+(i64 x, M y) { return M(x)+y; }\n    friend constexpr M operator-(i64 x, M y) { return M(x)-y; }\n    friend constexpr M operator*(i64 x, M y) { return M(x)*y; }\n    friend constexpr M operator/(i64 x, M y) { return M(x)/y; }\n    constexpr M inv() const { assert(x > 0); return pow(md-2); }\n    constexpr M pow(i64 n) const {\n        assert(not (x == 0 && n == 0));\n        if (n < 0) return inv().pow(-n);\n        M v = *this, r = 1;\n        for (; n > 0; n >>= 1, v *= v) if (n&1) r *= v;\n        return r;\n    }\n#ifdef LOCAL\n    friend string to_s(M r) { return to_s(r.val(), mod); }\n#endif\n    friend ostream& operator<<(ostream& os, M r) { return os << r.val(); }\n    friend istream& operator>>(istream& is, M &r) { i64 x; is >> x; r = x; return is; }\n};\n// <<<\n//constexpr int64_t MOD = 998244353;\nconstexpr int64_t MOD = 1e9+7;\nusing mint = modint<MOD>;\nmint sgn(int n) { return n%2 == 0 ? +1 : -1; }\n// >>> mod table\ntemplate <uint32_t mod>\nstruct ModTable {\n    vector<uint32_t> fact = {1,1}, finv = {1,1}, inv = {0,1};\n    void calc(int n) {\n        int old = fact.size();\n        if (n < old) return;\n        fact.resize(n+1);\n        finv.resize(n+1);\n        inv.resize(n+1);\n        for (uint32_t i = old; i <= n; i++) {\n            fact[i] = uint64_t(fact[i-1])*i % mod;\n            inv[i] = mod - uint64_t(inv[mod%i])*(mod/i) % mod;\n            finv[i] = uint64_t(finv[i-1])*inv[i] % mod;\n        }\n    }\n};\nModTable<MOD> mod_tab;\n\nmodint<MOD> fact(int n) {\n    assert(0 <= n);\n    return mod_tab.calc(n), mod_tab.fact[n];\n}\nmodint<MOD> finv(int n) {\n    assert(0 <= n);\n    return mod_tab.calc(n), mod_tab.finv[n];\n}\nmodint<MOD> C(int n, int k) {\n    if (n < 0 || k < 0 || n < k) return 0;\n    return fact(n)*finv(k)*finv(n-k);\n}\nmodint<MOD> P(int n, int k) {\n    assert(k >= 0); assert(n >= k);\n    return fact(n)*finv(n-k);\n}\n// <<<\n\nint32_t main() {\n    int n; cin >> n;\n\n    mint ans = 0;\n    rep (k,n-1) {\n        int x = (n-2)-(k-1);\n        int y = 2*(k-1)-(n-2);\n        auto cnt = fact(n-1)-C(x+y,x)*fact(k)*fact(n-1-k);\n        ans += cnt;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int MAX = 1e5 + 10;\nconst int MOD = 1e9 + 7;\nconst double EPS = 1e-9;\ntypedef long long ll;\nusing namespace std;\n#define mul(a, b) (((ll)(a) * (b) ) % MOD)\n#define sum(a, b) (((ll)(a) + (b) ) % MOD)\n\nint powmod(int a, int n){\n\tint s = 1;\n\twhile(n> 0){\n\t\tif(n & 1)s = mul(a, s);\n\t\ta = mul(a, a);\n\t\tn >>= 1;\n\t}\n\treturn s;\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t#define endl '\\n'\n\n\t#ifdef LOCAL_DEBUG\n\t\tfreopen(\"data.in\", \"r\", stdin );\n\t#endif\n\n\n\tint n; cin >> n;\n\tvector<int> fac(n + 1);\n\tvector<int> ifac(n + 1);\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; i++)fac[i] = mul(fac[i - 1], i);\n\tifac[n] = powmod(fac[n],  MOD - 2);\n\tfor(int i = n - 1; i >= 0; i--)ifac[i ] = mul(i + 1, ifac[i + 1]);\n\n\n\tfunction<int(int, int)> comb = [&](int a, int b){\n\t\tif(a < b)return 0;\n\t\treturn (int)mul(fac[a], mul(ifac[b], ifac[a - b]));\n\t};\n\tvector<int> tot(n);\n\tfor(int k = 0; k < n; k++)\n\t\ttot[k] = mul(comb(k - 1, n - 1 - k), fac[k]);\n\tvector<int> p(n);\n\tfor(int k = 1; k < n; k++)\n\t\tp[k] = (tot[k] - mul(n - 1 - (k - 1), tot[k - 1]) + MOD) % MOD;\n\tint ans = 0;\n\tfor(int k = 0; k < n; k++)\n\t\tans = sum(ans, mul(k, mul(p[k], fac[n - 1 - k])));\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int \n#define ll long long \nusing namespace std;\nconst int mod = 1e9+7;\nll ksm(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y>>=1;\n\t}return res;\n}\nll fac[1000100],Ifac[1010000];\ninline ll C(ll x,ll y){\n\treturn fac[x]*Ifac[y]%mod*Ifac[x-y]%mod;\n}\nint n;\nint main(){\n\tcin>>n;\n\tfac[0]=Ifac[0]=1;\n\tfor(rint i=1;i<=2*n;++i) fac[i]=fac[i-1]*i%mod;\n\tIfac[2*n]=ksm(fac[2*n],mod-2);\n\tfor(rint i=2*n-1;i;--i) Ifac[i]=Ifac[i+1]*(i+1)%mod;\n\tll ans=0,las=0;\n\tfor(rint i=(n+1)/2;i<=n-1;++i) {\n\t\tll tmp=1ll*C(i-1,n-i-1)*fac[i]%mod*fac[n-1-i]%mod;\n\t\tans=ans+(tmp-las)*i%mod+mod;\n\t\tans%=mod;\n\t\tlas=tmp; \n\t}cout<<ans;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e6 + 10;\nconst ll mod = 1e9 + 7;\nint n;\nll ans;\nll fac[maxn], inv[maxn], facinv[maxn], bin[maxn];\nvoid pre()\n{\n\tfac[0] = 1; for(int i = 1; i < maxn; ++i) fac[i] = fac[i - 1] * i % mod;\n\tinv[1] = 1; for(int i = 2; i < maxn; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\tfacinv[0] = 1; for(int i = 1; i < maxn; ++i) facinv[i] = facinv[i - 1] * inv[i] % mod;\n\tbin[0] = 1; for(int i = 1; i < maxn; ++i) bin[i] = bin[i - 1] * 2 % mod;\n}\nll C(int n, int m) { return n < m ? 0 : fac[n] * facinv[m] % mod * facinv[n - m] % mod;}\nll f(ll r, ll x)\n{\n\tll t = n - r - x + 1;\n\tif(t > r - 1 || t < 1) return 0;\n\treturn C(r - 1, 1) * C(r - 1 - 1, n - r - x) % mod;\n}\nll g(ll r, ll x)\n{\n\tll t = x - r;\n\treturn C(r - 1, t);\n}\nll fact(ll n) { return n < 0 ? 1 : fac[n];}\nint main()\n{\n\tpre();\n\tscanf(\"%d\", &n);\n\tif(n == 2) { puts(\"1\"); return 0;}\n\tif(n == 3) { puts(\"2\"); return 0;}\n\tfor(int i = 1; i <= n - 1; ++i) \n\t{\n\t\tll tmp = (f(i, 3) * 2 + f(i, 4) + g(i, n - 2) * 2 + g(i, n - 3) * 2) % mod;\n\t\tans = (ans + tmp * fact(i + 1) % mod % mod * fact(n - 1 - i - 1) % mod) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<long long> F, RF, R;\nlong long MOD = 1000000007;\n\nvoid init(long long N) {\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tR[i] = MOD - (R[MOD % i] * (MOD / i)) % MOD;\n\t\tRF[i] = (RF[i - 1] * R[i]) % MOD;\n\t}\n}\n\nint main() {\n\tlong long N;\n\tcin >> N;\n\tinit(N);\n\tlong long COUNT = 0;\n\tfor (int i = (N + 1) / 2; i < N; i++) {\n\t\tlong long X = F[i] * F[i - 1];\n\t\tX %= MOD;\n\t\tX *= RF[i * 2 - N];\n\t\tX %= MOD;\n\t\tCOUNT = (COUNT + X) % MOD;\n\t}\n\tcout << (F[N] - COUNT + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long \n#define MAX_N 200010\n#define MOD 1000000007\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a==0&&b==0)return 1;\n    if(a<=0)return 0;\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    make();\n    ll n;\n    cin >> n;  \n    vector<ll> a(n);\n    rep(i,n){\n        if(i>=n-1){\n            a[i] = fac[n-1];\n            continue;\n        }\n        a[i] = comb(n-2-i,i)*fac[i]%mod;\n        a[i] *= fac[n-1-i]%mod;\n        a[i] = (fac[n-1]-a[i]+mod)%mod;\n    }\n    return 0;\n    for(int i=n-1;i>=1;i--){\n        a[i] += mod-a[i-1];\n        a[i] %= mod;\n    }\n    //rep(i,n)cerr << a[i] << endl;\n    ll sm = 0;\n    rep(i,n){\n        sm += (n-i)*a[i]%mod;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M=1E9+7;\n\nunsigned int doit(int i,int j){\n\tif (i==j) return 0;\n\tif (j-i==1) return 1;\n\tint mid=(i+j)/2;\n\tunsigned int ret=(doit(i,mid)+doit(mid+1,j))%M;\n\tlong long p = (1LL * (mid-i+1) * (j-mid))%M;\n\tret = (ret + p)%M;\n\treturn ret;\n}\n\nint main(){\n\tint n;cin>>n;\n\tunsigned int s=doit(0,n-1);\n\tcout << s+1;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF int(1e9)\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=1000005;\nconst int mod=1e9+7;\nint n,ans;\nint fac[maxn],ifac[maxn];\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tif(n==2){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tans=fac[n];\n\trep(i,n-2){\n\t\tans-=1LL*C(i+1,n-3-i)*fac[i+2]%mod*fac[n-3-i]%mod;\n\t\tif(ans<0)ans+=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\n\nconst long long MOD = 1e9 + 7;\nconst int N = 2000005;\nint n;\n\nlong long fact[N + 1];\nlong long ufact[N + 1];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nlong long ans = 0;\nlong long w[N + 1];\n\nlong long cnk(long long n, long long k)\n{\n    if (k < 0 || k > n) return 0;\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    fact[0] = 1, ufact[0] = 1;\n    for (int i = 1; i <= N; i++) fact[i] = fact[i - 1] * i % MOD;\n    for (int i = 1; i <= N; i++) ufact[i] = inq(fact[i], MOD - 2) % MOD;\n    for (int i = 1; i <= n - 1; i++)\n    {\n        w[i] = cnk(i - 1, n - i - 1) * fact[i] % MOD * fact[n - i - 1] % MOD;\n    }\n    long long si = 0;\n    for (int i = 1; i <= n - 1; i++)\n    {\n        ans = (ans + (w[i] - si + MOD) * i) % MOD;\n        si = (si + w[i]) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <ll MOD>\nclass Combination {\n    ll N;\n    V<ll> factv, ifactv;\n\npublic:\n    Combination<MOD>(ll N) : N(N), factv(N + 1, 1), ifactv(N + 1) {\n        for(ll i = 1; i <= N; i++) factv[i] = factv[i - 1] * i % MOD;\n        ifactv.back() = inv(factv.back());\n        for(ll i = N - 1; 0 <= i; i--) ifactv[i] = (i + 1) * ifactv[i + 1] % MOD;\n    }\n\n    ll fact(ll n) { return factv[n]; }\n\n    ll ifact(ll n) { return ifactv[n]; }\n\n    ll pow(ll a, ll b) { return b ? (b & 1 ? a : 1) * pow(a * a % MOD, b / 2) % MOD : 1; }\n\n    ll inv(ll a) { return pow(a, MOD - 2); }\n\n    ll comb(ll n, ll k) { \n        if (n < k) return 0;\n        return factv[n] * ifactv[n - k] % MOD * ifactv[k] % MOD; \n    }\n};\n\nconst ll mod = 1e9 + 7;\nCombination<mod> C(1e6 + 10);\n\nll solve() {\n    ll N;\n    cin >> N;\n\n    if (N == 2) return 1;\n    if (N == 3) return 4;\n    if (N == 4) return 16;\n    ll ans = 0;\n    ll psum = 0;\n    for (ll i = 3; i < N; i++) {\n        ll rest = N - 1 - i;\n        ll perm = C.fact(i) * C.fact(rest) % mod;\n        perm = perm * C.comb(i - 1, rest) % mod;\n        ans += i * (perm - psum + mod) % mod;\n        psum = perm;\n    }\n\n    return ans % mod;\n}\n\nint main() {\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <assert.h>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <time.h>\n#include <string.h>\n#include <queue>\n#include <complex>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef complex<double> base;\nll mod=1e9+7;\ndouble eps=1e-9;\nll exp(ll x,ll y){if(y<0) return 0; ll ret=1;for(;y;y>>=1,x=(x*x)%mod){if(y&1)ret=(ret*x)%mod;}return ret;}\nll pexp(ll x, ll y){if(y<0) return 0; ll ret=1; for(;y;y>>=1,x=(x*x)){if(y&1)ret=(ret*x);}return ret;}\nll gcd(ll x,ll y){if(!x||!y) return x+y; return x%y==0?y:gcd(y,x%y);}\nll lcm(ll x,ll y){return x*(y/gcd(x,y));}\nll bsum(ll u,ll b){ll ret=0;if(u<b)return u;while(u){ret+=u%b;u/=b;}return ret;}\nll prival(ll u,ll p){ll cn=0;while(u%p==0){cn++;u=u/p;}return cn;}\nll minv(ll a,ll b){return 1<a?b-minv(b%a,a)*b/a:1;}\nll extm(ll a,ll b){ll ret=0;while(a!=0){if(a%2==1){ret+=b;ret%=mod;}a>>=1;b=(2*b)%mod;}return ret;}   \nll eaphi(ll x){ll t=x,ret=x,i;for(i=2;i*i<=x;i++){if(t%i==0){ret-=ret/i;while(t%i==0) t/=i;}}if(t!=1) ret-=ret/t;return ret;}\nll eadivc(ll x){ll ret=0;ll i;for(i=1;i*i<=x;i++){if(x%i==0 && i*i!=x) ret+=2;if(x%i==0 && i*i==x) ret+=1;}return ret;}\nll ndig(ll x, ll b){ll ret=0;while(x){x/=b; ret++;}return ret;}\nbool isprime(ll x){if(x<=1) return false; for(ll i=2;i*i<=x;i++){if(x%i==0){return false;}}return true;}\nll fac[1111111];\nll invfac[1111111];\nll n, ans, add;\n\nll ncr(ll u, ll v)\n{\n\tif(u<0 || v<0 || u<v) return 0;\n\tll ret=fac[u];\n\tret=(ret*invfac[v])%mod;\n\tret=(ret*invfac[u-v])%mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin>>n; fac[0]=1; invfac[0]=1; ll i, j;\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tfac[i]=(i*fac[i-1])%mod;\n\t\tinvfac[i]=exp(fac[i],mod-2);\n\t}\n\tans+=fac[n-1];\n\tfor(i=1 ; i<=n-1 ; i++)\n\t{\n\t\tadd=ncr(n-1,i)-ncr(i-1,n-2-i+1);\n\t\tadd=(add+mod)%mod;\n\t\tadd=(add*fac[n-1-i])%mod;\n\t\tadd=(add*fac[i])%mod;\n\t\tans=(ans+add); if(ans>=mod) ans-=mod;\n\t}\t\n\tans%=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N;\nll fact[1000006];\nll init[1000006];\n\nll f(ll x){\n    ll ret = fact[x];\n    ret *= (x-1);\n    ret %= mod;\n    return ret;\n}\n\nint main(){\n    cin >> N;\n    assert(N%2==1);\n    if(N==2){\n        cout << 1 << endl;\n        return 0;\n    }\n    fact[1] = 1;\n    for(int i=2;i<=N;i++) fact[i] = fact[i-1] * i % mod;\n\n    // calc init\n    init[3] = 2;\n    for(ll i=5;i<=N+2;i+=2){\n        ll index = (i -3) / 2 + 2;\n        ll tmp = index * (index-1) % mod;\n        init[i] = init[i-2] * tmp % mod;\n    }\n    //for(int i=3;i<=11;i+=2) cout << \"init \" << i << \"  --> \" << init[i] << endl;\n\n    ll ans;\n    if(N%2==1) ans = init[N];\n    else ans = init[N-1];\n\n    ans %= mod;\n\n    for(ll i=(N+1)/2+1;i<=N-1;i++){\n        ans += f(i);\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n\nlong long bipow(long long n, int m) {\n    if (m == 0) return 1;\n    if (m % 2 == 0) {\n        n = (n * n) % MOD;\n        return bipow(n, m / 2) % MOD;\n    } else\n        return (n * bipow(n, m - 1)) % MOD;\n}\n\n// fact_num[i] = i! % MOD\n// fact_denpow[i] = (i**(MOD-2)) % MOD\n// fact_den[i] = fact_denpow[i]! % MOD\n// nCm = fact_num[n] * fact_den[m] * fact_den[n-m]\n// で計算できる（MODを適切に取る）\n// O(NlogN)\nvoid set_table(int N, vector<long long> &fact_num, vector<long long> &fact_den){\n    fact_num.resize(N+1, 0);\n    fact_den.resize(N+1, 0);\n    vector<long long> fact_denpow(N+1, 0);\n\n    fact_num[0] = 1;\n    for(int i=1; i<=N; i++) fact_num[i] = (fact_num[i-1] * i) % MOD;\n\n    for(int i=0; i<=N; i++) fact_denpow[i] = bipow(i, MOD-2);\n    fact_den[0] = 1;\n    for(int i=1; i<=N; i++) fact_den[i] = (fact_den[i-1] * fact_denpow[i]) % MOD;\n}\n\n// mCn\nlong long comb(const vector<long long> &fact_num, const vector<long long> &fact_den, int m, int n){\n    return ((fact_num[m] * fact_den[n]) % MOD * fact_den[m-n]) % MOD;\n}\n\nlong long fac[123456];\n\nint main(){\n    long long N;\n    cin >> N;\n    if(N == 2){\n        cout << 1 << endl;\n        return 0;\n    }\n    vector<long long> fact_num, fact_den;\n    set_table(N, fact_num, fact_den);\n\n    vector<long long> v(N);\n    for(int i=2; i<N; i++){\n        if(i-1 < N-i-1) continue;\n        long long tmp = (fact_num[i] * fact_num[N-1-i]) % MOD;\n        tmp *= comb(fact_num, fact_den, i-1, N-1-i);\n        tmp %= MOD;\n        v[i] = tmp;\n    }\n\n    long long ans = 0;\n    for(int i=2; i<N; i++){\n        long long tmp = v[i];\n        if(i != 2) tmp = (tmp - v[i-1] + MOD) % MOD;\n        tmp = (tmp * i) % MOD;\n        ans = (ans + tmp) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1e9+7;\nll N;\nll inv[2000000];\nll FactorialInv[2000000];\nll Factorial[2000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    Factorial[0] = 1;\n    for(int i = 2; i < 2000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\nll patterns[1000500];\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    N--;\n    if(N == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    init_combination();\n    ll ans = 0;\n    ll sum = 0;\n    for(ll i = 2; i <= N; i++) {\n        patterns[i] = combination(i - 1, N - i);\n        patterns[i] *= Factorial[i];\n        patterns[i] %= mod;\n        patterns[i] *= Factorial[N - i];\n        patterns[i] %= mod;\n        patterns[i] += mod - sum;\n        patterns[i] %= mod;\n        sum = (sum + patterns[i]) % mod;\n        ans = (ans + patterns[i] * i) % mod;\n        //cerr << i << \" \" << patterns[i] << endl;\n    }\n    //cerr << \" \" << sum << \" \" << Factorial[N] << endl;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,ans=0;\n  cin>>N;\n  COMinit();\n  ll cnt[N];\n  REP(i,N) cnt[i]=0;\n  \n  for(ll i=(N+1)/2; i<=N-1; ++i){\n    cnt[i]=fac[i]*fac[i-1];\n    cnt[i]%=MOD;\n    cnt[i]*=finv[2*i-N];\n    cnt[i]%=MOD;\n    ans+=(cnt[i]-cnt[i-1])*i%MOD;\n    ans%=MOD;\n  }\n  \n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pd(x) cerr<<\"//\"<<(x)<<endl;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll mod = 1000000007;\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,g,h,i,j,k,ok,ng,l,q;\nll x[500005],y[500005],z[500005],w[500005];\nll banb[5005][5005],banw[5005][5005];\nchar s[500005],t[500005];\nbool flag,dame;\n\nll  fact[1200000];\nll rfact[1200000];\n\nll mpow(ll x, ll y, ll m) {\n    x %= m;\n    ll result = 1;\n    while (y > 0) {\n        if (y & 1) result = (result * x) % m;\n        x = (x * x) % m;\n        y >>= 1;\n    }\n    return result;\n}\nunsigned long long int minverse(unsigned long long int x, unsigned long long int m) {\n    return mpow(x, m-2, m);\n}\nvoid c3_init(ll m){\n    fact[0]  = rfact[0] = 1;\n    for(ll xxxx=1; xxxx<1200000; xxxx++){\n        fact[xxxx] = (fact[xxxx-1]*xxxx)%m;\n        rfact[xxxx] = minverse(fact[xxxx],m);\n    }\n}\nll c3(ll n, ll abc, ll m){\n    return (((fact[n] * rfact[abc])%m) * rfact[n-abc])%m;\n}\n \nint main(){\n    cin >> n;\n\tc3_init(mod);\n\tfor(i=1;i<=n-1;i++){\n\t\t//length is i\n\t\tif(1 + (i - 1) * 2 < n - 1)continue;\n\t\t//pe(i);\n\t\tll one,two;\n\t\ttwo = n - 1 - i;\n\t\tone = i - 1 - two;\n\t\tans += ((((((c3(one+two,one,mod) * fact[i])%mod) * fact[n-1-i]) % mod + (mod - sum))%mod) * i)%mod ;\n\t\t//ans += ((c3(one+two,one,mod) * (fact[i] * fact[n-1-i]) % mod + mod - sum)%mod * i)%mod;\n\t\tans %= mod;\n\t\t//p(ans);\n\t\t\n\t\tsum += (((((c3(one+two,one,mod) * fact[i])%mod) * fact[n-1-i]) % mod + (mod - sum))%mod);\n\t\t//sum += (c3(one+two,one,mod) * (fact[i] * fact[n-1-i])%mod)%mod;\n\t\tsum %= mod;\n\t\tassert(ans >= 0);\n\t\tassert(sum >= 0);\n\t}\n\tp(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nconst int mod=1e9+7;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint fac[N],inv[N],ifac[N];\nvoid init() {\n    const int n=1e6+5;\n    fac[0]=1;for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    inv[1]=1;for(int i=2;i<=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    ifac[0]=1;for(int i=1;i<=n;i++) ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n}\nint n;\nint C(int n,int m) {\n    if(n<0||m<0||n<m) return 0;\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint Calc(int s) {\n    return (C(n-1,s)-C(s-1,n-s-1)+mod)%mod;\n}\nint calc(int s) {\n    return 1ll*Calc(s)*fac[s]%mod*fac[n-1-s]%mod;\n}\nint main() {\n    init(),n=gi();\n    int ans=0;\n    for(int i=0;i<n-1;i++) ans=(ans+calc(i))%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\ntypedef long long ll;\nconst int N=101000,MOD=1000000007;\n\nll qpow(ll a,ll b){ll c=1;for(;b;b>>=1,a=a*a%MOD)if(b&1)c=c*a%MOD;return c;}\n\nint fact[N],ifact[N];\n\nint C(int n,int m)\n{\n\tif(n<m)return 0;\n\treturn (ll)fact[n]*ifact[m]%MOD*ifact[n-m]%MOD;\n}\n\nint f(int n,int k)\n{\n\treturn C(n-k+1,k);\n}\n\nint n;\n\nint main()\n{\n\tfact[0]=1;\n\tfor(int i=1;i<N;i++)fact[i]=(ll)fact[i-1]*i%MOD;\n\tifact[N-1]=qpow(fact[N-1],MOD-2);\n\tfor(int i=N-1;i;i--)ifact[i-1]=(ll)ifact[i]*i%MOD;\n\n\tscanf(\"%d\",&n);\n\n\tint ans=(ll)fact[n-1]*(n-1)%MOD;\n\n\tfor(int k=1;k<n;k++)\n\t{\n\t\tans=(ans-(ll)f(n-3,k)*fact[n-k-1]%MOD*fact[k]%MOD)%MOD;\n\t}\n\n\tans=(ans+MOD)%MOD;\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// FUCKED UP FUCKED UP FUCKED UP FUCKED UP FUCKED UP\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=1e6+10, maxm=5e4+10, lg=21, mod=1e9+7, inf=1e18;\n\nll n,fac[maxn],inv[maxn],cc[maxn];\nll pwm(ll a,ll b){if(b==0)return 1;if(b%2)return a*pwm(a,b-1)%mod;ll ret=pwm(a,b/2);return ret*ret%mod;}\nll C(ll n,ll r){return fac[n]*inv[r]%mod*inv[n-r]%mod;}\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tfac[0]=inv[0]=1; for(int i=1;i<maxn;i++) fac[i]=fac[i-1]*i%mod, inv[i]=pwm(fac[i],mod-2);\n\tcin>>n;\n\tll ans=0;\n\tfor(int k=(n+1)/2;k<n;k++){\n\t\tcc[k]=fac[k]*fac[n-1-k]%mod*C(k-1,n-1-k)%mod;\n\t\tans+=k*(cc[k]-cc[k-1]+mod)%mod, ans%=mod;\n\t}\n\tcout<<ans;\n\t\n\treturn 0;\n}\n\n\n\n \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#define sqr(x) (x)*(x)\nusing namespace std;\nlong long n,m,i,j,mod=1e9+7,f[1000005],fac[1000005],fi[1000005],inv[1000005],ans;\nlong long c(long long x,long long y)\n{\n\treturn fac[x]*fi[y]%mod*fi[x-y]%mod;\n}\nint main()\n{\n\tcin>>n;\n\tfac[0]=fac[1]=inv[0]=inv[1]=fi[0]=fi[1]=1;\n    for (i=2;i<=1000000;i++)  \n    {  \n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n        fi[i]=fi[i-1]*inv[i]%mod;\n    }\n    for (i=(n+1)/2;i<n;i++)\n    {\n\t\tf[i]=c(i-1,n-i-1)*fac[i]%mod*fac[n-i-1]%mod;\n\t}\n    for (i=(n+1)/2;i<n;i++)\n\t{\n\t\t(ans+=(f[i]-f[i-1])*i)%=mod;\n\t}\n    cout<<(ans%mod+mod)%mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 1000010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n;\n\nint fac[maxn];\n\nint C(int n,int k){\n\tif(n<k)return 0;\n\treturn (ll)fac[n]*fexp(fac[k],mod-2)%mod*fexp(fac[n-k],mod-2)%mod;\n}\n\nint main(){\n\tread(n);\n\tfac[0]=1;REP(i,1,n)fac[i]=(ll)fac[i-1]*i%mod;\n\tint ans=0;\n\tREP(i,0,n-1)ans=((ll)C(i-1,n-i-1)*fac[i]%mod*fac[n-i-1]+ans)%mod;\n\tans=((ll)fac[n-1]*n-ans+mod)%mod;\n\tiout(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int NMAX = 1000002;\nint n, fact[NMAX];\nlong long x, y, ans, last;\n\nlong long lgpow (long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1)\n      ans = ans * a % MOD;\n    b >>= 1;\n    a = a * a % MOD;\n  }\n  return ans;\n}\n\nlong long  C (long long n, long long m) {\n  long long a = fact[n], b = (fact[m] * fact[n - m]) % MOD;\n  return (a * lgpow(b, MOD - 2)) % MOD;\n}\n\nint main()\n{\n  cin >> n;\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++)\n    fact[i] = (long long)fact[i - 1] * i % MOD;\n  for (int k = (n + 1) / 2; k < n; k++) {\n    long long x = C(k - 1, n - 1 - k) * fact[k] % MOD * fact[n - k - 1] % MOD;\n    y = (x - last + MOD) % MOD * k % MOD;\n    ans = (ans + y) % MOD;\n    last = x;\n  }\n  cout << ans;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\nconst int maxn = 1e6 + 10;\nLL fac[maxn], inv_fac[maxn], num[maxn];\n\nLL qpow(LL a, LL b) {\n    LL ret = 1LL;\n    while (b) {\n        if (b & 1) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nLL inv(LL x) {\n    return qpow(x, mod - 2);\n}\n\nLL C(int n, int m) {\n    return fac[n] * inv_fac[m] % mod * inv_fac[n - m] % mod;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    if(N == 2) return puts(\"1\");\n    fac[0] = 1;\n    for (int i = 1; i <= N; ++i) fac[i] = fac[i - 1] * i % mod;\n    inv_fac[N] = inv(fac[N]);\n    for (int i = N - 1; i >= 0; --i) inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;\n    for (int i = (N + 1) / 2; i <= N - 1; ++i)\n        num[i] = C(i - 1, N - 1 - i) * fac[i] % mod * fac[N - 1 - i] % mod;\n    LL ans = 0;\n    for (int i = N - 1; i >= (N + 1) / 2; i--) {\n        num[i] = (num[i] - num[i - 1] + mod) % mod;\n        ans = (ans + num[i] * i) % mod;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for (int i = j; i <= k; i++)\n#define Forr(i, j, k) for (int i = j; i >= k; i--)\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\nconst int Mod = 1e9 + 7;\n\nint Pow(int x, int e) {\n\tint ret = 1;\n\twhile (e) {\n\t\tif (e & 1) ret = 1ll * ret * x % Mod;\n\t\tx = 1ll * x * x % Mod;\n\t\te >>= 1;\n\t}\n\treturn ret;\n}\n\nint n;\nint fac[N], rfac[N];\n\nint C(int a, int b) {\n\treturn 1ll * fac[a] * rfac[b] % Mod * rfac[a - b] % Mod;\n}\n\nint main() {\n\n\tscanf(\"%d\", &n);\n\n\tfac[0] = 1;\n\tFor(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\trfac[n] = Pow(fac[n], Mod - 2);\n\tForr(i, n, 1) rfac[i - 1] = 1ll * rfac[i] * i % Mod;\n\n\tint ans = 1ll * fac[n - 1] * (n - 1) % Mod;\n\tFor(i, n / 2 - 1, n - 2) {\n\t\tint x = (i - 1) * 2 - (n - 2);\n\t\tif (x < 0) continue;\n\t\tans = (ans - 1ll * C(i - 1, x) * fac[i] % Mod * fac[n - 1 - i] % Mod + Mod) % Mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long \nusing namespace std;\nconst int MAXN = 1e6 + 10, INF = 1e9 + 7, mod = 1000000007;\ntemplate<typename A, typename B> inline void chmax(A &x, B y) {\n\tx = x > y ? x : y;\n}\ntemplate<typename A, typename B> inline void chmin(A &x, B y) {\n\tx = x < y ? x : y;\n}\ntemplate<typename A, typename B> inline int mul(A x, B y) {\n\treturn 1ll * x * y % mod;\n}\ntemplate<typename A, typename B> inline void add2(A &x, B y) {\n\tif(x + y < 0) x = x + y + mod;\n\telse x = (x + y >= mod ? x + y - mod : x + y);\n}\ntemplate<typename A, typename B> inline int add(A x, B y) {\n\tif(x + y < 0) return x + y + mod;\n\telse return x + y >= mod ? x + y - mod : x + y;\n}\ntemplate<typename A, typename B> fp(A a, B p) {\n\tint base = 1;\n\twhile(p) {\n\t\tif(p & 1) base = mul(base, a);\n\t\ta = mul(a, a); p >>= 1;\n\t}\n\treturn base;\n}\ninline int read() {\n\tchar c = getchar(); int x = 0, f = 1;\n\twhile(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * f;\n}\nint N, fac[MAXN], ifac[MAXN], f[MAXN];\nint C(int N, int M) {\n\tif(M > N) return 0;\n\treturn mul(fac[N], mul(ifac[M], ifac[N - M]));\n}\nint main() {\n\tN = read(); fac[0] = 1;\n\tfor(int i = 1; i <= N; i++) fac[i] = mul(i, fac[i - 1]);\n\tifac[N] = fp(fac[N], mod - 2);\n\tfor(int i = N; i >= 1; i--) ifac[i - 1] = mul(ifac[i], i);\n\tint down = N / 2 + (N & 1);\n\tfor(int i = down; i < N; i++) \n\t\tf[i] = mul(mul(C(i - 1, N - i - 1), fac[i]), fac[N - i - 1]);\n\tint ans = 0;\n\tfor(int i = down; i < N; i++) add2(ans, mul(i, add(f[i], -f[i - 1])));\n\tcout << ans;\n\treturn 0;\n}\n/*\n3\n0 1 1\n5 7 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[1000010], invf[1000010];\nint comb(int n, int k) {\n    if(n < k) return 0;\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\n\nint N;\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 1000010; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 1000010; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N;\n\n    int ans = 0;\n    for(int i = 0; i < N - 1; i++) {\n        int tmp = comb(N - 1, i);\n        tmp += mod - comb(i - 1, N - 1 - i);\n        tmp %= mod;\n        ans += 1LL * fact[i] * fact[N - 1 - i] % mod * tmp % mod;\n        ans %= mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\ninline int mul(int x, int y) {return (ll)x * y % mod;}\ninline int inc(int x, int y) {x += y; return x >= mod ? x - mod : x;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = (ll)x * x % mod)\n\t\tif (y & 1) res = (ll)res * x % mod;\n\treturn res; \n}\nconst int MAXN = 1e6 + 10;\nint n, fac[MAXN], inv[MAXN];\ninline int binom(int x, int y) {return y < 0 || y > x ? 0 : mul(fac[x], mul(inv[y], inv[x - y]));}\n\nint main()\n{\n\tcin >> n;\n\tif (n == 2) return puts(\"1\"), 0;\n\tif (n == 3) return puts(\"4\"), 0;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tinv[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n; i >= 2; i --)\n\t\tinv[i - 1] = mul(inv[i], i);\n\tint ans = fac[n - 1];\n\tfor (int i = 1; i < n - 1; i ++)\n\t{\n\t\tint cnt = binom(i - 1, n - i - 1);\n\t\tcnt = mul(cnt, fac[i]);\n\t\tcnt = mul(cnt, fac[n - i - 1]);\n\t\tcnt = inc(fac[n - 1], mod - cnt);\n\t\tans = inc(ans, cnt);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " /*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#pragma GCC optimize \"-oFast\"\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int MAXN = 1000228;\nconst int P = 424243;\nconst int Mod = 1000000007;\n\nint n,m,cnt,ans;\nint fac[MAXN],ine[MAXN],f[MAXN];\n\n\nvoid add(int &a,int b){a+=b;if(a>=Mod)a-=Mod;}\nint cc(int a,int b)\n{\n    if(a<0 || b<0 || a<b)return 0;\n    return 1LL * fac[a]*ine[b]%Mod*ine[a-b]%Mod;\n}\nint pw(int i,int k)\n{\n    int a=1;\n    while(k) {\n        if(k&1)a=1LL * a*i%Mod;\n        i=1LL * i*i%Mod;k>>=1;\n    }\n    return a;\n} \n\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    //read(FILENAME);\n    cin >> n;\n    fac[0] = ine[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fac[i] = 1LL * fac[i-1] * i % Mod;\n    }\n    ine[n] = pw(fac[n], Mod - 2);\n    for (int i = n - 1; i; i--){\n        ine[i] = 1LL * ine[i+1]*(i+1)%Mod;\n    }\n    for (int i = 1; i < n; i++){\n        f[i ]= 1LL * cc(i-1,n-i-1)*fac[i]%Mod*fac[n-1-i]%Mod,add(ans,1LL * (f[i]-f[i-1]+Mod)*i%Mod);\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 1000005\n#define ll long long\n#define upperlimit 1000100\n#define INF 1e18\n#define eps 1e-8\n#define endl '\\n'\n#define pcc pair<char,char>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)\n#define MOD 1000000007LL\n#define slld(t) scanf(\"%lld\",&t)\n#define sd(t) scanf(\"%d\",&t)\n#define pd(t) printf(\"%d\\n\",t)\n#define plld(t) printf(\"%lld\\n\",t)\n#define mp(a,b) make_pair(a,b)\n#define FF first\n#define SS second\n#define pb(x) push_back(x)\n#define vi vector<int>\n#define vll vector<ll>\n#define clr(a) memset(a,0,sizeof(a))\n#define debug(a) printf(\"check%d\\n\",a)\n#define csl ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\n \nll gcd(ll n1,ll n2){\n\tif(n2==0)\n\t\treturn n1;\n\tif(n1%n2==0)return n2;\n\treturn gcd(n2,n1%n2);\n}\nll powmod(ll base,ll exponent)\n{\n\tif(exponent<0) exponent+=MOD-1;\n\tll ans=1;\n\twhile(exponent){\n\t\tif(exponent&1)ans=(ans*base)%MOD;\n\t\tbase=(base*base)%MOD;\n\t\texponent/=2;\n\t}\n\treturn ans;\n}\nll fact[MAX],ifact[MAX];\nint main()\n{\n\tfact[0]=1;\n\tifact[0]=1;\n\tfor(int i=1;i<MAX;i++)\n\t{\n\t\tfact[i]=(i*1LL*fact[i-1])%MOD;\n\t\tifact[i]=powmod(fact[i],-1);\n\t}\n\tll ans=0;\n\tint n;\n\tcin>>n;\n\tll prev=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i-1>=n-i-1)\n\t\t{\n\t\t\tll temp=fact[i-1]*ifact[n-i-1];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=ifact[i-1-n+i+1];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=fact[i];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=fact[n-i-1];\n\t\t\ttemp%=MOD;\n\t\t\tans+=MOD-prev;\n\t\t\tprev=temp;\n\t\t\t//cout<<i<<\" \"<<temp<<endl;\n\t\t\tans%=MOD;\n\t\t}\n\t\tans+=fact[n-1];\n     \tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a) for(int i=0;i<(a);i++)\nconst ll MOD=1000000007;\n\nconst int MAX_N=1010101;\nll P[MAX_N];\nll inv[MAX_N+1], fact[MAX_N+1], ifact[MAX_N+1];\n\nll C(int n, int k){\n  if(n<k) return 0LL;\n  return fact[n]*ifact[k]%MOD*ifact[n-k]%MOD;\n}\n\nvoid prepare(){\n  inv[1]=fact[0]=fact[1]=ifact[0]=ifact[1]=1LL;\n  for(int i=2;i<=MAX_N;i++){\n    inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    fact[i]=fact[i-1]*i%MOD;\n    ifact[i]=ifact[i-1]*inv[i]%MOD;\n  }\n}\n\n\nint main(){\n  prepare();\n  int N; cin>>N;\n  if(N==2){\n    cout<<1<<endl;\n    return 0;\n  }\n  ll ans=0,prev=0;\n  for(ll i=2;i<=(N-1);i++){\n    ll x=C(i-1,N-i-1)*fact[i]%MOD*fact[N-i-1]%MOD,y=(x-prev+MOD)%MOD;\n    (ans+=y*i)%=MOD;\n    prev=x;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n    const int maxSize = 1000001;\n\tvector<long long> inv(maxSize);\n\tvector<long long> fact(maxSize);\n\tvector<long long> factInv(maxSize);\n\tfor(int i=0;i<2;i++) inv[i] = fact[i] = factInv[i] = 1;\n\tfor(int i=2;i<maxSize;i++){\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tfactInv[i] = factInv[i-1] * inv[i] % MOD;\n\t}\n\tauto comb = [&](int n, int r){\n\t\tif(n < r || r < 0) return 0LL;\n\t\treturn fact[n] * factInv[n-r] % MOD * factInv[r] % MOD;\n\t};\n    auto perm = [&](int n, int r){\n        if(n < r || r < 0) return 0LL;\n        return fact[n] * factInv[n-r] % MOD;\n    };\n    int N; cin >> N;\n    long long res = 0;\n    long long sum = 0;\n    long long p1 = (N-2)%2, p2 = (N-2)/2;\n    while(p2 >= 0){\n        long long ch = p1+p2+1;\n        long long sel = comb(p1+p2, p1) * fact[ch] % MOD * fact[N-1-ch] % MOD;\n        sel = (sel + MOD - sum) % MOD;\n        res = (res + sel * ch) % MOD;\n        sum = (sum + sel) % MOD;\n        p1 += 2;\n        --p2;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nconst int q=1000000007;\nint n,a[1000010],b[1000010],p;\ninline int C(int n,int m)\n{\n\tif(m<0 || m>n)\n\t  return 0;\n\treturn (L)a[n]*b[m]%q*b[n-m]%q;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i;\n\tscanf(\"%d\",&n);\n\ta[0]=1;\n\tfor(i=1;i<=n;i++)\n\t  a[i]=(L)a[i-1]*i%q;\n\tb[0]=b[1]=1;\n\tfor(i=2;i<=n;i++)\n\t  b[i]=q-(L)q/i*b[q%i]%q;\n\tfor(i=2;i<=n;i++)\n\t  b[i]=(L)b[i]*b[i-1]%q;\n\tfor(i=0;i<n;i++)\n\t  p=(p+a[n-1]-(L)C(i-1,n-1-i)*a[i]%q*a[n-1-i])%q;\n\tp=(p+q)%q;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9+7;\nconst int MAXN=1e6+10;\nll fac[MAXN],inv[MAXN];\nll n,sum;\nvoid init()\n{\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=(fac[i-1]*(ll)i)%mod;\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\t\n\tfor (int i=2;i<=n;i++) inv[i]=(inv[i-1]*inv[i])%mod;\n}\nll C(int x,int y)\n{\n\tif (x<0||y<0||x<y) return 0;\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tinit();\n\tll ans=0;\n    for (int i=1;i<n;i++)\n    \t ans=(ans+(ll)i*((C(i-1,n-1-i)*fac[i]%mod*fac[n-1-i]%mod-C(i-2,n-i)*fac[i-1]%mod*fac[n-i]%mod+mod)%mod)%mod)%mod;\n    cout << ans << endl; \n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define N 500055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,fac[N],inv[N],f[N],ans;\nint C(int n,int m){\n\tif (n<m||m<0) return 0;\n\treturn (ll) fac[n]*inv[n-m]%mod;\n}\nint ksm(int x,int k){\n\tint sum=1;\n\twhile (k){\n\t\tif (k&1) sum=(ll)sum*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn sum;\n}\nsigned main(){\n\tn=read();\n\tfac[0]=1;F(i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);D(i,n-1,0) inv[i]=(ll)inv[i+1]*(i+1)%mod;\n\tF(i,(n+1)/2,n-1){\n\t\tf[i]=(ll)C(i-1,n-i-1)*fac[i]%mod;\n\t\tans=(ans+(ll)(f[i]-f[i-1])*i)%mod;\n\t}\n\twrn((ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 2000000;\nconst int mo = 1e9 + 7;\n\nint n;\nint fac[N + 5], inv[N + 5];\n\nint fpm(int x, int y) {\n    int res = 1;\n    for(; y > 0; y >>= 1) {\n        if(y & 1)\n            res = (ll) res * x % mo;\n        x = (ll) x * x % mo;\n    }\n    return res;\n}\n\nvoid init() {\n    fac[0] = 1;\n    for(int i = 1; i <= N; ++i) fac[i] = (ll) fac[i-1] * i % mo;\n    inv[N] = fpm(fac[N], mo - 2);\n    for(int i = N; i >= 1; --i) inv[i-1] = (ll) inv[i] * i % mo;\n}\n\ninline int binom(int x, int y) {\n    if(x < 0 || y < 0 || x < y) return 0;\n    return (ll) fac[x] * inv[y] % mo * inv[x - y] % mo;\n}\n\nint main() {\n#ifdef Wearry \n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    init();\n    scanf(\"%d\", &n);\n\n    int ans = (ll) fac[n-1] * (n-1) % mo;\n    for(int k = 1; k < n; ++k) {\n        ans = (ans - (ll) binom(n - 3 - k + 1, k) * fac[n - 1 - k] % mo * fac[k]) % mo; \n    }\n    ans = (ans + mo) % mo;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define ALL(v) (v).begin(), (v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x, n) bitset<n>(x)\n#define PI 3.14159265358979323846\n \ntypedef long long ll;\ntypedef pair< int, int > P;   \ntypedef pair< ll, P > PP;\n\n//-----------------------------------------------------------------------------\n\nll n;\nconst int MAX_N = 1000010;\nconst int MOD = 1e9 + 7;\nll fact[MAX_N], inv_fact[MAX_N];\n\nll mypow(ll a, int b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b & 1) (res *= a) %= MOD;\n\t\t(a *= a) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nvoid prv_calc() {\n\tfact[0] = 1;\n\tFOR(i, 1, MAX_N) fact[i] = fact[i - 1] * i % MOD;\n\tinv_fact[MAX_N - 1] = mypow(fact[MAX_N - 1], MOD - 2);\n\tRREP(i, MAX_N - 1) inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n}\n\nll comb(ll N, ll R) {\n\tif (R < 0 || N < R) return 0;\n\treturn fact[N] * inv_fact[R] % MOD * inv_fact[N - R] % MOD;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tprv_calc();\n\n\tcin >> n;\n\tll ans = 0, prv = 0, cur = 0;\n\tFOR(i, (n + 1) / 2, n) {\n\t\tcur = comb(i - 1, n - i - 1) * fact[i] % MOD * fact[n - i - 1] % MOD;\n\t\t(ans += (cur - prv + MOD) % MOD * i % MOD) %= MOD;\n\t\tprv = cur;\n\t}\n\tcout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string>\n#include<functional>\nusing namespace std;\ntypedef\tlong long int ll;\n\nint main(){\n    ll N = 1000000007;\n    ll n;\n    cin >> n;\n    ll s = 1;\n    for(ll i= 2; i < n; i++){\n        s = (s*i)%N;\n    }\n    s = (s*(n-1))%N;\n    ll t = 1;\n    for(ll i = 2; i <= n-2; i++){\n        t = (t*i)%N;\n    }\n    if(n==2) t = 0;\n    t = (t*(n-3))%N;\n    ll u = s-t;\n    cout << u << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define set0(x) memset(x,0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();ll f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\n\nint mod = 998244353;\ninline int mul(int x,int y){return 1ll*x*y%mod;}\ninline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\ninline int sub(int x,int y){return x-y<0?x-y+mod:x-y;}\ninline int sq(int x){return 1ll*x*x%mod;}\nint mpow(int a,int b){return b == 0 ? 1 : ( b&1 ? mul(a,sq(mpow(a,b/2))) : sq(mpow(a,b/2)));}\n\nconst int N = 1000000;\nint fac[N+10],invfac[N+10],n,k;\n\nint C(int n,int m){\n\tif(n<0 || m<0 || m>n)return 0;\n\treturn mul(fac[n],mul(invfac[m],invfac[n-m]));\n}\n\nint main() {\n\tfac[0] = 1;\n\tfor(int i=1;i<=N;i++)fac[i] = mul(fac[i-1],i);\n\tinvfac[N] = mpow(fac[N],mod-2);\n\tfor(int i=N-1;i>=0;i--) invfac[i] = mul(invfac[i+1],i+1);\n\tread(n);\n\tint ans = fac[n];\n\tfor(int i=1;i<=n-1;i++){\n\t\tif(i*2<n)continue;\n\t\tint b0 = i*2-n,d0 = i-b0;\n\t\tassert(d0!=0);\n\t\tans = sub(ans,mul(C(i-1,d0-1),mul(fac[i],fac[n-1-i])));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define N 1000005\nusing namespace std;\nint n,fac[N],inv[N];\nint C(int x,int y){\n\tif (x<y) return 0;\n\treturn 1ll*fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++)\n\t\tinv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tfor (int i=1;i<=n;i++){\n\t\tfac[i]=1ll*fac[i-1]*i%mo;\n\t\tinv[i]=1ll*inv[i-1]*inv[i]%mo; \n\t}\n\tint ans=1ll*(n-1)*fac[n-1]%mo;\n\tfor (int i=(n+1)/2;i<n-1;i++)\n\t\tans=(ans+mo-1ll*fac[i]*fac[n-1-i]%mo*C(i-1,n-i-1)%mo)%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433L;\n\ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n/*\n * @title ModInt\n */\ntemplate<long long mod> class ModInt {\npublic:\n\tlong long x;\n\tconstexpr ModInt():x(0) {\n\t\t// do nothing\n\t}\n\tconstexpr ModInt(long long y) : x(y>=0?(y%mod): (mod - (-y)%mod)%mod) {\n\t\t// do nothing\n\t}\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const long long y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const int y) {\n\t\tModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const long long y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const int y) {\n\t\tModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const long long y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const int y) {\n\t\tModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt operator=(const int y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator=(const long long y) {\n\t\tModInt p(y);\n\t\t*this = p;\n\t\treturn *this;\n\t}\n\tModInt operator-() const { return ModInt(-x); }\n\tModInt operator++() { \n\t\tx++;\n\t\tif(x>=mod) x-=mod;\n\t\treturn *this; \n\t}\n\tModInt operator--() { \n\t\tx--;\n\t\tif(x<0) x+=mod;\n\t\treturn *this; \n\t}\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\tModInt inv() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(long long n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tlong long t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n};\nusing modint = ModInt<MOD>;\n\n/*\n * @title CombinationMod\n */\ntemplate<long long mod> class CombinationMod {\n\tvector<long long> fac,finv,inv;\npublic:\n\tCombinationMod(int N) : fac(N + 1), finv(N + 1), inv(N + 1) {\n\t\tfac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n\t\tfor (int i = 2; i <= N; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % mod;\n\t\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n\tinline long long binom(int n, int k) {\n\t\treturn ((n < 0 || k < 0 || n < k) ? 0 : fac[n] * (finv[k] * finv[n - k] % mod) % mod);\n\t}\n\tinline long long factorial(int n) {\n\t\treturn (n<0?0:fac[n]);\n\t}\n};\n//verify https://atcoder.jp/contests/abc021/tasks/abc021_d\nCombinationMod<MOD> CM(1000000);\nll N; \nmodint f(int l,int r) {\n    modint sum = 0;\n    for(int i=0;i<=N/2;++i) {\n        ll use=i;\n        use += (l&1?(l-1)/2+1:l/2);\n        use += (r&1?(r-1)/2+1:r/2);\n        ll res=N-1-(use+1);\n        ll can=0;\n        can += (l&1?(l-3)/2:max(0,(l-2)/2));\n        can += (r&1?(r-3)/2:max(0,(r-2)/2));\n        modint cnt = 1;\n        cnt *= CM.factorial(use);\n        cnt *= CM.factorial(res);\n        cnt *= CM.binom(can,i);\n        cnt *= use+1;\n        sum += cnt;\n    }\n    return sum;\n}\nint main() {\n    cin >> N;\n    corner(N==2,1);\n    corner(N==3,4);\n    modint ans = 0;\n\tmap<int,map<int,map<int,modint>>> mp;\n\tmp[N-1][0][0]=f(0,N-1);\n\tif((N-1)%2==0)mp[N-1][1][1]=f(1,N-2);\n\tif((N-1)%2==0)mp[N-1][2][2]=f(2,N-3);\n\tif((N-1)%2==1)mp[N-1][1][2]=mp[N-1][2][1]=f(1,N-2);\n\tmp[N-2][0][0]=f(0,N-2);\n\tif((N-2)%2==0)mp[N-2][1][1]=f(1,N-3);\n\tif((N-2)%2==0)mp[N-2][2][2]=f(2,N-4);\n\tif((N-2)%2==1)mp[N-2][1][2]=mp[N-2][2][1]=f(1,N-3);\n\tfor(int i = 1; i+1<=N; ++i) {\n        {\n            int l = i-1,r=N-(i+1),s=l+r;\n\t\t\tmodint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n\t\t\tif(l==0||r==0)l=0,r=0;\n\t\t\telse l=2-(l%2),r=2-(r%2);\n            ans += coe*mp[s][l][r];\n        }\n        {\n            int l = i-1,r=N-i,s=l+r;\n\t\t\tmodint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n\t\t\tif(l==0||r==0)l=0,r=0;\n\t\t\telse l=2-(l%2),r=2-(r%2);\n            ans += coe*mp[s][l][r];\n        }\n        {\n            int l = i,r=N-(i+1),s=l+r;\n\t\t\tmodint coe=1;\n            if(l&1) coe *= (l-1)/2;\n            if(r&1) coe *= (r-1)/2;\n\t\t\tif(l==0||r==0)l=0,r=0;\n\t\t\telse l=2-(l%2),r=2-(r%2);\n            ans += coe*mp[s][l][r];\n       }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " /*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#pragma GCC optimize \"-oFast\"\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int MAXN = 1000228;\nconst int P = 424243;\nconst int Mod = 1000000007;\n\nint n,m,cnt,ans;\nint fac[MAXN],ine[MAXN],f[MAXN];\n\n\nvoid add(int &a,int b){a+=b;if(a>=Mod)a-=Mod;}\nint cc(int a,int b)\n{\n    if(a<0 || b<0 || a<b)return 0;\n    return 1LL * fac[a]*ine[b]%Mod*ine[a-b]%Mod;\n}\nint pw(int i,int k)\n{\n    int a=1;\n    while(k) {\n        if(k&1)a=1LL * a*i%Mod;\n        i=1LL * i*i%Mod;k>>=1;\n    }\n    return a;\n} \n\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    //read(FILENAME);\n    cin >> n;\n    fac[0] = ine[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fac[i] = 1LL * fac[i-1] * i % Mod;\n    }\n    ine[n] = pw(fac[n], Mod - 2);\n    for (int i = n - 1; i; i--){\n        ine[i] = 1LL * ine[i+1]*(i+1)%Mod;\n    }\n    for (int i = 1; i < n; i++){\n        f[i ]= 1LL * cc(i-1,n-i-1)*fac[i]%Mod*fac[n-1-i]%Mod,add(ans,1LL * (f[i]-f[i-1]+Mod)*i%Mod);\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Gear4        \n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#define FOR0(i,n) for(int i=0, _##i=(n); i<_##i; ++i)\n#define FOR(i,l,r) for(int i=(l), _##i=(r); i<_##i; ++i)\n#define FORD(i,l,r) for(int i=(r), _##i=(l); --i>=_##i; )\n#define SZ(a) ((int)((a).size()))\n#define printCase() \"Case #\" << caseNum << \": \"\n#define pb push_back\n#define mp make_pair\n#define SYNC std::ios::sync_with_stdio(false);  cin.tie(NULL);\n#define ff first\n#define ss second\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T, typename U> using P = pair<T,U>;\nusing ld = long double;\nusing ll = long long;\n#define endl '\\n'\nconst int inf = 1e9, mod = 1e9 + 7;\nconst ll INF = 9e18;\nconst ld EPS = 1e-9, PI = acosl(-1.0);\nconst int N = 1e6 + 6;\nint n;\nll fac[N], ifac[N];\nll ch(int n, int r) {\n    if(r < 0 || r > n) return 0;\n    return fac[n] * 1LL * (ifac[r] * 1LL * ifac[n-r] % mod) % mod;\n}\nint modexp(ll a, int b, ll p) {\n    ll ret = 1;\n    for(; b; b>>=1) {\n        if(b & 1) ret = ret * a % p;\n        a = a * a % p;\n    }\n    return ret;\n}\nint main() {\n    SYNC\n    fac[0] = ifac[0] = 1;\n    for(int i = 1; i<N; i++) fac[i] = fac[i-1] * 1LL * i % mod;\n    for(int i = 1; i<N; i++) ifac[i] = modexp(fac[i], mod-2, mod);\n    cin >> n;\n    ll ans = 0, cur = 0, pre = 0;\n    for(int i = 1; i < n; i++) {\n        cur = ch(i-1, n-i-1) * fac[i] % mod;\n        cur = cur * fac[n-i-1] % mod;\n        (ans += i * (cur-pre) % mod) %= mod;\n        pre = cur;\n    }\n    if(ans<0) ans += mod;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nconst ll MOD = 1e9+7;\n\nvector<int> memo(1000001,-1);\nint fact(int n){\n    n%=MOD;\n    if(memo[n]!=-1)return memo[n];\n    else return memo[n] = (fact(n-1)*n)%MOD;\n}\n\nll power(ll a,ll b){\n    ll ret=1;\n    if(b>0){\n        ret = power(a,b/2);\n        if(b%2==0)ret = (ret*ret)%MOD;\n        else ret = (((ret*ret)%MOD)*a)%MOD;\n    }\n    return ret;\n}\n\n\nint inv(int p){\n    return power(p,MOD-2);\n}\n\nint f(int n, int k){\n    int a = 2*k-n;\n    int b = n-k-1;\n    if(a<0 || b<0)return 0;\n    \n    return ((((fact(a+b) * inv(fact(a)))%MOD * inv(fact(b)))%MOD * fact(k))%MOD * fact(n-k-1))%MOD;\n}\n\nsigned main(){\n    memo[0] = 1;\n    int n;\n    cin>>n;\n    \n    int ans = 0;\n    for(int k=1; k<=n-1; k++){\n        (ans += k*(f(n,k)-f(n,k-1)))%=MOD;\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <boost/math/special_functions/factorials.hpp>\n \nint64_t score(int n) {\n  if (n == 2)\n    return 1;\n  if (n == 3)\n    return 4;\n  if (n == 4)\n    return 16;\n  return ((boost::math::factorial(n-2) + score(n-1)) * (n-1) -2 * boost::math::factorial(n-3)) % (10000000007);\n}\n \nint main() {\n  int n;\n  std::cin >> n;\n  std::cout << score(n) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nconst int mod=1e9+7,N=1e6+5;\n\nint n,fac[N],inv[N],f[N];\n\ninline int combn(int n,int m){\n\tif(n<m) return 0;\n\telse return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main(){\n\tscanf(\"%d\",&n); int ans=0; fac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=n-1;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tfor(int i=2;i<=n-1;++i) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=n-1;++i) inv[i]=1ll*inv[i-1]*inv[i]%mod;\n\tfor(int i=1;i<=n-1;++i) f[i]=1ll*combn(i-1,n-1-i)*fac[i]%mod*fac[n-1-i]%mod;\n\tfor(int i=1;i<=n-1;++i) ans=(ans+1ll*(f[i]-f[i-1]+mod)%mod*i%mod)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\nusing namespace std;\ntypedef long long int lli;\nint main() {fio; // remove during scanf\n\tint a[] = {1, 4, 16, 84, 656, 8148, 167568, 5866452, 356855440};\n\tint n;\n\tcin >> n;\n\tcout << a[n - 2];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T>void gi(T &x){\n\tint f;char c;\n\tfor(f=1,c=getchar();c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(x=0;c<='9'&&c>='0';c=getchar())x=x*10+(c&15);x*=f;\n}\nconst int N=1e6+10,mod=1e9+7;\nint Fac[N],inv[N],n,f[N];\ninline int C(int n,int m){\n\treturn 1ll*Fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n  cin>>n;\n  int ans=0,li=(n+1)/2;\n  Fac[0]=inv[0]=inv[1]=1;\n  for(int i=1;i<=n;i++)Fac[i]=1ll*Fac[i-1]*i%mod;\n  for(int i=2;i<=n;i++)inv[i]=(mod-1ll*(mod/i)*inv[mod%i]%mod)%mod;\n  for(int i=2;i<=n;i++)inv[i]=1ll*inv[i]*inv[i-1]%mod;\n  for(int i=li;i<n;i++)f[i]=1ll*C(i-1,n-1-i)*Fac[i]%mod*Fac[n-1-i]%mod;\n  for(int i=n-1;i>=li;i--)f[i]=(f[i]-f[i-1]+mod)%mod;\n  for(int i=n-1;i>=li;i--)ans=(ans+1ll*i*f[i])%mod;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000100;\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) x -= md;\n}\n\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) x += md;\n}\n\ninline int mul(int x, int y) {\n  return 1ll * x * y % md;\n}\n\ninline int power(int x, int y) {\n  int res = 1;\n  while (y > 0) {\n    if (y & 1) res = mul(res, x);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return res;\n}\n\ninline int inverse(int x) {\n  return power(x, md - 2);\n}\n\nint fac[N], ifac[N];\n\nvoid precalc() {\n  fac[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fac[i] = mul(fac[i - 1], i);\n  }\n  ifac[N - 1] = inverse(fac[N - 1]);\n  for (int i = N - 2; i >= 0; i--) {\n    ifac[i] = mul(ifac[i + 1], i + 1);\n  }\n}\n\nint C(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return mul(fac[n], mul(ifac[k], ifac[n - k]));\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  precalc();\n  int n;\n  cin >> n;\n  if (n == 1) {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  vector<int> g(n);\n  int res = 0;\n  for (int i = 1; i < n; i++) {\n    g[i] = mul(C(i - 1, n - 1 - i), mul(fac[i], fac[n - 1 - i]));\n    sub(g[i], g[i - 1]);\n    add(res, mul(i, g[i]));\n    add(g[i], g[i - 1]);\n  }\n  cout << res << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 1000000007\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\nint main(int argc, char const *argv[]) {\n  init();\n  ll n, ans = 0;std::cin >> n;\n  ll s = 0;\n  for(ll i=n/2+n%2;i<n;i++){\n    ll tmp = pp(fac[i], fac[n-1-i]);\n    tmp = pp(tmp, comb(i-1, n-1-i));\n    tmp = (tmp - s + P)%P;\n    s = (s + tmp)%P;\n    ans = (ans + pp(i, tmp))%P;\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n#define endl \"\\n\"\n \nconst LD eps=1e-10;\nconst long long INFLL=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9;\n \ntemplate<class T>\nvoid chmin(T& a, const T b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tfor(int i=0;i<q;i++)\n\t\tt*=p;\n\treturn t;\n}\n\ntemplate <typename T>\nstruct has_iter\n{\n\tprivate:\n\t\ttemplate <typename U>\n\t\tstatic constexpr true_type check(typename U::iterator*);\n\t\ttemplate <typename U>\n\t\tstatic constexpr false_type check(...);\n\n\tpublic:\n\t\tstatic constexpr bool value = decltype(check<T>(nullptr))::value;\n};\n\n\ntemplate<typename T, typename U = typename T::iterator>\nvoid print(const T& container)\n{\n\t\tauto&& first=begin(container), last=end(container);\n\t\tauto&& back=prev(last);\n\t\tfor(auto e=first; e!=last; e=next(e))\n\t\t\tcout<<*e<<\" \\n\"[e==back];\n}\n\n\nextern void* enabler;\ntemplate<typename Head, typename enable_if<!has_iter<Head>::value>::type*& = enabler>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<> void print<string>(const string& container)\n{\n\tcout<<container<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec)\n{\n\tfor(T& x: vec) is >> x;\n\treturn is;\n}\n\n\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& p)\n{\n\tos<<'('<<p.first<<\", \"<<p.second<<')';\n\treturn os;\n}\n\ntemplate<typename T>\nvector<T> read(int n)\n{\n\tvector<T> t(n);\n\tcin>>t;\n\treturn t;\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\ntemplate<typename Head, typename... Tail>\nstruct vector_demensions\n{\n\tusing type=vector<typename vector_demensions<Tail...>::type>;\n};\n\ntemplate<typename Head>\nstruct vector_demensions<Head> { using type=Head; };\n\ntemplate<typename T>\nvector<T> make_vectors(int size, T val)\n{\n\treturn vector<T>(size, val);\n}\n\ntemplate<typename T=int, typename... Args>\nauto make_vectors(int size, Args... tail)\n\t-> typename vector_demensions<Args..., T>::type\n{\n\tauto val=make_vectors<T>(forward<Args>(tail)...);\n\treturn vector<decltype(val)>(size, val);\n}\n\n\nclass Mod\n{\n\tpublic:\n\t\tusing value_type = long long;\n\tprivate:\n\t\tstatic const value_type MODULO = 1e9+7;\n\t\tvalue_type value;\n\n\t\tconstexpr value_type Normalize(value_type x) const\n\t\t{\n\t\t\treturn x<0?(x%MODULO+MODULO):(x%MODULO);\n\t\t}\n\n\tpublic:\n\t\tconstexpr Mod():value(0){}\n\t\tconstexpr Mod(const value_type &val):value(Normalize(val)) {}\n\t\t\n\t\texplicit operator value_type () const\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\tconstexpr const Mod operator -() const\n\t\t{\n\t\t\treturn Mod(MODULO - value);\n\t\t}\n\t\tconstexpr const Mod operator +(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value + rhs.value);\n\t\t}\n\t\tconstexpr const Mod operator -(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value + (-rhs).value);\n\t\t}\n\t\tconstexpr const Mod operator *(const Mod &rhs) const\n\t\t{\n\t\t\treturn Mod(value * rhs.value);\n\t\t}\n\t\tMod &operator +=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\tMod &operator -=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\tMod &operator *=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\n\n\t\tMod pow(value_type p) const;\n\n\t\tMod inv() const\n\t\t{\n\t\t\treturn pow(MODULO-2);\n\t\t}\n\n\t\tconst Mod operator /(const Mod &rhs) const\n\t\t{\n\t\t\treturn *this * rhs.inv();\n\t\t}\n\t\tMod &operator /=(const Mod &rhs)\n\t\t{\n\t\t\treturn *this = *this / rhs;\n\t\t}  \n\t\tconstexpr bool operator ==(const Mod &rhs)\n\t\t{\n\t\t\treturn value == rhs.value;\n\t\t}\n};\n\nMod Mod::pow(value_type p) const\n{\n\tMod tmp=1, mult=*this;\n\twhile(p)\n\t{\n\t\tif((p&1)>0) tmp*=mult;\n\t\tp>>=1;\n\t\tmult*=mult;\n\t}\n\treturn tmp;\n}\n\nnamespace std\n{\n\tostream& operator<<(ostream& os, const Mod mod)\n\t{\n\t\tos<<(typename Mod::value_type)mod;\n\t\treturn os;\n\t}\n};\n\nclass Factorial\n{\n\tprivate:\n\t\tvector<Mod> ary;\n\tpublic:\n\t\texplicit Factorial(const size_t size):ary(vector<Mod>(size))\n\t\t{\n\t\t\tary[0]=1;\n\t\t\tfor(size_t i=1;i<size;i++)\n\t\t\t\tary[i]=ary[i-1]*i;\n\t\t}\n\n\t\tsize_t size() const {   return ary.size();  }\n\n\t\tMod operator[] (const int id) const\n\t\t{\n\t\t\treturn ary[id];\n\t\t}\n};\nclass FactorialInv\n{\n\tprivate:\n\t\tvector<Mod> ary;\n\tpublic:\n\t\texplicit FactorialInv(const Factorial &fact):ary(vector<Mod>(fact.size()))\n\t\t{\n\t\t\tfor(size_t i=0;i<ary.size();i++)\n\t\t\t\tary[i]=fact[i].inv();\n\t\t}\n\n\t\t//FactorialInv& operator=(FactorialInv&&)=default;\n\n\t\tMod operator[] (const int id) const\n\t\t{\n\t\t\treturn ary[id];\n\t\t}\n};\n\nclass Combination\n{\n\tprivate:\n\t\tconst Factorial *fact;\n\t\tconst FactorialInv *fact_inv;\n\tpublic:\n\t\tCombination(const Factorial &fact_, const FactorialInv &fact_inv_):fact(&fact_),fact_inv(&fact_inv_)\n\t\t{}\n\n\t\tMod operator()(const int n, const int m) const\n\t\t{\n\t\t\treturn (*fact)[n] * (*fact_inv)[m] * (*fact_inv)[n-m];\n\t\t}\n};\n\n\nint main()\n{\n\tconst int N=1000000*2;\n\tFactorial fa(N);\n\tFactorialInv fi(fa);\n\tCombination comb(fa,fi);\n\tint n;\n\tcin>>n;\n\tMod ans=0, sum=0, t;\n\tFOR(k,1,n+1)\n\t{\n\t\tif(!(0<=n-k-1&&n-k-1<=k-1)) continue;\n\t\tt=comb(k-1, n-k-1)*fa[k]*fa[n-k-1];\n\t\t//print(k,t);\n\t\tans+=(t-sum)*Mod(k);\n\t\tsum+=t;\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define repr(i,b,e) for(int i = (b); i <= (e); i++)\n#define INF (1001001001)\n#define EPS (1e-15)\n\n#define pr(x) do{cerr << (#x) << \" = \" << (x) << endl;}while(0)\n#define pri(x,i) do{cerr << (#x) << \"[\" << i << \"] = \" << (x[i]) << endl;}while(0)\n#define pra(x) do{rep(__i,(x).size()) pri(x,__i);}while(0)\n#define pran(x,n) do{rep(__i,n) pri(x,__i);}while(0)\n#define pral(x) do{cerr << (#x) << \" =\";rep(__i,(x).size()) cerr<<\" \"<<(x[__i]);cerr<<endl;}while(0)\n#define prar(x,b,e) do{repr(__i,b,e) pri(x,__i);}while(0)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool CHMAX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool CHMIN(T &l,const T &r){return l>r?l=r,1:0;}\n\nll MOD = 1000000007;\n\nfunction<void(int,int)> tensi_no_3p=[&](int v,int d){\n};\n\nint in() {\n\tint a;\n\tscanf(\"%d \", &a);\n\treturn a;\n}\n\nll inv(ll a) {\n\tll ret = 1;\n\tll t = a;\n\tll n = MOD - 2;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1) ret = (ret * t) % MOD;\n\t\tt = t * t % MOD;\n\t\tn /= 2;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tassert(inv(42) * 42 % MOD == 1);\n\tll N;\n\tcin >> N;\n\tll minN = (N + 1) / 2;\n\tvector<ll> cums(N + 1);\n\tvector<ll> fact(N + 1);\n\tfact[0] = 1;\n\trepr(i, 1, N) fact[i] = fact[i - 1] * i % MOD;\n\tcums[minN] = fact[minN - 1] * fact[minN] % MOD * inv(fact[2 * minN - N]) % MOD;\n\trepr(k, minN, N - 2) {\n\t\tcums[k + 1] = cums[k] * k % MOD * (k + 1) % MOD * inv(2 * k - N + 1) % MOD * inv(2 * k - N + 2) % MOD;\n\t}\n\tpra(cums);\n\tll ans = 0;\n\trepr(k, 1, N - 1) {\n\t\tans += k * (cums[k] - cums[k - 1]) % MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\nint hoge() {\n\tint N;\n\tcin >> N;\n\tvint P(N - 1);\n\trep(i, N - 1) P[i] = i;\n\tll ans = 0;\n\tdo {\n\t\tvint box(N);\n\t\tint n = 0;\n\t\tint i;\n\t\tfor (i = 0; i < N - 1; i++) {\n\t\t\tif (box[P[i]] == 0) n++, box[P[i]]++;\n\t\t\tif (box[P[i] + 1] == 0) n++, box[P[i] + 1]++;\n\t\t\tif (n == N) break;\n\t\t}\n\t\tans = (ans + i + 1) % MOD;\n\t} while (next_permutation(P.begin(), P.end()));\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (1000006)\nll n,f[MAXN],inv[MAXN],mod=1e9+7,ans;\nint main(){\n\tFAST\n\tcin>>n;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\twhile(e){\n\t\t\tif(e&1) sum*=x, sum%=mod;\n\t\t\tx*=x,x%=mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn sum;\n\t};\n\tauto C=[&](ll n,ll k){\n\t\treturn n < k ? 0 : f[n]*inv[k]%mod*inv[n-k]%mod;\n\t};\n\tf[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1] = qexp(f[MAXN-1], mod-2); DEC(i,MAXN-2,0) inv[i]=inv[i+1] * (i+1) % mod;\n\tFOR(k,2,n-2){\n\t\tans -= C(k-1,n-k-1) * f[k] % mod * f[n-1-k] % mod, ans %= mod;\n\t}\n\tans += f[n-1] * (n-1) % mod + mod, ans %= mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <math.h>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <time.h>\n#include <bitset>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n//#define X first\n//#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i, 0, t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n\nconst LD PI = acos(-1.0);\nconst LD EPS = 1e-6;\nconst int INF = 1000000007;\nconst LL LINF = 1e18;\nconst LL mod = 1000000007;\nconst LL MAX = 1000047;\n\nLL F[MAX], INV[MAX], FI[MAX], A[MAX];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint n;\n\tcin >> n;\n\tINV[1] = 1;\n\tF[0] = FI[0] = 1;\n\tFOR(i, 1, n)\n\t{\n\t\tif (i > 1)\n\t\t{\n\t\t\tINV[i] = (-(mod / i) * INV[mod % i]) % mod;\n\t\t\tif (INV[i] < 0)\n\t\t\t\tINV[i] += mod;\n\t\t}\n\t\tF[i] = (F[i - 1] * i) % mod;\n\t\tFI[i] = (FI[i - 1] * INV[i]) % mod;\n\t}\n\tLL ans = 0, s = 0;\n\tFOR(i, (n + 1) >> 1, n)\n\t{\n\t\tLL a = (((F[i] * F[i - 1]) % mod) * FI[(i << 1) - n]) % mod;\n\t\tans += i * (a - s);\n\t\tans %= mod;\n\t\ts += a;\n\t\ts %= mod;\n\t}\n\tif (ans < 0)\n\t\tans += mod;\n\tcout << ans << endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib> \n#include<algorithm>\n\n#define debug printf(\"This is Debug\")\n\nusing namespace std; \n\nint vis[11];\n\nconst long long MOD = 1e9+7;\n\nint arr[]={1,2,3,4,5,6,7,8,9};\n\nint main(){\n\t\n\t//int n=11;\n\t\n\tint n;\n\tscanf(\"%d\",&n);\n\tn--;\n\t\n\tint cnt = 0;\n\tlong long ans = 0;\n\tint i;\n\tdo{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tcnt = 0;\n\t\tfor(i = 0;i<n ; ++i){\n\t\t\tif(vis[arr[i]] == 0){\n\t\t\t\tvis[arr[i]] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(vis[arr[i]+1] == 0){\n\t\t\t\tvis[arr[i]+1] = 1;\n\t\t\t\tcnt++; \n\t\t\t}\n\t\t\tif(cnt == n+1)\n\t\t\t\tbreak;\n\t\t}\n\t\tans += i+1;\n\t\tans = ans % MOD;\n\t}while(next_permutation(arr,arr+n));\n\t\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    if(N == 2){\n        cout << 1;\n        return 0;\n    }\n    int mod = 1000000007;\n\n    Combination C(N, mod);\n    int ans = 0;\n\n    //N - k - 1点以下の組み合わせ\n    vec combs(N, 0);\n    FOR(k, 0, (N - 2) / 2 + 1){\n        int tmp = C.comb(N - k - 2, k);\n        tmp = (tmp * C.fact[N - 1 - k]) % mod;\n        tmp = (tmp * C.fact[k]) % mod;\n        combs[k] = tmp;\n    }\n\n    FOR(k, 0, (N - 2) / 2 + 1){\n        ans += (combs[k] - combs[k + 1] + mod) * (N - k - 1);\n        ans %= mod;\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/rope>\n//using namespace __gnu_pbds;\n//using namespace __gnu_cxx;\n//\n//template<class T> using Tree = tree<T, null_type, less<T>, rb_t_tag,t_order_statistics_node_update>;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n//const long long mod = 998244353;\n\n// watch this\n//using ll = long long;\n//typedef long long LL;\n#define ll long long\n#undef ll\n\nconst int mxN = 2000010;\n\nlong long pow_mod(long long base, long long power) {\n\tlong long res = 1;\n\twhile (power) {\n\t\tif (power & 1)\n\t\t\tres = res * base % mod;\n\t\tbase = base * base % mod;\n\t\tpower >>= 1;\n\t}\n\treturn res;\n}\n\nlong long fact[mxN], inv[mxN];\n\nvoid init() {\n\tfact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i < mxN; i++)\n\t\tfact[i] = i * fact[i - 1] % mod, inv[i] = pow_mod(fact[i], mod - 2);\n}\n\nlong long NcR(long long N, long long R) {\n\tif (N < R || R < 0)\n\t\treturn 0;\n\treturn (fact[N] * inv[R] % mod) * inv[N - R] % mod;\n}\n\nint main(int argc, char** argv) {\n#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n#endif\n\n\tinit();\n\n\tint N;\n\tcin >> N;\n\tlong long res = 0;\n\tlong long sum = 0;\n\tfor (int i = 1; i < N; i++) {\n\t\tlong long cur = (NcR(i - 1, N - i - 1) * fact[i] % mod)\n\t\t\t\t* fact[N - 1 - i] % mod;\n\t\tcur += mod - sum;\n\t\tif (cur >= mod)\n\t\t\tcur -= mod;\n\t\tsum += cur;\n\t\tif (sum >= mod)\n\t\t\tsum -= mod;\n\t\tres = (res + i * cur) % mod;\n//\t\tcerr << res << '\\n';\n\t}\n\tcout << res << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007;\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  constexpr Fact() : val() {\n    val[0] = 1;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += fact.val[i] * fact.val[i - 1] % M * ifact.val[i * 2 - N] % M;\n    }\n    ans = fact.val[N - 1] * (N - 1) - ans;\n    ans %= M;\n    cout << (ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\nll f[1000100];\n\nvoid calc() {\n    f[0] = 1;\n    for(ll i = 1; i < 1000100; i++) {\n        f[i] = f[i - 1] * i;\n        f[i] %= mod;\n    }\n}\n\nll pow_mod(ll a, ll b, ll m){\n    ll ret = 1;\n    while (b > 0) {\n        if (b & 1) {\n            ret = ret * a % m;\n        }\n        a = a * a % m;\n        b >>= 1;\n    }\n    return ret;\n}\n\nll inv_mod(ll a, ll m){\n    return pow_mod(a, m - 2, m);\n}\n\nll comb(ll n, ll r) {\n    ll ret = f[n];\n    (ret *= inv_mod(f[r], mod)) %= mod;\n    (ret *= inv_mod(f[n - r], mod)) %= mod;\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    calc();\n    ll N;\n    cin >> N;\n    ll cur = 0;\n    ll ret = 0;\n    for(ll score = (N + 1) / 2; score <= N - 1; score++) {\n        ll ttmp = comb(score - 1, N - score - 1);\n        (ttmp *= f[N - 1 - score]) %= mod;\n        (ttmp *= f[score]) %= mod;\n        ll tmp = (ttmp - cur) % mod;\n        cur = comb(score - 1, N - score - 1) * f[N - 1 - score] % mod;\n        (cur *= f[score]) %= mod;\n        (tmp *= score) %= mod;\n        (tmp += mod) %= mod;\n//        cout << score << \":\" << tmp << \",\" << cur << endl;\n        (ret += tmp) %= mod;\n    }\n    output(ret);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long int\nusing namespace std;\n\nll mod = 1000000007;\n\nll factorials[1000005];\nll inv[1000005];\nll dp[1000005];\n\nll mod_pow(ll k, ll pow) {\n  ll ans = 1;\n  while (pow > 0) {\n    if (pow & 1) ans = ans * k % mod;\n    k = k * k % mod;\n    pow >>= 1;\n  }\n  return ans;\n}\n\nint main() {\n  ll n;\n  cin >> n;\n  factorials[0] = 1;\n  inv[0] = 1;\n\n  for (int i = 1; i < 1000005; i++) {\n    factorials[i] = (factorials[i - 1] * i) % mod;\n    inv[i] = (inv[i - 1] * mod_pow(i, mod - 2)) % mod;\n  }\n  \n  ll min_score = (n + 1) / 2;\n  ll max_score = n - 1;\n  ll ans = 0;\n  ll prev = 0;\n  for (int i = min_score; i <= max_score; i++) {\n    ll cnk = ((factorials[i - 1] * inv[n - 1 - i] % mod) * inv[2 * i - n] % mod) % mod;\n    ll add = (cnk * factorials[i] % mod) * factorials[n - 1 - i] % mod;\n    ans = (ans + (((add - prev + mod) % mod) * i) % mod) % mod;\n    prev = add;\n  }\n  cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"iostream\"\n# include \"cstdio\"\n\nusing namespace std;\n\nconst int maxm=1e6+10;\nconst int Mod=1e9+7;\n\nint N;\nlong long Fal[maxm],Inv1[maxm],Inv2[maxm],DP[maxm];\n\ninline long long C(int x,int y){\n\treturn Fal[x]*Inv2[y]%Mod*Inv2[x-y]%Mod;\n}\n\nint main(){\n\tregister int i,Max;\n\tregister long long Ans=0;\n    scanf(\"%d\",&N);\n    Max=(N+1)>>1;\n    Fal[0]=Fal[1]=Inv1[0]=Inv1[1]=Inv2[0]=Inv2[1]=1;\n\tfor(i=2;i<=N;i++){\n\t\tFal[i]=Fal[i-1]*i%Mod;\n\t\tInv1[i]=(Mod-Mod/i)*Inv1[Mod%i]%Mod;\n\t\tInv2[i]=Inv2[i-1]*Inv1[i]%Mod;\n\t}\n\tfor(i=Max;i<N;i++){\n\t\tDP[i]=C(i-1,N-i-1)*Fal[i]%Mod*Fal[N-i-1]%Mod;\n\t}\n\tfor(i=Max;i<N;i++){\n\t\tAns=(Ans+(DP[i]-DP[i-1])*i)%Mod;\n\t}\n\tAns=(Ans+Mod)%Mod;\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int maxN = 1e6 + 5;\nconst int mod = 1e9 + 7;\nll frac[maxN];\nll inv[maxN];\nll f[maxN];\nll pw(ll a, ll b) {\n    ll ans = 1;\n    while (b) {\n        if (b&1) ans = ans * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ans;\n}\nvoid init() {\n    frac[0]= 1;\n    inv[0] = 1;\n    for (int i = 1; i <= maxN; i++) {\n        frac[i] = frac[i-1] * i % mod;\n        inv[i] = inv[i-1] * pw(i, mod-1) % mod;\n    }\n}\nll c(ll m, ll n) {\n    if (m < n) return 0;\n    if (n == 0) return 1;\n    return frac[m] * inv[n] % mod * inv[m-n] % mod;\n}\nint main() {\n    int n;\n    cin >> n;\n    init();\n    f[2] = 1;\n    ll ans = 0;\n    for (ll i = n/2; i < n; i++) {\n        f[i] = c(i-1, n-1-i) * frac[i] % mod * frac[n-1-i] % mod;\n        //cout << f[i] << \"\\n\";\n        ans = (ans + (f[i] - f[i-1] + mod) % mod * i) % mod;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid qmax(int &x,int y) {if (x<y) x=y;}\nvoid qmin(int &x,int y) {if (x>y) x=y;}\ninline int read()\n{\n    char s;\n    int k=0,base=1;\n    while((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));\n    if(s==EOF)exit(0);\n    if(s=='-')base=-1,s=getchar();\n    while(isdigit(s)){k=k*10+(s^'0');s=getchar();}\n    return k*base;\n}\ninline void write(int x)\n{\n    static char cnt,num[15];cnt=0;\n    if (!x)\n    {\n        printf(\"0\");\n        return;\n    }\n    for (;x;x/=10) num[++cnt]=x%10;\n    for (;cnt;putchar(num[cnt--]+48));\n}\nconst ll mod=1e9+7;\nconst ll maxn=1e6+100;\nll p[maxn],ans,n,ny[maxn],f[maxn];\nll ksm(ll x,int y)\n{\n\tll sum=1;\n\twhile (y)\n\t{\n\t\tif (y&1) sum=sum*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn sum;\n}\nll C(int x,int y)\n{\n\tif (x<y) return 0;\n\treturn p[x]*ny[y]%mod*ny[x-y]%mod;\n}\nint main()\n{\n\tn=read();\n\tp[0]=1;ny[0]=1;\n\tfor (int i=1;i<n;i++) p[i]=p[i-1]*i%mod,ny[i]=ksm(p[i],mod-2);\n\tfor (int i=(n+1)/2;i<n;i++)\n\t{\n\t\tf[i]=C(i-1,n-i-1)*p[i]%mod*p[n-i-1]%mod;\n\t}\n\tfor (int i=(n+1)/2;i<n;i++)\n\t{\n\t\tans+=(f[i]-f[i-1])*i%mod;\n\t\tans%=mod;\n\t}\n\tans=(ans%mod+mod)%mod;\n\tcout<<ans;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <array>\n#include <list>\n#include <stack>\n#include <valarray>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef unsigned long long UInt;\n\nconst int INF = 1001001001;\nconst Int INFLL = 1001001001001001001LL;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\nint in() { int x; scanf(\"%d\", &x); return x; }\ndouble fin() { double x; scanf(\"%lf\", &x); return x; }\nInt lin() { Int x; scanf(\"%lld\", &x); return x; }\n\nconst Int MO = 1000000007;\nInt inv[1<<20], fact[1<<20], ifact[1<<20];\n\nvoid pre() {\n  inv[1] = 1;\n  for (int i = 2; i < (1<<20); ++i) {\n    inv[i] = MO - MO / i * inv[MO % i] % MO;\n  }\n  fact[0] = ifact[0] = 1;\n  for (int i = 1; i < (1<<20); ++i) {\n    fact[i] = fact[i-1] * i % MO;\n    ifact[i] = ifact[i-1] * inv[i] % MO;\n  }\n}\n\nInt comb(int n, int r) {\n  return fact[n] * ifact[r] % MO * ifact[n - r] % MO;\n}\n\nInt S[1<<20], L[1<<20];\n\nint main() {\n  int N = in();\n  pre();\n\n  int fst = -1;\n  for (int k = 1; k <= N - 1; ++k) {\n    const int two = N - k - 1;\n    const int one = k - 1 - two;\n    if (one >= 0 && two >= 0) {\n      fst = fst < 0 ? k : fst;\n      S[k] = comb(one + two, two) * fact[k] % MO;\n    }\n  }\n\n  Int res = 0, sub = 0;\n  for (int k = fst; k <= N - 1; ++k) {\n    (sub *= N - k) %= MO;\n    const Int l = (S[k] - sub + MO) % MO;\n    (res += l * k % MO * fact[N - 1 - k] % MO) %= MO;\n    (sub += l) %= MO;\n  }\n\n  printf(\"%lld\\n\", res);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\n\n#define MX 1000100\n\nll fact[MX], dfact[MX];\n\nll bin_pow(ll a, ll n) {\n\tll res(1);\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nvoid pre_calc()\n{\n\tfact[0] = dfact[0] = 1;\n\tfor (int i(1); i < MX; ++i)\n\t{\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tdfact[i] = bin_pow(fact[i], mod - 2);\n\t}\n}\n\nll C(ll n, ll k) { return fact[n] * dfact[n - k] % mod * dfact[k] % mod; }\n\nint main()\n{\n\tpre_calc();\n\tint n;\n\tcin >> n;\n\tll ans(0);\n\tll pre(0);\n\tfor (int m(1); m < n; ++m)\n\t\tif (m * 2 >= n) {\n\t\t\tll d = (2 * m - n) % mod;\n\t\t\tll c = C(m - 1, d);\n\t\t\tll cur = (mod - pre + C(m - 1, d) * fact[m] % mod * fact[n - 1 - m] % mod) % mod;\n\t\t\tpre += cur; pre %= mod;\n\t\t\tans += cur * m; ans %= mod;\n\t\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n    int x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%mod:(mod-(-y)%mod)%mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=mod)x-=mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=mod-p.x)>=mod)x-=mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1LL*x*p.x%mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        *this*=p.inverse();\n        return *this;\n    }\n\tModInt &operator^=(long long p){\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n    ModInt operator-()const{return ModInt(-x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n\tModInt operator^(long long p)const{return ModInt(*this)^=p;}\n    bool operator==(const ModInt &p)const{return x==p.x;}\n    bool operator!=(const ModInt &p)const{return x!=p.x;}\n    explicit operator int() const { return x; }                           // added by QCFium\n    ModInt operator=(const int p) {x = p; return ModInt(*this);} // added by QCFium\n    ModInt inverse()const{\n        int a=x,b=mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            a-=t*b;\n            std::swap(a,b);\n            u-=t*v;\n            std::swap(u,v);\n        }\n        return ModInt(u);\n    }\n    friend std::ostream &operator<<(std::ostream &os,const ModInt<mod> &p){\n        return os<<p.x;\n    }\n    friend std::istream &operator>>(std::istream &is,ModInt<mod> &a){\n        long long x;\n        is>>x;\n        a=ModInt<mod>(x);\n        return (is);\n    }\n};\ntypedef ModInt<MOD> mint;\n\nstruct MComb {\n    std::vector<mint> fact;\n    std::vector<mint> inversed;\n    MComb(int n) { // O(n+log(mod))\n        fact = std::vector<mint>(n+1,1);\n        for (int i = 1; i <= n; i++) fact[i] = fact[i-1]*mint(i);\n        inversed = std::vector<mint>(n+1);\n        inversed[n] = fact[n] ^ (MOD-2);\n        for (int i = n - 1; i >= 0; i--) inversed[i]=inversed[i+1]*mint(i+1);\n    }\n    mint ncr(int n, int r) {\n        return (fact[n] * inversed[r] * inversed[n-r]);\n    }\n    mint npr(int n, int r) {\n        return (fact[n] * inversed[n-r]);\n    }\n    mint nhr(int n, int r) {\n        assert(n+r-1 < (int)fact.size());\n        return ncr(n+r-1, r);\n    }\n};\n\nmint solve(int n) {\n\tint a[n - 1];\n\tfor (int i = 0; i + 1 < n; i++) a[i] = i;\n\tmint res = 0;\n\tint res_cnt[n + 1];\n\tmemset(res_cnt, 0, sizeof(res_cnt));\n\tdo {\n\t\tbool b[n];\n\t\tmemset(b, 0, sizeof(b));\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i + 1 < n; i++) {\n\t\t\tif (!b[a[i]]) b[a[i]] = true, cnt++;\n\t\t\tif (!b[a[i] + 1]) b[a[i] + 1] = true, cnt++;\n\t\t\tif (cnt == n) {\n\t\t\t\tres += i + 1;\n\t\t\t\tres_cnt[i + 1]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (std::next_permutation(a, a + n - 1));\n\tfor (int i = 0; i <= n; i++) std::cerr << i << \":\" << res_cnt[i] << std::endl;\n\treturn res;\n}\n\n\nint main() {\n\tint n = ri();\n\tif (n == 2) {\n\t\tstd::cout << 1 << std::endl;\n\t\treturn 0;\n\t}\n\tMComb com(n + 1);\n\tmint lower[n + 1];\n\tfor (int i = 2; i < n; i++) {\n\t\tmint res = 0;\n\t\tint usable = i - 2;\n\t\tint size = n - 3; // ume\n\t\tassert(usable <= size);\n\t\tif (usable * 2 >= size) {\n\t\t\t// std::cerr << i << \":\" << usable << \":\" << size - usable << std::endl;\n\t\t\tres += com.fact[i] * com.fact[n - i - 1] * com.ncr(usable, size - usable);\n\t\t}\n\t\tsize--;\n\t\tif (usable * 2 >= size && usable <= size) {\n\t\t\t// std::cerr << i << \":\" << usable << \":\" << size - usable << std::endl;\n\t\t\tres += com.fact[i] * com.fact[n - i - 1] * com.ncr(usable, size - usable);\n\t\t}\n\t\tlower[i] = res;\n\t}\n\tfor (int i = n - 1; i; i--) {\n\t\tlower[i] -= lower[i - 1];\n\t}\n\tmint res = 0;\n\tfor (int i = 2; i < n; i++) {\n\t\tres += lower[i] * i;\n\t}\n\t// for (int i = 0; i <= n; i++) std::cout << i << \":\" << lower[i] << std::endl;\n\tstd::cout << res << std::endl;\n\t// std::cout << solve(n) << std::endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst int NUM_=1e6+10;\nll fact[NUM_+1]={},factr[NUM_+1]={},inv[NUM_+1]={};\n\nll combi(ll N_, ll C_, ll mo=MOD) {\n  auto binpow = [&](ll x, ll e) -> ll{\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % mo; e /= 2;}\n      else {a = (a*p) % mo; e--;}\n    }\n    return a;\n  };\n  if (fact[0]==0) {\n    fact[0] = factr[0] = inv[0] = 1;\n    // FOR(i, 1, NUM_+1) fact[i] = fact[i-1] * i % MOD;\n    // factr[NUM_] = binpow(fact[NUM_], mo-2);\n    // for(int i=NUM_-1; i>=0; --i) factr[i] = factr[i+1] * (i+1) % MOD;\n    FOR(i, 1, NUM_) {\n      fact[i] = fact[i-1] * i % MOD;\n      inv[i] = binpow(i, MOD-2) % MOD;\n      factr[i] = factr[i-1] * inv[i] % MOD;\n    }\n  }\n  if(C_<0 || C_>N_) return 0;\n  // 前計算 O(max(N,K)) クエリ O(1)\n  return factr[C_]*fact[N_]%MOD*factr[N_-C_]%MOD;\n  // 前計算 O(max(N,K)log(mod)) クエリ O(K)\n  // ll ret = 1;\n  // for(;C_>0;N_--,C_--) (ret *= N_%MOD) %= MOD, (ret *= inv[C_]) %= MOD;\n  // return ret;\n}\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator--() { x--; return *this; }\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<1000000007> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  if(n == 2) {\n    cout << 1 << endl;\n    return 0;\n  }\n  if(n == 3) {\n    cout << 4 << endl;\n    return 0;\n  }\n  if(n == 4) {\n    cout << 16 << endl;\n    return 0;\n  }\n\n  mint a = 0, ret = 0;\n  REP(i, n) {\n    mint tmp = combi(i-1, n-i-1) * fact[i] % MOD * fact[n-i-1] % MOD;\n    tmp -= a;\n    ret += tmp*i;\n    a += tmp;\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int N=1e6+5, mod=1e9+7;\nLL n,fac[N],inv[N],tot,Ans;\n\nLL qpow(LL x,int y)\n{\n\tLL ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod, y>>=1;\n\t}\n\treturn ret; \n}\nLL C(int x,int y) {return fac[x]*inv[y]%mod*inv[x-y]%mod;}\nLL calc(int x) {return C(n-2-x,x)%mod*fac[n-1-x]%mod*fac[x]%mod;}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n < 5)\n\t{\n\t\tif(n == 2) puts(\"1\");\n\t\tif(n == 3) puts(\"4\");\n\t\tif(n == 4) puts(\"16\");\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<N;++i) fac[i]=fac[i-1]*i%mod;\n\tinv[N-1]=qpow(fac[N-1],mod-2);\n\tfor(int i=N-2;i>=0;--i) inv[i]=inv[i+1]*(i+1)%mod;\n\tint tmp=(n-2)/2;\n\tfor(int i=tmp;i>=0;--i)\n\t{\n\t\ttot=calc(i)-calc(i+1);\n\t\tAns+=tot*(n-i-1)%mod, Ans%=mod;\n\t}\n\t//cout<<Ans<<endl;\n\tAns+=mod, Ans%=mod;\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define ff first\n#define ss second\n#define finput ifstream cin;cin.open(\"in.txt\")\n#define foutput ofstream cout;cout.open(\"out.txt\")  \n#define fast ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define mod 1000000007\n\nll gcd(ll x, ll y){ \n\tif(x<y) \n\t\tswap(x,y); \n\tif(x%y==0)\n\t\treturn y;\n\treturn gcd(y, x%y);\n}\n\nll pwm(ll a, ll n){\n\tll ans = 1;\n\twhile(n>0){\n\t\tif(n%2==1){\n\t\t\tans = (ans * a)%mod;\n\t\t}\n\t\ta = (a*a)%mod;\n\t\tn /= 2;\n\t}\n\treturn ans%mod;\n}\n\nconst int pwn = 100010;\nll pw[pwn];\nvoid pwtwo(){\n\tpw[0] = 1;\n\tfor(int i=1; i<pwn; i++){\n\t\tpw[i] = (pw[i-1]*2)%mod;\n\t}\n}\n\n\nll gcdExtended(ll a, ll b, ll *x, ll *y); \n  \nll modInverse(ll a, ll m) \n{ \t\n\tif(a==1)\n\t\treturn 1;\n\t//cout<<\"mi \"<<a<<\" \"<<m<<\" \";\n    ll x, y; \n    ll g = gcdExtended(a, m, &x, &y); \n    if (g != 1){\n        //cout << \"Inverse doesn't exist\"<<endl; \n        return -1;\n    }\n    else\n    { \n        // m is added to handle negative x \n        ll res = (x%m + m) % m; \n        //cout<<res<<endl;\n        return res;\n        // cout << \"modular multiplicative inverse is \" << res; \n    } \n} \n  \nll gcdExtended(ll a, ll b, ll *x, ll *y) \n{ \n    if (a == 0) \n    { \n        *x = 0, *y = 1; \n        return b; \n    } \n  \n    ll x1, y1;\n    ll gcd = gcdExtended(b%a, a, &x1, &y1); \n  \n    *x = y1 - (b/a) * x1; \n    *y = x1; \n  \n    return gcd; \n} \n\nll fact[1000010];\nll init(){\n\tfact[0] = 1;\n\tfor(int i=1; i<1000010; i++)\n\t\tfact[i] = (fact[i-1]*i)%mod;\n}\n\nll ncr(ll n, ll r){\n\tll ans = fact[n];\n\t// cout<<ans<<\" \";\n\tif(r>n)\n\t\treturn 0;\n\t//if(r!=0)\n\tans = (ans*modInverse(fact[r], mod))%mod;\n\t// if(n-r!=0)\n\tans = (ans*modInverse(fact[n-r], mod))%mod;\n\n\treturn ans;\n}\n\nint main(){\n\t// finput;\n\t// foutput;\n\tfast;\n\n\tll n, k, i, j, x, m, r;\n\tll ans = 0ll;\n\t// string s;\n\tcin>>n;\n\tinit();\n\t// vector<int> vec;\n\t\n\ti=(n+1)/2;\n\n\tll pre = 0;\n\twhile(i<=n-1){\n\t\tr = n-1-i;\n\t\t// cout<<i<<\" \"<<n-2ll-r<< \" \"<<r<<\" \";\n\t\tx = ((ncr(n-2ll-r, r)%mod)*((fact[r]*fact[i])%mod))%mod;\n\t\t// cout<<x<<endl;\n\t\tx = (x + mod - pre)%mod;\n\t\t\n\t\tpre += x;\n\t\tpre %= mod;\n\n\t\t// cout<<x;\n\t\tans += (i*x)%mod;\n\t\tans %= mod;\n\n\t\ti++;\n\t}\n\tcout<<ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 1000000\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nint main(){\n\tinit();\n\tint n;\n\tcin>>n;\n\tvi po(n+1,1);\n\trep(i,n)po[i+1]=po[i]*(i+1)%MOD;\n\tll out=0;\n\tll sum=0;\n\tloop(i,1,n){\n\t\t(out+=i*(po[i]*po[n-1-i]%MOD*nCr(i-1,n-1-i)%MOD+MOD-sum)%MOD)%=MOD;\n\t\t(sum+=po[i]%MOD*po[n-1-i]%MOD*nCr(i-1,n-1-i))%=MOD;\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nll MOD = 1E9 + 7;\n\nll F[1000010], I[1000010];\n\nll power(ll a, ll b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2) {\n\t\t\tres *= a;\n\t\t\tres %= MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nll nchoosek(ll a, ll b) {\n\tll res = F[a] * I[b];\n\tres %= MOD;\n\tres *= I[a - b];\n\treturn res % MOD;\n}\n\nvoid init() {\n\tF[0] = 1;\n\tfor (int i = 1;i <= 1E6;i++) F[i] = (F[i - 1] * i) % MOD;\n\tI[1000000] = power(F[1000000], MOD - 2);\n    for (int i = 999999;i >= 0;i--) I[i] = (I[i + 1] * (i + 1)) % MOD;\n    return;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    init();\n    ll N;\n    cin >> N;\n    ll sol = ((N - 1) * F[N - 1]) % MOD;\n    // N - 1 cap\n    for (int n = 1;n * 2 <= N - 2;n++) {\n    \tll num = nchoosek(N - 2 - n, n);\n    \tnum *= (F[n] * F[N - 1 - n]) % MOD;\n    \tnum %= MOD;\n    \tsol += MOD - num;\n    \tsol %= MOD;\n    }\n    cout << sol << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000006;\nconst long long int MOD = 1000000007;\nlong long int fact[MAXN], inv_fact[MAXN], dp[MAXN];\nlong long int power(long long int a, int b)\n{\n\tif(!b)\n\t\treturn 1;\n\tlong long int ans = power(a, b/2);\n\tans = (ans*ans)%MOD;\n\tif(b%2)\n\t\tans = (ans*a)%MOD;\n\treturn ans;\n}\nvoid preprocess()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t{\n\t\tfact[i] = (fact[i - 1]*i)%MOD;\n\t}\n\tinv_fact[MAXN - 1] = power(fact[MAXN - 1], MOD - 2);\n\tfor (int i = MAXN - 2; i >= 0; --i)\n\t{\n\t\tinv_fact[i] = (inv_fact[i + 1]*(i + 1))%MOD;\n\t}\n}\nlong long int ncr(int n, int r)\n{\n\tif(n < 0 || r < 0 || n < r)\n\t\treturn 0;\n\tlong long int ret = (fact[n]*inv_fact[r])%MOD;\n\tret = (ret*inv_fact[n - r])%MOD;\n\treturn ret;\n}\nint main(int argc, char const *argv[])\n{\n\tpreprocess();\n\tint n;\n\tcin>>n;\n\tlong long int ans = 0;\n\tfor (int i = 1; i <= n - 1; ++i)\n\t{\n\t\tdp[i] = (ncr(i - 1, n - 1 - i)*fact[i])%MOD;\n\t\tdp[i] = (dp[i]*fact[n - 1 - i])%MOD;\n\t\tans = (ans + i*(dp[i] + MOD - dp[i-1]))%MOD;\n\t}\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"]\"; return os; }\n\n\n// import here\n\nstruct ModInt{\n    static const LL MOD = 1e+9 + 7;\n    LL v;\n    ModInt():v(0){}\n    ModInt(LL op):v(op){}\n    ModInt operator+(ModInt op) const{ return (v + op) % MOD; }\n    ModInt operator-(ModInt op) const{ return (v - op + MOD) % MOD; }\n    ModInt operator*(ModInt op) const{ return (v * op) % MOD; }\n    ModInt operator/(ModInt op) const{ return (v * op.inverse()) % MOD; }\n    ModInt operator%(LL op) = delete;\n    ModInt operator+=(ModInt op){ return v = (v + op) % MOD; }\n    ModInt operator-=(ModInt op){ return v = (v - op + MOD) % MOD; }\n    ModInt operator*=(ModInt op){ return v = (v * op) % MOD; }\n    ModInt operator/=(ModInt op){ return v = (v * op.inverse()) % MOD; }\n    ModInt operator-() const{ return MOD - v; }\n    bool operator==(ModInt op) const{ return v == op.v; }\n    bool operator!=(ModInt op) const{ return v != op.v; }\n    ModInt inverse() const{ return pow(MOD-2); }\n    ModInt pow(LL n) const{\n        if(n < 0) return pow(MOD-1 + n);\n        if(n == 0) return 1;\n        ModInt res = pow(n/2);\n        return res * res * ((n&1)?ModInt(v): ModInt(1));\n    }\nprivate:\n    operator LL() const{ return v; }\n};\nistream& operator>>(istream& st, ModInt& m){ st>>m.v; return st; }\nostream& operator<<(ostream& st, const ModInt& m){ st<<m.v; return st; }\n\n\nvector<ModInt> factorial(LL n){\n    vector<ModInt> res(n, 1);\n    for(LL i = 2; i < n; ++i) res[i] = res[i-1] * ModInt(i);\n    return res;\n}\n\nModInt permutation(LL n, LL m, vector<ModInt>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    return factorial.at(n) / factorial.at(n-m);\n}\n\nModInt combination(LL n, LL m, vector<ModInt>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    return factorial.at(n) / factorial.at(n-m) / factorial.at(m);\n}\n\nint main(){\n    LL n;\n    cin >> n;\n    if(n == 2){\n        cout << 1 << endl;\n        return 0;\n    }\n    if(n == 3){\n        cout << 4 << endl;\n        return 0;\n    }\n    vector<ModInt> fact = factorial(n+1);\n    vector<ModInt> equal_or_less(n+1);\n    for(LL k = 1; k <= n-1; ++k){\n        equal_or_less[k] = fact.at(k) * fact.at(n-1-k) * combination(k-1, n-1-k, fact);\n    }\n    ModInt ans = 0;\n    for(LL k = (n+1)/2; k <= n-1; ++k){\n        assert(k-1 >= n-k-1);\n        ans += (equal_or_less.at(k) - equal_or_less.at(k-1)) * ModInt(k);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 1000005;\n\nll inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = fac[i-1] * (ll) i % MOD;\n\t\tfinv[i] = finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * (finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nll add(ll x,ll y)\n{\n    return (x + y)%MOD;\n}\n\nll sub(ll x,ll y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nll mul(ll x,ll y)\n{\n    return x*y%MOD;\n}\n\nint f[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    if(n == 2){\n        cout << \"1\\n\";\n        return 0;\n    }\n    make();\n    int ans = 0;\n    srep(i,(n+1)/2,n){\n        f[i] = mul(comb(i-1,n-1-i),mul(fac[i],fac[n-1-i]));\n    }\n    rep(i,n){\n        ans = add(ans,mul(i,sub(f[i],f[i-1])));\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=1e9+7;\nint lt[2000050],tlt[2000050],n,ans,cnt;\nint binpow(int a,int b){\n\tif(b==0) return 1;\n\tif(b==1) return a%mod;\n\tint mid=binpow(a,b/2);\n\tif(b%2==0) return mid*mid%mod;\n\telse return mid*mid%mod*a%mod;\n}\nint c(int n,int k){\n\tif(n<k) return 0;\n\telse{\n\t\tint tmp=lt[n];\n\t\ttmp*=tlt[k];\n\t\ttmp%=mod;\n\t\ttmp*=tlt[n-k];\n\t\ttmp%=mod;\n\t\treturn tmp;\n\t}\n}\nsigned main(){\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tlt[0]=1;\n\tfor(int i=0;i<2000004;i++){\n\t\tif(i) lt[i]=lt[i-1]*i%mod;\n\t}\n\tcin>>n;\n\ttlt[n] = binpow(lt[n],mod-2);\n\tfor(int i=n;i>=1;i--) tlt[i-1]=(tlt[i]*i)%mod;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tint tmp=((c(i-1,n-i-1)%mod*lt[i]%mod*lt[n-i-1]%mod)%mod-cnt)%mod;\n\t\tans+=tmp*i;\n\t\tans%=mod;\n\t\tcnt+=tmp;\n\t\tcnt%=mod;\n\t}\n\tcout<<ans;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi fac,finv,inv;\nvoid init(ll n){\n    n*=3;\n    fac=vi(n+5);finv=vi(n+5);inv=vi(n+5);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    REP(i,2,n+5){\n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n}\nlong long modcom(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\nint main(){\n    ll n;cin>>n;\n    init(n);\n    ll ans=0;\n    vi v(n);\n    rep(i,n){\n        v[i]=fac[n-1-i]*fac[i]%mod*modcom(n-3-(2*i-1)+i,i)%mod;\n    }\n    rep(i,n-1)v[i]=(v[i]+mod-v[i+1])%mod;\n    //outv(v);\n    rep(i,n)ans=(ans+(n-1-i)*v[i])%mod;\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 1000100;\nconst int base = 1e9+7;\n\nint n;\nll fac[maxn],ifac[maxn];\n\nll pw(int a,int n) {\n    if (n==0) return 1ll;\n    if (n==1) return a;\n    ll tg = pw(a,n/2);\n    tg = (tg*tg) % base;\n    if (n%2) return (tg*a)%base;\n    return tg;\n}\n\nll C(int k,int n) {\n    if (k > n) return 0;\n    return (fac[n] * ifac[k] % base * ifac[n-k])%base;\n}\n\nint main() {\n    freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    fac[0] = 1, ifac[0] = 1;\n    for (int i=1;i<maxn;i++) {\n        fac[i] = (fac[i-1]*1ll*i)%base;\n        ifac[i] = pw(fac[i],base-2);\n    }\n    //cout<<C(1,1)<<endl;\n    cin>>n;\n    ll res=0,pre=0;\n    for (int i=(n-1)/2+1;i<n;i++) {\n        ll now = C(n-i-1,i-1) * fac[i] %base * fac[n-i-1] % base;\n        res = (res + 1ll*i*(now-pre)%base)%base;\n        pre = now;\n    }\n    cout<<res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007;\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  long long int v2[N];\n  constexpr Fact() : val(), v2() {\n    val[0] = 1;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n    for(int i = 1; i < N; ++i)v2[i] = val[i - 1] * val[i] % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += fact.v2[i] * ifact.val[i * 2 - N] % M;\n    }\n    ans = fact.val[N - 1] * (N - 1) - ans;\n    ans %= M;\n    cout << (ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nlong long int INF = 1000000007;\n\nlong long int pow10_9_5(long long int num){\n\tlong long int pow_num = 1000000005;\n\tlong long int mod_num = 1000000007;\n\tlong long int pow_cur = num;\n\tlong long int ret = 1;\n\twhile(pow_num > 0){\n\t\tif(pow_num % 2 == 1){\n\t\t\tret *= pow_cur;\n\t\t\tret %= mod_num;\n\t\t}\n\t\tpow_cur *= pow_cur;\n\t\tpow_cur %= mod_num;\n\t\tpow_num /= 2;\n\t}\n\treturn ret;\n}\n\nint main() {\n\t\n\tlong long int N;\n\tcin >> N;\n\t\n\tlong long int ans = 0;\n\tlong long int pp = 1;\n\tlong long int pp2 = 1;\n\t\n\tfor(long long int n = 1; n <= (N + 1) / 2; n++){\n\t\tpp *= n;\n\t\tpp %= INF;\n\t}\n\t\n\tlong long int num = (N - 1) / 2;\n\tlong long int den = N / 2 - 1;\n\t\n\tfor(long long int n = 1; n <= N - 2 - num; n++){\n\t\tpp2 *= n;\n\t\tpp2 %= INF;\n\t}\n\t\n\tlong long int conv;\n\t\n\tif(num != den){\n\t\tconv = num;\n\t}else{\n\t\tconv = 1;\n\t}\n\t\n\tlong long int diff = 0;\n\t\n\tfor(long long int n = num; n <= N - 3; n++){\n\t\tlong long int ppp = (pp * pp2) % INF;\n\t\tdiff += conv * ppp;\n\t\tdiff %= INF;\n\t\t//cout << n << endl;\n\t\t//cout << conv << \" \" << pp << \" \" << pp2 << endl;\n\t\tlong long int n1 = n;\n\t\tlong long int n2 = N - 2 - n;\n\t\tconv *= n1 + 1;\n\t\tconv %= INF;\n\t\tconv *= n2;\n\t\tconv %= INF;\n\t\tconv *= pow10_9_5(n1 - n2 + 1);\n\t\tconv %= INF;\n\t\tconv *= pow10_9_5(n1 - n2 + 2);\n\t\tconv %= INF;\n\t\tpp *= n + 2;\n\t\tpp %= INF;\n\t\tpp2 *= pow10_9_5(n2);\n\t\tpp2 %= INF;\n\t}\n\t\n\tans = (N - 1) * pp;\n\tans = (ans - diff + INF) % INF;\n\t\n\tcout << ans << endl;\n\t/*\n\tint DATA_SIZE = 10;\n\tint a[DATA_SIZE];\n\t\n\tfor(int i = 0; i < DATA_SIZE; i++){\n\t\ta[i] = i;\n\t}\n\tint ans_true = 0;\n\tdo{\n\t\t\n\t\tfor(int i = 0; i < DATA_SIZE; i++){\n\t\t\tcout << a[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t\n\t\tbool p[DATA_SIZE + 1] = {};\n\t\tfor(int i = 0; i < DATA_SIZE; i++){\n\t\t\tp[a[i]] = true;\n\t\t\tp[a[i] + 1] = true;\n\t\t\tbool flag = true;\n\t\t\tfor(int j = 0; j < DATA_SIZE + 1; j++){\n\t\t\t\tif(!p[j]){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tans_true += i + 1;\n\t\t\t\t//cout << i + 1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}while(next_permutation(a, a + DATA_SIZE));\n\t\n\tcout << ans_true << endl;\n\t*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#define int long long\nusing namespace std;\nconst int mod=1e9+7;\nint lt[2000050],tlt[2000050],n,ans,cnt;\nint binpow(int a,int b){\n\tif(b==0) return 1;\n\tif(b==1) return a%mod;\n\tint mid=binpow(a,b/2);\n\tif(b%2==0) return mid*mid%mod;\n\telse return mid*mid%mod*a%mod;\n}\nint c(int n,int k){\n\tif(n<k) return 0;\n\telse{\n\t\tint tmp=lt[n];\n\t\ttmp*=tlt[k];\n\t\ttmp%=mod;\n\t\ttmp*=tlt[n-k];\n\t\ttmp%=mod;\n\t\treturn tmp;\n\t}\n}\nsigned main(){\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tlt[0]=1;\n\tfor(int i=0;i<2000004;i++){\n\t\tif(i) lt[i]=lt[i-1]*i%mod;\n\t\ttlt[i]=binpow(lt[i],mod-2);\n\t}\n\tcin>>n;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tint tmp=((c(i-1,n-i-1)%mod*lt[i]%mod*lt[n-i-1]%mod)%mod-cnt)%mod;\n\t\tans+=tmp*i;\n\t\tans%=mod;\n\t\tcnt+=tmp;\n\t\tcnt%=mod;\n\t}\n\tcout<<ans;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nll modpow(ll x, ll n){\n    ll res = 1;\n    ll mul = x;\n    while(n){\n        if(n % 2) res = res * mul % MOD;\n        mul = mul * mul % MOD;\n        n /= 2;\n    }\n    return res;\n}\n\nstruct Combination\n{\n    int maxn;\n    vector<ll> fmemo;\n    vector<ll> imemo;\n    vector<ll> ifmemo;\n    \n    Combination(int maxn) : maxn(maxn){\n        fmemo.resize(maxn + 1);\n        imemo.resize(maxn + 1);\n        ifmemo.resize(maxn + 1);\n        for(ll i = 1; i <= maxn; i++){\n            imemo[i] = modpow(i, MOD - 2);\n        }\n    }\n\n    ll fact(ll n){\n        if(n == 0) return 1;\n        if(fmemo[n]) return fmemo[n];\n        return fmemo[n] = n * fact(n - 1) % MOD;\n    }\n\n    ll ifact(ll n){\n        if(n == 0) return 1;\n        if(ifmemo[n]) return ifmemo[n];\n        return ifmemo[n] = imemo[n] * ifact(n - 1) % MOD;\n    }\n\n    ll com(ll n, ll k){\n        if(k > n) return 0;\n        if(k == n || k == 0) return 1;\n        return (fact(n) * ifact(k) % MOD) * ifact(n - k) % MOD;\n    }\n};\n\nint main()\n{\n    ll n;\n    cin >> n;\n    Combination com(n + 2);\n    ll ans = com.fact(n - 1) * (n - 1);\n    for(int i = n - 2; i >= (n + 1) / 2; i--){\n        ans = (ans + MOD - com.com(i - 1, i * 2 - n) * com.fact(i) % MOD * com.fact(n - 1 - i) % MOD) % MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=(1e6)+10;\nconst ll mod=(1e9)+7;\nint n;\nll jc[maxn],ivjc[maxn],iv[maxn],ans;\nll c(ll a,ll b) {\n\tif (a<b) return 0;\n\tll res=jc[a]*ivjc[b]%mod*ivjc[a-b]%mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tjc[0]=ivjc[0]=1;\n\tfor (int i=1;i<=n;i++) {\n\t\tjc[i]=jc[i-1]*i%mod;\n\t\tiv[i]=(mod-iv[mod%i]*(mod/i)%mod)%mod;\n\t\tif (i==1) iv[1]=1;\n\t\tivjc[i]=ivjc[i-1]*iv[i]%mod;\n\t}\n\tll lst=0;\n\tfor (int s=max(1,n/2-1);s<n;s++) {\n\t\tll tmp=jc[s]*jc[n-s-1]%mod*c(s-1,n-s-1)%mod;\n\t\tans+=((tmp-lst+mod)%mod)*s%mod;\n\t\tlst=tmp;\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2018-04-28 20:53:50\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst int N=(int)1e6+9;\nconst ll mod=(ll)1e9+7;\ntemplate<int sz> struct Comb{\n    const ll mod = ::mod;\n    ll *fac, *ifac;\n    ll mem_fac[sz+5],mem_ifac[sz+5];\n\n    // long long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\n\n    Comb(ll *fa=0,ll *ifa=0){\n        fac=fa?fa:mem_fac;\n        ifac=ifa?ifa:mem_ifac;\n        fac[0]=ifac[0]=1;\n        for(int i=1;i<sz;++i){\n            fac[i]=i*fac[i-1]%mod;\n            ifac[i]=powmod(fac[i],mod-2,mod);\n        }\n    }\n    ll C(ll n,ll m){  // n >= m\n        if(n<m)return 0;\n        return (fac[n]*ifac[m]%mod)*ifac[n-m]%mod;\n    }\n    ll A(ll n,ll m){\n        if(n<m)return 0;\n        return fac[n]*ifac[n-m]%mod;\n    }\n};\n\nll fac[N],fnv[N],ans[N];\nComb<N> comb(fac,fnv);\nint main(){\n    int n;cin>>n;\n    ll res=0,cnt,t;\n    rep(j,(n+1)/2,n) ans[j]=(comb.C(j-1,n-j-1)*fac[j]%mod)*fac[n-j-1]%mod;\n    per(j,n,(n+1)/2) res+=(ans[j]-ans[j-1])*j%mod;\n    res%=mod;\n    if(res<0)res+=mod;\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<utility>\n#include<set>\n#include<stack>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<iomanip>\n#include<cstring>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<climits>\n#include<cmath>\n#include<cctype>\n\n\n#define pb push_back\n#define mp make_pair\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define ren(i,a,b) for(int i=a;i>=b;i--)\n#define ff first\n#define ss second\n#define pll pair<long long int,long long int>\n#define pii pair<int,int>\n#define vll vector<long long int>\n#define vii vector<int>\n#define gi(n) scanf(\"%d\",&n)\n#define gll(n) scanf(\"%lld\",&n)\n#define gstr(n) scanf(\"%s\",n)\n#define gl(n) cin >> n\n#define oi(n) printf(\"%d\",n)\n#define oll(n) printf(\"%lld\",n)\n#define ostr(n) printf(\"%s\",n)\n#define ol(n) cout << n\n#define os cout<<\" \"\n#define on cout<<\"\\n\"\n#define o2(a,b) cout<<a<<\" \"<<b\n#define all(n) n.begin(),n.end()\n#define present(s,x) (s.find(x) != s.end())\n#define cpresent(s,x) (find(all(s),x) != s.end())\n#define tr(container, it) for(__typeof(container.begin()) it = container.begin(); it != container.end(); it++)\nusing namespace std;\n\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef long double ld;\ntypedef vector<vector<ll> > mat;\n\nll f[1000005],inv[1000005],m=1e9+7;\n\nll p(ll a,ll b)\n{\n\tll r=1;\n\twhile(b)\n\t{\n\t\tif(b%2)\n\t\tr=(r*a)%m;\n\t\ta=(a*a)%m;\n\t\tb/=2;\n\t}\n\treturn r;\n}\n\nll ncr(ll n,ll r)\n{\n\tif(r<0||r>n)return 0;\n\tll kk=(f[n]*inv[r])%m;\n\tkk=(kk*(inv[n-r]))%m;\n\treturn kk;\n}\n\nint main()\n{ios_base::sync_with_stdio(false);\nint n;\ncin>>n;\nif(n==2)\n{\n\tol(\"1\");\n\treturn 0;\n}\nf[0]=1;\nrep(i,1,1000004)f[i]=(f[i-1]*i)%m;\ninv[1000004]=p(f[1000004],m-2);\n\nren(i,1000003,0)\ninv[i]=(inv[i+1]*(i+1))%m;\n\nll ans=0,lst=0;\n\nrep(i,2,n-1)\n{\n\tll kk=(ncr(i-1,n-1-i))%m;\n\tkk=(kk*f[i])%m;\n\tkk=(kk*f[n-1-i])%m;\n\tans=(ans+(kk-lst)*i)%m;\n\tlst=kk;\n}\nol((ans+m)%m);\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)\nusing namespace std;\ninline void read(int &x){\n    char c=getchar();\n    int p=1;\n    x=0;\n    while(!isdigit(c)){\n        if(c=='-')p=-1;\n        c=getchar();\n    }\n    while(isdigit(c)){\n        x=(x<<1)+(x<<3)+(c^'0');\n        c=getchar();\n    }\n    x*=p;\n}\n\nconst int MAXN=2e6+7;\n\nstatic int n;\n\nstatic int fac[MAXN],inv[MAXN];\n\nconst int mod=1e9+7;\n\ninline int power(int a,int b)\n{\n\tstatic int sum;\n\tfor(sum=1;b;b>>=1,a=(long long)a*a%mod)if(b&1)\n\t\tsum=(long long)sum*a%mod;\n\treturn sum;\n}\n\ninline void init()\n{\n\tread(n);\n\tfac[0]=1;\n\tRep(i,1,n+5)fac[i]=(long long)fac[i-1]*i%mod;\n\tinv[n+5]=power(fac[n+5],mod-2);\n\tRepe(i,n+5,1)inv[i-1]=(long long)inv[i]*i%mod;\n}\n\ninline int C(int a,int b)\n{\n\tif(a<b)return 0;\n\treturn (long long)fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\n\nstatic int f[MAXN],ans;\n\ninline void Add(int &a,int b){if((a+=b)>=mod)a-=mod;}\n\ninline void solve()\n{\n\tRep(i,0,n/2-1)f[i]=(long long)C(n-i-2,i)*fac[n-i-1]%mod*fac[i]%mod;\n\tRep(i,0,n/2-1)Add(ans,(long long)(f[i]-f[i+1]+mod)%mod*(n-i-1)%mod);\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Code be weshen zyk :'(\n * I won't surrender quietly\n */\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <bits/stdc++.h>\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate<class T> using orderd_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define S second\n#define F first\n#define pb push_back\n\nusing ii = pair<int, int>;\nusing ll = long long;\nusing db = long double;\n\nconst int N = 2e5 + 5, K = 12, MOD = 1e9 + 7;\nconst ll MX = 1e15;\nll fast(ll b, ll e){\n\tif(!e)\n\t\treturn 1;\n\tif(e & 1)\n\t\treturn b * fast(b, e - 1) % MOD;\n\treturn fast(b * b % MOD, e >> 1);\n}\nll F[N], iF[N];\nvoid init(){\n\tF[0] = iF[0] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tF[i] = F[i-1] * i % MOD;\n\t\tiF[i] = fast(F[i], MOD - 2);\n\t}\n}\nll C(int n, int k){\n\tif(k > n || k < 0)\n\t\treturn 0;\n\treturn F[n] * iF[k] % MOD * iF[n-k] % MOD;\n}\nint main() {\n#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n#endif\n\tinit();\n\tint n;\n\tcin >> n;\n\tll ans = 0, cur = 0;\n\n\tfor(int i = 1; i < n; i++){\n\t\tll num = C(i - 1, n - i - 1) * F[i] % MOD * F[n - i - 1] % MOD;\n\t\tnum = (num - cur + MOD) % MOD;\n\t\tcur = (cur + num) % MOD;\n\t\tans = (ans + num * i % MOD) % MOD;\n\t}\n\n\tcout << ans << '\\n';\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1000000007, MAXN = 1000 * 1000 + 100;\n\nint ans[MAXN], fact[MAXN], inv[MAXN];\n\nvoid PreWorks();\nint power(int a, int b);\nint chose(int k, int n);\n\nint main() {\n\tPreWorks();\n\tint n;\n\tll all = 0;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++)\n\t\tans[i] = (ll)chose(n - i - 1, i - 1) * fact[i] % MOD * fact[n - i - 1] % MOD;\n\tfor (int i = 1; i < n; i++) {\n\t\tall += (ll)(ans[i] - ans[i - 1]) * i % MOD;\n\t\t//cerr << ans[i] << ' ';\n\t\tall %= MOD;\n\t}\n\t//cerr << endl;\n\tcout << all % MOD;\n}\n\nint power(int a, int b) {\n\tif (!b)\n\t\treturn 1;\n\tint t = power(a, b / 2);\n\treturn b % 2? (ll)t * t % MOD * a % MOD: (ll)t * t % MOD;\n} \n\nvoid PreWorks() {\n\tfact[0] = 1;\n\tinv[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\tinv[i] = power(fact[i], MOD - 2);\n\t}\n}\n\nint chose(int k, int n) {\n\tif(k >= 0 && n >= k) return (ll)fact[n] * inv[n - k] % MOD * inv[k] % MOD;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007ll\n//作者:中国江苏南京丁天行\nusing namespace std;\nll n,ans,jc[1000005];\nll f(ll x,ll k){\n    ll ans=1;\n    while(k){\n        if(k&1)ans=ans*x%orz;\n        x=x*x%orz,k>>=1;\n    }\n    return ans;\n}\nll c(ll n,ll k){return jc[n]*f(jc[k],orz-2ll)%orz*f(jc[n-k],orz-2ll)%orz;}\nint main(){\n    cin>>n;\n    jc[0]=1;\n    for(ll i=1;i<=n;++i)jc[i]=jc[i-1]*i%orz;\n    for(ll i=1;i<n;++i){\n        ll N=n-2ll-i,K=i;\n        if(N<K) break;\n        ans=(ans+c(N,K)*jc[n-1ll-i]%orz*jc[i])%orz;\n    }\n    ans=jc[n-1]*(n-1ll)%orz-ans+orz;\n    cout<<ans%orz<<endl;\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tconstexpr auto pow_mod = [](int64_t a, int64_t n, int64_t mod) {\n\t\tint64_t r = 1;\n\t\tfor (; n; n >>= 1)\n\t\t{\n\t\t\tif (n & 1)\n\t\t\t{\n\t\t\t\t(r *= a) %= mod;\n\t\t\t}\n\t\t\t(a *= a) %= mod;\n\t\t}\n\t\treturn r;\n\t};\n\tint64_t n, mod = 1000000007;\n\tcin >> n;\n\tif (n == 2)\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tvector<int64_t> fact(n + 1), fact_rev(n + 1);\n\tfact[0] = 1;\n\tfor (int64_t i = 1; i <= n; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t}\n\tfact_rev[n] = pow_mod(fact[n], mod - 2, mod);\n\tfor (int64_t i = n - 1; 0 <= i; i--)\n\t{\n\t\tfact_rev[i] = fact_rev[i + 1] * (i + 1) % mod;\n\t}\n\tvector<int64_t> f(n, 0);\n\tfor (int64_t k = 2; k < n; k++)\n\t{\n\t\tint64_t a = 2 * k - n, b = n - k - 1;\n\t\tif (a < 0 || b < 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tf[k] = fact[a + b] * fact_rev[a] % mod * fact_rev[b] % mod * fact[k] % mod * fact[n - k - 1] % mod;\n\t}\n\tint64_t ans = 0;\n\tfor (int64_t k = 2; k < n; k++)\n\t{\n\t\tint64_t num = f[k] - f[k - 1];\n\t\tif (num < 0)\n\t\t{\n\t\t\tnum += mod;\n\t\t}\n\t\t(ans += k * num % mod) %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nnamespace Fact{\n\tlong f[1000001];\n\tlong rf[1000001];\n\tlong pow(long N,long K){\n\t\tif(K == 0){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(K % 2 == 0){\n\t\t\tlong t = pow(N,K/2);\n\t\t\treturn t*t%mod;\n\t\t}\n\t\telse{\n\t\t\treturn N*pow(N,K-1)%mod;\n\t\t}\n\t}\n\tvoid Fact(int N){\n\t\tfor(int i=0;i<N+1;i++){\n\t\t\tif(i == 0){\n\t\t\t\tf[i] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf[i] = (f[i-1]*i)%mod;\n\t\t\t}\n\t\t}\n\t\tfor(int i=N;i>=0;i--){\n\t\t\tif(i == N){\n\t\t\t\trf[i] = pow(f[N],mod-2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trf[i] = rf[i+1]*(i+1)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong GetFact(int N){\n\t\treturn f[N];\n\t}\n\tlong GetPerm(int N,int R){\n\t\treturn f[N] * rf[N-R] % mod;\n\t}\n\tlong GetConv(int N,int R){\n\t\treturn ((f[N]*rf[R])%mod*rf[N-R])%mod;\n\t}\n\tlong GetRev(int N){\n\t\tif(N == 0){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn rf[N] * f[N-1] % mod;\n\t\t}\n\t}\n}\nvoid Calc(){\n\tint N = rei();\n\tFact::Fact(1000000);\n\tif(N == 2){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tlong ans = 0;\n\tfor(int i=2;i<N-1;i++){\n\t\tint a = i-2;\n\t\tint b = N-4-a;\n\t\tif(a >= 0 && b >= 0 && a >= b){\n\t\t\tans += (i-1)*Fact::GetConv(a,b)%mod*Fact::GetFact(i)%mod*Fact::GetFact(N-2-i)%mod;\n\t\t}\n\t}\n\tans %= mod;\n\tans = (Fact::GetFact(N-1) * (N-1) % mod + mod - ans) % mod;\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\ntemplate <int M, bool IsPrime = false>\nclass modulo {\n    using ll = long long;\npublic:\n    modulo() : n(0) {}\n    modulo(int m) : n(m) {\n        if(n >= M) {\n            n %= M;\n        } else if(n < 0) {\n            n = (n % M + M) % M;\n        }\n    }\n    modulo(ll m) : modulo(int(m % M)) {}\n\n    explicit operator int() const { return n; }\n    explicit operator ll() const { return n; }\n\n    bool operator==(modulo const& a) const {\n        return n == a.n;\n    }\n\n    modulo& operator+=(modulo const& a) {\n        n += a.n;\n        if(n >= M) {\n            n -= M;\n        }\n        return *this;\n    }\n    modulo& operator-=(modulo const& a) {\n        n -= a.n;\n        if(n < 0) {\n            n += M;\n        }\n        return *this;\n    }\n    modulo& operator*=(modulo const& a) {\n        n = (ll(n) * a.n) % M;\n        return *this;\n    }\n    modulo operator^(int n) const {\n        if(n == 0) {\n            return modulo(1);\n        }\n        const modulo a = *this;\n        modulo res = (a * a) ^ (n / 2);\n        return n % 2 ? res * a : res;\n    }\n\n    typename std::enable_if<IsPrime, modulo>::type operator/(modulo const& a) const {\n        return *this * modulo(inv(ll(a), M));\n    }\n\nprivate:\n    ll n;\n    static typename std::enable_if<IsPrime, ll>::type inv(ll a, ll p) {\n        return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n    }\n};\n\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator+(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    return lhs += rhs;\n}\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator-(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    return lhs -= rhs;\n}\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator*(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    return lhs *= rhs;\n}\n\nconstexpr int MOD = 1000000007;\n\n// sw == false -> inv\ntemplate <int M = MOD>\nmodulo<M, true> fact(int n, bool sw = true) {\n    static std::vector<modulo<M, true>> v1 = {1}, v2 = {1};\n    if(n >= (int)v1.size()) {\n        const int from = v1.size(), to = n + 1024;\n        v1.reserve(to);\n        v2.reserve(to);\n        for(int i = from; i < to; ++i) {\n            v1.push_back(v1.back() * modulo<M, true>(i));\n            v2.push_back(v2.back() / modulo<M, true>(i));\n        }\n    }\n    return sw ? v1[n] : v2[n];\n}\n\ntemplate <int M = MOD>\nmodulo<M, true> comb(int a, int b) {\n    if(b < 0 || b > a) {\n        return fact<M>(0);\n    }\n    return fact<M>(a, true) * fact<M>(b, false) * fact<M>(a - b, false);\n}\n\nusing mod = modulo<MOD, true>;\n\nint main() {\n    int n;\n    cin >> n;\n    if(n == 2) {\n        cout << 1 << endl;\n    } else if(n == 3) {\n        cout << 4 << endl;\n    } else if(n == 4) {\n        cout << 10 << endl;\n    } else {\n        mod ans = 0;\n        mod cur = 0;\n        for(int k = (n + 1) / 2; k <= n - 1; ++k) {\n            mod t = comb(k - 1, n - 1 - k) * fact(k) * fact(n - 1 - k);\n            ans += (t - cur) * mod(k);\n            cur = t;\n        }\n        cout << (ll)ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define li          long long int\n#define rep(i,to)   for(li i=0;i<((li)(to));i++)\n#define repp(i,start,to)    for(li i=(li)(start);i<((li)(to));i++)\n#define pb          push_back\n#define sz(v)       ((li)(v).size())\n#define bgn(v)      ((v).begin())\n#define eend(v)     ((v).end())\n#define allof(v)    (v).begin(), (v).end()\n#define dodp(v,n)       memset(v,(li)n,sizeof(v))\n#define bit(n)      (1ll<<(li)(n))\n#define mp(a,b)     make_pair(a,b)\n#define rin rep(i,n)\n#define EPS 1e-12\n#define ETOL 1e-8\n#define MOD 1000000007\ntypedef pair<li, li> PI;\n\n#define INF bit(60)\n\n#define DBGP 1\n\n\n#define idp if(DBGP)\n#define F first\n#define S second\n#define p2(a,b)     idp cout<<a<<\"\\t\"<<b<<endl\n#define p3(a,b,c)       idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<endl\n#define p4(a,b,c,d)     idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<endl\n#define p5(a,b,c,d,e)       idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<endl\n#define p6(a,b,c,d,e,f)     idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<endl\n#define p7(a,b,c,d,e,f,g)       idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<endl\n#define p8(a,b,c,d,e,f,g,h)     idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<endl\n#define p9(a,b,c,d,e,f,g,h,i)       idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<\"\\t\"<<i<<endl\n#define p10(a,b,c,d,e,f,g,h,i,j)        idp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<\"\\t\"<<i<<\"\\t\"<<j<<endl\n#define foreach(it,v)   for(__typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)\n#define p2p(x)      idp p2((x).F, (x).S)\n#define dump(x,n)   idp{rep(i,n){cout<<x[i]<<\" \";}puts(\"\");}\n#define dump2(x,n)  idp{rep(i,n){cout<<\"[\"<<x[i].F<<\" , \"<<x[i].S<<\"] \";}puts(\"\");}\n#define dumpi(x)    idp{foreach(it, x){cout<<(*it)<<\" \";}puts(\"\");}\n#define dumpi2(x)   idp{foreach(it, x){cout<<\"[\"<<(it)->F<<\" , \"<<(it)->S<<\"] \";}puts(\"\");}\n\n#define read2d(a,w,h)   rep(i,h)rep(j,w)cin>>a[i][j]\n#define dump2d(a,w,h)   rep(i,h){rep(j,w)cout<<a[i][j]<<\" \";puts(\"\");}\n\ntypedef pair<li, li> PI;\n\ninline li gcd(li a, li b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\ninline li lcm(li a, li b) {\n    return a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\ninline li extgcd(li a, li b, li &x, li &y) {\n    li g = a; x = 1; y = 0;\n    if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    return g;\n}\n\nli invMod(li a) {\n    li x, y;\n    if (extgcd(a, MOD, x, y) == 1) return (x + MOD) % MOD;\n    else                         return 0; // unsolvable\n}\n\nli fact_mod[1000010];\n\ninline li combi(li n, li k) {\n    return (((fact_mod[n] * invMod(fact_mod[k])) % MOD) * invMod(fact_mod[n - k])) % MOD;\n}\n\ninline li calc(li n, li k) {\n    if (k < (n + 1) / 2)return 0;\n    li res = (fact_mod[k] * fact_mod[n - 1 - k]) % MOD;\n    res = (res * combi(k - 1, n - 1 - k)) % MOD;\n    return res;\n}\n\nint main() {\n    li n;\n    cin >> n;\n    fact_mod[0] = 1;\n    fact_mod[1] = 1;\n    repp(i, 2, n + 1) {\n        fact_mod[i] = (fact_mod[i - 1] * i) % MOD;\n    }\n    li res = 0;\n    repp(i, (n + 1) / 2, n) {\n        res = (res +\n               (\n                   (calc(n, i) - calc(n, i - 1) + MOD) % MOD\n               ) * i\n              ) % MOD;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 5;\ntypedef long long ll;\n\nint n;\nll f[N], mod = 1e9 + 7, inv[N], fac[N], ans;\n\nll calc(int n, int k) {\n\treturn fac[n]*inv[n - k]%mod*inv[k]%mod;\n}\n\nll fps(ll a, ll b) {\n\tll res = 1;\n\twhile(b) {\n\t\tif(b&1) res = res*a%mod;\n\t\tb /= 2;\n\t\ta = a*a%mod;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin>>n;\n\tfac[0] = inv[0] = fac[1] = inv[1] = 1;\n\tfor(int i = 2; i <= n; i++) {\n\t\tfac[i] = fac[i - 1]*i%mod;\n\t\tinv[i] = fps(fac[i], mod - 2);\n\t}\n\tfor(int i = (n + 1)/2; i < n; i++)\n\t\tf[i] = (calc(i - 1, n - i - 1)*fac[i]%mod*fac[n - i - 1])%mod;\n\tfor(int i = (n + 1)/2; i < n; i++)\n\t\tans = (ans + (f[i] - f[i - 1])*i)%mod;\n\tcout<<(ans + mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nconst int N = 1e6 + 5, Mod = 1e9 + 7;\nint ml(int x, int y) { return 1ll * x * y % Mod; }\nint dc(int x, int y) { return (x - y < 0) ? (x - y + Mod) : (x - y); }\nint ad(int x, int y) { return (x + y > Mod) ? (x + y - Mod) : (x + y); }\nint n, f[N], fac[N], inv[N];\nint ksm(int x, int y) {\n\tint ret = 1;\n\tfor (; y; y >>= 1, x = ml(x, x))\n\t\tif (y & 1) ret = ml(ret, x);\n\treturn ret;\n}\nvoid Prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) fac[i] = ml(fac[i - 1], i);\n\tinv[n] = ksm(fac[n], Mod - 2);\n\tfor (int i = n - 1; i >= 0; --i) inv[i] = ml(inv[i + 1], i + 1);\n}\nint binom(int u, int d) {\n\tif (u < 0 || d < 0) return 0;\n\tif (u < d) return 0;\n\treturn ml(fac[u], ml(inv[d], inv[u - d]));\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tPrepare();\n\tfor (int i = 1; i <= n - 1; ++i)\n\t\tf[i] = ml(binom(i - 1, n - i - 1), ml(fac[i], fac[n - i - 1]));\n\tfor (int i = n - 1; i >= 1; --i) f[i] = dc(f[i], f[i - 1]);\n\tint ans = 0;\n\tfor (int i = 1; i <= n - 1; ++i) ans = ad(ans, ml(f[i], i));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e6 + 10;\nconstexpr static int MOD = 1e9 + 7;\n\nint64_t f[MAXN], inv[MAXN], finv[MAXN];\nint64_t cnt[MAXN]; // cnt[k] is score at most k\n\nint64_t choose(int n, int k) {\n    return f[n] * finv[k] % MOD * finv[n - k] % MOD;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    n--;\n\n    f[0] = 1;\n    for (int i = 1; i <= n; i++)\n        f[i] = i * f[i - 1] % MOD;\n    inv[1] = 1;\n    finv[0] = finv[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        // i*q + r = MOD\n        // i*q = -r\n        // q = -r * i^{-1}\n        // i^{-1} = -q * r^{-1}\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;\n        finv[i] = inv[i] * finv[i - 1] % MOD;\n    }\n\n    // score <= k, 1 = a1 < a2 < ... < ak = n, consecutive diff 1 or 2\n    // k choices, place n - k + 1 ones in any of the k - 1 slots\n    for (int k = 0; k <= n; k++) {\n        if (k - 1 < n - k)\n            continue;\n        cnt[k] = choose(k - 1, n - k) * f[k] % MOD * f[n - k] % MOD;\n        // cout << k << \" \" << cnt[k] << endl;\n    }\n    int64_t total = 0;\n    for (int k = 1; k <= n; k++) {\n        total += (cnt[k] - cnt[k - 1] + MOD) * k;\n        total %= MOD;\n    }\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 1000005;\nconst int MMAX = 100005;\nconst int KMAX = 1005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n#define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define fi first\n#define se second\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> lp;\ntypedef pair<ll, ll> llp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\ntypedef unordered_map<ll, ll> umap;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// dump vector\n#ifdef DEBUG\n#define DUMPV(v, c) do{       \\\n  printf(\"%s: \", #v);         \\\n  for (int i = 0; i < (c); ++i) \\\n  {                           \\\n  cout << (v)[i] << \" \";      \\\n  }                           \\\n  cout << endl;               \\\n} while(0)\n#else\n#define DUMPV(v,c)\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll ok, ll ng, bool (*f)(ll)){\n  ll mid;\n  while(abs(ok - ng) > 1LL) {\n    mid =  (ok + ng) / 2LL;\n    if(f(mid)) {\n      debug(\"BSearch: f(%d) == true\\n\", mid);\n      ok = mid;\n    }\n    else\n    {\n      debug(\"BSearch: f(%d) == false\\n\", mid);\n      ng = mid;\n    }\n  }\n  return ok;\n}\n\nll NUM_TEST_CASE = 1;\n\nll N,M,K,A,B,C,D,E;\nint dp[NMAX] = {};\n\nstring S;\nvec v;\n\nll ans = {};\n\nll facto[NMAX], inv[NMAX];\n\nll biExp(ll x, int power){\n  if(power == 0) return 1;\n  ll xx = biExp(x, power / 2);\n  xx = xx * xx % MOD;\n  if(power % 2) xx = xx * x % MOD;\n  return xx;\n}\n\nll calcComb(int n, int r){\n  if(r > n || r < 0) return 0;\n  if(n == r || r == 0) return 1;\n  return facto[n] * inv[r] % MOD * inv[n-r] % MOD;\n}\n\nll solve(){\n  // main algorithm\n  if(N == 2) return 1;\n  if(N == 3) return 4;\n  if(N == 4) return 16;\n  // calc facto\n  facto[0] = 1;\n  for (int i = 1; i <= N; ++i)\n  {\n    facto[i] = facto[i - 1] * i % MOD;\n  }\n  // calc inv\n  inv[N] = biExp(facto[N], MOD - 2);\n  for (int i = N; i > 0; --i)\n  {\n    inv[i - 1] = inv[i] * i % MOD;\n  }\n\n  // calc sum for all k\n  ll sum = 0, preCount = 0, count = 0;\n  for (int k = (N + 1) / 2; k < N; ++k)\n  {\n    count = calcComb(k - 1, N - 1 - k) * facto[k] % MOD\n          * facto[N - 1 - k] % MOD;\n    sum = (sum + (count - preCount) * k % MOD) % MOD;\n    preCount = count;\n  }\n  return sum;\n}\nvoid debug(){\n  // output debug information\n\n}\nvoid answer(){\n  // output answer\n  cout << ans << endl;\n}\nvoid init(){\n  // initialize for each test case\n  // Fill(dp, -1);\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n\n  // cin >> NUM_TEST_CASE;\n\n  for (int test_case = 0; test_case < NUM_TEST_CASE; ++test_case)\n  {\n    init();\n\n    cin >> N;\n    ans = solve();\n    #ifdef DEBUG\n    debug();\n    #endif\n    answer();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint fact[1000005], fact_i[1000005];\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 1000005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 1000005; i++){\n\t\tfact_i[i] = pow(fact[i], mod-2);\n\t}\n}\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_i[k], ret %= mod;\n\tret *= fact_i[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint func(llint N, llint r)\n{\n\tllint batsu = N-r;\n\treturn comb(N+1-batsu, batsu) % mod;\n}\n\nllint N;\n\nint main(void)\n{\n\tcin >> N;\n\tif(N == 2){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tmake_fact();\n\t\n\tllint ans = 0;\n\tfor(int i = N/2; i <= N-1; i++){\n\t\tllint cnt = 0;\n\t\tif(N >= 3) cnt += func(N-3, i-2) * 2;\n\t\tif(N >= 7) cnt += (func(N-7, i-5) * 2*(N-6)) % mod, cnt %= mod;\n\t\tif(N >= 6) cnt += (func(N-6, i-4) * 4*(N-5)) % mod, cnt %= mod;\n\t\tif(N >= 8) cnt += (func(N-8, i-5) * 3*(N-7)) % mod, cnt %= mod;\n\t\tif(N >= 7) cnt += (func(N-7, i-4) * 6*(N-6)) % mod, cnt %= mod;\n\t\tif(N == 5 && i == 3) cnt += 2;\n\t\tif(N == 6 && i == 3) cnt += 3;\n\t\tcnt *= fact[i-1] % mod, cnt %= mod;\n\t\tcnt *= fact[(N-1)-i], cnt %= mod;\n\t\tans += (cnt * i) % mod, ans %= mod;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define N 10\nusing namespace std;\n\ntypedef long long ll;\nll n, s, fac[N + 5]{1, 1};\nint main()\n{\n\tll i, t, old = 0;\n\tfor (i = 2; i <= N; i++) fac[i] = fac[i - 1] * i;\n\tcin >> n;\n\tfor (i = (n + 1) / 2; i < n; i++) {\n\t\tt = fac[i] * fac[i - 1] / fac[2 * i - n];\n\t\ts += (t - old) * i;\n\t\told = t;\n\t}\n    cout << s << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long int M = 1000000007;\n\ntemplate<int N>\nstruct Fact{\n  long long int val[N];\n  long long int v2[N];\n  constexpr Fact() : val(), v2() {\n    val[0] = 1;\n    for(int i = 1; i < N; ++i)val[i] = val[i - 1] * i % M;\n    for(int i = 1; i < N; ++i)v2[i] = val[i - 1] * val[i] % M;\n  }\n};\n\ntemplate<int N, long long F>\nstruct IFact{\n  long long int val[N];\n  constexpr IFact() : val() {\n    val[N - 1] = F;\n    for(int i = N - 1; i > 0; --i)val[i - 1] = val[i] * i % M;\n  }\n};\n\nlong long int N, ans;\nconstexpr auto fact = Fact<1000001>();\nconstexpr auto ifact = IFact<1000001, 397802501>();\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    scanf(\"%lld\", &N);\n    for(int i = (N + 1) / 2; i < N - 1; ++i){\n        ans += fact.v2[i] * ifact.val[i * 2 - N] % M;\n    }\n    ans = fact.val[N] - fact.val[N - 1] - ans;\n    ans %= M;\n    printf(\"%lld\\n\",(ans > 0 ? ans : M + ans));\n    //cout << (ans > 0 ? ans : M + ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 100000000000000007LL\n#define ll long long\nusing namespace std;\nint ka[1145140],inv[1145140];\nvoid setkaijo(int n){\n\tka[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tka[i] = ka[i-1] * i;\n\t\tka[i] %= inf;\n\t}\n}\nint modpow(int x,int k){\n\t// x ^ k mod inf\n\tint res = 1;\n\twhile(k>0){\n\t\tif(k%2)res = (res*x)%inf;\n\t\tx = (x*x)%inf;\n\t\tk >>=1;\n\t}\n\treturn res;\n}\nvoid setinv(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tinv[i] = modpow(ka[i],(ll)inf-2);\n\t}\n}\nint comb(int n,int k){\n\tif( k<0 || n<0 || k>n)return 0;\n\tif(k==0 || k==n)return 1;\n\tint res = (ka[n] * inv[k]) % inf;\n\tres = (res*inv[n-k]) % inf;\n\treturn res;\n}\nsigned main(){\n\tint n;\n\tcin>>n;\n\tsetkaijo(1114514);\n\tsetinv(1114514);\n\tint mi = n/2 + n%2;\n\tint ma = n-1;\n\tint ans = 0;\n\tint sum = 0;\n\tfor(int i = mi; i<= ma;i++){\n\t\tint tmp = 1;\n\t\ttmp *= comb( i-1, n-i-1 );\n\t\ttmp *= ka[i]; tmp %= inf;\n\t\ttmp *= ka[n-1-i]; tmp %= inf;\n\t\ttmp += inf-sum; tmp %= inf;\n\t\tans += tmp * i; ans %= inf;\n\t\tsum += tmp; sum %= inf;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\n// for i in f..<t { as swift\n#define forin(i, f, t) for(auto i = f; i < t; i++)\n\nusing namespace std;\nusing ll = long long;\nint n;\n\nstring s[300];\n\nbool isSymmetry(int m) {\n    forin(i, 0, n) {\n        forin(j, 0, n) {\n            if (i == j) continue;\n            if (s[i][(j + m) % n] != s[(j + m) % n][i])\n                return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin >> n;\n    forin(i, 0, n) cin >> s[i];\n    ll count = 0;\n    forin(m, 0, n) {\n        if (isSymmetry(m)) count++;\n    }\n    cout << count * n << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nconst int64_t M = 1000000007;\nconst int MAX_N = 1000000;\nint64_t fact[MAX_N];\nint64_t inv[MAX_N];\n\nint64_t mod_pow(int64_t a, int64_t b)\n{\n  if (b == 0) return 1;\n  int64_t ret = mod_pow(a, b/2);\n  ret = ret * ret % M;\n  if (b % 2 == 1) ret = a * ret % M;\n  return ret;\n}\n\nint64_t comb(int64_t n, int64_t k)\n{\n  return (fact[n] * inv[n-k] % M) * inv[k] % M;\n}\n\nint main()\n{\n  cin >> n;\n\n  fact[0] = inv[0] = 1;\n  for (int i = 1; i < n; i++) {\n    fact[i] = fact[i-1] * i % M;\n    inv[i] = mod_pow(fact[i], M-2);\n  }\n\n  int64_t sum = 0;\n\n  int64_t prev_c = 0;\n  for (int k = 1; k <= n-1; k++) {\n    if (k - 1 >= n - 1 - k) {\n      int64_t c = (comb(k-1, n-1-k) * fact[k] % M) * fact[n-1-k] % M;\n      sum = (sum + k * ((c - prev_c) % M) % M) % M;\n      prev_c = c;\n    }\n  }\n\n  cout << sum << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#include <bitset>\n\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f3f3f3f3fLL\n#define SIZE 8080\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntypedef pair<double, int> pdi;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nll N;\nll dp[1145141]={0};\nll MOD = 1000000007;\nll bik[114514];\nll bikinv[114514];\nll gcd(ll a, ll b) {\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {\n\treturn a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\nll invMod(ll a, ll m) {\n\tll x, y;\n\tif (extgcd(a, m, x, y) == 1) return (x + m) % m;\n\telse                         return 0; // unsolvable\n}\nvoid bikcal(int NN){\n\tll hoge=(ll)1;\n\tbik[0]=(ll)1;\n\tbikinv[0]=(ll)1;\n\tfor(int i=1;i<NN;i++){\n\t\thoge=(hoge*i)%MOD;\n\t\tbik[i]=hoge;\n\t\tbikinv[i]=invMod(bik[i],MOD);\n\t}\n}\n\n\nll Comb(int a,int b){\n\tll ret;\n\tret=(((bik[a]*bikinv[b])%MOD)*bikinv[a-b])%MOD;\n\treturn ret;\n}\nint main(){\n\tcin>>N;\n\tint now=0;\n\tbikcal(N+1);\n\t//cout<<bikinv[0]<<endl;\n\t//cout<<Comb(4,0)<<endl;\n\tll ans=0;\n\tfor(int i=(N+1)/2;i<=N-1;i++){\n\t\tdp[i]=(((bik[i]*bik[N-i-1])%MOD)*Comb(i-1,2*i-N))%MOD;\n\t\t//if(i!=(N-1)&&(N%2==1))dp[i]=(2*dp[i])%MOD;\n\t\t//cout<<dp[i]<<endl;\n\t\tans=(ans+(((dp[i]-dp[i-1]+MOD)%MOD)*i)%MOD)%MOD;\n\t\t//cout<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 1000005, MOD = 1000000007;\nint f[N], finv[N], act[N];\n\ninline int mul(int a, int b) {\n    return (ll)a * b % MOD;\n}\n\nvoid precalc() {\n    f[0] = 1;\n    for (int i = 1; i < N; i++) {\n        f[i] = mul(f[i - 1], i);\n    }\n    finv[0] = finv[1] = 1;\n    for (int i = 2; i < N; i++) {\n        finv[i] = (MOD - mul(MOD / i, finv[MOD % i])) % MOD;\n    }\n    for (int i = 2; i < N; i++) {\n        finv[i] = mul(finv[i - 1], finv[i]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(cout.fixed);\n    cout.precision(20);\n    precalc();\n    int n;\n    cin >> n;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        act[k] = mul(mul(f[k - 1], f[k]), finv[2 * k - n]);\n    }\n    int res = 0;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        res = (res + mul(k, act[k] - act[k - 1] + MOD)) % MOD;\n    }\n    cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);++i)\n#define rep2(i,m,n) for(int (i)=(int)(n)-1;i>=(int)(m);--i)\n#define REP(i,n) rep(i,0,n)\n#define REP2(i,n) rep2(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\n#define en '\\n'\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nconstexpr long long INF = 1LL << 60;\nconstexpr int INF_INT = 1 << 25;\nconstexpr long long MOD = (ll) 1e9 + 7;\n//constexpr long long MOD = 998244353LL;\nusing ld=long double;\nstatic const ld pi = 3.141592653589793L;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge {\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<MOD>;\n\n// 二項係数ライブラリ\ntemplate<class T> struct Combination {\n    vector<T> fact_, inv_, finv_;\n    constexpr Combination() {}\n    constexpr Combination(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n+1);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T nPr(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[n-k];\n    }\n    constexpr T nCr(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T nHr(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return nCr(n+k-1,k);\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];//n!\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];//1/n\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];//1/n!\n    }\n};\n\nvoid solve(){\n\tll n;\n\tcin>>n;\n\tCombination<mint> com(n);\n\tmint ans = com.fact(n-1)*(n-1);\n\tREP(k,n-1){\n\t\tif(k-1<n-1-k) continue;\n\t\tans -= com.nCr(k-1,n-1-k) * com.fact(k) * com.fact(n-1-k);\n\t}\n\tcout<<ans<<en;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\t\n\tsolve();\n\t//ll t;cin>>t;REP(i,t) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\nconst int MN = 1000010;\n\nint N;\nll fac[MN], ifac[MN];\nll inv[MN];\n\nll nck(int n, int k) {\n\tif (n < 0 || k < 0 || k > n) {\n\t\treturn 0;\n\t}\n\treturn fac[n] * ifac[n-k] % MOD * ifac[k] % MOD;\n}\n\nint main() {\n\tinv[1] = 1;\n\n\tfor (int i = 2; i < MN; ++i) {\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\t\n\t}\n\n\tfac[0] = ifac[0] = 1;\n\tfor (int i = 1; i < MN; ++i) {\n\t\tfac[i] = fac[i-1] * i % MOD;\n\t\tifac[i] = ifac[i-1] * inv[i] % MOD;\n\t}\n\n\tcin >> N;\n\n\tll ret = 0;\n\n\tll la = 0;\n\n\tfor (int k = 1; k <= N-1; ++k) {\n\t\tll way = nck(k-1, N-1-k) * fac[k] % MOD * fac[N-1-k] % MOD;\n\t\tret = (ret + (way - la + MOD) * k) % MOD;\n\t\tla = way;\n\t}\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set tree<ttgl, null_type,less<ttgl>, rb_tree_tag,tree_order_statistics_node_update>*/\n \nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000007;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = 1e-6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 1000001;\nll fact[mxN];\nll ifact[mxN];\nll f[mxN];\nll g[mxN];\nll ans = 0;\nint n;\nll nCr(int n, int r) {\n    if(r>n)return 0;\n    return ((fact[n]*ifact[r])%MOD*(ifact[n-r]))%MOD;\n}\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n;\n    if(n==2) {\n        cout<<\"1\\n\";\n        exit(0);\n    }\n    fact[0] = 1;\n    ifact[0] = 1;\n    owo(i, 1, mxN) {\n        fact[i] = (fact[i-1]*i)%MOD;\n        ifact[i] = (ifact[i-1]*modInv(i))%MOD;\n    }\n    owo(i, 2, n) {\n        f[i] = (nCr(i-1, n-i-1)*fact[i])%MOD;\n        f[i] = (f[i]*fact[n-i-1])%MOD;\n        g[i] = (f[i] - f[i-1] + MOD)%MOD;\n        ans = (ans + g[i]*i)%MOD;\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n/// --- modulo Library {{{ ///\nconstexpr ll extgcd(ll a, ll b, ll& x, ll& y) {\n  if(b==0) {\n    x = 1; y = 0;\n    return a;\n  }\n  ll d = extgcd(b, a % b, y, x);\n  y -= (a / b) * x;\n  return d;\n}\nconstexpr ll modpow(ll a, ll b, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll r = 1;\n  while(b){\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\nconstexpr ll modinv(ll a, ll mod = 1e9 + 7) {\n  a = (a % mod + mod) % mod;\n  ll x = 0, y = 0;\n  extgcd(a, mod, x, y);\n  return (x % mod + mod) % mod;\n}\ntemplate<int N, int mod = int(1e9 + 7)> struct Factorial {\n  int arr[N+1], inv[N+1];\n  int operator[](int i) const { return arr[i]; }\n  constexpr Factorial(): arr(), inv() {\n    arr[0] = 1;\n    for(int i = 1; i <= N; i++) {\n      arr[i] = (ll) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N], mod);\n    for(int i = N-1; i >= 0; i--) {\n      inv[i] = (ll) (i + 1) * inv[i + 1] % mod;\n    }\n  }\n  int C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    return (((ll) arr[n] * inv[r]) % mod * inv[n - r]) % mod;\n  }\n};\n/// }}}--- ///\n\nconstexpr int N = 1e6 + 10;\nconstexpr Factorial<N> fact;\n\nll mod = 1e9 + 7;\n\n// これは天才\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n; cin >> n;\n  if(n == 2) return (cout << 1 << endl, 0);\n  ll ans = 0;\n  ll prev = 0;\n  for(int k = 1; k <= n - 1; k++) {\n    ll patterns = fact.C(k - 1, n - 1 - k);\n    patterns = (patterns * fact[k]) % mod;\n    patterns = (patterns * fact[n - 1 - k]) % mod;\n\n    // ここでpatternsは k \"以下\" の場合を数えている.\n    // つまりこれは数え上げテクニックとして,\n    // a_k - a_(k-1)\n    // などで just k回目 の値を数えられる.\n\n    ans = (((ans + (patterns - prev) * k)) % mod + mod) % mod;\n    prev = patterns;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n\nconst int mod = 1e9 + 7;\ninline int mul(int x, int y) {return (ll)x * y % mod;}\ninline int inc(int x, int y) {x += y; return x >= mod ? x - mod : x;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = (ll)x * x % mod)\n\t\tif (y & 1) res = (ll)res * x % mod;\n\treturn res; \n}\nconst int MAXN = 1e6 + 10;\nint n, fac[MAXN], inv[MAXN];\ninline int binom(int x, int y) {return y < 0 || y > x ? 0 : mul(fac[x], mul(inv[y], inv[x - y]));}\n\nint main()\n{\n\tcin >> n;\n\tif (n == 2) return puts(\"1\"), 0;\n\tif (n == 3) return puts(\"2\"), 0;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tinv[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n; i >= 2; i --)\n\t\tinv[i - 1] = mul(inv[i], i);\n\tint ans = fac[n - 1];\n\tfor (int i = 1; i < n - 1; i ++)\n\t{\n\t\tint cnt = binom(i - 1, n - i - 1);\n\t\tcnt = mul(cnt, fac[i]);\n\t\tcnt = mul(cnt, fac[n - i - 1]);\n\t\tcnt = inc(fac[n - 1], mod - cnt);\n\t\tans = inc(ans, cnt);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nint n;\nint md = 1000000007;\nint fact[1000010];\nint bfact[1000010];\n\ninline int mod(int x){\n    return (x % md + md) % md;\n}\n\ninline int C(int n, int k){\n    return mod(fact[n] * mod(bfact[k] * bfact[n-k]));\n}\n\nint binpow(int n, int k){\n    if(k == 0) return 1;\n    if(k & 1) return (binpow(n, k - 1) * n) % md;\n    int t = binpow(n, k >> 1);\n    return (t * t) % md;\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    fact[0] = bfact[0] = 1;\n    for(int i = 1; i <= n; i++){\n        fact[i] = mod(fact[i-1] * i);\n        bfact[i] = binpow(fact[i], md - 2);\n    }\n    int an = 0;\n    int last = 0;\n    for(int k = (n + 1) / 2; k < n; k++){\n        int tmp = C(k - 1, n - 1 - k);\n        tmp = mod(tmp * fact[k]);\n        tmp = mod(tmp * fact[n-1-k]);\n        int ttt = tmp;\n        tmp = mod(tmp - last);\n        last = ttt;\n        an = mod(an + tmp * k);\n    }\n    cout << an << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int max_N = (int)1e6 + 21;\n\nconst int mod = (int)1e9 + 7;\n\nint n, fac[max_N], _fac[max_N], inv[max_N], f[max_N];\n\nint main(){\n\tscanf(\"%d\", &n);\n\t\n\tif(n==1) return puts(\"1\"), 0;\n\t\n\tinv[1] = 1;\n\tfor(int i=2;i<=n;++i){\n\t\tinv[i] = 1ll*(mod/i)*inv[mod%i]%mod;\n\t\tif(inv[i]) inv[i] = mod-inv[i];\n\t}\n\t\n\tfac[0] = _fac[0] = 1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i] = 1ll*fac[i-1]*i%mod;\n\t\t_fac[i] = 1ll*_fac[i-1]*inv[i]%mod;\n\t}\n\t\n\tauto binom = [](int n, int m){\n\t\tif(n < m) return 0;\n\t\treturn int(1ll*fac[n]*_fac[m]%mod*_fac[n-m]%mod);\t\n\t};\n\t\n\tfor(int i=1;i<n;++i) f[i] = 1ll*binom(i-1, n-i-1)*fac[i]%mod*fac[n-i-1]%mod;\n\t\n\tint ans = 0;\n\t\n\tfor(int i=1;i<n;++i){\n\t\tint g = (f[i]-f[i-1]+mod)%mod;\n\t\tans = (ans+1ll*g*i)%mod;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*x%mod;\n    x=x*x%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll f[1000010],finv[1000010];\nll comb(ll n,ll r){\n  if(n<0||r<0||n<r)return 0;\n  return (f[n]*finv[n-r]%mod)*finv[r]%mod;\n}\n\nll n;\nll res=0;\n\nint main(){\n  cin>>n;\n  f[0]=f[1]=1;\n  repl(i,1,1000001)f[i+1]=(i+1)*f[i]%mod;\n  rep(i,1000001)finv[i]=mod_pow(f[i],mod-2);\n\n  ll res=0;\n  ll sum=0;\n  repl(i,(n+1)/2,n){\n    ll c=((((comb(i-1,n-1-i)*f[i])%mod)*f[n-1-i]%mod)-sum+mod)%mod;\n    (res+=c*i%mod)%=mod;\n    sum=((comb(i-1,n-1-i)*f[i])%mod)*f[n-1-i]%mod;\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i] * i % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main() {\n\tunsigned int n;\n\tuint64 ans;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = (N + 1) >> 1; i < N - 1; ++i) {\n\t\tans = (ans + fact.v2[i] * ifact.val[(i << 1) - N]) % M;\n\t}\n\tlong long unsigned int o = (fact.val[N - 1] + M - ans) % M;\n\tprintf(\"%llu\\n\", o);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 300000;\nconst int K = 100000;\nconst int mod = 1e9 + 7;\nint dp[N], f[N], invf[N], n, a[N];\nint binpow(int x, int y){\n    int res = 1;\n    while(y){\n        if (y % 2) res = res * x % mod;\n        y /= 2;\n        x = x * x % mod;\n    }\n    return res;\n}\nint c(int n, int k){\n    if (k > n || n < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n;\n    cin >> n;\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) f[i] = f[i - 1] * i % mod;\n    invf[n] = binpow(f[n], mod - 2);\n    for (int i = n - 1; i >= 0; i--) invf[i] = invf[i + 1] * (i + 1) % mod;\n    for (int i = 0; i < n; i++){\n        a[i] = c(n - 1 - (i + 1), n - 1 - i - (i + 1)) * f[i] % mod * f[n - 1 - i] % mod;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++){\n        ans = (ans + (a[i] - a[i + 1]) * (n - i - 1)) % mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int mod=1e9+7;\n\nll quick_pow(ll a,ll b){\n\tll ans=0;\n\twhile(b){\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nconst int maxn=2e6+7;\nll fac[maxn],inv[maxn],f[maxn];\n\nll C(ll n,ll m){\n\tif(n<m)  return 0;\n\tif(m==0) return 1;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint main (){\n\tint n;cin>>n;\n\tfac[0]=1;fac[1]=1;\n\tfor(int i=2;i<=maxn;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[maxn]=quick_pow(fac[maxn],mod-2);\n\tfor(int i=maxn-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tll ans=0;\n\tf[2]=1,f[1]=1;\n\tfor(int k=n/2;k<n;k++){\n\t\tf[k]=C(k-1,n-k-1)*fac[k]%mod*fac[n-k-1]%mod;\n\t\tans=(ans+(f[k]-f[k-1]+mod)%mod*k%mod+mod)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 1000000;\nconst int MOD = 1000000007;\n\nint n;\n\nint f[MAXN + 1];\n\nint inv[MAXN + 1];\nint fac[MAXN + 1];\nint ifac[MAXN + 1];\n\nint C(int n, int k) {\n\tif (k<0 || k>n) return 0;\n\treturn (ll)fac[n] * ifac[k] % MOD*ifac[n - k] % MOD;\n}\n\nint calc(int nop) {\n\tint nspace = n, nhash = n - nop;\n\tif (nhash == 0) return 0; else --nhash, nspace -= 2;\n\tif (nspace < 2 * nhash) return 0;\n\treturn (ll)C(nspace - nhash, nhash)*fac[nop] % MOD*fac[n - 1 - nop] % MOD;\n}\n\nint bf() {\n\tvector<int> p(n - 1); REP(i, n - 1) p[i] = i;\n\tint ret = 0;\n\tmap<int, int> tmp;\n\tdo {\n\t\tint mask = 0; int cnt = 0;\n\t\tREPSZ(i, p) {\n\t\t\tREP(j, 2) {\n\t\t\t\tint x = p[i] + j;\n\t\t\t\tif (mask&(1 << x)) continue;\n\t\t\t\tmask |= 1 << x; ++cnt;\n\t\t\t}\n\t\t\tif (cnt == n) {\n\t\t\t\tint ans = i + 1;\n\t\t\t\tret += ans;\n\t\t\t\tif (ans <= n - 2) {\n\t\t\t\t\tint pmask = 0; REP(j, n - 2) pmask |= 1 << p[j];\n\t\t\t\t\t++tmp[pmask];\n\t\t\t\t}\n\t\t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tassert(cnt == n);\n\t} while (next_permutation(p.begin(), p.end()));\n\tfor (auto it = tmp.begin(); it != tmp.end(); ++it) { int mask = it->first; REP(i, n) printf(\"%c\", mask&(1 << i) ? '+' : '.'); printf(\" = %d\\n\", it->second); }\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d\", &n);\n\tinv[1] = 1; FORE(i, 2, n) inv[i] = (ll)(MOD - MOD / i)*inv[MOD%i] % MOD;\n\tfac[0] = 1; FORE(i, 1, n) fac[i] = (ll)fac[i - 1] * i%MOD;\n\tifac[0] = 1; FORE(i, 1, n) ifac[i] = (ll)ifac[i - 1] * inv[i] % MOD;\n\n\tREP(i, n) f[i] = calc(i);\n\t//printf(\"f:\"); REP(i, n) printf(\" %d\", f[i]); puts(\"\");\n\tint ret = 0;\n\tFOR(i, 1, n) {\n\t\tint cur = (f[i] - f[i - 1] + MOD) % MOD;\n\t\tret = (ret + (ll)i*cur) % MOD;\n\t}\n\tprintf(\"%d\\n\", ret);\n\t//if (n <= 11) printf(\"bf=%d\\n\", bf());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n#ifndef debug_on\n#define debug_on 0\n#endif\n\n#define dbg \\\n    if(debug_on) cerr << \"DEBUG:\"\n#define ast(cond)           \\\n    do {                    \\\n        if((cond) == false) \\\n        {                   \\\n            if(debug_on)    \\\n            cerr << \"ASSERT\" << #cond \" failed at line:\" << __LINE__ << endl;   \\\n            exit(1);        \\\n        }                   \\\n    }while(0)\n\ntemplate<typename T>\nvoid InvMod(T *inv_mod, T n, T r)\n{\n    inv_mod[0] = 1;\n    if(1 <= n)\n        inv_mod[1] = 1;\n    for(T i = 2; i <= n; ++i)\n    {\n        inv_mod[i] = r - ((r / i) * inv_mod[r % i] % r);\n        ast(((inv_mod[i] * i) % r) == 1);\n    }\n}\n\ntemplate<typename T>\nvoid InvFactMod(T * inv_fact_mod, const T *inv_mod, T n, T r)\n{\n    inv_fact_mod[0] = 1;\n    if(1 <= n)\n        inv_fact_mod[1] = 1;\n    for(T i = 2; i <= n; ++i)\n    {\n        inv_fact_mod[i] = inv_fact_mod[i - 1] * inv_mod[i] % r;\n    }\n}\n\ntemplate<typename T>\nvoid FactMod(T * fact_mod, T n, T r)\n{\n    fact_mod[0] = 1;\n    if(1 <= n)\n        fact_mod[1] = 1;\n    for(T i = 2; i <= n; ++i)\n    {\n        fact_mod[i] = fact_mod[i-1] * i % r;\n    }\n}\n\n\nint main(int, char *[])\n{\n    uint64_t N;\n    const uint64_t R = 1000000000 + 7;\n    cin >> N;\n\n    const int min_step = (1+N) / 2;\n    const int max_step = N - 1;\n    dbg << \"MinStep:\" << min_step << \" max_step:\" << max_step << endl;\n    vector<uint64_t> inv_mod(N+1);\n    InvMod(inv_mod.data(), N, R);\n    vector<uint64_t> inv_fact_mod(N+1);\n    InvFactMod(inv_fact_mod.data(), inv_mod.data(), N, R);\n    vector<uint64_t> fact_mod(N+1);\n    FactMod(fact_mod.data(), N, R);\n    auto comb = [&](uint64_t n, uint64_t i)->uint64_t\n    {\n        uint64_t mul = fact_mod[n];\n        mul *= inv_fact_mod[i];\n        mul %= R;\n        mul *= inv_fact_mod[n - i];\n        mul %= R;\n        dbg << \"Comb(\" << n << \",\" << i << \"):\" << mul << endl;\n        return mul;\n    };\n    uint64_t sum = 0;\n    uint64_t prev_pats = 0;\n    for(int i = 1; i <= max_step; ++i)\n    {\n        if(i-1 < N - 1 - i) continue;\n        uint64_t mul = comb(i-1, N - 1 - i);\n        mul *= fact_mod[i];\n        mul %= R;\n        mul *= fact_mod[N - 1 - i];\n        mul %= R;\n\n        const uint64_t cur_total = mul;\n\n        mul += R;\n        mul -= prev_pats;\n        mul %= R;\n\n        prev_pats  = cur_total;\n\n        mul *= i;\n        mul %= R;\n        sum += mul;\n        sum %= R;\n    }\n    cout << sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll fact[1000001];\n\nll extgcd(ll a,ll b,ll& x,ll& y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll& e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2!=0){\n\t\treturn res*(p-fact[n%p])%p;\n\t}\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\n\nvoid solve(){\n\tll ans=0;\n\tll sum=0;\n\tfor(int i=2;i<=n-1;i++){\n\t\tll val=fact[i];\n\t\tval=val*mod_comb(i-1,n-1-i,MOD)%MOD;\n\t\tval=val*fact[n-1-i]%MOD;\n\t\tval+=MOD-sum;\n\t\tval%=MOD;\n\t\tans=(ans+(ll)val*i%MOD)%MOD;\n\t\tsum+=val;\n\t\tsum%=MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfact[0]=1;\n\tfor(ll i=1;i<=1000000;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t}\n\tif(n==2){\n\t\tprintf(\"1\\n\");\n\t}\n\tif(n==3){\n\t\tprintf(\"4\\n\");\n\t}\n\tif(n>=4){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int Fac[1000010]; \nlong long int Inv(long long int a, long long int m) {\n\tlong long int c[50];\n\tlong long int e[50];  \n\tc[0] = (m-2) % 2, e[0] = (m-2) / 2; \n\tfor (int i = 0; i < 49; ++i){\n\t\tc[i+1] = e[i] % 2;\n\t\te[i+1] = e[i] / 2;  \n\t}\n\tlong long int d[50]; \n\td[0] = a; \n\tfor (int j = 0; j < 49; ++j){\n\t\td[j+1] = (d[j] * d[j]) % m; \n\t}\n\tlong long int Q = 1; \n\tfor(int k = 0; k < 49; ++k){\n\t\tif(c[k]) Q = (Q * d[k]) % m; \n\t}\n\treturn Q;\n}\nint main(){\n\tint N; \n\tcin >> N; \n\tlong long int P = 1000000007; \n\tFac[0] = 1; \n\tfor(int i = 1; i <= 1000005; i++){\n\t\tFac[i] = (long long) i * Fac[i-1] % P; \n\t}\n\tlong long int ans1 = (long long) (N-1) * Fac[N-1] % P; \n\tlong long int ans2 = 0; \n\tfor(int i = N-2; i >= (N+1) / 2; i--){\n\t\tlong long int tmp = (((Fac[i-1] * Fac[i]) % P) * Inv(Fac[2*i-N], P)) % P; \n\t\tans2 = (ans2 + tmp) % P; \n\t}\n\tcout << (ans1 + P - ans2) % P << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#ifdef DEBUG\n#include \"cout11.h\"\n#undef NDEBUG\n#endif\n#include <cassert>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n\n\nll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\n\nconst ll M=1000000007LL;\n\nll ADD(ll x, ll y) { return (x+y) % M; }\nll SUB(ll x, ll y) { return (x-y+M) % M; }\nll MUL(ll x, ll y) { return x*y % M; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { assert(y%M!=0); return MUL(x, POW(y, M-2)); }\n// ll comb(ll n, ll k) { ll v=1; for(ll i=1; i<=k; i++) v = DIV(MUL(v, n-i+1),i); return v; }\n\n\nint N;\n\n\nll _fact[100001];\n\nvoid _prepare_fact(){\n    _fact[0] = _fact[1] = 1LL;\n    for(int i=2; i<=N; ++i) {\n        _fact[i] = MUL(_fact[i-1], i);\n    }\n}\n\ninline ll fact(int x){\n    assert(IN(x,0,N));\n    return _fact[x];\n}\n\n\nll sub(int k) {\n    // k回以内で\n    // a +  b = k - 1\n    // a + 2b = N - 2\n    int a = k*2 - N;\n    if (a < 0) return 0;\n    int b = N - k - 1;\n    // fprintf(stderr, \" // N=%d, k=%d; a=%d, b=%d;; %d %d %d %d %d\\n\", N,k,a,b, a+b, a,b,k,N-1-k);\n    assert(a+b == k-1);\n    assert(a+b*2 == N-2);\n\n    return MUL(\n            DIV(fact(a+b),\n                MUL(fact(a), fact(b))),\n            MUL(fact(k), fact(N-1-k))\n        );\n}\n\nll solve() {\n    ll total = 0;\n    ll last = 0;\n    for (int k=1; k<=N-1; ++k) {\n        ll a = sub(k), x = a - last;\n        total = ADD(total, MUL(x, k));\n        // fprintf(stderr, \"<=k=%d: %lld ; x=%lld\\n\", k,a, x);\n        last = a;\n    }\n    return total;\n}\n\nint main() {\n    cin >> N;\n    assert(IN(N,2,1000000));\n\n    _prepare_fact();\n\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#define db double\n#define LL long long\n#define inf 0x3f3f3f3f\n#define N 1000005\nusing namespace std;\nint gi()\n{\n    int res=0,s=1; char ch;\n    for(ch=getchar();(ch<'0'||ch>'9')&&ch!='-';ch=getchar());\n    if(ch=='-') s=-1,ch=getchar();\n    for(;ch>='0'&&ch<='9';ch=getchar()) res=res*10+ch-48;\n    return res*s;\n}\nconst int mo=1000000007;\nint n,jc[N],ny[N],f[N],ans;\nLL qp(LL x,LL y) {\n    LL res=1;\n    for(;y;y>>=1,x=x*x%mo)\n\tif(y&1) res=res*x%mo;\n    return res;\n}\nint C(int n,int m) {\n    return n>=m ? 1ll*jc[n]*ny[m]%mo*ny[n-m]%mo : 0;\n}\nint main()\n{\n    n=gi();\n    if(n==2) {printf(\"1\\n\");return 0;}\n    jc[0]=1; for(int i=1;i<=n;++i) jc[i]=1ll*jc[i-1]*i%mo;\n    ny[n]=qp(jc[n],mo-2);\n    for(int i=n-1;i>=0;--i) ny[i]=1ll*ny[i+1]*(i+1)%mo;\n    for(int i=2;i<=n-1;++i)\n\tf[i]=1ll*C(i-1,n-1-i)*jc[i]%mo*jc[n-1-i]%mo;\n    for(int i=2;i<=n-1;++i)\n\tans+=1ll*i*(f[i]-f[i-1]+mo)%mo,ans>=mo?ans-=mo:0;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i ; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\nint main() {\n\tstd::size_t n;\n\tuint64 ans;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = N >> 1; i < N - 1; ++i) {\n\t\tans += fact.v2[i] * ifact.val[(i << 1) - N] % M;\n\t}\n\tans = (fact.val[N - 1] * (N - 1) + M - ans) % M;\n\tprintf(\"%llu\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\nint fastpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = fastpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int comb(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    if(N == 2){\n        cout << 1;\n        return 0;\n    }\n    int mod = 1000000007;\n\n    Combination C(N, mod);\n    int ans = 0;\n\n    //両端以外が最後\n    FOR(k, 1, (N - 3) / 2 + 1){\n        int c = (k * C.comb(N - 3 - k, k)) % mod;\n        int tmp = (c * C.fact[N - k - 2]) % mod;\n        tmp = (tmp * 2 * C.fact[k]) % mod;\n        tmp = (tmp * (N - 1 - k)) % mod;\n        ans = (ans + tmp) % mod;\n    }\n\n    //両端が最後\n    FOR(k, 0, (N - 2) / 2 + 1){\n        int c = C.comb(N - k - 2, k);\n        int tmp = (c * C.fact[N - 2 - k]) % mod;\n        tmp = (tmp * C.fact[k]) % mod;\n        tmp = (tmp * (N - 1 - k)) % mod;\n        ans = (ans + 2 * tmp) % mod;\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int MOD = int(1e9) + 7;\n\nint n;\nint f[1000005], rf[1000005];\n\nvoid init() {\n    rf[0] = rf[1] = 1;\n    for (int i = 2; i < 1000005; ++i) {\n        rf[i] = (MOD - (LL)(MOD / i) * rf[MOD % i] % MOD) % MOD;\n    }\n    f[0] = 1;\n    for (int i = 1; i < 1000005; ++i) {\n        f[i] = (LL)f[i - 1] * i % MOD;\n        rf[i] = (LL)rf[i - 1] * rf[i] % MOD;\n    }\n}\n\nint c(int n, int k) {\n    return (LL)f[n] * rf[k] % MOD * rf[n - k] % MOD;\n}\n\nint main() {\n    init();\n    scanf(\"%d\", &n);\n    int ans = 0;\n    int pre = 0;\n    for (int k = (n + 1) / 2; k < n; ++k) {\n        int cur = (LL)c(k - 1, n - k - 1) * f[k] % MOD * f[n - 1 - k] % MOD;\n        ans = (ans + (LL)k * (cur - pre)) % MOD;\n        pre = cur;\n    }\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nstruct Combination\n{\n    using type = long long;\n    vector<type> fact, inv;\n    type mod;\n    int size;\n    bool initiated;\n    Combination(type sz, type m) : fact(sz + 1, 1), inv(sz + 1, 1), mod(m), size(sz)\n    {\n        initiated = false;\n    }\n    type mypow(type a, type b)\n    {\n        if (b == 0)\n            return 1;\n        type tmp = mypow(a, b / 2);\n        if (b % 2)\n            return (((tmp * tmp) % mod) * a) % mod;\n        else\n            return (tmp * tmp) % mod;\n    }\n    void init()\n    {\n        for (int i = 2; i <= size; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= MOD;\n            inv[i] = mypow(fact[i], mod - 2);\n        }\n    }\n    type comb(type p, type q)\n    {\n        if (!initiated)\n        {\n            initiated = true;\n            init();\n        }\n        if (p < q)\n            return 0;\n        if (q < 0)\n            return 0;\n        type ret = fact[p];\n        ret *= inv[q];\n        ret %= mod;\n        ret *= inv[p - q];\n        ret %= mod;\n        return ret;\n    }\n    type getFact(int index)\n    {\n        return fact[index];\n    }\n    type getInv(int index)\n    {\n        return inv[index];\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    Combination C(1000000, MOD);\n    ll res = 0, sum = 0;\n    for (int i = 1; i <= N; i++)\n    {\n        ll tmp = C.getFact(i) * C.getFact(N - i - 1);\n        tmp %= MOD;\n        tmp *= C.comb(i - 1, N - i - 1);\n        tmp %= MOD;\n        if (tmp == 0)\n            continue;\n        res += i * ((tmp + MOD - sum) % MOD);\n        sum = tmp;\n        res %= MOD;\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define all(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define X 1000010\nll fac[X],ivf[X],inv[X];\nll C(ll n,ll k){\n\tif(n<k)return 0;\n\tif(k<0)return 0;\n\treturn fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nvoid init(){\n\tfac[0]=ivf[0]=inv[1]=1;\n\tfor(ll i=1;i<X;i++){\n\t\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tivf[i]=ivf[i-1]*inv[i]%mod;\n\t}\n}\nll f[X];\nint main(){\n\tinit();\n\tll n;\n\tcin>>n;\n\tfor(int k=1;k<=n-1;k++){\n\t\tif(n-1-k>=0){\n\t\t\tf[k]=C(k-1,n-k-1)*fac[k]%mod*fac[n-1-k]%mod;\n\t\t}\n\t}\n\tfor(int k=n-1;k>=2;k--){\n\t\tf[k]-=f[k-1];\n\t}\n\tll ans=0;\n\tfor(int k=1;k<=n-1;k++){\n\t\tans=(ans+f[k]*k)%mod;\n\t}\n\tif(ans<0)ans+=mod;\n\tcout<<ans<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 40; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long Div(long long a, long long b, long long m) {\n\treturn (a*modpow(b, m - 2, m)) % m;\n}\n\nlong long N, fact[1000009], factinv[1000009], inv[1000009], mod = 1000000007;\nconst int MAX_N = 1000006;\n\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= MAX_N; i++) { fact[i] = 1LL * fact[i - 1] * i; fact[i] %= mod; }\n\tfor (int i = 0; i <= MAX_N; i++) factinv[i] = Div(1, fact[i], mod);\n\tfor (int i = 1; i <= MAX_N; i++) inv[i] = Div(1, i, mod);\n}\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\tlong long R = factinv[r] * factinv[n - r]; R %= mod;\n\treturn (R*fact[n]) % mod;\n}\n\nint main() {\n\tcin >> N;\n\tif (N == 2) { cout << \"1\" << endl; return 0; }\n\tif (N == 3) { cout << \"4\" << endl; return 0; }\n\tif (N == 4) { cout << \"16\" << endl; return 0; }\n\n\tlong long sum = 0; init();\n\n\tfor (int i = 3; i <= N; i++) {\n\t\tlong long E = 2 * (i - 1) - (N - 2);\n\t\tlong long V = ncr(i - 1, E);\n\t\tlong long U = E*(E - 1); U %= mod;\n\t\tU *= inv[i - 1]; U %= mod;\n\t\tU *= inv[i - 2]; U %= mod;\n\t\tU = (mod + 1 - U); U %= mod;\n\t\tU *= (i - 2); U %= mod; U += 2; U %= mod;\n\n\t\tV *= U; V %= mod;\n\t\tV *= (fact[i - 1] * fact[N - 1 - i]) % mod; V %= mod;\n\t\tsum += (V*i) % mod; sum %= mod;\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n;\nll MOD = 1e9+7;\nll num[1000100];\nll fac[1000100];\nll fnv[1000100];\n\nll power(ll a, ll n) {\n    if (!n) return 1;\n    ll t = power(a,n/2);\n    return t*t%MOD*((n%2)?a:1)%MOD;\n}\n\nll comb(ll n, ll k) {\n    if (k<0||k>n) return 0;\n    return fac[n]*fnv[k]%MOD*fnv[n-k]%MOD;\n}\n\nint main() {\n    int i;\n\n    scanf(\"%d\",&n);\n    fac[0] = 1;\n    for (i=1;i<=n;i++) fac[i]=fac[i-1]*i%MOD;\n    for (i=0;i<=n;i++) fnv[i]=power(fac[i],MOD-2);\n    for (i=0;i<n;i++) num[i] = comb(i-1,2*i-n)*fac[n-1-i]%MOD*fac[i]%MOD;\n    for (i=n-1;i>0;i--) num[i] = (num[i]+MOD-num[i-1])%MOD;\n   // for (i=0;i<n;i++) printf(\"%d : %lld\\n\",i,num[i]);\n    ll ans = 0;\n    for (i=0;i<n;i++) ans = (ans+num[i]*i)%MOD;\n    printf(\"%lld\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Utkarsh.25dec\n#include <bits/stdc++.h>\n#include <chrono>\n#include <random>\n#define ll long long int\n#define ull unsigned long long int\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define loop(i,a,b) for(ll i=a;i<=b;i++)\n#define vi vector <int>\n#define vs vector <string>\n#define vc vector <char>\n#define vl vector <ll>\n#define all(c) (c).begin(),(c).end()\n#define max3(a,b,c) max(max(a,b),c)\n#define min3(a,b,c) min(min(a,b),c)\n#define deb(x) cerr<<#x<<' '<<'='<<' '<<x<<'\\n'\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n// ordered_set s ; s.order_of_key(val)  no. of elements strictly less than val\n// s.find_by_order(i)  itertor to ith element (0 indexed)\ntypedef vector<vector<ll>> matrix;\nll power(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll modInverse(ll a){return power(a,mod-2);}\nconst int N=500023;\nbool vis[N];\nvector <int> adj[N];\nll fact[N];\nll invfact[N];\nll inv[N];\nvoid factorialsComputation()\n{\n    inv[0]=inv[1]=1;\n    fact[0]=fact[1]=1;\n    invfact[0]=invfact[1]=1;\n    for(int i=2;i<N;i++)\n    {\n        inv[i]=(inv[mod%i]*(mod-mod/i))%mod;\n        fact[i]=(fact[i-1]*i)%mod;\n        invfact[i]=(invfact[i-1]*inv[i])%mod;\n    }\n}\nll ncr(ll n,ll r)\n{\n    ll ans=fact[n];\n    ans*=(invfact[r]);\n    ans%=mod;\n    ans*=(invfact[n-r]);\n    ans%=mod;\n    return ans;\n}\nvoid solve()\n{\n    ll n;\n    cin>>n;\n    ll f[n+1]={0};\n    int low=(n+1)/2;\n    for(int k=low;k<=n-1;k++)\n    {\n        f[k]=(ncr(k-1,n-k-1))*fact[k];\n        f[k]%=mod;\n        f[k]*=fact[n-1-k];\n        f[k]%=mod;\n    }\n    ll ans=0;\n    for(int k=low;k<=n-1;k++)\n    {\n        ll ways=f[k]-f[k-1]+mod;\n        ways%=mod;\n        ways*=k;\n        ways%=mod;\n        ans+=ways;\n        ans%=mod;\n    }\n    cout<<ans<<'\\n';\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int T=1;\n    //cin>>T;\n    int t=0;\n    factorialsComputation();\n    while(t++<T)\n    {\n        //cout<<\"Case #\"<<t<<\":\"<<' ';\n        solve();\n        //cout<<'\\n';\n    }\n    cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << \"ms\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename Container>\nint SZ(const Container& S) { return S.size(); }\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg_var(x) clog << #x  << \": \" << x << endl;\n    #define dbg_array(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg_var(x)\n    #define dbg_array(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 1100000;\n\nLL Inverse(LL n, LL m) {\n    n %= m;\n    if (n <= 1) return n; // Handles properly (n = 0, m = 1).\n    return m - ((m * Inverse(m, n) - 1) / n);\n}\n\nLL fact[MAXN];\nLL invfact[MAXN];\nconst LL mod = 1e9 + 7;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; i++) fact[i] = (i*fact[i-1]) % mod;\n    for (int i = 0; i < MAXN; i++) invfact[i] = Inverse(fact[i], mod);\n\n    int N;\n    cin >> N;\n    LL res = fact[N];\n    for (int l = 1; l <= N-1; l++) {\n        if (2*l-N < 0) continue;\n        res -= ((fact[l]*fact[l-1])%mod*invfact[2*l-N]) % mod;\n    }\n    res %= mod;\n    res += mod;\n    res %= mod;\n    cout << res << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\n\n\ntemplate<typename Type, typename Operators>\nstruct AlgStruct {\n\n    Type x;\n\n    template<typename... Args> AlgStruct(Args... args) : x(args...) {}\n\n    template<typename... Args>\n        decltype(auto) operator[](Args... args) { return x.operator[](args...); }\n\n\n    AlgStruct& operator=(const AlgStruct& value) & = default;\n\n    template<typename... Args>\n        static AlgStruct id_add(Args... args) { return Operators::IdAdd(args...); }\n\n    template<typename... Args>\n        static AlgStruct id_mul(Args... args) { return Operators::IdMul(args...); }\n\n    AlgStruct operator+() const { return *this; }\n    AlgStruct operator-() const { return Operators::Opposite(x); }\n    AlgStruct reciprocal() const { return Operators::Reciprocal(x); }\n\n    AlgStruct operator+=(const AlgStruct& rhs) { x = Operators::Add(x, rhs.x); return *this; }\n    AlgStruct operator-=(const AlgStruct& rhs) { *this += -rhs; return *this; }\n    AlgStruct operator*=(const AlgStruct& rhs) { x = Operators::Mul(x, rhs.x); return *this; }\n    AlgStruct operator/=(const AlgStruct& rhs) { return *this *= rhs.reciprocal(); }\n\n    const AlgStruct operator+(const AlgStruct& rhs) const { return AlgStruct(*this) += rhs; }\n    const AlgStruct operator-(const AlgStruct& rhs) const { return AlgStruct(*this) -= rhs; }\n    const AlgStruct operator*(const AlgStruct& rhs) const { return AlgStruct(*this) *= rhs; }\n    const AlgStruct operator/(const AlgStruct& rhs) const { return AlgStruct(*this) /= rhs; }\n\n    AlgStruct power(LL n) const { return Operators::Power(x, n); }\n\n    bool operator<(const AlgStruct& rhs) const { return Operators::Less(x, rhs.x); }\n    bool operator>(const AlgStruct& rhs) const { return rhs < *this; }\n    bool operator<=(const AlgStruct& rhs) const { return !(*this > rhs); }\n    bool operator>=(const AlgStruct& rhs) const { return !(*this < rhs); }\n    bool operator==(const AlgStruct& rhs) const { return !(*this < rhs) && !(*this > rhs); }\n    bool operator!=(const AlgStruct& rhs) const { return !(*this == rhs); }\n};\n\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator+(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) + rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator-(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) - rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator*(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) * rhs;\n}\ntemplate<typename Type, typename Operators>\nconst AlgStruct<Type, Operators> operator/(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) / rhs;\n}\n\ntemplate<typename Type, typename Operators>\nbool operator<(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) < rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) > rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator<=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) <= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator>=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) >= rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator==(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) == rhs;\n}\ntemplate<typename Type, typename Operators>\nbool operator!=(const Type& lhs, const AlgStruct<Type, Operators>& rhs) {\n    return AlgStruct<Type, Operators>(lhs) != rhs;\n}\n\ntemplate<typename Type, typename Operators>\nauto& operator<<(ostream& s,const AlgStruct<Type, Operators>& a){ s << a.x; return s; }\n\n\ntemplate<LL mod>\nstruct GaloisFieldOperators {\n    static LL Add(LL lhs, LL rhs) { return (lhs + rhs) % mod; };\n    static LL Mul(LL lhs, LL rhs) { return (lhs * rhs) % mod; };\n    static LL IdAdd() { return 0; };\n    static LL IdMul() { return 1; };\n    static LL Opposite(LL value) { return ((-value % mod) + mod) % mod; };\n    static bool Less(LL lhs, LL rhs) { return lhs < rhs; };\n    static LL Power(LL value, LL n) {\n        LL res = IdMul();\n        while (n > 0) {\n            if (n & 1) res = Mul(res, value);\n            value = Mul(value, value); n >>= 1;\n        }\n        return res;\n    }\n    static LL Reciprocal(LL value) { return Power(value, mod-2); }\n};\n\nconst LL MOD = 1e9+7;\n\nusing GaloisField = AlgStruct<LL, GaloisFieldOperators<MOD>>;\n\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring::id_mul();\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * i;\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return 0;\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\n\nsigned main()\n{\n    LL n; cin >> n;\n\n    Fact<GaloisField> fact(n);\n    Comb<GaloisField> comb(n);\n\n    vector<GaloisField> num(n);\n\n    for (int k = 1; k <= n-1; ++k) {\n        num[k] = comb(k-1, n-1-k) * fact[k] * fact[n-1-k];\n    }\n\n    GaloisField ans = 0;\n\n    for (LL k = 1; k <= n-1; ++k) {\n        ans += (num[k] - num[k-1]) * k;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10, p = 1e9 + 7;\nint n, ans, fac[N], inv[N], f[N];\ninline void A(int &x, int y) { x += y; if (x >= p) x -= p; }\ninline int C(int x, int y) { return 1ll * fac[x] * inv[y] % p * inv[x - y] % p; }\nint main() {\n\tscanf(\"%d\", &n); --n;\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = 1ll * fac[i - 1] * i % p;\n\tinv[0] = inv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = 1ll * inv[p % i] * (p - p / i) % p;\n\tfor (int i = 2; i <= n; ++i) inv[i] = 1ll * inv[i] * inv[i - 1] % p;\n\tint bd = (n + 2) >> 1;\n\tfor (int i = bd; i <= n; ++i) f[i] = 1ll * C(i - 1, n - i) * fac[n - i] % p * fac[i] % p;\n\tfor (int i = n; i > bd; --i) A(f[i], p - f[i - 1]);\n\tint ans = 0;\n\tfor (int i = bd; i <= n; ++i) A(ans, 1ll * f[i] * i % p);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(v) (v).begin(),(v).end()\n\n#define PII pair<int,int>\n#define mp make_pair\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define debug(x) {cerr <<#x <<\" = \" <<x <<endl; }\n#define debug2(x,y) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y <<endl; } \n#define debug3(x,y,z) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y << \", \" << #z << \" = \" << z <<endl; } \n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<endl; }}\n#define debugt(t,n) {{cerr <<#t <<\" = \"; FOR(it,0,(n)) cerr <<t[it] <<\", \"; cerr <<endl; }}\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n\n\nusing namespace std;\n\nconst int max_n = 1e6 + 5;\n\n\nint mod = 1e9 + 7;\n\nint powmod(int a, int b) {\n\t if (b == 0) return 1;\n\t int sq = powmod(a, b/2);\n\t sq = (sq * 1LL * sq) % mod;\n\t if (b%2 == 0) return sq;\n\t return (sq * 1LL * a) % mod;\n}\n\nint fac[max_n];\nint ifac[max_n];\n\nint newton(int n, int k) {\n\tif (k < 0 || n < 0) return 0;\n\tif (k > n) return 0;\n\tint ans = (fac[n] * 1LL * ifac[k])%mod;\n\treturn (ans * 1LL * ifac[n-k])%mod;\n}\n\nint main() {\n\tmake(n);\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tn--;\n\tFOR(i,1,n+1) fac[i] = (i * 1LL * fac[i-1]) % mod;\n\tFOR(i,1,n+1) ifac[i] = powmod(fac[i], mod - 2);\n\tint ans = fac[n];\n\tFOR(k,1,n) {\n\t\tint mnoz = (fac[n-k]*1LL*fac[k])%mod;\n\t\tint ile = (newton(n, k) - newton(k-1, n-k)+mod)%mod;\n\t\tans = (ans + mnoz * 1LL * ile) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nconst int N=1000010;\nconst int MOD=1e9+7;\nint n;\nint fact[N],iact[N];\nint f[N];\nint fmi(int x,int y){\n\tint res=1;\n\tfor(;y;x=1ll*x*x%MOD,y>>=1)\n\t\tif(y&1)\n\t\t\tres=1ll*res*x%MOD;\n\treturn res;\n}\nvoid init(){\n\tfact[0]=fact[1]=1;\n\tfor(int i=2;i<=n;i++) fact[i]=1ll*fact[i-1]*i%MOD;\n\tiact[0]=iact[1]=1;\n\tiact[n]=fmi(fact[n],MOD-2);\n\tfor(int i=n-1;i>=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;\n}\ninline int C(int n,int m){\n\treturn m<=n?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;\n}\nvoid solve(){\n\tint ans=0,presum=0;\n\tfor(int k=(n+1)>>1;k<n;k++){\n\t\tint num=(1ll*C(k-1,n-1-k)*fact[k]%MOD*fact[n-1-k]%MOD-presum)%MOD;\n\t\t(ans+=1ll*num*k%MOD)%=MOD;\n\t\t(presum+=num)%=MOD;\n\t}\n\tprintf(\"%d\\n\",ans<0?ans+MOD:ans);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2000000000\n#define MOD 1000000007\n#define MAXN 200005\n#define REP(temp, init_val, end_val) for (int temp = init_val; temp <= end_val; ++temp)\n#define REPR(temp, init_val, end_val) for (int temp = init_val; temp >= end_val; --temp)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> intpair;\nint read(){\n    int f = 1, x = 0;\n    char c = getchar();\n    while (c < '0' || c > '9'){if(c == '-') f = -f; c = getchar();}\n    while (c >= '0' && c <= '9')x = x * 10 + c - '0', c = getchar();\n    return f * x; \n}\ninline int lowbit(int x){\n    return x & (-x);\n}\ninline int modadd(int x, int y){\n    return (x + y >= MOD ? x + y - MOD: x + y);\n}\ninline int sgn(int x){\n    return (x < 0 ? -1: (x > 0 ? 1: 0));\n}\ntemplate<typename T>\nT gcd(T a, T b){\n    return (!b) ? a: gcd(b, a % b);\n}\nint poww(int a, int b){\n    int res = 1;\n    while (b > 0){\n        if (b & 1) res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, b >>= 1;\n    }\n    return res;\n}\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int ddx[] = {-1, -1, -1, 0, 0, 1, 1, 1}, ddy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n/*--------------------------------------------------------------------*/\n/*--------------------------------------------------------------------*/\n\nint n;\nint fac[1000005], inv[1000005], invfac[1000005];\nint f[1000005] = {0};\nvoid init(){\n    n = read();\n    fac[0] = fac[1] = 1;\n    inv[1] = 1;\n    invfac[0] = invfac[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        fac[i] = 1ll * fac[i - 1] * i % MOD;\n        inv[i] = 1ll * (MOD - MOD / i) * inv[MOD % i] % MOD;\n        invfac[i] = 1ll * invfac[i - 1] * inv[i] % MOD;\n    }\n}\ninline int C(int nn, int mm){\n    return 1ll * fac[nn] * invfac[mm] % MOD * invfac[nn - mm] % MOD;\n}\nvoid solve(){\n    int hf = n >> 1;\n    for (int i = hf; i >= 1; --i)\n        f[i] = 1ll * C(n - i - 1, i - 1) * fac[n - i] % MOD, \n        f[i] = 1ll * f[i] * fac[i - 1] % MOD;\n    for (int i = 1; i < hf; ++i)\n        f[i] = modadd(f[i], MOD - f[i + 1]);\n    int ans = 0;\n    for (int i = 1; i <= hf; ++i)\n        ans = modadd(ans, 1ll * (n - i) * f[i] % MOD);\n    printf(\"%d\\n\", ans);\n}\nint main(){\n    int T = 1;\n    while (T--){\n        init();\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,C=0,ans=0,cnt=0;\n  cin>>N;\n  COMinit();\n  ans=(N-1)*fac[N-1]%MOD;\n  \n  for(ll i=4; i<=6; ++i){\n    cnt=0;\n    \n    for(ll j=0; j<=N/2; ++j){\n      C=0;\n      ll P=N-i-2*j;\n      if(P>=0 && P%3==0){\n        ll x=P/3;\n        C=COM(j+x,j)*fac[j+x+1];\n        C%=MOD;\n        C*=fac[N-2-j-x];\n        C%=MOD;\n      }\n      cnt+=C;\n      cnt%=MOD;\n    }\n    \n    if(i==5) cnt*=2;\n    ans=(ans-cnt)%MOD;\n  }\n  \n  ans%=MOD;\n  if(ans<0) ans+=MOD;\n  \n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG\n#include \"../../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = (ll)x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = (unsigned long long)x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n    // 平方剰余のうち一つを返す なければ-1\n    friend modint sqrt(modint a) {\n        if(a == 0) return 0;\n        ll q = MOD-1, s = 0;\n        while((q&1)==0) q>>=1, s++;\n        modint z=2;\n        while(1) {\n            if(z.pow((MOD-1)/2) == MOD-1) break;\n            z++;\n        }\n        modint c = z.pow(q), r = a.pow((q+1)/2), t = a.pow(q);\n        ll m = s;\n        while(t.x>1) {\n            modint tp=t;\n            ll k=-1;\n            FOR(i, 1, m) {\n                tp *= tp;\n                if(tp == 1) { k=i; break; }\n            }\n            if(k==-1) return -1;\n            modint cp=c;\n            REP(i, m-k-1) cp *= cp;\n            c = cp*cp, t = c*t, r = cp*r, m = k;\n        }\n        return r.x;\n    }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { \n        is >> a.x;\n        a.x = ((a.x%MOD)+MOD)%MOD;\n        return is;\n    }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<1000000007>;\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=2e6; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nint main(void) {\n    ll n;\n    cin >> n;\n\n    vector<mint> frac(n+1);\n    frac[0] = 1;\n    FOR(i, 1, n+1) frac[i] = frac[i-1] * i;\n\n    mint sum = 0, ans = 0;\n    vector<mint> dp(n+1);\n    FOR(i, 1, n) {\n        dp[i] = combi(i-1, n-1-i) * frac[i] * frac[n-1-i];\n        dp[i] -= sum;\n        ans += dp[i] * i;\n        sum += dp[i];\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\ntypedef double db;\nconst int N=1e6+5,mo=1e9+7;\nint fac[N],rev[N],i,cnt1,f[N],w[N],ans,n;\nint ksm(int x,int y)\n{\n\tif (y<0) y=1ll*(-y)*(mo-2)%(mo-1);\n\tint ret=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mo;\n\t\ty>>=1;\n\t\tx=1ll*x*x%mo;\n\t}\n\treturn ret;\n}\nint c(int m,int n)\n{\n\treturn 1ll*fac[m]*rev[n]%mo*rev[m-n]%mo;\n}\nvoid predo(int n)\n{\n\tfac[0]=1;\n\tfo(i,1,n) fac[i]=1ll*fac[i-1]*i%mo;\n\trev[n]=ksm(fac[n],mo-2);\n\tfd(i,n,1) rev[i-1]=1ll*rev[i]*i%mo;\n}\nint calc(int x)\n{\n\t//2*x-n+2=cnt1\n\tcnt1=2*x-n+2;\n\tif (cnt1>x||cnt1<0) return 0;\n\treturn c(x,cnt1);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tpredo(n);\n\tfo(i,0,n-2)\n\t{\n\t\tf[i]=1ll*c(n-2,i)*fac[i]%mo;\n\t\tw[i]=calc(i-1);\n\t\tf[i]=(f[i]+1ll*c(n-2,i-1)*fac[i]-1ll*w[i]*fac[i])%mo;\n\t\tif (!i) f[i]=1;\n\t\tans=(ans+1ll*f[i]*fac[n-1-i])%mo;\n\t}\n\tif (ans<0) ans+=mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int DIV=1000000000+7;\nlong myPow(long x, long n, long m){\n  if(n == 0)\n    return 1;\n  if(n % 2 == 0)\n    return myPow(x * x % m, n / 2, m);\n  else\n    return x * myPow(x, n - 1, m) % m;\n}\nlong fact(long i,long j){//i*i+1*....*i+j-1\n    if(j==0)\n        return 1;\n    else\n        return fact(i,j-1)*(i+j-1) % DIV;\n}\n\nint main(){\n    long N;\n    cin >> N;\n    \n    long m;\n    if(N%2==0)\n        m=N/2;\n        \n    else\n        m=(N-1)/2;\n    long A[m];\n//    long kaijo = fact(1,N-m-1);\n    A[0] = fact(1,N-1);\n//    A[m-1] = kaijo*kaijo*(N-m);\n    for(long i=1;i<m;i++){\n     //   A[i] = A[i-1];\n     //   A[i] /= (N-i)*(N-i-1);\n     //   A[i] *=  (N-i-i)*(N-i-i-1);\n    A[i]=fact(1,N-i-1)*fact(N-i-i-1,i);\n//        cout<<\"Ai:\"<<A[i]<<endl;\n    }\n    long ret;\n    for(int i=0;i<m;i++){\n        A[i] %= DIV;\n    }\n    ret = A[0] * (N-1);\n    for(int i=1;i<m;i++){\n        ret -= A[i];\n//        cout<<\"i:\"<<i<<endl;\n    }\n    ret %= DIV;\n    cout << ret << endl;\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int maxn = 1000005;\nint fac[maxn], rev[maxn];\nint n, ans, res;\n\ninline int power(int x, int p) {\n\tint res = 1;\n\twhile (p) {\n\t\tif (p&1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD; p >>= 1;\n\t}\n\treturn res;\n}\n\ninline int C(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn 1LL * fac[n] * rev[m] % MOD * rev[n-m] % MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n); n--;\n\tfac[0] = rev[0] = 1;\n\trep (i, 1, maxn-1) {\n\t\tfac[i] = 1LL * fac[i-1] * i % MOD;\n\t\trev[i] = power(fac[i], MOD - 2);\n\t}\n\tans = 1LL * n * fac[n] % MOD;\n\trep (i, 0, n-3) if (i <= n-2-i-1) {\n\t\tres = (res + 1LL * C(n-2-i-1, i) * (n-2-i) % MOD * fac[n-i-1] % MOD * fac[i]) % MOD;\n\t\t// printf(\"%d\\n\", res);\n\t}\n\tans = (ans + MOD - res) % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst int N=1000005;\nconst int MOD=1e9+7;\nint add (int x,int y)   {x=x+y;return x>=MOD?x-MOD:x;}\nint mul (int x,int y)   {return (LL)x*y%MOD;}\nint dec (int x,int y)   {x=x-y;return x<0?x+MOD:x;}\nint Pow (int x,int y)\n{\n\tif (y==0) return 1;\n\tif (y==1) return x;\n\tint lalal=Pow(x,y>>1);\n\tlalal=mul(lalal,lalal);\n\tif (y&1) lalal=mul(lalal,x);\n\treturn lalal;\n}\nint n;\nint JC[N],inv[N];\nvoid Init (int n)\n{\n\tJC[0]=1;for (int u=1;u<=n;u++) JC[u]=mul(JC[u-1],u);\n\tinv[n]=Pow(JC[n],MOD-2);\n\tfor (int u=n-1;u>=0;u--) inv[u]=mul(inv[u+1],u+1);\n}\nint C (int x,int y)\t{return mul(JC[x],mul(inv[y],inv[x-y]));}\nint f[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tInit(n);\n\tint ans=0;\n\tfor (int u=(n+1)/2;u<n;u++)\n\t{\n\t\tf[u]=mul(mul(C(u-1,n-u-1),JC[u]),JC[n-1-u]);\n\t\tans=ans+mul(u,dec(f[u],f[u-1]));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <int MD>\nstruct ModInt {\n    typedef ModInt M;\n    int v;\n    ModInt(int _v = 0) : v(_v) {}\n    M& operator += (const M &r) {\n        if ((v += r.v) >= MD) v -= MD;\n        return *this;\n    }\n    M& operator -= (const M &r) {\n        if ((v -= r.v) < 0) v += MD;\n        return *this;\n    }\n    M& operator *= (const M &r) {\n        v = ll(v) * r.v % MD;\n        return *this;\n    }\n    M operator + (const M &r) const { return M(*this) += r; }\n    M operator - (const M &r) const { return M(*this) -= r; }\n    M operator * (const M &r) const { return M(*this) *= r; }\n    M pow(int n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n};\ntypedef ModInt<1000000007> Mint;\n\nconst int MN = 1000010;\nint N;\nMint fac[MN], ifac[MN];\nMint f[MN];\n\nvoid first() {\n    fac[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        fac[i] = Mint(i) * fac[i - 1];\n    }\n    ifac[MN - 1] = fac[MN - 1].pow(1000000005);\n    for (int i = MN - 2; i >= 0; i--) {\n        ifac[i] = ifac[i + 1] * Mint(i + 1);\n    }\n}\n\nMint C(int n, int k) {\n    if (n < 0 || k < 0 || n < k) return Mint(0);\n    return fac[n] * ifac[k] * ifac[n - k];\n}\n\nMint g(int k) {\n    return C(k - 1, N - k - 1) * fac[k] * fac[N - 1 - k];\n}\n\nint main() {\n    first();\n    cin >> N;\n    Mint ans = 0;\n    for (int k = 1; k < N; k++) {\n        ans += (g(k) - g(k - 1)) * k;\n    }\n    cout << ans.v << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 21;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 62;\n\nll factorial(ll n,ll mod = mod){\n  static ll dp[e5];\n  if(dp[n]) return dp[n];\n  if(n == 0) return dp[n] = 1;\n  return dp[n] = (n*factorial(n-1))%mod;\n}\n\nll powl(ll x,ll r,ll mod = mod){\n  ll ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nll inverse(ll x,ll mod = mod){\n  return powl(x,mod-2,mod);\n}\n\nll combination(ll n,ll m,ll mod = mod){\n  if(n < m) return 0;\n  return (((factorial(n)*inverse(factorial(m)))%mod)*inverse(factorial(n-m)))%mod;\n}\n\n\nll n;\nll ans = 0;\n\nll solve(ll k){\n  return (((combination(k-1,n-1-k)*factorial(k))%mod)*factorial(n-1-k))%mod;\n}\n\n\nint main(){\n  cin >> n;\n  if(n == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  for(ll i = 2;i <= n-1;i++){\n    ans += ((((solve(i)-solve(i-1)+mod)%mod)*i)%mod);\n    ans %= mod;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\nll f[100100];\n\nvoid calc() {\n    f[0] = 1;\n    for(ll i = 1; i < 100100; i++) {\n        f[i] = f[i - 1] * i;\n        f[i] %= mod;\n    }\n}\n\nll pow_mod(ll a, ll b, ll m){\n    ll ret = 1;\n    while (b > 0) {\n        if (b & 1) {\n            ret = ret * a % m;\n        }\n        a = a * a % m;\n        b >>= 1;\n    }\n    return ret;\n}\n\nll inv_mod(ll a, ll m){\n    return pow_mod(a, m - 2, m);\n}\n\nll comb(ll n, ll r) {\n    ll ret = f[n];\n    (ret *= inv_mod(f[r], mod)) %= mod;\n    (ret *= inv_mod(f[n - r], mod)) %= mod;\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    calc();\n    ll N;\n    cin >> N;\n    ll cur = 0;\n    ll ret = 0;\n    for(ll score = (N + 1) / 2; score <= N - 1; score++) {\n        ll ttmp = comb(score - 1, N - score - 1);\n        (ttmp *= f[N - 1 - score]) %= mod;\n        (ttmp *= f[score]) %= mod;\n        ll tmp = (ttmp - cur) % mod;\n        cur = comb(score - 1, N - score - 1) * f[N - 1 - score] % mod;\n        (cur *= f[score]) %= mod;\n        (tmp *= score) %= mod;\n        (tmp += mod) %= mod;\n//        cout << score << \":\" << tmp << \",\" << cur << endl;\n        (ret += tmp) %= mod;\n    }\n    output(ret);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/rope>\n//using namespace __gnu_pbds;\n//using namespace __gnu_cxx;\n//\n//template<class T> using Tree = tree<T, null_type, less<T>, rb_t_tag,t_order_statistics_node_update>;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n//const long long mod = 998244353;\n\n// watch this\n//using ll = long long;\n//typedef long long LL;\n#define ll long long\n#undef ll\n\nconst int mxN = 2000010;\n\nlong long pow_mod(long long base, long long power) {\n\tlong long res = 1;\n\twhile (power) {\n\t\tif (power & 1)\n\t\t\tres = res * base % mod;\n\t\tbase = base * base % mod;\n\t\tpower >>= 1;\n\t}\n\treturn res;\n}\n\nlong long fact[mxN], inv[mxN];\n\nvoid init() {\n\tfact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i < mxN; i++)\n\t\tfact[i] = i * fact[i - 1] % mod, inv[i] = pow_mod(fact[i], mod - 2);\n}\n\nlong long NcR(long long N, long long R) {\n\tif (N < R || R < 0)\n\t\treturn 0;\n\treturn (fact[N] * inv[R] % mod) * inv[N - R] % mod;\n}\n\nint main(int argc, char** argv) {\n#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n#endif\n\n\tinit();\n\n\tint N;\n\tcin >> N;\n\tlong long res = 0;\n\tlong long sum = 0;\n\tfor (int i = 1; i < N; i++) {\n\t\tlong long cur = (NcR(i - 1, N - i - 1) * fact[i] % mod)\n\t\t\t\t* fact[N - 1 - i] % mod;\n\t\tcur += mod - sum;\n\t\tif (cur >= mod)\n\t\t\tcur -= mod;\n\t\tsum += cur;\n\t\tif (sum >= mod)\n\t\t\tsum -= mod;\n\t\tres = (res + i * cur) % mod;\n//\t\tcerr << res << '\\n';\n\t}\n\tcout << res << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300 * 1000 + 17;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\nint n;\nlong long a[N], r[N], F[N], rF[N];\n\nbool read() {\n    if (!(cin >> n))\n        return false;\n\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n\n    return true;\n}\n\nvoid solve() {\n    F[0] = rF[0] = F[1] = rF[1] = r[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        r[i] = (MOD - (MOD / i) * r[MOD % i] % MOD) % MOD;\n        F[i] = i * F[i - 1] % MOD;\n        rF[i] = r[i] * rF[i - 1] % MOD;\n    }\n\n    auto ans = 0ll;\n\n    for (int k = (n + 1) / 2; k < n; ++k)\n        ans += F[k] * F[k - 1] % MOD * rF[2 * k - n] % MOD;\n\n    cout << (MOD + F[n] - ans % MOD) % MOD << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define modp 1000000007\n#define Maxn 2000007\nusing namespace std;\nint pre[Maxn],inv[Maxn];\nint n;\nint power(int a,int b)\n{\n\tint res=1,now=a,left=b;\n\twhile (left>0)\n\t{\n\t\tif (left%2==1) res=(1LL*res*now)%modp;\n\t\tleft/=2;\n\t\tnow=(1LL*now*now)%modp;\n\t}\n\treturn res;\n}\nint calc(int x,int y)\n{\n\tif (y<0||y>x) return 0;\n\tif (y==0||y==x) return 1;\n\tint res=(1LL*pre[x]*inv[y])%modp;\n\treturn (1LL*res*inv[x-y])%modp;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tpre[0]=1;\n\tfor (int i=1;i<=2000000;i++)\n\t\tpre[i]=(1LL*i*pre[i-1])%modp;\n\tinv[2000000]=power(pre[2000000],modp-2);\n\tfor (int i=2000000;i;i--)\n\t\tinv[i-1]=(1LL*i*inv[i])%modp;\n\tint ans=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint del=(1LL*pre[i]*pre[n-1-i])%modp;\n\t\tdel=(1LL*del*calc(i-1,n-1-i))%modp;\n\t\tans=(ans+del)%modp;\n\t}\n\tans=(pre[n]-ans+modp)%modp;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n参考にした提出\nhttps://agc023.contest.atcoder.jp/submissions/2435072\n\n*/\n\n\n#include<cstddef>\n#include<cstdint>\n#include<cstdio>\n\nusing uint64 = std::uint_fast64_t;\n\nconstexpr uint64 M = 1000000007;\n\ntemplate<std::size_t N>\nstruct Fact {\n\tuint64 val[N], v2[N];\n\tconstexpr Fact() :val(), v2() {\n\t\tval[0] = 1;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i - 1] * i % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) v2[i] = val[i - 1] * val[i] % M;\n\t\tfor (std::size_t i = 1; i < N; ++i) val[i] = val[i] * i % M;\n\t}\n};\n\ntemplate<std::size_t N, uint64 F>\nstruct IFact {\n\tuint64 val[N];\n\tconstexpr IFact() : val() {\n\t\tval[N - 1] = F;\n\t\tfor (std::size_t i = N - 1; i; --i) val[i - 1] = val[i] * i % M;\n\t}\n};\n\nint main() {\nconstexpr auto fact = Fact<1000000>();\nconstexpr auto ifact = IFact<1000000, 498215386>();\n\tunsigned int n;\n\tuint64 ans=0;\n\tscanf(\"%u\", &n);\n\tconst std::size_t N = n;\n\tfor (std::size_t i = (N + 1) >> 1; i < N - 1; ++i) {\n\t\tans += fact.v2[i] * ifact.val[(i << 1) - N] % M;\n\t}\n\tans %= M;\n\tlong long unsigned int o = fact.val[N - 1] < ans ? fact.val[N - 1] + M - ans : fact.val[N - 1] - ans;\n\tprintf(\"%llu\\n\", o);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\nT pow(T x, T n, T mod) {\n    T ret = 1;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <class T>\nT inverse(T x, T p) { return pow(x, p - 2, p); }\n\nint main() {\n    long long n, ret = 0;\n    const auto mod = 1000000007ll;\n    std::cin >> n;\n    std::vector<long long> fact(n + 1), inv(n + 1);\n    fact[0] = 1;\n    for (auto i = 1ll; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    inv[n] = inverse(fact[n], mod);\n    for (auto i = n; i > 0; i--) inv[i - 1] = inv[i] * i % mod;\n    auto pre = 0ll;\n    for (auto i = (n + 1) / 2; i < n; i++) {\n        auto t = fact[i - 1] * inv[n - 1 - i] % mod * inv[2 * i - n] % mod * fact[i] % mod * fact[n - 1 - i] % mod;\n        ret = (ret + (t - pre + mod) % mod * i) % mod;\n        pre = t;\n    }\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(ll i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 1e6;\nconst ll MOD = 1e9+7;\n\nll N;\n\n//階乗とその逆元\nll fac[MAX+1],facInv[MAX+1];\n\nll power(ll e, ll x){ //e^x % MOD\n\tif (x == 0) return 1LL;\n\tif (x % 2 != 0) return ((power(e, x-1) * e) % MOD);\n\tll temp = power(e, x / 2);\n\treturn (temp * temp) % MOD;\n}\n\nll nck(ll n, ll k){\n\tif (!(n >= k && k >= 0)) return 0;\n\tll temp = (fac[n] * facInv[n-k]) % MOD;\n\treturn ((temp * facInv[k]) % MOD);\n}\n\nvoid fact(void){\n\t//階乗とその逆元\n\tfac[0] = facInv[0] = 1; //0! = 1\n\t//(x!)^(-1) ≡ (x!)^(p-2) (mod p)\n\tRep(1, MAX, i) fac[i] = (fac[i-1] * i) % MOD;\n\tfacInv[MAX] = power(fac[MAX], MOD-2);\n\tRep(1, MAX-1, i) facInv[MAX-i] = (facInv[MAX-i+1] * (MAX-i+1)) % MOD;\n}\n\nll calc(ll k) {\n\tll a = 2*k - N, b = N - k - 1LL;\n\treturn (nck(a+b, b)*fac[k]%MOD)*fac[N-k-1LL]%MOD;\n}\n\nvoid solve(void){\n\tcin >> N;\n\tfact();\n\tvector <ll> res(N);\n\trep(N, i) res[i] = calc(i);\n\tll ans = 0LL;\n\tRep(1, N-1, i) {\n\t\tans += i*(res[i]-res[i-1]);\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint f[1111111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tinit(1111111);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tf[i] = choose(i-1,n-i-1);\n\t\t//if(i>=n/2) cerr<<i<<' '<<f[i]<<'\\n';\n\t}\n\tint ans = 0; int pre = 0;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint res = 0;\n\t\tres = add(mult(f[i], mult(fact[i], fact[n-1-i])), MOD - pre);\n\t\t//cerr<<res<<' '<<pre<<'\\n';\n\t\tpre = add(pre, res);\n\t\tans=add(ans,mult(res,i));\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//---------------------------\nusing namespace std;\n//---------------------------\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define P(x) cout << (x) << \"\\n\"\n\n#define MOD 1000000007 // 1e9+7\n#define PI 3.1415926525\n#define ll long long int // 10^18\n#define INF 1000000001 // 1e9+1\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n//---------------------------\nll n;\nll a[1000005];\nll factt[1234567];\nll ff[1000000];\n\nll calc(ll a,ll b,ll p){\n  if(b==0){\n    return 1;\n  }else if(b%2==0){\n    ll d=calc(a,b/2,p);\n    return (d*d)%p;\n  }else if(b%2==1){\n    return (a*calc(a,b-1,p))%p;\n  }\n}\nll inv(ll y){\n  return calc(y, MOD-2, MOD);\n}\n\nll comb(ll a,ll b){\n  if(a<b)return 0;\n  ll ans=(factt[a]*inv(factt[b]))%MOD;\n  ans*=inv(factt[a-b])%MOD;\n  return ans%MOD;\n}\n\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  // ifstream in(\"input.txt\");\n  // cin.rdbuf(in.rdbuf());\n\n  cin>>n;\n  if(n==2){\n    P(1);\n    return 0;\n  }else if(n==3){\n    P(4);\n    return 0;\n  }\n  REP(i,1000000){\n    if(i==0)factt[i]=1;\n    else factt[i]=(i*factt[i-1])%MOD;\n  }\n  // REP(i,100)P(factt[i]);\n  REP(i,1000000){\n    ff[i]=(comb(i-1,n-i-1)*factt[i])%MOD;\n    ff[i]*=factt[n-i-1];\n    ff[i]%=MOD;\n  }\n  ll ans=0;\n  for(int i=(n-1)/2;i<=n-1;i++){\n    ans+=(ff[i]-ff[i-1])*i;\n    ans%=MOD;\n  }\n  P(ans%MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 1000000\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nint main(){\n\tinit();\n\tint n;\n\tcin>>n;\n\tvi po(n+1,1);\n\trep(i,n)po[i+1]=po[i]*(i+1)%MOD;\n\tll out=0;\n\tll sum=0;\n\tloop(i,1,n){\n\t\t(out+=i*(po[i]*po[n-1-i]%MOD*nCr(i-1,n-1-i)%MOD+MOD-sum)%MOD)%=MOD;\n\t\tsum=po[i]%MOD*po[n-1-i]%MOD*nCr(i-1,n-1-i)%MOD;\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<(int)n;i++)\n#define REP(i,n)\tfor(int i=0;i<=(int)n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<(int)n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=(int)n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\n#define fst\tfirst\n#define scn second\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrt(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a%b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nll fact[1000010];\nll inv[1000010];\nll dp[1000010];\n\nll modpow(ll a, ll b) {\n\tll ret = 1;\n\twhile (b) {\n\t\tif (b & 1)\tret = (ret*a) % mod;\n\t\ta = (a*a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nll nCm(ll n, ll m) {\n\treturn fact[n] * ((inv[m] * inv[n - m]) % mod) % mod;\n}\n\nint main() {\n\tint n;\tcin >> n;\n\tif (n == 2) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\telse if (n == 3) {\n\t\tcout << 4 << endl;\n\t\treturn 0;\n\t}\n\tfact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tSREP(i, 2, n) {\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t\tinv[i] = (inv[i - 1] * modpow(i, mod - 2)) % mod;\n\t}\n\tll ret = 0;\n\tsrep(i, 2, n) {\n\t\tif (i * 2 < n)\tcontinue;\n\t\tdp[i] = ((nCm(i - 1, n - i - 1)*fact[i]) % mod)*fact[n - i - 1] % mod;\n\t\t(ret += ((dp[i] - dp[i - 1] + mod) % mod)*i) %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(){\n  int N;\n  scanf(\"%d\", &N);\n  printf(\"たっくさーん!!\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(ll i=0;i<n;i++)\n#define repp(j, n) for(ll j=0;j<n;j++)\n#define reppp(i, m, n) for(ll i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 1e-10;\n\nll comb(ll fact[], ll rfact[], ll n, ll r){\n    return (((fact[n] * rfact[r]) % MOD) * rfact[n-r]) % MOD;\n}\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    ll n;\n    cin >> n;\n    \n    ll fact[n+1], rfact[n+1];\n    fact[0] = fact[1] = 1LL;\n    rfact[0] = rfact[1] = 1LL;\n    reppp(i, 2, n+1){\n        fact[i] = (fact[i-1] * (ll)i) % MOD;\n        rfact[i] = 1LL;\n        ll k = MOD-2LL;\n        ll a = fact[i];\n        while(k > 0LL){\n            if(k & 1LL){\n                rfact[i] *= a;\n                rfact[i] %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            k  >>= 1;\n        }\n    }\n\n    ll ans = 0LL, p_prev = 0LL;\n    rep(n){\n        if(i-1 < n-1-i) continue;\n        ll p = (((comb(fact, rfact, i-1, n-1-i) * fact[i]) % MOD) * fact[n-1-i]) % MOD;\n        ans = (ans + (i * (p - p_prev)) % MOD) % MOD;\n        p_prev = p;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nconst int p=1e9+7;\nint n,fac[N],inv[N];\ninline int pw(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=1ll*ans*x%p;\n\t\tx=1ll*x*x%p; y>>=1;\n\t}\n\treturn ans;\n}\ninline int C(int n,int m){\n\tif(m<0||m>n)return 0;\n\treturn 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nint main(){\n\tfac[0]=inv[0]=1; for(int i=1; i<N; ++i)fac[i]=1ll*fac[i-1]*i%p,inv[i]=pw(fac[i],p-2);\n\tscanf(\"%d\",&n);\n\tint ans=0;\n\tfor(int i=n-2; i>=0; --i){\n\t\tint tmp=(C(n-2,i)+C(n-2,i-1)-C(i-1,2*i-n))%p;\n\t\ttmp=1ll*tmp*fac[i]%p*fac[n-i-1]%p;\n\t\tif(!i)tmp=fac[n-i-1];\n\t\tans=(ans+tmp)%p;\n\t}\n\tprintf(\"%d\",(ans+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing\tnamespace\tstd;\n#define ll long long\n#define\tllu\tunsigned\tlong\tlong\n#define\tld\tdouble\n#define\tllu\tunsigned\tlong\tlong\n#define\trep(i,x,y)\t\tfor(ll\ti=x;i<y;++i)\n#define\tFor(i,x,y)\t\tfor(ll\ti=x;i<=y;++i)\n#define\tFOr(i,x,y)\t\tfor(ll\ti=(ll)(x);i>=(ll)(y);--i)\n#define\tpi\tacos(-1)\t\n#define\tmk\tmake_pair\n#define\tpa\tpair<ll,ll>\n#define\tlf\telse\tif\n#define\tIL\tinline\n#define\tmax(x,y)\t\t\t\t((x)<(y)?(y):(x))\n#define\tmin(x,y)\t\t\t\t((x)<(y)?(x):(y))\n#define\tsqr(x)\t\t\t\t\t\t((x)*(x))\n#define\tMul(x,y)\t\t\t\t((x)=1LL*(x)*(y)%mod)\n#define\tAdd(x,y)\t\t\t\t((x)=((x)+(y))%mod)\n#define\tMax(x,y)\t\t\t\t((x)=((x)<(y)?(y):(x)))\n#define\tMin(x,y)\t\t\t\t((x)=((x)>(y)?(y):(x)))\n#define\tE(x)\t\t\t\t\treturn\twriteln(x),0\n#define\tLL\t\t\t\t\t\t(long\tlong)\n#define\tp(x)\t\t\t\t\tprllf(\"~%lld~\\n\",LL(x))\n#define\tpp(x,y)\t\t\t\t\tprllf(\"~~%lld\t%lld~~\\n\",LL(x),LL(y))\n#define\tppp(x,y,z)\t\t\t\tprllf(\"~~~%lld\t%lld\t%lld~~~\\n\",LL(x),LL(y),LL(z))\n#define\tpppp(a,b,c,d)\t\t\tprllf(\"~~~%lld\t%lld\t%lld\t%lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define\tf_in(x)\t\t\t\t\tfreopen(x\".in\",\"r\",stdin)\n#define\tf_out(x)\t\t\t\tfreopen(x\".out\",\"w\",stdout)\n#define\topen(x)\t\t\t\t\tf_in(x),f_out(x)\n#define\tfi\tfirst\n#define\tse\tsecond\n#define\tGuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef\tcomplex<double>\tE;\nnamespace\tSHENZHEBEI{\n#ifdef\tLOCAL\n\t\t\t\tstruct\t_{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif\t\n#define\tNEG\t1\n\t\t\t\tinline\tchar\tgc(){\treturn\tgetchar();\t}\n#if\tNEG\n\t\t\t\tinline\tll\tread(){\t\t\t\tll\tx=0,fa=1;\tchar\tch=gc();\t\t\tfor\t(;!isdigit(ch);ch=gc())\tif\t(ch=='-')\tfa=-1;\t\tfor\t(;isdigit(ch);ch=gc())\t\tx=x*10-48+ch;\t\t\treturn\tx*fa;\t}\n\t\t\t\tinline\tvoid\twrite(ll\tx){\t\t\t\tif\t(x<0)\tputchar('-'),x=-x;\t\tif\t(x>=10)\t\t\twrite(x/10);\t\t\t\tputchar(x%10+'0');\t\t}\n#else\n\t\t\t\tinline\tll\tread(){\t\t\t\tll\tx=0;\tchar\tch=gc();\t\t\tfor\t(;!isdigit(ch);ch=gc());\t\t\t\tfor\t(;isdigit(ch);ch=gc())\t\tx=x*10-48+ch;\t\t\treturn\tx;\t\t\t}\n\t\t\t\tinline\tvoid\twrite(ll\tx){\t\t\t\tif\t(x>=10)\t\t\twrite(x/10);\t\t\t\tputchar(x%10+'0');\t\t}\n#endif\n\tvoid\twriteln(ll\tx){write(x);puts(\"\");}\n}using\tnamespace\tSHENZHEBEI;\nconst ll mod=1e9+7,N=1000010;\nll f[N],ans=0,n,fac[N],inv[N],chos[N],before;\nll ppow(ll x,ll k){ll ans=1;for(;k;k>>=1,Mul(x,x))if(k&1)Mul(ans,x);return ans;}\nll C(ll n,ll k){return (n>=k)?(fac[n]*inv[k]%mod*inv[n-k]%mod):0ll;}\nint main(){\n\tn=read();\n\tfac[0]=1;For(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tinv[n]=ppow(fac[n],mod-2);FOr(i,n,1)inv[i-1]=inv[i]*i%mod;\n\tFor(i,0,n)\tf[i]=C(n-i-2,i)*fac[n-i-1]%mod;\n\tFor(i,0,n)\tf[i]=f[i]-f[i+1];\n\tFor(i,0,n)\tAdd(ans,(n-i-1)*f[i]);\n\twriteln(ans);\n}\n/*\nooooo\noo**o**\nsimga\nn/p>=i*i\nn/(i*i)>=p\nsigma(i=1..sqrt(n),i是质数)\tmin(n/i*i,sqrt(n))\n\n去掉3个合法-> \nOO**OO\n*/"
  },
  {
    "language": "C++",
    "code": "/**\nSXR0aXAkI0JwbXptI3FhI3Z3I293bCNqY2IjUG0jMCNicG0jVHFkcXZvLyNCcG0jQW10bjBhY2phcWFicXZvLyNNYm16dml0MSNWdyNhdGN1am16I2tpdiNhbXF9bSNQcXUjVnd6I0F0bW14MSNQcWEjaXptI2l0dCNicHF2b2EjUXYjYnBtI3BtaWRtdmEjaXZsI3d2I21pemJwMSNFcHcjcWEjYnBtem0ja2l2I3F2Ym16a21sbSNRdiNQcWEjeHptYW12a20jbXtrbXhiI0lhI3BtI3htenVxYmJtYnBHI1BtI3N2d2VtYnAjRXBpYiMraXh4bWl6bWJwI2J3I1BxYSNrem1pYmN6bWEjSWEsI0ptbnd6bSN3eiNJbmJteiN3eiNKbXBxdmwjYnBtdTEjVnd6I2FwaXR0I2JwbXwja3d1eGlhYSNJY29wYiN3biNwcWEjc3Z3ZXRtbG9tI017a214YiNpYSNQbSNlcXR0bWJwMSNQcWEjYnB6d3ZtI2x3YnAjbXtibXZsI1dkbXojYnBtI3BtaWRtdmEjSXZsI3d2I21pemJwLyNpdmwjUG0jbm1tdG1icCNWdyNuaWJxb2NtI3F2I29jaXpscXZvI0l2bCN4em1hbXpkcXZvI2JwbXUvI053eiNQbSNxYSNicG0jVXdhYiNQcW9wMSNCcG0jQWN4em11bSMrcXYjb3R3enwsMQ==\n*/\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\n#define F first\n#define S second\n#define endl '\\n'\n#define deb(x) cout<<#x<<' '<<x<<endl;\n#define pb push_back\n\n\n#ifdef IZI_KATKA\n#define int __int64_t\n#else\n#define int __int64_t\n#endif\n\nconst long long MOD = 1e9 + 7;\nconst long long MAXN = 1e6 + 1;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n\nlong long readInt() {\n    bool minus1 = false;\n    long long result = 0;\n    char ch;\n    ch = getchar();\n    while (true) {\n        if (ch == '-') break;\n        if (ch >= '0' && ch <= '9') break;\n        ch = getchar();\n    }\n    if (ch == '-') minus1 = true; else result = ch-'0';\n    while (true) {\n        ch = getchar();\n        if (ch < '0' || ch > '9') break;\n        result = result*10 + (ch - '0');\n    }\n    if (minus1)\n        return -result;\n    else\n        return result;\n}\n\n\nint binpow(int a, int n) {\n\tif (n == 1){ \n\t\treturn a;\n\t}\n\tif (n % 2 == 0) {\n\t\tint x = binpow(a, n / 2);\n\t\treturn (x * x) % MOD;\n\t}\n\treturn (a * binpow(a, n - 1)) % MOD;\n}\n\nint fact[MAXN];\n\n\n\nint C(int n, int k) {\n\tif (k > n) return 0;\n\tint res = fact[n - k] * fact[k]  % MOD;\n\treturn fact[n] * binpow(res, MOD - 2) % MOD;\n}\n\nmain() {\n\t#ifdef IZI_KATKA\n\tassert(freopen(\"input\", \"r\", stdin));\n    assert(freopen(\"output\", \"w\", stdout));\n    #endif\n    int n = readInt();\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n\t\tfact[i] = fact[i - 1] * i;\n\t\tfact[i] %= MOD;    \n    }\n    int ans = fact[n];\n    for (int i = 1; i < n; i++) {\n\t\tans -= (fact[i] * fact[n - i - 1]) % MOD * C(i - 1, n - i - 1);\n    \tif (ans < 0)\n    \tans+= MOD;\n    }\n    cout << (ans+MOD)%MOD;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\n#define PROBLEM_NAME \"c\"\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) (debug(x, #x))\n#define C(x...) CHECK(x)\n#else\n#define L(x, ...) (x)\n#define C(x, ...) ;\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ii = pair<int,int>; using vii = vector<ii>;\nusing l = long long; using vl = vector<l>; using vvl = vector<vl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = acos(-1);\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n\nl const MOD = e9 + 7;\n\nl brute(l n) {\n  vl v(n - 1);\n  iota(all(v), 0);\n  l z = 0;\n  do {\n    l m = 0;\n    l s = 0;\n    for (auto x : v) {\n      s++;\n      m = (m | (3 << x));\n      if (m == (l(1) << n) - 1) break;\n    }\n    z += s;\n  } while (next_permutation(all(v)));\n  return z;\n}\n\nl sign(l n) {\n  if (n < 0) return -1;\n  if (n == 0) return 0;\n  return 1;\n}\n\n// conruent modulo, works for negative\nl cong(l x, l mod) {\n  return (x % mod + mod) % mod;\n}\n\n// (a * b) % mod, safe for l near max\nl mult_mod(l a, l b, l mod) {\n  l x = 0;\n  while (b) {\n    if (b % 2) x = (x + a) % mod;\n    a = (a * 2) % mod;\n    b /= 2;\n  }\n  return x;\n}\n\n// (base^power) % mod, safe for l near max\nl pow_mod(l base, l power, l mod) {\n  l r = 1;\n  while (power) {\n    if (power % 2) r = mult_mod(r, base, mod);\n    base = mult_mod(base, base, mod);\n    power /= 2;\n  }\n  return r;\n}\n\nl divup(l a, l b) { // ceil div\n  return (a + b - 1) / b;\n}\n\n// return gcd(a, b) and set x, y: a * x + b * y = gcd(a, b)\nl extended_euclid(l a, l b, l& x, l& y) {\n  if (b == 0) { x = 1; y = 0; return a; }\n  l d = extended_euclid(b, a % b, x, y);\n  l t = y;\n  y = x - (a / b) * y;\n  x = t;\n  return d;\n}\n\n// return b: a * b = 1 (mod n)\nl inverse_mod(l a, l n) {\n  l x, y;\n  l d = extended_euclid(a, n, x, y);\n  if (d != 1) return 0;\n  return cong(x, n);\n}\n\n// single combintions k from n\nl nCr(l n, l k, l mod) {\n  l a = 1;\n  for (l i = n; i > n - k; i--) a = mult_mod(a, i, mod);\n  l b = 1;\n  F(i, 1, k + 1) b = mult_mod(b, i, mod);\n  b = inverse_mod(b, mod);\n  return mult_mod(a, b, mod);\n}\n\n// precompute all combinations up to (n n)\nvvl combinations(l n, l mod) {\n  vvl c(n + 1, vl(n + 1));\n  F(i, 0, n + 1) {\n    c[i][0] = 1;\n    F(j, 1, i + 1) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n  }\n  return c;\n}\n\n// l on the ring of MOD, put l arg to the right: lm = lm + l\nstruct lm {\n  l raw;\n  lm(): raw(0) {}\n  lm(l x): raw(x) {}\n  lm(lm const& x): raw(x.raw) {}\n  lm(lm&& x) { swap(*this, x); }\n  friend void swap(lm& a, lm& b) { swap(a.raw, b.raw); }\n  lm& operator = (l x) { raw = x; return *this; }\n  lm& operator = (lm x) { swap(*this, x); return *this; }\n  void operator += (const lm x) { raw = cong(raw + x.raw, MOD); }\n  lm operator + (const lm x) { lm z(*this); z += x; return z; }\n  void operator -= (const lm x) { raw = cong(raw - x.raw, MOD); }\n  lm operator - (const lm x) { lm z(*this); z -= x; return z; }\n  void operator *= (const lm x) { raw = cong(raw * x.raw, MOD); }\n  lm operator * (const lm x) { lm z(*this); z *= x; return z; }\n  void operator /= (const lm x) { raw = cong(raw * inverse_mod(x.raw, MOD), MOD); }\n  lm operator / (const lm x) { lm z(*this); z /= x; return z; }\n};\nusing vlm = vector<lm>;\n\nl fast(l n) {\n  vlm f(n), g(n);\n  f[0] = 1;\n  F(i, 1, n) f[i] = f[i - 1] * i;\n  F(i, 0, n) g[i] = lm(1) / f[i];\n  lm z = 0;\n  lm s = 0;\n  F(k, (n + 1) / 2, n) {\n    lm t = f[k] * f[k - 1] * g[2 * k - n];\n    z += (t - s) * k;\n    swap(s, t);\n  }\n  return z.raw;\n}\n\nvoid solve(istream& cin, ostream& cout) {\n  // F(i, 2, 8) L(i, brute(i), fast(i));\n  l n; cin >> n;\n  cout << fast(n) << lf;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\nconst int maxn = 1e6 + 10;\nLL fac[maxn], inv_fac[maxn], num[maxn];\n\nLL qpow(LL a, LL b) {\n    LL ret = 1LL;\n    while (b) {\n        if (b & 1) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nLL inv(LL x) {\n    return qpow(x, mod - 2);\n}\n\nLL C(int n, int m) {\n    return fac[n] * inv_fac[m] % mod * inv_fac[n - m] % mod;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    if(N == 2) {puts(\"1\"); return 0;}\n    fac[0] = 1;\n    for (int i = 1; i <= N; ++i) fac[i] = fac[i - 1] * i % mod;\n    inv_fac[N] = inv(fac[N]);\n    for (int i = N - 1; i >= 0; --i) inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;\n    for (int i = (N + 1) / 2; i <= N - 1; ++i)\n        num[i] = C(i - 1, N - 1 - i) * fac[i] % mod * fac[N - 1 - i] % mod;\n    LL ans = 0;\n    for (int i = N - 1; i >= (N + 1) / 2; i--) {\n        num[i] = (num[i] - num[i - 1] + mod) % mod;\n        ans = (ans + num[i] * i) % mod;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <utility>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\n#define init() ios::sync_with_stdio(false); cin.tie();\n#define for0(i, n) for (int i=0; i<n; i++)\n#define for1(i, n) for (int i=1; i<=n; i++)\n#define for2(i, a, b) for (int i=a; i<=b; i++)\n#define bac0(i, n) for (int i=n-1; i>=0; i--)\n#define bac1(i, n) for (int i=n; i>0; i--)\n#define bac2(i, a, b) for (int i=a; i>=b; i--)\n#define PB push_back\n#define MOD 1000000009\n#define S second\n#define F first\n#define B 99997LL\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, char> ic;\n\nconst int N = (int) (1e6 + 5);\n\nint n;\nll f[N], fi[N];\n\nll mult(ll a, ll b) {\n    return (a * b) % MOD;\n}\n\nll powmod(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1) {\n            --b;\n            res = mult(res, a);\n        } else {\n            b /= 2;\n            a = mult(a, a);\n        }\n    }\n    return res;\n}\n\nll inv(ll a) {\n    return powmod(a, MOD - 2);\n}\n\nll S(int n, int k) {\n    if (n + 1 < 2 * k) return 0;\n    return mult(f[n - k + 1], inv(mult(f[k], f[n - 2 * k + 1])));\n}\n\nint main() {\n    init()\n\n    cin >> n;\n    --n;\n\n    f[0] = 1;\n    for1 (i, n) f[i] = mult(f[i - 1], i);\n\n    ll sum = 0, res = 0;\n    for2 (i, (n + 1) / 2, n) {\n        ll value = mult(S(n - 2, n - i), mult(f[i], f[n - i])) - sum;\n        sum = (sum + value) % MOD;\n        res = (res + mult(value, i)) % MOD;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\nusing namespace std;\nint main(void){\n    long long int n=0,i=1,buf1=0,buf3=0,buf4=0,buf2=0;\n    cin >> n;\n    if(n>1000000||n<2){\n    \texit(0);\n    }\n    buf3=n;\n    n=n-1;\n    for(int f=1;f<buf3;f++){\n    \ti=i*f;\n    \n    \tif(i>=2432902008176640000)i=i/(1000000000+7);\n    }\n    /*vector<long long int> v(n);\n    vector<long long int> buf2;\n    iota(v.begin(),v.end(),1);\n    do {\n        for(auto x : v)buf2.push_back(x);i++;\n    }while(next_permutation(v.begin(),v.end()));*/\n    buf2=2*2/1000000000+7;\n    if(buf3%2==0){\n        buf1=(i-2)*3+(2*2);\n    }\n    else{\n        buf1=(i-(buf3%2+buf3/2))*n;\n    }\n    cout  << buf1%(1000000000+7);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int DIV=1000000000+7;\nlong myPow(long x, long n, long m){\n  if(n == 0)\n    return 1;\n  if(n % 2 == 0)\n    return myPow(x * x % m, n / 2, m);\n  else\n    return x * myPow(x, n - 1, m) % m;\n}\nlong fact(long i,long j){//i*i+1*....*i+j-1\n    if(j==0)\n        return 1;\n    else\n        return fact(i,j-1)*(i+j-1) % DIV;\n}\n\nint main(){\n    long N;\n    cin >> N;\n    \n    long m;\n    if(N%2==0)\n        m=N/2;\n        \n    else\n        m=(N-1)/2;\n    long A[m];\n//    long kaijo = fact(1,N-m-1);\n    A[0] = fact(1,N-1);\n//    A[m-1] = kaijo*kaijo*(N-m);\n    for(long i=1;i<m;i++){\n     //   A[i] = A[i-1];\n     //   A[i] /= (N-i)*(N-i-1);\n     //   A[i] *=  (N-i-i)*(N-i-i-1);\n    A[i]=fact(1,N-i-1)*(N-i-i-1,i);\n//        cout<<\"Ai:\"<<A[i]<<endl;\n    }\n    long ret;\n    for(int i=0;i<m;i++){\n        A[i] %= DIV;\n    }\n    ret = A[0] * (N-1);\n    for(int i=1;i<m;i++){\n        ret -= A[i];\n//        cout<<\"i:\"<<i<<endl;\n    }\n    ret %= DIV;\n    cout << ret << endl;\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<uint_fast64_t Modulus = MOD>\nstruct Modint {\n  using u64 = uint_fast64_t;\n  u64 a;\n\n  constexpr Modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n  constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n\n  constexpr Modint &operator+=(const Modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) a -= Modulus;\n    return *this;\n  }\n  constexpr Modint &operator-=(const Modint rhs) noexcept {\n    if (a < rhs.a) a += Modulus;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr Modint &operator*=(const Modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr Modint &operator/=(Modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp & 1) *this *= rhs;\n      rhs *= rhs;\n      exp >>= 1;\n    }\n    return *this;\n  }\n\n  Modint pow(u64 t) const {\n    if (!t) return 1;\n    Modint x = pow(t>>1);\n    x *= x;\n    if (t&1) x *= *this;\n    return x;\n  }\n\n  explicit operator bool() const {\n    return a;\n  }\n\n  friend ostream &operator<<(ostream &os, const Modint &m) {\n    return os << m.a;\n  }\n};\n\nusing mint = Modint<>;\n\ntemplate<typename T>\nstruct ModCombination {\n  vector<T> fac, finv, inv;\n\n  ModCombination(int MAX) : fac(MAX + 1), finv(MAX + 1), inv(MAX + 1) {\n    fac[0] = finv[MAX] = inv[0] = 1;\n    for (int i=1; i<=MAX; ++i) fac[i] = fac[i-1] * i;\n    finv[MAX] /= fac[MAX];\n    for (int i=MAX-1; i>=0; --i) finv[i] = finv[i+1] * (i+1);\n    for (int i=1; i<=MAX; ++i) inv[i] = finv[i] * fac[i-1];\n  }\n\n  T P(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return fac[n] * finv[n-r];\n  }\n\n  T C(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return fac[n] * finv[r] * finv[n-r];\n  }\n\n  T H(int n, int r) const {\n    if (n < 0 || r < 0) return 0;\n    return C(n + r - 1, r);\n  }\n};\n\nvoid solve() {\n  int n; cin >> n;\n\n  if (n == 2) {\n    cout << 1 << endl;\n    return;\n  }\n\n  ModCombination<mint> comb(n);\n\n  mint ans = 0;\n\n  rep(k,n/2) {\n    ans += comb.C(n-3-k, k) * comb.P(n-1-k, n-1-k) * comb.P(k, k) * ((k+1) * 2);\n    ans += comb.C(n-4-k, k) * comb.P(n-2-k, n-2-k) * comb.P(k+1, k+1) * (k+2);\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Gear4        \n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#define FOR0(i,n) for(int i=0, _##i=(n); i<_##i; ++i)\n#define FOR(i,l,r) for(int i=(l), _##i=(r); i<_##i; ++i)\n#define FORD(i,l,r) for(int i=(r), _##i=(l); --i>=_##i; )\n#define SZ(a) ((int)((a).size()))\n#define printCase() \"Case #\" << caseNum << \": \"\n#define pb push_back\n#define mp make_pair\n#define SYNC std::ios::sync_with_stdio(false);  cin.tie(NULL);\n#define ff first\n#define ss second\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T, typename U> using P = pair<T,U>;\nusing ld = long double;\nusing ll = long long;\n#define endl '\\n'\nconst int inf = 1e9, mod = 1e9 + 7;\nconst ll INF = 9e18;\nconst ld EPS = 1e-9, PI = acosl(-1.0);\nconst int N = 1e6 + 6;\nint n, fac[N], ifac[N];\nll ch(int n, int r) {\n    if(r < 0 || r > n) return 0;\n    return fac[n] * 1LL * (ifac[r] * 1LL * ifac[n-r] % mod) % mod;\n}\nint modexp(ll a, int b, ll p) {\n    ll ret = 1;\n    for(; b; b>>=1) {\n        if(b & 1) ret = ret * a % p;\n        a = a * a % p;\n    }\n    return ret;\n}\nint main() {\n    SYNC\n    fac[0] = ifac[0] = 1;\n    for(int i = 1; i<N; i++) fac[i] = fac[i-1] * 1LL * i % mod;\n    for(int i = 1; i<N; i++) ifac[i] = modexp(fac[i], mod-2, mod);\n    cin >> n;\n    ll ans = 0, cur = 0, pre = 0;\n    for(int i = 1; i < n; i++) {\n        cur = ch(i-1, n-i-1) * fac[i] % mod;\n        cur = cur * fac[n-i-1] % mod;\n        (ans += i * (cur-pre)) %= mod;\n        (pre += cur) %= mod;\n    }\n    if(ans<0) ans =+ mod;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\tfor (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + ch - '0';\n\treturn x * f;\n}\n\nconst int N = 3e6 + 5;\nconst int P = 1e9 + 7;\nint fac[N], ifac[N], f[N];\n\nint Pow(int x, int t)\n{\n\tint res = 1;\n\tfor (; t; t >>= 1, x = 1LL * x * x % P)\n\t\tif (t & 1) res = 1LL * res * x % P;\n\treturn res;\n}\n\nint main()\n{\n\tint n = read();\n\t\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; ++i) fac[i] = 1LL * i * fac[i - 1] % P;\n\tifac[N - 1] = Pow(fac[N - 1], P - 2);\n\tfor (int i = N - 1; i >= 1; --i) ifac[i - 1] = 1LL * i * ifac[i] % P;\n\t\n\tint ans = 0;\n\tfor (int i = (n + 1) / 2; i <= n; ++i) \n\t\tf[i] = 1LL * fac[i] * fac[i - 1] % P * ifac[2 * i - n] % P;\n\tfor (int i = (n + 1) / 2; i <= n; ++i) \n\t\tans = ((ans + 1LL * i * (f[i] - f[i - 1]) % P) % P + P) % P;\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#define MAXN 1000005\n#define MOD 1000000007\n#define mod 1000000007\nusing namespace std;\ntypedef long long LL;\ntypedef long long ll;\nLL n,m,p,f[MAXN],g[MAXN],st;\nll h[MAXN];\nvoid init()\n{\n    f[0]=1;\n    for(int i=1;i<=MAXN;i++)\n    {\n        f[i]=f[i-1]*i;\n        f[i]%=MOD;\n     //   printf(\"%lld\\n\",fact[i]);\n    }\n}\nll powmod(ll x,ll n)\n{\n    ll s=1;\n    while(n)\n    {\n        if(n&1)\n            s=(s*x)%mod;\n        n>>=1;\n        x=(x*x)%mod;\n    }\n    return s;\n}\nll C(ll n,ll m)\n{\n    if(n<m)\n        return 0;\n    ll a=f[n],b=(f[n-m]*f[m])%mod;\n    return (a*powmod(b,mod-2))%mod;\n}\nint main()\n{\n    p=MOD;\n    init();\n    scanf(\"%lld\",&n);\n    //先求g[i]\n    //\n    if(n%2)\n    {\n        st=n/2+1;\n    }\n    else\n    {\n        st=n/2;\n    }\n    //\n    for(int i=st;i<=n-1;i++)\n    {\n     //   printf(\"%d\\n\",i);\n        g[i]=((C(i-1,n-i-1)*f[i])%MOD*f[n-i-1])%MOD;\n       // printf(\"%lld\\n\",g[i]);\n    }\n    for(int i=st;i<=n-1;i++)\n    {\n        h[i]=(g[i]-g[i-1]+MOD)%MOD;\n        h[i]%=MOD;\n    }\n    long long ans=0;\n    for(int i=st;i<=n-1;i++)\n    {\n        ans+=(h[i]*i)%MOD;\n        ans%=MOD;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long\n#define MOD 1000000007\n\nll power_mod(ll x, ll n, ll mod) {\n  if (n == 0)\n    return 1;\n  else if (n % 2)\n    return x * power_mod(x, n - 1, mod) % mod;\n  else\n    return power_mod(x * x % mod, n / 2, mod);\n}\n\nll facts[1000001];\nll rfacts[1000001];\n\nll comb(ll n, ll k) {\n  if (n == 0 || k == 0 || n - k == 0) return 1;\n  return (facts[n] * rfacts[k] % MOD) * rfacts[n - k] % MOD;\n}\n\nint main() {\n  int upper = 1000000;\n\n  ll f = 1;\n  facts[0] = 1;\n  for (int i = 1; i <= upper; i++) {\n    f = f * i % MOD;\n    facts[i] = f;\n    rfacts[i] = power_mod(f, MOD - 2, MOD);\n  }\n\n  //ここでcomb()使った処理\n  int n;\n  std::cin >> n;\n\n  ll res = 0;\n  ll pre = 0;\n  for (int k = (n - 1) / 2 + 1; k < n; k++) {\n    ll cnt = (comb(k - 1, n - k - 1) * facts[k] % MOD) * facts[n - k - 1] % MOD;\n\n    res = ((res + k * (cnt - pre)) % MOD + MOD) % MOD;\n    pre = cnt;\n  }\n\n  std::cout << res << std::endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long \n#define MAX_N 500010\n#define MOD 1000000007\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a==0&&b==0)return 1;\n    if(a<=0)return 0;\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    make();\n    ll n;\n    cin >> n;  \n    vector<ll> a(n);\n    rep(i,n){\n        if(i>=n-1){\n            a[i] = fac[n-1];\n            continue;\n        }\n        a[i] = comb(n-2-i,i)*fac[i]%mod;\n        a[i] *= fac[n-1-i]%mod;\n        a[i] = (fac[n-1]-a[i]+mod)%mod;\n    }\n    for(int i=n-1;i>=1;i--){\n        a[i] += mod-a[i-1];\n        a[i] %= mod;\n    }\n    //rep(i,n)cerr << a[i] << endl;\n    ll sm = 0;\n    rep(i,n){\n        sm += (n-i)*a[i]%mod;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 1000000\n#define MOD 1000000007\n#define rint register int\n#define gc() getchar()\ninline int read(int r=0,int s=0,int c=gc()){for(;c<48||c>57;s=c,c=gc());for(;c>=48&&c<=57;(r*=10)+=c-48,c=gc());return s^'-'?r:-r;}\ninline int fxp(int s, int n=MOD-2){int a=1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\nint fac[MAXN+5], efac[MAXN+5], f[MAXN+5], s[MAXN+5], n, Ans; inline int C(int n, int k){return n<0||k<0||n<k?0:1ll*fac[n]*efac[k]%MOD*efac[n-k]%MOD;}\nint main()\n{\n\tn = read(); for(rint i = fac[0] = 1; i <= n; fac[i] = 1ll*i*fac[i-1]%MOD, i++); efac[n] = fxp(fac[n]); for(rint i = n; i; efac[i-1] = 1ll*i*efac[i]%MOD, i--);\n\tfor(rint i = 1; i <= n; f[i] = 1ll*C(i-1,n-i-1)*fac[i]%MOD*fac[n-1-i]%MOD, f[i] = (f[i]+MOD-s[i-1])%MOD, s[i] = (s[i-1]+f[i])%MOD, i++);\n\tfor(rint i = 1; i < n; Ans = (Ans+1ll*i*f[i])%MOD, i++); printf(\"%d\\n\",Ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <string>\n#include <utility>\n#include <map>\n#include <deque>\n\nusing namespace std;\n#define rep(i,n) for(int i=1;i<=(int)(n);i++)\n#define Rep(i,n) for(int i=0;i<=(int)(n-1);i++)\ntypedef long long ll;\ntypedef map<int,int> mint;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\ntypedef deque<pair<ll,ll>> dep;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nint inf=1e9+1000;\nconst int mod=1e9+7;\nll infi=1e18+100;\n\nll N;\n\nll frac(int n){\n\tif(n==0) return 1;\n\telse return (n*frac(n))%mod;\n}\n\n\nint main(){\n\tcin>>N;\n\tll ninzuu[N+1]={};\n\tll frac[N+3];\n\tRep(i,N+1) frac[i]=frac(i);\n\tll sum=0;\n\tif(N%2==0){\n\t\tfor(int i=N/2;i<=N;i++){\n\t\t\tif(i==N/2) ninzuu[i]=frac[i];\n\t\t\telse{\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\t}\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=(N+1)/2;i<=N;i++){\n\t\t\t\tninzuu[i]=(frac[i]*frac[N-i]-ninzuu[i-1])%mod;\n\t\t\tsum+=(i*ninzuu[i])%mod;\n\t\t}\n\t\t\n\t}\n\tcout<<(sum)%mod<<endl;\n\t\n\t\n\t\n\t  return 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing ll = long long;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\nint const nmax = 1000000;\nint const modulo = 1000000007;\n\nstruct Mint{\nprivate:\n  void gcd(int a, int b, int &x, int &y) {\n    if(b == 0) {\n      x = 1;\n      y = 0;\n    } else {\n      gcd(b, a % b, x, y);\n      int aux = x;\n      x = y;\n      y = aux - a / b * y;\n    }\n  }\npublic:\n  int number;\n  Mint(ll number_ = 0) {\n    number = number_ % modulo;\n  }\n  Mint operator + (Mint a) {\n    return (number + a.number);\n  }\n  Mint operator - (Mint a) {\n    return (modulo + number - a.number);\n  }\n  Mint operator * (Mint a) {\n    return 1LL * number * a.number;\n  }\n  Mint operator / (Mint a) {\n    int x, y;\n    gcd(a.number, modulo, x, y);\n    x %= modulo;\n    if(x < 0)\n      x += modulo;\n    return 1LL * number * x;\n  }\n  friend std::ostream &operator <<(std::ostream &output, Mint a) {\n    output << a.number;\n    return output;\n  }\n};\n\nMint fact[1 + nmax];\nvoid precompute() {\n  fact[0] = 1;\n  for(int i = 1;i <= nmax; i++)\n    fact[i] = fact[i - 1] * i;\n}\nMint comb(int n, int k) {\n  if(0 <= k && k <= n)\n    return fact[n] / fact[k] / fact[n - k];\n  return 0;\n}\n\nint main() {\n  precompute();\n  int n;\n  std::cin >> n;\n  if(n == 2) {\n    std::cout << 1;\n    return 0;\n  }\n  Mint result;\n  result = fact[n - 1] * (n);\n  for(int i = (n + 1) / 2; i < n; i++) {\n    result = result - comb(i - 1, n - 1 - i) * fact[i] * fact[n - 1 - i];\n  }\n  std::cout << result;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconstexpr int MOD = 1e9 + 7;\nll pow1(ll n, ll p){\n    ll cur, res;\n    cur = n;\n    res = 1;\n    while(p){\n        if(p & 1){\n            res *= cur;\n            res %= MOD;\n        }\n        p /= 2;\n        cur *= cur;\n        cur %= MOD;\n    }\n    return res;\n}\nll fact[1000001];\nll inv[1000001];\nll K[1000001];\nll cnk(int n, int k){\n    if(n < k)return 0;\n    return fact[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n    fact[0] = inv[0] = 1;\n    for(int i = 1;i < 1000001;i++)\n        fact[i] = fact[i-1] * i % MOD, inv[i] = pow1(fact[i], MOD - 2);\n    int n;\n    cin >> n;\n//    cout << fact[10000] * inv[9999] % MOD << endl;\n    for(int i = 1;i < n;i++){\n        K[i] = cnk(i-1, n - i - 1) * fact[i] % MOD * fact[n-1-i] % MOD;\n    }\n    ll cum = 0;\n    ll res = 0;\n//    cout << K[5] - K[4] << endl;\n    for(int i = 1;i < n;i++){\n        res += (K[i] - K[i-1]) * i % MOD;\n        cum += K[i];\n        cum %= MOD;\n        res %= MOD;\n    }\n    if(res < 0)res += MOD;\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n\nint mod = 1e9 + 7;\n\n// mod_power.cc\nll po(ll k, ll x) {\n  if (x == 0) {\n    return 1;\n  }\n  if (x == 1) {\n    return k % mod;\n  }\n  ll y = po(k, x/2);\n  y = y * y % mod;\n  if (x % 2 == 1) {\n    y = y * k % mod;\n  }\n  return y;\n}\n\nvll factorial;\nvll inv_fact;\nll comb(ll x, ll y) {\n  if (x < 0 || x < y) {\n    return 0;\n  }\n  y = min(y, x-y);\n  if (y == 0) {\n    return 1;\n  }\n  ll ret = 1;\n  ret = ret * factorial[x] % mod;\n  ret = ret * inv_fact[y] % mod;\n  ret = ret * inv_fact[x-y] % mod;\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  if (n <= 3) {\n    int ans = 0;\n    if (n == 2) {\n      ans = 1;\n    } else if (n == 3) {\n      ans = 4;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n  }\n\n  factorial.assign(n+1, 0);\n  inv_fact.assign(n+1, 0);\n  factorial[0] = 1;\n  inv_fact[0] = 1;\n  rep (i, n) {\n    factorial[i+1] = factorial[i] * (i+1) % mod;\n    inv_fact[i+1] = po(factorial[i+1], mod-2) % mod;\n  }\n  ll ans = 0;\n  ll sum = 0;\n  FOR (i, 2, n) {\n    ll cnt = 1;\n    cnt = cnt * comb(i-1, n-1-i) % mod;\n    cnt = cnt * factorial[i] % mod;\n    cnt = cnt * factorial[n-1-i] % mod;\n    ll add = (cnt + mod - sum) * i % mod;\n    sum = (sum + cnt) % mod;\n    ans = (ans + add) % mod;\n    debug(ans);\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P\n{\n    int x,y,z;\n\n    bool operator<(const P &a)const{\n              return x>a.x;\n    }\n};\n\n\nvector<P> v[10];\n//bitset<4001000> b;\nint a,c,i,b,k,n,d,e,m;//dy[15]={0,1,0,-1,-1,1,-1,1},dx[15]={1,0,-1,0,1,1,-1,-1};//\nint l[33];\n\nint o[3000544];\nint j[41][6];\nint dx[10]={0,1,0,-1,1,1,-1,-1},dy[10]={-1,0,1,0,1,-1,1,-1},dz[10]={0,0,0,0,1,-1};\n\n\nlong long x,y,mod=1000000007;\nlong long z[1000100],z1[100100];\n\nP u[1000020];\nstack<int> s[2];\n//queue<int> q,q1,q2;\n//set<int> s;\nqueue<P> q;\n\n//'1'==49;\n//'A'==65;\n//'a'==97;\n//unordered_\n//map<long long,long long> p;\n//list<int> l;\n//string r1,r;\nchar r[52];\n//deque<int> de;\nbool as(P a,P b)\n{\n    if(a.x!=b.x)\n    return a.x<b.x;\n    return a.y<b.y;\n}\nlong long g(long long a)\n{\n    if(a<0) return 0;\n    return z[a];\n}\n\nlong long p(long long a,long long b)\n{\n    if(!b) return 1;\n    long long x=p(a,b/2);\n    x*=x;\n    x%=mod;\n    if(b&1) x*=a,x%=mod;\n    return x;\n}\n\nlong long f(long long x,long long y)\n{\n    if(x<y) return 0;\n    //printf(\"@@%lld %lld\\n\",z1[y],p(g(y),mod-2));\n    return g(x)*z1[y]%mod*z1[x-y]%mod;\n}\n\nint main()\n{\n    scanf(\"%d\",&a);\n    if(a==2)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    z[0]=1;\n    z1[0]=1;\n    for(int t=1;t<=a;t++)\n        z[t]=z[t-1]*t%mod,z1[t]=p(z[t],mod-2);\n    long long n=0;\n    for(int t=2;t<a;t++)\n    {\n        y=x;\n        x=f(t-1,a-1-t)*g(t)%mod*g(a-1-t)%mod;\n        n+=(x-y)*t;\n        n%=mod;\n        //printf(\"@@%lld %lld\\n\",z1[t],p(g(t),mod-2));\n        //printf(\"!!%lld %lld %lld %lld\\n\",x,f(t-1,a-t-1),g(t),g(a-1-t));\n    }\n    printf(\"%lld\",n);\n}\n//128397156\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,ans=0;\n  cin>>N;\n  COMinit();\n  ll cnt[N];\n  REP(i,N) cnt[i]=0;\n  \n  for(ll i=1; i<=N-1; ++i){\n    cnt[i]=COM(i-1,N-1-i)*fac[i];\n    cnt[i]%=MOD;\n    cnt[i]*=fac[N-1-i];\n    cnt[i]%=MOD;\n    ans+=(cnt[i]-cnt[i-1])*i;\n    ans%=MOD;\n  }\n  \n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string.h>\n#include <queue>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9+7;\nll fac[1111111];\nll invfac[1111111];\nll n, ans, add;\n\n\nll exp(ll x,ll y){\n    if(y<0) return 0;\n    ll ret=1;\n    for(;y;y>>=1,x=(x*x)%mod){\n        if(y&1)ret=(ret*x)%mod;\n    }\n    return ret;\n}\n\nll ncr(ll u, ll v){\n    if(u<0 || v<0 || u<v) return 0;\n    ll ret = fac[u];\n    ret=(ret*invfac[v])%mod;\n    ret=(ret*invfac[u-v])%mod;\n    return ret;\n}\n\nint main(void){\n    cin>>n;\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1 ; i<=n ; i++){\n        fac[i]=(i*fac[i-1])%mod;\n        invfac[i]=exp(fac[i],mod-2);\n    }\n    ans+=fac[n-1];\n    for(int i=1 ; i<=n-1 ; i++){\n        add = ncr(n-1,i)-ncr(i-1,n-2-i+1);\n        add = (add+mod)%mod;\n        add = (add*fac[n-1-i])%mod;\n        add = (add*fac[i])%mod;\n        ans = (ans+add);\n        if(ans>=mod) ans-=mod;\n    }\t\n    ans%=mod;\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 5;\ntypedef long long ll;\n\nint n;\nll f[N], mod = 1e9 + 7, inv[N], fac[N], ans;\n\nll calc(int n, int k) {\n\treturn fac[n]*inv[n - k]%mod*inv[k]%mod;\n}\n\nll fps(ll a, ll b) {\n\tll res = 1;\n\twhile(b) {\n\t\tif(b&1) res = res*a%mod;\n\t\tb /= 2;\n\t\ta = a*a%mod;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin>>n;\n\tfac[0] = inv[0] = fac[1] = inv[1] = 1;\n\tfor(int i = 2; i <= n; i++) {\n\t\tfac[i] = fac[i - 1]*i;\n\t\tinv[i] = fps(fac[i], mod - 2);\n\t}\n\tfor(int i = (n + 1)/2; i < n; i++)\n\t\tf[i] = (calc(i - 1, n - i - 1)*fac[i]%mod*fac[n - i - 1])%mod;\n\tfor(int i = (n + 1)/2; i < n; i++)\n\t\tans = (ans + (f[i] - f[i - 1])*i)%mod;\n\tcout<<(ans + mod)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,res;\nstring s[304];\nint ok(int a, int b){\n  for(int i = 0; i<n; i++)\n    for(int j = 0; j<n; j++)\n      if(s[(i+a)%n][(j+b)%n] != s[(j+a)%n][(i+b)%n]) return 0;\n  return 1;\n}\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  std::cin >> n;\n  for(int i = 0; i<n; i++) std::cin >> s[i];\n  for(int a = 0; a<n; a++) res+=n*ok(a,0);\n  std::cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// AGC023\n// C - Painting Machines\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 1000000;\nconst ll MOD = 1e9 + 7;\n\nint N;\nll fact[MAX_N + 1];\nll fact_inv[MAX_N + 1];\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n    ll d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\nll mod_inv(ll a, ll m) {\n    ll x, y;\n    extgcd(a, m, x, y);\n    return (m + x) % m;\n}\n\nvoid calc_fact() {\n    fact[0] = fact_inv[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n        fact_inv[i] = mod_inv(fact[i], MOD);\n    }\n}\n\nll solve() {\n    calc_fact();\n\n    ll ans = 0;\n    ll prev_cnt = 0;\n    for (int k = (N + 1) / 2; k <= N - 1; k++) {\n        ll cnt = fact[k - 1];\n        (cnt *= fact_inv[N - 1 - k]) %= MOD;\n        (cnt *= fact_inv[2 * k - N]) %= MOD;\n        (cnt *= fact[k]) %= MOD;\n        (cnt *= fact[N - 1 - k]) %= MOD;\n        // cerr << k << \" \" << cnt << endl;\n        (ans += k * (cnt - prev_cnt + MOD)) %= MOD;\n        prev_cnt = cnt;\n    }\n    return ans;\n}\n\nint main() {\n    cin >> N;\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010000, MOD = 1e9 + 7;\n\nlong long f[N], fac[N], inv[N];\nint n;\n\nlong long Kissme(long long x, long long y) {\n  long long c = 1;\n  while(y) {\n    if(y & 1) c = c * x % MOD;\n    x = x * x % MOD;\n    y >>= 1;\n  }\n  return c;\n}\n\nvoid Init(void) {\n  fac[0] = 1;\n  for(int i = 1; i <= n; i++)\n    fac[i] = fac[i - 1] * i % MOD;\n  inv[n] = Kissme(fac[n], MOD - 2);\n  for(int i = n - 1; i >= 0; i--)\n    inv[i] = inv[i + 1] * (i + 1) % MOD;\n}\n\nlong long C(int x, int y) {\n  if(x < y) return 0;\n  return fac[x] * inv[y] % MOD * inv[x - y] % MOD;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  Init();\n  long long ans = 0;\n  for(int i = 0; i < n; i++)\n    f[i] = C(n - 3 - i + 1, i);\n  //for(int i = 1; i < n; i++)\n  //f[i] = (f[i - 1] + f[i]) % MOD;\n  for(int i = 0; i < n; i++)\n    f[i] = f[i] * fac[i] % MOD * fac[n - i - 1] % MOD;\n  for(int i = 1; i < n; i++) {\n    ans = (ans + ((f[n - i - 1] - f[n - i]) * i % MOD + MOD) % MOD) % MOD;  \n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define lop(i, s, t) for (int i = s;i < (t);++i)\n#define rep(i, s, t) for (int i = s;i <= (t);++i) \n#define dec(i, s, t) for (int i = s;i >= (t);--i)\n#define cmin(a, b) (a > b ? a = b : a)\n#define cmax(a, b) (a < b ? a = b : a)\nusing namespace std; \n\n#define Pr(f,...) printf(f,##__VA_ARGS__),fflush(stdout)\n\nconst int N=1e6+60,P=1e9+7;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\n\ntypedef long long ll;\n\nint n,fac[N],inv[N],ans;\n\nint C(int n,int m){\n\tif(m<0||m>n||n<0)return 0;\n\treturn mul(fac[n],mul(inv[n-m],inv[m])); \n}\n\nint main() {\n#ifdef CURIOUSCAT\n\t//freopen(\"dat.in\",\"r\",stdin);\n\t//freopen(\"my.out\",\"w\",stdout); \n#endif\n\tscanf(\"%d\",&n); \n\tif(n==2){ return puts(\"1\"),0; }\n\tfac[0]=1; rep(i,1,n)fac[i]=mul(fac[i-1],i); \n\tinv[1]=1; rep(i,2,n)inv[i]=mul(P-P/i,inv[P%i]); \n\tinv[0]=1; rep(i,1,n)inv[i]=mul(inv[i-1],inv[i]);\n\tans=mul(n-1,fac[n-1]); \n\trep(k,1,n-2){\n\t\tint w=mul(C(k-1,n-k-1),mul(fac[k],fac[n-1-k]));\n\t\tans=sub(ans,w); \n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nstd::map<int, int> mem;\n\nint64_t factorial(int n) {\n  if (n <= 1)\n    return 1;\n  if (mem[n] == 0)\n    mem[n] = n * factorial(n-1);\n  return mem[n]  % (10000000007);\n}\n\nint64_t score(int n) {\n  if (n == 2)\n    return 1;\n  if (n == 3)\n    return 4;\n  if (n == 4)\n    return 16;\n  return ((factorial(n-2) + score(n-1)) * (n-1) -2 * factorial(n-3)) % (10000000007);\n}\n\nint main() {\n  int n;\n  std::cin >> n;\n  std::cout << score(n) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint N;\nLL fact[1145141];\nLL revf[1145141];\n\nLL mypow(LL base, LL exp) {\n  if (exp == 0) return 1;\n  LL res = mypow(base*base%MOD, exp/2);\n  if (exp%2) res = res*base % MOD;\n  return res;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  fact[0] = 1;\n  revf[0] = 1;\n  reps(i, 1, N+10) {\n    fact[i] = fact[i-1] * i % MOD;\n    revf[i] = revf[i-1] * mypow(i, MOD-2) % MOD;\n  }\n\n  LL ans = 0;\n  LL prev = 0;\n  rep(k, N) {\n    if (2*k < N) continue;\n    LL cnt = fact[k] * fact[k-1] % MOD * revf[2*k-N] % MOD;\n    LL num = (cnt + MOD - prev) % MOD;\n    ans = (ans + k*num) % MOD;\n    prev = cnt;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T, class S> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T> inline vector<T> cinv2(ll N){\n\tvector<T> v(N); REP(i, N){ll a, b; cin>>a>>b; v[i]={a,b};} return move(v);}\ntemplate<class T,class S,class R> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv3(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c; cin>>a>>b>>c; v[i]={a,b,c};} return move(v);}\ntemplate<class T,class S,class R,class Q> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv4(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c,d; cin>>a>>b>>c>>d; v[i]={a,b,c,d};} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nstruct Combination{\n\tvmll f, g;\n\tCombination(){}\n\tCombination(ll maxN): f(maxN+1, 1), g(maxN+1){ InitSub(maxN); }\n\tvoid init(ll maxN){ f.resize(maxN+1, 1); g.resize(maxN+1); InitSub(maxN); }\n\tmll operator () (ll n, ll r){ return (n<0||r<0||n<r) ? mll(0) : f[n]*g[n-r]*g[r]; }//nCr\n\tmll P(ll n, ll r){ return (n<0 || r<0 || n<r) ? mll(0) : f[n]*g[n-r]; } //nPr\n\tmll H(ll n, ll r){ return operator()(n+r-1, r); }//nHr\n\tmll inv(ll n) { return f[n-1] * g[n]; } //1/n\n\tmll fact(ll n) { return f[n]; } //n!\n\tmll finv(ll n) { return g[n]; } //1/n!\n\tvoid InitSub(ll maxN){\n\t\tREPS(i, 1, maxN){ f[i] = f[i-1] * i; }\n\t\tg[maxN] = 1 / f[maxN];\n\t\tDEPS(i, 1, maxN){ g[i-1] = g[i] * i; }\n\t}\n};\n\n\nvoid calc(ll n)\n{\n\tCombination cm(n+10);\n\tif (n==2){\n\t\tcout << 1 << '\\n'; return;\n\t}\n\n\tmll ans=0;\n\trep(k, 2, n-1){\n\t\tll r=n-k;\n\t\tans+=k*2*cm(k-1, r-1)*cm.fact(k-1)*cm.fact(r-1);\n\t\tans+=k*cm(k-2, r-1)*(r-1)*cm.fact(k-1)*2*cm.fact(r-1);\n\t\tans+=k*cm(k-2, r-2)*(r-2)*cm.fact(k-1)*cm.fact(r-1);\n\t}\n\n\tcout << ans << '\\n';\n}\n\n\nvoid solve()\n{\n\tll n;  cin >> n;\n\tcalc(n);\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\nconst li mod = 1e9 + 7;\n\nli pow(li x, li n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n\n    li sq = pow(x, n / 2);\n    if (n & 1) {\n        return sq * sq % mod * x % mod;\n    }\n    return sq * sq % mod;\n}\n\nli inv(li x) {\n    return pow(x, mod - 2);\n}\n\n// https://oeis.org/A030528\n// dp[i][j] = j - 1 choose (i - j + 1 ). sorry writers!\n\nint main() {\n    li n;\n    cin >> n;\n\n    vector<li> pow;\n    pow.push_back(1);\n    for (int i = 0; i < n + 10; ++i) {\n        pow.push_back(pow.back() * (i + 1) % mod);\n    }\n\n    li ans = 0;\n    li dpacc = 0;\n    for (int j = 0; j < n; ++j) {\n        li comb = (j >= n - j) ? (pow[j - 1] * inv(pow[n - j - 1]) % mod * inv(pow[2 * j - n] % mod)) : 0;\n        li totptn = comb % mod * pow[j] % mod * pow[n - 1 - j] % mod;\n        ans += (totptn - dpacc + mod) % mod * j % mod;\n        ans %= mod;\n\n        dpacc = totptn;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 1000007;\nconst int MOD = SC ( int, 1e9 + 7 );\n\nint n;\nLL frac[MAXN], rf[MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nint add ( int x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n\treturn x;\n}\n\nvoid addv ( int &x, int y )\n{\n\tx += y;\n\tif ( x >= MOD ) x -= MOD;\n}\n\nint dec ( int x, int y )\n{\n\tx -= y;\n\tif ( x < 0 ) x += MOD;\n\treturn x;\n}\n\nint qpow ( int a, int b )\n{\n\tLL base = a, ans = 1;\n\twhile ( b ){\n\t\tif ( b & 1 ) ( ans *= base ) %= MOD;\n\t\t( base *= base ) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn SC ( int, ans );\n}\n\nint C ( int n, int m )\n{\n\treturn ( n >= m ) ? SC ( int, frac[n] * rf[m] % MOD * rf[n-m] % MOD ) : 0;\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n\t\n\tfrac[0] = 1;\n\tlp ( i, 1, MAXN ) frac[i] = frac[i-1] * i % MOD;\n\trf[MAXN-1] = qpow ( frac[MAXN-1], MOD-2 );\n\tlpdi ( i, MAXN-2, 0 ) rf[i] = rf[i+1] * ( i + 1 ) % MOD;\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tcin >> n;\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\t--n;\n\t\n\tint ans = 0;\n\tlp ( i, 0, n ){\n\t\taddv ( ans, dec ( C ( n, i ), C ( i - 1, n - i ) ) * frac[i] % MOD * frac[n-i] % MOD );\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define mod 1000000007\n#define maxn 1000010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nint fac[maxn],inv[maxn];\nint n;\ninline ll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\ninline ll C(int n,int m){return m<0||m>n?0:(ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tn=read();\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(ll)fac[i-1]*i%mod;\n\t\tinv[i]=power(fac[i],mod-2);\n\t}\n\tint ans=0,last=0;\n\tfor(int i=1;i<n;i++){\n\t\tint now=C(i-1,n-i-1)*fac[n-i-1]%mod*fac[i]%mod;\n//\t\tprintf(\"%d %d\\n\",i,now-last);\n\t\tans=(ans+(ll)(now-last+mod)*i)%mod;\n\t\tlast=now;\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ull unsigned long long\n#define ll long long\n#define il inline\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define rep0(i, n) for(int i = 0; i < (n); i ++)\n#define per0(i, n) for(int i = (n) - 1; i >= 0; i --)\n#define ept 1e-9\n#define INF 0x3f3f3f3f\n#define sz(x) (x).size()\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\ninline ll read1()\n{\n\tll x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nusing namespace std;\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\nint jc[N], ny[N],n;\nint C(int n,int m)\n{\n\tif(n < m) return 0;\n\treturn (ll)jc[n] * ny[m] % mod * ny[n - m] % mod;\n}\nint ans=0;\nint main()\n{\n\tn = read();\n\tjc[0] = 1;\n\trep(i, 1, n) jc[i] = (ll)jc[i - 1] * i % mod;\n\tny[1] = 1;\n\trep(i, 2, n) ny[i] = (ll)(mod - mod / i) * ny[mod % i] % mod;\n\tny[0] = 1;\n\tfor(int i = 1; i <= n && i < mod; i ++) ny[i] = (ll)ny[i] * ny[i - 1] % mod;\n\trep(i, 1, n - 1)\n\t{\n\t\tint now = C(i - 1, n - i - 1);\n\t\tans = (ans + (ll)now * jc[i] % mod * jc[n - i - 1] % mod) % mod;\n\t}\n\tprintf(\"%d\",(jc[n] + mod - ans) % mod);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long \n#define MAX_N 200010\n#define MOD 1000000007\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a==0&&b==0)return 1;\n    if(a<=0)return 0;\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    make();\n    ll n;\n    cin >> n;  \n    vector<ll> a(n);\n    return 0;\n    rep(i,n){\n        if(i>=n-1){\n            a[i] = fac[n-1];\n            continue;\n        }\n        a[i] = comb(n-2-i,i)*fac[i]%mod;\n        a[i] *= fac[n-1-i]%mod;\n        a[i] = (fac[n-1]-a[i]+mod)%mod;\n    }\n    return 0;\n    for(int i=n-1;i>=1;i--){\n        a[i] += mod-a[i-1];\n        a[i] %= mod;\n    }\n    //rep(i,n)cerr << a[i] << endl;\n    ll sm = 0;\n    rep(i,n){\n        sm += (n-i)*a[i]%mod;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 2000005, MOD = 1000000007;\nint f[N], finv[N], act[N];\n\ninline add(int &a, int b) {\n    a += b;\n    if (a >= MOD) {\n        a -= MOD;\n    }\n}\n\ninline sub(int &a, int b) {\n    a -= b;\n    if (a < 0) {\n        a += MOD;\n    }\n}\n\ninline int mul(int a, int b) {\n    return (ll)a * b % MOD;\n}\n\nvoid precalc() {\n    f[0] = 1;\n    for (int i = 1; i < N; i++) {\n        f[i] = mul(f[i - 1], i);\n    }\n    finv[0] = finv[1] = 1;\n    for (int i = 2; i < N; i++) {\n        finv[i] = (MOD - mul(MOD / i, finv[MOD % i])) % MOD;\n    }\n    for (int i = 2; i < N; i++) {\n        finv[i] = mul(finv[i - 1], finv[i]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(cout.fixed);\n    cout.precision(20);\n    precalc();\n    int n;\n    cin >> n;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        act[k] = mul(mul(f[k - 1], f[k]), finv[2 * k - n]);\n    }\n    ll res = 0;\n    for (int k = (n + 1) / 2; k < n; k++) {\n        int realact = act[i];\n        sub(realact, act[k - 1]);\n        add(res, mul(k, realact));\n    }\n    cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nconst int64_t M = 1000000007;\nconst int MAX_N = 1000000;\nint64_t fact[MAX_N];\nint64_t inv[MAX_N];\n\nint64_t mod_pow(int64_t a, int64_t b)\n{\n  if (b == 0) return 1;\n  int64_t ret = mod_pow(a, b/2);\n  ret = ret * ret % M;\n  if (b % 2 == 1) ret = a * ret % M;\n  return ret;\n}\n\nint64_t comb(int64_t n, int64_t k)\n{\n  return (fact[n] * inv[n-k] % M) * inv[k] % M;\n}\n\nint main()\n{\n  scanf(\"%d\\n\", &n);\n\n  fact[0] = inv[0] = 1;\n  for (int i = 1; i < n; i++) {\n    fact[i] = fact[i-1] * i % M;\n    inv[i] = mod_pow(fact[i], M-2);\n  }\n\n  int64_t sum = 0;\n\n  int64_t prev_c = 0;\n  for (int k = 1; k <= n-1; k++) {\n    if (k - 1 >= n - 1 - k) {\n      int64_t c = (comb(k-1, n-1-k) * fact[k] % M) * fact[n-1-k] % M;\n      sum = (sum + k * ((c - prev_c) % M) % M) % M;\n      prev_c = c;\n    }\n  }\n\n  cout << sum << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SIZE(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nstruct ModRing {\n   int mod, x;\n   ModRing(int mod_n) : mod(mod_n), x(0) {}\n   ModRing(int a, int mod_n) : mod(mod_n) { x = ((a % mod) + mod) % mod; }\n\n   bool operator==(const ModRing& a) const {\n      return x == a.x;\n   }\n   bool operator==(int a) const {\n      return *this == ModRing(a, mod);\n   }\n   ModRing& operator=(int a) {\n      return *this = ModRing(a, mod);\n   }\n   ModRing operator-() const {\n      return ModRing((-x + mod) % mod, mod);\n   }\n   ModRing& operator+=(const ModRing& a) {\n      (x += a.x) %= mod;\n      return *this;\n   }\n   ModRing& operator-=(const ModRing& a) {\n      return *this += -a;\n   }\n   ModRing& operator*=(const ModRing& a) {\n      (x *= a.x) %= mod;\n      return *this;\n   }\n   const ModRing operator+(const ModRing& a) const {\n      return ModRing(x, mod) += a;\n   }\n   const ModRing operator-(const ModRing& a) const {\n      return ModRing(x, mod) -= a;\n   }\n   const ModRing operator*(const ModRing& a) const {\n      return ModRing(x, mod) *= a;\n   }\n   ModRing& operator+=(int a) {\n      return *this += ModRing(a, mod);\n   }\n   ModRing& operator-=(int a) {\n      return *this -= ModRing(a, mod);\n   }\n   ModRing& operator*=(int a) {\n      return *this *= ModRing(a, mod);\n   }\n   const ModRing operator+(int a) const {\n      return ModRing(x, mod) += a;\n   }\n   const ModRing operator-(int a) const {\n      return ModRing(x, mod) -= a;\n   }\n   const ModRing operator*(int a) const {\n      return ModRing(x, mod) *= a;\n   }\n   ModRing power(int n) const {\n      ModRing tmp(x, mod), res(1, mod);\n      while (n > 0) {\n         if ((n & 1) == 1) res *= tmp;\n         tmp *= tmp;\n         n >>= 1;\n      }\n      return res;\n   }\n};\nauto&operator<<(ostream&s,const ModRing&a){s<<a.x;return s;}\n\nstruct FiniteField : ModRing {\n   FiniteField(int mod_n) : ModRing(mod_n) {}\n   FiniteField(int a, int mod_n) : ModRing(a, mod_n) {}\n   FiniteField(const ModRing& a) : ModRing(a) {}\n\n   bool operator==(const FiniteField& a) const {\n      return ModRing::operator==(a);\n   }\n   bool operator==(int a) const {\n      return ModRing::operator==(a);\n   }\n   FiniteField& operator=(int a) {\n      return *this = FiniteField(ModRing::operator=(a));\n   }\n   FiniteField operator-() const {\n      return FiniteField(ModRing::operator-());\n   }\n   FiniteField& operator+=(const FiniteField& a) {\n      return *this = FiniteField(ModRing::operator+=(a));\n   }\n   FiniteField& operator-=(const FiniteField& a) {\n      return *this = FiniteField(ModRing::operator-=(a));\n   }\n   FiniteField& operator*=(const FiniteField& a) {\n      return *this = FiniteField(ModRing::operator*=(a));\n   }\n   const FiniteField operator+(const FiniteField& a) const {\n      return FiniteField(ModRing::operator+(a));\n   }\n   const FiniteField operator-(const FiniteField& a) const {\n      return FiniteField(ModRing::operator-(a));\n   }\n   const FiniteField operator*(const FiniteField& a) const {\n      return FiniteField(ModRing::operator*(a));\n   }\n   FiniteField& operator+=(int a) {\n      return *this = FiniteField(ModRing::operator+=(a));\n   }\n   FiniteField& operator-=(int a) {\n      return *this = FiniteField(ModRing::operator-=(a));\n   }\n   FiniteField& operator*=(int a) {\n      return *this = FiniteField(ModRing::operator*=(a));\n   }\n   const FiniteField operator+(int a) const {\n      return FiniteField(ModRing::operator+(a));\n   }\n   const FiniteField operator-(int a) const {\n      return FiniteField(ModRing::operator-(a));\n   }\n   const FiniteField operator*(int a) const {\n      return FiniteField(ModRing::operator*(a));\n   }\n   FiniteField power(int n) const {\n      return FiniteField(ModRing::power(n));\n   }\n\n   FiniteField inverse() const {\n      try { if (x == 0) throw \"0 have no inverse\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return power(mod-2);\n   }\n   FiniteField& operator/=(const FiniteField& a) {\n      return *this *= a.inverse();\n   }\n   const FiniteField operator/(const FiniteField& a) const {\n      return FiniteField(x, mod) /= a;\n   }\n   FiniteField& operator/=(int a) {\n      return *this /= FiniteField(a, mod);\n   }\n   const FiniteField operator/(int a) const {\n      return FiniteField(x, mod) /= a;\n   }\n};\n\nint GF_MOD = MOD_N;\nstruct GF : FiniteField {\n   GF() : FiniteField(GF_MOD) {}\n   GF(int a) : FiniteField(a, GF_MOD) {}\n   GF(const FiniteField& a) : FiniteField(a) {}\n};\n\nvector<GF> frac;\nvoid init_frac(int N) {\n   frac.resize(N+1);\n   frac[0] = 1;\n   for (int i = 1; i <= N; i++) {\n      frac[i] = frac[i-1] * i;\n   }\n}\nGF C(int n, int r) {\n   if (n < 0 || n-r < 0 || r < 0) {\n      return 0;\n   }\n   return frac[n] / (frac[n-r] * frac[r]);;\n}\n\nsigned main()\n{\n   int n; cin >> n;\n\n   init_frac(n-1);\n   V<GF> num(n);\n   FORE(k, 1, n-1) {\n      num[k] = C(k-1, n-1-k) * frac[k] * frac[n-1-k];\n   }\n   GF ans = 0;\n   FORE(k, 1, n-1) {\n      ans += (num[k] - num[k-1]) * k;\n   }\n   cout << ans << endl;\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<map>\n#include<bitset>\n#include<math.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define REP(i,m,n) for(ll i=m;i<(ll)(n);i++)\ntypedef pair<int,int> pint;\ntypedef long long ll;\nconst ll mod= 1e9+7;\nconst ll  longinf = 1LL<<60;\nint dx[4]={1,0,-1,0}, dy[4]={0,1,0,-1};\n\nll fact[1010101],invfact[1010101];\n\nll comb(int n,int k){\n  if(k<0||k>n)return 0;\n  ll ret=fact[n]*invfact[k] %mod;\n  ret=ret*invfact[n-k] %mod;\n  return ret %mod;\n  }\n\nll inv(ll n){\n  ll ret=1,k=mod-2;\n  while(k>0){\n    if(k&1)ret=ret*n %mod;\n    n=n*n %mod;\n    k/=2;\n    }\n  return ret%mod;\n  }\n\nint main(){\n  ll n;\n  cin>>n;\n  fact[0]=invfact[0]=1;\n  rep(i,n+1)fact[i+1]=fact[i]*(i+1) %mod;\n  invfact[n]=inv(fact[n]);\n  rep(i,n+1)invfact[n-i-1]=invfact[n-i]*(n-i)%mod;\n  ll a[n];\n  a[n-1]=fact[n-1] %mod;\n \n  for(ll i=n-2;i>=n-i;i--){\n    a[i]=fact[i]*comb(i-1,n-1-i) %mod;\n    a[i]=a[i]*fact[n-i-1]%mod;\n    a[i+1]=(a[i+1]-a[i]+mod) %mod;\n    }\n  ll ans=0;\n  for(ll i=n-1;i>=n-i;i--){\n    ans+=a[i]*i;\n    ans%=mod;\n    }\n  cout<<ans%mod<<endl;\n  return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst ll MOD=1000000007;\nconst ll MAX=1200000;\nll n,fin,fac[MAX],use[MAX],cum[MAX],sum;\nll power(ll x,ll y){\n    if(y==0) return 1;\n    ll t=power(x,y/2);\n    if(y%2) return t*t%MOD*x%MOD;\n    return t*t%MOD;\n}\nll comb(ll x,ll y){\n    return fac[x]*power(fac[y],MOD-2)%MOD*power(fac[x-y],MOD-2)%MOD;\n}\nint main(){\n    scanf(\"%lld\",&n);\n    fac[0]=1;\n    for(ll i=1;i<=n;i++) fac[i]=fac[i-1]*i%MOD;\n    for(ll i=(n+1)/2;i<=n-1;i++) use[i]=comb(i-1,2*i-n)*fac[i]%MOD*fac[n-1-i]%MOD;\n    for(ll i=(n+1)/2;i<=n-1;i++) cum[i]=use[i]-use[i-1]+MOD,sum+=(cum[i]*i)%MOD,sum%=MOD;\n    printf(\"%lld\\n\",sum);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define F first\n#define S second\n#define ld long double\nint const M=1e6+10,inf=1e9+10,mod=1e9+7;\nint fact[M],ans[M];\nint pw(int x,int y)\n{\n\tif(y==0)return 1;\n\tint tmp=pw(x,y/2);\n\tif(y%2==0)return (tmp*tmp)%mod;\n\treturn ((tmp*tmp)%mod*x)%mod;\n}\nint C(int n,int r)\n{\n\tint tmp=fact[r]*fact[n-r];\n\ttmp%=mod;\n\ttmp=pw(tmp,mod-2);\n\ttmp*=fact[n];\n\ttmp%=mod;\n\treturn tmp;\n}\nint say(int n,int r)\n{\n\tint tmp=n-r;\n\tif(tmp==0 && r==0)return 1;\n\tif(tmp<r || r==0)return 0;\n\treturn C(tmp-1,r-1);\n}\nint32_t main()\n{\n\tint n;\n\tcin>>n;\n\tfact[0]=1;\n\t//cout<<C(5,2)<<\" \"<<pw(2,4)<<endl;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfact[i]=fact[i-1]*i;\n\t\tfact[i]%=mod;\n\t}\n\tint all=0;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tif(n-i-1<0)continue;\n\t\tint res=n-i;\n\t\tif(n-2>=res)\n\t\t\tans[i]=say(n-2,res);\n\t\tans[i]*=(res*2)%mod;\n\t\tans[i]%=mod;\n\t\tif(n-2>=res-1){\n\t\t\tans[i]+=say(n-2,res-1)*res;\n\t\t\tans[i]%=mod;\n\t\t}\n\t\tif(n-3>=res)\n\t\t{\n\t\t\tint hlp=say(n-3,res-1)*2;\n\t\t\thlp*=res;\n\t\t\thlp%=mod;\n\t\t\tans[i]+=hlp;\n\t\t\tans[i]%=mod;\n\t\t}\n\t\tint tmp=1;\n\t\ttmp%=mod;\n\t\ttmp*=fact[i-1];\n\t\ttmp%=mod;\n\t\ttmp*=fact[n-i-1];\n\t\ttmp%=mod;\n\t\ttmp*=i;\n\t\ttmp%=mod;\n\t\ttmp*=ans[i];\n\t\ttmp%=mod;\n\t//\tcout<<i<<\" \"<<res<<\" \"<<tmp<<\" \"<<ans[i]<<endl;\n\t\tall+=tmp;\n\t\tall%=mod;\n\t}\n\tcout<<all;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n    friend istream& operator << (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(int e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n};\nusing mn = modnum<1'000'000'007>;\nusing vmn = vector<mn>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    vmn fact(N + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= N; i++)\n        fact[i] = i * fact[i - 1];\n\n    auto ncr = [&fact](int n, int r) {\n        if (r < 0 || n < r) return mn(0);\n        return fact[n] / (fact[r] * fact[n-r]);\n    };\n\n    vmn matl(N);\n    for (int miss = 0; miss <= N - 2; miss++) {\n        mn pick = ncr(N - 2 - miss, miss);\n        matl[miss] = pick * fact[N - 1 - miss] * fact[miss];\n    }\n\n    mn ans = 0;\n    for (int miss = 0; miss <= N - 2; miss++) {\n        ans += (matl[miss] - matl[miss + 1]) * mn(N - 1 - miss);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-4-28 22:56:15\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nconst int MAX_SIZE = 1000010;\nconst long long MOD = 1000000007;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init() {\n  inv[1] = 1;\n  for (int i=2; i<MAX_SIZE; i++) {\n    inv[i] = ((MOD - inv[MOD%i]) * (MOD/i))%MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i=1; i<MAX_SIZE; i++) {\n    fact[i] = (i * fact[i-1])%MOD;\n    factinv[i] = (inv[i] * factinv[i-1])%MOD;\n  }\n}\n\nlong long C(int n, int k) {\n  if (n >=0 && k >= 0 && n-k >= 0) {\n    return ((fact[n] * factinv[k])%MOD * factinv[n-k])%MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n) {\n  if (n == 0) {\n    return 1;\n  } else if (n%2 == 1) {\n    return (x * power(x, n-1)) % MOD;\n  } else {\n    long long half = power(x, n/2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcm(long long a, long long b) {\n  if (a < b) {\n    return gcm(b, a);\n  }\n  if (b == 0) return a;\n  return gcm(b, a%b);\n}\n\nll N;\nll Ika[200010];\n\nint main()\n{\n  init();\n  cin >> N;\n  Ika[0] = Ika[1] = 0;\n  if (N == 2)\n  {\n    Ika[1] = 1;\n  }\n  for (auto A = 2; A <= N - 1; A++)\n  {\n    ll x = N - 1 - A;\n    if (x >= 0 && A >= 0)\n    {\n      Ika[A] = ((C(A - 1, N - 1 - A) * fact[x]) % MOD * fact[A]) % MOD;\n      if (N < 100)\n      {\n        cerr << \"Ika[\" << A << \"] = \" << Ika[A] << endl;\n      }\n    }\n  }\n  ll ans = 0;\n  for (ll A = 1; A <= N - 1; A++)\n  {\n    ans += (A * (Ika[A] + MOD - Ika[A - 1])) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\ntypedef long long int ll;\nconst ll MODP = 1000000007;\n\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n\ntypedef long long int ll;\n\n\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll invMod(ll a, ll m) {\n  ll x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n  else                         return 0; // unsolvable\n}\n\n\nll powmod(ll n, ll m){ //TODO: 繰り返し二乗法に改善\n\tll ret = 1;\n\tfor(int i=0;i<m;i++){\n\t\tret = (ret * n) % MODP;\n\t}\n\treturn ret;\n}\n\n\nll comb(ll n, ll m){\n\tif (m<0 || n<m) return 0; //failsafe\n\tll ret = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tret = (ret * (n-m+i)) % MODP;\n\t\tret = (ret * invMod(i, MODP)) % MODP;\n\t}\n\treturn ret % MODP;\n}\n\n\n\nll n;\nstatic ll f[1000001];\n\nint main(void){\n\tcin >> n;\n\tf[0] = 1;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i] = (f[i-1] * i) % MODP;\n\t}\n\tll ans = f[n], ans2 = 0;\n\tfor(int i=(n+1)/2;i<n;i++){\n\t\tll val = f[i] * f[i-1] % MODP;\n\t\tval = val * invMod(f[2*i-n], MODP) % MODP;\n\t\tval = val * invMod(f[n-1-i], MODP) % MODP;\n\t\tans2 = (ans2 + val) % MODP;\n\t}\n\tans = (ans - ans2 + MODP) % MODP;\n\tcout << ans << endl;\n\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n & 1) return (a * powmod(a, n - 1, mod)) % mod;\n\treturn powmod((a * a) % mod, n / 2, mod);\n}\n\nint mod = 1000000007;\nint n;\nint fact[1000010];\nint factInv[1000010];\nint f[1000010];\n\nvoid initFact() {\n\tfact[0] = 1;\n\tfactInv[0] = 1;\n\tfor (int i = 1; i < 1000010; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t\tfactInv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n}\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * factInv[k] % mod * factInv[n - k] % mod;\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\t\n\tinitFact();\n\t\n\t/*dp[1][1] = 1;\n\tfor (i = 1; i <= n - 2; i++) {\n\t\tfor (j = 1; j <= i; j++) {\n\t\t\tdp[i + 1][j + 1] += dp[i][j] * (j + 1); dp[i + 1][j + 1] %= mod;\n\t\t\tdp[i + 2][j + 1] += dp[i][j] * (j + 1); dp[i + 2][j + 1] %= mod;\n\t\t}\n\t}*/\n\t\n\t//f[j] = dp[n - 1][j] = fact[j] * comb[j - 1][n - 1 - j]. (1 <= j <= n - 1)\n\tfor (i = 1; i < n; i++) {\n\t\tf[i] = fact[i] * comb(i - 1, n - 1 - i) % mod;\n\t\t//cout << i - 1 << \" \" << n - 1 - i << \" \" << comb(i - 1, n - 1 - i) << endl;\n\t\t//cout << \"f[\" << i << \"] = \" << f[i] << endl;\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 1; i <= n - 1; i++) {\n\t\tint cnt = (f[i] - (f[i - 1] * (n - i)) % mod + mod) % mod;\n\t\tcnt *= fact[n - 1 - i];\n\t\tcnt %= mod;\n\t\t//cout << \"i = \" << i << \", dp = \" << dp[n - 1][i] << endl;\n\t\t//cout << i << \" \" << cnt << endl;\n\t\tans += cnt * i;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\ntypedef long long LL;\nconst LL MOD = 1e9+7;\nconst int N = 1000000+10;\n\nLL f[N],inv[N];\n\nLL mpow(LL a, LL x) {\n    if(x==0) return 1;\n    LL t = mpow(a,x/2);\n    if(x%2==0) return t*t%MOD;\n    return t*t%MOD*a%MOD;\n}\n\nvoid init() {\n    inv[0]=f[0]=1;\n    for(int i=1;i<N;i++) {\n        f[i]=f[i-1]*i%MOD;\n        inv[i]=mpow(f[i],MOD-2);\n    }\n}\nLL c(LL n, LL m) {\n    if(n<m) return 0;\n    return f[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\n\nLL g[N];\nint main() {\n    init();\n    LL n; cin >> n;\n    LL ret = 0; \n\n    for(LL k=1;k<=n-1;k++) {\n        g[k]=f[k]*c(k-1,n-1-k)%MOD;\n        //printf(\"%lld %lld %lld\\n\", k, g[k], c(k-1,n-1-k));\n        ret = ret + k*( (g[k]-g[k-1]*(n-k))%MOD+MOD )%MOD*f[n-1-k]%MOD;\n        ret = (ret % MOD + MOD) % MOD;\n    }\n\n    cout<<ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define ff first\n#define ss second\n#define finput ifstream cin;cin.open(\"in.txt\")\n#define foutput ofstream cout;cout.open(\"out.txt\")  \n#define fast ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define mod 1000000007\n\nll gcd(ll x, ll y){ \n\tif(x<y) \n\t\tswap(x,y); \n\tif(x%y==0)\n\t\treturn y;\n\treturn gcd(y, x%y);\n}\n\nll pwm(ll a, ll n){\n\tll ans = 1;\n\twhile(n>0){\n\t\tif(n%2==1){\n\t\t\tans = (ans * a)%mod;\n\t\t}\n\t\ta = (a*a)%mod;\n\t\tn /= 2;\n\t}\n\treturn ans%mod;\n}\n\nconst int pwn = 100010;\nll pw[pwn];\nvoid pwtwo(){\n\tpw[0] = 1;\n\tfor(int i=1; i<pwn; i++){\n\t\tpw[i] = (pw[i-1]*2)%mod;\n\t}\n}\n\n\nll gcdExtended(ll a, ll b, ll *x, ll *y); \n  \nll modInverse(ll a, ll m) \n{ \t\n\tif(a==1)\n\t\treturn 1;\n\t//cout<<\"mi \"<<a<<\" \"<<m<<\" \";\n    ll x, y; \n    ll g = gcdExtended(a, m, &x, &y); \n    if (g != 1){\n        //cout << \"Inverse doesn't exist\"<<endl; \n        return -1;\n    }\n    else\n    { \n        // m is added to handle negative x \n        ll res = (x%m + m) % m; \n        //cout<<res<<endl;\n        return res;\n        // cout << \"modular multiplicative inverse is \" << res; \n    } \n} \n  \nll gcdExtended(ll a, ll b, ll *x, ll *y) \n{ \n    if (a == 0) \n    { \n        *x = 0, *y = 1; \n        return b; \n    } \n  \n    ll x1, y1;\n    ll gcd = gcdExtended(b%a, a, &x1, &y1); \n  \n    *x = y1 - (b/a) * x1; \n    *y = x1; \n  \n    return gcd; \n} \n\nll fact[1000010];\nll init(){\n\tfact[0] = 1;\n\tfor(int i=1; i<1000010; i++)\n\t\tfact[i] = (fact[i-1]*i)%mod;\n}\n\nll ncr(ll n, ll r){\n\tll ans = fact[n];\n\t// cout<<ans<<\" \";\n\tif(r>n)\n\t\treturn 0;\n\t//if(r!=0)\n\tans = (ans*modInverse(fact[r], mod))%mod;\n\t// if(n-r!=0)\n\tans = (ans*modInverse(fact[n-r], mod))%mod;\n\n\treturn ans;\n}\n\nint main(){\n\t// finput;\n\t// foutput;\n\tfast;\n\tinit();\n\t\n\tll n, k, i, j, x, m, r;\n\tcin>>n;\n\n\tll ans = (fact[n-1]*(n-1))%mod;\n\ti = n-2;\n\tll mx = 1;\n\twhile(i>0){\n\t\tj = i-1ll;\n\t\tif(j<mx)\n\t\t\tbreak;\n\t\tll tmp = fact[i];\n\t\tk = mx++;\n\t\twhile(k>0){\n\t\t\ttmp *= j;\n\t\t\ttmp %= mod;\n\t\t\tk--;\n\t\t\tj--;\n\t\t}\n\t\tans -= tmp;\n\t\tans += mod;\n\t\tans %= mod;\n\t\ti--;\n\t}\n\tcout<<ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> II;\ntypedef pair<long long, int> LLI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<II> VII;\n\n#define For(i,a,b) for(int i = a;i <= b; i++)\n#define Rep(i,a,b) for(int i = a;i >= b; i--)\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, f) for(auto i : f)\n#define fi first\n#define se second\n#define pb push_back\n#define sz(s) int(s.size())\n#define reset(f, x) memset(f, x, sizeof(f))\n#define all(x) x.begin(), x.end()\n#define two(x) (1LL << x)\n#define getbit(x, i) ((x >> (i-1)) & 1LL)\n#define onbit(x, i) (x | (1LL << (i-1)))\n#define offbit(x, i) (x & ~(1 << (i-1)))\n\nconst int M = 1e9 + 7;\nconst int N = 1e6 + 1;\n\nint n;\nLL f[N], res, g[N];\n\nLL pw(LL a, int n) {\n    LL res = 1;\n    while (n) {\n        if (n & 1) res = (res*a) % M;\n        a = (a*a) % M;\n        n >>= 1;\n    }\n    return res;\n}\n\nLL C(int k, int n) {\n    LL res = (g[n]*pw(g[k], M-2)) % M;\n    res = (res*pw(g[n-k], M-2)) % M;\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    cin >> n;\n    g[0] = g[1] = 1;\n    For(i, 2, n) g[i] = (g[i-1]*i) % M;\n    //cout << C(1, 2) << \"\\n\";\n    for(int k = (n+1)/2; k < n; k++) {\n        f[k] = (C(n-k-1, k-1)*g[k]) % M;\n        f[k] = (f[k]*g[n-1-k]) % M;\n        res = (res + ((f[k] - f[k-1] + M)*k) % M) % M;\n    }\n    cout << res;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-4-28 22:56:15\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nconst int MAX_SIZE = 1000010;\nconst long long MOD = 1000000007;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init() {\n  inv[1] = 1;\n  for (int i=2; i<MAX_SIZE; i++) {\n    inv[i] = ((MOD - inv[MOD%i]) * (MOD/i))%MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i=1; i<MAX_SIZE; i++) {\n    fact[i] = (i * fact[i-1])%MOD;\n    factinv[i] = (inv[i] * factinv[i-1])%MOD;\n  }\n}\n\nlong long C(int n, int k) {\n  if (n >=0 && k >= 0 && n-k >= 0) {\n    return ((fact[n] * factinv[k])%MOD * factinv[n-k])%MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n) {\n  if (n == 0) {\n    return 1;\n  } else if (n%2 == 1) {\n    return (x * power(x, n-1)) % MOD;\n  } else {\n    long long half = power(x, n/2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcm(long long a, long long b) {\n  if (a < b) {\n    return gcm(b, a);\n  }\n  if (b == 0) return a;\n  return gcm(b, a%b);\n}\n\nll N;\nll Ika[200010];\n\nint main()\n{\n  init();\n  cin >> N;\n  Ika[0] = Ika[1] = 0;\n  if (N == 2)\n  {\n    cout << 1 << endl;\n    return 0;\n  }\n  for (auto A = 2; A <= N - 1; A++)\n  {\n    ll x = N - 1 - A;\n    if (x >= 0 && A >= 0)\n    {\n      Ika[A] = ((C(A - 1, N - 1 - A) * fact[x]) % MOD * fact[A]) % MOD;\n      if (N < 100)\n      {\n        cerr << \"Ika[\" << A << \"] = \" << Ika[A] << endl;\n      }\n    }\n  }\n  ll ans = 0;\n  for (ll A = 1; A <= N - 1; A++)\n  {\n    ans += (A * (Ika[A] + MOD - Ika[A - 1])) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string>\n#include<functional>\nusing namespace std;\ntypedef\tlong long int ll;\n\nint main(){\n    ll N = 1000000007;\n    ll n;\n    cin >> n;\n    ll s = 1;\n    for(ll i= 2; i < n; i++){\n        s = (s*i)%N;\n    }\n    s = (s*(n-1))%N;\n    ll t = 1;\n    for(ll i = 2; i <= n-2; i++){\n        t = (t*i)%N;\n    }\n    if(n==2) t = 0;\n    t = (t*(n-3))%N;\n    ll u = s-t;\n    if(u < 0) u = u+N;\n    cout << u << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <deque>\n#define INF 1e9\n#define MOD 1000000007\n#define MAX_N 1000001\n#define mod(x, M) ((x % M) + M) % M\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll M[MAX_N], S[MAX_N];\n\n\nll mod_pow(ll x, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nll frac[MAX_N];\nvoid init(ll N) {\n    frac[0] = 1;\n    for (ll i = 1; i < N; ++i) {\n        frac[i] = mod(frac[i - 1] * i, MOD);\n    }\n}\n\nll comb(ll n, ll r) {\n    return mod(frac[n] * mod_pow(mod(frac[n - r] * frac[r], MOD), MOD - 2, MOD), MOD);\n}\n\n\nint main() {\n    ll N;\n    cin >> N;\n    init(N);\n    \n    M[0] = 0;\n    for (ll i = 0; i < N; ++i) {\n        if (i - 1 < (N-1) - i) {\n            S[i] = 0;\n        } else {\n            S[i] = mod(comb(i - 1, (N-1) - i) * frac[i], MOD);\n        }\n        if (i != 0) {\n            M[i] = mod(S[i] - mod(S[i - 1] * (N - i), MOD), MOD);\n        }\n    }\n    \n    ll ans = 0;\n    for (ll i = 0; i < N; ++i) {\n        ans = mod(ans + mod(mod(M[i] * frac[(N-1) - i], MOD) * i, MOD), MOD);\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll mod = 1e9+7;\nll f[1000009], fi[1000009];\nll e (ll b, ll E){\n    if(!E) return 1;\n    if(1&E) return b*e(b, E-1) % mod;\n    return e(b * b % mod, E/2);\n}\nll C(ll n, ll m){\n    if( n < m  || m < 0) return 0;\n    return f[n] * fi[m] % mod * fi[n - m] % mod;\n}\nmain(){\n    ll n;\n    cin >> n;\n    f[0] = 1;\n    if(n == 2) {\n        cout << 1 << endl;\n        return 0;\n    }\n    for (ll i= 1; i <= n; i++)\n        f[i] = (f[i-1]*i) % mod;\n    for (ll i= 0; i <= n; i++)\n        fi[i] = e(f[i], mod-2);\n    ll ans = 0;\n    ll X = 0;\n    for (ll i= 2; i <= n-1; i++){\n        ll K = 2*(i-1) - n + 2;\n        ll No = C(i-1, K);\n         No = No * f[n-1-i]  % mod;\n         No = No * f[i] % mod;\n         No = (No-X+ mod ) % mod;\n         X  = (X + No) % mod;\n         ans = (ans + No * i) % mod;\n\n    }\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 1000005\nusing namespace std;\nlong long n, s, M=1e9+7, fac[N]={1,1}, inv[N]={1,1}, fin[N]={1,1};\n\nint main() {\n\tint i;\n\tcin>>n;\n\tfor(i=2; i<=n; i++) {\n\t\tfac[i] = fac[i-1] * i % M;\n\t\tinv[i] = inv[M%i] * (M-M/i) % M;\n\t\tfin[i] = fin[i-1] * inv[i] % M;\n\t}\n\tfor(i=(n+1)/2; i<n; i++) s += fac[i] * fac[i-1] % M * fin[2*i-n] % M;\n\tcout<<(fac[n] - s%M + M) % M;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, fact[10010101], ifact[10010101], ans;\nconstexpr long long int M = 1000000007, m = 79133769, n = 536396504, mask = 1073741823;\n\nstatic inline long long int MR(long long int A){\n    long long int ret((A + M * (m * A & mask)) >> 30);\n    return ret - (ret >= M) * M;\n}\n\nstatic inline long long int Prod(long long int lhs, long long int rhs){\n    return MR(MR(lhs * rhs) * n);\n}\n\nint main(){\n    scanf(\"%lld\", &N);\n    *fact = 1;\n    for(int i = 1; i < N; ++i){\n        fact[i] = Prod(fact[i - 1], i);\n    }\n    long long n = M - 2, r = fact[N - 1];\n    ifact[N - 1] = 1;\n    while(n){\n        if(n & 1){\n            ifact[N - 1] = ifact[N - 1] * r % M;\n        }\n        n /= 2;\n        r = r * r % M;\n    }\n    for(int i = N - 1; i > 0; --i){\n        ifact[i - 1] = Prod(ifact[i], i);\n    }\n    ans = fact[N - 1] * (N - 1);\n    for(int i = N / 2; i < N - 1; ++i){\n        ans += M - Prod(Prod(fact[i], fact[i - 1]), ifact[i * 2 - N]);\n    }\n    ans %= M;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ***********************************************\nAuthor        :dasinlsb\nCreated Time  :2018/6/5 16:12:33\nFile Name     :C:\\dasin\\duipai.cpp\n************************************************ */\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\nconst int N=1000005;\nconst int mod=1000*1000*1000+7;\nint n,ans,fac[N],inv[N];\nint Pow(int x,int y){\n  int t=1;\n  for(;y;y>>=1,x=(ll)x*x%mod)if(y&1)t=(ll)t*x%mod;\n  return t;\n}\nint main(){\n // freopen(\"C:/dasin/aa.in\",\"r\",stdin);\n  //freopen(\"C:/dasin/mine.out\",\"w\",stdout);\n  int i,j;\n  scanf(\"%d\",&n);\n  for(fac[0]=i=1;i<=n;++i)fac[i]=(ll)fac[i-1]*i%mod;\n  inv[n]=Pow(fac[n],mod-2);\n  for(i=n;i;--i)inv[i-1]=(ll)inv[i]*i%mod;\n  int pre=0;\n  for(i=(n+1)/2;i<n;++i){\n    //printf(\"ans %d:  %d,%d,%d \",i,i-1,i,2*i-n);\n    int now=(ll)fac[i-1]*fac[i]%mod*inv[2*i-n]%mod;\n    ans=(ans+(ll)i*(now-pre+mod))%mod;\n    pre=now;\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize (\"-O2\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nll fac[N], inv[N], dp[N];\nint n;\n\nll POW(ll x, ll t){\n\tll res = 1;\n\twhile (t){\n\t\tif (t & 1) res = res * x % MOD;\n\t\tt >>= 1;\n\t\tx = x * x % MOD;\n\t}\n\treturn res;\n}\n\nll nCr(ll x, ll y){\n\tif (y > x || y < 0 || x < 0) return 0;\n\tll res = fac[x];\n\tres = res * inv[y] % MOD;\n\tres = res * inv[x - y] % MOD;\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % MOD, inv[i] = POW(fac[i], MOD - 2);\n\t//cout << nCr(6, 3) << '\\n';\n\tfor (int i = 1; i <= n - 1; i++){\n\t\tdp[i] = nCr(i - 1, n - i - 1);\n\t\tdp[i] = dp[i] * fac[i] % MOD;\n\t\tdp[i] = dp[i] * fac[n - i - 1] % MOD;\n\t}\n\tll sm = 0;\n\tll ans = 0;\n\tfor (int i = 1; i <= n - 1; i++){\n\t//\tcout << dp[i] << '\\n';\n\t\tdp[i] -= sm;\n\t\tdp[i] %= MOD;\n\t\tdp[i] += MOD;\n\t\tdp[i] %= MOD;\n\t\tans = (ans + dp[i] * i % MOD) % MOD;\n\t\tsm = (sm + dp[i]) % MOD;\n\t}\n\tcout << ans;\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 2000006\n\nint n;\n\nlong long int k[MAX];\nlong long int rv[MAX];\n\n#define MOD 1000000007\nlong long int ppow(long long int i, long long int j){\n\tlong long int res = 1;\n\twhile (j){\n\t\tif (j & 1LL){\n\t\t\tres *= i;\n\t\t}\n\t\tj >>= 1LL;\n\t\ti *= i;\n\t\tif (i >= MOD)i %= MOD;\n\t\tif (res >= MOD)res %= MOD;\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tk[0] = 1;\n\tfor (int i = 1; i < MAX; i++){\n\t\tk[i] = k[i - 1];\n\t\tk[i] *= i;\n\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t}\n\trv[MAX - 1] = ppow(k[MAX - 1], MOD - 2);\n\tfor (int i = MAX - 2; i >= 0; i--){\n\t\trv[i] = rv[i + 1];\n\t\trv[i] *= (i+1LL);\n\t\tif (rv[i] >= MOD)rv[i] %= MOD;\n\t}\n}\n\nlong long int K(int a, int b){\n\ta += b;\n\ta--;\n\tif (a < b)return 0;\n\tlong long int up = k[a];\n\tlong long int dw = rv[b]*rv[a-b];\n\tif (dw >= MOD)dw %= MOD;\n\tup *= dw;\n\tif (up >= MOD)up%=MOD;\n\treturn up;\n}\nlong long int comb(int emp){\n\tif (emp == 0)return 1;\n\tint must = emp+1;\n\tint shape = n - emp - must;\n\tif (shape < 0)return 0;\n\treturn K(emp + 1, shape);\n}\n\nint main(){\n\tcin >> n;\n\tinit();\n\tlong long int sum = 0;\n\tlong long int ans = 0;\n\tn--;\n\tfor (int i = 1; i <= n; i++){\n\t\tlong long int until = comb(n - i);\n\t\tlong long int tmp  = until*k[i];\n\t\tif (tmp >= MOD)tmp %= MOD;\n\t\ttmp *= k[n - i];\n\t\tif (tmp >= MOD)tmp %= MOD;\n\t\tlong long int p = tmp;\n\t\ttmp -= sum;\n\t\tif (tmp < 0)tmp += MOD;\n\t\tsum = p;\n\t\tans += tmp*(long long int)(i);\n\t\tif (ans >= MOD)ans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n//拡張ユークリッドの互除法\nint extgcd(int a, int b, int& x, int& y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\n// 階乗、階乗逆元テーブル\nint fact[1100000], fact_inv[1100000];\nint mod_fact(int n, int m) {\n    fact[0] = fact_inv[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        (fact[i] = fact[i - 1] * i) %= m;\n        fact_inv[i] = mod_inverse(fact[i], m);\n    }\n}\n\nint N;\nint mod = 1e9 + 7;\nint f[1100000];\n\nsigned main() {\n    cin >> N;\n    mod_fact(N, mod);\n    int K = N / 2 + N % 2;\n    for (int i = K; i <= N - 1; i++) {\n        f[i] = fact[i - 1] * fact[i] % mod * fact_inv[2 * i - N] % mod;\n    }\n    int ans = f[K] * K % mod;\n    for (int i = K + 1; i <= N - 1; i++) {\n        (ans += (f[i] - f[i - 1] + mod) % mod * i) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n{-# LANGUAGE BangPatterns          #-}\n{-# LANGUAGE CPP                   #-}\n{-# LANGUAGE MagicHash             #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE RecordWildCards       #-}\n{-# LANGUAGE TupleSections         #-}\n{-# LANGUAGE TypeFamilies          #-}\n{-# LANGUAGE UnboxedTuples         #-}\n\nimport           Control.Applicative\nimport           Control.DeepSeq\nimport           Control.Exception\nimport           Control.Monad\nimport           Control.Monad.ST\nimport           Control.Monad.Trans.State.Strict\nimport           Data.Array.Base\nimport           Data.Array.ST                    (STUArray, runSTUArray)\nimport           Data.Bits\nimport           Data.Bool\nimport qualified Data.ByteString.Char8            as B\nimport           Data.Char\nimport           Data.Coerce\nimport qualified Data.Foldable                    as F\nimport           Data.Function\nimport           Data.Int\nimport qualified Data.IntMap.Strict               as IM\nimport qualified Data.IntSet                      as IS\nimport qualified Data.List                        as L\nimport qualified Data.Map.Strict                  as M\nimport           Data.Monoid\nimport           Data.Ord\nimport qualified Data.Set                         as S\nimport           Data.STRef\nimport           Data.Tuple\nimport           Data.Word\nimport           Debug.Trace\nimport           GHC.Arr                          (Array, Ix (..), STArray)\nimport           GHC.Exts\nimport           System.Exit\nimport           System.IO\n--\nimport           GHC.Prim\n\nmain :: IO ()\nmain = do\n    !n <- readLn :: IO Int\n    print $ solve n\n\nlim :: Int\nlim = 1000000\n\nsolve :: Int -> Int\nsolve n = F.foldl' (+%) 0 $ zipWith3 (\\i x y -> (x -% y) *% i) is fs $ 0:fs\n  where\n    is = [div (n + 1) 2 .. n - 1]\n    fs = map f is\n    f k = fact k *% fact (k - 1) /% fact (2 * k - n)\n\n#define MOD 1000000007\n\ninfixl 7 *%, /%\ninfixl 6 +%, -%\n\ntype IntMod = Int\n\n(+%), (-%), (*%), (/%) :: IntMod -> IntMod -> IntMod\n(I# x#) +% (I# y#) = I# ((x# +# y#) `remInt#` MOD#)\n(I# x#) -% (I# y#) = I# ((x# -# y# +# MOD#) `remInt#` MOD#)\n(I# x#) *% (I# y#) = I# ((x# *# y#) `remInt#` MOD#)\n(I# x#) /% (I# y#) = go# y# MOD# 1# 0#\n  where\n    go# a# b# u# v#\n        | isTrue# (b# ># 0#) = case a# `quotInt#` b# of\n            q# -> go# b# (a# -# (q# *# b#)) v# (u# -# (q# *# v#))\n        | otherwise = I# ((x# *# (u# +# MOD#)) `remInt#` MOD#)\n{-# INLINE (+%) #-}\n{-# INLINE (-%) #-}\n{-# INLINE (*%) #-}\n{-# INLINE (/%) #-}\n\nfactCache :: UArray Int Int\nfactCache = runSTUArray $ do\n    fact <- newArray (0, lim) 1\n    F.for_ [2..lim] $ \\i ->\n        unsafeRead fact (i - 1) >>= unsafeWrite fact i . (*% i)\n    return fact\n\nfact :: Int -> Int\nfact = unsafeAt factCache\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n{-# LANGUAGE BangPatterns          #-}\n{-# LANGUAGE CPP                   #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE RecordWildCards       #-}\n{-# LANGUAGE TupleSections         #-}\n{-# LANGUAGE TypeFamilies          #-}\n\nimport           Control.Applicative\nimport           Control.DeepSeq\nimport           Control.Exception\nimport           Control.Monad\nimport           Control.Monad.ST\nimport           Control.Monad.Trans.State.Strict\nimport           Data.Array.Base\nimport           Data.Array.ST                    (STUArray, runSTUArray)\nimport           Data.Bits\nimport           Data.Bool\nimport qualified Data.ByteString.Char8            as B\nimport           Data.Char\nimport           Data.Coerce\nimport qualified Data.Foldable                    as F\nimport           Data.Function\nimport           Data.Int\nimport qualified Data.IntMap.Strict               as IM\nimport qualified Data.IntSet                      as IS\nimport qualified Data.List                        as L\nimport qualified Data.Map.Strict                  as M\nimport           Data.Monoid\nimport           Data.Ord\nimport qualified Data.Set                         as S\nimport           Data.STRef\nimport           Data.Tuple\nimport           Data.Word\nimport           Debug.Trace\nimport           GHC.Arr                          (Array, Ix (..), STArray)\nimport           GHC.Exts\nimport           System.Exit\nimport           System.IO\n\nmain :: IO ()\nmain = do\n    !n <- readLn :: IO Int\n    print $ solve n\n\nlim :: Int\nlim = 1000000\n\nmodulus :: Int\nmodulus = 1000000007\n\ninfixl 7 *%, /%\ninfixl 6 +%, -%\n\n(+%), (-%), (*%), (/%) :: Int -> Int -> Int\nx +% y = case x + y of xy -> if xy < modulus then xy else xy - modulus\nx -% y = case x - y of xy -> if xy >= 0  then xy else xy + modulus\nx *% y = x * y `rem` modulus\nx /% y = go y modulus 1 0\n   where\n     go !a !b !u !v\n       | b > 0 = case a `quot` b of q -> go b (a-q*b) v (u-q*v)\n       | otherwise = x * u `mod` modulus\n{-# INLINE (+%) #-}\n{-# INLINE (-%) #-}\n{-# INLINE (*%) #-}\n{-# INLINE (/%) #-}\n\nfactCache :: UArray Int Int\nfactCache = runSTUArray $ do\n    fact <- newArray (0, lim) 1\n    F.for_ [2..lim] $ \\i ->\n        unsafeRead fact (i - 1) >>= unsafeWrite fact i . (*% i)\n    return fact\n\nsolve :: Int -> Int\nsolve n = F.foldl' (\\x y->(x+y)`rem`modulus) 0 $ zipWith3 (\\i x y -> (x -% y) *% i) is fs $ 0:fs\n  where\n    is = [div (n + 1) 2 .. n - 1]\n    fs = map f is\n    f k = unsafeAt factCache k *% unsafeAt factCache (k - 1)\n      /% unsafeAt factCache (2 * k - n)\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint *fact, *fact_inv;\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint A(int N, int x){\n\tif(N - x < 0 || N - x > x){\n\t\treturn 0;\n\t}\n\treturn (fact[x] * fact_inv[N - x]) % p;\n}\n\nsigned main(){\n\tint N, i, ans = 0;\n\tscanf(\"%lld\", &N);\n\tfact = (int *)malloc(sizeof(int) * (N + 1));\n\tfact_inv = (int *)malloc(sizeof(int) * (N + 1));\n\tfact[0] = 1;\n\tfact_inv[0] = 1;\n\tfact_inv[1] = 1;\n\tfor(i = 1; i <= N; i++){\n\t\tfact[i] = (fact[i - 1] * i) % p;\n\t}\n\tfor(i = 2; i <= N; i++){\n\t\tfact_inv[i] = MOD(-(p / i) * fact_inv[p % i]);\n\t}\n\tfor(i = 1; i <= N; i++){\n\t\tfact_inv[i] = (fact_inv[i] * fact_inv[i - 1]) % p;\n\t}\n//\tprintf(\"test\\n\");\n\tfor(i = 1; i < N; i++){\n\t\tans = (ans + i * MOD(A(N - 1, i) - A(N - 1, i - 1))) % p;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "long m=1e9+7,f[1<<20]={1},v[1<<20]={1},a=1;i;\nlong p(long a,long b){return b?p(a*a%m,b/2)*(b%2?a:1)%m:1;}\nmain(n){\n\tfor(scanf(\"%d\",&n);i++<n;)v[i]=p(f[i]=a=a*i%m,m-2);\n\tfor(i=n/2;i<n;i++)a=(a-f[i]*f[i-1]%m*v[2*i-n]%m+m)%m;\n\tprintf(\"%ld\",a);\n}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\n\nlong long factorial[2097152];\n\nvoid cfact(){\n    long long i;\n    factorial[0]=1ll;\n    factorial[1]=1ll;\n    for(i=2ll;i<2097152ll;i++){\n        factorial[i]=(factorial[i-1]*i)%mod;\n    }\n}\n\nlong long power(long long a, long long b){\n\tlong long x = 1, y = a;\n\twhile (b > 0){\n\t\tif(b%2){\n\t\t\tx = (x*y)%mod;\n\t\t}\n\t\ty = (y*y)%mod;\n\t\tb /= 2;\n\t}\n\treturn x%mod;\n}\n \nlong long modular_inverse(long long n){\n\treturn power(n%mod,mod-2ll);\n}\n\nlong long calcnCr(long long n,long long k){\n\treturn (factorial[n]*((modular_inverse(factorial[k])*modular_inverse(factorial[n-k]))%mod))%mod;\n}\n\nint main(void){\n    cfact();\n    long long bw,x,i,j,n,m,k,a,b,c,w,r=0,l,t,rwp=0,np;\n    scanf(\"%lld\",&n);n--;\n    //l=strlen(s);\n    t=(n-1ll)/2ll;\n    for(i=t;i>=0;i--){\n        if(i!=0){x=i+1ll;np=(calcnCr(n-x,i)%mod);}else{np=1ll;}\n        //printf(\"%lld C %lld = %lld\\n\",n-x,i,np);\n        np*=factorial[n-i];np%=mod;\n        np*=factorial[i];np%=mod;\n        bw=np;\n        if(np>rwp){np-=rwp;np%=mod;}else{np=mod+np-rwp;np%=mod;}\n        //printf(\"<%lld  %lld>\\n\",np,n-i);\n        r+=(((np*(n-i))%mod));r%=mod;\n        rwp%=mod;rwp=bw;\n    }\n    //qsort(a,n,sizeof(int),sortfncsj);\n    printf(\"%lld\\n\",r);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint *fact, *fact_inv;\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint A(int N, int x){\n\tif(N - x < 0 || N - x > x - 1 || x - 1 < 0){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn MOD(MOD(fact[x - 1] * fact_inv[N - x]) * MOD(fact[x] * fact_inv[2 * x - N - 1]));\n\t}\n}\n\nsigned main(){\n\tint N, i, ans = 0;\n\tscanf(\"%lld\", &N);\n\tfact = (int *)malloc(sizeof(int) * (N + 1));\n\tfact_inv = (int *)malloc(sizeof(int) * (N + 1));\n\tfact[0] = 1;\n\tfact_inv[0] = 1;\n\tfact_inv[1] = 1;\n\tfor(i = 1; i <= N; i++){\n\t\tfact[i] = MOD(fact[i - 1] * i);\n\t}\n\tfor(i = 2; i <= N; i++){\n\t\tfact_inv[i] = MOD(-(p / i) * fact_inv[p % i]);\n\t}\n\tfor(i = 1; i <= N; i++){\n\t\tfact_inv[i] = MOD(fact_inv[i] * fact_inv[i - 1]);\n\t}\n\tfor(i = 1; i < N; i++){\n\t\tans = MOD(ans + i * MOD(MOD(fact[N - 1 - i] * A(N - 1, i)) - MOD(fact[N - i] * A(N - 1, i - 1))));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n\n#define MOD 1000000007\nll fact[1000010];\nll invfact[1000010];\nll temp[1000010];\n\nll choose(ll n,ll r){\n\tif(n<0||r<0||r>n)return 0;\n\treturn fact[n]*invfact[r]%MOD*invfact[n-r]%MOD;\n}\n\nint main(){\n\tfact[0]=1;\n\trep(i,1,1000005)fact[i]=fact[i-1]*i%MOD;\n\tinvfact[1000000]=pom(fact[1000000],MOD-2,MOD);\n\tfor(ll i=999999;i>=0;i--)invfact[i]=invfact[i+1]*(i+1)%MOD;\n\t\n\tll n;\n\tscanf(\"%lld\",&n);\n\trep(k,0,n)temp[k]=choose(k-1,n-1-k)*fact[k]%MOD*fact[n-1-k]%MOD;\n\tll ans=0;\n\trep(k,1,n)ans=(ans+k*(temp[k]-temp[k-1]+MOD))%MOD;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 200000000000007LL\n\n#define MOD 1000000007\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n#include <set>\n#include <map>\n\n// using namespace std; // HELL\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n// using std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\n\ntypedef struct {\n\tull s;\n\tull t;\n\tint32_t c;\n} struct_a;\n\ntypedef struct {\n\tint32_t from;\n\tint32_t to;\n\tsll cost;\n} struct_b;\n\n\n\nconst hw vector8[8] = {\n\t{-1, -1},\n\t{-1,  0},\n\t{-1, +1},\n\t{ 0, -1},\n\t{ 0, +1},\n\t{+1, -1},\n\t{+1,  0},\n\t{+1, +1}\n};\n\null n, m;\null h, w;\null k;\null q;\null vua, vub, vuc, vud, vue, vuf;\nsll vsa, vsb, vsc, vsd, vse, vsf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nsize_t slen;\nsize_t tlen;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nvoid printUquotient (ull left, ull right) {\n\tconst int32_t digits = 20;\n\n\tprintf(\"%llu.\", left / right);\n\tleft %= right;\n\tfor (int32_t i = 0; i < digits; i++) {\n\t\tleft *= 10;\n\t\tprintf(\"%1d\", left / right);\n\t\tleft %= right;\n\t}\n\tputs(\"\");\n\n\treturn;\n}\n\nvoid printSquotient (sll left, sll right) {\n\tif (left * right < 0) putchar('-');\n\tprintUquotient(sdiff(left, 0), sdiff(right, 0));\n\n\treturn;\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#ifdef __cplusplus\n\nbool setfind (set<ull> s, ull x) {\n\treturn (s.find(x) != s.end());\n}\n\n#endif\n\nsll dist[N_MAX];\nstruct_b path[M_MAX * 2];\n\n// ull a[N_MAX];\n// ull a[M_MAX];\nsll a[N_MAX];\n// ull a[N_MAX][N_MAX];\n// ull a[M_MAX][M_MAX];\n// sll a[N_MAX][N_MAX];\n// ull b[N_MAX];\n// ull b[M_MAX];\nsll b[N_MAX];\null c[N_MAX];\n// sll c[M_MAX];\n// char c[N_MAX];\n// char s[N_MAX + 1];\nchar s[N_MAX + 1][N_MAX + 1];\n// char s[N_MAX + 1][M_MAX + 1];\n// char t[N_MAX + 1];\n\null alphabets[26];\n// ull blphabets[26];\n// char alphabets[26];\n\n// ull dp[N_MAX + 1];\n// sll dp[N_MAX + 1];\n// ull dp[N_MAX + 1][N_MAX + 1];\n// sll dp[N_MAX + 1][N_MAX + 1];\n// bool dp[N_MAX + 1];\n// bool dp[N_MAX + 1][N_MAX + 1];\n// bool dq[N_MAX];\nhwll arr[N_MAX + 1];\n// hwll arr[M_MAX];\nhwll brr[N_MAX];\n\n// sll dp[N_MAX + 1];\n// ull color[N_MAX];\n// set<sll> children[N_MAX];\n// set<sll> leaf[N_MAX];\n\n\n\ndouble distance (sll x1, sll y1, sll x2, sll y2) {\n\tdouble xdist2, ydist2, origindist, dist;\n\n\txdist2 = (x1 - x2) * (x1 - x2);\n\tydist2 = (y1 - y2) * (y1 - y2);\n\treturn sqrt(xdist2 + ydist2);\n}\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tull l = *(sll*)left;\n\tull r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\null accp (ull a, ull p) {\n\tif (a == 0) {\n\t\treturn 0;\n\t}\n\tif (a == 1) {\n\t\treturn p;\n\t}\n\n\treturn divide((MOD + bitpow(a, p, MOD) - 1) % MOD, a - 1, MOD);\n}\n\nsll dd (sll t, sll x) {\n\tif (x < t) {\n\t\tif ((t - x) % 2) return BIG;\n\t\treturn (t - x) / 2;\n\t} else {\n\t\treturn (x - t);\n\t}\n}\n\nbool func (double x) {\n\tsll i, j;\n\tfor (i = 0; i < n + m; i++) {\n\t\tfor (j = i + 1; j < n + m; j++) {\n\t\t\tif (i < n) {\n\t\t\t\tif (x > (double)c[i]) return false;\n\t\t\t}\n\n\t\t\tdouble rsum = (i < n ? (double)c[i] : x) + (j < n ? (double)c[j] : x);\n\t\t\tdouble actualdist = distance(a[i], b[i], a[j], b[j]);\n\n\t\t\tif (rsum > actualdist) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\null frac[2000000];\null dp[2000000];\n\n\tull d[1000][1000];\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\t// double result = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tull item;\n\tull *dpcell;\n\n\tfor (i = 0; i <= n + 10; i++) {\n\t\tif (i == 0) {\n\t\t\tfrac[i] = 1;\n\t\t} else {\n\t\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\t}\n\t}\n\n\tfor (i = 1; i < n; i++) {\n\t\tif (i < n - i) {\n\t\t\tdp[i] = 0;\n\t\t} else {\n\t\t\t// dp[i] = divide(1, frac[n - i], MOD);\n\t\t\t// dp[i] = divide(divide(frac[i], frac[n - i], MOD), frac[i * 2 - n], MOD);\n\t\t\tdp[i] = divide(divide(frac[i - 1], frac[n - i - 1], MOD), frac[i * 2 - n], MOD);\n\t\t}\n\t\t// printf(\"[%llu][%llu]: %llu\\n\", n, i, dp[i]);\n\t}\n\n\tfor (i = 1; i < n; i++) {\n\t\tull coveri = (frac[i] * dp[i] % MOD) * frac[(n - 1) - i] % MOD;\n\t\tull coveri1 = (frac[i - 1] * dp[i - 1] % MOD) * frac[(n - 1) - (i - 1)] % MOD;\n\t\t// ull yet = frac[n - i];\n\n\t\tull item = ((MOD + coveri - coveri1) % MOD) % MOD;\n\t\t// ull item = (MOD + (coveri % MOD) - (coveri1 % MOD)) % MOD;\n\t\t// item = (((MOD + (frac[i] * dp[i] % MOD) - (frac[i - 1] * dp[i - 1] % MOD)) % MOD) * frac[n - i] % MOD);\n\t\tresult = (result + (item * i) % MOD) % MOD;\n\t\t// printf(\"%lld: %llu...\\n\", i, result);\n\t}\n\n\n\t// for (i = 0; i < 1000; i++) {\n\t// \t// printf(\"%2llu:\", i);\n\t// \tfor (j = 0; j < 1000; j++) {\n\t// \t\tif (i == 0) {\n\t// \t\t\td[i][j] = (j ? 0 : 1);\n\t// \t\t\tcontinue;\n\t// \t\t}\n\t// \t\tif (i == 1) {\n\t// \t\t\td[i][j] = 0;\n\t// \t\t\tcontinue;\n\t// \t\t}\n\n\t// \t\td[i][j] = (i > 0 ? d[i - 1][j - 1] : 0) + (i > 1 ? d[i - 2][j - 1] : 0);\n\t// \t\td[i][j] %= MOD;\n\t// \t\t// printf(\"%4llu \", dp[i][j]);\n\t// \t}\n\t// \t// puts(\"\");\n\t// }\n\t// for (i = 1; i < n; i++) {\n\t// \tif (dp[i] != d[n][i]) {\n\t// \t\tprintf(\"[%llu][%llu] %llu != %llu\\n\", n, i, d[n][i], dp[i]);\n\t// \t}\n\t// }\n\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.12lf\\n\", (double)result);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\tputs(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\t// scanf(\"%lf\", &vda, &vdb);\n\t// scanf(\"%lld%lld%lld%lld\", &vsa, &vsb, &vsc, &vsd);\n\t// scanf(\"%llu%llu\", &vua, &vub, &vuc, &vud);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%*llu%*llu\");\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n);\n\t// scanf(\"%llu%llu\", &vua, &vub, &vuc, &vud, &vue, &vuf);\n\t// scanf(\"%lld%lld\", &vsa, &vsb, &vsc);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%llu\", &c[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &a[n + i]);\n\t// \tscanf(\"%lld\", &b[n + i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &b[i]);\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &a[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%llu\", &q);\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint *fact, *fact_inv;\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint A(int N, int x){\n\tif(N - x < 0 || N - x > x - 1 || x - 1 < 0){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn MOD(MOD(fact[x - 1] * fact_inv[N - x]) * MOD(fact[x] * fact_inv[2 * x - N - 1]));\n\t}\n}\n\nsigned main(){\n\tint N, i, ans = 0;\n\tscanf(\"%lld\", &N);\n\tfact = (int *)malloc(sizeof(int) * (N + 1));\n\tfact_inv = (int *)malloc(sizeof(int) * (N + 1));\n\tfact[0] = 1;\n\tfact_inv[0] = 1;\n\tfact_inv[1] = 1;\n\tfor(i = 1; i <= N; i++){\n\t\tfact[i] = MOD(fact[i - 1] * i);\n\t}\n\tfor(i = 2; i <= N; i++){\n\t\tfact_inv[i] = MOD(-(p / i) * fact_inv[p % i]);\n\t}\n\tfor(i = 1; i <= N; i++){\n\t\tfact_inv[i] = MOD(fact_inv[i] * fact_inv[i - 1]);\n\t}\n\tfor(i = 1; i < N; i++){\n\t\tans = MOD(ans + i * MOD(A(N - 1, i) - A(N - 1, i - 1)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main (void){\nreturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nimport com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type.Int\n\nconst val P = 1000000007L\n\n// Find (x, y, r) such that r = gcd(a,b) and ax + by = r.\nfun extendedGCD(a: Long, b: Long): Triple<Long, Long, Long> {\n  var x0 = 1L\n  var y0 = 0L\n  var z0 = a\n  var x1 = 0L\n  var y1 = 1L\n  var z1 = b\n  while (true) {\n    if (z1 == 0L) return Triple(x0, y0, z0)\n    val q = z0 / z1\n    val x2 = x0 - q * x1\n    val y2 = y0 - q * y1\n    val z2 = z0 - q * z1\n    x0 = x1\n    x1 = x2\n    y0 = y1\n    y1 = y2\n    z0 = z1\n    z1 = z2\n  }\n}\n\nfun inverseMod(a: Long, m: Long): Long {\n  val (x, y, r) = extendedGCD(a, m)\n  if (r != 1L) return 0  // No inverse.\n\n  return (x + m) % m\n}\n\nfun timesMod(x: Long, y: Long): Long {\n  return x * y % P\n}\n\nfun plusMod(x: Long, y: Long): Long {\n  return (x + y) % P\n}\n\nfun minusMod(x: Long, y: Long): Long {\n  return (x - y + P) % P\n}\n\nclass FiniteField(xRaw: Long) {\n  val x = if (xRaw >= 0) xRaw % P else (P - ((-xRaw) % P)) % P\n  constructor(xi: Int): this(xi.toLong())\n  operator fun plus(o: FiniteField) = FiniteField((x + o.x) % P)\n  operator fun plus(o: Int) = this + FiniteField(o)\n  operator fun minus(o: FiniteField) = FiniteField((x + P - o.x) % P)\n  operator fun minus(o: Int) = this - FiniteField(o)\n  operator fun times(o: FiniteField) = FiniteField((x * o.x) % P)\n  operator fun times(o: Int) = this * FiniteField(o)\n  operator fun div(o: FiniteField) = this * inverseMod(o.x, P).toInt()\n  operator fun div(o: Int) = this * FiniteField(o)\n  override fun toString() = x.toString()\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val factorialTable = Array(n, { FiniteField(0L) })\n  factorialTable[0] = FiniteField(1)\n  for (k in 1..(n - 1)) {\n    factorialTable[k] = factorialTable[k - 1] * k\n  }\n  val inverseFactorialTable = factorialTable.map { FiniteField(1) / it }.toTypedArray()\n\n  val fTable = Array(n, { k ->\n    if (2 * k < n) FiniteField(0)\n    else factorialTable[k] * factorialTable[k - 1] / factorialTable[2 * k - n]\n  })\n\n  var ans = FiniteField(0)\n  for (k in 1..(n - 1)) {\n    val count = fTable[k] - fTable[k - 1]\n    ans += count * k\n  }\n  println(ans)\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nimport com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type.Int\n\nconst val P = 1000000007L\n\n// Find (x, y, r) such that r = gcd(a,b) and ax + by = r.\nfun extendedGCD(a: Long, b: Long): Triple<Long, Long, Long> {\n  var x0 = 1L\n  var y0 = 0L\n  var z0 = a\n  var x1 = 0L\n  var y1 = 1L\n  var z1 = b\n  while (true) {\n    if (z1 == 0L) return Triple(x0, y0, z0)\n    val q = z0 / z1\n    val x2 = x0 - q * x1\n    val y2 = y0 - q * y1\n    val z2 = z0 - q * z1\n    x0 = x1\n    x1 = x2\n    y0 = y1\n    y1 = y2\n    z0 = z1\n    z1 = z2\n  }\n}\n\nfun inverseMod(a: Long, m: Long): Long {\n  val (x, y, r) = extendedGCD(a, m)\n  if (r != 1L) return 0  // No inverse.\n\n  return (x + m) % m\n}\n\nfun timesMod(x: Long, y: Long): Long {\n  return x * y % P\n}\n\nfun plusMod(x: Long, y: Long): Long {\n  return (x + y) % P\n}\n\nfun minusMod(x: Long, y: Long): Long {\n  return (x - y + P) % P\n}\n\nclass FiniteField(xRaw: Long) {\n  val x = if (xRaw >= 0) xRaw % P else (P - ((-xRaw) % P)) % P\n  constructor(xi: Int): this(xi.toLong())\n  operator fun plus(o: FiniteField) = FiniteField((x + o.x) % P)\n  operator fun plus(o: Int) = this + FiniteField(o)\n  operator fun minus(o: FiniteField) = FiniteField((x + P - o.x) % P)\n  operator fun minus(o: Int) = this - FiniteField(o)\n  operator fun times(o: FiniteField) = FiniteField((x * o.x) % P)\n  operator fun times(o: Int) = this * FiniteField(o)\n  operator fun div(o: FiniteField) = this * inverseMod(o.x, P).toInt()\n  operator fun div(o: Int) = this * FiniteField(o)\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val factorialTable = LongArray(n)\n  factorialTable[0] = 1\n  for (k in 1..(n - 1)) {\n    factorialTable[k] = (factorialTable[k - 1] * k) % P\n  }\n  val inverseFactorialTable = factorialTable.map { inverseMod(it, P) }.toLongArray()\n\n  val fTable = LongArray(n, { k ->\n    if (2 * k < n) 0\n    else timesMod(\n        timesMod(factorialTable[k], factorialTable[k - 1]), inverseFactorialTable[2 * k - n])\n  })\n\n  var ans = 0L\n  for (k in 1..(n - 1)) {\n    val count = minusMod(fTable[k], fTable[k - 1])\n    ans = plusMod(ans, timesMod(count, k.toLong()))\n  }\n  println(ans)\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nimport com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type.Int\n\nconst val P = 1000000007L\n\n// Find (x, y, r) such that r = gcd(a,b) and ax + by = r.\nfun extendedGCD(a: Long, b: Long): Triple<Long, Long, Long> {\n  var x0 = 1L\n  var y0 = 0L\n  var z0 = a\n  var x1 = 0L\n  var y1 = 1L\n  var z1 = b\n  while (true) {\n    if (z1 == 0L) return Triple(x0, y0, z0)\n    val q = z0 / z1\n    val x2 = x0 - q * x1\n    val y2 = y0 - q * y1\n    val z2 = z0 - q * z1\n    x0 = x1\n    x1 = x2\n    y0 = y1\n    y1 = y2\n    z0 = z1\n    z1 = z2\n  }\n}\n\nfun inverseMod(a: Long, m: Long): Long {\n  val (x, y, r) = extendedGCD(a, m)\n  if (r != 1L) return 0  // No inverse.\n\n  return (x + m) % m\n}\n\nfun timesMod(x: Long, y: Long): Long {\n  return x * y % P\n}\n\nfun plusMod(x: Long, y: Long): Long {\n  return (x + y) % P\n}\n\nfun minusMod(x: Long, y: Long): Long {\n  return (x - y + P) % P\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val factorialTable = LongArray(n)\n  factorialTable[0] = 1\n  for (k in 1..(n - 1)) {\n    factorialTable[k] = (factorialTable[k - 1] * k) % P\n  }\n  val inverseFactorialTable = factorialTable.map { inverseMod(it, P) }.toLongArray()\n\n  val fTable = Array(n, { k ->\n    if (2 * k < n) 0\n    else timesMod(\n        timesMod(factorialTable[k], factorialTable[k - 1]), inverseFactorialTable[2 * k - n])\n  })\n\n  var ans = 0L\n  for (k in 1..(n - 1)) {\n    val count = minusMod(fTable[k], fTable[k - 1])\n    ans = plusMod(ans, timesMod(count, k.toLong()))\n  }\n  println(ans)\n}"
  },
  {
    "language": "Kotlin",
    "code": "val mod = 1000000007L\nval factorialMemo = Array(1000000 + 1){1L}.apply {\n    var r = 1L\n    for (i in 1..1000000){\n        r = r mul i\n        this[i] = r\n    }\n}\nval divFactorialMemo = factorialMemo.map{exp(it, mod - 2)}\nfun factorial(n:Long):Long{\n    var r = 1L\n    for (i in 2..n){\n        r = r mul i\n    }\n    return r\n}\nfun exp(base:Long, exponent:Long):Long {\n    return when(exponent){\n        0L -> 1\n        1L -> base\n        else -> exp(base, exponent / 2).let{it mul it mul exp(base, exponent % 2)}\n    }\n}\ninfix fun Long.div(n:Long):Long {\n    return this mul exp(n, mod - 2)\n}\ninfix fun Long.mul(n:Long):Long {\n    return this * n % mod\n}\ninfix fun Long.mul(n:Int):Long = this mul n.toLong()\ninfix fun Long.plus(n:Long):Long{\n    return (this + n) % mod\n}\ninfix fun Long.minus(n:Long):Long {\n    return (this - n) plus mod\n}\nfun G(N:Int, n:Int):Long {\n    return g(N, n) mul factorialMemo[n] mul factorialMemo[N - n - 1]\n}\nfun g(N:Int, n:Int):Long {\n    return (factorialMemo[N - 1] mul divFactorialMemo[n] mul divFactorialMemo[N - n - 1]) minus f(N, n)\n}\nfun f(N:Int, n:Int):Long{\n    if (2 * n >= N)\n        return factorialMemo[n - 1] mul divFactorialMemo[N - 1 - n] mul divFactorialMemo[2 * n - N]\n    else\n        return 0\n}\nfun main(args:Array<String>):Unit{\n    val n = readLine()!!.toInt()\n    println((0 until n - 1).map{G(n, it)}.fold(0L){a, b -> a plus b})\n}"
  },
  {
    "language": "Kotlin",
    "code": "const val P = 1000000007L\n\n// Find (x, y, r) such that r = gcd(a,b) and ax + by = r.\nfun extendedGCD(a: Long, b: Long): Triple<Long, Long, Long> {\n  var x0 = 1L\n  var y0 = 0L\n  var z0 = a\n  var x1 = 0L\n  var y1 = 1L\n  var z1 = b\n  while (true) {\n    if (z1 == 0L) return Triple(x0, y0, z0)\n    val q = z0 / z1\n    val x2 = x0 - q * x1\n    val y2 = y0 - q * y1\n    val z2 = z0 - q * z1\n    x0 = x1\n    x1 = x2\n    y0 = y1\n    y1 = y2\n    z0 = z1\n    z1 = z2\n  }\n}\n\nfun inverseMod(a: Long, m: Long): Long {\n  val (x, y, r) = extendedGCD(a, m)\n  if (r != 1L) return 0  // No inverse.\n\n  return (x + m) % m\n}\n\nclass FiniteField(xRaw: Long) {\n  val x = if (xRaw >= 0) xRaw % P else (P - ((-xRaw) % P)) % P\n  constructor(xi: Int): this(xi.toLong())\n  operator fun plus(o: Long) = FiniteField((x + o) % P)\n  operator fun plus(o: FiniteField) = this + o.x\n  operator fun minus(o: Long) = FiniteField((x + P - o) % P)\n  operator fun minus(o: FiniteField) = this - o.x\n  operator fun times(o: Long) = FiniteField((x * o) % P)\n  operator fun times(o: FiniteField) = this * o.x\n  operator fun div(o: Long) = this * inverseMod(o, P)\n  operator fun div(o: FiniteField) = this / o.x\n  override fun toString() = x.toString()\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val factorialTable = Array(n, { FiniteField(0L) })\n  factorialTable[0] = FiniteField(1)\n  for (k in 1..(n - 1)) {\n    factorialTable[k] = factorialTable[k - 1] * k\n  }\n\n  val fTable = Array(n, { k ->\n    if (2 * k < n) FiniteField(0)\n    else factorialTable[k] * factorialTable[k - 1] / factorialTable[2 * k - n]\n  })\n\n  var ans = FiniteField(0)\n  for (k in 1..(n - 1)) {\n    val count = fTable[k] - fTable[k - 1]\n    ans += count * k.toLong()\n  }\n  println(ans)\n}"
  },
  {
    "language": "Kotlin",
    "code": "const val P = 1000000007L\n\n// Find (x, y, r) such that r = gcd(a,b) and ax + by = r.\nfun extendedGCD(a: Long, b: Long): Triple<Long, Long, Long> {\n  var x0 = 1L\n  var y0 = 0L\n  var z0 = a\n  var x1 = 0L\n  var y1 = 1L\n  var z1 = b\n  while (true) {\n    if (z1 == 0L) return Triple(x0, y0, z0)\n    val q = z0 / z1\n    val x2 = x0 - q * x1\n    val y2 = y0 - q * y1\n    val z2 = z0 - q * z1\n    x0 = x1\n    x1 = x2\n    y0 = y1\n    y1 = y2\n    z0 = z1\n    z1 = z2\n  }\n}\n\nfun inverseMod(a: Long, m: Long): Long {\n  val (x, y, r) = extendedGCD(a, m)\n  if (r != 1L) return 0  // No inverse.\n\n  return (x + m) % m\n}\n\nclass FiniteField(xRaw: Long) {\n  private var x = if (xRaw >= 0) xRaw % P else (P - ((-xRaw) % P)) % P\n  constructor(xi: Int): this(xi.toLong())\n  operator fun plusAssign(o: Long) {\n    x += o\n    x %= P\n  }\n  operator fun plusAssign(o: FiniteField) {\n    this += o.x\n  }\n  operator fun minusAssign(o: Long) {\n    x += P - o\n    x %= P\n  }\n  operator fun minusAssign(o: FiniteField) {\n    this -= o.x\n  }\n  operator fun timesAssign(o: Long) {\n    x *= o\n    x %= P\n  }\n  operator fun timesAssign(o: FiniteField) {\n    this *= o.x\n  }\n  operator fun divAssign(o: Long) {\n    x *= inverseMod(o, P)\n    x %= P\n  }\n  operator fun divAssign(o: FiniteField) {\n    this /= o.x\n  }\n  override fun toString() = x.toString()\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val factorialTable = Array(n, { FiniteField(0L) })\n  factorialTable[0] = FiniteField(1)\n  for (k in 1..(n - 1)) {\n    factorialTable[k] = FiniteField(1)\n    factorialTable[k] *= factorialTable[k - 1]\n    factorialTable[k] *= k.toLong()\n  }\n\n  val fTable = Array(n, { k ->\n    if (2 * k < n) FiniteField(0)\n    else {\n      val f = FiniteField(1)\n      f *= factorialTable[k]\n      f *= factorialTable[k - 1]\n      f /= factorialTable[2 * k - n]\n      f\n    }\n  })\n\n  var ans = FiniteField(0)\n  for (k in 1..(n - 1)) {\n    val count = FiniteField(0)\n    count += fTable[k]\n    count -= fTable[k - 1]\n    count *= k.toLong()\n    ans += count\n  }\n  println(ans)\n}"
  },
  {
    "language": "Kotlin",
    "code": "const val P = 1000000007L\n\n// Find (x, y, r) such that r = gcd(a,b) and ax + by = r.\nfun extendedGCD(a: Long, b: Long): Triple<Long, Long, Long> {\n  var x0 = 1L\n  var y0 = 0L\n  var z0 = a\n  var x1 = 0L\n  var y1 = 1L\n  var z1 = b\n  while (true) {\n    if (z1 == 0L) return Triple(x0, y0, z0)\n    val q = z0 / z1\n    val x2 = x0 - q * x1\n    val y2 = y0 - q * y1\n    val z2 = z0 - q * z1\n    x0 = x1\n    x1 = x2\n    y0 = y1\n    y1 = y2\n    z0 = z1\n    z1 = z2\n  }\n}\n\nfun inverseMod(a: Long, m: Long): Long {\n  val (x, y, r) = extendedGCD(a, m)\n  if (r != 1L) return 0  // No inverse.\n\n  return (x + m) % m\n}\n\nclass FiniteField(xRaw: Long) {\n  val x = if (xRaw >= 0) xRaw % P else (P - ((-xRaw) % P)) % P\n  constructor(xi: Int): this(xi.toLong())\n  operator fun plus(o: Long) = FiniteField((x + o) % P)\n  operator fun plus(o: FiniteField) = this + o.x\n  operator fun minus(o: Long) = FiniteField((x + P - o) % P)\n  operator fun minus(o: FiniteField) = this - o.x\n  operator fun times(o: Long) = FiniteField((x * o) % P)\n  operator fun times(o: FiniteField) = this * o.x\n  operator fun div(o: Long) = this * inverseMod(o, P)\n  operator fun div(o: FiniteField) = this / o.x\n  override fun toString() = x.toString()\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val factorialTable = Array(n, { FiniteField(0L) })\n  factorialTable[0] = FiniteField(1)\n  for (k in 1..(n - 1)) {\n    factorialTable[k] = factorialTable[k - 1] * k.toLong()\n  }\n\n  val fTable = Array(n, { k ->\n    if (2 * k < n) FiniteField(0)\n    else factorialTable[k] * factorialTable[k - 1] / factorialTable[2 * k - n]\n  })\n\n  var ans = FiniteField(0)\n  for (k in 1..(n - 1)) {\n    val count = fTable[k] - fTable[k - 1]\n    ans += count * k.toLong()\n  }\n  println(ans)\n}"
  },
  {
    "language": "Kotlin",
    "code": "val mod = 1000000007L\n\nfun exp(base:Long, exponent:Long):Long {\n    return when(exponent){\n        0L -> 1\n        1L -> base\n        else -> exp(base, exponent / 2).let{it mul it mul exp(base, exponent % 2)}\n    }\n}\ninfix fun Long.div(n:Long):Long {\n    return this mul exp(n, mod - 2)\n}\ninfix fun Long.mul(n:Long):Long {\n    return this * n % mod\n}\ninfix fun Long.mul(n:Int):Long = this mul n.toLong()\ninfix fun Long.plus(n:Long):Long{\n    return (this + n) % mod\n}\ninfix fun Long.minus(n:Long):Long {\n    return (this - n) plus mod\n}\n\nfun main(args:Array<String>):Unit{\n    val N = readLine()!!.toInt()\n    val factorial = Array(N + 1){1L}.apply{\n        for (i in 1 .. N){\n            this[i] = this[i - 1] mul i\n        }\n    }\n    val divFactorial = factorial.map{exp(it, mod - 2)}\n    val f = Array(N){0L}.apply {\n        for (n in ((N + 1) / 2) until N){\n            this[n] = factorial[n - 1] mul divFactorial[N - 1 - n] mul divFactorial[2 * n - N]\n        }\n    }\n    val g = Array(N){\n        (factorial[N - 1] mul divFactorial[it] mul divFactorial[N - it - 1]) minus f[it]\n    }\n    val G = Array(N){\n        g[it] mul factorial[it] mul factorial[N - it - 1]\n    }\n    println((0 until N - 1).map{G[it]}.fold(0L){a, b -> a plus b})\n}"
  },
  {
    "language": "Kotlin",
    "code": "val mod = 1000000007L\n\nfun exp(base:Long, exponent:Long):Long {\n    return when(exponent){\n        0L -> 1\n        1L -> base\n        else -> exp(base, exponent / 2).let{it mul it mul exp(base, exponent % 2)}\n    }\n}\ninfix fun Long.div(n:Long):Long {\n    return this mul exp(n, mod - 2)\n}\ninfix fun Long.mul(n:Long):Long {\n    return this * n % mod\n}\ninfix fun Long.mul(n:Int):Long = this mul n.toLong()\ninfix fun Long.plus(n:Long):Long{\n    return (this + n) % mod\n}\ninfix fun Long.minus(n:Long):Long {\n    return (this - n) plus mod\n}\n\nfun main(args:Array<String>):Unit{\n    val N = readLine()!!.toInt()\n    val factorial = Array(N + 1){1L}.apply{\n        for (i in 1 .. N){\n            this[i] = this[i - 1] mul i\n        }\n    }\n    val divFactorial = factorial.mapIndexed{index, fact -> if (index % 2 == N % 2) exp(fact, mod - 2) else 0L}\n    val G = Array(N){\n        factorial[N - 1] minus (if (it * 2 >= N) (factorial[it - 1] mul factorial[it] mul divFactorial[2 * it - N]) else 0L)\n    }\n    println((0 until N - 1).map{G[it]}.fold(0L){a, b -> a plus b})\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nimport com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type.Int\n\nconst val P = 1000000007L\n\n// Find (x, y, r) such that r = gcd(a,b) and ax + by = r.\nfun extendedGCD(a: Long, b: Long): Triple<Long, Long, Long> {\n  var x0 = 1L\n  var y0 = 0L\n  var z0 = a\n  var x1 = 0L\n  var y1 = 1L\n  var z1 = b\n  while (true) {\n    if (z1 == 0L) return Triple(x0, y0, z0)\n    val q = z0 / z1\n    val x2 = x0 - q * x1\n    val y2 = y0 - q * y1\n    val z2 = z0 - q * z1\n    x0 = x1\n    x1 = x2\n    y0 = y1\n    y1 = y2\n    z0 = z1\n    z1 = z2\n  }\n}\n\nfun inverseMod(a: Long, m: Long): Long {\n  val (x, y, r) = extendedGCD(a, m)\n  if (r != 1L) return 0  // No inverse.\n\n  return (x + m) % m\n}\n\nfun timesMod(x: Long, y: Long): Long {\n  return x * y % P\n}\n\nfun plusMod(x: Long, y: Long): Long {\n  return (x + y) % P\n}\n\nfun minusMod(x: Long, y: Long): Long {\n  return (x - y + P) % P\n}\n\nclass FiniteField(xRaw: Long) {\n  val x = if (xRaw >= 0) xRaw % P else (P - ((-xRaw) % P)) % P\n  constructor(xi: Int): this(xi.toLong())\n  operator fun plus(o: FiniteField) = FiniteField((x + o.x) % P)\n  operator fun plus(o: Int) = this + FiniteField(o)\n  operator fun minus(o: FiniteField) = FiniteField((x + P - o.x) % P)\n  operator fun minus(o: Int) = this - FiniteField(o)\n  operator fun times(o: FiniteField) = FiniteField((x * o.x) % P)\n  operator fun times(o: Int) = this * FiniteField(o)\n  operator fun div(o: FiniteField) = this * inverseMod(o.x, P).toInt()\n  operator fun div(o: Int) = this * FiniteField(o)\n  override fun toString() = x.toString()\n}\n\nfun main(args: Array<String>) {\n  val n = readLine()!!.toInt()\n  val factorialTable = Array(n, { FiniteField(0L) })\n  factorialTable[0] = FiniteField(1)\n  for (k in 1..(n - 1)) {\n    factorialTable[k] = factorialTable[k - 1] * k\n  }\n\n  val fTable = Array(n, { k ->\n    if (2 * k < n) FiniteField(0)\n    else factorialTable[k] * factorialTable[k - 1] / factorialTable[2 * k - n]\n  })\n\n  var ans = FiniteField(0)\n  for (k in 1..(n - 1)) {\n    val count = fTable[k] - fTable[k - 1]\n    ans += count * k\n  }\n  println(ans)\n}"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  private static void solve() {\n    int n = ni();\n\n    int mod = 1000000000 + 7;\n    long ret = 0;\n    int[][] fif = enumFIF(n + 1, mod);\n    if (n == 2) {\n      System.out.println(1);\n      return;\n    } else if (n == 3) {\n      System.out.println(4);\n      return;\n    }\n\n    long[] a = new long[n];\n    for (int k = (n + 1) / 2; k <= n - 1; k ++) {\n      //k個置く→(n-1-k)個置く\n      long now = 1;\n      now *= fif[0][k];\n      now %= mod;\n      now *= fif[0][n - 1 - k];\n      now %= mod;\n      \n      //k-1個の間に(n-1-k)個を配置\n      now *= C(k-1,n-1-k,mod,fif);\n      now %= mod;\n\n      a[k] = now;\n    }\n    \n    for (int k = (n + 1) / 2; k <= n - 1; k ++) {\n      ret += (a[k] - a[k - 1] + mod) % mod * k;\n      ret %= mod;\n    }\n    System.out.println(ret);\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif)\n  {\n      if(n < 0 || r < 0 || r > n)return 0;\n      return (long)fif[0][n]*fif[1][r]%mod*fif[1][n-r]%mod;\n  }\n  \n  public static int[][] enumFIF(int n, int mod)\n  {\n      int[] f = new int[n+1];\n      int[] invf = new int[n+1];\n      f[0] = 1;\n      for(int i = 1;i <= n;i++){\n          f[i] = (int)((long)f[i-1] * i % mod);\n      }\n      long a = f[n];\n      long b = mod;\n      long p = 1, q = 0;\n      while(b > 0){\n          long c = a / b;\n          long d;\n          d = a; a = b; b = d % b;\n          d = p; p = q; q = d - c * q;\n      }\n      invf[n] = (int)(p < 0 ? p + mod : p);\n      for(int i = n-1;i >= 0;i--){\n          invf[i] = (int)((long)invf[i+1] * (i+1) % mod);\n      }\n      return new int[][]{f, invf};\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class ModuloCombinatorics {\n\t\t/** maximal needed number, N itself is included **/\n\t\tfinal int N;\n\n\t\t/** prime modulo **/\n\t\tfinal int P;\n\n\t\t/** factorials **/\n\t\tfinal int[] fact;\n\n\t\t/** multiplicative inverses, take care to not touch inv[0] **/\n\t\tfinal int[] inv;\n\n\t\t/** inverse factorials **/\n\t\tfinal int[] invFact;\n\n\t\tpublic ModuloCombinatorics(int N, int P) {\n\t\t\tthis.N = N;\n\t\t\tthis.P = P;\n\t\t\tfact = new int[N + 1];\n\t\t\tfact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tfact[i] = (int) ((long) i * fact[i - 1] % P);\n\t\t\t}\n\n\t\t\tinv = new int[N + 1];\n\t\t\tinv[1] = 1;\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tinv[i] = P - (int) ((long) (P / i) * inv[P % i] % P);\n\t\t\t}\n\n\t\t\tinvFact = new int[N + 1];\n\t\t\tinvFact[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tinvFact[i] = (int) ((long) invFact[i - 1] * inv[i] % P);\n\t\t\t}\n\t\t}\n\n\t\tpublic int choose(int n, int k) {\n\t\t\treturn (n < 0 || k < 0 || k > n) ? 0 : (int) ((long) fact[n]\n\t\t\t\t\t* invFact[k] % P * invFact[n - k] % P);\n\t\t}\n\n\t\t/** a^b modulo mod, mod is arbitrary **/\n\t\tstatic public int pow(int a, long b, int mod) {\n\t\t\tif (a < 0 || a >= mod || b < 0) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tint ret = 1;\n\t\t\tfor (; b > 0; b >>= 1) {\n\t\t\t\tif ((b & 1) == 1) {\n\t\t\t\t\tret = (int) ((long) ret * a % mod);\n\t\t\t\t}\n\t\t\t\ta = (int) ((long) a * a % mod);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/** a^b modulo P **/\n\t\tpublic int pow(int a, long b) {\n\t\t\treturn pow(a, b, P);\n\t\t}\n\t}\n\n\tstatic final int P = 1_000_000_007;\n\n\tModuloCombinatorics mc = new ModuloCombinatorics(1_000_010, P);\n\n\tint fast(int n) {\n\t\tif (n < 5) {\n\t\t\treturn slow(n);\n\t\t}\n\n\t\tint diff = n - 2;\n\n\t\tlong ret = 0;\n\n\t\tfor (int twos = diff / 2; twos >= 0; twos--) {\n\t\t\tint ones = diff - twos * 2;\n\n\t\t\tlong total = (long) mc.choose(ones + twos, ones)\n\t\t\t\t\t* (ones + twos - 1) % P;\n\n\t\t\tlong total11;\n\t\t\tif (ones < 2) {\n\t\t\t\ttotal11 = 0;\n\t\t\t} else {\n\t\t\t\ttotal11 = (long) mc.choose(ones + twos - 2, ones - 2)\n\t\t\t\t\t\t* (ones + twos - 1) % P;\n\t\t\t}\n\n\t\t\ttotal -= total11;\n\t\t\tif (total < 0) {\n\t\t\t\ttotal += P;\n\t\t\t}\n\n\t\t\t// but those on the edge can be two\n\t\t\ttotal += 2 * mc.choose(ones + twos, ones) % P;\n\n\t\t\tint len = ones + twos + 1;\n\n\t\t\tret += total * mc.fact[len - 1] % P * mc.fact[n - 1 - len] % P\n\t\t\t\t\t* len % P;\n\t\t}\n\n\t\treturn (int) (ret % P);\n\t}\n\n\tint slow(int n) {\n\t\tint[] p = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tp[i] = i;\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tdo {\n\t\t\tint[] done = new int[n];\n\t\t\tint left = n;\n\n\t\t\tfor (int v : p) {\n\t\t\t\tif (left != 0) {\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t\tleft -= (1 - done[v]) + (1 - done[v + 1]);\n\t\t\t\tdone[v] = done[v + 1] = 1;\n\t\t\t}\n\t\t} while (nextPermutation(p));\n\n\t\treturn ret;\n\t}\n\n\tstatic boolean nextPermutation(int[] a) {\n\t\tint n = a.length;\n\t\tint ptr = n - 1;\n\t\twhile (ptr > 0 && a[ptr - 1] >= a[ptr]) {\n\t\t\tptr--;\n\t\t}\n\n\t\tfor (int i = ptr, j = n - 1; i < j; i++, j--) {\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = tmp;\n\t\t}\n\n\t\tif (ptr <= 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = ptr;; i++) {\n\t\t\tif (a[ptr - 1] < a[i]) {\n\t\t\t\tint tmp = a[ptr - 1];\n\t\t\t\ta[ptr - 1] = a[i];\n\t\t\t\ta[i] = tmp;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid submit() {\n\t\tout.println(fast(nextInt()));\n\t}\n\n\tvoid test() {\n\t\tfor (int n = 2; n <= 12; n++) {\n\t\t\tSystem.err.println(slow(n) + \" \" + fast(n));\n\t\t}\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 1000000007;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int pow(int a, int e) {\n\t\tif (e == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint r = a;\n\t\tfor (int i = 30 - Integer.numberOfLeadingZeros(e); i >= 0; i--) {\n\t\t\tr = mul(r, r);\n\t\t\tif ((e & (1 << i)) != 0) {\n\t\t\t\tr = mul(r, a);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int inv(int a) {\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt() - 1;\n//\t\tSystem.err.println(\"N = \" + n);\n\t\tint facts[] = new int[n + 1];\n\t\tfacts[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfacts[i] = mul(facts[i - 1], i);\n\t\t}\n\t\tint ansNum = mul(facts[n], n), ansDen = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint looseness = 2 * i - n - 1;\n\t\t\tif (looseness < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint curNum = mul(facts[n - i + looseness], facts[i]),\n\t\t\t\tcurDen = facts[looseness];\n//\t\t\tif (i < 10) {\n//\t\t\t\tSystem.err.println(\"i = \" + i + \", ans = \" + mul(curNum, inv(curDen)));\n//\t\t\t}\n\t\t\tansNum = sub(mul(ansNum, curDen), mul(ansDen, curNum));\n\t\t\tansDen = mul(ansDen, curDen);\n\t\t}\n//\t\tSystem.err.println(\"i = \" + n + \", ans = \" + facts[n]);\n\t\tout.print(mul(ansNum, inv(ansDen)));\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n;\n    long[] fac, iFac;\n    int MOD = 1000000007;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        solve();\n    }\n\n    void solve() {\n        fac = new long[n + 1];\n        iFac = new long[n + 1];\n        fillFactorials();\n        long ans = 0;\n        long prevWays = 0;\n        if (n == 2) {\n            ans = 1;\n        } else if (n == 3) {\n            ans = 4;\n        } else {\n            int start = (n % 2 == 0) ? n / 2 : (n + 1) / 2;\n            for (int k = start; k < n; k++) {\n                long ways = (combination(k - 1, n - 1 - k) * fac[k] % MOD) *\n                        fac[n - 1 - k] % MOD;\n                ans = (ans + (ways - prevWays + MOD) % MOD * k % MOD ) % MOD;\n                prevWays = ways;\n            }\n        }\n        System.out.println(ans);\n    }\n\n    long combination(int n, int r) {\n        if (n < r) return 0;\n        if (n < 0) return 0;\n        return fac[n] * iFac[n - r] % MOD * iFac[r] % MOD;\n    }\n\n    void fillFactorials() {\n        fac[0] = 1;\n        iFac[0] = 1;\n        for (int i = 1; i < fac.length; i++) {\n            fac[i] = i * fac[i - 1] % MOD;\n            iFac[i] = (new BigInteger(Long.toString(fac[i]))).modPow(\n                    new BigInteger(Long.toString(MOD - 2)),\n                            new BigInteger(Integer.toString(MOD))).longValue();\n        }\n    }\n\n    /*\n    long power(long a, long b, long mod) {\n        long x = 1;\n        long y = a;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                x = x * y % mod;\n            }\n            y = y * y % mod;\n        }\n    }\n    */\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            final int mod = (int) 1e9 + 7;\n\n            int n = in.nextInt();\n\n            Combination comb = new Combination(n + 1, mod);\n\n            long[] cnt = new long[n];\n            for (int k = 0; k < cnt.length; k++) {\n                // a + b = k - 1\n                // a + 2*b = n - 2\n                final int b = n - k - 1;\n                final int a = k - 1 - b;\n                if (a >= 0 && b >= 0) {\n                    cnt[k] = comb.get(a + b, a) * comb.getFact(k) % mod * comb.getFact(n - 1 - k) % mod;\n                }\n            }\n            long ans = 0;\n            for (int k = 1; k < cnt.length; k++) {\n                ans += (cnt[k] - cnt[k - 1]) * k % mod;\n            }\n            out.println((ans % mod + mod) % mod);\n        }\n\n        public class Combination {\n            final int mod;\n            final int MAX;\n            final long[] fact;\n            final long[] inv;\n            final long[] invfact;\n\n            public Combination(int n, int mod) {\n                this.mod = mod;\n                MAX = n + 1;\n                fact = new long[MAX];\n                invfact = new long[MAX];\n                inv = new long[MAX];\n\n                inv[1] = 1;\n                for (int i = 2; i < inv.length; i++) {\n                    inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n                }\n\n                fact[0] = 1;\n                invfact[0] = 1;\n                for (int i = 1; i < inv.length; i++) {\n                    fact[i] = i * fact[i - 1] % mod;\n                    invfact[i] = inv[i] * invfact[i - 1] % mod;\n                }\n            }\n\n            public long get(int n, int r) {\n                return fact[n] * invfact[n - r] % mod * invfact[r] % mod;\n            }\n\n            public long getFact(int n) {\n                return fact[n];\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC {\n\n    static final int mod = 1000 * 1000 * 1000 + 7;\n    static final int maxn = 1010 * 1000;\n    static int[] f = new int[maxn];\n    static int[] rf = new int[maxn];\n\n    static {\n      f[0] = 1;\n      rf[0] = 1;\n      for (int i = 1; i < maxn; ++i) {\n        f[i] = (int) ((f[i - 1] * (long) i) % mod);\n        rf[i] = IntegerUtils.pow(f[i], mod - 2, mod);\n      }\n    }\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      // int[] a = new int[n - 1];\n      // for (int i = 0; i < n - 1; ++i)\n      //     a[i] = i;\n      // int res = 0;\n      // do {\n      //     int cur = 0;\n      //     boolean[] u = new boolean[n];\n      //     int left = n;\n      //     while (cur < n) {\n      //         if (!u[a[cur]])\n      //             --left;\n      //         if (!u[a[cur] + 1])\n      //             --left;\n      //         u[a[cur]] = true;\n      //         u[a[cur] + 1] = true;\n      //         ++cur;\n      //         if (left == 0) break;\n      //     }\n      //     res += cur;\n      // } while (Permutations.nextPermutation(a));\n      // out.printLine(res);\n\n      long res = 0;\n      for (int k = 0; k < n; ++k) {\n        res += bad(n, k);\n        res %= mod;\n      }\n      out.printLine(res);\n    }\n\n    private long bad(int n, int k) {\n      int missing = n - 1 - k;\n      long good = C(n - 2 - missing, missing);\n      good *= f[missing];\n      good %= mod;\n      good *= f[n - 1 - missing];\n      good %= mod;\n      long bad = f[n - 1] - good;\n      bad = (bad % mod + mod) % mod;\n      return bad;\n    }\n\n    private long C(int n, int k) {\n      if (k < 0 || k > n) {\n        return 0;\n      }\n      return ((f[n] * (long) rf[k]) % mod * (long) rf[n - k]) % mod;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class IntegerUtils {\n\n    public static int pow(long x, long y, int mod) {\n      x %= mod;\n      long res = 1;\n      while (y > 0) {\n        if (y % 2 == 1) {\n          --y;\n          res = (res * x) % mod;\n        } else {\n          y /= 2;\n          x = (x * x) % mod;\n        }\n      }\n      return (int) (res % mod);\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint mod = 1000000007;\n\t\tint[][] fif = enumFIF(1000005, mod);\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 1;i <= n-1;i++){\n\t\t\ta[i] = C(n-2-(n-1-i), n-1-i, mod, fif)\n\t\t\t\t\t * fif[0][n-1-i] % mod\n\t\t\t\t\t * fif[0][n-1-(n-1-i)];\n\t\t\ta[i] %= mod;\n\t\t}\n\t\tlong ret = 0;\n\t\tfor(int i = n-1;i >= 1;i--){\n\t\t\ta[i] -= a[i-1];\n\t\t\tret += a[i] * i;\n\t\t\tret %= mod;\n\t\t}\n\t\tif(ret < 0)ret += mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tint n;\n\tlong mo = 1_000_000_000 + 7;\n\tlong[] fac = new long[3000000];\n\tlong[] ifac = new long[3000000];\n\tlong[] inv = new long[3000000];\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i) {\n\t\t\tfac[i] = i * fac[i - 1] % mo;\n\t\t}\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = mo - inv[(int) (mo % i)] * (mo / i) % mo;\n\t\t}\n\t\tifac[0] = 1;\n\t\tfor (int i = 1; i < ifac.length; ++i) {\n\t\t\tifac[i] = ifac[i - 1] * inv[i] % mo;\n\t\t}\n\t}\n\n\tlong comb(int n, int k) {\n\t\treturn fac[n] * ifac[n - k] % mo * ifac[k] % mo;\n\t}\n\n\tlong g(int k) {\n\t\tif (2 * k < n)\n\t\t\treturn 0;\n\t\tint a = 2 * k - n;\n\t\tint b = n - k;\n\t\treturn comb(a - 1 + b, b - 1) * fac[k] % mo * fac[n - 1 - k] % mo;\n\t}\n\n\tlong f(int k) {\n\t\treturn (g(k) - g(k - 1) + mo) % mo;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tn = (int) sc.nextLong();\n\t\tlong ans = 0;\n\t\tfor (int i = (n + 1) / 2; i <= n - 1; ++i) {\n\t\t\tans = (ans + f(i) * i % mo) % mo;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tlong pow(long a, long n) {\n\t\tlong ret = 1;\n\t\tfor (; n > 0; n >>= 1, a = a * a % mo) {\n\t\t\tif (n % 2 == 1) {\n\t\t\t\tret = ret * a % mo;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong inv(long a) {\n\t\treturn pow(a, mo - 2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc023;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    private static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = in.nextInt();\n        prec(n+10);\n\n        if (n <= 2) {\n            out.println(1);\n            out.flush();\n            return;\n        }\n\n        long[] wayK = new long[n];\n        for (int k = 2 ; k <= n-1 ; k++) {\n            long A = _fact[k] * _fact[n-1-k] % MOD;\n            long gap = n-1-k-1;\n            if (gap >= 0) {\n                long left = k-2-gap;\n                long all = left+n-k-1;\n                A *= comb(all, left);\n                A %= MOD;\n            }\n            wayK[k] = A;\n        }\n\n        long total = 0;\n        for (int i = 1 ; i <= n-1 ; i++) {\n            total += ((wayK[i] - wayK[i-1] + MOD) % MOD) * i % MOD;\n            total %= MOD;\n        }\n        out.println(total);\n        out.flush();\n\n    }\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x % 2 != 0) {\n                res = (res * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD - 2) % MOD;\n    }\n\n    static long[] _fact;\n    static long[] _invfact;\n\n    static long comb(long ln, long lr) {\n        int n = (int) ln;\n        int r = (int) lr;\n        if (n < 0 || r < 0 || r > n) {\n            return 0;\n        }\n        if (r > n / 2) {\n            r = n - r;\n        }\n        return (((_fact[n] * _invfact[n - r]) % MOD) * _invfact[r]) % MOD;\n    }\n\n    static void prec(int n) {\n        _fact = new long[n + 1];\n        _invfact = new long[n + 1];\n        _fact[0] = 1;\n        _invfact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            _fact[i] = _fact[i - 1] * i % MOD;\n            _invfact[i] = inv(_fact[i]);\n        }\n    }\n\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader input =\n            new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(input.readLine());\n        cal(n);\n    }\n\n\n    static void cal(int n) {\n        long sum = 0;\n        long last = 0;\n        for (int i=2+(n-2)/2; i<=n-1; i++) {\n            last = perm(n-3,i-2) * comb(i,i) * comb(n-3-i, n-3-i) - last;\n            \n            sum += last * i;\n            sum %= 1e9+7;\n            //System.out.println(\"i=\"+i+\"; \" + perm(n-3,i-2) + \" \" + comb(i,i)+ \" \" +comb(n-3-i, n-3-i));\n        }\n        System.out.println(sum);\n    }\n\n\n    public static long comb(int n, int r) {\n        long ret = 1;\n        for (int i=0; i<r; i++) {\n            ret *= n-i;\n            ret %= 1e9+7;\n        }\n        return ret;\n    }\n\n    public static long perm(int n, int r) {\n        long ret = 1;\n        for (int i=0; i<r; i++) {\n            ret *= n-i;\n            ret /= i+1;\n        }\n        return ret;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic long MOD = 1000000007;\n\t\n\tstatic long inv(long a) {\n\t\treturn eleva(a, (int)MOD - 2);\n\t}\n\t\n\tstatic long eleva(long b, int e) {\n\t\tif (e == 0) return 1;\n\t\tlong ret = eleva(b, e / 2);\n\t\tret *= ret;\n\t\tret %= MOD;\n\t\tif (e % 2 == 1) {\n\t\t\tret *= b;\n\t\t\tret %= MOD;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint N = sc.nextInt();\n\t\tlong[] fact = new long[N], invFact = new long[N];\n\t\tfact[0] = invFact[0] = 1;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t\tinvFact[i] = inv(fact[i]);\n\t\t}\n\t\tlong ans = fact[N-1] * (N-1) % MOD;\n\t\t\n\t\tfor (int k = (N + 1)/2; k < N - 1; k++) {\n\t\t\tlong tmp = (fact[k-1] * fact[k]) % MOD;\n\t\t\ttmp = (tmp * invFact[2*k - N]) % MOD;\n\t\t\tans -= tmp;\n\t\t}\n\t\tans %= MOD; ans += MOD; ans %= MOD;\n\t\tSystem.out.println(ans);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint mod = 1000000007;\n\t\tlong[][] res =  guessLeaned(1000000007, \n\t\t\t\t1, 4, 16, 84, 516, 3696, 30096, 275040, 2786400, 31000320, 375736320, 928152292\n\t\t\t\t);\n\t\t\n\t\tlong[] u = {1, 4, 16};\n\t\tfor(int i = 3;i <= n;i++){\n\t\t\tlong v = f(res, u, i, mod);\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tu[j] = u[j+1];\n\t\t\t}\n\t\t\tu[2] = v;\n\t\t}\n\t\tout.println(u[0]);\n\t}\n\t\n\tpublic static long f(long[][] ged, long[] prevs, long x, int mod)\n\t{\n\t\tint n = ged.length;\n\t\tassert prevs.length == n-1;\n\t\tx -= n-1;\n\t\t\n\t\tlong s = 0;\n\t\tlong tar = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tlong co = 0;\n\t\t\tfor(int j = ged[i].length-1;j >= 0;j--){\n\t\t\t\tco = (co * x + ged[i][j]) % mod;\n\t\t\t}\n\t\t\tif(i < n-1){\n\t\t\t\ts += co * prevs[i];\n\t\t\t\ts %= mod;\n\t\t\t}else{\n\t\t\t\ttar = co;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ret = -invl(tar, mod) * s % mod;\n\t\tif(ret < 0)ret += mod;\n\t\treturn ret;\n\t}\n\t\n\tpublic static long[][] guessLeaned(int mod, long... a)\n\t{\n\t\tint n = a.length;\n\t\t\n\t\t// #formula >= #variable\n\t\t// n-r+2 >= r(r+1)/2\n\t\tfor(int r = n;r >= 1;r--){\n\t\t\tif(n-r+2 < r*(r+1)/2)continue;\n\t\t\tint[][] M = new int[n-r+2][r*(r+1)/2];\n\t\t\tfor(int i = 0;i < n-r+1;i++){\n\t\t\t\tint p = 0;\n\t\t\t\tfor(int j = 0;j < r;j++){\n\t\t\t\t\tlong prod = 1;\n\t\t\t\t\tfor(int k = 0;k <= r-j-1;k++){\n\t\t\t\t\t\tM[i][p++] = (int)(prod*a[i+j]%mod);\n\t\t\t\t\t\tprod = prod * i % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tM[n-r+1][0] = 1;\n\t\t\t\n\t\t\tint[] v = new int[n-r+2];\n\t\t\tv[n-r+1] = 1;\n\t\t\t\n\t\t\tResult res = gaussElimination(M, v, mod);\n\t\t\tif(res.exists){\n\t\t\t\tlong[][] ret = new long[r][];\n\t\t\t\tint p = 0;\n\t\t\t\tfor(int i = 0;i < r;i++){\n\t\t\t\t\tret[i] = new long[r-i];\n\t\t\t\t\tfor(int j = 0;j < r-i;j++){\n\t\t\t\t\t\tret[i][j] = res.sol[p++];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Result gaussElimination(int[][] M, int[] v, int mod)\n\t{\n\t\tint n = M.length, m = M[0].length;\n\t\tint[] head = new int[n];\n\t\t\n\t\t// if not needed, comment out.\n\t\tfor(int[] row : M){\n\t\t\tfor(int i = 0;i < row.length;i++){\n\t\t\t\trow[i] %= mod;\n\t\t\t\tif(row[i] < 0)row[i] += mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Forward Elimination\n\t\tint row = 0;\n\t\tfor(int col = 0;col < m;col++){\n\t\t\t// select pivot\n\t\t\tboolean pivotFound = false;\n\t\t\tout:\n\t\t\tfor(int prow = row;prow < n;prow++){\n\t\t\t\tif(M[prow][col] != 0){\n\t\t\t\t\t// pivot found\n\t\t\t\t\tif(prow != row){\n\t\t\t\t\t\t// swap rows\n\t\t\t\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\t\t\t\tint u = M[prow][k]; M[prow][k] = M[row][k]; M[row][k] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dum = v[prow]; v[prow] = v[row]; v[row] = dum;\n\t\t\t\t\t}\n\t\t\t\t\tpivotFound = true;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!pivotFound)continue;\n\t\t\thead[row] = col;\n\t\t\t\n\t\t\t// diag to 1\n\t\t\tlong imul = invl(M[row][col], mod);\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tM[row][k] = (int)(M[row][k] * imul % mod);\n\t\t\t}\n\t\t\tv[row] = (int)(v[row] * imul % mod);\n\t\t\t\n\t\t\tfor(int j = row+1;j < n;j++){\n\t\t\t\tif(M[j][col] != 0){\n\t\t\t\t\tlong mul = mod-M[j][col];\n\t\t\t\t\tfor(int k = col;k < m;k++){\n\t\t\t\t\t\tM[j][k] = (int)((M[j][k] + M[row][k] * mul) % mod);\n\t\t\t\t\t}\n\t\t\t\t\tv[j] = (int)((v[j] + v[row] * mul) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t\trow++;\n\t\t}\n\t\t\n\t\tResult ret = new Result();\n\t\tret.mat = M;\n\t\tfor(int i = row;i < n;i++){\n\t\t\tif(v[i] != 0){\n\t\t\t\tret.rank = row;\n\t\t\t\tret.exists = false;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = row-1;i >= 0;i--){\n\t\t\tfor(int j = i-1;j >= 0;j--){\n\t\t\t\tif(M[j][head[i]] != 0){\n\t\t\t\t\tlong mul = mod-M[j][head[i]];\n\t\t\t\t\tfor(int k = head[i];k < m;k++){\n\t\t\t\t\t\tM[j][k] = (int)((M[j][k] + M[i][k] * mul) % mod);\n\t\t\t\t\t}\n\t\t\t\t\tv[j] = (int)((v[j] + v[i] * mul) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] retv = new int[m];\n\t\tfor(int i = 0;i < row;i++){\n\t\t\tretv[head[i]] = v[i];\n\t\t}\n\t\t\n\t\tret.sol = retv;\n\t\tret.rank = row;\n\t\tret.exists = true;\n\t\treturn ret;\n\t}\n\t\n\tpublic static class Result\n\t{\n\t\tpublic int[][] mat;\n\t\tpublic int[] sol;\n\t\tpublic int rank;\n\t\tpublic boolean exists;\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \n \npublic class Main implements Runnable {\n \n  public static final int MOD = 1000000007;\n\n  public void run() {\n    BetterScanner scanner = new BetterScanner(System.in);\n\n    int n = scanner.nextInt();\n\n    long[] fact = new long[n];\n    long[] invfact = new long[n];\n\n    fact[0] = 1;\n    for (int i = 1 ; i < n ; i ++) {\n      fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    invfact[n - 1] = pow(fact[n - 1], MOD - 2);\n    for (int i = n - 2 ; i >= 0 ; i --) {\n      invfact[i] = invfact[i + 1] * (i + 1) % MOD;\n    }\n\n    long res = 0;\n    int s = (n + 1) / 2;\n\n    long coeff;\n    if ((n - s) % 2 == 0) {\n      coeff = - (n - s) / 2;\n    } else {\n      coeff = - (n - s) / 2 + n - 1;\n    }\n\n    for (; s <= n - 1 ; s ++) {\n      long val = fact[s - 1] * fact[s] % MOD * invfact[2 * s - n] % MOD;\n      res = (coeff * val % MOD + res) % MOD;\n      coeff = -coeff + s;\n    }\n\n    System.out.println(res);\n  }\n\n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    } else if (b % 2 == 0) {\n      long d = pow(a, b / 2);\n      return (d * d) % MOD;\n    } else {\n      long d = pow(a, b - 1);\n      return (a * d) % MOD;\n    }\n  }\n\n  public static void main(String[] args) {\n    Main main = new Main();\n    main.run();\n  }\n \n  // scanner slightly faster than usual ones\n  public static class BetterScanner {\n \n    private InputStream stream;\n    private byte[] buffer = new byte[1024];\n    private int pointer = 0;\n    private int bufferLength = 0;\n \n    public BetterScanner(InputStream stream) {\n      this.stream = stream;\n    }\n \n    private boolean updateBuffer() {\n      if (pointer >= bufferLength) {\n        pointer = 0;\n        try {\n          bufferLength = stream.read(buffer);\n        } catch (IOException exception) {\n          exception.printStackTrace();\n        }\n        return bufferLength > 0;\n      } else {\n        return true;\n      }\n    }\n \n    private int read() {\n      if (updateBuffer()) {\n        return buffer[pointer ++];\n      } else {\n        return -1;\n      }\n    }\n \n    public boolean hasNext() {\n      skipUnprintable();\n      return updateBuffer();\n    }\n \n    private void skipUnprintable() { \n      while (updateBuffer() && !isPrintableChar(buffer[pointer])) {\n        pointer ++;\n      }\n    }\n \n    public String next() {\n      if (hasNext()) {\n        StringBuilder builder = new StringBuilder();\n        int codePoint = read();\n        while (isPrintableChar(codePoint)) {\n          builder.appendCodePoint(codePoint);\n          codePoint = read();\n        }\n        return builder.toString();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n \n    public long nextLong() {\n      if (hasNext()) {\n        long number = 0;\n        boolean minus = false;\n        int codePoint = read();\n        if (codePoint == '-') {\n          minus = true;\n          codePoint = read();\n        }\n        if (codePoint >= '0' && codePoint <= '9') {\n          while (true) {\n            if (codePoint >= '0' && codePoint <= '9') {\n              number *= 10;\n              number += codePoint - '0';\n            } else if (codePoint < 0 || !isPrintableChar(codePoint)) {\n              return (minus) ? -number : number;\n            } else {\n              throw new NumberFormatException();\n            }\n            codePoint = read();\n          }\n        } else {\n          throw new NumberFormatException();\n        }\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n \n    public int nextInt() {\n      long number = nextLong();\n      if (number >= Integer.MIN_VALUE && number <= Integer.MAX_VALUE) {\n        return (int)number;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n \n    private boolean isPrintableChar(int codePoint) {\n      return codePoint >= 33 && codePoint <= 126;\n    }\n \n  }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        static final long MODULO = (long) (1e9 + 7);\n        static int[] invs;\n        static int[] facts;\n        static int[] invfacts;\n\n        static {\n            int k = (int) 2e6;\n            invs = new int[k + 2];\n            invs[1] = 1;\n            for (int i = 2; i <= k + 1; ++i) {\n                invs[i] = (int) ((MODULO - (MODULO / i) * (long) invs[(int) (MODULO % i)] % MODULO) % MODULO);\n            }\n            facts = new int[k + 2];\n            invfacts = new int[k + 2];\n            facts[0] = 1;\n            invfacts[0] = 1;\n            for (int i = 1; i <= k + 1; ++i) {\n                facts[i] = (int) (facts[i - 1] * (long) i % MODULO);\n                invfacts[i] = (int) (invfacts[i - 1] * (long) invs[i] % MODULO);\n            }\n        }\n\n        static long c(int n, int k) {\n            if (k < 0 || k > n) return 0;\n            return facts[n] * (long) invfacts[k] % MODULO * (long) invfacts[n - k] % MODULO;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long res = 0;\n            for (int k = 1; k <= n - 1; ++k) {\n                long ways = c(n - 2 - k, k);\n                ways = ways * facts[k] % MODULO;\n                ways = ways * facts[n - 1 - k] % MODULO;\n                res = (res + ways) % MODULO;\n            }\n            res = (facts[n - 1] * (long) (n - 1) % MODULO - res + MODULO) % MODULO;\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Iterator;\nimport java.util.PrimitiveIterator;\nimport java.util.Scanner;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\naaaaaaaaaaaaaaaa\npublic class Main{\n\tstatic Scanner s=new Scanner(System.in);\n\t\n\tint factsum[]=new int[1000001],fact[]=new int[1000001];\n\tprivate static final int MOD=1000000007;\n\t{\n\t\tfactsum[1]=1;\n\t\tfor(int i:rep(2,1000000)) {\n\t\t\tfact[i]=factsum[i]=(int)(((long)i*factsum[i-1])%MOD);\n\t\t\tfactsum[i]+=fact[i-1];\n\t\t\tfactsum[i]%=MOD;\n\t\t}\n\t}\n\tvoid solve(){\n\t\tint n=gInt();\n\t\tint min=(n+1)/2;\n\t\tint max=n-1;\n\t\tlong r=0;\n\t\tfor(int firstfill:rep(min,max)) {\n\t\t\tlong v=(long)firstfill*fact[firstfill]%MOD*(factsum[n-1]-factsum[firstfill]+1)%MOD;\n\t\t\tSystem.err.println(v);\n\t\t\tr+=v;\n\t\t\tr%=MOD;\n\t\t}\n\t\tSystem.out.println(r);\n\t}\n\n\tpublic static void main(String[] $){\n\t\tnew Main().solve();\n\t}\n\n\tstatic int gInt(){\n\t\treturn Integer.parseInt(s.next());\n\t}\n\tstatic long gLong(){\n\t\treturn Long.parseLong(s.next());\n\t}\n\tstatic double gDouble(){\n\t\treturn Double.parseDouble(s.next());\n\t}\n\n\tSupplyingIterator<Integer> ints(int n){\n\t\treturn new SupplyingIterator<>(n,Main::gInt);\n\t}\n\tSupplyingIterator<Long> longs(int n){\n\t\treturn new SupplyingIterator<>(n,Main::gLong);\n\t}\n\tSupplyingIterator<Double> doubles(int n){\n\t\treturn new SupplyingIterator<>(n,Main::gDouble);\n\t}\n\tSupplyingIterator<String> strs(int n){\n\t\treturn new SupplyingIterator<>(n,s::next);\n\t}\n\n\tRange rep(int i){\n\t\treturn Range.rep(i);\n\t}\n\tRange rep(int f,int t,int d){\n\t\treturn Range.rep(f,t,d);\n\t}\n\tRange rep(int f,int t){\n\t\treturn rep(f,t,1);\n\t}\n\tRange rrep(int f,int t){\n\t\treturn rep(t,f,-1);\n\t}\n\n\tIntStream REP(int v){\n\t\treturn IntStream.range(0,v);\n\t}\n\tIntStream REP(int l,int r){\n\t\treturn IntStream.rangeClosed(l,r);\n\t}\n\n\tIntStream INTS(int n){\n\t\treturn IntStream.generate(Main::gInt).limit(n);\n\t}\n\tStream<String> STRS(int n){\n\t\treturn Stream.generate(s::next).limit(n);\n\t}\n\n}\nclass SupplyingIterator<T> implements Iterable<T>,Iterator<T>{\n\tint\t\t\tt;\n\tSupplier<T>\tsupplier;\n\n\tSupplyingIterator(int t,Supplier<T> supplier){\n\t\tthis.t=t;\n\t\tthis.supplier=supplier;\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator(){\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean hasNext(){\n\t\treturn t>0;\n\t}\n\n\t@Override\n\tpublic T next(){\n\t\t--t;\n\t\treturn supplier.get();\n\t}\n\n}\nclass Range implements Iterable<Integer>,PrimitiveIterator.OfInt{\n\tint to,cur,d;\n\n\tRange(int from,int to,int d){\n\t\tthis.cur=from-d;\n\t\tthis.to=to;\n\t\tthis.d=d;\n\t}\n\n\tRange(int n){\n\t\tthis(0,n-1,1);\n\t}\n\n\t@Override\n\tpublic Iterator<Integer> iterator(){\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean hasNext(){\n\t\treturn cur+d==to||(cur!=to&&(cur<to==cur+d<to));\n\t}\n\n\t@Override\n\tpublic int nextInt(){\n\t\treturn cur+=d;\n\t}\n\n\tstatic Range rep(int i){\n\t\treturn new Range(i);\n\t}\n\tstatic Range rep(int f,int t,int d){\n\t\treturn new Range(f,t,d);\n\t}\n\tstatic Range rep(int f,int t){\n\t\treturn rep(f,t,1);\n\t}\n\tstatic Range rrep(int f,int t){\n\t\treturn rep(f,t,-1);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  private static void solve() {\n    int n = ni();\n\n    int mod = 1000000000 + 7;\n    long ret = 0;\n    int[][] fif = enumFIF(n + 1, mod);\n    if (n == 2) {\n      System.out.println(1);\n      return;\n    } else if (n == 3) {\n      System.out.println(2);\n      return;\n    }\n\n    long[] a = new long[n];\n    for (int k = (n + 1) / 2; k <= n - 1; k ++) {\n      //k個置く→(n-1-k)個置く\n      long now = 1;\n      now *= fif[0][k];\n      now %= mod;\n      now *= fif[0][n - 1 - k];\n      now %= mod;\n      \n      //k-1個の間に(n-1-k)個を配置\n      now *= C(k-1,n-1-k,mod,fif);\n      now %= mod;\n\n      a[k] = now;\n    }\n    \n    for (int k = (n + 1) / 2; k <= n - 1; k ++) {\n      ret += (a[k] - a[k - 1] + mod) % mod * k;\n      ret %= mod;\n    }\n    System.out.println(ret);\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif)\n  {\n      if(n < 0 || r < 0 || r > n)return 0;\n      return (long)fif[0][n]*fif[1][r]%mod*fif[1][n-r]%mod;\n  }\n  \n  public static int[][] enumFIF(int n, int mod)\n  {\n      int[] f = new int[n+1];\n      int[] invf = new int[n+1];\n      f[0] = 1;\n      for(int i = 1;i <= n;i++){\n          f[i] = (int)((long)f[i-1] * i % mod);\n      }\n      long a = f[n];\n      long b = mod;\n      long p = 1, q = 0;\n      while(b > 0){\n          long c = a / b;\n          long d;\n          d = a; a = b; b = d % b;\n          d = p; p = q; q = d - c * q;\n      }\n      invf[n] = (int)(p < 0 ? p + mod : p);\n      for(int i = n-1;i >= 0;i--){\n          invf[i] = (int)((long)invf[i+1] * (i+1) % mod);\n      }\n      return new int[][]{f, invf};\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tint n;\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tn = in.nextInt();\n\t\t\tif (n == 1) {\n\t\t\t\tout.println(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int k = 1; k < n; k++) {\n\t\t\t\tans += k * (MOD + f(k) - f(k-1)) % MOD;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t\tout.println(ans % MOD);\n\n\t\t}\n\n\t\tlong f(int k) {\n\t\t\treturn comb(k-1, n-k-1) * fact[k] % MOD * fact[n-k-1] % MOD;\n\t\t}\n\t}\n\n\tpublic static long comb(int n, int r) {\n\t\tif (r < 0 || r > n)\n\t\t\treturn 0L;\n\t\treturn fact[n] % MOD * factInv[r] % MOD * factInv[n - r] % MOD;\n\t}\n\n\tpublic static int MAXN = 1000000;\n\n\tstatic long[] fact = factorialArray(MAXN, MOD);\n\tstatic long[] factInv = factorialInverseArray(MAXN, MOD,\n\t\t\tinverseArray(MAXN, MOD));\n\n\tpublic static long[] factorialArray(int maxN, long mod) {\n\t\tlong[] fact = new long[maxN + 1];\n\t\tfact[0] = 1 % mod;\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tfact[i] = fact[i - 1] * i % mod;\n\t\t}\n\t\treturn fact;\n\t}\n\n\tpublic static long[] inverseArray(int maxN, long modP) {\n\t\tlong[] inv = new long[maxN + 1];\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i <= maxN; i++) {\n\t\t\tinv[i] = modP - (modP / i) * inv[(int) (modP % i)] % modP;\n\t\t}\n\t\treturn inv;\n\t}\n\n\tpublic static long[] factorialInverseArray(int maxN, long modP,\n\t\t\tlong[] inverseArray) {\n\t\tlong[] factInv = new long[maxN + 1];\n\t\tfactInv[0] = 1;\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tfactInv[i] = factInv[i - 1] * inverseArray[i] % modP;\n\t\t}\n\t\treturn factInv;\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(int n) {\n\t\t\tint[] res = new int[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i + 1] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(int n) {\n\t\t\tlong[] res = new long[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i + 1] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic long MOD = 1000000007;\n\t\n\tstatic long inv(long a) {\n\t\treturn eleva(a, (int)MOD - 2);\n\t}\n\t\n\tstatic long eleva(long b, int e) {\n\t\tif (e == 0) return 1;\n\t\tlong ret = eleva(b, e / 2);\n\t\tret *= ret;\n\t\tret %= MOD;\n\t\tif (e % 2 == 1) {\n\t\t\tret *= b;\n\t\t\tret %= MOD;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint N = sc.nextInt();\n\t\tlong[] fact = new long[N], invFact = new long[N];\n\t\tfor (int i = 2; i < N; i++) if (invFact[i] == 0) {\n\t\t\tfor (int j = i; j < N; j+=i) {\n\t\t\t\tinvFact[j] = i;\n\t\t\t}\n\t\t}\n\t\tfact[0] = invFact[0] = fact[1] = invFact[1] = 1;\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t\tint p = (int)invFact[i];\n\t\t\tif (p == i) {\n\t\t\t\tinvFact[i] = inv(i);\n\t\t\t} else {\n\t\t\t\tinvFact[i] = (invFact[p] * invFact[i/p]) % MOD;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tinvFact[i] = (invFact[i] * invFact[i-1]) % MOD;\n\t\t}\n\t\tlong ans = fact[N-1] * (N-1) % MOD;\n\t\t\n\t\tfor (int k = (N + 1)/2; k < N - 1; k++) {\n\t\t\tlong tmp = (fact[k-1] * fact[k]) % MOD;\n\t\t\ttmp = (tmp * invFact[2*k - N]) % MOD;\n\t\t\tans -= tmp;\n\t\t}\n\t\tans %= MOD; ans += MOD; ans %= MOD;\n\t\tSystem.out.println(ans);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    final FastScanner in = new FastScanner(System.in);\n\n    final long MOD = (long)((1e9) + 7);\n\n    /* MOD_CALCULATION */\n    long ADD(long a, long b) {\n        return (a + b) % MOD;\n    }\n\n    long SUB(long a, long b) {\n        return (a - b + MOD) % MOD;\n    }\n\n    long MULT(long a, long b) {\n        return (a * b) % MOD;\n    }\n\n    long POW(long a, long x) {\n        long res = 1;\n        for ( ; x > 0; x >>= 1) {\n            if (x % 2 == 1) res = MULT(res, a);\n            a = MULT(a, a);\n        }\n\n        return res;\n    }\n\n    long DIV(long a, long b) {\n        return MULT(a, POW(b, MOD - 2));\n    }\n    /* end */\n\n    public void solve() {\n        int N = in.nextInt();\n        if (N == 2) {\n            System.out.println(1);\n            return;\n        } else if (N == 3) {\n            System.out.println(4);\n            return;\n        }\n\n        long[] fact = new long[N+1];\n        fact[0] = 1;\n        for (int i = 0; i < N; i++) {\n            fact[i+1] = MULT(fact[i], i + 1);\n        }\n        long[] inv = new long[N+1];\n        inv[N] = DIV(1, fact[N]);\n        for (int i = N - 1; i >= 0; i--) {\n            inv[i] = MULT(inv[i+1], i + 1);\n        }\n\n        long res = 0;\n        long[] cnt = new long[N];\n        for (int K = 1; K <= N - 1; K++) {\n            if (2 * K < N) {\n                continue;\n            }\n            long comb = MULT(MULT(fact[K-1], inv[N-1-K]), inv[2*K-N]);\n            cnt[K] = MULT(comb, MULT(fact[K], fact[N-1-K]));\n            res = ADD(res, MULT(K, SUB(cnt[K], cnt[K-1])));\n        }\n        System.out.println(res);\n    }\n\n    public static void main(final String[] args) {\n        new Main().solve();\n    }\n\n    class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n            // stream = new FileInputStream(new File(\"dec.in\"));\n\n        }\n\n        int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        boolean isEndline(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; i++)\n                array[i] = nextInt();\n\n            return array;\n        }\n\n        int[][] nextIntMap(int n, int m) {\n            int[][] map = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                map[i] = in.nextIntArray(m);\n            }\n            return map;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        long[] nextLongArray(int n) {\n            long[] array = new long[n];\n            for (int i = 0; i < n; i++)\n                array[i] = nextLong();\n\n            return array;\n        }\n\n        long[][] nextLongMap(int n, int m) {\n            long[][] map = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                map[i] = in.nextLongArray(m);\n            }\n            return map;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        double[] nextDoubleArray(int n) {\n            double[] array = new double[n];\n            for (int i = 0; i < n; i++)\n                array[i] = nextDouble();\n\n            return array;\n        }\n\n        double[][] nextDoubleMap(int n, int m) {\n            double[][] map = new double[n][m];\n            for (int i = 0; i < n; i++) {\n                map[i] = in.nextDoubleArray(m);\n            }\n            return map;\n        }\n\n        String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        String[] nextStringArray(int n) {\n            String[] array = new String[n];\n            for (int i = 0; i < n; i++)\n                array[i] = next();\n\n            return array;\n        }\n\n        String nextLine() {\n            int c = read();\n            while (isEndline(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndline(c));\n            return res.toString();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \n \npublic class Main implements Runnable {\n \n  public static final int MOD = 1000000007;\n\n  public void run() {\n    BetterScanner scanner = new BetterScanner(System.in);\n\n    int n = scanner.nextInt();\n\n    long[] fact = new long[n];\n    long[] invfact = new long[n];\n\n    fact[0] = 1;\n    for (int i = 1 ; i < n ; i ++) {\n      fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    invfact[n - 1] = pow(fact[n - 1], MOD - 2);\n    for (int i = n - 2 ; i >= 0 ; i --) {\n      invfact[i] = invfact[i + 1] * (i + 1) % MOD;\n    }\n\n    long res = 0;\n    long prev = 0;\n    for (int s = (n + 1) / 2 ; s <= n - 1 ; s ++) {\n      long val = fact[s - 1] * fact[s] % MOD * invfact[2 * s - n] % MOD;\n      res = (s * (val - prev) % MOD + res) % MOD;\n      prev = val;\n    }\n\n    System.out.println(res);\n  }\n\n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    } else if (b % 2 == 0) {\n      long d = pow(a, b / 2);\n      return (d * d) % MOD;\n    } else {\n      long d = pow(a, b - 1);\n      return (a * d) % MOD;\n    }\n  }\n\n  public static void main(String[] args) {\n    Main main = new Main();\n    main.run();\n  }\n \n  // scanner slightly faster than usual ones\n  public static class BetterScanner {\n \n    private InputStream stream;\n    private byte[] buffer = new byte[1024];\n    private int pointer = 0;\n    private int bufferLength = 0;\n \n    public BetterScanner(InputStream stream) {\n      this.stream = stream;\n    }\n \n    private boolean updateBuffer() {\n      if (pointer >= bufferLength) {\n        pointer = 0;\n        try {\n          bufferLength = stream.read(buffer);\n        } catch (IOException exception) {\n          exception.printStackTrace();\n        }\n        return bufferLength > 0;\n      } else {\n        return true;\n      }\n    }\n \n    private int read() {\n      if (updateBuffer()) {\n        return buffer[pointer ++];\n      } else {\n        return -1;\n      }\n    }\n \n    public boolean hasNext() {\n      skipUnprintable();\n      return updateBuffer();\n    }\n \n    private void skipUnprintable() { \n      while (updateBuffer() && !isPrintableChar(buffer[pointer])) {\n        pointer ++;\n      }\n    }\n \n    public String next() {\n      if (hasNext()) {\n        StringBuilder builder = new StringBuilder();\n        int codePoint = read();\n        while (isPrintableChar(codePoint)) {\n          builder.appendCodePoint(codePoint);\n          codePoint = read();\n        }\n        return builder.toString();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n \n    public long nextLong() {\n      if (hasNext()) {\n        long number = 0;\n        boolean minus = false;\n        int codePoint = read();\n        if (codePoint == '-') {\n          minus = true;\n          codePoint = read();\n        }\n        if (codePoint >= '0' && codePoint <= '9') {\n          while (true) {\n            if (codePoint >= '0' && codePoint <= '9') {\n              number *= 10;\n              number += codePoint - '0';\n            } else if (codePoint < 0 || !isPrintableChar(codePoint)) {\n              return (minus) ? -number : number;\n            } else {\n              throw new NumberFormatException();\n            }\n            codePoint = read();\n          }\n        } else {\n          throw new NumberFormatException();\n        }\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n \n    public int nextInt() {\n      long number = nextLong();\n      if (number >= Integer.MIN_VALUE && number <= Integer.MAX_VALUE) {\n        return (int)number;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n \n    private boolean isPrintableChar(int codePoint) {\n      return codePoint >= 33 && codePoint <= 126;\n    }\n \n  }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tint n;\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tn = in.nextInt();\n\t\t\tlong ans = 0;\n\t\t\tfor (int k = 1; k < n; k++) {\n\t\t\t\tans += k * (MOD + f(k) - f(k-1)) % MOD;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t\tout.println(ans % MOD);\n\n\t\t}\n\n\t\tlong f(int k) {\n\t\t\treturn comb(k-1, n-k-1) * fact[k] % MOD * fact[n-k-1] % MOD;\n\t\t}\n\t}\n\n\tpublic static long comb(int n, int r) {\n\t\tif (r < 0 || r > n)\n\t\t\treturn 0L;\n\t\treturn fact[n] % MOD * factInv[r] % MOD * factInv[n - r] % MOD;\n\t}\n\n\tpublic static int MAXN = 200000;\n\n\tstatic long[] fact = factorialArray(MAXN, MOD);\n\tstatic long[] factInv = factorialInverseArray(MAXN, MOD,\n\t\t\tinverseArray(MAXN, MOD));\n\n\tpublic static long[] factorialArray(int maxN, long mod) {\n\t\tlong[] fact = new long[maxN + 1];\n\t\tfact[0] = 1 % mod;\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tfact[i] = fact[i - 1] * i % mod;\n\t\t}\n\t\treturn fact;\n\t}\n\n\tpublic static long[] inverseArray(int maxN, long modP) {\n\t\tlong[] inv = new long[maxN + 1];\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i <= maxN; i++) {\n\t\t\tinv[i] = modP - (modP / i) * inv[(int) (modP % i)] % modP;\n\t\t}\n\t\treturn inv;\n\t}\n\n\tpublic static long[] factorialInverseArray(int maxN, long modP,\n\t\t\tlong[] inverseArray) {\n\t\tlong[] factInv = new long[maxN + 1];\n\t\tfactInv[0] = 1;\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tfactInv[i] = factInv[i - 1] * inverseArray[i] % modP;\n\t\t}\n\t\treturn factInv;\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(int n) {\n\t\t\tint[] res = new int[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i + 1] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(int n) {\n\t\t\tlong[] res = new long[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i + 1] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \n \npublic class Main implements Runnable {\n \n  public static final int MOD = 1000000007;\n\n  public void run() {\n    BetterScanner scanner = new BetterScanner(System.in);\n\n    int n = scanner.nextInt();\n    long[][] fact = calcFact(n);\n\n    long res = 0;\n    long prev = 0;\n    for (int s = (n + 1) / 2 ; s <= n - 1 ; s ++) {\n      long val = fact[0][s - 1] * fact[0][s] % MOD * fact[1][2 * s - n] % MOD;\n      res = (s * (val - prev + MOD) % MOD + res) % MOD;\n      prev = val;\n    }\n\n    System.out.println(res);\n  }\n\n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    } else if (b % 2 == 0) {\n      long d = pow(a, b / 2);\n      return (d * d) % MOD;\n    } else {\n      long d = pow(a, b - 1);\n      return (a * d) % MOD;\n    }\n  }\n\n  public long[][] calcFact(int n) {\n    long[] fact = new long[n];\n    long[] invfact = new long[n];\n    fact[0] = 1;\n    for (int i = 1 ; i < n ; i ++) {\n      fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    invfact[n - 1] = pow(fact[n - 1], MOD - 2);\n    for (int i = n - 2 ; i >= 0 ; i --) {\n      invfact[i] = invfact[i + 1] * (i + 1) % MOD;\n    }\n    return new long[][]{fact, invfact};\n  }\n\n  public static void main(String[] args) {\n    Main main = new Main();\n    main.run();\n  }\n \n  // scanner slightly faster than usual ones\n  public static class BetterScanner {\n \n    private InputStream stream;\n    private byte[] buffer = new byte[1024];\n    private int pointer = 0;\n    private int bufferLength = 0;\n \n    public BetterScanner(InputStream stream) {\n      this.stream = stream;\n    }\n \n    private boolean updateBuffer() {\n      if (pointer >= bufferLength) {\n        pointer = 0;\n        try {\n          bufferLength = stream.read(buffer);\n        } catch (IOException exception) {\n          exception.printStackTrace();\n        }\n        return bufferLength > 0;\n      } else {\n        return true;\n      }\n    }\n \n    private int read() {\n      if (updateBuffer()) {\n        return buffer[pointer ++];\n      } else {\n        return -1;\n      }\n    }\n \n    public boolean hasNext() {\n      skipUnprintable();\n      return updateBuffer();\n    }\n \n    private void skipUnprintable() { \n      while (updateBuffer() && !isPrintableChar(buffer[pointer])) {\n        pointer ++;\n      }\n    }\n \n    public String next() {\n      if (hasNext()) {\n        StringBuilder builder = new StringBuilder();\n        int codePoint = read();\n        while (isPrintableChar(codePoint)) {\n          builder.appendCodePoint(codePoint);\n          codePoint = read();\n        }\n        return builder.toString();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n \n    public long nextLong() {\n      if (hasNext()) {\n        long number = 0;\n        boolean minus = false;\n        int codePoint = read();\n        if (codePoint == '-') {\n          minus = true;\n          codePoint = read();\n        }\n        if (codePoint >= '0' && codePoint <= '9') {\n          while (true) {\n            if (codePoint >= '0' && codePoint <= '9') {\n              number *= 10;\n              number += codePoint - '0';\n            } else if (codePoint < 0 || !isPrintableChar(codePoint)) {\n              return (minus) ? -number : number;\n            } else {\n              throw new NumberFormatException();\n            }\n            codePoint = read();\n          }\n        } else {\n          throw new NumberFormatException();\n        }\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n \n    public int nextInt() {\n      long number = nextLong();\n      if (number >= Integer.MIN_VALUE && number <= Integer.MAX_VALUE) {\n        return (int)number;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n \n    private boolean isPrintableChar(int codePoint) {\n      return codePoint >= 33 && codePoint <= 126;\n    }\n \n  }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n \nclass Main {\n    public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter pw = new PrintWriter(System.out);\n    public static String line;\n    public static StringTokenizer st;\n    public static ArrayList<ArrayList<Integer>> adjList;\n    public static int[] dx = {-1, 0, 1, 0, -1, 1, 1, -1, 0};\n    public static int[] dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\n    public static int INF = 0x3f3f3f3f;\n    public static int MOD = 1000000007;\n    public static long LINF = 0x3f3f3f3f3f3f3f3fL;\n\n    public static long[] fact, inv;\n\n    public static long nCr(int N, int R) {\n        if (R < 0 || R > N) return 0;\n        return (( fact[N] * inv[R] % MOD ) * inv[N-R]) % MOD;\n    }\n\n    public static void main(String[] args) throws Exception {\n        int N = Integer.parseInt(br.readLine());\n        fact = new long[N+1];\n        inv = new long[N+1];\n        \n        fact[0] = 1;\n        inv[0] = 1;\n        BigInteger BIMOD = BigInteger.valueOf(MOD);\n        for (int i = 1; i <= N; i++) {\n            fact[i] = (i * fact[i-1]) % MOD;\n            inv[i] = BigInteger.valueOf(fact[i]).modInverse(BIMOD).longValue();\n        }\n        // System.out.println(inv[1]);\n        long ans = 0;\n        long prev = 0;\n        for (int K = 1; K <= N; K++) {\n            if (N - K - 1 < 0) break;\n            long n = ((nCr(K-1, N-K-1) * fact[K] % MOD) * fact[N-K-1]) % MOD;\n            long times = n - prev;\n            prev = n;\n            ans = ans + ((times * K) % MOD);\n            ans %= MOD;\n        }\n        pw.println(ans);\n\n        pw.close(); \n        br.close();\n    }\n}\n\nclass Point implements Comparable<Point>{\n    public int x, y;\n \n    Point(int _x, int _y){\n        x = _x;\n        y = _y;\n    }\n \n    public String toString(){\n        return x + \" \" + y;\n    }\n\n    public int compareTo(Point p){\n        if (x != p.x) return x < p.x ? -1 : 1;\n        if (y != p.y) return y < p.y ? -1 : 1;\n        return 0;\n    }\n} \n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    final int mod = (int) 1e9 + 7;\n\n    int[] fact;\n    int[] factInv;\n\n    int mul(int x, int y) {\n        return (int) (x * 1L * y % mod);\n    }\n\n    int c(int n, int k) {\n        if (k < 0 || k > n) {\n            return 0;\n        }\n        return mul(fact[n], mul(factInv[k], factInv[n - k]));\n    }\n\n    void solve() {\n        final int n = in.nextInt();\n        fact = new int[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i < fact.length; i++) {\n            fact[i] = mul(i, fact[i - 1]);\n        }\n        factInv = new int[fact.length];\n        factInv[factInv.length - 1] = BigInteger.valueOf(fact[fact.length - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n        for (int i = factInv.length - 2; i >= 0; i--) {\n            factInv[i] = mul(factInv[i + 1], i + 1);\n        }\n        if (n == 2) {\n            out.println(1);\n            return;\n        }\n        int res = 0;\n        int prev = 0;\n        for (int used = 2; used < n; used++) {\n            int have = used - 2;\n            int min = (n - 3) / 2;\n            int more = have - min;\n            if (more < 0) {\n                continue;\n            }\n            int cells = 2 * used - n;\n            int vars = c(used - 1, cells);\n            vars = mul(vars, fact[n - 1 - used]);\n            vars = mul(vars, fact[used]);\n            res = add(res, mul(sub(vars, prev), used));\n            prev = vars;\n        }\n        out.println(res);\n    }\n\n    int sub(int x, int y) {\n        x -= y;\n        return x < 0 ? (x + mod) : x;\n    }\n\n    int add(int x, int y) {\n        x += y;\n        return x < mod ? x : (x - mod);\n    }\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScan in = new MyScan(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, MyScan in, PrintWriter out) {\n            int i = in.nextInt();\n\n            long[] md = new long[i];\n\n            int rm = i - 2;\n            int lx = i - 2;\n            while (rm >= 0) {\n                md[lx + 1] = Util.c(rm, lx);\n                rm -= 2;\n                lx--;\n            }\n            long res = 0;\n            long prev = 0;\n            for (int m = 1; m < i; m++) {\n                long cur = Util.fact(m) * Util.fact(i - m - 1) % Util._m;\n                cur = cur * (md[m]) % Util._m;\n\n\n                res += (cur - prev + Util._m) * m % Util._m;\n                prev = cur;\n\n            }\n\n\n            out.println(res % Util._m);\n\n        }\n\n    }\n\n    static class MyScan {\n        private final InputStream in;\n        private byte[] inbuf = new byte[1024];\n        public int lenbuf = 0;\n        public int ptrbuf = 0;\n\n        public MyScan(InputStream in) {\n            this.in = in;\n        }\n\n        private int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = in.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = num * 10 + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n    }\n\n    static class Util {\n        public static final long M07 = 1000_000_007;\n        public static long _m = M07;\n        private static long[] fact;\n        private static long[] inv;\n        private static long[] ifact;\n\n        public static void l() {\n            fact = new long[1000001];\n            inv = new long[1000001];\n            ifact = new long[1000001];\n            for (int s = 0; s < 2; s++) {\n                fact[s] = 1;\n                ifact[s] = 1;\n                inv[s] = 1;\n            }\n            inv[0] = 0;\n            for (int i = 2; i < inv.length; i++) {\n                inv[i] = (_m - (_m / i) * inv[(int) (_m % i)] % _m) % _m;\n            }\n            for (int i = 2; i < fact.length; i++) {\n                fact[i] = i * fact[i - 1] % _m;\n                ifact[i] = inv[i] * ifact[i - 1] % _m;\n            }\n        }\n\n        public static long c(int a, int b) {\n            if (fact == null) l();\n            return ifact[a] * ifact[b - a] % _m * fact[b] % _m;\n        }\n\n        public static long fact(int a) {\n            if (fact == null) l();\n            return fact[a];\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main{\n\n    static long[] factorial;\n    static long[] invfac;\n\n    static long mod = (long)1e9+7;\n    static long inverse(long m){\n        long res =1;\n        for(int i=0;i<32;++i){\n            if((((mod-2)>>i)&1)==1)res=(res*m)%mod;\n            m = (m*m)%mod;\n        }\n        return res;\n    }\n    static long C(int i, int j){\n        return (((factorial[i]*invfac[i-j])%mod)*invfac[j])%mod;\n    }\n\n    static long func(int N, int j){\n        //Nをj回以上で埋める\n        if(N==j)return factorial[N];\n        return ((C(j-1,N-j-1)*factorial[j])%mod*factorial[N-j-1])%mod;\n    }\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        factorial = new long[N+1];\n        factorial[0]=1;\n        for(int i=1;i<=N;++i)factorial[i]=(factorial[i-1]*i)%mod;\n        invfac = new long[N+1];\n        for(int i=0;i<=N;++i)invfac[i]=inverse(factorial[i]);\n        long ans = (func(N, (N+1)/2)*((N+1)/2))%mod;\n        for(int j=(N+1)/2+1;j<N;++j){\n            ans = (ans + j*((func(N, j) - func(N, j-1) + mod)%mod)%mod)%mod;\n        }\n        System.out.println(ans);\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\nclass Solver{\n\tScanner sc =new Scanner(System.in);\n\t\n\tint mod = 1000000007;\n\t\n\tint perm[] = new int[1123456];\n\t{\n\t\tperm[0] = 1;\n\t\tfor(int i = 1; i <= 1123450;i++){\n\t\t\tperm[i] = (int)(((long)perm[i-1]*i) % mod);\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tint n = sc.nextInt()-1;\n\t\t\n\t\t\n\t\tlong res = perm[n] * (n);\n\t\tfor(int i = 1 ; i<=(n-1)/2;i++){\n\t\t\tres = (res + mod - ((long)comb2(n ,i)*perm[n-i])%mod)%mod;\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n\t}\n\t\n\t\n\tlong comb2(int x,int y){\n\t\tint s = x - 2 - y;\n\t\treturn comb_mod(s+1,  y);\n\t}\n\n\t\n\tint exp_mod(long a, long b, int m) {\n\t\tlong res = 1;\n\t\twhile (b > 0) {\n\t\t\tif ((b&1) == 1)\n\t\t\t\tres = (res * a)%m;\n\t\t\ta = (a * a)%m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn (int)res;\n\t}\n\n\tint comb_mod(int n, int r) {\n\t\treturn (int) \n\t\t\t\t( (long) ( (long)perm[n] * exp_mod(perm[r],  mod-2,mod) % mod)\n\t\t\t\t                         * exp_mod(perm[n-r],mod-2,mod) % mod);\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tSolver s  = new Solver();\n\t\ts.run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n;\n    long[] fac, iFac;\n    int MOD = 1000000007;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        solve();\n    }\n\n    void solve() {\n        fac = new long[n + 1];\n        fillFactorial();\n        long ans = 0;\n        long prevWays = 0;\n        if (n == 2) {\n            ans = 1;\n        } else if (n == 3) {\n            ans = 4;\n        } else {\n            int start = (n % 2 == 0) ? n / 2 : (n + 1) / 2;\n            for (int k = start; k < n; k++) {\n                long ways = (combination(k - 1, n - 1 - k) * fac[k] % MOD) *\n                        fac[n - 1 - k] % MOD;\n                ans = (ans + (ways - prevWays + MOD) % MOD * k % MOD ) % MOD;\n                prevWays = ways;\n                //System.out.println(ans);\n            }\n        }\n        System.out.println(ans);\n    }\n\n    long combination(int n, int r) {\n        if (n < r) return 0;\n        if (n < 0) return 0;\n        return fac[n] / (fac[n - r] * fac[r] % MOD);\n    }\n\n    void fillFactorial() {\n        fac[0] = 1;\n        for (int i = 1; i < fac.length; i++) {\n            fac[i] = i * fac[i - 1] % MOD;\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \n \npublic class Main implements Runnable {\n \n  public static final int MOD = 1000000007;\n\n  public void run() {\n    BetterScanner scanner = new BetterScanner(System.in);\n\n    int n = scanner.nextInt();\n\n    long[] fact = new long[n];\n    long[] invfact = new long[n];\n\n    fact[0] = 1;\n    for (int i = 1 ; i < n ; i ++) {\n      fact[i] = fact[i - 1] * i % MOD;\n    }\n    invfact[n - 1] = pow(fact[n - 1], MOD - 2);\n    for (int i = n - 2 ; i >= 0 ; i --) {\n      invfact[i] = invfact[i + 1] * (i + 1) % MOD;\n    }\n\n    long res = 0;\n    long prev = 0;\n    for (int s = (n + 1) / 2 ; s <= n - 1 ; s ++) {\n      long val = fact[s - 1] * fact[s] % MOD * invfact[2 * s - n] % MOD;\n      res = (s * (val - prev + MOD) % MOD + res) % MOD;\n      prev = val;\n    }\n\n    System.out.println(res);\n  }\n\n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    } else if (b % 2 == 0) {\n      long d = pow(a, b / 2);\n      return (d * d) % MOD;\n    } else {\n      long d = pow(a, b - 1);\n      return (a * d) % MOD;\n    }\n  }\n\n  public static void main(String[] args) {\n    Main main = new Main();\n    main.run();\n  }\n \n  // scanner slightly faster than usual ones\n  public static class BetterScanner {\n \n    private InputStream stream;\n    private byte[] buffer = new byte[1024];\n    private int pointer = 0;\n    private int bufferLength = 0;\n \n    public BetterScanner(InputStream stream) {\n      this.stream = stream;\n    }\n \n    private boolean updateBuffer() {\n      if (pointer >= bufferLength) {\n        pointer = 0;\n        try {\n          bufferLength = stream.read(buffer);\n        } catch (IOException exception) {\n          exception.printStackTrace();\n        }\n        return bufferLength > 0;\n      } else {\n        return true;\n      }\n    }\n \n    private int read() {\n      if (updateBuffer()) {\n        return buffer[pointer ++];\n      } else {\n        return -1;\n      }\n    }\n \n    public boolean hasNext() {\n      skipUnprintable();\n      return updateBuffer();\n    }\n \n    private void skipUnprintable() { \n      while (updateBuffer() && !isPrintableChar(buffer[pointer])) {\n        pointer ++;\n      }\n    }\n \n    public String next() {\n      if (hasNext()) {\n        StringBuilder builder = new StringBuilder();\n        int codePoint = read();\n        while (isPrintableChar(codePoint)) {\n          builder.appendCodePoint(codePoint);\n          codePoint = read();\n        }\n        return builder.toString();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n \n    public long nextLong() {\n      if (hasNext()) {\n        long number = 0;\n        boolean minus = false;\n        int codePoint = read();\n        if (codePoint == '-') {\n          minus = true;\n          codePoint = read();\n        }\n        if (codePoint >= '0' && codePoint <= '9') {\n          while (true) {\n            if (codePoint >= '0' && codePoint <= '9') {\n              number *= 10;\n              number += codePoint - '0';\n            } else if (codePoint < 0 || !isPrintableChar(codePoint)) {\n              return (minus) ? -number : number;\n            } else {\n              throw new NumberFormatException();\n            }\n            codePoint = read();\n          }\n        } else {\n          throw new NumberFormatException();\n        }\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n \n    public int nextInt() {\n      long number = nextLong();\n      if (number >= Integer.MIN_VALUE && number <= Integer.MAX_VALUE) {\n        return (int)number;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n \n    private boolean isPrintableChar(int codePoint) {\n      return codePoint >= 33 && codePoint <= 126;\n    }\n \n  }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic long MOD = 1000000007;\n\t\n\tstatic long inv(long a) {\n\t\treturn eleva(a, (int)MOD - 2);\n\t}\n\t\n\tstatic long eleva(long b, int e) {\n\t\tif (e == 0) return 1;\n\t\tlong ret = eleva(b, e / 2);\n\t\tret *= ret;\n\t\tret %= MOD;\n\t\tif (e % 2 == 1) {\n\t\t\tret *= b;\n\t\t\tret %= MOD;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint N = sc.nextInt();\n\t\tlong[] fact = new long[N], invFact = new long[N];\n\t\tfact[0] = invFact[0] = fact[1] = invFact[1] = 1;\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t}\n\t\tinvFact[N-1] = inv(fact[N-1]);\n\t\tfor (int i = N - 2; i >= 2; i--) {\n\t\t\tinvFact[i] = (invFact[i+1] * (i+1)) % MOD;\n\t\t}\n\t\t\n\t\tlong ans = fact[N-1] * (N-1) % MOD;\n\t\tfor (int k = (N + 1)/2; k < N - 1; k++) {\n\t\t\tlong tmp = (fact[k-1] * fact[k]) % MOD;\n\t\t\ttmp = (tmp * invFact[2*k - N]) % MOD;\n\t\t\tans -= tmp;\n\t\t}\n\t\tans %= MOD; ans += MOD; ans %= MOD;\n\t\tSystem.out.println(ans);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n;\n    long[] fac, iFac;\n    int MOD = 1000000007;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        solve();\n    }\n\n    void solve() {\n        fac = new long[n + 1];\n        iFac = new long[n + 1];\n        fillFactorials();\n        long ans = 0;\n        long prevWays = 0;\n        if (n == 2) {\n            ans = 1;\n        } else if (n == 3) {\n            ans = 4;\n        } else {\n            int start = (n % 2 == 0) ? n / 2 : (n + 1) / 2;\n            for (int k = start; k < n; k++) {\n                long ways = (combination(k - 1, n - 1 - k) * fac[k] % MOD) *\n                        fac[n - 1 - k] % MOD;\n                ans = (ans + (ways - prevWays + MOD) % MOD * k % MOD ) % MOD;\n                prevWays = ways;\n            }\n        }\n        System.out.println(ans);\n    }\n\n    long combination(int n, int r) {\n        if (n < r) return 0;\n        if (n < 0) return 0;\n        return fac[n] * iFac[n - r] % MOD * iFac[r] % MOD;\n    }\n\n    void fillFactorials() {\n        fac[0] = 1;\n        iFac[0] = 1;\n        for (int i = 1; i < fac.length; i++) {\n            fac[i] = i * fac[i - 1] % MOD;\n            //iFac[i] = (new BigInteger(Long.toString(fac[i]))).modPow(\n            //        new BigInteger(Long.toString(MOD - 2)),\n            //                new BigInteger(Integer.toString(MOD))).longValue();\n            iFac[i] = power(fac[i], MOD - 2, MOD);\n        }\n    }\n\n    long power(long a, long b, long mod) {\n        long x = 1;\n        long y = a;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                x = x * y % mod;\n            }\n            y = y * y % mod;\n            b /= 2;\n        }\n        return x % mod;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  private static void solve() {\n    int n = ni();\n\n    int mod = 1000000000 + 7;\n    long ret = 0;\n    int[][] fif = enumFIF(n + 1, mod);\n    if (n == 2) {\n      System.out.println(1);\n      return;\n    } else if (n == 3) {\n      System.out.println(2);\n      return;\n    }\n\n    long[] a = new long[n];\n    for (int k = (n + 1) / 2; k <= n - 1; k ++) {\n      //k個置く→(n-1-k)個置く\n      long now = 1;\n      now *= fif[0][k];\n      now %= mod;\n      now *= fif[0][n - 1 - k];\n      now %= mod;\n      \n      //k-1個の間に(n-1-k)個を配置\n      now *= C(k-1,n-1-k,mod,fif);\n      now %= mod;\n\n      a[k] = now;\n    }\n    \n    for (int k = (n + 1) / 2; k <= n - 1; k ++) {\n      ret += (a[k] - a[k - 1] + mod) * k;\n      ret %= mod;\n    }\n    System.out.println(ret);\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif)\n  {\n      if(n < 0 || r < 0 || r > n)return 0;\n      return (long)fif[0][n]*fif[1][r]%mod*fif[1][n-r]%mod;\n  }\n  \n  public static int[][] enumFIF(int n, int mod)\n  {\n      int[] f = new int[n+1];\n      int[] invf = new int[n+1];\n      f[0] = 1;\n      for(int i = 1;i <= n;i++){\n          f[i] = (int)((long)f[i-1] * i % mod);\n      }\n      long a = f[n];\n      long b = mod;\n      long p = 1, q = 0;\n      while(b > 0){\n          long c = a / b;\n          long d;\n          d = a; a = b; b = d % b;\n          d = p; p = q; q = d - c * q;\n      }\n      invf[n] = (int)(p < 0 ? p + mod : p);\n      for(int i = n-1;i >= 0;i--){\n          invf[i] = (int)((long)invf[i+1] * (i+1) % mod);\n      }\n      return new int[][]{f, invf};\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskC solver = new TaskC();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskC {\n        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n        NumberTheory.Factorial fact = new NumberTheory.Factorial(1000000, mod);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n\n\n            int[] t = new int[n];\n            for (int i = 0; i < n; i++) {\n                int minus = cover(n, i);\n                minus = mod.mul(fact.fact(n - 1 - i), minus);\n                minus = mod.mul(fact.fact(i), minus);\n                t[i] = mod.subtract(fact.fact(n - 1), minus);\n            }\n\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                ans = mod.plus(ans, t[i]);\n            }\n\n            out.println(ans);\n        }\n\n        public int cover(int n, int k) {\n            int b = n - 1 - k;\n            int a = k - b;\n            if (a < 1 || b < 0) {\n                return 0;\n            }\n            int ans = fact.fact(k - 1);\n            ans = mod.mul(ans, fact.invFact(a - 1));\n            ans = mod.mul(ans, fact.invFact(b));\n            return ans;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, NumberTheory.Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n\n        }\n\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n            NumberTheory.Modular modular;\n\n            public Factorial(int[] fact, int[] inv, NumberTheory.InverseNumber in, int limit,\n                            NumberTheory.Modular modular) {\n                this.modular = modular;\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new NumberTheory.InverseNumber(limit, modular), limit,\n                                modular);\n            }\n\n            public int fact(int n) {\n                return fact[n];\n            }\n\n            public int invFact(int n) {\n                return inv[n];\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    // long mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE;\n\n    void solve(){\n        int n = ni();\n        int mod = 1000000007;\n        int[][] fif = enumFIF(1000000, mod);\n        long ans = 0;\n        long sum = 0;\n        for(int k = 0; k < n; k++){\n            long res = C(k-1, n-1-k, mod, fif);\n            res *= fif[0][k];\n            res %= mod;\n            res *= fif[0][n-1-k];\n            res %= mod;\n            ans += k * (res-sum+mod)%mod;\n            ans %= mod;\n            sum = res;\n        }\n        out.println(ans);\n    }\n\n    public static long C(int n, int r, int mod, int[][] fif) {\n        if (n < 0 || r < 0 || r > n)\n            return 0;\n        return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n    }\n\n    \n    public static int[][] enumFIF(int n, int mod) {\n        int[] f = new int[n + 1];\n        int[] invf = new int[n + 1];\n        f[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            f[i] = (int) ((long) f[i - 1] * i % mod);\n        }\n        long a = f[n];\n        long b = mod;\n        long p = 1, q = 0;\n        while (b > 0) {\n            long c = a / b;\n            long d;\n            d = a;\n            a = b;\n            b = d % b;\n            d = p;\n            p = q;\n            q = d - c * q;\n        }\n        invf[n] = (int) (p < 0 ? p + mod : p);\n        for (int i = n - 1; i >= 0; i--) {\n            invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n        }\n        return new int[][] { f, invf };\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n \nclass Main {\n    public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter pw = new PrintWriter(System.out);\n    public static String line;\n    public static StringTokenizer st;\n    public static ArrayList<ArrayList<Integer>> adjList;\n    public static int[] dx = {-1, 0, 1, 0, -1, 1, 1, -1, 0};\n    public static int[] dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\n    public static int INF = 0x3f3f3f3f;\n    public static int MOD = 1000000007;\n    public static long LINF = 0x3f3f3f3f3f3f3f3fL;\n\n    public static long[] fact, inv;\n\n    public static long nCr(int N, int R) {\n        if (R < 0 || R > N) return 0;\n        return (( fact[N] * inv[R] % MOD ) * inv[N-R]) % MOD;\n    }\n\n    public static void main(String[] args) throws Exception {\n        int N = Integer.parseInt(br.readLine());\n        fact = new long[N+1];\n        inv = new long[N+1];\n        \n        fact[0] = 1;\n        inv[0] = 1;\n        BigInteger BIMOD = BigInteger.valueOf(MOD);\n        for (int i = 1; i <= N; i++) {\n            fact[i] = (i * fact[i-1]) % MOD;\n            inv[i] = BigInteger.valueOf(fact[i]).modInverse(BIMOD).longValue();\n        }\n        // System.out.println(inv[1]);\n        long ans = 0;\n        long prev = 0;\n        for (int K = 1; K <= N; K++) {\n            if (N - K - 1 < 0) break;\n            long n = ((nCr(K-1, N-K-1) * fact[K] % MOD) * fact[N-K-1]) % MOD;\n            long times = ( n - prev + MOD ) % MOD;\n            prev = n;\n            ans = ans + ((times * K) % MOD);\n            ans %= MOD;\n        }\n        pw.println(ans);\n\n        pw.close(); \n        br.close();\n    }\n}\n\nclass Point implements Comparable<Point>{\n    public int x, y;\n \n    Point(int _x, int _y){\n        x = _x;\n        y = _y;\n    }\n \n    public String toString(){\n        return x + \" \" + y;\n    }\n\n    public int compareTo(Point p){\n        if (x != p.x) return x < p.x ? -1 : 1;\n        if (y != p.y) return y < p.y ? -1 : 1;\n        return 0;\n    }\n} \n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main implements Runnable {\n    static ContestScanner in;\n    static Writer out;\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n\n    public void run() {\n        Main main = new Main();\n        try {\n            in = new ContestScanner();\n            out = new Writer();\n            main.solve();\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void solve() throws IOException {\n        int n = in.nextInt();\n        long ans = 0;\n        long mod = 1000000007;\n        long[] fact = getFact(n, mod);\n        for (int i = n - 1; i - 1 >= n - 1 - i; i--) {\n            ans = (ans + modcomb(i - 1, n - 1 - i, fact, mod) * fact[i] % mod * fact[n - 1 - i] % mod) % mod;\n        }\n        ans = ((fact[n - 1] * n % mod - ans) % mod + mod) % mod;\n        System.out.println(ans);\n    }\n\n    long modcomb(int n, int r, long[] fact, long mod) {\n        return fact[n] * modinv(fact[n - r], mod) % mod * modinv(fact[r], mod) % mod;\n    }\n\n\n    long[] getFact(int n, long mod) {\n        long[] fact = new long[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = fact[i - 1] * i % mod;\n        }\n        return fact;\n    }\n\n    long modinv(long n, long mod){\n        return modpow(n, mod-2, mod);\n    }\n\n    long modpow(long n, long a, long mod){\n        long res = 1;\n        while(a > 0){\n            if((a&1)==1) res = (res * n) % mod;\n            n = n * n % mod;\n            a >>= 1;\n        }\n        return res;\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n    @Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n    public void add(T key,int v){put(key,get(key)+v);}\n    public void add(T key){put(key,get(key)+1);}\n    public void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n    public MultiSet<T> merge(MultiSet<T> set)\n    {MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n        for(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n\nclass Writer extends PrintWriter{\n    public Writer(String filename)throws IOException\n    {super(new BufferedWriter(new FileWriter(filename)));}\n    public Writer()throws IOException {super(System.out);}\n}\nclass ContestScanner implements Closeable {\n    private BufferedReader in;private int c=-2;\n    public ContestScanner()throws IOException\n    {in=new BufferedReader(new InputStreamReader(System.in));}\n    public ContestScanner(String filename)throws IOException\n    {in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n    public String nextToken()throws IOException {\n        StringBuilder sb=new StringBuilder();\n        while((c=in.read())!=-1&&Character.isWhitespace(c));\n        while(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n        return sb.toString();\n    }\n    public String readLine()throws IOException{\n        StringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n        while(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n        return sb.toString();\n    }\n    public long nextLong()throws IOException,NumberFormatException\n    {return Long.parseLong(nextToken());}\n    public int nextInt()throws NumberFormatException,IOException\n    {return(int)nextLong();}\n    public double nextDouble()throws NumberFormatException,IOException\n    {return Double.parseDouble(nextToken());}\n    public void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tif(N<=4){\n\t\t\tif(N==2) System.out.println(1);\n\t\t\tif(N==3) System.out.println(4);\n\t\t\telse System.out.println(16);\n\t\t\treturn;\n\t\t}\n\t\tlong[] b = new long[(N+1)/2 + 1]; //n!\n\t\tlong MOD = 1000000007;\n\t\t\n\t\tb[0] = 1;\n\t\tfor(int i=1;i<=(N+1)/2;++i) b[i] = b[i-1] * i % MOD;\n\t\t\n\t\tint saitan = (N+1)/2; //最短手数\n\t\tlong keisuu = (b[saitan] * b[N-1-saitan]) % MOD; \n\t\tlong ans = keisuu*saitan;\n\t\tif(N%2==1) ans *= 2;\n\t\tans %= MOD;\n\t\tfor(int p=saitan+1;p<N;p++){\n\t\t\tint hujun = p-saitan;\n\t\t\tlong score = comb(p-2,hujun) % MOD;\n\t\t\tscore = (score * keisuu * p) % MOD;\n\t\t\tans += score;\n\t\t\tif(ans >= MOD) ans -= MOD;\n\t\t\t//System.out.println(p+\" \"+score+\" \"+ans);\n\t\t}\n\t\tSystem.out.println(ans);\n\t\treturn;\n\t}\n\t\n\tpublic static long comb(int a,int b){\n\t\tint limit = Math.min(b, a-b);\n\t\tlong ret = 1;\n\t\tfor(int i=1;i<=limit;++i){\n\t\t\tret *= (a+1-i);\n\t\t\tret /= i;\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int[] fact;\n        int[] invFact;\n        int mod = 1000000007;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt() - 1;\n            fact = new int[n + 1];\n            invFact = new int[n + 1];\n            fact[0] = invFact[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                fact[i] = (int) ((long) fact[i - 1] * i % mod);\n            }\n            invFact[n] = (int) MathUtils.inv(fact[n], mod);\n            for (int i = n - 1; i >= 0; i--) {\n                invFact[i] = (int) ((long) invFact[i + 1] * (i + 1) % mod);\n            }\n\n            long ans = 0;\n\n            for (int count = 0; count <= n; count++) {\n                long add = 1;\n                add = choose(count - 1, n - count);\n                add = (add * fact[count] % mod * fact[n - count] % mod);\n                ans += fact[n] - add;\n            }\n            out.println((ans % mod + mod) % mod);\n        }\n\n        private long choose(int n, int k) {\n            if (k < 0 || k > n) {\n                return 0;\n            }\n            return (long) fact[n] * invFact[k] % mod * invFact[n - k] % mod;\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n    }\n\n    static class MathUtils {\n        public static long modPow(long a, long b, long mod) {\n            while (a < 0) {\n                a += mod;\n            }\n            long res = 1;\n            while (b > 0) {\n                if ((b & 1) != 0) {\n                    res = res * a % mod;\n                }\n                a = a * a % mod;\n                b >>>= 1;\n            }\n            return res;\n        }\n\n        public static long inv(long a, long mod) {\n            return modPow(a, mod - 2, mod);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  private static void solve() {\n    int n = ni();\n\n    int mod = 1000000000 + 7;\n    long ret = 0;\n    int[][] fif = enumFIF(n + 1, mod);\n    if (n == 2) {\n      System.out.println(1);\n      return;\n    } else if (n == 3) {\n      System.out.println(2);\n      return;\n    }\n\n    long[] a = new long[n];\n    for (int k = (n + 1) / 2; k <= n - 1; k ++) {\n      //k個置く→(n-1-k)個置く\n      long now = 1;\n      now *= fif[0][k];\n      now %= mod;\n      now *= fif[0][n - 1 - k];\n      now %= mod;\n      \n      //k-1個の間に(n-1-k)個を配置\n      now *= C(k-1,n-1-k,mod,fif);\n      now %= mod;\n\n      a[k] = now;\n    }\n    \n    for (int k = (n + 1) / 2; k <= n - 1; k ++) {\n      ret += (a[k] - a[k - 1]) * k;\n      ret %= mod;\n    }\n    System.out.println(ret);\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif)\n  {\n      if(n < 0 || r < 0 || r > n)return 0;\n      return (long)fif[0][n]*fif[1][r]%mod*fif[1][n-r]%mod;\n  }\n  \n  public static int[][] enumFIF(int n, int mod)\n  {\n      int[] f = new int[n+1];\n      int[] invf = new int[n+1];\n      f[0] = 1;\n      for(int i = 1;i <= n;i++){\n          f[i] = (int)((long)f[i-1] * i % mod);\n      }\n      long a = f[n];\n      long b = mod;\n      long p = 1, q = 0;\n      while(b > 0){\n          long c = a / b;\n          long d;\n          d = a; a = b; b = d % b;\n          d = p; p = q; q = d - c * q;\n      }\n      invf[n] = (int)(p < 0 ? p + mod : p);\n      for(int i = n-1;i >= 0;i--){\n          invf[i] = (int)((long)invf[i+1] * (i+1) % mod);\n      }\n      return new int[][]{f, invf};\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CPaintingMachines solver = new CPaintingMachines();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CPaintingMachines {\n        static final NumberTheory.Mod107 mod = new NumberTheory.Mod107();\n        NumberTheory.ModularNumber<NumberTheory.Mod107>[] fact;\n\n        public NumberTheory.ModularNumber<NumberTheory.Mod107> ncr(int n, int r) {\n            if (r < 0 || n < r) return mod.create(0);\n            return fact[n].div(fact[r].mult(fact[n - r]));\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt() - 1;\n\n            fact = new NumberTheory.ModularNumber[n + 1];\n            fact[0] = mod.create(1);\n            for (int i = 1; i <= n; i++) {\n                fact[i] = fact[i - 1].mult(i);\n            }\n\n            NumberTheory.ModularNumber<NumberTheory.Mod107> answer = fact[n].mult(n);\n\n            for (int i = 1; i <= n - 2; i++) {\n                answer = answer.subtract(fact[i].mult(fact[n - i]).mult(ncr(n - 1 - i, i)));\n            }\n\n            out.println(answer);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class NumberTheory {\n        public abstract static class Modulus<M extends NumberTheory.Modulus<M>> {\n            public abstract long modulus();\n\n            public NumberTheory.ModularNumber<M> create(long value) {\n                return new NumberTheory.ModularNumber(value, this);\n            }\n\n        }\n\n        public static class Mod107 extends NumberTheory.Modulus<NumberTheory.Mod107> {\n            public long modulus() {\n                return 1_000_000_007L;\n            }\n\n        }\n\n        public static class ModularNumber<M extends NumberTheory.Modulus<M>> {\n            public final long value;\n            public final M m;\n            public final long MOD;\n\n            public ModularNumber(long value, M m) {\n                this.m = m;\n                this.MOD = m.modulus();\n                this.value = (value % MOD + MOD) % MOD;\n            }\n\n            public NumberTheory.ModularNumber<M> subtract(NumberTheory.ModularNumber<M> other) {\n                return m.create(value - other.value);\n            }\n\n            public NumberTheory.ModularNumber<M> mult(NumberTheory.ModularNumber<M> other) {\n                return m.create(value * other.value);\n            }\n\n            public NumberTheory.ModularNumber<M> mult(long other) {\n                return m.create(value * other);\n            }\n\n            public NumberTheory.ModularNumber<M> div(NumberTheory.ModularNumber<M> other) {\n                return this.mult(other.inv());\n            }\n\n            public NumberTheory.ModularNumber<M> inv() {\n                long g = m.modulus(), x = 0, y = 1;\n                for (long r = value; r != 0; ) {\n                    long q = g / r;\n                    g %= r;\n\n                    long temp = g;\n                    g = r;\n                    r = temp;\n\n                    x -= q * y;\n\n                    temp = x;\n                    x = y;\n                    y = temp;\n                }\n\n                assert (g == 1);\n                assert (y == MOD || y == -MOD);\n\n                return m.create(x);\n            }\n\n            public String toString() {\n                return String.valueOf(value);\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        if(N == 2)\n        {\n            Console.WriteLine(1);\n            return;\n        }\n\n        setFact(N + 10);\n\n        long ans = 0;\n\n        int Nokori = N - 2;\n        for (int i = (Nokori + 1) / 2; i <= Nokori; i++)\n        {\n            int step1 = i * 2 - Nokori;\n            int step2 = i - step1;\n\n            long score = 1 + i;\n            long S12 = getC(step1 + step2, step1);\n            long S12Fact = fact[score];\n            long S0Fact = fact[N - 1 - score];\n\n\n            long add = score * S12 % mod * S12Fact % mod * S0Fact % mod;\n            \n            ans += add;\n            ans %= mod;\n            \n\n        }\n        Console.WriteLine(ans);\n\n\n\n\n\n\n    }\n\n    long mod = 1000000007;\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n\n    long getC(int a, int b)\n    {\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n\n}\n\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public int N;\n        public long MOD = 1000000007;\n\n        public void Run()\n        {\n            var comb = new FermatCombination(1000000);\n\n            N = Input.ReadInt();\n\n            long ret = 0;\n            {\n                var v = comb.Permutation(N - 1, N - 1);\n                ret += (v * (N)) % MOD;\n                ret %= MOD;\n            }\n\n            for (int k = 0; k < N; k++)\n            {\n                // C(K − 1, N − 1 − K) × K! × (N − 1 − K)!  \n\n                if (k - 1 < N - 1 - k) continue;\n                var v1 = comb.Combination(k - 1, N - 1 - k);\n                var v2 = comb.Permutation(k, k);\n                var v3 = comb.Permutation(N - 1 - k, N - 1 - k);\n                var v = (((v1 * v2) % MOD) * v3) % MOD;\n                ret += (MOD - v);\n                ret %= MOD;\n            }\n\n            Console.WriteLine(ret);\n        }\n    }\n\n    // libs ----------\n    // フェルマーの定理、逆元を使う場合\n    class FermatCombination\n    {\n        public long[] Factrial; // 階乗\n        public long[] Inverse; // 逆元\n        public long MOD = 1000000007;\n\n        public FermatCombination(int n)\n        {\n\n            Factrial = new long[n + 1];\n            Inverse = new long[n + 1];\n            Factrial[0] = 1;\n            Inverse[0] = 1;\n\n            for (int i = 1; i <= n; i++)\n            {\n                Factrial[i] = (Factrial[i - 1] * i) % MOD;\n            }\n\n            for (int i = 1; i <= n; i++)\n            {\n                // フェルマーの小定理で逆元を求める\n                Inverse[i] = Power(Factrial[i], (int)MOD - 2, MOD) % MOD;\n            }\n        }\n\n        public long Permutation(int n, int k)\n        {\n            return Factrial[n] * Inverse[n - k] % MOD;\n        }\n\n        public long Combination(int n, int k)\n        {\n            return Factrial[n] * Inverse[k] % MOD * Inverse[n - k] % MOD;\n        }\n\n        public static long Power(long x, long n, long M)\n        {\n            long tmp = 1;\n\n            if (n > 0)\n            {\n                tmp = Power(x, n / 2, M);\n                if (n % 2 == 0) tmp = (tmp * tmp) % M;\n                else tmp = (((tmp * tmp) % M) * x) % M;\n            }\n\n            return tmp;\n        }\n    }\n\n    // common ----------\n\n    internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace AGC023C {\n    class Program {\n        static void Main(string[] args) {\n            int N = int.Parse(Console.ReadLine());\n            long[] fact = new long[N];\n            long[] invfact = new long[N];\n            fact[0] = 1;\n            invfact[0] = 1;\n            for (int i = 1; i < N; i++) {\n                fact[i] = multiply(fact[i - 1], i);\n                invfact[i] = divide(1, fact[i]);\n            }\n            long[] nums = new long[N];\n            for (int i = 1; i <= N - 1; i++) {\n                long conbi = 0;\n                if (i - 1 >= N - 1 - i) {\n                    conbi = multiply(fact[i - 1], multiply(invfact[N - 1 - i], invfact[(i - 1) - (N - 1 - i)]));\n                }\n                nums[i] = multiply(multiply(fact[i], fact[N - 1 - i]), conbi);\n            }\n            long ans = 0;\n            for (int i = 1; i < N; i++) {\n                ans = (ans + multiply(nums[i] - nums[i - 1], i)) % mod;\n            }\n            Console.WriteLine(ans);\n        }\n\n        //定数です\n        const long mod = 1000000007;\n\n        //mod下でのx×yです\n        private static long multiply(long x, long y) {\n            return (x % mod) * (y % mod) % mod;\n        }\n\n        //mod下でのxのy乗です\n        private static long power(long x, long y) {\n            if (y == 0) {\n                return 1;\n            } else if (y == 1) {\n                return x % mod;\n            } else if (y % 2 == 0) {\n                long p = power(x, y / 2);\n                return p * p % mod;\n            } else {\n                long p = power(x, y / 2);\n                return (p * p) % mod * (x % mod) % mod;\n            }\n        }\n\n        private static long divide(long x, long y) {\n            return multiply(x, power(y, mod - 2));\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace AGC023C {\n    class Program {\n        static void Main(string[] args) {\n            int N = int.Parse(Console.ReadLine());\n            long[] fact = new long[N];\n            long[] invfact = new long[N];\n            fact[0] = 1;\n            invfact[0] = 1;\n            for (int i = 1; i < N; i++) {\n                fact[i] = multiply(fact[i - 1], i);\n                invfact[i] = divide(1, fact[i]);\n            }\n            long[] nums = new long[N];\n            for (int i = 1; i < N; i++) {\n                long conbi = 0;\n                if (i - 1 >= N - 1 - i) {\n                    conbi = multiply(fact[i - 1], multiply(invfact[N - 1 - i], invfact[(i - 1) - (N - 1 - i)]));\n                }\n                nums[i] = multiply(multiply(fact[i], fact[N - 1 - i]), conbi);\n            }\n            long ans = 0;\n            for (int i = 1; i < N; i++) {\n                ans = (ans + multiply((nums[i] - nums[i - 1] + mod), i)) % mod;\n            }\n            Console.WriteLine(ans);\n        }\n\n        //定数です\n        const long mod = 1000000007;\n\n        //mod下でのx×yです\n        private static long multiply(long x, long y) {\n            return (x % mod) * (y % mod) % mod;\n        }\n\n        //mod下でのxのy乗です\n        private static long power(long x, long y) {\n            if (y == 0) {\n                return 1;\n            } else if (y == 1) {\n                return x % mod;\n            } else if (y % 2 == 0) {\n                long p = power(x, y / 2);\n                return p * p % mod;\n            } else {\n                long p = power(x, y / 2);\n                return (p * p) % mod * (x % mod) % mod;\n            }\n        }\n\n        private static long divide(long x, long y) {\n            return multiply(x, power(y, mod - 2));\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random();\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\t// naive(n - 1);\n\t\t\tif (n == 2) {\n\t\t\t\tConsole.WriteLine(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar table = new BinomialCoefficient(n + 50);\n\t\t\tvar fact = table.fact;\n\t\t\tModInt ans = (n - 1) * fact[n - 1];\n\t\t\tfor (int k = 0; k <= n - 1; k++) {\n\t\t\t\tvar two = k;\n\t\t\t\tvar one = n - 1 - 2 * k;\n\t\t\t\tvar zero = k;\n\t\t\t\tif (one < 1) break;\n\t\t\t\tModInt v = 1;\n\t\t\t\t// Debug.WriteLine($\"{two} {one} {zero}\");\n\t\t\t\tv *= fact[two + one];\n\t\t\t\tv *= fact[zero];\n\t\t\t\tv *= table[two + one - 1, two];\n\t\t\t\tif (k > 0)\n\t\t\t\t\tans -= v;\n\t\t\t\t// Debug.WriteLine($\"! {k} {v}\");\n\t\t\t}\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t\tvoid naive(int n) {\n\t\t\tDebug.WriteLine(n + 1);\n\t\t\tvar dp = new long[1 << n];\n\t\t\tdp[0] = 1;\n\t\t\tint ALL = (1 << (n + 1)) - 1;\n\t\t\tvar ans = 0L;\n\t\t\tvar dist = new long[n + 1];\n\t\t\tfor (int i = 0; i < 1 << n; i++) {\n\t\t\t\tif (dp[i] == 0) continue;\n\t\t\t\tvar mask = 0;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif ((i >> j & 1) == 1) {\n\t\t\t\t\t\tmask |= 1 << j;\n\t\t\t\t\t\tmask |= 1 << (j + 1);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mask == ALL) {\n\t\t\t\t\tfor (int j = n - cnt; j >= 1; j--)\n\t\t\t\t\t\tdp[i] *= j;\n\t\t\t\t\tans += cnt * dp[i];\n\t\t\t\t\tdist[cnt] += dp[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\t\tif ((i >> j & 1) == 0) dp[i | (1 << j)] += dp[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tDebug.WriteLine(dist.AsJoinedString());\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n];\n\t\t\tfor (int i = 0; i < a.Length; ++i) a[i] = f(i);\n\t\t\treturn a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n\t\tvar solver = new Program.Solver();\n\t\t/* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t*/\n\t\tsolver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n\t/// <summary>\n\t/// 剰余を取る値．\n\t/// </summary>\n\tpublic const long Mod = (int)1e9 + 7;\n\n\t/// <summary>\n\t/// 実際の数値．\n\t/// </summary>\n\tpublic long num;\n\t/// <summary>\n\t/// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n\t/// </summary>\n\t/// <param name=\"n\">インスタンスが持つ値</param>\n\t/// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n\tpublic ModInt(long n) { num = n; }\n\t/// <summary>\n\t/// このインスタンスの数値を文字列に変換します．\n\t/// </summary>\n\t/// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n\tpublic override string ToString() { return num.ToString(); }\n\tpublic static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n\tpublic static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n\tpublic static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n\tpublic static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(long v, long k) {\n\t\tlong ret = 1;\n\t\tfor (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n\t\t\tif ((k & 1) == 1) ret = ret * v % Mod;\n\t\treturn new ModInt(ret);\n\t}\n\t/// <summary>\n\t/// 与えられた数の逆元を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">逆元を取る対象となる数</param>\n\t/// <returns>逆元となるような値</returns>\n\t/// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n\tpublic static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n\n#region Binomial Coefficient\npublic class BinomialCoefficient {\n\tpublic ModInt[] fact, ifact;\n\tpublic BinomialCoefficient(int n) {\n\t\tfact = new ModInt[n + 1];\n\t\tifact = new ModInt[n + 1];\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfact[i] = fact[i - 1] * i;\n\t\tifact[n] = ModInt.Inverse(fact[n]);\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tifact[i] = ifact[i + 1] * (i + 1);\n\t\tifact[0] = ifact[1];\n\t}\n\tpublic ModInt this[int n, int r] {\n\t\tget {\n\t\t\tif (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n\t\t\treturn fact[n] * ifact[n - r] * ifact[r];\n\t\t}\n\t}\n\tpublic ModInt RepeatedCombination(int n, int k) {\n\t\tif (k == 0) return 1;\n\t\treturn this[n + k - 1, k];\n\t}\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i;M=10**9+7;I=[1,1];*F=I;*R=I;2.upto(N){|i|I<<z=(M-M/i)*I[M%i]%M;F<<i*F[-1]%M;R<<z*R[-1]%M};r=F[N];(-~N/2...N).each{|i|r=(r-F[i-1]*R[2*i-N]*F[i])%M};p r"
  },
  {
    "language": "Ruby",
    "code": "M=10**9+7\n*F=I=[r=1,t=1]\n*R=I\n(N=eval`dd`).times{|i|i>1&&(I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;R<<t=t*z%M);$.+=i<-~N/2?0:F[-2]*r*R[2*i-N]%M}\np (r*N-$.)%M"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i\nM=10**9+7\n*F=I=[r=1,t=1]\nR=*I,*(2..N).map{|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;t=t*z%M}\n(-~N/2...N).each{|i|r-=F[i-1]*R[2*i-N]*F[i]%M}\np r%M\n###############################################\n###############################################\n###############################################\n###############################################\n###############################################"
  },
  {
    "language": "Ruby",
    "code": "def create_fact_mod(num_max, mod)\n    $fmod = Array.new(num_max + 1)\n    $fmod[0] = 1\n    $fmod[1] = 1\n    (2..num_max).each do |i|\n        $fmod[i] = ($fmod[i - 1] * i) % mod\n    end\nend\n\ndef create_seq_inv_mod(num_max, mod)\n    $simod = Array.new(num_max + 1)\n    $simod[0] = 1\n    $simod[1] = 1\n    (2..num_max).each do |i|\n        $simod[i] = (mod - mod / i) * $simod[mod % i] % mod\n    end\nend\n\ndef create_fact_inv_mod(num_max, mod)\n    $fimod = Array.new(num_max + 1)\n    $fimod[0] = 1\n    $fimod[1] = 1\n    (2..num_max).each do |i|\n        $fimod[i] = ($fimod[i - 1] * $simod[i]) % mod\n    end\nend\n\ndef create_mod_tables(n, mod)\n    create_fact_mod(n, mod)\n    create_seq_inv_mod(n, mod)\n    create_fact_inv_mod(n, mod)\nend\n\ndef comb_mod(n, k, mod)\n    return $fmod[n] * $fimod[n - k] * $fimod[k] % mod\nend\n\n\nN = gets.to_i\n#N = 10**6\nMOD = 10**9 + 7\n\ncreate_mod_tables(N, MOD)\n\nsum = 0\nnow = 0\nprev = 0\n\n((N+1)/2...N).each do |i|\n    now = $fmod[i - 1] * $fmod[i] * $fimod[2 * i - N] % MOD\n    sum += (now - prev) * i\n    sum %= MOD\n    prev = now\nend\np sum"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n# IS_DEBUG = true\nIS_DEBUG = false\ndef dputs str\n\tif(IS_DEBUG)\n\t\tputs str\n\tend\nend\ndef dpp str\n\tif(IS_DEBUG)\n\t\tpp str\n\tend\nend\ndef comb(n,a)\n\treturn $fact[n] * $finv[a] % $mod * $finv[n-a] % $mod;\nend\ndef pow(a,n)\n\tprd = 1;\n\texp = a;\n\twhile(n > 0)\n\t\tif((n&1)==1)\n\t\t\tprd *= exp;\n\t\t\tprd %= $mod;\n\t\tend\n\t\texp *= exp;\n\t\texp %= $mod;\n\t\tn >>= 1;\n\tend\n\treturn prd;\nend\n# constant\nNMAX = 1000000 + 1;\n# $mod = 998244353;\n$mod = 10**9+7;\n$fact = Array.new(NMAX);\n$finv = Array.new(NMAX);\n# read\nN,_=gets.chomp.split(' ').map{|n| n.to_i}\n# preprocess\n$fact[0] = 1;\n$finv[0] = 1;\nfor i in 1..(NMAX)\n\t$fact[i] = $fact[i-1] * i % $mod;\n\t$finv[i] = pow($fact[i], $mod-2);\nend\n# main\nnumk = Array.new(N){0};\nleast = (N*1.0/2).ceil\nfor k in least..(N-1)\n\tnumk[k] = comb(k-1, N-1-k) % $mod * $fact[k] % $mod * $fact[N-1-k] % $mod\nend\nsum = least * numk[least]\nfor i in (least+1)..(N-1)\n\tsum += i * (numk[i] - numk[i-1])\n\tsum %= $mod\nend\nputs sum\n\n"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i\nM=10**9+7\n*F=I=[r=1,1]\n*R=I\n2.upto(N){|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;R<<z*R[-1]%M}\n(-~N/2...N).each{|i|r-=F[i-1]*R[2*i-N]*F[i]%M}\np r%M\n###############################################\n###############################################\n###############################################\n###############################################\n###############################################"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i\nM=10**9+7\ns=0\n*F=I=[r=1,1]\n*R=I\n2.upto(N){|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;R<<z*R[-1]%M;i<-~N/2||i>=N||s+=F[-2]*r*R[2*i-N]%M}\np N>2?(r-s)%M: 1\n###############################################\n###############################################\n###############################################\n###############################################\n###############################################"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i\nM=10**9+7;I=[1,1];*F=I;*R=I\n2.upto(N){|i|I<<z=(M-M/i)*I[M%i]%M;F<<i*F[-1]%M;R<<z*R[-1]%M}\nr=0\n(N/2...N).each{|i|r=(r+F[i-1]*R[N-i-1]*R[2*i-N]*F[i]*F[N-i-1])%M}\np (F[N]-r)%M"
  },
  {
    "language": "Ruby",
    "code": "M=10**9+7\n*F=I=[r=1,t=1]\nR=*I,*(2..N=gets.to_i).map{|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;t=t*z%M}\n(-~N/2...N).map{|i|r-=F[i-1]*R[2*i-N]*F[i]%M}\np r%M"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n# IS_DEBUG = true\nIS_DEBUG = false\ndef dputs str\n\tif(IS_DEBUG)\n\t\tputs str\n\tend\nend\ndef dpp str\n\tif(IS_DEBUG)\n\t\tpp str\n\tend\nend\ndef comb(n,a)\n\treturn $fact[n] * $finv[a] % $mod * $finv[n-a] % $mod;\nend\ndef pow(a,n)\n\tprd = 1;\n\texp = a;\n\twhile(n > 0)\n\t\tif((n&1)==1)\n\t\t\tprd *= exp;\n\t\t\tprd %= $mod;\n\t\tend\n\t\texp *= exp;\n\t\texp %= $mod;\n\t\tn >>= 1;\n\tend\n\treturn prd;\nend\n# constant\nNMAX = 100015;\n# $mod = 998244353;\n$mod = 10**9+7;\n$fact = Array.new(NMAX);\n$finv = Array.new(NMAX);\n# read\nN,_=gets.chomp.split(' ').map{|n| n.to_i}\n# preprocess\n$fact[0] = 1;\n$finv[0] = 1;\nfor i in 1..(NMAX)\n\t$fact[i] = $fact[i-1] * i % $mod;\n\t$finv[i] = pow($fact[i], $mod-2);\nend\n# main\nnumk = Array.new(N){0};\nleast = (N*1.0/2).ceil\nfor k in least..(N-1)\n\tnumk[k] = comb(k-1, N-1-k) % $mod * $fact[k] % $mod * $fact[N-1-k] % $mod\nend\nsum = least * numk[least]\nfor i in (least+1)..(N-1)\n\tsum += i * (numk[i] - numk[i-1])\n\tsum %= $mod\nend\nputs sum\n\n"
  },
  {
    "language": "Ruby",
    "code": "# num ** power % mod\n# mod must be prime\ndef power_mod(num, power, mod)\n    prod = 1\n    num %= mod\n    while power > 0 do\n        if power & 1 == 1\n            prod = (prod * num) % mod\n        end\n        num = (num * num) % mod\n        power >>= 1\n    end\n    return prod\nend\n\ndef factory_mod(num_max, mod)\n    arr = Array.new(num_max + 1)\n    arr[0] = 1\n    arr[1] = 1\n    (2..num_max).each do |i|\n        arr[i] = (arr[i - 1] * i) % mod\n    end\n    return arr\nend\n\ndef factory_inv_mod(num_max, mod)\n    arr = Array.new(num_max + 1)\n    arr[0] = 1\n    arr[1] = 1\n    (2..num_max).each do |i|\n        arr[i] = (arr[i - 1] * power_mod(i, mod - 2, mod)) % mod\n    end\n    return arr\nend\n\ndef create_mod_table(n, mod)\n    $fmod ||= factory_mod(n, mod)\n    $fimod ||= factory_inv_mod(n, mod)\nend\n\ndef comb_mod(n, k, mod)\n    $fmod ||= factory_mod(n, mod)\n    $fimod ||= factory_inv_mod(n, mod)\n    return $fmod[n] * $fimod[n - k] * $fimod[k] % mod\nend\n\n\nN = gets.to_i\nMOD = 10**9 + 7\n\ncreate_mod_table(N, MOD)\n\nsum = 0\nnow = 0\nprev = 0\n\n((N+1)/2...N).each do |i|\n    now = comb_mod(i - 1, N - 1 - i, MOD) * $fmod[i] * $fmod[N - 1 - i]\n    sum += (now - prev) * i\n    sum %= MOD\n    prev = now\nend\np sum"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i\nM=10**9+7\n*F=I=[r=1,t=1]\nR=1,1,*(2..N).map{|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;t=t*z%M}\n(-~N/2...N).each{|i|r-=F[i-1]*R[2*i-N]*F[i]%M}\np r%M\n###############################################\n###############################################\n###############################################\n###############################################\n###############################################"
  },
  {
    "language": "Ruby",
    "code": "N=gets.to_i\nM=10**9+7;I=[1,1];*F=I;*R=I\n2.upto(N){|i|I<<z=(M-M/i)*I[M%i]%M;F<<i*F[-1]%M;R<<z*R[-1]%M}\nr=0\n(-~N/2...N).each{|i|r=(r+F[i-1]*R[N-i-1]*R[2*i-N]*F[i]*F[N-i-1])%M}\np (F[N]-r)%M"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.bigint;\nimport std.math, std.random, std.datetime;\nimport std.array, std.range, std.algorithm, std.container;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n\n// ----- library mod -----\n\nconst ulong mod = 1_000_000_007;\n\t// assert(mod % 2 > 0);\n\t// for(int i = 3; i * i <= x; i += 2) assert(x % i > 0);\n\t// assert(mod * mod < ulong.max);\n\t\nconst int nmax = 1_000_000;\n\t\t\nulong sum(ulong[] xs ...){\n\tulong ans = 0;\n\tforeach(x; xs){\n\t\tans += x;\n\t\tans %= mod;\n\t\t}\n\treturn ans;\n\t}\n\nulong diff(ulong x, ulong y){\n\treturn sum(x, neg(y));\n\t}\n\nulong neg(ulong x){\n\tassert(x < mod);\n\treturn (mod - x) % mod;\n\t}\n\nulong prod(ulong[] xs ...){\n\tulong ans = 1;\n\tforeach(x; xs){\n\t\tans *= x;\n\t\tans %= mod;\n\t\t}\n\treturn ans;\n\t}\n\nulong quot(ulong x, ulong y){\n\tassert(y > 0);\n\tassert(y < nmax);\n\treturn prod(x, inv(y));\n\t}\n\nulong inv(ulong x){\n\tassert(x > 0);\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _inv;\n\tif(!inited){\n\t\t_inv[1] = 1;\n\t\tforeach(i; 2 .. nmax){\n\t\t\t_inv[i] = (mod - mod / i) * _inv[mod % i] % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _inv[cast(int) x];\n\t}\n\nulong frac(ulong x){\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _frac;\n\tif(!inited){\n\t\t_frac[0] = 1;\n\t\tforeach(i; 1 .. nmax){\n\t\t\t_frac[i] = _frac[i - 1] * i % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _frac[cast(int) x];\n\t}\n\nulong invfrac(ulong x){\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _invfrac;\n\tif(!inited){\n\t\t_invfrac[0] = 1;\n\t\tforeach(i; 1 .. nmax){\n\t\t\t_invfrac[i] = _invfrac[i - 1] * inv(i) % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _invfrac[cast(int) x];\n\t}\n\nulong binom(ulong n, ulong k){\n\tassert(n < nmax);\n\tassert(k <= n);\n\treturn prod(frac(n), invfrac(k), invfrac(n - k));\n\t}\n\n// ----- library mod end -----\n\n\n\n\nconst DEBUG = 0;\n\n\nvoid main(){\n\tint n = read.to!int;\n\t\n\tlong[nmax] ys;\n\tlong[nmax] xs;\n\t\n\tforeach(k; 0 .. (n + 1) / 2){\n\t\tys[k] = 0;\n\t\t}\n\tforeach(k; (n + 1) / 2 .. n + 1){\n\t\tys[k] = binom(k - 1, 2 * k - n) * frac(k);\n\t\tys[k] %= mod;\n\t\t}\n\t\n\tforeach(k; 0 .. (n + 1) / 2){\n\t\txs[k] = 0;\n\t\t}\n\tforeach(k; (n + 1) / 2 .. n + 1){\n\t\txs[k] = ys[k];\n\t\txs[k] += neg(prod(ys[k - 1], (n - k)));\n\t\txs[k] %= mod;\n\t\t}\n\t\n\tif(DEBUG) ys[0 .. n + 1].writeln;\n\tif(DEBUG) xs[0 .. n + 1].writeln;\n\t\n\tlong sum = 0;\n\tforeach(k; 0 .. n){\n\t\tsum += prod(xs[k], k);\n\t\tsum %= mod;\n\t\t}\n\t\n\tsum.writeln;\n\t}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.bigint;\nimport std.math, std.random, std.datetime;\nimport std.array, std.range, std.algorithm, std.container;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n\n// ----- library mod -----\n\nconst ulong mod = 1_000_000_007;\n\t// assert(mod % 2 > 0);\n\t// for(int i = 3; i * i <= x; i += 2) assert(x % i > 0);\n\t// assert(mod * mod < ulong.max);\n\t\nconst int nmax = 1_000_000;\n\t\t\nulong sum(ulong[] xs ...){\n\tulong ans = 0;\n\tforeach(x; xs){\n\t\tans += x;\n\t\tans %= mod;\n\t\t}\n\treturn ans;\n\t}\n\nulong diff(ulong x, ulong y){\n\treturn sum(x, neg(y));\n\t}\n\nulong neg(ulong x){\n\tassert(x < mod);\n\treturn (mod - x) % mod;\n\t}\n\nulong prod(ulong[] xs ...){\n\tulong ans = 1;\n\tforeach(x; xs){\n\t\tans *= x;\n\t\tans %= mod;\n\t\t}\n\treturn ans;\n\t}\n\nulong quot(ulong x, ulong y){\n\tassert(y > 0);\n\tassert(y < nmax);\n\treturn prod(x, inv(y));\n\t}\n\nulong inv(ulong x){\n\tassert(x > 0);\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _inv;\n\tif(!inited){\n\t\t_inv[1] = 1;\n\t\tforeach(i; 2 .. nmax){\n\t\t\t_inv[i] = (mod - mod / i) * _inv[mod % i] % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _inv[cast(int) x];\n\t}\n\nulong frac(ulong x){\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _frac;\n\tif(!inited){\n\t\t_frac[0] = 1;\n\t\tforeach(i; 1 .. nmax){\n\t\t\t_frac[i] = _frac[i - 1] * i % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _frac[cast(int) x];\n\t}\n\nulong invfrac(ulong x){\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _invfrac;\n\tif(!inited){\n\t\t_invfrac[0] = 1;\n\t\tforeach(i; 1 .. nmax){\n\t\t\t_invfrac[i] = _invfrac[i - 1] * inv(i) % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _invfrac[cast(int) x];\n\t}\n\nulong binom(ulong n, ulong k){\n\tassert(n < nmax);\n\tassert(k <= n);\n\treturn prod(frac(n), invfrac(k), invfrac(n - k));\n\t}\n\n// ----- library mod end -----\n\n\n\n\nconst DEBUG = 0;\n\n\nvoid main(){\n\tint n = read.to!int;\n\t\n\tlong[nmax] ys;\n\tlong[nmax] xs;\n\t\n\tforeach(k; 0 .. (n + 1) / 2){\n\t\tys[k] = 0;\n\t\t}\n\tforeach(k; (n + 1) / 2 .. n + 1){\n\t\tys[k] = prod(binom(k - 1, 2 * k - n), frac(k));\n\t\t}\n\t\n\tforeach(k; 0 .. (n + 1) / 2){\n\t\txs[k] = 0;\n\t\t}\n\tforeach(k; (n + 1) / 2 .. n + 1){\n\t\txs[k] = diff(ys[k], prod(ys[k - 1], (n - k)));\n\t\t}\n\t\n\tif(DEBUG) ys[0 .. n + 1].writeln;\n\tif(DEBUG) xs[0 .. n + 1].writeln;\n\t\n\tlong sum = 0;\n\tforeach(k; 0 .. n){\n\t\tsum += prod(xs[k], k);\n\t\tsum %= mod;\n\t\t}\n\t\n\tsum.writeln;\n\t}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array, std.typecons;\nimport std.math, std.numeric;\n\nimmutable long mod = 10L^^9 + 7;\n\nvoid main() {\n    int n; scan(n);\n\n    auto fact = new long[](n + 1);\n    auto rfact = new long[](n + 1);\n    fact[0] = 1;\n    foreach (i ; 1 .. n + 1) {\n        fact[i] = (fact[i-1] * i) % mod;\n    }\n    rfact[n] = powmod(fact[n], mod - 2, mod);\n    foreach_reverse (i ; 0 .. n) {\n        rfact[i] = (rfact[i+1] * (i+1)) % mod;\n    }\n    debug {\n        writeln(fact);\n        writeln(rfact);\n    }\n    long binom(int n, int k) {\n        return fact[n] * rfact[k] % mod * rfact[n-k] % mod;\n    }\n\n    long ans;\n    long pre;\n\n    foreach (k ; 0 .. n) {\n        int b = n - 2 - (k - 1);\n        if (b < 0 || b > k - 1) continue;\n        long v = binom(k - 1, b) * fact[k] % mod * fact[n - 1 - k] % mod;\n        debug {\n            writeln(k, \" \", v);\n        }\n        ans += k * (v - pre + mod) % mod;\n        ans %= mod;\n        pre = v;\n    }\n\n    writeln(ans);\n}\n\n\n\nlong powmod(long x, long y, long mod) {\n    return y > 0 ? powmod(x, y>>1, mod)^^2 % mod * x^^(y&1) % mod : 1L;\n}\n\n\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.bigint;\nimport std.math, std.random, std.datetime;\nimport std.array, std.range, std.algorithm, std.container;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n\n// ----- library mod -----\n\nconst ulong mod = 1_000_000_007;\n\t// assert(mod % 2 > 0);\n\t// for(int i = 3; i * i <= x; i += 2) assert(x % i > 0);\n\t// assert(mod * mod < ulong.max);\n\t\nconst int nmax = 1_000_000;\n\t\t\nulong sum(ulong[] xs ...){\n\tulong ans = 0;\n\tforeach(x; xs){\n\t\tans += x;\n\t\tans %= mod;\n\t\t}\n\treturn ans;\n\t}\n\nulong diff(ulong x, ulong y){\n\treturn sum(x, neg(y));\n\t}\n\nulong neg(ulong x){\n\tassert(x < mod);\n\treturn (mod - x) % mod;\n\t}\n\nulong prod(ulong[] xs ...){\n\tulong ans = 1;\n\tforeach(x; xs){\n\t\tans *= x;\n\t\tans %= mod;\n\t\t}\n\treturn ans;\n\t}\n\nulong quot(ulong x, ulong y){\n\tassert(y > 0);\n\tassert(y < nmax);\n\treturn prod(x, inv(y));\n\t}\n\nulong inv(ulong x){\n\tassert(x > 0);\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _inv;\n\tif(!inited){\n\t\t_inv[1] = 1;\n\t\tforeach(i; 2 .. nmax){\n\t\t\t_inv[i] = (mod - mod / i) * _inv[mod % i] % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _inv[cast(int) x];\n\t}\n\nulong frac(ulong x){\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _frac;\n\tif(!inited){\n\t\t_frac[0] = 1;\n\t\tforeach(i; 1 .. nmax){\n\t\t\t_frac[i] = _frac[i - 1] * i % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _frac[cast(int) x];\n\t}\n\nulong invfrac(ulong x){\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _invfrac;\n\tif(!inited){\n\t\t_invfrac[0] = 1;\n\t\tforeach(i; 1 .. nmax){\n\t\t\t_invfrac[i] = _invfrac[i - 1] * inv(i) % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _invfrac[cast(int) x];\n\t}\n\nulong binom(ulong n, ulong k){\n\tassert(n < nmax);\n\tassert(k <= n);\n\treturn prod(frac(n), invfrac(k), invfrac(n - k));\n\t}\n\n// ----- library mod end -----\n\n\n\n\nconst DEBUG = 0;\n\n\nvoid main(){\n\tint n = read.to!int;\n\t\n\tlong[nmax] ys;\n\tlong[nmax] xs;\n\t\n\tforeach(k; 0 .. (n + 1) / 2){\n\t\tys[k] = 0;\n\t\t}\n\tforeach(k; (n + 1) / 2 .. n + 1){\n\t\tys[k] = binom(k - 1, 2 * k - n) * frac(k);\n\t\tys[k] %= mod;\n\t\t}\n\t\n\tforeach(k; 0 .. (n + 1) / 2){\n\t\txs[k] = 0;\n\t\t}\n\tforeach(k; (n + 1) / 2 .. n + 1){\n\t\txs[k] = ys[k];\n\t\txs[k] += neg(prod(ys[k - 1] * (n - k)));\n\t\txs[k] %= mod;\n\t\t}\n\t\n\tif(DEBUG) ys[0 .. n + 1].writeln;\n\tif(DEBUG) xs[0 .. n + 1].writeln;\n\t\n\tlong sum = 0;\n\tforeach(k; 0 .. n){\n\t\tsum += prod(xs[k], k);\n\t\tsum %= mod;\n\t\t}\n\t\n\tsum.writeln;\n\t}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"C\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.modint;\nalias Mint = ModInt!(10^^9 + 7);\n\n\nMint solve(int n) {\n    auto fact = factTable!Mint(10^^6 + 10^^5);\n    auto iFac = invFactTable!Mint(10^^6 + 10^^5);\n    if (n == 1) return Mint(1);\n\n    Mint ans = fact[n];\n    foreach (i; 1..n) {\n        Mint x = fact[n]*iFac[i]*iFac[n-i];\n        int a = 2*i-n-1;\n        if (0 <= a && a <= i-1) {\n            x -= fact[i-1]*iFac[a]*iFac[i-1-a];\n        }\n//        writeln(x, \" \", i);\n        ans += x * fact[i] * fact[n-i];\n    }\n    return ans;\n}\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) assert(!sc.hasNext);\n\n    int n;\n    sc.read(n);\n    n--;\n\n\n    writeln(solve(n));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/modint.d */\n// module dkh.modint;\n\n// import dkh.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n     \n    auto opBinary(string op:\"^^\", T)(T r) const {return pow(this, r, ModInt(1));}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return x^^(MD-2);};\n    string toString() const {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(T : DModInt!S, string S);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/numeric/primitive.d */\n// module dkh.numeric.primitive;\n\nimport std.traits, std.bigint;\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n \nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        m >>= 1;\n    }\n    return r % md;\n}\n\n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n\n \nT invMod(T)(T x, T md) {\n    auto r = extGcd!T(x, md);\n    assert(r[2] == 1);\n    auto z = r[0];\n    return (z % md + md) % md;\n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length != 0) {\n            enforce(readSingle(args[0]));\n            read(args[1..$]);\n        }\n    }\n    bool hasNext() {\n        return succ();\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto Comb = new Combination();\n\n    if (N == 2) {\n        writeln(1);\n        return;\n    }\n\n    if (N == 3) {\n        writeln(4);\n        return;\n    }\n\n    long ans = 0;\n    auto steps = new long[](N+1);\n    \n    foreach (k; 2..N+1) {\n        steps[k] = Comb.comb(k-1, N-k-1) * Comb.fact(k) % MOD * Comb.fact(N-k-1) % MOD;\n    }\n\n    foreach_reverse(k; 2..N+1) {\n        if (steps[k] == 0) continue;\n        steps[k] = steps[k] - steps[k-1];\n        steps[k] = (steps[k] % MOD + MOD) % MOD;\n        ans = (ans + steps[k] * k % MOD) % MOD;\n    }\n    \n    ans.writeln;\n}\n\nclass Combination {\n    immutable int MAX = 2*10^^6+1;\n    immutable long MOD = 10^^9+7;\n    long[] modinv;\n    long[] f_mod;\n    long[] f_modinv;\n    \n    this() {\n        modinv = new long[](MAX);\n        modinv[0] = modinv[1] = 1;\n        foreach(i; 2..MAX) {\n            modinv[i] = modinv[MOD.to!int % i] * (MOD - MOD / i) % MOD;\n        }\n\n        f_mod = new long[](MAX);\n        f_modinv = new long[](MAX);\n        f_mod[0] = f_mod[1] = 1;\n        f_modinv[0] = f_modinv[1] = 1;\n\n        foreach(i; 2..MAX.to!int) {\n            f_mod[i] = (i * f_mod[i-1]) % MOD;\n            f_modinv[i] = (modinv[i] * f_modinv[i-1]) % MOD;\n        }\n    }\n\n    long comb(int n, int k) {\n        if (n < 0 || k < 0 || n < k) return 0;\n        return f_mod[n] * f_modinv[n-k] % MOD * f_modinv[k] % MOD;\n    }\n\n    long fact(int n) {\n        if (n < 0) return 0;\n        return f_mod[n];\n    }\n}\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.bigint;\nimport std.math, std.random, std.datetime;\nimport std.array, std.range, std.algorithm, std.container;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n\n// ----- library mod -----\n\nconst ulong mod = 1_000_000_007;\n\t// assert(mod % 2 > 0);\n\t// for(int i = 3; i * i <= x; i += 2) assert(x % i > 0);\n\t// assert(mod * mod < ulong.max);\n\t\nconst int nmax = 1_000_000;\n\t\t\nulong sum(ulong[] xs ...){\n\tulong ans = 0;\n\tforeach(x; xs){\n\t\tans += x;\n\t\tans %= mod;\n\t\t}\n\treturn ans;\n\t}\n\nulong diff(ulong x, ulong y){\n\treturn sum(x, neg(y));\n\t}\n\nulong neg(ulong x){\n\tassert(x < mod);\n\treturn (mod - x) % mod;\n\t}\n\nulong prod(ulong[] xs ...){\n\tulong ans = 1;\n\tforeach(x; xs){\n\t\tans *= x;\n\t\tans %= mod;\n\t\t}\n\treturn ans;\n\t}\n\nulong quot(ulong x, ulong y){\n\tassert(y > 0);\n\tassert(y < nmax);\n\treturn prod(x, inv(y));\n\t}\n\nulong inv(ulong x){\n\tassert(x > 0);\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _inv;\n\tif(!inited){\n\t\t_inv[1] = 1;\n\t\tforeach(i; 2 .. nmax){\n\t\t\t_inv[i] = (mod - mod / i) * _inv[mod % i] % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _inv[cast(int) x];\n\t}\n\nulong frac(ulong x){\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _frac;\n\tif(!inited){\n\t\t_frac[0] = 1;\n\t\tforeach(i; 1 .. nmax){\n\t\t\t_frac[i] = _frac[i - 1] * i % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _frac[cast(int) x];\n\t}\n\nulong invfrac(ulong x){\n\tassert(x < nmax);\n\tstatic bool inited = false;\n\tstatic ulong[nmax] _invfrac;\n\tif(!inited){\n\t\t_invfrac[0] = 1;\n\t\tforeach(i; 1 .. nmax){\n\t\t\t_invfrac[i] = _invfrac[i - 1] * inv(i) % mod;\n\t\t\t}\n\t\tinited = true;\n\t\t}\n\treturn _invfrac[cast(int) x];\n\t}\n\nulong binom(ulong n, ulong k){\n\tassert(n < nmax);\n\tassert(k <= n);\n\treturn prod(frac(n), invfrac(k), invfrac(n - k));\n\t}\n\n// ----- library mod end -----\n\n\n\n\nconst DEBUG = 0;\n\n\nvoid main(){\n\tint n = read.to!int;\n\t\n\tlong[nmax] ys;\n\tlong[nmax] xs;\n\t\n\tforeach(k; 0 .. (n + 1) / 2){\n\t\tys[k] = 0;\n\t\t}\n\tforeach(k; (n + 1) / 2 .. n + 1){\n\t\tys[k] = binom(k - 1, 2 * k - n) * frac(k);\n\t\tys[k] %= mod;\n\t\t}\n\t\n\tforeach(k; 0 .. (n + 1) / 2){\n\t\txs[k] = 0;\n\t\t}\n\tforeach(k; (n + 1) / 2 .. n + 1){\n\t\txs[k] = ys[k];\n\t\txs[k] += neg(prod(ys[k - 1] * (n - k - 1)));\n\t\txs[k] %= mod;\n\t\t}\n\t\n\tif(DEBUG) ys[0 .. n + 1].writeln;\n\tif(DEBUG) xs[0 .. n + 1].writeln;\n\t\n\tlong sum = 0;\n\tforeach(k; 0 .. n){\n\t\tsum += prod(xs[k], k);\n\t\tsum %= mod;\n\t\t}\n\t\n\tsum.writeln;\n\t}"
  },
  {
    "language": "Bash",
    "code": "\n/*\n\n    考虑一个可以用 K ((n+1)/2 <= K < n)次染黑的方案，\n\n\t那么将操作前K次的机器从小到大排序，一定是:\n\n\ta1=1 < a2 < ...< ak=n-1\n\n\t并且 a[i+1]-a[i] <= 2\n\n\t\n\n\t转化模型，就是一个变量初始等于 1 ,每次操作可以 +1 或者 +2 ,\n\n\tk-1 次操作之后 = n-1 的方案数. \n\n\t\n\n\tC(k-1 , n-k-1) * (k!) * ((n-k-1)!)\n\n*/\n\n#include<bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\nconst int ha=1e9+7,N=1e6+5,mod=ha-1;\n\n \n\ninline int add(int x,int y){ x+=y; return x>=ha?x-ha:x;}\n\ninline void ADD(int &x,int y){ x+=y; if(x>=ha) x-=ha;}\n\n \n\ninline int ksm(int x,int y){\n\n    int an=1;\n\n    for(;y;y>>=1,x=x*(ll)x%ha) if(y&1) an=an*(ll)x%ha;\n\n    return an;\n\n}\n\n \n\nint n,jc[N],ni[N],ans,f[N]; \n\n \n\ninline void init(){\n\n    jc[0]=1;\n\n    for(int i=1;i<=n;i++) jc[i]=jc[i-1]*(ll)i%ha;\n\n    ni[n]=ksm(jc[n],ha-2);\n\n    for(int i=n;i;i--) ni[i-1]=ni[i]*(ll)i%ha;\n\n}\n\n \n\ninline void solve(){\n\n\tfor(int k=n+1>>1;k<n;k++) f[k]=jc[k]*(ll)jc[k-1]%ha*(ll)ni[2*k-n]%ha;\n\n\tfor(int k=n+1>>1;k<n;k++) ADD(ans,add(f[k],ha-f[k-1])*(ll)k%ha);\n\n}\n\n \n\nint main(){\n\n\tscanf(\"%d\",&n),init();\n\n\tsolve(),printf(\"%d\\n\",ans);\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "Bash",
    "code": "\n#include<iostream>\n\n#include<cstdio>\n\n#include<cstdlib>\n\n#include<cstring>\n\n#include<cmath>\n\n#include<algorithm>\n\n#include<vector>\n\n#define re register\n\n#define il inline\n\n#define ll long long\n\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define min(a,b) ((a)<(b)?(a):(b))\n\n#define fp(i,a,b) for(re int i=a;i<=b;i++)\n\n#define fq(i,a,b) for(re int i=a;i>=b;i--)\n\nusing namespace std;\n\nconst int mod=1e9+7,N=1e6+100;\n\nll n,x,jc[N],p,ans,Need,f[N],inv[N];\n\nil ll gi()\n\n{\n\n  re ll x=0,t=1;\n\n  re char ch=getchar();\n\n  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n\n  if(ch=='-') t=-1,ch=getchar();\n\n  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();\n\n  return x*t;\n\n}\n\nil ll C(re ll x,re ll y)\n\n{\n\n  return jc[y]*inv[y-x]%mod*inv[x]%mod;\n\n}\n\nint main()\n\n{\n\n  n=gi();Need=(n+1)/2;\n\n  jc[0]=inv[0]=inv[1]=1;\n\n  fp(i,2,n) inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;//printf(\"%lld \",inv[i]);\n\n  fp(i,1,n) jc[i]=jc[i-1]*i%mod;\n\n  fp(i,2,n) inv[i]=inv[i]*inv[i-1]%mod;\n\n  fp(i,Need,n-1) f[i]=C(n-i-1,i-1)*jc[i]%mod*jc[n-i-1]%mod;\n\n  fq(i,n-1,Need) f[i]=(f[i]-f[i-1]+mod)%mod;\n\n  fp(i,Need,n-1) (ans+=(f[i]*i%mod))%=mod;\n\n  printf(\"%lld\\n\",ans);\n\n  return 0;\n\n}\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false\n  result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) > int(' '):\n      get = true\n      result.add(c)\n    else:\n      if get: break\n      get = false\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate infty(T): untyped = ((T(1) shl T(sizeof(T)*8-2)) - 1)\n#}}}\n\n#{{{ gcd and inverse\nconst GCD_H = 0\n\nproc gcd(a,b:int):int=\n  if b == 0: return a\n  else: return gcd(b,a mod b)\nproc lcm(a,b:int):int=\n  return a div gcd(a, b) * b\n# a x + b y = gcd(a, b)\nproc extgcd(a,b:int, x,y:var int):int =\n  var\n    g = a\n  x = 1\n  y = 0\n  if b != 0:\n    g = extgcd(b, a mod b, y, x)\n    y -= (a div b) * x\n  return g;\n\nproc invMod(a,m:int):int =\n  var\n    x,y:int\n  if extgcd(a, m, x, y) == 1: return (x + m) mod m\n  else: return 0 # unsolvable\n#}}}\n\nconst MOD = 1_000_000_007\n#{{{ Mint\ntype Mint = object\n  v:int\nproc newMint[T](a:T):Mint =\n  return Mint(v:a mod MOD)\nproc newMint(a:Mint):Mint =\n  return a\nproc `+=`[T](a:var Mint, b:T):void =\n  a.v += newMint(b).v\n  if a.v >= MOD:\n    a.v -= MOD\nproc `+`[T](a:Mint,b:T):Mint =\n  var c = a\n  c += b\n  return c\nproc `*=`[T](a:var Mint,b:T):void =\n  a.v *= newMint(b).v\n  a.v = a.v mod MOD\nproc `*`[T](a:Mint,b:T):Mint =\n  var c = a\n  c *= b\n  return c\nproc `-`(a:Mint):Mint =\n  if a.v == 0: return a\n  else: return Mint(v:MOD - a.v)\nproc `-=`[T](a:var Mint,b:T):void =\n  a.v -= newMint(b).v\n  if a.v < 0:\n    a.v += MOD\nproc `-`[T](a:Mint,b:T):Mint =\n  var c = a\n  c -= b\n  return c\nproc `$`(a:Mint):string =\n  return $(a.v)\nwhen declared(GCD_H):\n  proc `/=`[T](a:var Mint,b:T):void =\n    a.v *= invMod(newMint(b).v,MOD)\n    a.v = a.v mod MOD\n  proc `/`[T](a:Mint,b:T):Mint =\n    var c = a\n    c /= b\n    return c\n#}}}\n\n#{{{ fact, comb, perm\nvar\n  factorial_val = @[newMint(1)]\n  comb_val = @[@[newMint(1)]]\n\nproc fact(n:int):Mint =\n  for i in len(factorial_val)..n:\n    factorial_val.add(factorial_val[i-1] * i)\n  return factorial_val[n]\nproc comb_memo(n,r:int):Mint =\n  if n<0 or r<0 or n<r:\n    return newMint(0)\n  while comb_val.len < n + 1:\n    var t = comb_val.len\n    comb_val.add(newSeqWith(t + 1, newMint(0)))\n    comb_val[t][0] = newMint(1)\n    comb_val[t][t] = newMint(1)\n    for i in 1..t-1:\n      comb_val[t][i] = comb_val[t-1][i-1] + comb_val[t-1][i]\n  return comb_val[n][r]\n\nwhen declared(GCD_H):\n  proc comb(n,r:int):Mint =\n    if n<0 or r<0 or n<r:\n      return newMint(0)\n    else:\n      return fact(n)/(fact(r)*fact(n-r))\n  proc perm(n,r:int):Mint =\n    if n<0 or n<r:\n      return newMint(0)\n    else:\n      return fact(n)/fact(n-r)\n#}}}\n\n\nproc main():void =\n  var\n    N = nextInt()\n    ans = newMint(0)\n    sum0 = newMint(0)\n  if N == 2:\n    echo 1\n    return\n  for k in 0..N-2:\n    var\n      sum = newMint(0)\n    block:\n      var\n        t = N - 2 - (2 * (k-1) + 3)\n      if k >= 1 and t >= 0:\n        sum += comb(t + k, k) * 2 * k\n    block:\n      var\n        t = N - 2 - (2 * (k-2) + 4)\n      if k >= 2 and t >= 0:\n        sum += comb(t + k - 1, k - 1) * (k-1)\n    block:\n      var\n        t = N - 4 - 2 * (k - 1)\n      if k >= 1 and t >= 0:\n        sum += comb(t + k - 1, k - 1) * 2\n    block:\n      var\n        t = N - 3 - (2 * k)\n      if t >= 0:\n        sum += comb(t + k, k) * 2\n    sum *= fact(N - 2 - k) * fact(k)\n    sum0 += sum\n    ans += sum * (N - 1 - k)\n  echo ans\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readLine*(): string =\n  stdin.readLine()\nproc readSeq*(): seq[string] =\n  readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = readLine().strip()\nproc readInt1*(): int =\n  readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\nproc newSeqWith*[T](n: Natural; e: T): seq[T] =\n  result = newSeq[T](n)\n  for i in 0..<n:\n    result[i] = e\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] =\n  newSeqWith(n1, newSeq[T](n2))\ntype seq3*[T] = seq[seq[seq[T]]]\nproc newSeq3*[T](n1, n2, n3: Natural): seq3[T] =\n  newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\n\n#------------------------------------------------------------------------------#\nconst MOD = int(10^9+7)\n\ntype Op1[T] = proc(a: T, b: T): T\ntype Op2[T] = proc(a: T, b: T): T\n\nproc repeatedSquares[T](x: T, n: Natural, e: T, f: Op2[T]): T =\n    result = e\n    var xx = f(x, e)\n    var i = n\n    while i > 0:\n        if (i and 1) != 0:\n            result = f(result, xx)\n        xx = f(xx, xx)\n        i = i shr 1\n\nproc addM(a, b: Natural): Natural = (a + b) mod MOD\nproc subM(a, b: Natural): Natural = (a - b + MOD) mod MOD\nproc mulM(a, b: Natural): Natural = a * b mod MOD\nproc powM(a, b: Natural): Natural = repeatedSquares[Natural](a, b, 1, `mulM`)\nproc invM(a: Natural): Natural = a.powM(MOD - 2)\nproc divM(a, b: Natural): Natural = a.mulM(invM(b))\n\nvar memoFactM: seq[Natural] = nil\nvar memoFactInvM: seq[Natural] = nil\n\nproc buildFactTable(n: Natural) =\n  memoFactM = newSeq[Natural](n + 1)\n  memoFactM[0] = 1\n  for i in 1..n:\n    memoFactM[i] = memoFactM[i - 1].mulM(i)\n\n  memoFactInvM = newSeq[Natural](n + 1)\n  memoFactInvM[n] = invM(memoFactM[n])\n  for i in countdown(n - 1, 0):\n    memoFactInvM[i] = memoFactInvM[i + 1].mulM(i + 1)\n\nbuildFactTable(10^6)\n\nproc factM(n: Natural): Natural = memoFactM[n]\n\nproc factInvM(n: Natural): Natural = memoFactInvM[n]\n\nproc combM(n, r: Natural): Natural =\n  if r > n:\n    return 0\n  if r > n div 2:\n    return combM(n, n - r)\n\n  result = factM(n).mulM(factInvM(n - r)).mulM(factInvM(r))\n\nproc multCombM(n, r: Natural): Natural = combM(n + r - 1, r - 1)\n\n#------------------------------------------------------------------------------#\n\nproc main() =\n  let n = readInt1()\n\n  if n <= 2:\n    echo 1\n    return\n\n  var ans = 0\n  var sum = 0\n  for k in 2..<n:\n    if n - 1 - k notin 0..(k - 1):\n      continue\n    let comb = (k - 1).combM(n - 1 - k).mulM(factM(k)).mulM(factM(n - 1 - k))\n    ans = ans.addM(comb.subM(sum).mulM(k))\n    sum = sum.addM(comb.subM(sum))\n  echo ans\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "# import sequtils, strutils, strscans, algorithm, math, future, sets, queues, tables # for yukicoder (0.17.1)\nimport sequtils, strutils, algorithm, math, future, sets, queues, tables # for AtCoder (0.13.0)\ntemplate getLine: string = stdin.readLine\ntemplate getInteger: int = getLine.parseInt\ntemplate getBiggestInteger: int64 = getLine.parseBiggestInt\ntemplate getIntSeq: seq[int] = getLine.split.map(parseInt)\ntemplate getBigIntSeq: seq[int64] = getLine.split.map(parseBiggestInt)\n\nproc powmod[T](x, k, m: T): T =\n  if k == 0:\n    result = 1\n  elif k mod 2 == 0:\n    let x = powmod(x, k shr 1, m)\n    result = x * x mod m\n  else:\n    result = powmod(x, k-1, m) * x mod m\n\nproc inv[T](x: T, modulo: T = 1e9.int + 7): T =\n  return powmod(x, modulo - 2, modulo)\n\nwhen isMainModule:\n  let\n    N = getBiggestInteger\n    MOD = 1e9.int64 + 7\n  var fact, inv_fact = newSeq[int64](N)\n  fact[0] = 1.int64\n  inv_fact[0] = inv(fact[0])\n  for i in 1..(N.int - 1):\n    fact[i] = i.int64 * fact[i - 1] mod MOD\n    inv_fact[i] = inv(fact[i])\n  var ans, prev = 0.int64\n  for k in ((N.int + 1) div 2)..(N.int - 1):\n    let cnt = fact[k - 1] * inv_fact[k * 2 - N.int] mod MOD * fact[k] mod MOD\n    ans += (cnt - prev + MOD) mod MOD * k.int64\n    ans = ans mod MOD\n    prev = cnt\n  ans.echo\n"
  },
  {
    "language": "Nim",
    "code": "# import sequtils, strutils, strscans, algorithm, math, future, sets, queues, tables # for yukicoder (0.17.1)\nimport sequtils, strutils, algorithm, math, future, sets, queues, tables # for AtCoder (0.13.0)\ntemplate getLine: string = stdin.readLine\ntemplate getInteger: int = getLine.parseInt\ntemplate getBiggestInteger: int64 = getLine.parseBiggestInt\ntemplate getIntSeq: seq[int] = getLine.split.map(parseInt)\ntemplate getBigIntSeq: seq[int64] = getLine.split.map(parseBiggestInt)\n\nproc powmod[T](x, k, m: T): T =\n  if k == 0:\n    result = 1\n  elif k mod 2 == 0:\n    let x = powmod(x, k shr 1, m)\n    result = x * x mod m\n  else:\n    result = powmod(x, k-1, m) * x mod m\n\nproc inv[T](x: T, modulo: T = 1e9.int + 7): T =\n  return powmod(x, modulo - 2, modulo)\n\nwhen isMainModule:\n  let\n    N = getBiggestInteger\n    MOD = 1e9.int64 + 7\n  var fact, inv_fact = newSeq[int64](N)\n  fact[0] = 1\n  inv_fact[0] = inv(1)\n  for i in 1..(N.int - 1):\n    fact[i] = i * fact[i - 1] mod MOD\n    inv_fact[i] = inv(fact[i])\n  var ans, prev = 0.int64\n  for k in ((N.int + 1) div 2)..(N.int - 1):\n    let cnt = fact[k - 1] * inv_fact[k * 2 - N.int] mod MOD * fact[k] mod MOD\n    ans += (cnt - prev) * k\n    ans = ans mod MOD\n    prev = cnt\n  ans.echo\n"
  },
  {
    "language": "Nim",
    "code": "# import sequtils, strutils, strscans, algorithm, math, future, sets, queues, tables # for yukicoder (0.17.1)\nimport sequtils, strutils, algorithm, math, future, sets, queues, tables # for AtCoder (0.13.0)\ntemplate getLine: string = stdin.readLine\ntemplate getInteger: int = getLine.parseInt\ntemplate getBiggestInteger: int64 = getLine.parseBiggestInt\ntemplate getIntSeq: seq[int] = getLine.split.map(parseInt)\ntemplate getBigIntSeq: seq[int64] = getLine.split.map(parseBiggestInt)\n\nproc powmod[T](x, k, m: T): T =\n  if k == 0:\n    result = 1\n  elif k mod 2 == 0:\n    let x = powmod(x, k shr 1, m)\n    result = x * x mod m\n  else:\n    result = powmod(x, k-1, m) * x mod m\n\nproc inv[T](x: T, modulo: T = 1e9.int + 7): T =\n  return powmod(x, modulo - 2, modulo)\n\nwhen isMainModule:\n  let\n    N = getBiggestInteger\n    MOD = 1e9.int64 + 7\n  var fact, inv_fact = newSeq[int64](N)\n  fact[0] = 1.int64\n  inv_fact[0] = inv(fact[0])\n  for i in 1..(N.int - 1):\n    fact[i] = i.int64 * fact[i - 1] mod MOD\n    inv_fact[i] = inv(fact[i])\n  var ans, prev = 0.int64\n  for k in ((N.int + 1) div 2)..(N.int - 1):\n    let cnt = fact[k - 1] * inv_fact[k * 2 - N.int] mod MOD * fact[k] mod MOD\n    ans += (cnt - prev) * k.int64\n    ans = ans mod MOD\n    prev = cnt\n  ans.echo\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nn = int(input())\nnn = [i for i in range(0, n - 1)]\nans = 0\nfor element in itertools.permutations(nn, n - 1):\n    field = 0\n    tm = 0\n    for elm in element:\n        blk = (1 << elm) + (1 << (elm + 1))\n        field = field | blk\n        tm += 1\n        if field == (1 << n) - 1:\n            break\n    ans += tm\n    ans = ans % (10**9 + 7)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nMOD = 10**9 + 7\n\nv = 1\nfor K in range(2, (N+1)//2):\n    v = v * K * (K-1) % MOD\n\nb = 1\nans = cnt = 0\nfor K in range((N+1)//2, N):\n    v = v * K * (K-1) % MOD\n    ans += (v - cnt) * K % MOD\n    cnt = v\n    ans %= MOD\n    v = v * pow((2*K-N+1)*(2*K-N+2), MOD-2, MOD) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\nn = int(input())\nseq = [x for x in range(1,n)]\ntest_list = list(itertools.permutations(seq))\nscore = 0\n\nfor i in test_list:\n    key = True\n    ans_list = []\n    sc = 0\n    for j in i:\n        if key:\n            ans_list.append(j)\n            ans_list.append(j+1)\n\n            ans_num = len(set(ans_list))\n            sc += 1\n            if ans_num == n:\n                key = False\n\n    score += sc\n\nprint(score % (10**9 + 7))\n"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nMOD = 10**9 + 7\n\nfact = [1]*(N+1)\n\nfor i in range(1, N+1):\n    fact[i] = r = i*fact[i-1] % MOD\n\nans = cnt = 0\nfor K in range((N+1)//2, N):\n    res = fact[K]*fact[K-1]*pow(fact[2*K-N], MOD-2, MOD) % MOD\n    ans += (res - cnt) * K % MOD\n    cnt = res\n    ans %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\ndef exponen(input1,input2):\n    binaryl=list(str(bin(input2))[2:])\n    binarysize=len(binaryl)\n    binarylist=[int(binaryl[binarysize-1-i]) for i in range(binarysize)]\n    modlist=[0 for i in range(binarysize)]\n    modlist[0]=input1\n    for i in range(1,binarysize):\n        modlist[i]=times(modlist[i-1],modlist[i-1])\n    answer=1\n    for i in range(binarysize):\n        if binarylist[i]==1:\n            answer=times(answer,modlist[i])\n    return answer\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(i,Fact[i-1])\nans=0\ndef C(A,B):\n    return divide(Fact[A],times(Fact[B],Fact[A-B]))\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    F=times(Fact[K],Fact[N-1-K])\n    G=C(K-1,N-1-K)\n    SGL[K]=(times(F,G))\nfor K in range(1,N):\n    ans=plus(ans,times(SGL[K]-SGL[K-1],K))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\ndef exponen(input1,input2):\n    binaryl=list(str(bin(input2))[2:])\n    binarysize=len(binaryl)\n    binarylist=[int(binaryl[binarysize-1-i]) for i in range(binarysize)]\n    modlist=[0 for i in range(binarysize)]\n    modlist[0]=input1\n    for i in range(1,binarysize):\n        modlist[i]=times(modlist[i-1],modlist[i-1])\n    answer=1\n    for i in range(binarysize):\n        if binarylist[i]==1:\n            answer=times(answer,modlist[i])\n    return answer\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(i,Fact[i-1])\nans=0\ndef C(A,B):\n    return divide(Fact[A],times(Fact[B],Fact[A-B]))\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    F=times(Fact[K],Fact[N-1-K])\n    G=C(K-1,N-1-K)\n    SGL[K]=(times(F,G))\nfor K in range(1,N):\n    ans+=times(SGL[K]-SGL[K-1],K)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):#コンビネーションの高速計算　\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #出力の制限\nN = 10**6\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN=int(input())\n\nres=0\nW=0\nfor k in range((N-1)//2+1,N):\n    res+=(g1[N-1-k]*g1[k]*cmb(k-1,N-k-1,mod)-W)*k\n    res%=mod\n    W=cmb(k-1,N-k-1,mod)*g1[k]*g1[N-1-k]\n\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "def C(n, m):\n\treturn 0 if n < m else fact[n] * inv[m] % MOD * inv[n - m] % MOD\n\nMOD = 1000000007\nn = int(raw_input())\nfact = [1] * (n + 1)\ninv = [1] * (n + 1)\nfor i in range(1, n + 1):\n\tfact[i] = fact[i - 1] * i % MOD\ninv[n] = pow(fact[n], MOD - 2, MOD)\nfor i in range(n, 0, -1):\n\tinv[i - 1] = inv[i] * i % MOD\nans = 0\nfor i in range(1, n):\n\tans += C(i - 1, n - i - 1) * fact[i] % MOD * fact[n - i - 1] % MOD\nprint (fact[n - 1] * n - ans % MOD + MOD) % MOD"
  },
  {
    "language": "Python",
    "code": "N = int(input()) - 1\n\nLARGE = 10**9+7\n\ndef ex_euclid(x, y):\n    c0, c1 = x, y\n    a0, a1 = 1, 0\n    b0, b1 = 0, 1\n \n    while c1 != 0:\n        m = c0 % c1\n        q = c0 // c1\n \n        c0, c1 = c1, m\n        a0, a1 = a1, (a0 - q * a1)\n        b0, b1 = b1, (b0 - q * b1)\n \n    return c0, a0, b0\n# precompute\nfac_list = [1]*(N+1)\nfac = 1\nfor i in range(1, N+1):\n    fac = (fac * i) % LARGE\n    fac_list[i] = fac\n    \nfac_inv_list = [1]*(N+1)\nfor i in range(N+1):\n    fac_inv_list[i] =  pow(fac_list[i], LARGE-2, LARGE)\n    \ndef nCr(n, r):\n    return (((fac_list[n] * fac_inv_list[r]) % LARGE) * fac_inv_list[n-r]) % LARGE\n\ndef pat(n, r):\n    return (((fac_list[n] * fac_inv_list[r]) % LARGE) * fac_inv_list[n-r]) % LARGE\n\n\npat = 0\nscore = 0\n\nfor k in range(N+1):\n    if k-1 >= N-k:\n        res = (((fac_list[k-1]*fac_list[k]) % LARGE) * fac_inv_list[k-1-N+k]) % LARGE\n        score = (score + (res - pat) * k) % LARGE\n        # print(k, pat, res)\n        pat = res\nprint(score)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\nans = 0\nm = n - 1\nf = list(fact(m))\nperm = 0\n\nfor k in range((n+1)//2, n):\n    b = m - k\n    a = (m - 1) - (2 * b)\n    perm_ = f[a+b] * pow(f[a], p-2, p) %p * pow(f[b], p-2, p) %p * f[k] % p * f[m-k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm + perm_ %p\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 62;\n\nll factorial(ll n,ll mod = mod){\n  static ll dp[e5];\n  if(dp[n]) return dp[n];\n  if(n == 0) return dp[n] = 1;\n  return dp[n] = (n*factorial(n-1))%mod;\n}\n\nll powl(ll x,ll r,ll mod = mod){\n  ll ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nll inverse(ll x,ll mod = mod){\n  return powl(x,mod-2,mod);\n}\n\nll combination(ll n,ll m,ll mod = mod){\n  if(n < m) return 0;\n  return (((factorial(n)*inverse(factorial(m)))%mod)*inverse(factorial(n-m)))%mod;\n}\n\n\nll n;\nll ans = 0;\n\nll solve(ll k){\n  return (((combination(k-1,n-1-k)*factorial(k))%mod)*factorial(n-1-k))%mod;\n}\n\n\nint main(){\n  cin >> n;\n  if(n == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  for(ll i = 2;i <= n-1;i++){\n    ans += ((((solve(i)-solve(i-1)+mod)%mod)*i)%mod);\n    ans %= mod;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn = int(input())\n\nM = 10**9+7 # 出力の制限\nN = n+3 # 必要なテーブルサイズ\n\ng1 = [None] * (N+1) # 元テーブル\ng2 = [None] * (N+1) #逆元テーブル\ninverse = [None] * (N+1) #逆元テーブル計算用テーブル\ng1[0] = g1[1] = g2[0] = g2[1] = 1\ninverse[0], inverse[1] = [0, 1] \n\nfor i in range( 2, N + 1 ):\n    g1[i] = ( g1[i-1] * i ) % M \n    inverse[i] = ( -inverse[M % i] * (M//i) ) % M # ai+b==0 mod M <=> i==-b*a^(-1) <=> i^(-1)==-b^(-1)*aより\n    g2[i] = (g2[i-1] * inverse[i]) % M \n\ndef cmb(n, r, M):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return (g1[n] * g2[r] * g2[n-r]) % M\nans = 0\nprev = 0\n# s = 0\nfor i in range((n+1)//2, n):\n    tmp = (cmb(i-1, n-i-1, M) * g1[i] * g1[n-1-i])\n    ans += tmp\n#     ans += i*(tmp-prev)\n    prev = tmp\n#     print(i, tmp, g1[i], g1[n-1-i])\n    ans %= M\ni = n-1\nans = (i+1) * (cmb(i-1, n-i-1, M) * g1[i] * g1[n-1-i]) - ans\nans %= M\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "mod=10**9+7\nN=int(input())\nFact=[1 for i in range(N+1)]\nFinv=[1 for i in range(N+1)]\nfor i in range(N):\n    Fact[i+1]=(Fact[i]*(i+1))%mod\nFinv[N]=pow(Fact[N],mod-2,mod)\nfor i in range(N-1,-1,-1):\n    Finv[i]=((i+1)*Finv[i+1])%mod\nans=0\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    SGL[K]=(((Fact[K]*Finv[2*K-N])%mod)*Fact[K-1])\nfor K in range(1,N):\n    ans+=((SGL[K]-SGL[K-1])*K)%mod\n    ans%=mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "\nN = int(input())\n\nF = [1]\n#F_ = [1]\nn = 1\nfor i in range(1, N):\n    n *= i\n    n %= 1e9+7\n    F.append(n)\n    #F_.append(1/n)\n#print(F)\n\nC = lambda n,r: (F[n]/(F[r]*F[n-r]))%(1e9+7)\n\nans = 0\ncnt = 0\nfor i in range((N+1)//2, N):\n    #print(i, N-i-1,C(i-1, N-i-1),F[i],F[N-i-1])\n    tmp = C(i-1, N-i-1)*F[i]*F[N-i-1]\n    ans += (tmp-cnt)%(1e9+7)*i\n    cnt = tmp\nprint(int(ans%(1e9+7)))\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\n\nmod=10**9+7\n\nFACT=[1]\nfor i in range(1,10**6+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(10**6,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nANS=0\nMINUS=0\n\ndef k_perm(k):\n    return Combi(k-1,N-k-1)*FACT[k]*FACT[N-k-1]%mod\n\nfor k in range(N):\n    ANS=(ANS+(k_perm(k)-k_perm(k-1))*k)%mod\n\nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "N = int(input()) - 1\n\nLARGE = 10**9+7\n\ndef ex_euclid(x, y):\n    c0, c1 = x, y\n    a0, a1 = 1, 0\n    b0, b1 = 0, 1\n \n    while c1 != 0:\n        m = c0 % c1\n        q = c0 // c1\n \n        c0, c1 = c1, m\n        a0, a1 = a1, (a0 - q * a1)\n        b0, b1 = b1, (b0 - q * b1)\n \n    return c0, a0, b0\n# precompute\nfac_list = [1]*(N+1)\nfac = 1\nfor i in range(1, N+1):\n    fac = (fac * i) % LARGE\n    fac_list[i] = fac\n    \nfac_inv_list = [1]*(N+1)\nfor i in range(N+1):\n    fac_inv_list[i] =  pow(fac_list[i], LARGE-2, LARGE)\n    \ndef nCr(n, r):\n    return (((fac_list[n] * fac_inv_list[r]) % LARGE) * fac_inv_list[n-r]) % LARGE\n\ndef pat(n, r):\n    return (((fac_list[n] * fac_inv_list[r]) % LARGE) * fac_inv_list[n-r]) % LARGE\n\n\npat = 0\nscore = 0\n\nfor k in range(N+1):\n    if k-1 >= N-k:\n        res = (((fac_list[k-1]*fac_list[k]) % LARGE) * fac_inv_list[k-1-N+k]) % LARGE\n        score = (score + (res - pat) * k) % LARGE\n        # print(k, pat, res)\n        pat = res\nprint(score)"
  },
  {
    "language": "Python",
    "code": "import sys\nN=int(input())\nif N==2:\n    print(1)\n    sys.exit()\nif N==3:\n    print(2)\n    sys.exit()\nmod=10**9+7\ntable=[1]*(N+3)\nt=1\nfor i in range(1,N+3):\n    t*=i\n    t%=mod\n    table[i]=t\nrtable=[1]*(N+3)\nt=1\nfor i in range(1,N+3):\n    t*=pow(i,mod-2,mod)\n    t%=mod\n    rtable[i]=t\n#print(table,rtable)\nans=0\nl=0\nfor k in range(N):\n    if 0>2*k-N:\n        continue\n    num=table[k]*table[N-1-k]\n    div=table[k-1]*rtable[N-1-k]*rtable[k-1-(N-1-k)]\n    div%=mod\n    num*=div\n    num%=mod\n    ans+=k*(num-l)\n    l=num\n    l%=mod\n    ans%=mod\n    #print(k, num, div)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\n\nans = 0\nm = n - 1\nf = list(fact(m))\nperm = 0\n\nfor k in range(n//2, n):\n    b = m - k\n    a = (m - 1) - (2 * b)\n    perm_ = f[a+b]//(f[a]*f[b]) %p * f[k] % p * f[m-k] % p\n    ans += (perm_ - perm) * k % p\n    perm += perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nN = int(input())\n\nmod = 1000000007\n\ndef euclid(a, b):\n    (x, lastx) = (0, 1)\n    (y, lasty) = (1, 0)\n    while b != 0:\n        q = a // b\n        (a, b) = (b, a % b)\n        (x, lastx) = (lastx - q * x, x)\n        (y, lasty) = (lasty - q * y, y)\n    return (lastx, lasty, a)\n\n_modinv = {}\ndef modinv(a):\n    if a not in _modinv:\n        inv, _, _ = euclid(a, mod)\n        _modinv[a] = inv%mod\n    return _modinv[a]\n\n_factorial = {0: 1, 1: 1}\ndef factorial(n):\n    if n not in _factorial:\n        _factorial[n] = factorial(n-1)*n%mod\n    return _factorial[n]\n\ndef comb(n, k):\n    return factorial(n)*modinv(factorial(k))*modinv(factorial(n-k))%mod\n\nif N == 2:\n    print(1)\n    exit()\nif N == 3:\n    print(4)\n\nres = 0\nmem = 0\n    \nfor K in range((N+1)//2, N):\n    tmp = factorial(K)*factorial(N-1-K)*comb(K-1, N-K-1)\n    just = (tmp-mem)%mod\n    mem = tmp\n    res += K*just\n    res %= mod\n    \nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "P=10**9+7\ndef egcd(a, b):\n    (x, lastx) = (0, 1)\n    (y, lasty) = (1, 0)\n    while b != 0:\n        q = a // b\n        (a, b) = (b, a % b)\n        (x, lastx) = (lastx - q * x, x)\n        (y, lasty) = (lasty - q * y, y)\n    return (lastx, lasty, a)\ndef inv(x):\n    return egcd(x,P)[0]\nN=int(input())\nFact=[0 for i in range(N+1)]\nFinv=[0 for i in range(N+1)]\nFact[0]=1\nFinv[0]=1\nfor i in range(N):\n    Fact[i+1]=((i+1)*Fact[i])%P\n    Finv[i+1]=(Finv[i]*inv(i+1))%P\nSGN=[0 for i in range(N)]\nans=0\nfor k in range(N):\n    if 2*k-N>=0:\n        SGN[k]=(((Fact[k-1]*Fact[k])%P)*Finv[2*k-N])%P\n        ans=(ans+k*(SGN[k]-SGN[k-1]))%P\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfrom numba import jit\nimport collections\n\nn = int(input())\nmachine = []\nfor i in range(n-1):\n    machine.append(i)\nresult = []\nl = []\nfor i in permutations(machine):\n    for _ in range(n):\n        l.append(1)\n    score = 0\n    for j in i:\n        l[j] = -1\n        l[j + 1] = -1\n        score += 1\n        if(all(x == -1 for x in l)):\n            result.append(score)\n            l.clear()\n            break\ntemp = collections.Counter(result)\nans = 0\nfor k,v in temp.items():\n    ans += k*v\nprint(ans%(10**9+7))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\nans = 0\nm = n - 1\nf = list(fact(m))\nperm = 0\n\nfor k in range((n+1)//2, n):\n    b = m - k\n    a = (m - 1) - (2 * b)\n    perm_ = f[a+b] * pow(f[a], p-2, p) %p * pow(f[b], p-2, p) %p * f[k] % p * f[m-k] % p\n    ans += (perm_ - perm) %p * k % p\n    perm = perm + perm_ %p\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\nans = 0\nm = n - 1\nf = list(fact(m))\nperm = 0\n\nfor k in range((n+1)//2, n):\n    b = m - k\n    a = (m - 1) - (2 * b)\n    perm_ = f[a+b] * pow(f[a], p-2, p) %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfn,fk,mod = [1]*n,[1]*n,10**9+7\nfor i in range(n-1): fn[i+1] = (fn[i]*(i+2))%mod\ndef power(n,k):\n\tif k==1: return n\n\telif k%2==0: return power((n**2)%mod,k//2)\n\telse: return (n*power(n,k-1))%mod\ndef comb(n,k):\n\tif n<k or k<0: return 0\n\telif k==0 or n==k: return 1\n\telse: return (((fn[n-1]*fk[n-k-1])%mod)*fk[k-1])%mod\nfk[-1] = power(fn[-1],mod-2)\nfor i in range(2,n+1): fk[-i] = (fk[-i+1]*(n+2-i))%mod\nfn.append(1)\nans = fn[n-2]*(n-1)\nfor i in range(n-2,(n-1)//2,-1):\n\tans = (ans-comb(i-1,n-i-1)*fn[i-1]*fn[n-i-2])%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\ndef invfact(n, f, p):\n    m = pow(f[n], p-2, p)\n    yield m\n    for i in range(n, 0, -1):\n        m = m * i % p\n        yield m\n\nans = 0\nm = n - 1\nf = list(fact(m))\nrf = list(invfact(m, f, p))\nrf.reverse()\nperm = 0\n\nfor k in range((n+1)//2, n):\n    perm_ = f[k-1] * rf[2*k-n-2] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import itertools\na=list(range(1,int(input())))\nb=[]\nfor i in itertools.permutations(a):\n    for I in range(len(i)):\n        if len(set(n+z for z in [0,1]for n in i[0:I+1]))>max(a):\n            b+=[I+1];break\nprint(sum(b))\n"
  },
  {
    "language": "Python",
    "code": "MOD = (10 ** 9) + 7\n\nlist_size = 1000000\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\ndef power(n, x):\n\tif x == 1:\n\t\treturn n\n\telif x % 2 == 0:\n\t\treturn power(int((n * n) % MOD), int(x / 2))\n\telse:\n\t\treturn int((n * power(n, x - 1)) % MOD)\n\nf_r_list[-1] = power(f_list[-1], MOD - 2)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\ndef factorial(i):\n\tif i == 0:\n\t\treturn 1\n\telse:\n\t\treturn f_list[i-1]\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nn = int(input())\nans = ((n - 1) * factorial(n - 1)) % MOD\nfor i in range(n - 2, (n + 1) // 2 - 1, -1):\n\tans -= comb(i - 1, n - i - 1) * factorial(n - i - 1) * factorial(i)\n\tans %= MOD\n\t#print(ans, cnt)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n, p):\n    n_ = [1]\n    for i in range(1, n+1):\n         n_.append((n_[-1]*i) % p)\n    return n_\n\ndef invfact(n, f, p):\n    m = [pow(f[n], p-2, p)]\n    for i in range(n, 0, -1):\n        m.append(m[-1] * i % p)\n    return m\n\nans = 0\nm = n - 1\nf = fact(m, p)\nrf = invfact(m, f, p)\nrf.reverse()\nperm = 0\n\nfor k in range((n+1)//2, n):\n    perm_ = f[k-1] * rf[2*k-n] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\n'''\ndef exponen(input1,input2):\n    binaryl=list(str(bin(input2))[2:])\n    binarysize=len(binaryl)\n    binarylist=[int(binaryl[binarysize-1-i]) for i in range(binarysize)]\n    modlist=[0 for i in range(binarysize)]\n    modlist[0]=input1\n    for i in range(1,binarysize):\n        modlist[i]=times(modlist[i-1],modlist[i-1])\n    answer=1\n    for i in range(binarysize):\n        if binarylist[i]==1:\n            answer=times(answer,modlist[i])\n    return answer\n'''\ndef exponen(input1,input2):\n    if input2==0:\n        return 1\n    elif input2%2==0:\n        return exponen(times(input1,input1),input2//2)\n    else:\n        return times(input1,exponen(times(input1,input1),input2//2))\n\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nFinv=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(Fact[i-1],i)\n    Finv[i]=divide(1,Fact[i])\nans=0\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    SGL[K]=times(times(Fact[K],Finv[2*K-N]),Fact[K-1])\nfor K in range(1,N):\n    ans=plus(ans,times(SGL[K]-SGL[K-1],K))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import exit, setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import bisect\n\ndef read():\n  return int(input())\n\ndef reads():\n  return [int(x) for x in input().split()]\n\nMOD = 10**9 + 7\n\nN = read()\n\nNN = N + 1\nfact = [1] * NN\nfor i in range(1, NN):\n  fact[i] = (fact[i-1] * i) % MOD\n\ndef inv(n):\n  return pow(n, MOD-2, MOD)\n\ndef comb(n, k):\n  return fact[n] * inv(fact[n-k]) % MOD * inv(fact[k]) % MOD\n\nS = [0] * N\nfor k in range((N+1) // 2, N):\n  S[k] = comb(k-1, N-1-k) * fact[k] % MOD * fact[N-1-k] % MOD\n\nans = 0\nfor k in range((N+1) // 2, N):\n  ans = (ans + k * (S[k] - S[k-1]) % MOD) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def C(n,m):return 0 if n<m else fact[n]*inv[m]%MOD*inv[n-m]%MOD\nMOD=1000000007\nn=int(raw_input())\nfact=[1]*(n+1)\ninv=[1]*(n+1)\nfor i in range(1,n+1):fact[i]=fact[i-1]*i%MOD\ninv[n]=pow(fact[n],MOD-2,MOD)\nfor i in range(n,0,-1):inv[i-1]=inv[i]*i%MOD\nans=0\nfor i in range(1,n):ans+=C(i-1,n-i-1)*fact[i]%MOD*fact[n-i-1]%MOD\nprint(fact[n-1]*n-ans%MOD+MOD)%MOD"
  },
  {
    "language": "Python",
    "code": "mod=10**9+7\nN=int(input())\n\nFactorial=[1]*(N+1)\nfor i in range(1,N+1):\n  Factorial[i]=Factorial[i-1]*(i)%mod\ndef power(x,y):\n  if y==0:\n    return 1\n  elif y==1:\n    return x%mod\n  elif y%2==0:\n    return power(x,y//2)**2%mod\n  else:\n    return (power(x,y//2)**2)*x%mod\n\ninverseFactorial=[1]*(N+1)\ninverseFactorial[N]=power(Factorial[N],mod-2)\nfor i in range(0,N)[::-1]:\n  inverseFactorial[i]=(inverseFactorial[i+1]*(i+1))%mod\n  \ndef comb(x,y):\n  if x<y or y<0:\n    return 0\n  else:\n    return (Factorial[x]*inverseFactorial[y]*inverseFactorial[x-y])%mod\n\nP=[0]*(N)\nfor k in range(N):\n  P[k]=(comb(k-1,2*k-N)*Factorial[k]*Factorial[N-1-k])%mod\nans=0\nfor k in range(1,N):\n  ans=(ans+k*(P[k]-P[k-1]))%mod\nprint(ans)\n\n  \n  \n"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\ndef exponen(input1,input2):\n    binarylist=list(str(bin(input2))[2:])[::-1]\n    binarysize=len(binarylist)\n    modlist=[0 for i in range(binarysize)]\n    modlist[0]=input1\n    for i in range(1,binarysize):\n        modlist[i]=times(modlist[i-1],modlist[i-1])\n    answer=1\n    for i in range(binarysize):\n        if binarylist[i]==1:\n            answer=times(answer,modlist[i])\n    return answer\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nFinv=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(Fact[i-1],i)\n    Finv[i]=divide(1,Fact[i])\nans=0\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    SGL[K]=times(times(Fact[K],Finv[2*K-N]),Fact[K-1])\nfor K in range(1,N):\n    ans=plus(ans,times(SGL[K]-SGL[K-1],K))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "law = 10**9+7\nN = long(raw_input())\nans = 0L\nif N == 2:\n  ans = 1\nelif N ==3:\n  ans = 4\nelse:\n  factorio = [1L]\n  t = 1L\n  for i in range(N+1)[1:]:\n    t *= i\n    t %= law\n    factorio.append(t)\n  num = 0\n  past_ruiseki = 0\n  for K in range(N/2, N):\n    ruiseki = (((factorio[K]*factorio[K-1])%law)/factorio[2*K-N])%law\n    num = (ruiseki-past_ruiseki)%law\n    ans += (K*num)%law\n    past_ruiseki = ruiseki\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "Md,MN=1000000007,1000006\nfac,ifac,a,res,inv=[1,1],[1,1],[0],0,[1,1]\nfor i in range(2,MN):\n    inv.append(inv[Md%i]*(Md-Md/i)%Md)\n    fac.append(fac[-1]*i%Md)\n    ifac.append(ifac[-1]*inv[i]%Md)\ndef C(x,y):\n    if(x<y):\n        return 0\n    return fac[x]*ifac[y]*ifac[x-y]\ndef D(x,y):\n    return C(x-y+1,y)\n\nn=int(input())\nfor i in range(1,n):\n    if i*2-n>=0:\n        a.append(D(n-3,n-i-1)*fac[i]*fac[n-i-1]%Md)\n    else:\n        a.append(0)\nfor i in range(n-1,0,-1):\n    a[i]=(a[i]-a[i-1])%Md\n    res=res+a[i]*i\nres=res%Md\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n, p):\n    n_ = [1]\n    for i in range(1, n+1):\n         n_.append((n_[-1]*i) % p)\n    return n\n\ndef invfact(n, f, p):\n    m = [pow(f[n], p-2, p)]\n    for i in range(n, 0, -1):\n        m.append(m[-1] * i % p)\n    return m\n\nans = 0\nm = n - 1\nf = fact(m, p)\nrf = invfact(m, f, p)\nrf.reverse()\nperm = 0\n\nfor k in range((n+1)//2, n):\n    perm_ = f[k-1] * rf[2*k-n] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nMOD = 10**9+7\ndef frac(limit):\n    frac = [1]*limit\n    for i in range(2,limit):\n        frac[i] = i * frac[i-1]%MOD\n    fraci = [None]*limit\n    fraci[-1] = pow(frac[-1], MOD -2, MOD)\n    for i in range(-2, -limit-1, -1):\n        fraci[i] = fraci[i+1] * (limit + i + 1) % MOD\n    return frac, fraci\nfrac, fraci = frac(1341398)\ndef comb(a, b):\n    if not a >= b >= 0:\n        return 0\n    return frac[a]*fraci[b]*fraci[a-b]%MOD\n\nN = int(readline())\n\nf = [0]*N\n\nfor k in range(1, N):\n    if 2*k < N:\n        continue\n    f[k] = comb(k-1, 2*k-N)\n\ng = [f[i]*frac[i]*frac[N-1-i]%MOD for i in range(N)]\n\nans = 0\n\nfor k in range(1, N):\n    ans = (ans + k*(g[k] - g[k-1]))%MOD\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import exit, setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import bisect\n\ndef read():\n  return int(input())\n\ndef reads():\n  return [int(x) for x in input().split()]\n\nMOD = 10**9 + 7\n\nN = read()\n\nNN = N + 1\nfact = [1] * NN\nfor i in range(1, NN):\n  fact[i] = (fact[i-1] * i) % MOD\n\ndef inv(n):\n  return pow(n, MOD-2, MOD)\n\ninvfact = [inv(fact[i]) for i in range(NN)]\n\ndef comb(n, k):\n  return fact[n] * invfact[n-k] % MOD * invfact[k] % MOD\n\nS = [0] * N\nfor k in range((N+1) // 2, N):\n  S[k] = comb(k-1, N-1-k) * fact[k] % MOD * fact[N-1-k] % MOD\n\nans = 0\nfor k in range((N+1) // 2, N):\n  ans = (ans + k * (S[k] - S[k-1]) % MOD) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport sys,collections,itertools,re,math,fractions,decimal,random,array,bisect,heapq\n\n# decimal.getcontext().prec = 50\n# sys.setrecursionlimit(10000)\nMOD = 10**9 + 7\n\ndef solve(f):\n    n = f.read_int()\n\n    fact = [1] * (n+1)\n    ifact = [1] * (n+1)\n    for i in range(1, n+1):\n        fact[i] = (fact[i-1] * i) % MOD\n        ifact[i] = pow(fact[i], MOD-2, MOD)\n\n    def nCk(n, k):\n        if k < 0 or k > n: return 0\n        return (fact[n] * ifact[n-k] * ifact[k]) % MOD\n\n    ans = 0\n    c0 = 0\n    for i in xrange(n/2,n):\n        c1 = (nCk(i-1, n-1-i)*fact[i]*fact[n-i-1] - c0 + MOD) % MOD\n        ans = (ans + c1*i) % MOD\n        c0 = (c0 + c1) % MOD\n\n    return ans\n\n\nclass Reader(object):\n    def __init__(self, filename=None):\n        self.file = open(filename) if filename is not None else None\n        self.case = 1\n\n    def __readline(self):\n        return self.file.next().strip() if self.file else raw_input()\n\n    def next_case(self):\n        self.file.next()\n        self.case += 1\n\n    def read_int(self): return int(self.__readline())\n    def read_float(self): return float(self.__readline())\n    def read_long(self): return long(self.__readline())\n    def read_decimal(self): return decimal.Decimal(self.__readline())\n    def read_str(self): return self.__readline()\n\n    def read_int_list(self): return map(int, self.__readline().split())\n    def read_float_list(self): return map(float, self.__readline().split())\n    def read_long_list(self): return map(long, self.__readline().split())\n    def read_decimal_list(self): return map(decimal.Decimal, self.__readline().split())\n    def read_str_list(self): return self.__readline().split()\n\nif __name__ == '__main__':\n    filename = sys.argv[1] if len(sys.argv) > 1 else None\n    f = Reader(filename)\n    if f.file:\n        while True:\n            print \"Case #%d\\n\"%f.case, solve(f)\n            try:\n                f.next_case()\n            except StopIteration:\n                break\n    else:\n        print solve(f)\n"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nMOD = 10**9 + 7\n\nfact = [1]*(N+1)\nrfact = [1]*(N+1)\n\nfor i in range(1, N+1):\n    fact[i] = r = i*fact[i-1] % MOD\n    rfact[i] = pow(r, MOD-2, MOD)\n\nans = cnt = 0\nfor K in range((N+1)//2, N):\n    res = fact[K]*fact[K-1]*rfact[2*K-N] % MOD\n    ans += (res - cnt) * K % MOD\n    cnt = res\n    ans %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nimport collections\nn = int(input())\nmachine = []\n[machine.append(i) for i in range(n-1)]\nresult = []\nfor i in permutations(machine):\n    l = []\n    [l.append(i) for i in range(n)]\n    score = 0\n    for j in i:\n        l[j] = -1\n        l[j + 1] = -1\n        score += 1\n        if(all(x == -1 for x in l)):\n            result.append(score)\n            break\nprint(result)\ntemp = collections.Counter(result)\nans = 0\nfor k,v in temp.items():\n    ans += k*v\nprint(ans%(10**9+7))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\ndef invfact(n, f, p):\n    m = pow(f[n], p-2, p)\n    yield m\n    for i in range(n, 0, -1):\n        m = m * i % p\n        yield m\n\nans = 0\nm = n - 1\nf = list(fact(m))\nrf = list(invfact(m, f, p))\nrf.reverse()\nperm = 0\n\nfor k in range((n+1)//2, n):\n    perm_ = f[k-1] * rf[2*k-n] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nmod=10**9+7\nfra=[1]*(n+2)\ninv=[1]*(n+2)\nt1=1\nt2=1\nfor i in range(1,n+2):\n    t1*=i\n    t1%=mod\n    t2*=pow(i,mod-2,mod)\n    t2%=mod\n    fra[i]=t1\n    inv[i]=t2\ndef comb(n,r):\n    return fra[n]*inv[n-r]*inv[r]%mod\nans=0\nt=0\nfor i in range((n+1)//2,n):\n    a=comb(i-1,n-1-i)*fra[i]%mod\n    ans+=(a-t)*fra[n-1-i]*i\n    ans%=mod\n    t+=a\n    t%=mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nN=int(input())\nif N==2:\n    print(1)\n    sys.exit()\nif N==3:\n    print(4)\n    sys.exit()\nmod=10**9+7\ntable=[1]*(N+3)\nt=1\nfor i in range(1,N+3):\n    t*=i\n    t%=mod\n    table[i]=t\nrtable=[1]*(N+3)\nt=1\nfor i in range(1,N+3):\n    t*=pow(i,mod-2,mod)\n    t%=mod\n    rtable[i]=t\n#print(table,rtable)\nans=0\nl=0\nfor k in range(N):\n    if 0>2*k-N:\n        continue\n    num=table[k]*table[N-1-k]\n    div=table[k-1]*rtable[N-1-k]*rtable[k-1-(N-1-k)]\n    div%=mod\n    num*=div\n    num%=mod\n    ans+=k*(num-l)\n    l=num\n    l%=mod\n    ans%=mod\n    #print(k, num, div)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nMOD = 10**9+7\nfac = [1,1] + [0]*N\nfinv = [1,1] + [0]*N\ninv = [0,1] + [0]*N\nfor i in range(2,N+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef ncr(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = 0\nprev = 0\nfor k in range((N+1)//2, N):\n    tmp = ncr(k-1, N-1-k) * fac[k] * fac[N-1-k]\n    tmp %= MOD\n    ans += (tmp - prev) * k\n    ans %= MOD\n    prev = tmp\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport sys,collections,itertools,re,math,fractions,decimal,random,array,bisect,heapq\n\n# decimal.getcontext().prec = 50\n# sys.setrecursionlimit(10000)\nMOD = 10**9 + 7\n\ndef solve(f):\n    n = f.read_int()\n\n    fact = [1] * (n+1)\n    ifact = [1] * (n+1)\n    for i in range(1, n+1):\n        fact[i] = (fact[i-1] * i) % MOD\n        ifact[i] = pow(fact[i], MOD-2, MOD)\n\n    def nCk(n, k):\n        if k < 0 or k > n: return 0\n        return (fact[n] * ifact[n-k] * ifact[k]) % MOD\n\n    ans = 0\n    c0 = 0\n    for i in xrange(n/2,n):\n        c1 = (nCk(i-1, n-1-i)*fact[i]*fact[n-i-1] - c0 + MOD) % MOD\n        ans = (ans + c1*i) % MOD\n        c0 = (c0 + c1) % MOD\n\n    return ans\n\n\nclass Reader(object):\n    def __init__(self, filename=None):\n        self.file = open(filename) if filename is not None else None\n        self.case = 1\n\n    def __readline(self):\n        return self.file.next().strip() if self.file else raw_input()\n\n    def next_case(self):\n        self.file.next()\n        self.case += 1\n\n    def read_int(self): return int(self.__readline())\n    def read_float(self): return float(self.__readline())\n    def read_long(self): return long(self.__readline())\n    def read_decimal(self): return decimal.Decimal(self.__readline())\n    def read_str(self): return self.__readline()\n\n    def read_int_list(self): return map(int, self.__readline().split())\n    def read_float_list(self): return map(float, self.__readline().split())\n    def read_long_list(self): return map(long, self.__readline().split())\n    def read_decimal_list(self): return map(decimal.Decimal, self.__readline().split())\n    def read_str_list(self): return self.__readline().split()\n\nif __name__ == '__main__':\n    filename = sys.argv[1] if len(sys.argv) > 1 else None\n    f = Reader(filename)\n    if f.file:\n        while True:\n            print \"Case #%d\\n\"%f.case, solve(f)\n            try:\n                f.next_case()\n            except StopIteration:\n                break\n    else:\n        print solve(f)\n"
  },
  {
    "language": "Python",
    "code": "P=10**9+7\ndef egcd(a, b):\n    (x, lastx) = (0, 1)\n    (y, lasty) = (1, 0)\n    while b != 0:\n        q = a // b\n        (a, b) = (b, a % b)\n        (x, lastx) = (lastx - q * x, x)\n        (y, lasty) = (lasty - q * y, y)\n    return (lastx, lasty, a)\ndef inv(x):\n    return egcd(x,P)[0]\nN=int(input())\nFact=[0 for i in range(N+1)]\nFinv=[0 for i in range(N+1)]\nFact[0]=1\nFinv[0]=1\nfor i in range(N):\n    Fact[i+1]=((i+1)*Fact[i])%P\n    Finv[i+1]=(Finv[i]*inv(i+1))%P\nSGN=[0 for i in range(N)]\nans=0\nfor k in range(N):\n    if 2*k-N>=0:\n        SGN[k]=(((Fact[k-1]*Fact[k])%P)*Finv[2*k-N])%P\n        ans=(ans+k*(SGN[k]-SGN[k-1]))%P\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "Md,MN=1000000007,1000006\nfac,ifac,a,res,inv=[1,1],[1,1],[0],0,[1,1]\nfor i in range(2,MN):\n    inv.append(inv[Md%i]*(Md-Md//i)%Md)\n    fac.append(fac[-1]*i%Md)\n    ifac.append(ifac[-1]*inv[i]%Md)\nn=int(input())\nfor i in range(1,n):\n    if i*2-n>=0:\n        a.append(fac[i-1]*ifac[i+i-n]*fac[i]%Md)\n    else:\n        a.append(0)\nfor i in range(n-1,0,-1):\n    a[i]=(a[i]-a[i-1])%Md\n    res+=a[i]*i\nres=res%Md\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #空白あり\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #空白なし\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())  #空白あり\ndef LS2(): return list(sys.stdin.readline().rstrip())  #空白なし\n\n\nN = I()\nmod = 10**9+7\n\nif N == 2:\n    print(1)\n    exit()\nelif N == 3:\n    print(4)\n    exit()\n\nkaijou = [1]\nfor i in range(1,N+1):\n    kaijou.append((kaijou[-1]*i) % mod)\n\nkaijou_inverse = [1]*(N+1)\nfor i in range(1,N+1):\n    kaijou_inverse[i] = pow(kaijou[i],mod-2,mod)\n\ndef nCr(n,r):\n    if n < r:\n        return 0\n    return (kaijou_inverse[n]*kaijou_inverse[r]*kaijou_inverse[n-r]) % mod\n\nans = 0\nfor i in range(1,N):\n    ans += i*kaijou[i]*kaijou[N-i-i]*nCr(i-1,N-1-i)\n    ans %= mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nimport collections\nimport numba\n\nn = int(input())\nmachine = []\nfor i in range(n-1):\n    machine.append(i)\nresult = []\nl = []\nfor i in permutations(machine):\n    for _ in range(n):\n        l.append(1)\n    score = 0\n    for j in i:\n        l[j] = -1\n        l[j + 1] = -1\n        score += 1\n        if(all(x == -1 for x in l)):\n            result.append(score)\n            l.clear()\n            break\ntemp = collections.Counter(result)\nans = 0\nfor k,v in temp.items():\n    ans += k*v\nprint(ans%(10**9+7))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    for i in range(n-1, 0, -1):\n         n_ = (n_*i) % p\n    return n * n_ % p, n_\n\ndef nfact(n):\n    for i in range(n-1, 0, -1):\n         n = (n*i) % p\n    return n\n\ndef comb(n, r):\n    return fact(n)//(fact(r) * fact(n-r))\n\nans = 0\nm = n - 1\nif n == 2:\n    ans = 1\n\nelif m % 2 == 0:\n    fm, fm_ = fact(m)\n    #mc = fact(m-1)\n    #ans += mc * 2 *m\n    ans += fm * 2 % p\n    fm -= fm_ * 2\n    ans += fm * (m-1) % p\n    \nelse:\n    fm, fm_ = fact(m)\n    #mc = fact(m-1)\n    #ans += mc * 2 *m\n    hn = n // 2\n    fhn, fhn_ = fact(hn)\n    ans += fhn * fhn_ % p * (hn) % p\n    ans += fm_ * 2 % p * m % p\n    fm -= fhn * fhn_\n    fm -= fm_ * 2\n    ans += fm * (m-1)\n    # ans += fhn * hn % p\n    # ans += fhn * (((hn+1) // 2 + hn) * hn % p) % p\n    # fm -= fhn * 2\n    # ans += fm * m % p\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nMOD = 10**9 + 7\n\nfact = [1]*(N+1)\n\nfor i in range(1, N+1):\n    fact[i] = r = i*fact[i-1] % MOD\n\ncnts = [0]*(N+1)\nrev = 1\nfor K in range(N-1, (N+1)//2-1, -1):\n    cnts[K] = fact[K]*fact[K-1]*rev % MOD\n    rev = rev * (2*K-N) * (2*K-N-1) % MOD\n\nans = 0\nfor K in range((N+1)//2, N):\n    ans += (cnts[K] - cnts[K-1]) * K % MOD\n    ans %= MOD\nans = (ans * pow(fact[N-2], MOD-2, MOD)) % MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nimport collections\nn = int(input())\nmachine = []\n[machine.append(i) for i in range(n-1)]\nresult = []\nfor i in permutations(machine):\n    l = []\n    [l.append(i) for i in range(n)]\n    score = 0\n    for j in i:\n        l[j] = -1\n        l[j + 1] = -1\n        score += 1\n        if(all(x == -1 for x in l)):\n            result.append(score)\n            break\ntemp = collections.Counter(result)\nans = 0\nfor k,v in temp.items():\n    ans += k*v\nprint(ans%(10**9+7))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #空白あり\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #空白なし\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())  #空白あり\ndef LS2(): return list(sys.stdin.readline().rstrip())  #空白なし\n\n\nN = I()\nmod = 10**9+7\n\nif N == 2:\n    print(1)\n    exit()\nelif N == 3:\n    print(4)\n    exit()\n\nkaijou = [1]\nfor i in range(1,N+1):\n    kaijou.append((kaijou[-1]*i) % mod)\n\nkaijou_inverse = [1]\nfor i in range(1,N+1):\n    kaijou_inverse[i] = pow(kaijou[i],mod-2,mod)\n\ndef nCr(n,r):\n    if n < r:\n        return 0\n    return (kaijou_inverse[n]*kaijou_inverse[r]*kaijou_inverse[n-r]) % mod\n\nans = 0\nfor i in range(1,N):\n    ans += i*kaijou[i]*kaijou[N-i-i]*nCr(i-1,N-1-i)\n    ans %= mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def inv(x, mod = 10 ** 9 + 7):\n    return pow(x, mod - 2, mod)\n\nmod = 10 ** 9 + 7\nN = int(input())\nfact = [1]\nfor i in range(1, N):\n    fact.append(fact[-1] * i % mod)\ninv_fact = [inv(fact[-1])]\nfor i in reversed(range(1, N)):\n    inv_fact.append(inv_fact[-1] * i % mod)\ninv_fact = inv_fact[::-1]\n\nans = prev = 0\nfor k in range((N + 1) // 2, N):\n    cnt = fact[k - 1] * inv_fact[k * 2 - N] % mod * fact[k] % mod\n    ans += (cnt - prev + mod) * k\n    ans %= mod\n    prev = cnt\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nMOD = 10**9 + 7\n\nfact = [1]*(N+1)\nrfact = [1]*(N+1)\n\nfor i in range(1, N+1):\n    fact[i] = r = i*fact[i-1] % MOD\n    rfact[i] = pow(r, MOD-2, MOD)\n\nans = 0\ncnt = 0\nfor K in range(1, N):\n    if not K >= N-K >= 1:\n        continue\n    res = fact[K]*fact[K-1]*rfact[2*K-N] % MOD\n    ans += (res - cnt) * K % MOD\n    cnt = res\nprint(ans % MOD)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\n# def fact(n, p):\n#     n_ = 1\n#     yield n_\n#     for i in range(1, n+1):\n#          n_ = (n_*i) % p\n#          yield n_\n\n# def invfact(n, f, p):\n#     m = pow(f[n], p-2, p)\n#     yield m\n#     for i in range(n, 0, -1):\n#         m = m * i % p\n#         yield m\n\ndef fact(n, p):\n    n_ = [1]\n    for i in range(1, n+1):\n         n_.append((n_[-1]*i) % p)\n    return n\n\ndef invfact(n, f, p):\n    m = [pow(f[n], p-2, p)]\n    for i in range(n, 0, -1):\n        m.append(m[-1] * i % p)\n    return m\n\nans = 0\nm = n - 1\nf = fact(m, p)\nrf = invfact(m, f, p)\nrf.reverse()\nperm = 0\n\nfor k in range((n+1)//2, n):\n    perm_ = f[k-1] * rf[2*k-n] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\ndef exponen(input1,input2):\n    return pow(input1,input2,characteristic)\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nFinv=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(Fact[i-1],i)\n    Finv[i]=divide(1,Fact[i])\nans=0\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    SGL[K]=times(times(Fact[K],Finv[2*K-N]),Fact[K-1])\nfor K in range(1,N):\n    ans=plus(ans,times(SGL[K]-SGL[K-1],K))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\ndef exponen(input1,input2):\n    return pow(input1,input2,characteristic)\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nFinv=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(Fact[i-1],i)\n    Finv[i]=divide(1,Fact[i])\nans=0\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    SGL[K]=times(times(Fact[K],Finv[2*K-N]),Fact[K-1])\nfor K in range(1,N):\n    ans=plus(ans,times(SGL[K]-SGL[K-1],K))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "MOD = (10 ** 9) + 7\n\nlist_size = 1000000\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\ndef power(n, x):\n\tif x == 1:\n\t\treturn n\n\telif x % 2 == 0:\n\t\treturn power(int((n * n) % MOD), int(x / 2))\n\telse:\n\t\treturn int((n * power(n, x - 1)) % MOD)\n\nf_r_list[-1] = power(f_list[-1], MOD - 2)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\ndef factorial(i):\n\tif i == 0:\n\t\treturn 1\n\telse:\n\t\treturn f_list[i-1]\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nn = int(input())\nans = ((n - 1) * factorial(n - 1)) % MOD\nfor i in range(n - 2, (n + 1) // 2 - 1, -1):\n\tans -= comb(i - 1, n - i - 1) * factorial(n - i - 1) * factorial(i)\n\tans %= MOD\n\t#print(ans, cnt)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nMOD = 10**9 + 7\n\nfact = [1]*(N+1)\nrfact = [1]*(N+1)\n\nfor i in range(1, N+1):\n    fact[i] = r = i*fact[i-1] % MOD\n    rfact[i] = pow(r, MOD-2, MOD)\n\nans = 0\ncnt = 0\nfor K in range(1, N):\n    if not K >= N-K >= 1:\n        continue\n    res = fact[K]*fact[K-1]*rfact[2*K-N] % MOD\n    ans += (res - cnt) * K % MOD\n    cnt = res\n    ans %= MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "Md,MN=1000000007,1000006\nfac,ifac,a,res,inv=[1,1],[1,1],[0],0,[1,1]\nfor i in range(2,MN):\n    inv.append(inv[Md%i]*(Md-Md/i)%Md)\n    fac.append(fac[-1]*i%Md)\n    ifac.append(ifac[-1]*inv[i]%Md)\ndef C(x,y):\n    if(x<y):\n        return 0\n    return fac[x]*ifac[y]*ifac[x-y]\ndef D(x,y):\n    return C(x-y+1,y)\n\nn=int(input())\nfor i in range(1,n):\n    if i*2-n>=0:\n        a.append(D(n-3,n-i-1)*fac[i]*fac[n-i-1]%Md)\n    else:\n        a.append(0)\nfor i in range(n-1,0,-1):\n    a[i]=(a[i]-a[i-1])%Md\n    res=res+a[i]*i\nres=res%Md\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "def prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    inverses = [1] * (n + 1)\n    inverses[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        inverses[m - 1] = inv\n    return factorials, inverses\n\n\ndef solve(n):\n    MOD = 1000000007\n    fac, inv = prepare(n, MOD)\n    ans = 0\n    cnt = 0\n    for k in range((n + 1) // 2, n):\n        tmp = fac[k - 1] * inv[n - 1 - k] * inv[2 * k - n]\n        tmp %= MOD\n        tmp *= fac[k]\n        tmp %= MOD\n        tmp *= fac[n - 1 - k]\n        tmp %= MOD\n        just = (tmp - cnt) % MOD\n        ans += just * k\n        ans %= MOD\n        cnt = tmp\n    return ans\n\n\nn = int(input())\nprint(solve(n))\n"
  },
  {
    "language": "Python",
    "code": "Md,MN=1000000007,1000006\nfac,ifac,a,res,inv=[1,1],[1,1],[0],0,[1,1]\nfor i in range(2,MN):\n    inv.append(inv[Md%i]*(Md-Md//i)%Md)\n    fac.append(fac[-1]*i%Md)\n    ifac.append(ifac[-1]*inv[i]%Md)\ndef C(x,y):\n    if(x<y):\n        return 0\n    return fac[x]*ifac[y]*ifac[x-y]\ndef D(x,y):\n    return C(x-y+1,y)\n\nn=int(input())\nfor i in range(1,n):\n    if i*2-n>=0:\n        a.append(D(n-3,n-i-1)*fac[i]*fac[n-i-1]%Md)\n    else:\n        a.append(0)\nfor i in range(n-1,0,-1):\n    a[i]=(a[i]-a[i-1])%Md\n    res=res+a[i]*i\nres=res%Md\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\n\nmod=10**9+7\n\nFACT=[1]\nfor i in range(1,10**6+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(10**6,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nANS=0\nMINUS=0\n\ndef k_perm(k):\n    return Combi(k-1,N-k-1)*FACT[k]*FACT[N-k-1]%mod\n\nfor k in range(N):\n    ANS=(ANS+(k_perm(k)-k_perm(k-1))*k)%mod\n\nprint(ANS)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn = int(input())\n\nM = 10**9+7 # 出力の制限\nN = n+3 # 必要なテーブルサイズ\n\ng1 = [None] * (N+1) # 元テーブル\ng2 = [None] * (N+1) #逆元テーブル\ninverse = [None] * (N+1) #逆元テーブル計算用テーブル\ng1[0] = g1[1] = g2[0] = g2[1] = 1\ninverse[0], inverse[1] = [0, 1] \n\nfor i in range( 2, N + 1 ):\n    g1[i] = ( g1[i-1] * i ) % M \n    inverse[i] = ( -inverse[M % i] * (M//i) ) % M # ai+b==0 mod M <=> i==-b*a^(-1) <=> i^(-1)==-b^(-1)*aより\n    g2[i] = (g2[i-1] * inverse[i]) % M \n\ndef cmb(n, r, M):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return (g1[n] * g2[r] * g2[n-r]) % M\nans = 0\nprev = 0\n# s = 0\nfor i in range((n+1)//2, n):\n    tmp = (cmb(i-1, n-i-1, M) * g1[i] * g1[n-1-i])\n    ans += i*(tmp-prev)\n    prev = tmp\n#     print(i, tmp, g1[i], g1[n-1-i])\n    ans %= M\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ndef I(): return int(sys.stdin.readline().rstrip())\n\n\nN = I()\nmod = 10**9+7\n\n\nfac = [1]*(N+1)\nfor i in range(1,N+1):\n    fac[i] = (fac[i-1]*i) % mod\n\nfac_inverse = [1]*(N+1)\nfor i in range(1,N+1):\n    fac_inverse[i] = pow(fac[i],mod-2,mod)\n\n\ndef nCr(n,r):\n    if n < r:\n        return 0\n    return (fac[n]*fac_inverse[r]*fac_inverse[n-r]) % mod\n\n\nA = [0]*(N+1)  # Ai = i回以下マシンを稼働することで、全て黒く塗られるような順列の個数\nfor i in range(N+1):\n    A[i] = (fac[i]*fac[N-1-i]*nCr(i-1,N-1-i)) % mod\n\nans = 0\nfor i in range(1,N):\n    ans += i*(A[i]-A[i-1])\n    ans %= mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN = int(input())\n\ndef cumprod(arr):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\nU = 10**6+100\nx = np.arange(U,dtype=np.int64)\nx[0] = 1\nfact = cumprod(x)\nx = np.arange(U,0,-1,dtype=np.int64)\nx[0] = pow(int(fact[-1]),MOD-2,MOD)\nfact_inv = cumprod(x)[::-1]\n\n# 1,N-1の間のn台で完成させる方法\nn = np.arange((N-3)//2,N-2)\n\n# +1,+2をn+1個でN-2を作る方法\n# +0,+1をn+1個でN-3-nを作る方法\n# comb[n+1][N-3-n] * (n+2)! * (N-n-3)!\nx = fact[n+1] * fact[n+2] % MOD * fact_inv[4-N+2*n] % MOD\nanswer = (x[-1] * (N-1) - x[:-1].sum()) % MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nmod=10**9+7\nfra=[1]*(n+2)\ninv=[1]*(n+2)\nt=1\nfor i in range(1,n+2):\n    t*=i\n    t%=mod\n    fra[i]=t\nt=pow(fra[n+1],mod-2,mod)\nfor i in range(n+1,0,-1):\n    inv[i]=t\n    t*=i\n    t%=mod\nans=fra[n]\nfor i in range((n+1)//2,n):\n    ans-=fra[i-1]*inv[2*i-n]*fra[i]%mod\n    ans%=mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "Md,MN=1000000007,1000006\nfac,ifac,a,res=[1],[1],[0],0\nfor i in range(1,MN):\n    fac.append(fac[-1]*i%Md)\n    ifac.append(pow(fac[-1],Md-2,Md))\ndef C(x,y):\n    if(x<y):\n        return 0\n    return fac[x]*ifac[y]*ifac[x-y]\ndef D(x,y):\n    return C(x-y+1,y)\n\nn=int(input())\nfor i in range(1,n):\n    if i*2-n>=0:\n        a.append(D(n-3,n-i-1)*fac[i]*fac[n-i-1]%Md)\n    else:\n        a.append(0)\nfor i in range(n-1,0,-1):\n    a[i]=(a[i]-a[i-1])%Md\n    res=res+a[i]*i\nres=res%Md\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfn,fk,mod = [1]*n,[1]*n,10**9+7\nfor i in range(n-1): fn[i+1] = (fn[i]*(i+2))%mod\ndef power(n,k):\n\tif k==1: return n\n\telif k%2==0: return power((n**2)%mod,k//2)\n\telse: return (n*power(n,k-1))%mod\ndef comb(n,k):\n\tif n<k or k<0: return 0\n\telif k==0 or n==k: return 1\n\telse: return (((fn[n-1]*fk[n-k-1])%mod)*fk[k-1])%mod\nfk[-1] = power(fn[-1],mod-2)\nfor i in range(2,n+1): fk[-i] = (fk[-i+1]*(n+2-i))%mod\nfn.append(1)\nans = f[n-2]\nfor i in range(2,n):\n\tans = (ans-comb(i-1,n-i-1)*fn[i-1]*fn[n-i-2])%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "Md,MN=1000000007,1000006\nfac,ifac,a,res,inv=[1,1],[1,1],[0],0,[1,1]\nfor i in range(2,MN):\n    inv.append(inv[Md%i]*(Md-Md/i)%Md)\n    fac.append(fac[-1]*i%Md)\n    ifac.append(ifac[-1]*inv[i]%Md)\ndef C(x,y):\n    if(x<y):\n        return 0\n    return fac[x]*ifac[y]*ifac[x-y]\ndef D(x,y):\n    return C(x-y+1,y)\n\nn=int(input())\nfor i in range(1,n):\n    if i*2-n>=0:\n        a.append(D(n-3,n-i-1)*fac[i]*fac[n-i-1]%Md)\n    else:\n        a.append(0)\nfor i in range(n-1,0,-1):\n    a[i]=(a[i]-a[i-1])%Md\n    res=res+a[i]*i\nres=res%Md\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "N = long(raw_input())\nMOD = 10**9 + 7\n\nfact = [1]*(N+1)\n\nfor i in range(1, N+1):\n    fact[i] = r = i*fact[i-1] % MOD\n\ncnts = [0]*(N+1)\nrev = 1\nfor K in range(N-1, (N+1)/2-1, -1):\n    cnts[K] = fact[K]*fact[K-1]*rev % MOD\n    rev = rev * (2*K-N) * (2*K-N-1) % MOD\n\nans = 0\nfor K in range((N+1)/2, N):\n    ans += (cnts[K] - cnts[K-1]) * K % MOD\n    ans %= MOD\nans = (ans * pow(fact[N-2], MOD-2, MOD)) % MOD\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "from sys import exit, setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import bisect\n\ndef read():\n  return int(input())\n\ndef reads():\n  return [int(x) for x in input().split()]\n\nMOD = 10**9 + 7\n\nN = read()\n\nNN = N + 1\nfact = [1] * NN\nfor i in range(1, NN):\n  fact[i] = (fact[i-1] * i) % MOD\n\ndef inv(n):\n  return pow(n, MOD-2, MOD)\n\ndef comb(n, k):\n  return fact[n] * inv(fact[n-k]) % MOD * inv(fact[k]) % MOD\n\nS = [0] * N\nfor k in range((N+1) // 2, N):\n  c = comb(k-1, N-1-k)\n  S[k] = c * fact[k] % MOD\n\n# print(S, file=stderr)\n\nans = 0\nfor k in range((N+1) // 2, N):\n  ans = (ans + k * (S[k] - S[k-1] * (N - k)) % MOD) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "law = 10**9+7\nN = long(raw_input())\nans = 0L\nif N == 2:\n  ans = 1\nelif N ==3:\n  ans = 4\nelse:\n  factorio = [1L]\n  t = 1L\n  for i in range(N+1)[1:]:\n    t *= i\n    t %= law\n    factorio.append(t)\n  num = 0\n  past_ruiseki = 0\n  for K in range(N/2, N):\n    ruiseki = (((factorio[K]*factorio[K-1])%law)/factorio[2*K-N])%law\n    num = (ruiseki-past_ruiseki)%law\n    ans += K*num\n    past_ruiseki = ruiseki\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "N = int(input()) - 1\n\nLARGE = 10**9+7\n\ndef ex_euclid(x, y):\n    c0, c1 = x, y\n    a0, a1 = 1, 0\n    b0, b1 = 0, 1\n \n    while c1 != 0:\n        m = c0 % c1\n        q = c0 // c1\n \n        c0, c1 = c1, m\n        a0, a1 = a1, (a0 - q * a1)\n        b0, b1 = b1, (b0 - q * b1)\n \n    return c0, a0, b0\n# precompute\nfac_list = [1]*(N+1)\nfac = 1\nfor i in range(1, N+1):\n    fac = (fac * i) % LARGE\n    fac_list[i] = fac\n    \nfac_inv_list = [1]*(N+1)\nfor i in range(N+1):\n    c,a,b = ex_euclid(fac_list[i], LARGE)\n    fac_inv_list[i] = a % LARGE\n    \ndef nCr(n, r):\n    return (((fac_list[n] * fac_inv_list[r]) % LARGE) * fac_inv_list[n-r]) % LARGE\n\ndef pat(n, r):\n    return (((fac_list[n] * fac_inv_list[r]) % LARGE) * fac_inv_list[n-r]) % LARGE\n\n\npat = 0\nscore = 0\n\nfor k in range(N+1):\n    if k-1 >= N-k:\n        res = (((nCr(k-1, N-k)*fac_list[k]) % LARGE) * fac_list[N-k]) % LARGE\n        score = (score + (res - pat) * k) % LARGE\n        # print(k, pat, res)\n        pat = res\nprint(score)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nmod=10**9+7\nfra=[1]*(n+2)\ninv=[1]*(n+2)\nt1=1\nt2=1\nfor i in range(1,n+2):\n    t1*=i\n    t1%=mod\n    t2*=pow(i,mod-2,mod)\n    t2%=mod\n    fra[i]=t1\n    inv[i]=t2\nans=fra[n]\nfor i in range((n+1)//2,n):\n    ans-=fra[i-1]*inv[2*i-n]*fra[i]%mod\n    ans%=mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import itertools\nn = int(input())\nnn = [i for i in range(0, n - 1)]\nans = 0\nfor element in itertools.permutations(nn, n - 1):\n    field = 0\n    tm = 0\n    for elm in element:\n        blk = (1 << elm) + (1 << (elm + 1))\n        field = field | blk\n        tm += 1\n        if field == (1 << n) - 1:\n            break\n    ans += tm\n    ans = ans % (10^9 + 7)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import itertools\nP=10**9+7\nN=int(input())\nS=list(itertools.permutations(range(N-1),N-1))\nscoresum=0\nfor sg in S:\n    score=0\n    L=[0 for i in range(N)]\n    W=N\n    for i in range(N-1):\n        if L[sg[i]]==0:\n            W-=1\n        L[sg[i]]=1\n        if L[sg[i]+1]==0:\n            W-=1\n        L[sg[i]+1]=1\n        if W==0:\n            score=i+1\n            break\n    scoresum+=score\nprint(scoresum)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nimport collections\nn = int(input())\nmachine = []\n[machine.append(i) for i in range(n-1)]\nresult = []\nfor i in permutations(machine):\n    l = []\n    [l.append(i) for i in range(n)]\n    score = 0\n    for j in i:\n        l[j] = -1\n        l[j + 1] = -1\n        score += 1\n        if(all(x == -1 for x in l)):\n            result.append(score)\n            break\ntemp = collections.Counter(result)\nans = 0\nfor k,v in temp.items():\n    ans += k*v\nprint(ans%(10**9+7))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n, p):\n    n_ = [1]\n    for i in range(1, n+1):\n         n_.append((n_[-1]*i) % p)\n    return n\n\ndef invfact(n, f, p):\n    m = [pow(f[n], p-2, p)]\n    for i in range(n, 0, -1):\n        m.append(m[-1] * i % p)\n    return m\n\nans = 0\nm = n - 1\nf = list(fact(m, p))\nrf = list(invfact(m, f, p))\nrf.reverse()\nperm = 0\n\nfor k in range((n+1)//2, n):\n    perm_ = f[k-1] * rf[2*k-n] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from sys import exit, setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import bisect\n \ndef read():\n  return int(input())\n \ndef reads():\n  return [int(x) for x in input().split()]\n \nMOD = 10**9 + 7\n \nN = read()\n \nNN = N + 1\nfact = [1] * NN\nfor i in range(1, NN):\n  fact[i] = (fact[i-1] * i) % MOD\n \ndef inv(n):\n  return pow(n, MOD-2, MOD)\n \ninvfact = [0] * NN\ninvfact[-1] = inv(fact[-1])\nfor i in range(NN-2, -1, -1):\n  invfact[i] = invfact[i+1] * (i+1) % MOD\n \ndef comb(n, k):\n  return fact[n] * invfact[n-k] % MOD * invfact[k] % MOD\n \nS = [0] * N\nfor k in range((N+1) // 2, N):\n  S[k] = comb(k-1, N-1-k) * fact[k] % MOD * fact[N-1-k] % MOD\n \nans = 0\nfor k in range((N+1) // 2, N):\n  ans = (ans + k * (S[k] - S[k-1]) % MOD) % MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n, p):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\ndef invfact(n, f, p):\n    m = pow(f[n], p-2, p)\n    yield m\n    for i in range(n, 0, -1):\n        m = m * i % p\n        yield m\n\nans = 0\nm = n - 1\nf = list(fact(m, p))\nrf = list(invfact(m, f, p))\nrf.reverse()\nperm = 0\n\nfor k in range((n+1)//2, n):\n    perm_ = f[k-1] * rf[2*k-n] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\ndef exponen(input1,input2):\n    binaryl=list(str(bin(input2))[2:])\n    binarysize=len(binaryl)\n    binarylist=[int(binaryl[binarysize-1-i]) for i in range(binarysize)]\n    modlist=[0 for i in range(binarysize)]\n    modlist[0]=input1\n    for i in range(1,binarysize):\n        modlist[i]=times(modlist[i-1],modlist[i-1])\n    answer=1\n    for i in range(binarysize):\n        if binarylist[i]==1:\n            answer=times(answer,modlist[i])\n    return answer\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(i,Fact[i-1])\nans=0\ndef C(A,B):\n    return divide(Fact[A],times(Fact[B],Fact[A-B]))\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    F=times(Fact[K],Fact[N-1-K])\n    G=C(K-1,N-1-K)\n    SGL[K]=(times(F,G))\nfor K in range(1,N):\n    ans=plus(ans,times(SGL[K]-SGL[K-1],K))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nN = int(input())\n\nmod = 1000000007\n\ndef euclid(a, b):\n    (x, lastx) = (0, 1)\n    (y, lasty) = (1, 0)\n    while b != 0:\n        q = a // b\n        (a, b) = (b, a % b)\n        (x, lastx) = (lastx - q * x, x)\n        (y, lasty) = (lasty - q * y, y)\n    return (lastx, lasty, a)\n\n_modinv = {}\ndef modinv(a):\n    if a not in _modinv:\n        inv, _, _ = euclid(a, mod)\n        _modinv[a] = inv%mod\n    return _modinv[a]\n\n_factorial = {0: 1}\nfor n in range(1, N+1):\n    _factorial[n] = n*_factorial[n-1]%mod\n\ndef factorial(n):\n    return _factorial[n]\n\ndef comb(n, k):\n    return factorial(n)*modinv(factorial(k))*modinv(factorial(n-k))%mod\n\nif N == 2:\n    print(1)\n    exit(0)\nif N == 3:\n    print(4)\n    exit(0)\n\nres = 0\nmem = 0\n    \nfor K in range((N+1)//2, N):\n    tmp = factorial(K)*factorial(N-1-K)*comb(K-1, N-K-1)\n    just = (tmp-mem)%mod\n    mem = tmp\n    res += K*just\n    res %= mod\n    \nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "mod=10**9+7\nN=int(input())\nFact=[1 for i in range(N+1)]\nFinv=[1 for i in range(N+1)]\nfor i in range(N):\n    Fact[i+1]=(Fact[i]*(i+1))%mod\nFinv[N]=pow(Fact[N],mod-2,mod)\nfor i in range(N-1,-1,-1):\n    Finv[i]=((i+1)*Finv[i+1])%mod\nans=0\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    SGL[K]=(((Fact[K]*Finv[2*K-N])%mod)*Fact[K-1])\nfor K in range(1,N):\n    ans+=((SGL[K]-SGL[K-1])*K)%mod\n    ans%=mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\ndef invfact(n, f, p):\n    for i in range(n):\n        yield pow(f[i], p-2, p)\n\nans = 0\nm = n - 1\nf = list(fact(m))\nrf = list(invfact(n, f, p))\nperm = 0\n\nfor k in range((n+1)//2, n):\n    b = m - k\n    a = (m - 1) - (2 * b)\n    perm_ = f[a+b] * rf[a] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\np = 10**9 + 7\n\ndef fact(n):\n    n_ = 1\n    yield n_\n    for i in range(1, n+1):\n         n_ = (n_*i) % p\n         yield n_\n\ndef invfact(n, f, p):\n    m = pow(f[n], p-2, p)\n    yield m\n    for i in range(n, 0, -1):\n        m = m * i % p\n        yield m\n\nans = 0\nm = n - 1\nf = list(fact(m))\nrf = list(invfact(m, f, p))\nrf.reverse()\nperm = 0\n\nfor k in range((n+1)//2, n):\n    b = m - k\n    a = (m - 1) - (2 * b)\n    perm_ = f[a+b] * rf[a] %p * f[k] % p\n    ans += (perm_ - perm) %p * k % p\n    ans %= p\n    perm = perm_\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\ndef exponen(input1,input2):\n    binaryl=list(str(bin(input2))[2:])\n    binarysize=len(binaryl)\n    binarylist=[int(binaryl[binarysize-1-i]) for i in range(binarysize)]\n    modlist=[0 for i in range(binarysize)]\n    modlist[0]=input1\n    for i in range(1,binarysize):\n        modlist[i]=times(modlist[i-1],modlist[i-1])\n    answer=1\n    for i in range(binarysize):\n        if binarylist[i]==1:\n            answer=times(answer,modlist[i])\n    return answer\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nFinv=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(Fact[i-1],i)\n    Finv[i]=divide(Finv[i-1],i)\nans=0\ndef C(A,B):\n    return times(Fact[A],times(Finv[B],Finv[A-B]))\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    SGL[K]=times(times(Fact[K],Fact[K-1]),Finv[2*K-N])\nfor K in range(1,N):\n    ans=plus(ans,times(SGL[K]-SGL[K-1],K))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nimport collections\nimport numba\nn = int(input())\nmachine = []\n[machine.append(i) for i in range(n-1)]\nresult = []\nfor i in permutations(machine):\n    l = []\n    [l.append(i) for i in range(n)]\n    score = 0\n    for j in i:\n        l[j] = -1\n        l[j + 1] = -1\n        score += 1\n        if(all(x == -1 for x in l)):\n            result.append(score)\n            break\ntemp = collections.Counter(result)\nans = 0\nfor k,v in temp.items():\n    ans += k*v\nprint(ans%(10**9+7))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nMOD = 10**9+7\nfac = [1,1] + [0]*N\nfinv = [1,1] + [0]*N\ninv = [0,1] + [0]*N\nfor i in range(2,N+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef ncr(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = 0\nprev = 0\nfor k in range((N+1)//2, N):\n    tmp = ncr(k-1, N-1-k) * fac[k] * fac[N-1-k]\n    tmp %= MOD\n    ans += (tmp - prev) * k\n    ans %= MOD\n    prev = tmp\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def permutations(L):\n    if L == []:\n        return [[]]\n    else:\n        return [[h]+t for i,h in enumerate(L)\n                      for t   in permutations(L[:i]+L[i+1:])]\n\nn = int(input())\n\nperm_list = []\nfor i in range(n - 1):\n    perm_list.append(str(i+1))\nperm_result = permutations(perm_list)\n#print(perm_result)\nscore = 0\nfor p in perm_result:\n    m = [0] * n\n    for j in range(len(p)):\n        m[int(p[j])-1] = 1\n        m[int(p[j])] = 1\n        mini_score = 0\n        for i in range(n-1):\n            mini_score += m[i]\n        if mini_score == n-1:\n            score += j+1\n            break\n\nprint(score)"
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 62;\n\nll factorial(ll n,ll mod = mod){\n  static ll dp[100000];\n  if(dp[n]) return dp[n];\n  if(n == 0) return dp[n] = 1;\n  return dp[n] = (n*factorial(n-1))%mod;\n}\n\nll powl(ll x,ll r,ll mod = mod){\n  ll ret = 1;\n  for(;r != 0;r >>= 1){\n    if(r&1 != 0) ret *= x,ret %= mod;\n    x *= x,x %= mod;\n  }\n  return ret;\n}\n\nll inverse(ll x,ll mod = mod){\n  return powl(x,mod-2,mod);\n}\n\nll combination(ll n,ll m,ll mod = mod){\n  if(n < m) return 0;\n  return (((factorial(n)*inverse(factorial(m)))%mod)*inverse(factorial(n-m)))%mod;\n}\n\n\nll n;\nll ans = 0;\n\nll solve(ll k){\n  return (((combination(k-1,n-1-k)*factorial(k))%mod)*factorial(n-1-k))%mod;\n}\n\n\nint main(){\n  cin >> n;\n  if(n == 2){\n    cout << 1 << endl;\n    return 0;\n  }\n  for(ll i = 2;i <= n-1;i++){\n    ans += ((((solve(i)-solve(i-1)+mod)%mod)*i)%mod);\n    ans %= mod;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\n\nmod=10**9+7\n\nFACT=[1]\nfor i in range(1,10**6+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(10**6,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nANS=0\nMINUS=0\n\ndef k_perm(k):\n    return Combi(k-1,N-k-1)*FACT[k]*FACT[N-k-1]%mod\n\nfor k in range(N//2,N):\n    ANS=(ANS+(k_perm(k)-k_perm(k-1))*k)%mod\n\nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "characteristic=10**9+7\ndef plus(input1,input2):\n    return (input1+input2)%characteristic\ndef minus(input1,input2):\n    return (input1-input2)%characteristic\ndef times(input1,input2):\n    return (input1*input2)%characteristic\ndef exponen(input1,input2):\n    binaryl=list(str(bin(input2))[2:])\n    binarysize=len(binaryl)\n    binarylist=[int(binaryl[binarysize-1-i]) for i in range(binarysize)]\n    modlist=[0 for i in range(binarysize)]\n    modlist[0]=input1\n    for i in range(1,binarysize):\n        modlist[i]=times(modlist[i-1],modlist[i-1])\n    answer=1\n    for i in range(binarysize):\n        if binarylist[i]==1:\n            answer=times(answer,modlist[i])\n    return answer\ndef divide(input1,input2):\n    return times(input1,exponen(input2,characteristic-2))\nN=int(input())\nFact=[1 for i in range(N+1)]\nFinv=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    Fact[i]=times(Fact[i-1],i)\n    Finv[i]=divide(1,Fact[i])\nans=0\nSGL=[0 for i in range(N)]\nfor K in range(N):\n    if 2*K-N<0:\n        continue\n    SGL[K]=times(times(Fact[K],Finv[2*K-N]),Fact[K-1])\nfor K in range(1,N):\n    ans=plus(ans,times(SGL[K]-SGL[K-1],K))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc023/tasks/agc023_c\n\n完全に無駄になる(すべて塗られている後に動く)マシンの数を数えればいい\nつまり、取り除いていくことを考える\n→取り除くと、その両側は取り除けない\n\nマシンの総数は (N-1)! * (N-1)\n1,N-1のマシンは取り除かれることはない\n\nN-1 の順列のうち、隣り合う数字が選ばれる or 1,N-1が選ばれるまでに登場した数字の総数を求めよ\nとなる\n\n答え = ΣΣt個取ったうえでxを取る場合\n        t x\n        \n隣り合わないでa個取る場合にはすべてが等しい確率で含まれる…？\n1234から2こ取る場合\n1 3\n1  4\n 2 4\n→違うわ　でも問題ない…？\nt番目にxを取るの数を数え上げられればいい\n\n→隣り合わないで x個取る方法 * x! * (N-1-x)!\n→隣り合わないで x個取る通り数がわかればおk\n\ndp[i][x] = i番目まで見てx個取る通り数\ndp[i][x] = Σdp[j][x-1]\n           j <= i-2\n\n1つづつ置いていくことを考える\n置くと置ける場所が2減る場合と1減る場合がある\n\n最初はXこどこにでも置ける\nそのうち、1減るのは2とおり、2減るのはN-2通り\n次のおける集合を考える\n1減るのは\n\n=====答えを見た=====\n\n愚直に考えればいい\n各Kについて、K回目ですべて塗られているような順列の個数がわかればいい→f(K)\nK回目に初めて塗られるのは f(K) - f(K-1) - f(K-2) - … - f(1)\n\nf(K)を導出する\nまず、K個のマシンを選びたい → g(K)とする\nf(K) = g(K) * K! * (N-1-K)! である\n\ng(K)を導出する\n選ばれないマスはN-1-K個\n隙間に選ばれないマスを入れていくことを考える\n\n隙間はK-1個ある\nここにN-1-K個のあまりものを入れていく\nnCr(K-1,N-1-K)\n\n\"\"\"\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv): #上で求めたfacとinvsを引数に入れるべし(上の関数で与えたnが計算できる最大のnになる)\n    if n < r:\n        return 0\n    return fac[n] * inv[n-r] * inv[r] % mod\n\nN = int(input())\nmod = 10**9+7\n\nfac,inv = modfac(N+10,mod)\nfsum = 0\nans = 0\n\nfor K in range(1,N):\n    f = modnCr(K-1,N-1-K,mod,fac,inv) * fac[K] * fac[N-1-K]\n    ans += (f - fsum) * K % mod\n    fsum = f\n    fsum %= mod\n    ans %= mod\nprint (ans)\n\n\n\n\n\n\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc023/tasks/agc023_c\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: u64 = 1000000007;\n\nstruct Combination {\n    fact: Vec<u64>,\n    invfact: Vec<u64>,\n}\n\nimpl Combination {\n    fn inv(a: u64) -> u64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: u64, p: u64) -> u64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as u64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as u64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: usize, r: usize) -> u64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[r] % MOD * self.invfact[n - r] % MOD\n    }\n\n    fn perm(&self, n: usize, r: usize) -> u64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-r] % MOD\n    }\n}\n\nfn main() {\n    input! {\n        n: usize\n    };\n\n    let comb = Combination::new(n+10);\n\n    let mut bi = vec![0; n];\n    for two in 0..n-1 {\n        let score = n-1-two;\n        let gaps = score-1;\n\n        // debug!(score, comb.comb(gaps, two) % MOD * comb.fact[score] % MOD * comb.fact[two] % MOD);\n        bi[score] = comb.comb(gaps, two) % MOD * comb.fact[score] % MOD * comb.fact[two] % MOD;\n    }\n\n    let mut sum = 0;\n    for i in 1..n {\n        sum += (i as u64) * (MOD + bi[i] - bi[i-1]) % MOD;\n        sum %= MOD;\n    }\n\n    println!(\"{}\", sum);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::collections::HashMap;\n\n\nfn invmod(a: i64, p: i64) -> i64 {\n    if a == 1 {\n        return 1;\n    } else {\n        return (1 - p*invmod(p%a, a)) / a + p;\n    }\n}\n\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    let n: i64 = sc.read();\n    let md: i64 = 1_000_000_007;\n    // println!(\"{}\", md);\n\n    let mut facn1 = 1;\n    for i in 1..n {\n        facn1 *= i;\n        facn1 %= md;\n    }\n    let facn1 = facn1;\n    // println!(\"{}\", facn1);\n    // println!(\"a\");\n    let mut ans: i64 = 0;\n\n    let mut x: i64 = facn1;\n    ans += x;\n    for i in 0..n-2 {\n        x *= (n-2 - 2*i);\n        x %= md;\n        x *= (n-3 - 2*i);\n        x %= md;\n        let t: i64 = (n-1 - i) * (n-2 - i) * (i + 1);\n        x *= invmod(t % md, md);\n        x %= md;\n        // println!(\"{}\", x);\n        ans += (facn1 - x);\n        ans %= md;\n    }\n    ans = (ans + md) % md;\n\n\n    /*\n    let mut x = 1;\n    for i in 1..n {\n        x *= i;\n        x %= md;\n        if i * 2 < n {\n            ans += facn1;\n            ans %= md;\n        } else {\n        }\n    }\n    */\n\n    println!(\"{}\", ans);\n}\n\n// thanks, ir5\nuse std::io::{stdin, Read, StdinLock};\nuse std::str::FromStr;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner { cin: cin }\n    }\n\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin\n            .by_ref()\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        token.parse::<T>().ok()\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc023/tasks/agc023_c\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: u64 = 1000000007;\n\nstruct Combination {\n    fact: Vec<u64>,\n    invfact: Vec<u64>,\n}\n\nimpl Combination {\n    fn inv(a: u64) -> u64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: u64, p: u64) -> u64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as u64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as u64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: usize, r: usize) -> u64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[r] % MOD * self.invfact[n - r] % MOD\n    }\n\n    fn perm(&self, n: usize, r: usize) -> u64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-r] % MOD\n    }\n}\n\nfn main() {\n    input! {\n        n: usize\n    };\n\n    let comb = Combination::new(n+10);\n\n    let mut bi = vec![0; n];\n    for two in 0..n-1 {\n        let score = n-1-two;\n        let gaps = score-1;\n\n        debug!(score, comb.comb(gaps, two) % MOD * comb.fact[score] % MOD * comb.fact[two] % MOD);\n        bi[score] = comb.comb(gaps, two) % MOD * comb.fact[score] % MOD * comb.fact[two] % MOD;\n    }\n\n    let mut sum = 0;\n    for i in 1..n {\n        sum += (i as u64) * (MOD + bi[i] - bi[i-1]) % MOD;\n        sum %= MOD;\n    }\n\n    println!(\"{}\", sum);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 1_000_000_007;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let n: usize = sc.read();\n\n    if n == 2 {\n        println!(\"{}\", 1);\n        return;\n    } else if n == 3 {\n        println!(\"{}\", 4);\n        return;\n    }\n\n    let combination = Combination::new(n + 1, MOD);\n    let mut factorial = vec![1; n + 1];\n    for i in 0..n {\n        factorial[i + 1] = (factorial[i] * (i + 1)) % MOD;\n    }\n\n    let mut ans = 0;\n    let mut sum = 0;\n    for k in 2..n {\n        if k - 1 < n - 1 - k {\n            continue;\n        }\n        let mut c = combination.get(k - 1, n - 1 - k);\n        c = (c * factorial[k]) % MOD;\n        c = (c * factorial[n - 1 - k]) % MOD;\n        c = ((c + MOD) - sum) % MOD;\n        sum = (c + sum) % MOD;\n        ans = (ans + c * k) % MOD;\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Combination {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Combination {\n            fact: fact,\n            inv_fact: inv_fact,\n            modulo: modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> usize {\n        assert!(x >= y);\n        self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo\n    }\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        assert!(self.0 > 0);\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end Precalc ----------\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let n: usize = s.trim().parse().unwrap();\n    let pc = Precalc::new(n);\n    let mut way = vec![ModInt::zero(); n];\n    for x in (1..n).rev() {\n        let y = n - 1 - x;\n        if y > x - 1 {\n            break;\n        }\n        way[x] = pc.comb(x - 1, y) * pc.fact(x) * pc.fact(n - 1 - x);\n    }\n    let mut ans = ModInt::zero();\n    for i in 1..n {\n        ans += ModInt(i as u32) * (way[i] - way[i - 1]);\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse modular::*;\n\nfn main() {\n    let con = read_string();\n    let mut sc = Scanner::new(&con);\n\n    let n: usize = sc.next();\n\n    let mut fact_tbl: Vec<Modular> = vec![1.into(); n + 1];\n    let mut ifact_tbl: Vec<Modular> = vec![1.into(); n + 1];\n\n    for i in 1..n + 1 {\n        fact_tbl[i] = fact_tbl[i - 1] * (i as i64);\n        ifact_tbl[i] = fact_tbl[i].recip();\n    }\n\n    let comb = |n, k| -> Modular { fact_tbl[n] * ifact_tbl[k] * ifact_tbl[n - k] };\n\n    let mut acc: Modular = 0.into();\n    let mut ans: Modular = 0.into();\n\n    for k in (n + 1) / 2..n {\n        let p1 = fact_tbl[k];\n        let p2 = fact_tbl[n - 1 - k];\n        let t = comb(k - 1, n - 1 - k);\n\n        let v: Modular = t * (p1 * p2) - acc;\n\n        ans += v * (k as i64);\n        acc += v;\n    }\n\n    println!(\"{}\", ans);\n}\n\n//-----\n\npub mod io {\n    use std;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T>(&mut self) -> T\n        where\n            T: std::str::FromStr,\n            <T as std::str::FromStr>::Err: std::fmt::Debug,\n        {\n            let s = self.iter.next().unwrap();\n            s.parse::<T>().unwrap()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n\npub mod modular {\n    const M: i64 = 1000000007;\n\n    #[derive(Debug, Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq)]\n    pub struct Modular(i64);\n\n    impl ::std::fmt::Display for Modular {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl Modular {\n        pub fn new(v: i64) -> Modular {\n            Modular(v % M)\n        }\n\n        pub fn pow(self, mut r: i64) -> Modular {\n            let mut k = self;\n            let mut ret = 1.into();\n\n            while r > 0 {\n                if r % 2 != 0 {\n                    ret = ret * k;\n                }\n                r /= 2;\n                k = k * k;\n            }\n\n            ret\n        }\n\n        // This requires M is prime\n        pub fn recip(self) -> Modular {\n            self.pow(M - 2)\n        }\n    }\n\n    use std::ops::*;\n\n    impl<T: Into<Modular>> Add<T> for Modular {\n        type Output = Modular;\n        fn add(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 + rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> AddAssign<T> for Modular {\n        fn add_assign(&mut self, rhs: T) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Sub<T> for Modular {\n        type Output = Modular;\n        fn sub(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 - rhs.into().0 + M)\n        }\n    }\n    impl<T: Into<Modular>> SubAssign<T> for Modular {\n        fn sub_assign(&mut self, rhs: T) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Mul<T> for Modular {\n        type Output = Modular;\n        fn mul(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 * rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> MulAssign<T> for Modular {\n        fn mul_assign(&mut self, rhs: T) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Div<T> for Modular {\n        type Output = Modular;\n        fn div(self, rhs: T) -> Self::Output {\n            self * rhs.into().recip()\n        }\n    }\n    impl<T: Into<Modular>> DivAssign<T> for Modular {\n        fn div_assign(&mut self, rhs: T) {\n            *self = *self / rhs;\n        }\n    }\n\n    impl Neg for Modular {\n        type Output = Modular;\n        fn neg(self) -> Self::Output {\n            Modular(0) - self\n        }\n    }\n\n    impl<T: ::std::convert::Into<i64>> ::std::convert::From<T> for Modular {\n        fn from(v: T) -> Self {\n            Modular::new(v.into())\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse modular::*;\n\n// use std::collections::BTreeMap;\n\n// fn bf(\n//     cur: usize,\n//     n: usize,\n//     used: i64,\n//     hist: &mut Vec<usize>,\n//     mm: &mut BTreeMap<i64, i64>,\n// ) -> Modular {\n//     if cur == n - 1 {\n//         let mut v = vec![false; n];\n//         let mut pn = 0;\n//         for i in 0..n - 1 {\n//             if !v[hist[i]] {\n//                 pn += 1;\n//             }\n//             if !v[hist[i] + 1] {\n//                 pn += 1;\n//             }\n//             v[hist[i]] = true;\n//             v[hist[i] + 1] = true;\n\n//             if pn == n {\n//                 // if i + 1 == (n + 1) / 2 {\n//                 //     println!(\"{:?}\", hist);\n//                 // }\n//                 *mm.entry(i as i64 + 1).or_insert(0) += 1;\n//                 return (i as i64 + 1).into();\n//             }\n//         }\n\n//         unreachable!();\n//     }\n\n//     let mut ret = 0.into();\n\n//     for i in 0..n - 1 {\n//         if used & (1 << i) != 0 {\n//             continue;\n//         }\n\n//         hist[cur] = i;\n//         ret += bf(cur + 1, n, used | (1 << i), hist, mm);\n//     }\n\n//     ret\n// }\n\nfn main() {\n    // for n in 2..12 {\n    //     let mut hist = vec![0; n - 1];\n    //     let mut mm = BTreeMap::new();\n    //     println!(\"{}: {}\", n, bf(0, n, 0, &mut hist, &mut mm));\n\n    //     let mut acc: i64 = 0;\n\n    //     for (k, v) in mm {\n    //         let p1: i64 = (1..k + 1).product();\n    //         let p2: i64 = (1..(n as i64 - 1 - k + 1)).product();\n\n    //         // let cur = p1 * p2 - acc;\n\n    //         // println!(\"  * k={}, v={}, cur={}\", k, v, cur);\n    //         assert!((v + acc) % (p1 * p2) == 0);\n    //         // assert!((v + acc) % (p1 * p2) == 0);\n    //         println!(\"  * {}: {}, {}\", k, v, (v + acc) / (p1 * p2));\n\n    //         acc += v;\n    //     }\n    // }\n\n    let con = read_string();\n    let mut sc = Scanner::new(&con);\n\n    let n: usize = sc.next();\n\n    let mut fact_tbl: Vec<Modular> = vec![1.into(); n + 1];\n    let mut ifact_tbl: Vec<Modular> = vec![1.into(); n + 1];\n\n    for i in 1..n + 1 {\n        fact_tbl[i] = fact_tbl[i - 1] * (i as i64);\n        ifact_tbl[i] = fact_tbl[i].recip();\n    }\n\n    let fact = |n| -> Modular { fact_tbl[n] };\n    let ifact = |n| -> Modular { ifact_tbl[n] };\n    let comb = |n, k| -> Modular { fact(n) * ifact(k) * ifact(n - k) };\n\n    let mut acc: Modular = 0.into();\n    let mut ans: Modular = 0.into();\n\n    for k in (n + 1) / 2..n {\n        let p1 = fact(k);\n        let p2 = fact(n - 1 - k);\n        let t = comb(k - 1, n - 1 - k);\n\n        let v: Modular = t * (p1 * p2) - acc;\n\n        ans += v * (k as i64);\n        acc += v;\n    }\n\n    println!(\"{}\", ans);\n}\n\n//-----\n\npub mod io {\n    use std;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T>(&mut self) -> T\n        where\n            T: std::str::FromStr,\n            <T as std::str::FromStr>::Err: std::fmt::Debug,\n        {\n            let s = self.iter.next().unwrap();\n            s.parse::<T>().unwrap()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n\npub mod modular {\n    const M: i64 = 1000000007;\n\n    #[derive(Debug, Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq)]\n    pub struct Modular(i64);\n\n    impl ::std::fmt::Display for Modular {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl Modular {\n        pub fn new(v: i64) -> Modular {\n            Modular(v % M)\n        }\n\n        pub fn pow(self, mut r: i64) -> Modular {\n            let mut k = self;\n            let mut ret = 1.into();\n\n            while r > 0 {\n                if r % 2 != 0 {\n                    ret = ret * k;\n                }\n                r /= 2;\n                k = k * k;\n            }\n\n            ret\n        }\n\n        // This requires M is prime\n        pub fn recip(self) -> Modular {\n            self.pow(M - 2)\n        }\n    }\n\n    use std::ops::*;\n\n    impl<T: Into<Modular>> Add<T> for Modular {\n        type Output = Modular;\n        fn add(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 + rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> AddAssign<T> for Modular {\n        fn add_assign(&mut self, rhs: T) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Sub<T> for Modular {\n        type Output = Modular;\n        fn sub(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 - rhs.into().0 + M)\n        }\n    }\n    impl<T: Into<Modular>> SubAssign<T> for Modular {\n        fn sub_assign(&mut self, rhs: T) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Mul<T> for Modular {\n        type Output = Modular;\n        fn mul(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 * rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> MulAssign<T> for Modular {\n        fn mul_assign(&mut self, rhs: T) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Div<T> for Modular {\n        type Output = Modular;\n        fn div(self, rhs: T) -> Self::Output {\n            self * rhs.into().recip()\n        }\n    }\n    impl<T: Into<Modular>> DivAssign<T> for Modular {\n        fn div_assign(&mut self, rhs: T) {\n            *self = *self / rhs;\n        }\n    }\n\n    impl Neg for Modular {\n        type Output = Modular;\n        fn neg(self) -> Self::Output {\n            Modular(0) - self\n        }\n    }\n\n    impl<T: ::std::convert::Into<i64>> ::std::convert::From<T> for Modular {\n        fn from(v: T) -> Self {\n            Modular::new(v.into())\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_macros, dead_code)]\nuse std::f64::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! dump{\n    ($($a:expr),*) => {\n        #[cfg(debug_assertions)]\n        eprintln!(\n            concat!(\"{}:{}:{}: \",$(stringify!($a), \" = {:?}, \"),*),\n            file!(), line!(), column!(), $($a),*\n        );\n        #[cfg(not(debug_assertions))]\n        {};\n    }\n}\n\nconst INF: i64 = 0x3f3f3f3f3f3f3f3f;\nconst MOD: i64 = 1000000007;\nconst NOTHING: usize = std::usize::MAX;\nconst DX: [usize; 4] = [1, 0, std::usize::MAX, 0];\nconst DY: [usize; 4] = [0, 1, 0, std::usize::MAX];\nconst N: usize = 1_000_000;\nfn solve<R: std::io::Read, W: std::io::Write>(io: &mut IO<R, W>) {\n    let n: usize = io.read();\n    let mut fact: Vec<i64> = vec![1;n+1];\n    for i in 2..n + 1 {\n        fact[i] = fact[i - 1] * i as i64 % MOD;\n    }\n    let mut res = 0;\n    let mut prev = 0;\n\n    for k in (n + 1) / 2..n {\n        let cur = fact[k] * fact[k - 1] % MOD * recip_mod(fact[2 * k - n], MOD) % MOD;\n        let mut diff = (cur - prev) % MOD;\n        if diff < 0 {\n            diff += MOD;\n        }\n        res = (res + diff * k as i64 % MOD) % MOD;\n        prev = cur;\n    }\n    io.writeln(res);\n}\n\npub fn recip_mod(x: i64, modulus: i64) -> i64 {\n    let mut r0 = x;\n    let mut r1 = modulus;\n    let mut x0 = 1;\n    let mut x1 = 0;\n    while r1 > 0 {\n        let q = r0 / r1;\n        r0 = r0 % r1;\n        std::mem::swap(&mut r0, &mut r1);\n        x0 = x0 - q * x1;\n        std::mem::swap(&mut x0, &mut x1);\n    }\n    let res = x0 % modulus;\n    if res < 0 { res + modulus } else { res }\n}\n\nfn main() {\n    use std::io::*;\n    let stdin = stdin();\n    let stdin = BufReader::new(stdin.lock());\n    let stdout = stdout();\n    let stdout = BufWriter::new(stdout.lock());\n    let mut io = IO::new(stdin, stdout);\n    solve(&mut io);\n    io.flush();\n}\n\npub struct IO<R, W> {\n    reader: std::io::Bytes<R>,\n    writer: W,\n}\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO {\n            reader: r.bytes(),\n            writer: w,\n        }\n    }\n\n    pub fn read<T: Read>(&mut self) -> T {\n        T::read(&mut self.reader)\n    }\n\n    pub fn reads<T: Read>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| T::read(&mut self.reader)).collect()\n    }\n\n    pub fn write<T: std::fmt::Display>(&mut self, x: T) {\n        self.writer.write_fmt(format_args!(\"{}\", x)).unwrap();\n    }\n    pub fn writeln<T: std::fmt::Display>(&mut self, x: T) {\n        self.writer.write_fmt(format_args!(\"{}\\n\", x)).unwrap();\n    }\n\n    pub fn writes<T: std::fmt::Display>(&mut self, xs: &Vec<T>, sep: &str) {\n        let mut it = xs.iter();\n        for &x in it.next().iter() {\n            self.write(x);\n        }\n        for x in it {\n            self.writer.write(sep.as_bytes()).unwrap();\n            self.write(x);\n        }\n    }\n\n    pub fn writesln<T: std::fmt::Display>(&mut self, xs: &Vec<T>, sep: &str) {\n        self.writes(xs, sep);\n        self.writer.write(b\"\\n\").unwrap();\n    }\n\n    pub fn flush(&mut self) {\n        self.writer.flush().unwrap()\n    }\n}\n\npub trait Read {\n    fn read<R: std::io::Read>(bytes: &mut std::io::Bytes<R>) -> Self;\n}\n\n#[inline(always)]\npub fn is_whitespace(x: u8) -> bool {\n    x < 33u8 || 126u8 < x\n}\n\nmacro_rules! read_int_impl{\n    ($($t:ty)*) => ($(\n        impl Read for $t {\n            fn read<R: std::io::Read>(bytes: &mut std::io::Bytes<R>) -> Self {\n                let head: u8 = bytes\n                    .map(|x| x.unwrap())\n                    .skip_while(|&x| is_whitespace(x))\n                    .next()\n                    .unwrap();\n                if head == 45u8 {\n                    bytes.map(|x| x.unwrap())\n                        .take_while(|&x| !is_whitespace(x))\n                        .fold(0, |a, x| 10 * a - x as $t + 48)\n                } else {\n                    bytes.map(|x| x.unwrap())\n                        .take_while(|&x| !is_whitespace(x))\n                        .fold((head - 48) as $t, |a, x| 10 * a + x as $t - 48)\n                }\n            }\n        }\n    )*)\n}\nread_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64}\n\nmacro_rules! read_float_impl{\n    ($($t:ty)*) => ($(\n        impl Read for $t {\n            fn read<R: std::io::Read>(bytes: &mut std::io::Bytes<R>) -> Self {\n                String::read(bytes).as_str().parse::<$t>().unwrap()\n            }\n        }\n    )*)\n}\nread_float_impl! { f32 f64 }\n\nimpl Read for char {\n    fn read<R: std::io::Read>(bytes: &mut std::io::Bytes<R>) -> Self {\n        bytes.map(|x| x.unwrap())\n            .skip_while(|&x| is_whitespace(x))\n            .next()\n            .unwrap() as char\n    }\n}\n\nimpl Read for String {\n    fn read<R: std::io::Read>(bytes: &mut std::io::Bytes<R>) -> Self {\n        bytes.map(|x| x.unwrap())\n            .skip_while(|&x| is_whitespace(x))\n            .take_while(|&x| !is_whitespace(x))\n            .map(|x| x as char)\n            .collect()\n    }\n}\n\nimpl Read for Vec<char> {\n    fn read<R: std::io::Read>(bytes: &mut std::io::Bytes<R>) -> Self {\n        bytes.map(|x| x.unwrap())\n            .skip_while(|&x| is_whitespace(x))\n            .take_while(|&x| !is_whitespace(x))\n            .map(|x| x as char)\n            .collect()\n    }\n}\n\nmacro_rules! read_tuple_impl{\n    ($($t:ident),+) => {\n        impl<$($t: Read),*> Read for ($($t),*) {\n            fn read<R: std::io::Read>(bytes: &mut std::io::Bytes<R>) -> Self {\n                ($($t::read(bytes)),+)\n            }\n        }\n    }\n}\nread_tuple_impl!(A, B);\nread_tuple_impl!(A, B, C);\nread_tuple_impl!(A, B, C, D);\nread_tuple_impl!(A, B, C, D, E);\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 1_000_000_007;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let n: usize = sc.read();\n    if n == 2 {\n        println!(\"1\");\n        return;\n    }\n\n    let comb = Combination::new(n, MOD);\n    let mut fact = vec![1; n];\n    for i in 1..n {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n\n    let mut ans = 0;\n    let mut sum = 0;\n    for k in 2..n {\n        let mut pausing = n - 1 - k;\n        if k - 1 < pausing {\n            continue;\n        }\n        let c = comb.get(k - 1, pausing);\n        let c = (((c * fact[k]) % MOD) * fact[pausing]) % MOD;\n        let c = c + MOD - sum;\n        sum = (sum + c) % MOD;\n        ans = (ans + k * c) % MOD;\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Combination {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Combination {\n            fact: fact,\n            inv_fact: inv_fact,\n            modulo: modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> usize {\n        assert!(x >= y);\n        self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo\n    }\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules !zero_one_impls {($({$Trait :ident $method :ident $($t :ty ) *,$e :expr } ) *) =>{$($(impl $Trait for $t {#[inline ] fn $method () ->Self {$e } } ) *) *} ;}\nzero_one_impls !({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,0 } {Zero zero f32 f64 ,0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,1 } {One one f32 f64 ,1. } ) ;\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String ) ;\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($(<$T as IterScan >::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B ) ;\n    iter_scan_tuple_impl !(A B C ) ;\n    iter_scan_tuple_impl !(A B C D ) ;\n    iter_scan_tuple_impl !(A B C D E ) ;\n    iter_scan_tuple_impl !(A B C D E F ) ;\n    iter_scan_tuple_impl !(A B C D E F G ) ;\n    iter_scan_tuple_impl !(A B C D E F G H ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J K ) ;\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\npub trait Modulus {\n    fn get_modulus() -> u32;\n    #[inline]\n    fn modulo(x: u32) -> u32 {\n        x % Self::get_modulus()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules! make_modulus {\n    ($t :ident ,$e :expr ) => {\n        pub struct $t {}\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                const MODULUS: u32 = $e;\n                MODULUS\n            }\n        }\n    };\n}\n#[allow(unused_macros)]\nmacro_rules! make_dynamic_modulus {\n    ($t :ident ,$m :ident ,$e :expr ) => {\n        pub struct $t {}\n        static mut $m: u32 = $e;\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                unsafe { $m }\n            }\n        }\n    };\n}\npub mod modulus {\n    use super::*;\n    pub struct Modulo1000000007 {}\n    impl Modulus for Modulo1000000007 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_007;\n            MODULUS\n        }\n    }\n    pub struct Modulo1000000009 {}\n    impl Modulus for Modulo1000000009 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_009;\n            MODULUS\n        }\n    }\n    pub struct Modulo998244353 {}\n    impl Modulus for Modulo998244353 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 998_244_353;\n            MODULUS\n        }\n    }\n    pub struct DynModulo {}\n    static mut DYN_MODULUS: u32 = 1_000_000_007;\n    impl Modulus for DynModulo {\n        #[inline]\n        fn get_modulus() -> u32 {\n            unsafe { DYN_MODULUS }\n        }\n    }\n    pub fn set_dyn_modulus(m: u32) {\n        unsafe {\n            DYN_MODULUS = m;\n        }\n    }\n}\npub struct MInt<M>\nwhere\n    M: Modulus,\n{\n    x: u32,\n    _marker: std::marker::PhantomData<fn() -> M>,\n}\nmod mint_impls {\n    use super::*;\n    use std::{\n        cmp::Ordering,\n        fmt::{self, Debug},\n        hash::{Hash, Hasher},\n        iter::{Product, Sum},\n        marker::PhantomData,\n        mem::swap,\n        num::ParseIntError,\n        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n        str::FromStr,\n    };\n    impl<M: Modulus> MInt<M> {\n        #[inline]\n        pub fn new(x: u32) -> Self {\n            Self {\n                x: M::modulo(x),\n                _marker: PhantomData,\n            }\n        }\n        #[inline]\n        pub fn new_unchecked(x: u32) -> Self {\n            Self {\n                x,\n                _marker: PhantomData,\n            }\n        }\n        #[inline]\n        pub fn inner(self) -> u32 {\n            self.x\n        }\n        #[inline]\n        pub fn get_mod() -> u32 {\n            M::get_modulus()\n        }\n        #[inline]\n        pub fn pow(mut self, mut y: usize) -> Self {\n            let mut x = Self::one();\n            while y > 0 {\n                if y & 1 == 1 {\n                    x *= self;\n                }\n                self *= self;\n                y >>= 1;\n            }\n            x\n        }\n        #[inline]\n        /// only prime modulus\n        pub fn inv(self) -> Self {\n            let mut a = self.x;\n            let (mut b, mut u, mut s) = (M::get_modulus(), 1, 0);\n            let k = a.trailing_zeros();\n            a >>= k;\n            for _ in 0..k {\n                if u & 1 == 1 {\n                    u += M::get_modulus();\n                }\n                u /= 2;\n            }\n            while a != b {\n                if b < a {\n                    swap(&mut a, &mut b);\n                    swap(&mut u, &mut s);\n                }\n                b -= a;\n                if s < u {\n                    s += M::get_modulus();\n                }\n                s -= u;\n                let k = b.trailing_zeros();\n                b >>= k;\n                for _ in 0..k {\n                    if s & 1 == 1 {\n                        s += M::get_modulus();\n                    }\n                    s /= 2;\n                }\n            }\n            Self::new_unchecked(s)\n        }\n    }\n    impl<M: Modulus> Clone for MInt<M> {\n        #[inline]\n        fn clone(&self) -> Self {\n            Self {\n                x: Clone::clone(&self.x),\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<M: Modulus> Copy for MInt<M> {}\n    impl<M: Modulus> Debug for MInt<M> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            Debug::fmt(&self.x, f)\n        }\n    }\n    impl<M: Modulus> Default for MInt<M> {\n        #[inline]\n        fn default() -> Self {\n            Self::zero()\n        }\n    }\n    impl<M: Modulus> PartialEq for MInt<M> {\n        #[inline]\n        fn eq(&self, other: &Self) -> bool {\n            PartialEq::eq(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> PartialOrd for MInt<M> {\n        #[inline]\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            PartialOrd::partial_cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Eq for MInt<M> {}\n    impl<M: Modulus> Ord for MInt<M> {\n        #[inline]\n        fn cmp(&self, other: &Self) -> Ordering {\n            Ord::cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Hash for MInt<M> {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            Hash::hash(&self.x, state)\n        }\n    }\n    impl<M: Modulus> From<u32> for MInt<M> {\n        #[inline]\n        fn from(x: u32) -> Self {\n            Self::new(x)\n        }\n    }\n    impl<M: Modulus> From<u64> for MInt<M> {\n        #[inline]\n        fn from(x: u64) -> Self {\n            Self::new_unchecked((x % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> From<usize> for MInt<M> {\n        #[inline]\n        fn from(x: usize) -> Self {\n            Self::new_unchecked((x % M::get_modulus() as usize) as u32)\n        }\n    }\n    impl<M: Modulus> From<i32> for MInt<M> {\n        #[inline]\n        fn from(x: i32) -> Self {\n            let x = x % M::get_modulus() as i32;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i32) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> From<i64> for MInt<M> {\n        #[inline]\n        fn from(x: i64) -> Self {\n            let x = x % M::get_modulus() as i64;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i64) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> From<isize> for MInt<M> {\n        #[inline]\n        fn from(x: isize) -> Self {\n            let x = x % M::get_modulus() as isize;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as isize) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> Add for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn add(self, rhs: Self) -> Self::Output {\n            let mut x = self.x + rhs.x;\n            if x >= M::get_modulus() {\n                x -= M::get_modulus();\n            }\n            Self::new_unchecked(x)\n        }\n    }\n    impl<M: Modulus> Sub for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn sub(self, rhs: Self) -> Self::Output {\n            if self.x < rhs.x {\n                Self::new_unchecked(self.x + M::get_modulus() - rhs.x)\n            } else {\n                Self::new_unchecked(self.x - rhs.x)\n            }\n        }\n    }\n    impl<M: Modulus> Mul for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn mul(self, rhs: Self) -> Self::Output {\n            Self::new_unchecked((self.x as u64 * rhs.x as u64 % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> Div for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn div(self, rhs: Self) -> Self::Output {\n            self * rhs.inv()\n        }\n    }\n    impl<M: Modulus> Neg for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn neg(self) -> Self::Output {\n            if self.x == 0 {\n                Self::zero()\n            } else {\n                Self::new_unchecked(M::get_modulus() - self.x)\n            }\n        }\n    }\n    impl<M: Modulus> Sum for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<M: Modulus> Product for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Sum<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Product<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<M: Modulus> fmt::Display for MInt<M> {\n        fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> Result<(), fmt::Error> {\n            write!(f, \"{}\", self.x)\n        }\n    }\n    impl<M: Modulus> FromStr for MInt<M> {\n        type Err = ParseIntError;\n        #[inline]\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            s.parse::<u32>().map(Self::new)\n        }\n    }\n    impl<M: Modulus> IterScan for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            iter.next()?.parse::<MInt<M>>().ok()\n        }\n    }\n    impl<M: Modulus> Zero for MInt<M> {\n        #[inline]\n        fn zero() -> Self {\n            Self::new_unchecked(0)\n        }\n    }\n    impl<M: Modulus> One for MInt<M> {\n        #[inline]\n        fn one() -> Self {\n            Self::new_unchecked(1)\n        }\n    }\n    macro_rules! mint_ref_binop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp<$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: $t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(self, *other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, *other)\n                }\n            }\n        };\n    }\n    mint_ref_binop!(Add, add, MInt<M>);\n    mint_ref_binop!(Sub, sub, MInt<M>);\n    mint_ref_binop!(Mul, mul, MInt<M>);\n    mint_ref_binop!(Div, div, MInt<M>);\n    macro_rules! mint_ref_unop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp for &$t {\n                type Output = <$t as $imp>::Output;\n                #[inline]\n                fn $method(self) -> <$t as $imp>::Output {\n                    $imp::$method(*self)\n                }\n            }\n        };\n    }\n    mint_ref_unop!(Neg, neg, MInt<M>);\n    macro_rules! mint_ref_op_assign {\n        ($imp :ident ,$method :ident ,$t :ty ,$fromimp :ident ,$frommethod :ident ) => {\n            impl<M: Modulus> $imp<$t> for $t {\n                #[inline]\n                fn $method(&mut self, rhs: $t) {\n                    *self = $fromimp::$frommethod(*self, rhs);\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                #[inline]\n                fn $method(&mut self, other: &$t) {\n                    $imp::$method(self, *other);\n                }\n            }\n        };\n    }\n    mint_ref_op_assign!(AddAssign, add_assign, MInt<M>, Add, add);\n    mint_ref_op_assign!(SubAssign, sub_assign, MInt<M>, Sub, sub);\n    mint_ref_op_assign!(MulAssign, mul_assign, MInt<M>, Mul, mul);\n    mint_ref_op_assign!(DivAssign, div_assign, MInt<M>, Div, div);\n}\n#[derive(Clone, Debug)]\npub struct MemorizedFactorial<M: Modulus> {\n    pub fact: Vec<MInt<M>>,\n    pub inv_fact: Vec<MInt<M>>,\n}\nimpl<M: Modulus> MemorizedFactorial<M> {\n    pub fn new(max_n: usize) -> Self {\n        let mut fact = vec![MInt::one(); max_n + 1];\n        let mut inv_fact = vec![MInt::one(); max_n + 1];\n        for i in 2..=max_n {\n            fact[i] = fact[i - 1] * MInt::new(i as u32);\n        }\n        inv_fact[max_n] = fact[max_n].inv();\n        for i in (3..=max_n).rev() {\n            inv_fact[i - 1] = inv_fact[i] * MInt::new(i as u32);\n        }\n        Self { fact, inv_fact }\n    }\n    #[inline]\n    pub fn combination(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        if r <= n {\n            self.fact[n] * self.inv_fact[r] * self.inv_fact[n - r]\n        } else {\n            MInt::zero()\n        }\n    }\n    #[inline]\n    pub fn permutation(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        if r <= n {\n            self.fact[n] * self.inv_fact[n - r]\n        } else {\n            MInt::zero()\n        }\n    }\n    #[inline]\n    pub fn homogeneous_product(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n + r < self.fact.len() + 1);\n        if n != 0 && r != 0 {\n            self.combination(n + r - 1, r)\n        } else {\n            MInt::one()\n        }\n    }\n    #[inline]\n    pub fn inv(&self, n: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        debug_assert!(n > 0);\n        self.inv_fact[n] * self.fact[n - 1]\n    }\n}\ntype M = MInt<modulus::Modulo1000000007>;\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut _in_buf = Vec::new();\n    stdin().read_to_end(&mut _in_buf).expect(\"io error\");\n    let _in_buf = unsafe { String::from_utf8_unchecked(_in_buf) };\n    let mut scanner = Scanner::new(&_in_buf);\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :ty ;$len :expr ] ) =>{scanner .scan_vec ::<$t >($len ) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;([$t :ty ] ) =>{scanner .iter ::<$t >() } ;({$e :expr } ) =>{scanner .mscan ($e ) } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let _out = stdout();\n    let mut _out = BufWriter::new(_out.lock());\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let f = MemorizedFactorial::new(n);\n    let mut ans = M::zero();\n    let mut p = M::zero();\n    for k in (n + 1) / 2..n {\n        let x = f.combination(k - 1, 2 * k - n) * f.fact[k] * f.fact[n - k - 1];\n        ans += (x - p) * M::from(k);\n        p = x;\n    }\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse modular::*;\n\nfn main() {\n    let con = read_string();\n    let mut sc = Scanner::new(&con);\n\n    let n: usize = sc.next();\n\n    let mut fact_tbl: Vec<Modular> = vec![1.into(); n + 1];\n    let mut ifact_tbl: Vec<Modular> = vec![1.into(); n + 1];\n\n    for i in 1..n + 1 {\n        fact_tbl[i] = fact_tbl[i - 1] * (i as i64);\n        ifact_tbl[i] = fact_tbl[i].recip();\n    }\n\n    let comb = |n, k| -> Modular { fact_tbl[n] * ifact_tbl[k] * ifact_tbl[n - k] };\n\n    let mut acc: Modular = 0.into();\n    let mut ans: Modular = 0.into();\n\n    for k in (n + 1) / 2..n {\n        let p1 = fact_tbl[k];\n        let p2 = fact_tbl[n - 1 - k];\n        let t = comb(k - 1, n - 1 - k);\n        let v = t * (p1 * p2) - acc;\n\n        ans += v * (k as i64);\n        acc += v;\n    }\n\n    println!(\"{}\", ans);\n}\n\n//-----\n\npub mod io {\n    use std;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T>(&mut self) -> T\n        where\n            T: std::str::FromStr,\n            <T as std::str::FromStr>::Err: std::fmt::Debug,\n        {\n            let s = self.iter.next().unwrap();\n            s.parse::<T>().unwrap()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n\npub mod modular {\n    const M: i64 = 1000000007;\n\n    #[derive(Debug, Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq)]\n    pub struct Modular(i64);\n\n    impl ::std::fmt::Display for Modular {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl Modular {\n        pub fn new(v: i64) -> Modular {\n            Modular(v % M)\n        }\n\n        pub fn pow(self, mut r: i64) -> Modular {\n            let mut k = self;\n            let mut ret = 1.into();\n\n            while r > 0 {\n                if r % 2 != 0 {\n                    ret = ret * k;\n                }\n                r /= 2;\n                k = k * k;\n            }\n\n            ret\n        }\n\n        // This requires M is prime\n        pub fn recip(self) -> Modular {\n            self.pow(M - 2)\n        }\n    }\n\n    use std::ops::*;\n\n    impl<T: Into<Modular>> Add<T> for Modular {\n        type Output = Modular;\n        fn add(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 + rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> AddAssign<T> for Modular {\n        fn add_assign(&mut self, rhs: T) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Sub<T> for Modular {\n        type Output = Modular;\n        fn sub(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 - rhs.into().0 + M)\n        }\n    }\n    impl<T: Into<Modular>> SubAssign<T> for Modular {\n        fn sub_assign(&mut self, rhs: T) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Mul<T> for Modular {\n        type Output = Modular;\n        fn mul(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 * rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> MulAssign<T> for Modular {\n        fn mul_assign(&mut self, rhs: T) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Div<T> for Modular {\n        type Output = Modular;\n        fn div(self, rhs: T) -> Self::Output {\n            self * rhs.into().recip()\n        }\n    }\n    impl<T: Into<Modular>> DivAssign<T> for Modular {\n        fn div_assign(&mut self, rhs: T) {\n            *self = *self / rhs;\n        }\n    }\n\n    impl Neg for Modular {\n        type Output = Modular;\n        fn neg(self) -> Self::Output {\n            Modular(0) - self\n        }\n    }\n\n    impl<T: ::std::convert::Into<i64>> ::std::convert::From<T> for Modular {\n        fn from(v: T) -> Self {\n            Modular::new(v.into())\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use io::*;\nuse modular::*;\n\nfn main() {\n    let con = read_string();\n    let mut sc = Scanner::new(&con);\n\n    let n: usize = sc.next();\n\n    let mut fact_tbl: Vec<Modular> = vec![1.into(); n + 1];\n    let mut ifact_tbl: Vec<Modular> = vec![1.into(); n + 1];\n\n    for i in 1..n + 1 {\n        fact_tbl[i] = fact_tbl[i - 1] * (i as i64);\n        ifact_tbl[i] = fact_tbl[i].recip();\n    }\n\n    let fact = |n| -> Modular { fact_tbl[n] };\n    let ifact = |n| -> Modular { ifact_tbl[n] };\n    let comb = |n, k| -> Modular { fact(n) * ifact(k) * ifact(n - k) };\n\n    let mut acc: Modular = 0.into();\n    let mut ans: Modular = 0.into();\n\n    for k in (n + 1) / 2..n {\n        let p1 = fact(k);\n        let p2 = fact(n - 1 - k);\n        let t = comb(k - 1, n - 1 - k);\n\n        let v: Modular = t * (p1 * p2) - acc;\n\n        ans += v * (k as i64);\n        acc += v;\n    }\n\n    println!(\"{}\", ans);\n}\n\n//-----\n\npub mod io {\n    use std;\n\n    pub struct Scanner<'a> {\n        iter: std::str::SplitWhitespace<'a>,\n    }\n\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a str) -> Scanner<'a> {\n            Scanner {\n                iter: s.split_whitespace(),\n            }\n        }\n\n        pub fn next<T>(&mut self) -> T\n        where\n            T: std::str::FromStr,\n            <T as std::str::FromStr>::Err: std::fmt::Debug,\n        {\n            let s = self.iter.next().unwrap();\n            s.parse::<T>().unwrap()\n        }\n    }\n\n    pub fn read_string() -> String {\n        use std::io::Read;\n\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n\n    pub fn read_line() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        s.trim_right().to_owned()\n    }\n}\n\npub mod modular {\n    const M: i64 = 1000000007;\n\n    #[derive(Debug, Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq)]\n    pub struct Modular(i64);\n\n    impl ::std::fmt::Display for Modular {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl Modular {\n        pub fn new(v: i64) -> Modular {\n            Modular(v % M)\n        }\n\n        pub fn pow(self, mut r: i64) -> Modular {\n            let mut k = self;\n            let mut ret = 1.into();\n\n            while r > 0 {\n                if r % 2 != 0 {\n                    ret = ret * k;\n                }\n                r /= 2;\n                k = k * k;\n            }\n\n            ret\n        }\n\n        // This requires M is prime\n        pub fn recip(self) -> Modular {\n            self.pow(M - 2)\n        }\n    }\n\n    use std::ops::*;\n\n    impl<T: Into<Modular>> Add<T> for Modular {\n        type Output = Modular;\n        fn add(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 + rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> AddAssign<T> for Modular {\n        fn add_assign(&mut self, rhs: T) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Sub<T> for Modular {\n        type Output = Modular;\n        fn sub(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 - rhs.into().0 + M)\n        }\n    }\n    impl<T: Into<Modular>> SubAssign<T> for Modular {\n        fn sub_assign(&mut self, rhs: T) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Mul<T> for Modular {\n        type Output = Modular;\n        fn mul(self, rhs: T) -> Self::Output {\n            Modular::new(self.0 * rhs.into().0)\n        }\n    }\n    impl<T: Into<Modular>> MulAssign<T> for Modular {\n        fn mul_assign(&mut self, rhs: T) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Into<Modular>> Div<T> for Modular {\n        type Output = Modular;\n        fn div(self, rhs: T) -> Self::Output {\n            self * rhs.into().recip()\n        }\n    }\n    impl<T: Into<Modular>> DivAssign<T> for Modular {\n        fn div_assign(&mut self, rhs: T) {\n            *self = *self / rhs;\n        }\n    }\n\n    impl Neg for Modular {\n        type Output = Modular;\n        fn neg(self) -> Self::Output {\n            Modular(0) - self\n        }\n    }\n\n    impl<T: ::std::convert::Into<i64>> ::std::convert::From<T> for Modular {\n        fn from(v: T) -> Self {\n            Modular::new(v.into())\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn gcd(a: i64, b: i64) -> i64 {\n    if b == 0 {\n        return a;\n    }\n    gcd(b, a % b)\n}\n\n#[allow(dead_code)]\nfn lcm(a: i64, b: i64) -> i64 {\n    a / gcd(a, b) * b\n}\n\n#[allow(dead_code)]\n// a x + b y = gcd(a, b)\nfn extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {\n    let mut g = a;\n    *x = 1;\n    *y = 0;\n    if b != 0 {\n        g = extgcd(b, a % b, y, x);\n        *y -= (a / b) * *x;\n    }\n    g\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 1000010;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX + 1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe { FACTORIAL[n] }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 {\n        return 0;\n    }\n    init_fact();\n    unsafe { FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD }\n}\n\nfn calc(n: usize, k: usize) -> i64 {\n    if k == 0 || 1 + k > n {\n        return 0;\n    }\n    combi(k - 1, n - 1 - k) * fact(k) % MOD * fact(n - 1 - k) % MOD\n}\nfn main() {\n    let n: usize = read();\n    let mut ans = 0;\n    if n == 2 {\n        ans = 1;\n    } else if n == 3 {\n        ans = 4;\n    } else {\n        for k in 2..n {\n            ans = (ans + k as i64 * (calc(n, k) - calc(n, k - 1) + MOD)) % MOD;\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 1_000_000_007;\nfn main() {\n    let combination = Combination::new(1000000, MOD);\n    let mut sc = Scanner::new();\n    let n: usize = sc.read();\n    if n == 2 {\n        println!(\"1\");\n        return;\n    }\n\n    let mut fact = vec![0; n + 1];\n    fact[0] = 1;\n    for i in 1..n {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n\n    let mut ans = 0;\n    let mut sum = 0;\n    for k in 2..n {\n        if k - 1 < n - 1 - k {\n            continue;\n        }\n        let mut c = combination.get(k - 1, n - 1 - k);\n        c = (c * fact[k]) % MOD;\n        c = (c * fact[n - 1 - k]) % MOD;\n        c = (c + MOD - sum) % MOD;\n        sum = (sum + c) % MOD;\n        ans = (ans + c * k) % MOD;\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Combination {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Combination {\n            fact: fact,\n            inv_fact: inv_fact,\n            modulo: modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> usize {\n        assert!(x >= y);\n        self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo\n    }\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\n#[allow(dead_code)]\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read_vec<T>(&mut self, n: usize) -> Vec<T>\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        (0..n).map(|_| self.read()).collect()\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  }
]