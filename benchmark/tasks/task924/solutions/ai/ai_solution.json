[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100\n\nint main() {\n    int N, x[MAX_N], y[MAX_N];\n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n    \n    int min_result = INT_MAX;\n    \n    for (int mask = 0; mask < (1 << N); mask++) {\n        int r_max = INT_MIN, r_min = INT_MAX;\n        int b_max = INT_MIN, b_min = INT_MAX;\n        \n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                r_max = (x[i] > r_max) ? x[i] : r_max;\n                r_min = (x[i] < r_min) ? x[i] : r_min;\n                b_max = (y[i] > b_max) ? y[i] : b_max;\n                b_min = (y[i] < b_min) ? y[i] : b_min;\n            } else {\n                r_max = (y[i] > r_max) ? y[i] : r_max;\n                r_min = (y[i] < r_min) ? y[i] : r_min;\n                b_max = (x[i] > b_max) ? x[i] : b_max;\n                b_min = (x[i] < b_min) ? x[i] : b_min;\n            }\n        }\n        \n        int result = (r_max - r_min) * (b_max - b_min);\n        min_result = (result < min_result) ? result : min_result;\n    }\n    \n    printf(\"%d\\n\", min_result);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int *x = malloc(N * sizeof(int));\n    int *y = malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n\n    int *all = malloc(2 * N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        all[2 * i] = x[i];\n        all[2 * i + 1] = y[i];\n    }\n    qsort(all, 2 * N, sizeof(int), compare);\n\n    int total_min = all[0];\n    int total_max = all[2 * N - 1];\n\n    int min_diff = INT_MAX;\n\n    // Case 1: All red or all blue in one color\n    int R_diff = total_max - total_min;\n    int B_diff = 0;\n    min_diff = R_diff * B_diff;\n\n    // Case 2: Try to split into two groups\n    int *min_candidates = malloc(4 * sizeof(int));\n    int *max_candidates = malloc(4 * sizeof(int));\n    int candidate_count = 0;\n\n    for (int i = 0; i < 4 && i < 2 * N; i++) {\n        min_candidates[candidate_count] = all[i];\n        max_candidates[candidate_count] = all[2 * N - 1 - i];\n        candidate_count++;\n    }\n\n    for (int i = 0; i < candidate_count; i++) {\n        for (int j = 0; j < candidate_count; j++) {\n            int R_min = min_candidates[i];\n            int R_max = max_candidates[j];\n            if (R_min > R_max) continue;\n\n            int B_min = INT_MAX;\n            int B_max = INT_MIN;\n            int valid = 1;\n            for (int k = 0; k < N; k++) {\n                int a = x[k];\n                int b = y[k];\n                if ((a >= R_min && a <= R_max) || (b >= R_min && b <= R_max)) {\n                    int other = (a >= R_min && a <= R_max) ? b : a;\n                    B_min = min(B_min, other);\n                    B_max = max(B_max, other);\n                } else {\n                    valid = 0;\n                    break;\n                }\n            }\n            if (valid) {\n                int current_diff = (R_max - R_min) * (B_max - B_min);\n                if (current_diff < min_diff) {\n                    min_diff = current_diff;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", min_diff);\n\n    free(x);\n    free(y);\n    free(all);\n    free(min_candidates);\n    free(max_candidates);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:21:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> bags(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> bags[i].first >> bags[i].second;\n    }\n\n    long long min_product = LLONG_MAX;\n\n    // We need to consider different strategies to minimize the product\n    // Strategy 1: All x_i are in one color, all y_i in the other\n    vector<int> all_numbers;\n    for (auto &bag : bags) {\n        all_numbers.push_back(bag.first);\n        all_numbers.push_back(bag.second);\n    }\n    sort(all_numbers.begin(), all_numbers.end());\n    int total_min = all_numbers.front();\n    int total_max = all_numbers.back();\n    // Case 1: All x_i are red, y_i are blue\n    vector<int> red, blue;\n    for (auto &bag : bags) {\n        red.push_back(bag.first);\n        blue.push_back(bag.second);\n    }\n    sort(red.begin(), red.end());\n    sort(blue.begin(), blue.end());\n    int R_max = red.back();\n    int R_min = red.front();\n    int B_max = blue.back();\n    int B_min = blue.front();\n    long long product = (long long)(R_max - R_min) * (B_max - B_min);\n    min_product = min(min_product, product);\n\n    // Case 2: All y_i are red, x_i are blue\n    red.clear();\n    blue.clear();\n    for (auto &bag : bags) {\n        red.push_back(bag.second);\n        blue.push_back(bag.first);\n    }\n    sort(red.begin(), red.end());\n    sort(blue.begin(), blue.end());\n    R_max = red.back();\n    R_min = red.front();\n    B_max = blue.back();\n    B_min = blue.front();\n    product = (long long)(R_max - R_min) * (B_max - B_min);\n    min_product = min(min_product, product);\n\n    // Strategy 2: Try to have one color's range as small as possible by selecting min/max from each bag\n    // We need to choose one element from each bag to be in red, the other in blue, to minimize the product\n    // To minimize the product, one of the ranges (R or B) should be as small as possible\n    // So, we can try to make one color consist of the smallest or largest elements possible\n\n    // Try to make red have the smallest possible range (i.e., all red are as close as possible)\n    // So, we choose for each bag the element that is closest to the median or some central value\n    // But this is hard to optimize, so we can try all possible candidates for R_min and R_max\n\n    // Generate all possible candidates for R_min and R_max\n    vector<int> candidates;\n    for (auto &bag : bags) {\n        candidates.push_back(bag.first);\n        candidates.push_back(bag.second);\n    }\n    sort(candidates.begin(), candidates.end());\n\n    // We can limit the candidates to the first and last few to reduce computation\n    int candidate_limit = min(200, (int)candidates.size());\n    for (int i = 0; i < candidate_limit; ++i) {\n        int R_min_candidate = candidates[i];\n        for (int j = max(i, (int)candidates.size() - candidate_limit); j < candidates.size(); ++j) {\n            int R_max_candidate = candidates[j];\n            if (R_min_candidate > R_max_candidate) continue;\n\n            // Now, for each bag, choose the element that is within [R_min_candidate, R_max_candidate]\n            // If both are within, choose the one that minimizes B's range\n            // If only one is within, choose that one\n            // If none are within, this R_min_candidate and R_max_candidate is invalid\n            bool valid = true;\n            vector<int> blue_numbers;\n            for (auto &bag : bags) {\n                bool first_in = (bag.first >= R_min_candidate && bag.first <= R_max_candidate);\n                bool second_in = (bag.second >= R_min_candidate && bag.second <= R_max_candidate);\n                if (!first_in && !second_in) {\n                    valid = false;\n                    break;\n                }\n                if (first_in && second_in) {\n                    // Choose the one that doesn't expand the blue range\n                    // But since we don't know yet, we can choose either, but for simplicity, choose the smaller one\n                    // To minimize B_max, choose the larger one; to minimize B_min, choose the smaller one\n                    // This is a heuristic; may not be optimal\n                    blue_numbers.push_back(bag.first >= R_min_candidate && bag.first <= R_max_candidate ? bag.second : bag.first);\n                } else if (first_in) {\n                    blue_numbers.push_back(bag.second);\n                } else {\n                    blue_numbers.push_back(bag.first);\n                }\n            }\n            if (!valid) continue;\n\n            sort(blue_numbers.begin(), blue_numbers.end());\n            int B_min_current = blue_numbers.front();\n            int B_max_current = blue_numbers.back();\n            product = (long long)(R_max_candidate - R_min_candidate) * (B_max_current - B_min_current);\n            min_product = min(min_product, product);\n        }\n    }\n\n    cout << min_product << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:22:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[][] bags = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            bags[i][0] = sc.nextInt();\n            bags[i][1] = sc.nextInt();\n        }\n\n        long minProduct = Long.MAX_VALUE;\n\n        // Generate all possible combinations of choosing x or y for red and blue\n        for (int mask = 0; mask < (1 << N); mask++) {\n            List<Integer> red = new ArrayList<>();\n            List<Integer> blue = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    red.add(bags[i][0]);\n                    blue.add(bags[i][1]);\n                } else {\n                    red.add(bags[i][1]);\n                    blue.add(bags[i][0]);\n                }\n            }\n            Collections.sort(red);\n            Collections.sort(blue);\n            int rDiff = red.get(red.size() - 1) - red.get(0);\n            int bDiff = blue.get(blue.size() - 1) - blue.get(0);\n            long product = (long) rDiff * bDiff;\n            if (product < minProduct) {\n                minProduct = product;\n            }\n        }\n\n        System.out.println(minProduct);\n    }\n}",
    "timestamp": "2025-08-05 23:22:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int minimizeSpread(int N, int[][] bags) {\n        int result = Integer.MAX_VALUE;\n        \n        for (int mask = 0; mask < (1 << N); mask++) {\n            List<Integer> redBalls = new ArrayList<>();\n            List<Integer> blueBalls = new ArrayList<>();\n            \n            for (int i = 0; i < N; i++) {\n                if ((mask & (1 << i)) > 0) {\n                    redBalls.add(bags[i][0]);\n                    blueBalls.add(bags[i][1]);\n                } else {\n                    redBalls.add(bags[i][1]);\n                    blueBalls.add(bags[i][0]);\n                }\n            }\n            \n            int rMin = Collections.min(redBalls);\n            int rMax = Collections.max(redBalls);\n            int bMin = Collections.min(blueBalls);\n            int bMax = Collections.max(blueBalls);\n            \n            result = Math.min(result, (rMax - rMin) * (bMax - bMin));\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] bags = new int[N][2];\n        \n        for (int i = 0; i < N; i++) {\n            bags[i][0] = scanner.nextInt();\n            bags[i][1] = scanner.nextInt();\n        }\n        \n        System.out.println(minimizeSpread(N, bags));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:23:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<pair<int, int>> bags(N);\n    for (int i = 0; i < N; i++) {\n        cin >> bags[i].first >> bags[i].second;\n    }\n    \n    int minResult = INT_MAX;\n    \n    for (int mask = 0; mask < (1 << N); mask++) {\n        int Rmax = INT_MIN, Rmin = INT_MAX;\n        int Bmax = INT_MIN, Bmin = INT_MAX;\n        \n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                Rmax = max(Rmax, bags[i].first);\n                Rmin = min(Rmin, bags[i].first);\n                Bmax = max(Bmax, bags[i].second);\n                Bmin = min(Bmin, bags[i].second);\n            } else {\n                Rmax = max(Rmax, bags[i].second);\n                Rmin = min(Rmin, bags[i].second);\n                Bmax = max(Bmax, bags[i].first);\n                Bmin = min(Bmin, bags[i].first);\n            }\n        }\n        \n        minResult = min(minResult, (Rmax - Rmin) * (Bmax - Bmin));\n    }\n    \n    cout << minResult << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_product_difference(N, bags):\n    red_balls = []\n    blue_balls = []\n    \n    for x, y in bags:\n        if x < y:\n            red_balls.append(x)\n            blue_balls.append(y)\n        else:\n            red_balls.append(y)\n            blue_balls.append(x)\n    \n    red_balls.sort()\n    blue_balls.sort()\n    \n    R_max = red_balls[-1]\n    R_min = red_balls[0]\n    B_max = blue_balls[-1]\n    B_min = blue_balls[0]\n    \n    return (R_max - R_min) * (B_max - B_min)\n\n# Example usage:\n# N = 3\n# bags = [(1, 3), (4, 2), (6, 5)]\n# print(min_product_difference(N, bags))",
    "timestamp": "2025-08-13 15:00:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class MinimizeColorDifference {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] balls = new int[N][2];\n        \n        for (int i = 0; i < N; i++) {\n            balls[i][0] = scanner.nextInt();\n            balls[i][1] = scanner.nextInt();\n        }\n        \n        int[] allBalls = new int[2 * N];\n        \n        for (int i = 0; i < N; i++) {\n            allBalls[2 * i] = balls[i][0];\n            allBalls[2 * i + 1] = balls[i][1];\n        }\n        \n        Arrays.sort(allBalls);\n        \n        int minDifference = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < N; i++) {\n            int Rmin = allBalls[i];\n            int Rmax = allBalls[i + N - 1];\n            int Bmin = allBalls[0];\n            int Bmax = allBalls[N + i];\n            int currentDifference = (Rmax - Rmin) * (Bmax - Bmin);\n            minDifference = Math.min(minDifference, currentDifference);\n        }\n        \n        System.out.println(minDifference);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 15:00:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\ntypedef struct {\n    int red;\n    int blue;\n} Ball;\n\nint compare(const void *a, const void *b) {\n    Ball *ballA = (Ball *)a;\n    Ball *ballB = (Ball *)b;\n    return (ballB->red + ballB->blue) - (ballA->red + ballA->blue);\n}\n\nint min_difference_product(int n, int balls[][2]) {\n    Ball sortedBalls[n];\n    for (int i = 0; i < n; i++) {\n        int x = balls[i][0];\n        int y = balls[i][1];\n        sortedBalls[i].red = x > y ? x : y;  // Maximum value assumes up to paint red\n        sortedBalls[i].blue = x > y ? y : x; // Minimum value assumes up to paint blue\n    }\n    qsort(sortedBalls, n, sizeof(Ball), compare);\n    \n    int minValue = INT_MAX;\n    \n    for (int split = 0; split <= n; split++) {\n        int R_max = INT_MIN, R_min = INT_MAX;\n        int B_max = INT_MIN, B_min = INT_MAX;\n        \n        for (int i = 0; i < n; i++) {\n            if (i < split) {\n                if (sortedBalls[i].red > R_max) R_max = sortedBalls[i].red;\n                if (sortedBalls[i].red < R_min) R_min = sortedBalls[i].red;\n            } else {\n                if (sortedBalls[i].blue > B_max) B_max = sortedBalls[i].blue;\n                if (sortedBalls[i].blue < B_min) B_min = sortedBalls[i].blue;\n            }\n        }\n        \n        int R_range = R_max - R_min;\n        int B_range = B_max - B_min;\n        \n        int currentValue = R_range * B_range;\n        if (currentValue < minValue) minValue = currentValue;\n    }\n    \n    return minValue;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int balls[N][2];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &balls[i][0], &balls[i][1]);\n    }\n    int result = min_difference_product(N, balls);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:00:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> X(N), Y(N), red, blue;\n\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i];\n        red.push_back(X[i]);\n        blue.push_back(Y[i]);\n    }\n\n    sort(red.begin(), red.end());\n    sort(blue.begin(), blue.end());\n\n    int min_value = INT_MAX;\n\n    for (int i = 0; i <= N; i++) {\n        vector<int> reds, blues;\n        if (i > 0) {\n            for (int j = 0; j < i; j++) {\n                reds.push_back(Y[j]);\n                blues.push_back(X[j]);\n            }\n        }\n        for (int j = i; j < N; j++) {\n            reds.push_back(X[j]);\n            blues.push_back(Y[j]);\n        }\n\n        int rmin = *min_element(reds.begin(), reds.end());\n        int rmax = *max_element(reds.begin(), reds.end());\n        int bmin = *min_element(blues.begin(), blues.end());\n        int bmax = *max_element(blues.begin(), blues.end());\n\n        min_value = min(min_value, (rmax - rmin) * (bmax - bmin));\n    }\n\n    cout << min_value << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:00:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, balls):\n    min_product = float('inf')\n    \n    for mask in range(1 << N):\n        red_max = float('-inf')\n        red_min = float('inf')\n        blue_max = float('-inf')\n        blue_min = float('inf')\n        \n        for i in range(N):\n            if mask & (1 << i):\n                red_max = max(red_max, balls[i][0])\n                red_min = min(red_min, balls[i][0])\n                blue_max = max(blue_max, balls[i][1])\n                blue_min = min(blue_min, balls[i][1])\n            else:\n                red_max = max(red_max, balls[i][1])\n                red_min = min(red_min, balls[i][1])\n                blue_max = max(blue_max, balls[i][0])\n                blue_min = min(blue_min, balls[i][0])\n        \n        min_product = min(min_product, (red_max - red_min) * (blue_max - blue_min))\n    \n    return min_product\n\ndef main():\n    N = int(input())\n    balls = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        balls.append((x, y))\n    \n    print(solve(N, balls))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 15:00:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    bags = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        if x > y:\n            x, y = y, x\n        bags.append((x, y))\n    \n    # Sort bags by the smaller number in each bag\n    bags.sort()\n    \n    # Precompute min and max for all possible R and B selections\n    # Case 1: All x_i are in R, all y_i are in B\n    R = [x for x, y in bags]\n    B = [y for x, y in bags]\n    R_max = max(R)\n    R_min = min(R)\n    B_max = max(B)\n    B_min = min(B)\n    res = (R_max - R_min) * (B_max - B_min)\n    \n    # Case 2: Some y_i are in R, some x_i are in B. Need to find the optimal swap.\n    # We need to consider swapping some pairs to minimize the product.\n    # The optimal strategy involves sorting all possible candidates and trying the top candidates.\n    all_values = []\n    for x, y in bags:\n        all_values.append(x)\n        all_values.append(y)\n    all_values.sort()\n    \n    # The minimal range is all_values[-k] - all_values[0] for some k.\n    # We need to select N elements for R and N for B.\n    # The minimal product is when the ranges are as tight as possible.\n    min_product = float('inf')\n    total = 2 * N\n    # We can try selecting N consecutive elements in the sorted list.\n    for i in range(len(all_values) - N + 1):\n        current_min = all_values[i]\n        current_max = all_values[i + N - 1]\n        # The remaining elements would be the other color.\n        other_min = min(all_values[0], all_values[i + N] if i + N < total else all_values[-1])\n        other_max = max(all_values[-1], all_values[i - 1] if i > 0 else all_values[0])\n        # But this might not cover all cases. Need to ensure that for each bag, one is in R and one in B.\n        # So the above approach might not work. Need a better way.\n    \n    # Alternative approach: find the minimal product by considering the best possible R and B ranges.\n    # We need to find the minimal (Rmax - Rmin)*(Bmax - Bmin) where for each bag, one is in R and one in B.\n    # The optimal solution involves selecting Rmin and Rmax such that the corresponding Bmin and Bmax minimize the product.\n    \n    # Collect all possible candidates for R and B.\n    # We can try to fix the minimal and maximal elements in R and compute the corresponding B.\n    # But this is O(N^2) which might be too slow for N=2e5.\n    # Hence, we need a smarter approach.\n    \n    # Another observation: the optimal solution is either:\n    # 1. All x_i are in R and all y_i are in B (already computed as 'res')\n    # 2. The R set contains some y_i and B set contains some x_i, and the optimal is achieved by swapping some pairs to minimize the product.\n    # The minimal product in case 2 is when the R and B sets are as tight as possible.\n    # So we can try to find the minimal possible (max_R - min_R) and (max_B - min_B) by considering the global min and max.\n    \n    global_min = min(all_values)\n    global_max = max(all_values)\n    \n    # The minimal product is when one of the colors has max - min as small as possible.\n    # So we can try to make R's range as small as possible, and B's range will be constrained by the remaining elements.\n    \n    # To minimize (Rmax - Rmin), we can try to select N elements with the smallest range.\n    # But we need to ensure that for each bag, one element is in R and one in B.\n    # So we can sort all elements and try to find N elements (one from each bag) with minimal range.\n    \n    # Now, we need to find a set S of N elements (one from each bag) such that max(S) - min(S) is minimized.\n    # This is similar to the problem of selecting one element from each bag to minimize the range.\n    \n    # To find such S, we can use a sliding window approach on the sorted list of all elements, keeping track of which bags are covered in the window.\n    \n    # First, assign an index to each bag for tracking.\n    elements = []\n    for i in range(N):\n        x, y = bags[i]\n        elements.append((x, i))\n        elements.append((y, i))\n    elements.sort()\n    \n    from collections import defaultdict\n    freq = defaultdict(int)\n    left = 0\n    cnt = 0\n    min_range = float('inf')\n    \n    # Sliding window to find the minimal range covering at least one element from each bag.\n    for right in range(len(elements)):\n        val, bag_idx = elements[right]\n        if freq[bag_idx] == 0:\n            cnt += 1\n        freq[bag_idx] += 1\n        \n        while cnt == N:\n            current_range = elements[right][0] - elements[left][0]\n            if current_range < min_range:\n                min_range = current_range\n            left_val, left_bag = elements[left]\n            freq[left_bag] -= 1\n            if freq[left_bag] == 0:\n                cnt -= 1\n            left += 1\n    \n    if min_range != float('inf'):\n        # The other color's range is global_max - global_min - but this is not accurate.\n        # The other color's min and max are the remaining elements.\n        # So the other color's min is the min of the elements not in S, and max is the max of the elements not in S.\n        # But since S is one element per bag, the other color is the other element in each bag.\n        # So the other color's min is the min of the complementary elements.\n        # However, during the sliding window, we don't track the complementary elements.\n        # Hence, this approach might not directly give us the other color's min and max.\n        # So we need another way.\n        \n        # Alternative idea: the minimal product is min_range * (other_max - other_min)\n        # But other_max and other_min are the max and min of the remaining elements (one per bag not in S).\n        # To find the minimal product, we need to minimize min_range * (other_max - other_min)\n        # So we need to find S such that min_range is minimized and (other_max - other_min) is as small as possible.\n        # This is complex, so perhaps it's better to consider that the minimal product is either:\n        # 1. The initial case (all x in R, all y in B)\n        # 2. The case where one color's range is min_range, and the other is determined by the remaining elements.\n        \n        # So we can compute the other color's min and max as follows:\n        # For the elements not in S (i.e., the other elements in each bag), compute their min and max.\n        # But since S is one element per bag, the other elements are the complementary ones.\n        # So for each bag, if we picked x in S, the other is y, and vice versa.\n        \n        # However, during the sliding window, we don't track which element is picked from each bag.\n        # Hence, we need to find, for the minimal range window, the corresponding other elements.\n        \n        # This is getting complicated, so perhaps it's better to accept that the minimal product is the minimum between:\n        # 1. The initial case (all x in R, all y in B)\n        # 2. The case where one color's range is as small as possible (min_range), and the other is global_max - global_min (which is an upper bound)\n        \n        # But this might not be accurate, so we can try to compute the other color's range more accurately.\n        \n        # Recompute the minimal window and track the other elements.\n        # Re-initialize\n        freq = defaultdict(int)\n        left = 0\n        cnt = 0\n        min_range = float('inf')\n        best_left = 0\n        best_right = 0\n        \n        for right in range(len(elements)):\n            val, bag_idx = elements[right]\n            if freq[bag_idx] == 0:\n                cnt += 1\n            freq[bag_idx] += 1\n            \n            while cnt == N:\n                current_range = elements[right][0] - elements[left][0]\n                if current_range < min_range:\n                    min_range = current_range\n                    best_left = left\n                    best_right = right\n                left_val, left_bag = elements[left]\n                freq[left_bag] -= 1\n                if freq[left_bag] == 0:\n                    cnt -= 1\n                left += 1\n        \n        # Now, collect the elements in the best window\n        window_elements = set()\n        for i in range(best_left, best_right + 1):\n            val, bag_idx = elements[i]\n            window_elements.add(bag_idx)\n        \n        # The other color's elements are the complementary ones\n        other_min = float('inf')\n        other_max = -float('inf')\n        for i in range(N):\n            x, y = bags[i]\n            if i in window_elements:\n                # The element in the window is either x or y\n                # The other is the complementary\n                for idx in range(best_left, best_right + 1):\n                    val, bag_idx = elements[idx]\n                    if bag_idx == i:\n                        if val == x:\n                            other_val = y\n                        else:\n                            other_val = x\n                        if other_val < other_min:\n                            other_min = other_val\n                        if other_val > other_max:\n                            other_max = other_val\n                        break\n            else:\n                # This bag is not in the window, which shouldn't happen since the window covers all bags\n                pass\n        \n        product = min_range * (other_max - other_min)\n        res = min(res, product)\n    \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 15:01:53"
  }
]