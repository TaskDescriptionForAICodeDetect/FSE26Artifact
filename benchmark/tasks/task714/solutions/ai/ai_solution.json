[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n#define MAX_DEGREE 20\n\nint graph[MAX_N][MAX_DEGREE];\nint degree[MAX_N];\nint color[MAX_N][MAX_DEGREE];\nint used_colors[MAX_DEGREE];\n\nvoid solve(int N, int M, int edges[][2]) {\n    // Initialize graph\n    memset(degree, 0, sizeof(degree));\n    memset(color, 0, sizeof(color));\n\n    // Build adjacency list\n    for (int i = 0; i < M; i++) {\n        int u = edges[i][0], v = edges[i][1];\n        graph[u][degree[u]++] = v;\n        graph[v][degree[v]++] = u;\n    }\n\n    // Color edges\n    int max_color = 0;\n    for (int u = 1; u <= N; u++) {\n        // Reset used colors\n        memset(used_colors, 0, sizeof(used_colors));\n\n        // Color each adjacent edge with unique color\n        for (int j = 0; j < degree[u]; j++) {\n            int v = graph[u][j];\n            \n            // Find first unused color\n            int c = 1;\n            while (used_colors[c]) c++;\n            \n            color[u][j] = c;\n            used_colors[c] = 1;\n            max_color = (c > max_color) ? c : max_color;\n\n            // Find corresponding edge in neighbor's adjacency list\n            for (int k = 0; k < degree[v]; k++) {\n                if (graph[v][k] == u) {\n                    color[v][k] = c;\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_color);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int edges[MAX_N][2];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &edges[i][0], &edges[i][1]);\n    }\n\n    solve(N, M, edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int to;\n    int idx;\n} Edge;\n\nEdge **adj;\nint *color;\nint max_degree = 0;\n\nvoid dfs(int u, int parent, int parent_color) {\n    int current_color = 1;\n    for (int i = 0; adj[u][i].to != 0; ++i) {\n        int v = adj[u][i].to;\n        int idx = adj[u][i].idx;\n        if (v == parent) continue;\n        if (current_color == parent_color) current_color++;\n        color[idx] = current_color++;\n        dfs(v, u, color[idx]);\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    adj = (Edge **)malloc((N + 1) * sizeof(Edge *));\n    for (int i = 1; i <= N; ++i) {\n        adj[i] = (Edge *)malloc((N + 1) * sizeof(Edge));\n        for (int j = 0; j <= N; ++j) {\n            adj[i][j].to = 0;\n        }\n    }\n    \n    int *degree = (int *)calloc(N + 1, sizeof(int));\n    color = (int *)malloc(N * sizeof(int));\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        adj[a][degree[a]].to = b;\n        adj[a][degree[a]].idx = i;\n        degree[a]++;\n        adj[b][degree[b]].to = a;\n        adj[b][degree[b]].idx = i;\n        degree[b]++;\n        if (degree[a] > max_degree) max_degree = degree[a];\n        if (degree[b] > max_degree) max_degree = degree[b];\n    }\n    \n    dfs(1, -1, -1);\n    \n    printf(\"%d\\n\", max_degree);\n    for (int i = 0; i < N - 1; ++i) {\n        printf(\"%d\\n\", color[i]);\n    }\n    \n    for (int i = 1; i <= N; ++i) {\n        free(adj[i]);\n    }\n    free(adj);\n    free(degree);\n    free(color);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<pair<int, int>>> adj(N + 1);\n    vector<int> color(N - 1);\n    int max_degree = 0;\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].emplace_back(b, i);\n        adj[b].emplace_back(a, i);\n        max_degree = max(max_degree, (int)max(adj[a].size(), adj[b].size()));\n    }\n\n    vector<int> used(N + 1, 0);\n    vector<bool> visited(N + 1, false);\n    visited[1] = true;\n    vector<int> stack = {1};\n\n    while (!stack.empty()) {\n        int u = stack.back();\n        stack.pop_back();\n        int c = 1;\n        for (auto [v, idx] : adj[u]) {\n            if (visited[v]) continue;\n            if (c == used[u]) ++c;\n            color[idx] = c;\n            used[v] = c;\n            ++c;\n            visited[v] = true;\n            stack.push_back(v);\n        }\n    }\n\n    cout << max_degree << endl;\n    for (int i = 0; i < N - 1; ++i) {\n        cout << color[i] << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TreeEdgeColoring {\n    static class Edge {\n        int to, color;\n        Edge(int to, int color) {\n            this.to = to;\n            this.color = color;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        List<List<Edge>> tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n\n        int[] degrees = new int[N + 1];\n        int[][] edges = new int[N - 1][2];\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            edges[i][0] = a;\n            edges[i][1] = b;\n            degrees[a]++;\n            degrees[b]++;\n        }\n\n        int maxDegree = 0;\n        for (int i = 1; i <= N; i++) {\n            maxDegree = Math.max(maxDegree, degrees[i]);\n        }\n\n        System.out.println(maxDegree);\n\n        // BFS to color edges\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(1);\n        boolean[] visited = new boolean[N + 1];\n        visited[1] = true;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            int color = 1;\n            Set<Integer> usedColors = new HashSet<>();\n            for (Edge e : tree.get(u)) {\n                usedColors.add(e.color);\n            }\n\n            for (Edge e : tree.get(u)) {\n                if (e.color == 0) {\n                    while (usedColors.contains(color)) {\n                        color++;\n                    }\n                    e.color = color;\n                    for (Edge rev : tree.get(e.to)) {\n                        if (rev.to == u) {\n                            rev.color = color;\n                            break;\n                        }\n                    }\n                    usedColors.add(color);\n                    color++;\n                }\n                if (!visited[e.to]) {\n                    visited[e.to] = true;\n                    queue.add(e.to);\n                }\n            }\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            for (Edge e : tree.get(a)) {\n                if (e.to == b) {\n                    System.out.println(e.color);\n                    break;\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:41:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class EdgeColoring {\n    public static int[] colorEdges(int N, int[][] edges) {\n        // Create adjacency list representation of the graph\n        List<List<Integer>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i < N + 1; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Build adjacency list\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        \n        // Track edge colors\n        int[] edgeColors = new int[edges.length];\n        Arrays.fill(edgeColors, -1);\n        \n        // Track used colors for each vertex\n        Set<Integer>[] usedColors = new HashSet[N + 1];\n        for (int i = 1; i <= N; i++) {\n            usedColors[i] = new HashSet<>();\n        }\n        \n        // Color each edge\n        for (int i = 0; i < edges.length; i++) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            \n            // Find the smallest color not used by adjacent edges\n            int color = 0;\n            while (usedColors[u].contains(color) || usedColors[v].contains(color)) {\n                color++;\n            }\n            \n            // Assign color to edge\n            edgeColors[i] = color;\n            usedColors[u].add(color);\n            usedColors[v].add(color);\n        }\n        \n        return edgeColors;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int N = 4;\n        int[][] edges = {{1, 2}, {1, 3}, {2, 4}, {3, 4}};\n        int[] colors = colorEdges(N, edges);\n        \n        for (int i = 0; i < colors.length; i++) {\n            System.out.println(\"Edge \" + edges[i][0] + \"-\" + edges[i][1] + \": Color \" + colors[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:41:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nclass TreeColoring {\nprivate:\n    int N;\n    vector<vector<int>> graph;\n    vector<int> edgeColors;\n\npublic:\n    TreeColoring(int vertices) : N(vertices), graph(N+1), edgeColors(N) {}\n\n    void addEdge(int u, int v) {\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    int minimumEdgeColoring() {\n        int maxDegree = 0;\n        for (int i = 1; i <= N; i++) {\n            maxDegree = max(maxDegree, (int)graph[i].size());\n        }\n        return maxDegree;\n    }\n\n    void colorEdges() {\n        int colors = minimumEdgeColoring();\n        vector<bool> usedColors(colors + 1, false);\n\n        for (int v = 1; v <= N; v++) {\n            fill(usedColors.begin(), usedColors.end(), false);\n            \n            for (int neighbor : graph[v]) {\n                int colorIndex = lower_bound(graph[v].begin(), graph[v].end(), neighbor) - graph[v].begin();\n                if (edgeColors[colorIndex] != 0) {\n                    usedColors[edgeColors[colorIndex]] = true;\n                }\n            }\n\n            for (int c = 1; c <= colors; c++) {\n                if (!usedColors[c]) {\n                    for (int& neighbor : graph[v]) {\n                        int colorIndex = lower_bound(graph[v].begin(), graph[v].end(), neighbor) - graph[v].begin();\n                        if (edgeColors[colorIndex] == 0) {\n                            edgeColors[colorIndex] = c;\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    void printEdgeColors() {\n        for (int color : edgeColors) {\n            cout << color << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    TreeColoring treeColoring(N);\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        treeColoring.addEdge(u, v);\n    }\n\n    treeColoring.colorEdges();\n    treeColoring.printEdgeColors();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef color_tree_edges(N, edges):\n    def dfs(node, parent_color):\n        next_color = 1\n        for neighbour, idx in adj[node]:\n            if not colors[idx]:\n                if next_color == parent_color:\n                    next_color += 1\n                colors[idx] = next_color\n                dfs(neighbour, next_color)\n                next_color += 1\n\n    adj = defaultdict(list)\n    for idx, (a, b) in enumerate(edges):\n        adj[a].append((b, idx))\n        adj[b].append((a, idx))\n\n    colors = [0] * (N - 1)\n    dfs(1, 0)\n\n    return colors\n\n# Example usage:\nN = 5\nedges = [(1, 2), (1, 3), (2, 4), (2, 5)]\nprint(color_tree_edges(N, edges))",
    "timestamp": "2025-08-13 12:06:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeColoring {\n    // Edge class representing an edge between two nodes\n    static class Edge {\n        int from, to, color;\n        Edge(int from, int to) {\n            this.from = from;\n            this.to = to;\n            this.color = -1; // uncolored\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        ArrayList<Edge>[] tree = new ArrayList[N + 1];\n        \n        // Initialize adjacency list\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        \n        // Read edges and populate adjacency list\n        Edge[] edges = new Edge[N - 1];\n        for (int i = 0; i < N - 1; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            Edge edge = new Edge(a, b);\n            edges[i] = edge;\n            tree[a].add(edge);\n            tree[b].add(edge);\n        }\n        \n        // Find maximum degree\n        int maxDegree = 0;\n        for (int i = 1; i <= N; i++) {\n            maxDegree = Math.max(maxDegree, tree[i].size());\n        }\n        \n        // Paint edges (color the tree with maxDegree colors)\n        paintEdges(tree, edges, maxDegree);\n        \n        // Output the colors\n        for (Edge edge : edges) {\n            System.out.println(edge.color);\n        }\n        \n        scanner.close();\n    }\n\n    static void paintEdges(ArrayList<Edge>[] tree, Edge[] edges, int maxDegree) {\n        boolean[] usedColors = new boolean[maxDegree + 1];\n\n        for (int i = 1; i < tree.length; i++) {\n            Arrays.fill(usedColors, false);\n            for (Edge edge : tree[i]) {\n                if (edge.color != -1) { // mark colors already used by other vertices\n                    usedColors[edge.color] = true;\n                }\n            }\n\n            // Assign a color to each uncolored edge incident to vertex i\n            int color = 1;\n            for (Edge edge : tree[i]) {\n                if (edge.color == -1) {\n                    while (usedColors[color]) {\n                        color++;\n                    }\n                    edge.color = color;\n                    usedColors[color] = true;\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:06:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int v, idx;\n} Edge;\n\nEdge edges[2 * MAX_N];\nint head[MAX_N + 1], next[MAX_N];\nint color[MAX_N];\nint maxDegree = 0;\n\nvoid addEdge(int u, int v, int idx) {\n    static int edgeIndex = 0;\n    edges[edgeIndex] = (Edge){v, idx};\n    next[edgeIndex] = head[u];\n    head[u] = edgeIndex++;\n}\n\nvoid dfs(int u, int parent) {\n    int c = 0;\n    for (int k = head[u]; k != -1; k = next[k]) {\n        int v = edges[k].v;\n        int idx = edges[k].idx;\n\n        if (v == parent) continue;\n\n        c++;\n        if (c == color[parent]) c++; // ensure a different color from parent\n\n        color[idx] = c;\n        dfs(v, u);\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    memset(head, -1, sizeof(head));\n    memset(color, 0, sizeof(color));\n\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n\n        addEdge(a, b, i);\n        addEdge(b, a, i);\n\n        // Find the maximum degree while reading input\n        int degreeA = 0, degreeB = 0;\n        for (int k = head[a]; k != -1; k = next[k]) degreeA++;\n        for (int k = head[b]; k != -1; k = next[k]) degreeB++;\n        \n        if (degreeA > maxDegree) maxDegree = degreeA;\n        if (degreeB > maxDegree) maxDegree = degreeB;\n    }\n\n    // DFS to assign colors, starting from vertex 1 (or any node)\n    dfs(1, 0);\n    \n    printf(\"%d\\n\", maxDegree);\n    for (int i = 0; i < N - 1; i++) {\n        printf(\"%d\\n\", color[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:06:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function paintTreeEdges(n, edges) {\n    const result = Array(edges.length).fill(0);\n    \n    const adj = Array.from({ length: n + 1 }, () => []);\n    edges.forEach(([a, b], index) => {\n        adj[a].push([b, index]);\n        adj[b].push([a, index]);\n    });\n\n    const maxDegree = Math.max(...adj.map(neighbors => neighbors.length));\n    const maxColors = maxDegree;\n\n    function dfs(node, parent, usedColors) {\n        let color = 1;\n        for (const [neighbor, edgeIndex] of adj[node]) {\n            if (neighbor === parent) continue;\n            while (color === usedColors.get(neighbor) || color === usedColors.get(node)) {\n                color++;\n            }\n            result[edgeIndex] = color;\n            usedColors.set(node, color);\n            dfs(neighbor, node, usedColors);\n        }\n    }\n\n    dfs(1, 0, new Map());\n    return result;\n}\n\nconst n = 5; \nconst edges = [\n    [1, 2],\n    [1, 3],\n    [2, 4],\n    [2, 5]\n];\n\nconsole.log(paintTreeEdges(n, edges));",
    "timestamp": "2025-08-13 12:07:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef minimum_edge_coloring(N, edges):\n    # Create adjacency list representation of the graph\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Track edge colors\n    edge_colors = {}\n    \n    # Track color usage for each vertex\n    vertex_used_colors = defaultdict(set)\n    \n    def color_edge(u, v):\n        # Find the smallest available color for this edge\n        used_colors = vertex_used_colors[u] | vertex_used_colors[v]\n        color = 1\n        while color in used_colors:\n            color += 1\n        \n        # Color the edge\n        edge_colors[(u, v)] = color\n        edge_colors[(v, u)] = color\n        vertex_used_colors[u].add(color)\n        vertex_used_colors[v].add(color)\n        return color\n    \n    # Color each edge\n    for u, v in edges:\n        if (u, v) not in edge_colors:\n            color_edge(u, v)\n    \n    # Return maximum color used and the coloring\n    max_color = max(edge_colors.values()) if edge_colors else 0\n    return max_color, edge_colors\n\n# Example usage\nN = 5\nedges = [(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)]\nmax_colors, coloring = minimum_edge_coloring(N, edges)\nprint(f\"Minimum colors needed: {max_colors}\")\nprint(\"Edge coloring:\", coloring)",
    "timestamp": "2025-08-13 12:07:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minEdgeColoring(N, edges) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    const degree = new Array(N + 1).fill(0);\n\n    for (const [a, b] of edges) {\n        graph[a].push(b);\n        graph[b].push(a);\n        degree[a]++;\n        degree[b]++;\n    }\n\n    const maxDegree = Math.max(...degree.slice(1));\n    const colors = new Array(edges.length).fill(0);\n    const usedColors = Array.from({ length: N + 1 }, () => new Set());\n\n    for (let i = 0; i < edges.length; i++) {\n        const [a, b] = edges[i];\n        let color = 1;\n        while (usedColors[a].has(color) || usedColors[b].has(color)) {\n            color++;\n        }\n        colors[i] = color;\n        usedColors[a].add(color);\n        usedColors[b].add(color);\n    }\n\n    return {\n        minColors: Math.max(...colors),\n        edgeColors: colors\n    };\n}",
    "timestamp": "2025-08-13 12:07:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(N+1)]\n    edges = {}\n    for i in range(N-1):\n        a = int(input[ptr])\n        b = int(input[ptr+1])\n        ptr += 2\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n        edges[i] = (a, b)\n\n    max_degree = max(len(neighbors) for neighbors in adj)\n    color_used = [0] * (N-1)\n\n    root = 1\n    for i in range(1, N+1):\n        if len(adj[i]) == max_degree:\n            root = i\n            break\n\n    q = deque()\n    q.append((root, -1, 0))\n    while q:\n        u, parent, parent_color = q.popleft()\n        color = 1\n        for (v, edge_idx) in adj[u]:\n            if v == parent:\n                continue\n            if color == parent_color:\n                color += 1\n            color_used[edge_idx] = color\n            q.append((v, u, color))\n            color += 1\n\n    print(max_degree)\n    for i in range(N-1):\n        print(color_used[i])\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:07:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n\nfunction solve() {\n    const N = parseInt(input[0], 10);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    const edges = [];\n    const colorMap = new Map();\n\n    for (let i = 1; i <= N - 1; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        adj[a].push({ to: b, idx: i - 1 });\n        adj[b].push({ to: a, idx: i - 1 });\n        edges.push([a, b]);\n    }\n\n    let maxDegree = 0;\n    for (let i = 1; i <= N; i++) {\n        maxDegree = Math.max(maxDegree, adj[i].length);\n    }\n\n    const colors = new Array(N - 1).fill(0);\n    const used = new Array(maxDegree + 1).fill(false);\n\n    function dfs(u, parent) {\n        let color = 1;\n        for (const edge of adj[u]) {\n            if (edge.to === parent) continue;\n            if (color <= maxDegree) {\n                while (used[color]) {\n                    color++;\n                }\n                colors[edge.idx] = color;\n                used[color] = true;\n            }\n        }\n        for (const edge of adj[u]) {\n            if (edge.to === parent) continue;\n            used[colors[edge.idx]] = false;\n        }\n        for (const edge of adj[u]) {\n            if (edge.to === parent) continue;\n            dfs(edge.to, u);\n        }\n    }\n\n    dfs(1, -1);\n\n    console.log(maxDegree);\n    console.log(colors.join(' '));\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:07:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid dfs(int node, int parent, vector<vector<pair<int, int>>>& graph, vector<int>& edgeColor) {\n    int color = 1;\n    for (auto& adj : graph[node]) {\n        int adjNode = adj.first;\n        int edgeIdx = adj.second;\n        if (adjNode == parent) continue;\n        if (color == edgeColor[edgeIdx]) color++; // Ensure no repeated color for parent edge\n        edgeColor[edgeIdx] = color;\n        dfs(adjNode, node, graph, edgeColor);\n        color++;\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<pair<int, int>>> graph(N + 1);\n    vector<int> edgeColor(N - 1);\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].emplace_back(b, i);\n        graph[b].emplace_back(a, i);\n    }\n    \n    dfs(1, -1, graph, edgeColor);\n    int maxColors = 0;\n    for (auto color : edgeColor) {\n        maxColors = max(maxColors, color); \n    }\n    \n    cout << maxColors << endl;\n    for (auto color : edgeColor) {\n        cout << color << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:33:12"
  }
]