[
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines\n    val n = in.next.toInt\n    val es = in.take(n).flatMap(e => {\n        val Array(r, _, t@_*) = e.split(\" \").map(_.toInt)\n        t.map((r, _))\n    }).toList\n    in.next\n    for (Array(s, d, v) <- in..map(_.split(\" \").map(_.toInt))) {\n        val g = Array.fill(n+1)(Int.MaxValue-100)\n        g(s) = 1\n        var flag = true\n        while(flag) {\n            flag = false\n            for (e <- es) if (g(e(0)) + 1 < g(e(1))) {g(e(1)) = g(e(0)) + 1; flag = true}\n        }\n        println(if (v >= g(d)) g(d) else \"NA\")\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val inf = Int.MaxValue-10000\n    val in = io.Source.stdin.getLines\n    val n = in.next.toInt\n    val e = in.take(n).flatMap(x => {val y = x.split(\" \").map(_.toInt); y.drop(2).map(z => Array(y(0), z))}).toList\n    for (Array(s, d, v) <- in.take(in.next.toInt).map(_.split(\" \").map(_.toInt))) {\n        val g = Array.fill(n+1)(inf)\n        g(s) = 1\n        var flag = true\n        while(flag) {\n            flag = false\n            for (b <- e) if (g(b(0)) + 1 < g(b(1))) {g(b(1)) = g(b(0)) + 1; flag = true}\n        }\n        println(if (v >= g(d)) g(d) else \"NA\")\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    val N = sc.nextInt\n    val len = Array.fill[Array[Int]](N)(Array.fill[Int](N)(Int.MaxValue / 6))\n    for (idx <- 0 until N) {\n      len(idx)(idx) = 0\n      val now = sc.nextInt - 1\n      val count = sc.nextInt\n      for (idx2 <- 0 until count) {\n        len(now)(sc.nextInt - 1) = 1\n      }\n    }\n\n    for (k <- 0 until N) {\n      for (i <- 0 until N) {\n        for (j <- 0 until N) {\n          len(i)(j) = Math.min(len(i)(j), len(i)(k) + len(k)(j))\n        }\n      }\n    }\n\n    val P = sc.nextInt\n    for (idx <- 0 until P) {\n      val s, d = sc.nextInt - 1\n      val v = sc.nextInt\n      if (len(s)(d) + 1 <= v) {\n        println(len(s)(d) + 1)\n      } else {\n        println(\"NA\")\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n    solve(sc)\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines\n    val n = in.next.toInt\n    val es = in.take(n).flatMap(e => {\n        val Array(r, _, t@_*) = e.split(\" \").map(_.toInt)\n        t.map((r, _))\n    }).toList\n    in.next\n    for (Array(s, d, v) <- in.map(_.split(\" \").map(_.toInt))) {\n        val g = Array.fill(n+1)(Int.MaxValue-100)\n        g(s) = 1\n        var flag = true\n        while(flag) {\n            flag = false\n            for (e <- es) if (g(e._1) + 1 < g(e._2)) {g(e._2) = g(e._1) + 1; flag = true}\n        }\n        println(if (v >= g(d)) g(d) else \"NA\")\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines\n    val n = in.next.toInt\n    val es = in.take(n).flatMap(e => {\n        val Array(r, _, t@_*) = e.split(\" \").map(_.toInt)\n        t.map((r, _))\n    }).toList\n    in.next\n    for (Array(s, d, v) <- in.map(_.split(\" \").map(_.toInt))) {\n        val g = Array.fill(n+1)(Int.MaxValue-100)\n        g(s) = 1\n        (0 until es.size).foreach (_ => \n            for (e <- es) if (g(e._1) + 1 < g(e._2)) g(e._2) = g(e._1) + 1\n        )\n        println(if (v >= g(d)) g(d) else \"NA\")\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines\n    val n = in.next.toInt\n    val es = in.take(n).flatMap(e => {\n        val Array(r, _, t@_*) = e.split(\" \").map(_.toInt)\n        t.map((r, _))\n    }).toList\n    in.next\n    for (Array(s, d, v) <- in.map(_.split(\" \").map(_.toInt))) {\n        val g = Array.fill(n+1)(Int.MaxValue-100)\n        g(s) = 1\n        var flag = true\n        while(flag) {\n            flag = false\n            for (e <- es) if (g(e(0)) + 1 < g(e(1))) {g(e(1)) = g(e(0)) + 1; flag = true}\n        }\n        println(if (v >= g(d)) g(d) else \"NA\")\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n    val in = io.Source.stdin.getLines\n    val n = in.next.toInt\n    val es = in.take(n).flatMap(e => {\n        val Array(r, _, t@_*) = e.split(\" \").map(_.toInt)\n        t.map((r, _))\n    }).toList\n    in.next\n    for (Array(s, d, v) <- in.map(_.split(\" \").map(_.toInt))) {\n        val g = Array.fill(n+1)(Int.MaxValue-100)\n        g(s) = 1\n        var flag = true\n        while(flag) {\n            flag = false\n            for ((r, t) <- es)\n                if (g(r) + 1 < g(t)) {\n                    g(t) = g(r) + 1\n                    flag = true\n                }\n        }\n        println(if (v >= g(d)) g(d) else \"NA\")\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tint n, p;\n\tbool route[101][101];\n\t\n\tfor(int i=0; i<=100; ++i)\n\tfor(int j=0; j<=100; ++j)\n\troute[i][j]=false;\n\t\n\tscanf(\" %d\", &n);\n\tfor(int i=0; i<n; ++i){\n\t\tint r, k;\n\t\tscanf(\" %d %d\", &r, &k);\n\t\tfor(int j=0; j<k; ++j){\n\t\t\tint t;\n\t\t\tscanf(\" %d\", &t);\n\t\t\troute[r][t]=true;\n\t\t}\n\t}\n\t\n\tscanf(\" %d\", &p);\n\tfor(int i=0; i<p; ++i){\n\t\tint cost[101];\n\t\tfor(int j=0; j<=100; ++j) cost[j]=20000;\n\t\t\n\t\tint s, d, v;\n\t\tscanf(\" %d %d %d\", &s, &d, &v);\n\t\t\n\t\t//bfs\n\t\tqueue<int> que;\n\t\tcost[s]=1;\n\t\tque.push(s);\n\t\twhile( !que.empty() ){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\tif(route[v][j] && cost[j] > cost[v]+1){\n\t\t\t\t\tcost[j]=cost[v]+1;\n\t\t\t\t\tque.push(j);\t\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tif(cost[d] <= v) printf(\"%d\\n\", cost[d]);\n\t\telse printf(\"NA\\n\");\n\t}\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> dist(n+1, vector<int>(n+1, 1000));\n    for (int i=0; i<n+1; ++i) {\n        dist[i][i] = 0;\n    }\n    int r, k;\n    for (int i=0; i<n; ++i) {\n        cin >> r >> k;\n        int t;\n        for (int j=0; j<k; ++j) {\n            cin >> t;\n            dist[r][t] = 1;\n        }\n    }\n    for (int k=0; k<n+1; ++k) {\n        for (int i=0; i<n+1; ++i) {\n            for (int j=0; j<n+1; ++j) {\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n    int p;\n    cin >> p;\n    int s, d, v;\n    for (int i=0; i<p; ++i) {\n        cin >> s >> d >> v;\n        if (dist[s][d]+1 <= v) {\n            cout << dist[s][d]+1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define f first\n#define P pair<int,int>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int n,p,m,t,s;\n  cin>>n;\n  vector<int>a[n+1];\n  r(i,n){cin>>p>>m;\n    while(m--)cin>>t,a[p].push_back(t);\n  }\n  cin>>m;\n  while(m--){\n    cin>>s>>t>>p;p--;\n    queue<P>q;\n    q.push(make_pair(s,0));\n    while(!q.empty()){\n      P w=q.front();q.pop();\n      if(w.f==t){cout<<w.S+1<<endl;goto L;}\n      r(i,a[w.f].size()){\n        if(w.S+1<=p)q.push(make_pair(a[w.f][i],w.S+1));\n      }\n    }\n    cout<<\"NA\"<<endl;\n    if(0)L:n++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1e8\nusing namespace std;\n\nint graf[105][105];\n\nvoid wfloyd(int V) {\n\tfor (int k = 0;k < V;k++) {\n\t\tfor (int i = 0;i < V;i++) {\n\t\t\tfor (int j = 0;j < V;j++)graf[i][j] = min(graf[i][j], graf[i][k] + graf[k][j]);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tfor (int i = 0;i <= n;i++)\n\t\tfor (int j = 0;j <= n;j++)graf[i][j] = INF;\n\n\tfor (int i = 0;i < n;i++) {\n\t\tint s, d;\n\t\tcin >> s >> d;\n\n\t\tfor (int j = 0;j < d;j++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tgraf[s-1][a-1] = 1;\n\t\t}\n\t}\n\n\twfloyd(n);\n\tint p;\n\tcin >> p;\n\tfor (int i = 0;i < p;i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tint d = graf[a-1][b-1];\n\t\tif (d >= c)cout << \"NA\" << endl;\n\t\telse cout << d + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint node[200][200];\nint main()\n{\n  int n;\n  cin>>n;\n  memset(node,-1,sizeof(node));\n  for(;n--;)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      int ans=-1;\n\n      queue<P> qu;\n      int c[200];\n      memset(c,-1,sizeof(c));\n      for(int i=0;i<200;i++)\n\t{\n\t  if(v-1>0)\n\t    if(node[s][i]==1)\n\t      qu.push(P(i,v-1));\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  //      cout<<a.first<<\" \"<<a.second<<endl;\n\t  if(a.first==d)\n\t    {\n\t      ans=v-a.second+1;\n\t      break;\n\t    }\n\t  for(int i=0;i<200;i++)\n\t    {\n\t      if(node[a.first][i]==1)\n\t\t{\n\t\t  if(a.second-1>0)\n\t\t    {\n\t\t      if(c[i]==-1)\n\t\t\t{\n\t\t\t  c[i]=a.second-1;\n\t\t\t  qu.push(P(i,a.second-1));\t    \n\t\t\t}\n\t\t    }\n\t\t}\n\t    } \n\t}\n      \n      \n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n      \n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,b;\n  int ans=0;\n  int flag[111][111];\n  int box[111][111];\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      box[i][j]=9999;\n      flag[i][j]=0;\n    }\n  }\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      box[r-1][t-1]=1;\n    }\n  }\n  for(int z=0;z<n;z++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tbox[i][j]=min(box[i][j],box[i][z]+box[z][j]);\n      }\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> b;\n    ans=box[s-1][d-1]+1;\n    if(ans<=b){\n      cout << box[s-1][d-1]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector <int> ro[101];\nint s,d,v;\nint s2,d2;\nint kk,n,r,md;\nbool flg[102] ;\n\n\nvoid visit(int sn,int dis) {\n  //  for(int i=1;i<=n;i++)cout << flg[i];\n  // cout <<\" \";\n  \n  if(sn == d-1 && dis <=v)  md = min(md,dis);\n  else if(dis < v && dis < md) {\n    for(int i=0;i<ro[sn].size();i++) {\n      if(flg[ro[sn][i]] == 0){\n\t//\tcout <<sn+1 << \"to\"<<ro[sn][i] << endl;\n\tflg[ro[sn][i]] = 1;\n\tvisit(ro[sn][i]-1,dis+1);\n\tflg[ro[sn][i]] = 0;\n      }\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n    \n  for(int i=0;i<n;i++) {\n    cin >> r >> kk;\n    ro[i].resize(kk);\n    for(int j=0;j<kk;j++) cin >> ro[r-1][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n    \n    for(int j=1;j<=n;j++) flg[j] = 0;\n    md = 10000000;\n    flg[s]  = 1;   \n    visit(s-1,1);\n    \n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(101);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    vector<bool> check(101, false);\n    queue<int> fq, nq, sq;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            if (check[pos]) {\n                continue;\n            } else {\n                check[pos] = true;\n            }\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            } else {\n                for (int i: g[pos]) {\n                    nq.push(i);\n                }\n            }\n        }\n        if (c == 0 || nq.empty()) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n;\n\tint d[101][101];\n\tREP(i, 101)REP(j, 101) d[i][j] = (i == j ? 0 : INF);\n\tcin >> n;\n\tREP(i, n)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tREP(j, b)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tk--;\n\t\t\td[i][k] = 1;\n\t\t}\n\t}\n\tREP(k, 101)REP(i, 101)REP(j, 101) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\tint q;\n\tcin >> q;\n\twhile (q--)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (d[a][b] < c) cout << d[a][b]+1 << endl;\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;n++)\nint n,nn, a, b, c;\n\nint main() {\n\tcin >> n;\n\tint data[n+1][n+1];\n\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tdata[i][j]=900000;\n\t\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a>>b;\n\t\tfor (int j = 0; j < b; ++j) {\n\t\t\tcin >> c;\n\t\t\tdata[a][c]=1;\n\t\t}\n\t}\n\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tfor (int k = 1; k <= n; ++k) {\n\t\t\t\tdata[j][k]=min(data[j][k],data[j][i]+data[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\t/*for (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<data[i][j]+1<<endl;\n\t\t\t}\n\t}*/\n\n\n\tcin>>n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin>>a>>b>>c;\n\t\tif(data[a][b]+1<=c){cout<<data[a][b]+1<<endl;}\n\t\telse{cout<<\"NA\"<<endl;}\n\t}\nreturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\ntypedef long long ll;\n\nint d[110][110];\n\nint main(void) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = INF;\n        }\n        d[i][i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n        int r, k;\n        cin >> r >> k;\n        --r;\n        int t;\n        for (int j = 0; j < k; j++) {\n            cin >> t;\n            d[r][t-1] = 1;\n        }\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n    int p;\n    cin >> p;\n    for (int i = 0; i < p; i++) {\n        int s, D, v;\n        cin >> s >> D >> v;\n        if (v > d[s-1][D-1]) {\n            cout << d[s-1][D-1]+1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint n, a[101][101], s, t, u;\n\t\n\twhile(cin >> n){\n\t\tfill(&a[0][0], &a[n][n], 99999);\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\ta[i][i] = 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s >> t;\n\t\t\twhile(t--){\n\t\t\t\tcin >> u;\n\t\t\t\ta[s][u] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\ta[i][j] = (a[i][j] > a[i][k]+a[k][j])? a[i][k]+a[k][j] : a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tcout << a[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\twhile(n--){\n\t\t\tcin >> s >> t >> u;\n\t\t\tif(a[s][t]+1 <= u){\n\t\t\t\tcout << a[s][t]+1 << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repp(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\nusing namespace std;\n\nconst int INF = 1e7;\n\nint n;\nint d[101][101];\n\nvoid init(int n){\n    rep(i, 0, n){\n        rep(j, 0, n){\n            d[i][j] = INF;\n            if(i == j) d[i][j] = 0;\n        }\n    }\n}\n\nvoid warshall_floyd(){\n    rep(k, 0, n){\n        rep(i, 0, n){\n            rep(j, 0, n){\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin >> n;\n    init(n);\n    int r, k, t;\n    rep(i, 0 ,n){\n        cin >> r >> k;\n        rep(j, 0, k){\n            cin >> t;\n            d[r - 1][t - 1] = 1;\n        }\n    }\n    warshall_floyd();\n    int fr, to, v, p;\n    cin >> p;\n    rep(i, 0, p){\n        cin >> fr >> to >> v;\n        if(d[fr - 1][to - 1] < v){\n            cout << d[fr - 1][to - 1] + 1 << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define M 10000\n\nusing namespace std;\n\nbool TransportPacket(const vector< vector<int> >& data,\n\t\t     int s, int g, int ttl, int* ans_){\n  vector<bool> is_reached(data.size(), false);\n  vector<int> ans(data.size(), M);\n  int i, j;\n  ans[s] = 0;\n  i = s;\n  while(i != g){\n    is_reached[i] = true;\n    for(j=0; j<data[i].size(); ++j){\n      ans[j] = min(ans[j], ans[i] + data[i][j]);\n    }\n    for(i=-1, j=0; j<is_reached.size(); ++j){\n      if(!is_reached[j] && (i < 0 || ans[i] > ans[j])) i = j;\n    }\n  }\n  *ans_ = ans[g] + 1;\n  if(ttl - *ans_ >= 0) return true;\n  else return false;\n}\n\nint main(){\n  int n, r, k, t;\n  int s, d, v, ans;\n\n  cin >> n;\n  vector< vector<int> > data(n, vector<int>(n, M));\n\n  for(int i=0; i<n; ++i){\n    cin >> r >> k;\n    for(int j=0; j<k; ++j){\n      cin >> t;\n      data[r-1][t-1] = 1;\n    }\n  }\n  cin >> n;\n  for(int i=0; i<n; ++i){\n    cin >> s >> d >> v;\n    if(TransportPacket(data, s-1, d-1, v, &ans)) cout << ans << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  const int INF = 1 << 30;\n  int n, dis[110][110];\n  cin >> n;\n  fill((int*)dis, (int*)(dis + 110), INF);\n  for (int i = 1; i <= n; i++) {\n    dis[i][i] = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int r, k;\n    cin >> r >> k;\n    for (int j = 0; j < k; j++) {\n      int t;\n      cin >> t;\n      dis[r][t] = 1;\n    }\n  }\n  for (int k = 1; k <= n; k++) {\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= n; j++) {\n        if (dis[i][k] == INF || dis[k][j] == INF) continue;\n        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n      }\n    }\n  }\n  int p;\n  cin >> p;\n  for (int i = 0; i < p; i++) {\n    int s, d, v;\n    cin >> s >> d >> v;\n    if (dis[s][d] + 1 <= v) cout << dis[s][d] + 1 << endl;\n    else cout << \"NA\" << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 2011/10/02 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tint G[100][100];\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<n; j++)\n\t\t\tif(i==j)\n\t\t\t\tG[i][j] = 0;\n\t\t\telse\n\t\t\t\tG[i][j] = -1;\n\n\tfor(int i=0; i<n; i++){\n\t\tint r;\n\t\tcin >> r;\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j=0; j<k; j++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tG[r-1][t-1] = 1;\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++)\n\t\t\tcout << G[i][j] << ' ';\n\t\tcout << endl;\n\t}\n*/\n\n\tfor(int k=0; k<n; k++)\n\t\tfor(int i=0; i<n; i++)\n\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\tif(G[i][k]==-1||G[k][j]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if(G[i][j]==-1||(G[i][j]>G[i][k]+G[k][j]))\n\t\t\t\t\tG[i][j] = G[i][k]+G[k][j];\n\n\tint p;\n\tcin >> p;\n\n\tfor(int i=0; i<p; i++){\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\n\t\tif(v>=G[s-1][d-1]+1)\n\t\t\tcout << G[s-1][d-1]+1 << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0;i<n;++i)\n\n//ダイグスとらで解くそうです\n\nusing namespace std;\n\ntypedef pair<int,int> DisNum;\n\nvector<int> canto;\n\nint Serch(vector<DisNum> canConnect[102],int from,int to,int hp)\n{\n\tint distance[102] = {};//距離を保存\n\tREP(i,102) distance[i] = INT_MAX;\n\tpriority_queue<DisNum,vector<DisNum>,greater<DisNum>> qu;//行き先のストックをキュー\n\tqu.push(DisNum(0,from));\n\tdistance[from] = 0;\n\twhile(!qu.empty())\n\t{\n\t\tDisNum nowfrom;\n\t\tnowfrom = qu.top();qu.pop();\n\t\tif(distance[nowfrom.second] != nowfrom.first) continue;\n\t\tif(nowfrom.second == to) return nowfrom.first;\n\t\tfor(int i=0;i<canConnect[nowfrom.second].size();++i)\n\t\t{\n\t\t\tint v = canConnect[nowfrom.second][i].second;//今から調べる先の座標\n\t\t\tint n = nowfrom.second;\n\t\t\tif(distance[v] > distance[n] + canConnect[nowfrom.second][i].first)\n\t\t\t{\n\t\t\t\tdistance[v] = distance[n] + canConnect[nowfrom.second][i].first;\n\t\t\t\tqu.push(DisNum(distance[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint maxn;\n\tcanto.clear();\n\tvector<DisNum> canConnect[102];\n\tcin >> maxn;\n\tfor(int i=0;i<maxn;++i)\n\t{\n\t\tint r,k;\n\t\tcin >> r >> k;\n\t\tfor(int j=0;j<k;++j)\n\t\t{\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tcanConnect[r].push_back(DisNum(1,t));\n\t\t}\n\t}\n\tint l;\n\tcin >> l;\n\tfor(int j=0;j<l;++j)\n\t{\n\t\tint s,d,v;\n\t\tcin >> s >> d >> v;\n\t\tint ans = Serch(canConnect,s,d,v) + 1;\n\t\tif(ans <= v)\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <deque>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N_MAX = 100;\n\nclass Node {\npublic:\n\tint pos, ttl;\n\tNode(int p, int t) : pos(p), ttl(t) {}\n};\n\nint n;\n// adj[from][to] from->toの辺があるか\nbool adj[N_MAX + 1][N_MAX + 1];\n\nvoid bfs(int src, int dst, int limit) {\n\tdeque<Node> que;\n\tque.push_back(Node(src, limit - 1));\n\twhile (!que.empty()) {\n\t\tNode current = que.front();\n\t\tque.pop_front();\n\t\tif (current.pos == dst) {\n\t\t\tcout << limit - current.ttl << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (current.ttl == 0) continue;\n\t\tfor (int next = 1; next <= n; next++) {\n\t\t\tif (adj[current.pos][next]) {\n\t\t\t\tque.push_back(Node(next, current.ttl - 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfill(adj[r], adj[r] + n, false);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tadj[r][t] = true;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tbfs(s, d, v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\n/* main??? */\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\n/* ???????????¢??° */\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\n/* ??????????????\\?¶??????±??\\?????¢??° */\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++){\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ???????????±???????????±??\\?????¢??° */\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcSumRouter(i4StartRouter,i4GoalRouter,i4TTL);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ??????????????????????¨????????????°?¨??????¢??° */\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\t/* ?????°??£?¨? */\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\t/* ????????¨ */\n\tI4 i4DefineRouter[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\tI4 i4RoopMax;\n\t\n\t/* ????????? */\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\ti4DefineRouter[i4RoopCnt1] = FALSE;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\tif(i4TTL<=i4RouterNum){\t\n\t\ti4RoopMax = i4TTL;\n\t}\n\telse{\n\t\ti4RoopMax = i4RouterNum;\n\t}\n\t\n\ti4DefineRouter[i4Sender] = TRUE;\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<i4RoopMax; i4RoopCnt1++){\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=i4RouterNum; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i4DefineRouter[i4RoopCnt3] != TRUE){\n\t\t\t\t\t\t\ti4DefineRouter[i4RoopCnt3] = TRUE;\n\t\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#define MAX_N 110\n#define INF 2<<31\nbool A[MAX_N][MAX_N];\nint rooter_num;\nusing namespace std;\nint bfs(int,int);\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  int a;\n  memset(A,false,sizeof(A));\n  cin>>rooter_num;\n  /*------------input---------------*/\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r][t]=true;\n\t}\n    }\n  cin>>n;\n  /*-------------search--------------*/\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      a=bfs(startNode,goalNode);\n      //cout<<\"TTL=\"<<TTL<<\";\"<<\"a-1=\"<<a<<endl;\n      /*\n\t TTLの減少値 = (それまでに通ったルータの数) - 1\n\t 直前のNodeでTTLが1以上ならばパケットが通るので\n\t goal地点でのTTLの減少値がTTLと同等,またはそれ以下ならば\n\t パケットが通る事になる。\n       */\n      if(a<=TTL)cout<<a<<endl;\n      else cout<<\"NA\"<<endl;\n       \n    }\n  return 0;\n}\nint bfs(int startNode,int goalNode)\n{\n  queue<int>Q;\n  int visited[rooter_num+1];\n  /*\n    visitedは既に通過しているかの判定と経由したルータの数を保持する\n  */\n  memset(visited,0,sizeof(visited));\n  /*\n    memsetによって全てを０で初期化する\n  */\n\n  int currentNode=startNode;\n  Q.push(currentNode);\n  visited[currentNode]=1;\n\n  /*-------BFS--------*/  \n  while(!Q.empty())\n    {\n      currentNode=Q.front();\n      Q.pop();\n      for(int nextNode=1;nextNode<=rooter_num;nextNode++)\n\t{\n\n\t  if(A[currentNode][nextNode]==0)continue;\n\t  /*\n\t    接続されていない場合を切り取った\n\t  */\n\t  if(nextNode==goalNode)return visited[currentNode]+1;\n\t  /*\n\t    goalNodeの接続を確認したので探索を打ち切る\n\t  */\n\t  if(visited[nextNode]<=0)\n\t    {\n\t      visited[nextNode]=visited[currentNode]+1;\n\t      Q.push(nextNode);\n\t    }\n\t  /*\n\t    まだ訪れていない(かつ接続出来るNodeを)キューに追加する\n\t   */\n\t}\n    }\n  return INF;\n  /*\n    接続出来ない場合無限大を返す\n   */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<limits.h>\nusing namespace std;\n\nint n;\nint d[103][103];\nvoid wf();\n\nint main(){ \n  while(cin >> n)wf();\n}\n\n\n\n\nvoid wf(){\n  int i1,m,J2;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j)d[i][j]=0;\n      d[i][j]=1000000000;//INT_MAXテつづつセテつづδつバテつグテつづδゥ\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> i1 >> m;\n    for(int j=0;j<m;j++){\n      cin >> J2;\n      d[i1-1][J2-1]=1;\n    }\n  }\n\n  for(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n  int oh;\n\n  cin >> oh;\n  int st,ed,ttl;\n  for(int i=0;i<oh;i++){\n    cin >> st >> ed >> ttl;\n    if(d[st-1][ed-1]+1 > ttl)cout << \"NA\" << endl;\n    else cout << d[st-1][ed-1]+1 << endl;\n\n  }/*\n for(int i=0;i<n;i++){\n     for(int j=0;j<n;j++)cout << d[i][j] << \" \" ;\n     cout << endl;\n   }\n   */\n\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define N 101\n\nint M[N][N];//&#65533;&#1488;&#1677;s&#65533;\nint d[N];//&#65533;m&#65533;[&#65533;h&#65533;&#784;&#65533;\nint pi[N];//&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#30152;&#65533;&#65533;&#65533;&#65533;\n\nvoid initi();\nint BFS(int start,int goal);\n\n\nmain(){\n  initi();\n  int n;\n  cin >> n;\n  for(int i = 0; i< n ; i++){\n    int Bangou,setuzokusu;\n    cin >> Bangou;\n    cin >> setuzokusu;\n    for(int j=0;j < setuzokusu ; j++){\n      int to;\n      cin >> to;\n      M[Bangou][to]=1;\n    }\n  }//&#65533;f&#65533;[&#65533;^&#65533;&#787;&#65533;&#65533;&#834;&#65533;&#65533;&#65533;&#65533;&#1794;\n  \n  \n  cin >> n;\n  for(int i = 0; i < n;i++){\n    int start,goal,TTL,result;\n    cin >> start >> goal >> TTL;\n    if ( (result =BFS(start,goal)+1) > TTL)cout << \"NA\" << endl;\n    else cout << result << endl;\n  }\n  \n  \n  \n  \n  return 0;     \n}\n\n\nvoid initi(){\n        for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++)M[i][j]=0;\n        }\n}\n\nint BFS(int start,int goal){\n        \n  queue<int> Q;//&#65533;L&#65533;&#65533;&#65533;[&#65533;&#65533;&#65533;p&#65533;\n  for(int i=0;i<N;i++){\n    d[i] =1 << 21;\n    pi[i]=0;\n  }\n  \n  d[start]=0;\n  Q.push(start);\n  \n  while(!Q.empty()){//&#65533;L&#65533;&#65533;&#65533;[&#65533;&#65533;&#65533;&#65533;&#65533;&#578;&#514;&#65533;&#65533;&#1794;&#322;&#65533;&#65533;\n    int u=Q.front();\n    Q.pop();\n    //  cout << \"Now u is\" << u << endl;\n    for(int v = 0 ; v <N ; v++){\n      if (M[u][v] && d[v] == 1 << 21){//u&#65533;&#65533;&#65533;&#65533;v&#65533;&#589;s&#65533;&#65533;&#65533;&#269;X&#65533;&#65533;v&#65533;&#771;X&#65533;^&#65533;[&#65533;g&#65533;n&#65533;_&#65533;&#65533;&#65533;&#65533;&#65533;&#779;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#337;&#65533;&#65533;&#782;&#65533;\n        d[v]=d[u]+1;\n        pi[v]=u;//&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#30152;&#65533;&#65533;&#65533;&#65533;\n        Q.push(v);\n        //cout <<\"from \"  <<u << \"to\" <<v << endl;\n      }\n    }\n  }\n\n  //for(int i=1;i<8;i++)cout << d[i]<< \" \";\n  //cout << endl;\n  \n  \n  return d[goal];\n        \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){\n\t\tttl = current = 0;\n\t}\n\n\tvoid copy(Packet t){\n\t\tttl = t.ttl;\n\t\tcurrent = t.current;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = t.checkTable[i];\n\t}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit;\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int d = 1; d <= n; d++){\n\t\t\t\tif(d != start && table[start][d] == 1){\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(d);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp.copy(Q.front());\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.ttl > 0 && tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1 && t_limit-tmp.ttl + 1 <= n){\n\t\t\t\tfor(int m=1; m <= n; m++){\n\t\t\t\t\tif(m != tmp.current && tmp.checkTable[m] == 0 && table[tmp.current][m] == 1){\n\t\t\t\t\t\tPacket q;\n\t\t\t\t\t\tq.copy(tmp);\n\t\t\t\t\t\tq.ttl--;\n\t\t\t\t\t\tq.set(m);\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101],P[101],D[101],num,min,min_index,current;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <=  t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int index=1; index <= n; index++){\n\t\t\tP[index] = 0;\n\t\t\tD[index] = 1000000000;\n\t\t}\n\n\t\tP[start] = 1;\n\t\tnum = 1;\n\n\t\tfor(int index = 1; index <= n; index++){\n\t\t\tif(index != start && table[start][index] == 1){\n\t\t\t\tif(memo[index][goal] > 0 && memo[index][goal] + 1 <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[index][goal]+1);\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tD[index] = 1;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)continue;\n\n\t\twhile(num < n){\n\t\t\tmin = 1000000000;\n\t\t\tfor(int index=1;index <= n; index++){  //??????????????°?????????????????????????????¢???\n\t\t\t\tif(P[index] == 0 && D[index] < min){ //?????????????????§?????????????????????????????????\n\t\t\t\t\tmin = D[index];\n\t\t\t\t\tmin_index =index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(min == 1000000000)break; //?????????????????????????????????????????°break\n\n\t\t\tP[min_index] = 1; //min_index?????????????????¨??????\n\t\t\tcurrent = min_index;\n\t\t\tnum++; //???????????????????????°???1?¢???????\n\n\t\t\tif(memo[current][goal] > 0 && D[current]+memo[current][goal] <= t_limit){\n\t\t\t\tD[goal] = D[current]+memo[current][goal]-1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tif(table[current][i] == 1){\t//start???????????????????????¨???????????£????????????\n\t\t\t\t\tD[i] = (D[i] <= (D[current]+1))?D[i]:(D[current]+1); //?????????????????´??\\????????¢??¨???current????????±???????????¢???????????????D??¨??????\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif(D[goal] >= t_limit){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tmemo[start][goal] = D[goal]+1;\n\t\t\tprintf(\"%d\\n\",D[goal]+1);\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define SUB 103\nint net[SUB][SUB],n,maxx=0;\ntypedef pair<int,int> BVB;\nint ans(int,int,int);\nint main(){\n  int i,j,p,num,n1,th;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n  }\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n  int pkn;\n  cin >> pkn;\n  int st,ed,c,answer;\n  for(i=0;i<pkn;i++){\n    cin >> st >> ed >> c;\n    answer = ans(st,ed,c);\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n  }\n}\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  if(st == ed && c != 0)return 1;\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n    if(next.second < 0)break; \n    for(i=1;i<=maxx;i++){\n      if(net[next.first][i] == 1)mem++;  \n      if(net[next.first][i] == 1 && i == ed ){\n\treturn (fr.second - next.second)+1;\n      }\n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      if(mem == n)break;\n    }\n  }\n  return -2;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101],P[101],D[101],num,min,min_index,current;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <=  t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int index=1; index <= n; index++){\n\t\t\tP[index] = 0;\n\t\t\tD[index] = 1000000000;\n\t\t}\n\n\t\tP[start] = 1;\n\t\tnum = 1;\n\n\t\tfor(int index = 1; index <= n; index++){\n\t\t\tif(index != start && table[start][index] == 1){\n\t\t\t\tD[index] = 1;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)continue;\n\n\t\twhile(num < n){\n\t\t\tmin = 1000000000;\n\t\t\tfor(int index=1;index <= n; index++){\n\t\t\t\tif(P[index] == 0 && D[index] < min){\n\t\t\t\t\tmin = D[index];\n\t\t\t\t\tmin_index =index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(min == 1000000000)break;\n\n\t\t\tP[min_index] = 1;\n\t\t\tcurrent = min_index;\n\t\t\tnum++;\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tif(table[current][i] == 1){\n\t\t\t\t\tD[i] = (D[i] <= (D[current]+1))?D[i]:(D[current]+1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif(D[goal] >= t_limit){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tmemo[start][goal] = D[goal]+1;\n\t\t\tprintf(\"%d\\n\",D[goal]+1);\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 29;\nconst int N = 100;\nint n;\nint as[N+1][N+1];\n\nvoid floyd() {\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                as[i][j] = min(as[i][j], as[i][k] + as[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    while (cin >> n) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                as[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int r, k;\n            cin >> r >> k;\n            for (int j = 0; j < k; j++) {\n                int t;\n                cin >> t;\n                as[r][t] = 1;\n            }\n        }\n        floyd();\n        int p;\n        cin >> p;\n        for (int i = 0; i < p; i++) {\n            int s, d, v;\n            cin >> s >> d >> v;\n            int dist = as[s][d] + 1;\n            if (dist <= v) {\n                cout << dist << endl;\n            } else {\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n\nstatic const int NO = -2;\nstatic const int N = 300;\n\n\nint graph[N + 1][N + 1] = {{}};\nint dis[N + 1] = {};\nint n;\n\nvoid bfs(int v){\n  queue<int> Q;\n\n  Q.push(v);\n\n  for(int i = 1; i <= N; i++){\n    dis[i] = NO;\n  }\n\n  dis[v] = 1;\n\n  int u;\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n\n    for(int i = 1;i <= n; i++){\n      if(graph[u][i]==0) continue;\n      if(dis[i]!=NO)continue;\n      dis[i] = dis[u] + 1;\n      Q.push(i);\n\n    }\n  }\n}\n\nint main(){\n\n  int r[N+1] = {};\n  int d[N+1] = {};\n  int k[N+1] = {};\n  int f[N+1] = {};\n  int p,s[N+1] = {};\n  int v[N+1] = {};\n\n\n  //in\n  cin >> n;\n\n  for(int i = 1;i <= n; i++){\n\n    cin >> r[i] >> k[i];\n\n    for(int j = 1;j <= k[i];j++){\n\n      cin >> f[j];\n      graph[r[i]][f[j]] = 1;\n    }\n  }\n\n  cin >> p;\n  for(int i = 1;i <= p; i++){\n    cin >> s[i] >> d[i] >> v[i];\n    bfs(s[i]);\n\n    if(v[i] >= dis[d[i]]) cout << dis[d[i]] << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){\n\t\tttl = current = 0;\n\t}\n\n\tvoid copy(Packet t){\n\t\tttl = t.ttl;\n\t\tcurrent = t.current;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = t.checkTable[i];\n\t}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tif(memo[start][goal] != 0){\n\t\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(i);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.ttl > 0 && tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && (memo[i][goal]+1) < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+2+memo[i][goal]);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+2+memo[i][goal];\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p;\n\t\t\t\t\t\tp.copy(tmp);\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int maxv=100;\nint main()\n{\n\tint root[101][101];\n\tfor(int i=0;i<10;i++){\n\t\tfor(int i2=0;i2<10;i2++){\n\t\t\troot[i][i2]=maxv;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tint r,k,ch;\n\tcin>>r>>k;\n\t\tfor(int i2=0;i2<k;i2++){\n\t\t\tcin>>ch;\n\t\t\troot[r][ch]=1;\n\t\t}\n\t}\n\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int i2=01;i2<=n;i2++){\n\t\t\t\troot[i][i2]=min(root[i][i2],root[i][k]+root[k][i2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint m;\n\tint s,d,v;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>s>>d>>v;\n\t\tif(v-root[s][d]>0){\n\t\t\tcout<<root[s][d]+1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 5000;\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\nconst int INF = 100000000;\n\nint prevv[MAX_V];\n\nclass Situation{\npublic:\n\tint ttl;\n\tint node;\n\tint dist;\n\n\tSituation();\n\tSituation(int ttl_,int node_,int dist_){\n\t\tttl=ttl_;\n\t\tnode=node_;\n\t\tdist=dist_;\n\t}\n\n\tbool operator<(const Situation &sit)const{\n\t\treturn sit.dist > this->dist;\n\t}\n};\n\nvoid dijkstra(int s,int ttl){\n\tpriority_queue<Situation > que;\n\tfill(d,d+MAX_V,INF);\n\td[s] = 0;\n\tque.push(Situation(ttl,s,0));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.node;\n\t\tif(d[v] < p.dist)\n\t\t\tcontinue;\n\t\tif(ttl==1)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(ttl-1,e.to,d[e.to]));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tint from;\n\t\tcin>>from;\n\t\tint m;\n\t\tcin>>m;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint to;\n\t\t\tcin>>to;\n\t\t\tedge e;\n\t\t\te.cost=1;\n\t\t\te.to=to;\n\t\t\tG[from].push_back(e);\n\t\t}\n\t}\n\tint l;\n\tcin>>l;\n\tfor(int j = 0; j < l; j++){\n\t\tint s,dd,v;\n\t\tcin>>s>>dd>>v;\n\t\tdijkstra(s,v);\n\t\tif(d[dd]==INF)\n\t\t\tcout<<\"NA\"<<endl;\n\t\telse\n\t\t\tcout<<d[dd]+1<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Packet Transportation\n//Level: 2\n//Category: グラフ,Graph,全点対間最短距離\n//Note:\n\n/**\n * 全点対間の最短距離を求めておけば良い。\n * オーダーは O(N^3)。\n */\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate <typename T>\nstruct Maybe {/*{{{*/\n    T val;\n    bool valid;\n\n    Maybe() : valid(false) {}\n    Maybe(T &t) : val(t), valid(true) {}\n\n    T& operator =(const T &rv) {\n        val = rv;\n        valid = true;\n        return val;\n    }\n\n    operator T() const {\n        return valid ? val : T();\n    }\n\n    template<typename Cond>\n    bool update(const T &v, Cond cond) {\n        if(!valid || cond(v, val)) {\n            val = v;\n            valid = true;\n            return true;\n        }\n        return false;\n    }\n\n    bool update(const T &v) {\n        return update(v, less<T>());\n    }\n};/*}}}*/\n\ntemplate<typename T>\nstruct WarshallFloyd {\n    vector<vector<Maybe<T>>> graph;\n    int N;\n\n    WarshallFloyd(int size) : graph(size), N(size) {\n        for(auto &v : graph) {\n            v.resize(size);\n        }\n    }\n\n    void add_edge(int from, int to, const T &dist) {\n        graph[from][to] = dist;\n    }\n\n    void freeze() {\n        for(int k = 0; k < N; ++k) {\n            for(int i = 0; i < N; ++i) {\n                for(int j = 0; j < N; ++j) {\n                    if(graph[i][k].valid && graph[k][j].valid) {\n                        graph[i][j].update(graph[i][k] + graph[k][j]);\n                    }\n                }\n            }\n        }\n    }\n\n    const Maybe<T>& query(int from, int to) {\n        return graph[from][to];\n    }\n};\n\nbool solve(bool first) {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    WarshallFloyd<int> wf(N);\n    for(int i = 0; i < N; ++i) {\n        int from, k;\n        cin >> from >> k;\n        --from;\n        while(k--) {\n            int v;\n            cin >> v;\n            wf.add_edge(from, v-1, 1);\n        }\n    }\n    wf.freeze();\n    int P;\n    cin >> P;\n    while(P--) {\n        int s, d, t;\n        cin >> s >> d >> t;\n        const auto &dist = wf.query(s-1, d-1);\n        if(dist.valid && dist <= t) {\n            cout << dist << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(2);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define MAX 100\n#define INF (1<<21)\nint n, L[MAX][MAX],S[MAX];\n\nint bfs( int s, int t ){\n    queue<int> q; q.push(s);\n    int u, v, d[MAX];\n    rep(i, n) d[i] = INF;\n    d[s] = 1;\n    while( !q.empty() ){\n\tu = q.front(); q.pop();\n\trep(i, S[u]){\n\t    v = L[u][i];\n\t    if ( d[v] == INF ){\n\t\td[v] = d[u] + 1;\n\t\tq.push(v);\n\t    }\n\t}\n    }\n    return d[t];\n}\n\nmain(){\n    int s, t, tl, q, c;\n    cin >> n;\n    rep(i, n){\n\tcin >> s; s--; cin >> S[s];\n\trep(j, S[s]){\n\t    cin >> L[s][j]; L[s][j]--;\n\t}\n    }\n    cin >> q;\n    rep(i, q){\n\tcin >> s >> t >> tl; s--; t--;\n\tc = bfs(s, t);\n\tif ( c <= tl ) cout << c << endl;\n\telse cout << \"NA\" << endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\treturn 0;\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER)\n\t{\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL)\n\t{\n\t\tprintf(\"start:%d,goal:%d,TTL:%d\\n\",i4StartRouter,i4GoalRouter,i4TTL);\n\t\ti4Ans = CalcDijikstra(i4StartRouter,i4GoalRouter,i4TTL,1);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum)\n{\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tif(i4TTL <= i4RoopCnt1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE)\n\t\t\t{\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=MAX_ROUTER; i4RoopCnt3++)\n\t\t\t\t{\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define INF 1e+9\n#define MAX_N 101\n\nusing namespace std;\nint main(void){\n\tint n;cin>>n;\n\tint g[MAX_N][MAX_N];\n\tfor(int i=0;i<MAX_N;++i)for(int j=0;j<MAX_N;++j) g[i][j]=INF;\n\tfor(int i=0,r,k;i<n;++i){\n\t\tcin>>r>>k;\n\t\tfor(int j=0,t;j<k;++j){\n\t\t\tcin>>t;\n\t\t\tg[r][t]=1;\n\t\t}\n\t}\n\tint d[MAX_N][MAX_N];\n\tfor(int i=0;i<MAX_N;++i)for(int j=0;j<MAX_N;++j)d[i][j]=(i==j)?1:INF;\n\tfor(int i=1;i<=n;++i){\n\t\tbool f=false;\n\t\tfor(;;){\n\t\t\tfor(int j=1;j<=n;++j){//from\n\t\t\t\tfor(int k=1;k<=n;++k){//to\n\t\t\t\t\tif(d[i][j]!=INF && d[i][j] + g[j][k] < d[i][k]){\n\t\t\t\t\t\td[i][k] = d[i][j] + g[j][k];\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==false) break;\n\t\t\tf=false;\n\t\t}\n\t}\n\tint p;cin>>p;\n\tfor(int i=0,from,to,v;i<p;++i){\n\t\tcin>>from>>to>>v;\n\t\tif(d[from][to]>v) cout<<\"NA\"<<endl;\n\t\telse cout<<d[from][to]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int INF = 100;\nint d[100][100];\nvoid init()\n{\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tif(i == j){\n\t\t\t\td[i][j] = 0;\n\t\t\t}else{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tinit();\n\tfor(int i=0;i<n;i++){\n\t\tint a,m;\n\t\tcin >> a >> m;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\td[a-1][b-1] = 1;\n\t\t}\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint dis = d[i][k]+d[k][j];\n\t\t\t\tif(dis < d[i][j]){\n\t\t\t\t\td[i][j] = dis;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor(int j=0;j<p;j++){\n\t\tint a,b,pket;\n\t\tcin >> a >> b >> pket;\n\t\tif(d[a-1][b-1]+1 <= pket)\n\t\t\tcout << d[a-1][b-1]+1  << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint n,i,j,k,a,b,c,cost[101][101];\n\tchar cc;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) cost[i][j] = 1<<28;\n\t\tcin>>a>>b;\n\t\tfor(j=0;j<b;j++){\n\t\t\tcin >> c;\n\t\t\tcost[a][c]=1;\n\t\t}\n\t}\n\tfor(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++)\n\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b>>c;\n\t\tif(cost[a][b]<c) cout << cost[a][b]+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main(){\n  int a,b,c,d,e,f,g,now,v[101],m[101][101]={};\n  queue<int> q;\n  cin >> a;\n  for(int i=1;i<=a;i++){\n    cin >>b>>c;\n    for(int j=0;j<c;j++){\n      cin >> d;\n      m[i][d]=1;\n    }\n  }\n  cin >> d;\n  for(int i=0;i<d;i++){\n    cin >> e >> f >> g;\n    q.push(e);\n    for(int j=1;j<=a;j++)v[j]=1200;\n    v[e]=1;\n    while(1){\n      now=q.front();q.pop();\n      if(now==f){\n\tif(v[f]>g){\n\t  cout << \"NA\" << endl;\n\t  break;\n\t}else {\n\t  cout << v[now] << endl;\n\t  break;\n\t}\n      }\n      for(int j=1;j<=a;j++){\n\tif(m[now][j]==1&&v[j]==1200){\n\t  v[j]=v[now]+1;\n\t  q.push(j);\n\t}\n      }\n      if(q.empty()){\n\tcout<< \"NA\" << endl;\n\tbreak;\n      }\n    }\n    while(!q.empty())q.pop();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint main(){\n    int n; cin>>n;\n    vector<vector<pii>>edge(n,vector<pii>());\n    rep(i,n){\n        int r; cin>>r;\n        --r;\n        int k; cin>>k;\n        rep(j,k){\n            int to; cin>>to;\n            edge[r].push_back(pii(to-1,1));\n        }\n    }\n    int p; cin>>p;\n    rep(_,p){\n        priority_queue<pii,vector<pii>,greater<pii>>que;\n        int from,to,cost; cin>>from>>to>>cost;\n        --to,--from;\n        vector<int>d(n,INF);\n        d[from]=0;\n        que.push(pii(0,from));\n        while(!que.empty()){\n            pii now=que.top(); que.pop();\n            if(now.second==to)break;\n            if(d[now.second]<now.first)continue;\n            for(int i=0; i<edge[now.second].size();i++){\n                pii next=edge[now.second][i];\n                if(d[next.first]<now.first+next.second)continue;\n                d[next.first]=now.first+next.second;\n                que.push(pii(now.first+next.second,next.first));\n            }\n        }\n        if(d[to]<cost)cout<<d[to]+1<<endl;\n        else cout<<\"NA\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nconst int SIZE = 101;\n\nint solve( int table[ SIZE ][ SIZE ], int s, int e, int initTtl, int numRooter )\n{\n\tif( initTtl < 2 ){\n\t\treturn 0;\n\t}\n\tbool bPast[ SIZE ];\n\tmemset( bPast, 0, sizeof( bPast ) );\n\tbPast[ s ] = true;\n\tvector< int > pList;\n\tfor( int i = 1; i <= numRooter; ++i ){\n\t\tif( table[ s ][ i ] ){\n\t\t\tif( i == e ){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tbPast[ i ] = true;\n\t\t\tpList.push_back( i );\n\t\t}\n\t}\n\n\tint ttl = initTtl;\n\twhile( pList.size() > 0 ){\n\t\t--ttl;\n\t\tif( ttl < 1 ){\n\t\t\treturn 0;\n\t\t}\n\t\tvector< int > pList2;\n\t\tfor( int i = 0; i < pList.size(); ++i ){\n\t\t\tint p = pList[ i ];\n\t\t\tif( p == e ){\n\t\t\t\treturn initTtl - ttl + 1;\n\t\t\t}\n\t\t\tfor( int j = 1; j <= numRooter; ++j ){\n\t\t\t\tif( table[ p ][ j ] && !bPast[ j ] ){\n\t\t\t\t\tbPast[ j ] = true;\n\t\t\t\t\tpList2.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpList = pList2;\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tint table[ SIZE ][ SIZE ];\n\n\tint n;\n\twhile( cin >> n ){\n\t\tmemset( table, 0, sizeof(table) );\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tint id, numRooter;\n\t\t\tcin >> id >> numRooter;\n\t\t\tfor( int j = 0; j < numRooter; ++j ){\n\t\t\t\tint to;\n\t\t\t\tcin >> to;\n\t\t\t\ttable[ id ][ to ] = true;\n\t\t\t}\n\t\t}\n\t\tint p;\n\t\tcin >> p;\n\t\tfor( int i = 0; i < p; ++i ){\n\t\t\tint from, to, ttl;\n\t\t\tcin >> from >> to >> ttl;\n\t\t\tint result = solve( table, from, to, ttl, n );\n\t\t\tif( result > 0 ){\n\t\t\t\tcout << result << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nvector<int> con[101];\n\n#define INF ((int)1e9)\n\nint bfs(int const S, int const T) {\n  queue<pair<int, int> > q;\n  int cost[101]; fill(cost, cost+100, INF);\n  cost[S] = 0;\n  q.push(make_pair(0, S));\n  while(!q.empty()) {\n    int now = q.front().second;\n    int c = q.front().first; q.pop();\n    int const size = con[now].size();\n    for(int i=0; i<size; i++) {\n      if(cost[con[now][i]]<INF) continue;\n      cost[con[now][i]] = c + 1;\n      //cout <<   \"cost: \" <<   cost[con[now][i]] << endl;\n      q.push(make_pair(c + 1, con[now][i]));\n    }\n  }\n  \n  return cost[T];\n}\n\nint main() {\n  \n  int n; cin >> n;\n  for(int I = 0; I < n; I++) {\n    int r, k;\n    cin >> r >> k; r--;\n    for(int i=0; i<k; i++) {\n      int t; cin >> t; t --;\n      con[r].push_back(t);\n    }\n    // cout << \"con[\"<<r<<\"].size() \" << con[r].size() << endl;\n  }\n  \n  int m; cin >> m;\n  for(int i=0; i<m; i++) {\n    int a, b, ttl; cin >> a >> b >> ttl; a--; b--;\n    int ans;\n    if((ans = bfs(a, b)+1) <= ttl) {\n      cout << ans << endl;\n    }\n    else {\n      cout << \"NA\" << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nvoid show(int** a, int n)\n{\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) std::cout << a[i][j] << \" \";\n\t\tstd::cout <<std::endl;\n\t}\n}\n\nint main()\n{\n\tint n; std::cin >> n;\n\tint** D = new int*[n];\n\tfor (int i=0; i<n; i++) D[i] = new int[n];\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) D[i][j] = (i==j) ? 0 : n;\n\t}\n\tfor (int i=0; i<n; i++) {\n\t\tint s; std::cin >> s;\n\t\tint k; std::cin >> k;\n\t\tfor (int j=0; j<k; j++) {\n\t\t\tint t; std::cin >> t;\n\t\t\tD[s-1][t-1] = 1;\n\t\t}\n\t}\n\t\n\t//show(D, n);\n\t// Floyd-Warshall\n\tfor (int k=0; k<n; k++) {\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tfor (int j=0; j<n; j++) {\n\t\t\t\tD[i][j] = std::min(D[i][j], D[i][k] + D[k][j]);\n\t\t\t}\n\t\t}\n\t\t//std::cout << k << std::endl;\n\t\t//show(D, n);\n\t}\n\t\n\tint p; std::cin >> p;\n\tfor (int i=0; i<p; i++) {\n\t\tint s, t, v;\n\t\tstd::cin >> s >> t >> v;\n\t\tif (D[s-1][t-1] < n && D[s-1][t-1]+1 <= v) std::cout << D[s-1][t-1]+1 << std::endl;\n\t\telse std::cout << \"NA\" << std::endl;\n\t}\n\t\n\tfor (int i=0; i<n; i++) delete[] D[i];\n\tdelete[] D;\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint router[200][200];\nint b[200][200];\n\nint main(void){\n  int N;\n  cin >> N;\n  for(int n=0; n < N; n++){\n    int r, k;\n    cin >> r >> k;\n    for(int i=0; i < k; i++){\n      int tmp; cin >> tmp;\n      b[r][tmp] = 1;\n    }\n  }\n\n\n  int pac_n;\n  cin >> pac_n;\n  for(int p=0; p < pac_n; p++){\n    int start, des, ttl; cin >> start >> des >> ttl;\n    \n    queue<pair<int, int> > que;   //<id, now_ttl>\n    que.push(make_pair(start, ttl));\n    bool flg = false;\n    for(int x = 0; x < N+1; x++){\n      for(int y = 0; y < N+1; y++){\n        router[x][y] = b[x][y];\n      }\n    }\n    while(!que.empty()){\n      pair<int, int> q = que.front(); que.pop();\n      if(q.first == des){\n        cout << ttl - q.second + 1<< endl;\n        flg = true;\n        break;\n      }\n      if(q.second != 1){\n        for(int i=0; i <= N; i++){\n          if(router[q.first][i] == 1){\n            router[q.first][i] = 0;\n            que.push(make_pair(i, q.second - 1));\n          }\n        }\n      }\n    }\n    if(!flg)\n      cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF 1e9\n\nint main() {\n\tint n; cin >> n;\n\tint m[100][100]; fill(&m[0][0], &m[0][0]+100*100, INF);\n\tfor (int i = 0; i < n; ++i) m[i][i] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint r, k; cin >> r >> k; --r;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint t; cin >> t; --t;\n\t\t\tm[r][t] = 1;\n\t\t}\n\t}\n\tfor (int k = 0; k < n; ++k) for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t}\n\tint p; cin >> p;\n\tfor (int k = 0; k < p; ++k) {\n\t\tint s, t; cin >> s >> t; --s, --t;\n\t\tint th; cin >> th;\n\t\tif (m[s][t] < th) cout << m[s][t]+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\n\n\n\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\nint main()\n{\n\tINT(n);\n\tint a[110][110];\n\tFOR(i, 110)FOR(j, 110)a[i][j] = (i != j ? INF:0);\n\tFOR(i, n)\n\t{\n\t\tINT(r);\n\t\tINT(k);\n\t\tFOR(j, k)\n\t\t{\n\t\t\tINT(t);\n\t\t\ta[r][t] = 1;\n\t\t}\n\t}\n\tFOR(k, n+1)FOR(i, n+1)FOR(j, n+1)a[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n\tINT(p);\n\tFOR(i, p)\n\t{\n\t\tINT(s); \n\t\tINT(g);\n\t\tINT(t);\n\t\tif (a[s][g]+1 <= t)cout << a[s][g]+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> NODE;\n#define pos first\n#define ttl second\n\nmap< int,vector<int> > info;\nint bfs(int s,int d,int v){\n\tqueue<NODE> Q;\n\tmap<int,bool>done;\n\t\n\tQ.push( make_pair(s,v));\n\twhile( !Q.empty() ){\n\t\t/* queueツづ個静ヲツ督ェツづ個ノツーツドツづーツ訪ツ姪「ツ催渉づ敖づ可つオツづowツ陛渉青板づ可禿シツづェツ、ツキツδーツつゥツづァツ偲ヲツづィツ渉慊つュ */\n\t\tNODE now = Q.front();\n\t\tQ.pop();\n\t\tdone[now.pos] = true;\n\t\tif(now.pos == d){\n\t\t\treturn now.ttl;\n\t\t}\n\t\tif(now.ttl-1==0)continue;\n\t\tfor(int i=0;i<info[now.pos].size();i++){\n\t\t\tif( !done[info[now.pos][i]] ){\n\t\t\t\tQ.push( make_pair(info[now.pos][i], now.ttl-1) );\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint n,r,k,t;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tinfo[r].push_back(t);\n\t\t}\n\t}\t\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k >> t;\n\t\t \n\t\tif( ~bfs(r,k,t) )cout << t-bfs(r,k,t)+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){\n\t\tttl = current = 0;\n\t}\n\n\tvoid copy(Packet t){\n\t\tttl = t.ttl;\n\t\tcurrent = t.current;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = t.checkTable[i];\n\t}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tif(memo[start][goal] != 0){\n\t\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int d = 1; d <= n; d++){\n\t\t\t\tif(d != start && table[start][d] == 1){\n\t\t\t\t\tif(memo[d][goal] > 0 && memo[d][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[d][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[d][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(d);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp.copy(Q.front());\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.ttl > 0 && tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1 && t_limit-tmp.ttl + 1 <= n){\n\t\t\t\tfor(int m=1; m <= n; m++){\n\t\t\t\t\tif(m != tmp.current && tmp.checkTable[m] == 0 && table[tmp.current][m] == 1){\n\t\t\t\t\t\tPacket q;\n\t\t\t\t\t\tq.copy(tmp);\n\t\t\t\t\t\tq.ttl--;\n\t\t\t\t\t\tq.set(m);\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint router[100][100];\n\nint main(void){\n  int N;\n  cin >> N;\n  for(int n=0; n < N; n++){\n    int r, k;\n    cin >> r >> k;\n    for(int i=0; i < k; i++){\n      int tmp; cin >> tmp;\n      router[r][tmp] = 1;\n    }\n  }\n\n\n  int pac_n;\n  cin >> pac_n;\n  for(int p=0; p < pac_n; p++){\n    int start, des, ttl; cin >> start >> des >> ttl;\n    \n    queue<pair<int, int> > que;   //<id, now_ttl>\n    que.push(make_pair(start, ttl));\n    bool flg = false;\n    while(!que.empty()){\n      pair<int, int> q = que.front(); que.pop();\n      if(q.first == des){\n        cout << ttl - q.second + 1<< endl;\n        flg = true;\n        break;\n      }\n      if(q.second != 1){\n        for(int i=0; i <= N; i++){\n          if(router[q.first][i] == 1){\n            que.push(make_pair(i, q.second - 1));\n          }\n        }\n      }\n    }\n    if(!flg)\n      cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep0(i,n) for(i=0;i<(n);i++)\n#define repp(i,m,n) for(int i=(m);i<(n);i++)\n\n#define PUTLINE cout<<__LINE__<<endl;\n\nvector<int> edges[110];\nint dis[110];\n\nint main() {\n\tint n;\n\tcin>>n;\n\tint r,k;\n\trep(i,n){\n\t\tcin>>r>>k;\n\t\twhile(k--){\n\t\t\tedges[i].push_back(in()-1);\n\t\t}\n\t}\n\tint p;\n\tcin>>p;\n\trep(i,p){\n\t\tint s,d,v;\n\t\tcin>>s>>d>>v;\n\t\ts--;d--;\n\t\trep(j,n)dis[j]=100100100;\n\t\tpriority_queue<pint,vector<pint>,greater<pint> > que;\n\t\tque.push(mp(0,s));\n\t\twhile(!que.empty()){\n\t\t\tpint v=que.top();\n\t\t\tque.pop();\n\t\t\tif(dis[v.second]<=v.first)continue;\n\t\t\tdis[v.second]=v.first;\n\t\t\trep(j,edges[v.second].size()){\n\t\t\t\tque.push(mp(v.first+1,edges[v.second][j]));\n\t\t\t}\n\t\t}\n\t\tif(dis[d]>=v)cout<<\"NA\"<<endl;\n\t\telse cout<<dis[d]+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dis[101][101];\nmain()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)if(i!=j)dis[i][j]=1e9;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint r,k;cin>>r>>k;\n\t\tfor(;k--;)\n\t\t{\n\t\t\tint t;cin>>t;\n\t\t\tdis[r][t]=1;\n\t\t}\n\t}\n\tfor(int k=0;k++<n;)for(int i=0;i++<n;)for(int j=0;j++<n;)\n\t\tdis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n\tint p;cin>>p;\n\tfor(;p--;)\n\t{\n\t\tint s,t,d;cin>>s>>t>>d;\n\t\tif(dis[s][t]<d)cout<<dis[s][t]+1<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Memory Limit ExceededÉÈé\n//[ðñ70kByteögpµÄ¢éçµ¢\n//TvCvbg©Í¤Ü­¢ÁÄ¢éÁÛ¢\n//\n\n\n\n#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nvoid debug();\n\nint main(){\n\n \n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n\n    //  for(int k=0;k<maxx;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  // cout << \"maxx =\" << maxx << endl;\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n\n  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  //debug();\n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0,yes=10001;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  \n  //cout << \"FIRST next.second = \" << c << endl;  \n  //cout << \"FIRST         cal = \" << cal << endl;\n  //cout << \"             maxx = \" << maxx  << endl;\n  //cout << \"               ed = \" << ed << endl;\n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    //  cout << \"pop i = \" << next.first << endl;\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //   cout << \"1:next.first =  \" << next.first << endl;\n    //   cout << \"1:next.second = \" << next.second << endl; \n    \n    for(i=1;i<=maxx;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;\n\n      // cout << \"net[\" << next.first << \"][\" << i <<\"] = \" << net[next.first][i] << endl;\n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\n\t/*\t\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"2:   next.second = \" << next.second << endl; \n\t*/\t\n\n\tif(yes >  (c-next.second+1)){\n\t  yes = (c - next.second)+1;\n\t  //\t  cout << \"change yes = \" << yes << endl;\n\t}\n\t\n      }\n            \n\n      if(net[next.first][i] == 1){\n\tNari.push(BVB(i,next.second));\n\t//\tcout << \"push i = \" << i << endl;\n      }\n      \n  \n    }\n      \n    \n  }\n\n  //  cout << \"return yes = \" << yes << endl; \n\n  if(yes != 10001){return yes;}\n  else return -2;\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\nvoid debug(){\n  for(int i=1;i<=maxx;i++){\n    if(i==1){\n      cout << \"   \";\n      for(int k=1;k<=maxx;k++){\n\tprintf(\"%3d\",k);\n      }\n      cout << endl;\n      for(int k=1;k<=maxx;k++)printf(\"___\");\n      cout << endl;\n    }\n\n    for(int j=1;j<=maxx;j++){\n      if(j == 1)cout << i << \" |\";\n      printf(\"%3d\",net[i][j]);\n    }\n    cout << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[101];\nint s,d,v;\nint s2,d2;\nint kk[100],n;\nbool flg[102] ;\n\nvoid visit(int sn,int dis) {\n  int x;\n  \n  flg[sn+1] = 1;\n  \n  if(sn == d-1 && dis <=v)  md = min(md,dis);\n\n  else if(dis <= v) {\n    for(int i=0;i<ro[sn].size();i++) {\n      \n      if(flg[ro[sn][i]] == 0){\n\t//\tcout <<sn+1 << \"to\"<<ro[sn][i] << endl;\n\tvisit(ro[sn][i]-1,dis+1);\n\tflg[ro[sn][i]] = 0;\n      }\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk[i];\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[i][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n\n\n    for(int i=0;i<=n;i++) flg[i] = 0;\n    md = 10000000;\n   \n    visit(s-1,1);\n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\nint main(){\n  int a,n,m,x,s,d,v,map[200][200][1]={};\n  queue <int> A;\n  cin>>n;\n  for(int i=1;i<=n;i++){\n    cin>>a;\n    cin>>map[i][0][0];\n    for(int j=1;j<=map[i][0][0];j++){\n      cin>>map[i][j][0];\n    }\n  }\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>d>>v;\n    A.push(s);\n    while(1){\n      x=A.front();\n      if(x==d)break;\n      A.pop();\n      for(int j=1;j<=map[x][0][0];j++){\n        if(map[map[x][j][0]][0][1]==0){\n        A.push(map[x][j][0]);\n        map[map[x][j][0]][0][1]=map[x][0][1]+1;\n        }\n      }\n    }\n    if(v>map[x][0][1])printf(\"%d\\n\",map[x][0][1]);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0144 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144)\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#define rep(i,a) for(int i=0;i<(a);++i)\n#define clr(a,v) memset((a),(v),sizeof(a))\n\ntypedef std::pair<int, int> P;\n\nconst int MAX_N = 100;\n\nint n, p;\nstd::vector<int> G[MAX_N];\nbool used[MAX_N];\n\nint bfs( int s, int d, int tl )\n{\n\tclr( used, false );\n\tstd::queue<P> que;\n\tque.push( P( s, 1 ) );\n\n\twhile( !que.empty() )\n\t{\n\t\tP p = que.front(); que.pop();\n\t\tint v = p.first, dep = p.second;\n\n\t\tif( used[v] || dep > tl )\n\t\t\tcontinue;\n\t\tif( v == d )\n\t\t\treturn dep;\n\n\t\tused[v] = true;\n\n\t\trep( i, G[v].size() )\n\t\t{\n\t\t\tint u = G[v][i];\n\n\t\t\tif( !used[u] )\n\t\t\t\tque.push( P( u, dep+1 ) );\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tscanf( \"%d\", &n );\n\trep( i, n )\n\t{\n\t\tint r, k;\n\t\tscanf( \"%d%d\", &r, &k );\n\t\t--r;\n\n\t\trep( j, k )\n\t\t{\n\t\t\tint t;\n\t\t\tscanf( \"%d\", &t );\n\t\t\tG[r].push_back(t-1);\n\t\t}\n\t}\n\n\tscanf( \"%d\", &p );\n\trep( i, p )\n\t{\n\t\tint s, d, v;\n\t\tscanf( \"%d%d%d\", &s, &d, &v );\n\n\t\tint c = bfs( s-1, d-1, v );\n\n\t\tif( ~c )\n\t\t\tprintf( \"%d\\n\", c );\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\nusing namespace std;\n\nconstexpr int INF = (1 << 30) - 1;\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector< vector<int> > g(n);\n        for(int i = 0 ; i < n ; ++i){\n            int r, k;\n            cin >> r >> k;\n            --r;\n            for(int j = 0 ; j < k ; ++j){\n                int t;\n                cin >> t;\n                g[r].push_back(t - 1);\n            }\n        }\n\n        vector< vector<int> > cost(n, vector<int>(n, INF));\n        for(int i = 0 ; i < n ; ++i){\n            cost[i][i] = 1;\n            queue< pair<int, int> > que;\n            que.push({1, i});\n            while(!que.empty()){\n                pair<int, int> now = que.front();\n                que.pop();\n                if(cost[i][now.second] < now.first){\n                    continue;\n                }\n                for(auto to : g[now.second]){\n                    if(cost[i][to] > now.first + 1){\n                        cost[i][to] = now.first + 1;\n                        que.push({now.first + 1, to});\n                    }\n                }\n            }\n        }\n\n        int p;\n        cin >> p;\n\n        while(p--){\n            int s, d, v;\n            cin >> s >> d >> v;\n            --s;\n            --d;\n\n            if(cost[s][d] <= v){\n                cout << cost[s][d] << endl;\n            }else{\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint router[200][200];\nint b[200][200];\n\nint main(void){\n  int N;\n  cin >> N;\n  for(int n=0; n < N; n++){\n    int r, k;\n    cin >> r >> k;\n    for(int i=0; i < k; i++){\n      int tmp; cin >> tmp;\n      b[r][tmp] = 1;\n    }\n  }\n\n\n  int pac_n;\n  cin >> pac_n;\n  for(int p=0; p < pac_n; p++){\n    int start, des, ttl; cin >> start >> des >> ttl;\n    \n    queue<pair<int, int> > que;   //<id, now_ttl>\n    que.push(make_pair(start, ttl));\n    bool flg = false;\n    for(int x = 0; x <= N; x++){\n      for(int y = 0; y <= N; y++){\n        router[x][y] = b[x][y];\n      }\n    }\n    while(!que.empty()){\n      pair<int, int> q = que.front(); que.pop();\n      if(q.first == des){\n        cout << ttl - q.second + 1<< endl;\n        flg = true;\n        break;\n      }\n      if(q.second > 1){\n        for(int i=0; i <= N; i++){\n          if(router[q.first][i] == 1){\n            router[q.first][i] = 0;\n            que.push(make_pair(i, q.second - 1));\n          }\n        }\n      }\n    }\n    if(!flg)\n      cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 5000;\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\nconst int INF = 100000000;\n\nint prevv[MAX_V];\n\nclass Situation{\npublic:\n\tint ttl;\n\tint node;\n\tint dist;\n\n\tSituation();\n\tSituation(int ttl_,int node_,int dist_){\n\t\tttl=ttl_;\n\t\tnode=node_;\n\t\tdist=dist_;\n\t}\n\n\tbool operator<(const Situation &sit)const{\n\t\treturn sit.dist > this->dist;\n\t}\n};\n\nvoid dijkstra(int s,int ttl){\n\tpriority_queue<Situation > que;\n\tfill(d,d+MAX_V,INF);\n\td[s] = 0;\n\tque.push(Situation(ttl,s,0));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.node;\n\t\tif(d[v] < p.dist)\n\t\t\tcontinue;\n\t\tif(p.ttl<=1)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(ttl-1,e.to,d[e.to]));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tint from;\n\t\tcin>>from;\n\t\tint m;\n\t\tcin>>m;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint to;\n\t\t\tcin>>to;\n\t\t\tedge e;\n\t\t\te.cost=1;\n\t\t\te.to=to;\n\t\t\tG[from].push_back(e);\n\t\t}\n\t}\n\tint l;\n\tcin>>l;\n\tfor(int j = 0; j < l; j++){\n\t\tint s,dd,v;\n\t\tcin>>s>>dd>>v;\n\t\tdijkstra(s,v);\n\t\tif(d[dd]==INF)\n\t\t\tcout<<\"NA\"<<endl;\n\t\telse\n\t\t\tcout<<d[dd]+1<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int>rinsetu[100]{};\nunordered_map<int, int>taiou;\nint main() {\n\tint a;\n\tcin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\ttaiou[c] = b;\n\t\tfor (int e = 0; e < d; e++) {\n\t\t\tint f; scanf(\"%d\", &f);\n\t\t\trinsetu[b].push_back(f);\n\t\t}\n\t}\n\tint b; cin >> b;\n\tfor (int c = 0; c < b; c++) {\n\t\tint g, h, i; scanf(\"%d%d%d\", &g, &h, &i);\n\t\tint e[100]{};\n\t\tmemset(e, -1, sizeof(e));\n\t\tqueue<int>Q;\n\t\te[taiou[g]] = 1;\n\t\tQ.push(g);\n\t\twhile (Q.size()) {\n\t\t\tint o = Q.front(); Q.pop();\n\t\t\to = taiou[o];\n\t\t\tif (e[o] > i)break;\n\t\t\tfor (int p : rinsetu[o]) {\n\t\t\t\tif (e[taiou[p]] == -1) {\n\t\t\t\t e[taiou[p]] = e[o] + 1; Q.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (e[taiou[h]] == -1||e[taiou[h]]>i)puts(\"NA\");\n\t\telse cout << e[taiou[h]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nint main(){\n\n  int num,n1,th;\n\n  cin >> n;\n\n\n\n  for(int i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n    for(int j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  \n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c;\n\n\n\n  for(int i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    if(ans(st,ed,c) != -2)cout << ans(st,ed,c) << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n}\n\n\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int yes=10001;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n   \n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; \n    \n    for(int i=1;i<=maxx;i++){\n      \n      if(net[next.first][i] == 1 && i == ed ){ //ツ姪堋的ツ地ツ督楪達\n\n\tif(yes >  (c-next.second+1))yes = (c - next.second)+1;\n\t\n\t\n      }\n            \n      if(net[next.first][i] == 1){\n\tNari.push(BVB(i,next.second));\n\n      }\n      \n    }\n       \n  }\n  if(yes != 10001){return yes;}\n  else return -2; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#define INF (2000000000)\n#define MAX (2000)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\n\n\nint n;\n\nint head[100];\nint to[10000];\nint next[10000];\n\nint d[100];\n\nvoid Search(int now)\n{\n\tfill(d, d + 100, INF);\n\td[now] = 0;\n\t\n\twhile (true){\n\t\tbool f = false;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int e = head[i]; e != -1; e = next[e]){\n\t\t\t\tif (d[i] != INF && d[to[e]] > d[i] + 1){\n\t\t\t\t\td[to[e]] = d[i] + 1;\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!f) break;\n\t}\n}\n\nint main()\n{\n\tmemset(head, -1, sizeof(head));\n\t\n\tint m = 0;\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tint r, k;\n\t\tscanf(\"%d %d\", &r, &k);\n\t\tr--;\n\t\t\n\t\tfor (int j = 0; j < k; j++){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tt--;\n\t\t\t\n\t\t\tnext[m] = head[r];\n\t\t\thead[r] = m;\n\t\t\tto[m] = t;\n\t\t\tm++;\n\t\t}\n\t}\n\t\n\tint p;\n\tscanf(\"%d\", &p);\n\t\n\tfor (int i = 0; i < p; i++){\n\t\tint f, t, v;\n\t\tscanf(\"%d %d %d\", &f, &t, &v);\n\t\tf--; t--;\n\t\t\n\t\tSearch(f);\n\t\t\n\t\tif (d[t] + 1 <= v){\n\t\t\tprintf(\"%d\\n\", d[t] + 1);\n\t\t}\n\t\telse {\n\t\t\tputs(\"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nconst int SIZE = 101;\n\nint solve( int table[ SIZE ][ SIZE ], int s, int e, int initTtl, int numRooter )\n{\n\tif( initTtl < 2 ){\n\t\treturn 0;\n\t}\n\tbool bPast[ SIZE ];\n\tmemset( bPast, 0, sizeof( bPast ) );\n\tbPast[ s ] = true;\n\tvector< int > pList;\n\tfor( int i = 1; i <= numRooter; ++i ){\n\t\tif( table[ s ][ i ] ){\n\t\t\tif( i == e ){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tbPast[ i ] = true;\n\t\t\tpList.push_back( i );\n\t\t}\n\t}\n\n\tint ttl = initTtl;\n\twhile( pList.size() > 0 ){\n\t\t--ttl;\n\t\tif( ttl < 1 ){\n\t\t\treturn 0;\n\t\t}\n\t\tvector< int > pList2;\n\t\tfor( int i = 0; i < pList.size(); ++i ){\n\t\t\tint p = pList[ i ];\n\t\t\tif( p == e ){\n\t\t\t\treturn initTtl - ttl + 1;\n\t\t\t}\n\t\t\tfor( int j = 1; j <= numRooter; ++j ){\n\t\t\t\tif( table[ p ][ j ] && !bPast[ j ] ){\n\t\t\t\t\tbPast[ j ] = true;\n\t\t\t\t\tpList2.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpList = pList2;\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tint table[ SIZE ][ SIZE ];\n\n\tint n;\n\twhile( cin >> n ){\n\t\tcin.ignore( 100, '\\n' );\n\t\tmemset( table, 0, sizeof(table) );\n\t\tstring s;\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tgetline( cin, s );\n\t\t\tint o = s[ 0 ] - '0';\n\t\t\tfor( int j = 4; j < s.size(); j += 2 ){\n\t\t\t\ttable[ o ][ s[ j ] - '0' ] = true;\n\t\t\t}\n\t\t}\n\t\tint p;\n\t\tcin >> p;\n\t\tfor( int i = 0; i < p; ++i ){\n\t\t\tint from, to, ttl;\n\t\t\tcin >> from >> to >> ttl;\n\t\t\tint result = solve( table, from, to, ttl, n );\n\t\t\tif( result > 0 ){\n\t\t\t\tcout << result << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\nusing namespace std;\n\n#define INF 10000000\n\nint n,r,k,t,p,s,d,v;\nvector<pair<int,vector<int> > > vec;\n\nint find(int num){\n\tfor(int i = 0; i < n; i++){\n\t\tif(vec[i].first == num){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint sch(int st, int ed){\n\tint from = find(st);\n\tint to = find(ed);\n\tvector<int> vv = vector<int>(n,INF);\n\tvv[from] = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int vi = 0; vi < n; vi++){\n\t\t\tif(vv[vi] == i - 1){\n\t\t\t\tfor(int j = 0; j < vec[vi].second.size(); j++){\n\t\t\t\t\tint tmp = find(vec[vi].second[j]);\n\t\t\t\t\tif(vv[tmp] == INF){\n\t\t\t\t\t\tvv[tmp] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vv[to];\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tvec = vector<pair<int,vector<int> > >(n);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\",&r,&k);\n\t\tvec[i].first = r;\n\t\tvec[i].second = vector<int>(k);\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tvec[i].second[j] = t;\n\t\t}\n\t}\n\tscanf(\"%d\",&p);\n\tfor(int i = 0; i < p; i++){\n\t\tscanf(\"%d%d%d\",&s,&d,&v);\n\t\tint l = sch(s,d);\n\t\tl += 1;\n\t\tif(l <= v){\n\t\t\tprintf(\"%d\\n\",l);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\twent_num = 1;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t\twent_num++;\n\t}\n\n\tint ttl,checkTable[101],went_num,current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i <= n; i++){\n\t\tfor(int k=1; k <= n; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\n\n\n\t\twhile(!Q.empty() && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 0 && tmp.went_num < n){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+1);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+1;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\n\n\nint main(){\n\n \n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n\n    for(int k=0;k<maxx;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  // cout << \"maxx =\" << maxx << endl;\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n\n  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  \n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; \n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=maxx;i++){\n      if(net[next.first][i] == 1)mem++;  \n\n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ \n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      if(mem == n)break;\n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX_N = 103;\nvector<int> E[MAX_N];\n\n\nint solve(int s, int d, int v) {\n  int vis[MAX_N];\n  queue<int> que;\n  fill(vis, vis+MAX_N, -1);\n  vis[s] = 1;\n  que.push(s);\n  while(!que.empty()) {\n    int p = que.front();\n    que.pop();\n    for(int i = 0; i < E[p].size(); ++i) {\n      int np = E[p][i];\n      if(vis[np] != -1) continue;\n      vis[np] = vis[p] + 1;\n      if(np == d) {\n\tif(v >= vis[np]) return vis[np];\n\telse return -1;\n      }\n      que.push(np);\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    for(int i = 0; i < MAX_N; ++i) E[i].clear();\n    for(int i = 0; i < n; ++i) {\n      int r, k;\n      cin >> r >> k;\n      for(int j = 0; j < k; ++j) {\n\tint t;\n\tcin >> t;\n\tE[r].push_back(t);\n      }\n    }\n    int p;\n    cin >> p;\n    for(int i = 0; i < p; ++i) {\n      int s, d, v;\n      cin >> s >> d >> v;\n      int ans = solve(s,d,v);\n      if(ans == -1) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint main() {\n\tint n, p, r, k, t, s, d, v;\n\tcin >> n;\n\tint m[100][100] = {};\n\trep(i,n) {\n\t\tcin >> r >> k;\n\t\trep(j,k) {\n\t\t\tcin >> t;\n\t\t\tm[r-1][t-1] = 1;\n\t\t}\n\t}\n\tint ret[100][100] = {};\n\trep(i,100) {\n\t\tret[i][i] = 1;\n\t}\n\trep(i,n) {\n\t\tqueue<int> q;\n\t\tq.push(i);\n\t\twhile(!q.empty()) {\n\t\t\tint a = q.front(); q.pop();\n\t\t\trep(j,n) {\n\t\t\t\tif(m[a][j] && ret[i][j]==0) {\n\t\t\t\t\tq.push(j);\n\t\t\t\t\tret[i][j] = ret[i][a]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n) {\n\t\trep(j,n) {\n\t\t\tcout << ret[i][j] << \" \";\n\t\t}\n\t\tcout <<endl;\n\t}\n\tcin >> p;\n\trep(i,p) {\n\t\tcin >> s >> d >> v;\n\t\t--s,--d;\n\t\tif(ret[s][d] > v || ret[s][d] == 0) cout<< \"NA\" << endl;\n\t\telse cout << ret[s][d] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nconst int MAX_N = 110;\n\nvector<vector<int>> dist(MAX_N, vector<int>(MAX_N, 1e9));\nvoid warshall_floyd(int n){\n    for(int k=0; k<n; k++){\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    int n; cin>>n;\n\n    for(int i=0; i<n; i++) dist[i][i] = 0;\n\n    for(int i=0; i<n; i++){\n        int r; cin>>r;\n        r--;\n        int k; cin>>k;\n        while(k--){\n            int t; cin>>t;\n            t--;\n            dist[r][t] = 1;\n        }\n    }\n\n    warshall_floyd(n);\n\n    int q; cin>>q;\n    while(q--){\n        int s, d, v; cin>>s>>d>>v;\n        s--, d--;\n        if(dist[s][d] + 1 <= v){\n            cout << dist[s][d] + 1 << endl;\n        }\n        else{\n            cout << \"NA\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src_, int dst_, Weight weight_) :\n\t\tsrc(src_), dst(dst_), weight(weight_) { }\n\tEdge(int src_, int dst_) :\n\t\tsrc(src_), dst(dst_) {\n\n\t}\n};\npair<bool, vector<Weight>> spfa(const int v_num, const vector<vector<Edge>>&es, const int start) {\n\tvector<Weight>diss(v_num, INT_MAX);\n\tqueue<int>que;\n\tvector<bool>use(v_num);\n\tvector<int>count(v_num);\n\tque.emplace(start);\n\tdiss[start] = 0;\n\twhile (!que.empty()) {\n\t\tint src(que.front());\n\t\tque.pop();\n\t\tuse[src] = false;\n\t\tfor (auto e : es[src]) {\n\t\t\tconst int d = e.dst;\n\t\t\tif (diss[src] + e.weight < diss[d]) {\n\t\t\t\tdiss[d] = diss[src] + e.weight;\n\t\t\t\tif (!use[d]) {\n\t\t\t\t\tuse[d] = true;\n\t\t\t\t\tcount[d]++;\n\t\t\t\t\tif (count[d] >= v_num)return make_pair(false, vector<Weight>());\n\t\t\t\t\tque.emplace(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(true, diss);\n}\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsetmp(vs);\n\t}\n\tCompress(const set<int>&vs) {\n\t\tsetmp(vs);\n\t}\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\tvoid setmp(const set<int>&vs) {\n\t\tint num = 0;\n\t\tfor (auto v : vs) {\n\t\t\tmp[v] = num;\n\t\t\trevmp[num] = v;\n\t\t\tnum++;\n\t\t}\n\t}\n};\n\nint main() {\n\tint N; cin >> N;\n\tvector<vector<Edge>>es(N);\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint r; cin >> r;\n\t\tmp[r] = i;\n\t\trevmp[i] = r;\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint t; cin >> t;\n\t\t\tes[i].push_back(Edge(i, t));\n\t\t}\n\t}\n\tvector<vector<int>>companion(N,vector<int>(N,1e8));\n\tfor (auto& aes : es) {\n\t\tfor (auto&e : aes) {\n\t\t\te.dst = mp[e.dst];\n\t\t\tcompanion[e.src][e.dst] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcompanion[i][i] = 0;\n\t}\n\tfor (int k = 0; k < N; ++k) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tcompanion[i][j] = min(companion[i][k] + companion[k][j], companion[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint P; cin >> P;\n\twhile (P--) {\n\t\tint s, d, v; cin >> s >> d >> v;\n\t\tint ans = companion[mp[s]][mp[d]];\n\t\tif (ans >= v)cout << \"NA\" << endl;\n\t\telse {\n\n\t\t\tcout << ans + 1 << endl;\n\t\t}\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Class ------ //\nclass Graph1 {\npublic:\n\t// ------ Variables ------ //\n\tstatic const int INF = 1000000000;\n\tint V; vector<vector<int> > G;\n\n\t// ------ Constructors ------ //\n\tGraph1() : V(0), G(vector<vector<int> >()) {}\n\tGraph1(int v) : V(v), G(vector<vector<int> >(v)) {}\n\tGraph1(vector<vector<int> > g) : V(g.size()), G(g) {}\n\n\t// ------ Basic Functions ------ //\n\tvoid add1(int v1, int v2) { G[v1].push_back(v2); }\n\tvoid add2(int v1, int v2) { add1(v1, v2); add1(v2, v1); }\n\n\t// ------ Algorithms ------ //\n\tvector<int> dist(int s) {\n\t\tqueue<int> que; que.push(s);\n\t\tvector<int> d(V, INF);\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tif (d[G[u][i]] == INF) {\n\t\t\t\t\td[G[u][i]] = d[u] + 1;\n\t\t\t\t\tque.push(G[u][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n};\nint N, Q, c, u, v; Graph1 G;\nint main() {\n\tscanf(\"%d\", &N); G = Graph1(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &u, &c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tscanf(\"%d\", &v); G.add1(u - 1, v - 1);\n\t\t}\n\t}\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d%d\", &u, &v, &c);\n\t\tint d = G.dist(u - 1)[v - 1] + 1;\n\t\tif (d > c) printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", d);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(100001);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    vector<bool> check(100001, false);\n    queue<int> fq, nq, sq;\n    int cnt = 0;\n    fq.push(s);\n    if (c == 0) {\n        return -1;\n    }\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            if (check[pos]) {\n                continue;\n            } else {\n                check[pos] = true;\n            }\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            }\n            for (int i: g[pos]) {\n                nq.push(i);\n            }\n        }\n        if (c == 0 || nq.empty()) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n        //cout << c << \"====\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\nusing namespace std;\n\n#define INF 1000000000\n\nint d[100][100];\n\nint main()\n{\n  fill((int*)d, (int*)d + 10000, INF);\n  \n  int N;\n  cin >> N;\n  for(int i = 0; i < N; i++)\n  {\n    int r, k, t;\n    cin >> r >> k;\n    for(int j = 0; j < k; j++)\n    {\n      cin >> t;\n      d[r - 1][t - 1] = 1;\n    }\n  }\n\n  for(int k = 0; k < N; k++)\n    for(int i = 0; i < N; i++)\n      for(int j = 0; j < N; j++)\n        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n  int S, D, V, P;\n  cin >> P;\n  for(int i = 0; i < P; i++)\n  {\n    cin >> S >> D >> V;\n    if(d[S - 1][D - 1] < V)\n      cout << d[S - 1][D - 1] + 1 << endl;\n    else\n      cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntypedef std::pair<int, int> pii;\ntypedef std::vector<int> vi;\ntypedef std::vector<double> vd;\ntypedef std::vector<std::string> vs;\ntypedef std::vector<pii> vpii;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { rep(i,v.size()) is >> v[i]; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Array;\ntypedef std::vector<Array> Matrix;\n\nclass Graph {\n  std::vector<Edges> g;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int &src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nmain {\n  int n;\n  cin >> n;\n  Graph g(n);\n  while (n--) {\n    int r, k;\n    cin >> r >> k;\n    --r;\n    while (k--) {\n      int t;\n      cin >> t;\n      --t;\n      g.addArc(r, t);\n    }\n  }\n  n = g.size();\n  Matrix dist(n, Array(n));\n  rep(i, n) {\n    vector<Weight> d = dijkstra<INF>(g, i).first;\n    rep(j, n) dist[i][j] = d[j];\n  }\n  int p;\n  cin >> p;\n  while (p--) {\n    int s, d, v;\n    cin >> s >> d >> v;\n    --s, --d;\n    if (dist[s][d] + 1 > v) {\n      cout << \"NA\" << endl;\n      continue;\n    }\n    cout << dist[s][d] + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> NODE;\n#define pos first\n#define distance second\n\nint n;\nbool info[100][100];\n\nint bfs(int s,int d){\n\tqueue<NODE> Q;\n\tbool done[100]={false};\n\t\n\tQ.push( make_pair(s,0) );\n\twhile( !Q.empty() ){\n\t\tNODE now = Q.front();\n\t\tQ.pop();\n\t\tdone[now.pos] = true;\n\n\t\tif(now.pos == d){\n\t\t\treturn now.distance;\n\t\t}\n\n\t\tfor(int next=0;next<n;next++){\n\t\t\tif(info[now.pos][next] && !done[next]){\n\t\t\t\tQ.push( make_pair(next,now.distance+1) );\n\t\t\t}\n\t\t}\n\t}\n\treturn INT_MAX;\n}\n\nint main(){\n\tint r,k,t,p,s,d,v;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tr--;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\tinfo[r][t] = true;\n\t\t}\n\t}\t\n\t\n\tcin >> p;\n\tfor(int i=0;i<p;i++){\n\t\tcin >> s >> d >> v;\n\t\ts--;d--;\n\t\tif(v > bfs(s,d) )cout << bfs(s,d)+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\nusing namespace std;\n\nint main() {\n  int n, m, t, u, v;\n  int a[100][100];\n  cin >> n;\n  for (int i=0; i<n; i++) {\n    for (int j=0; j<n; j++) {\n      a[i][j] = -1;\n    }\n    a[i][i] = 0;\n  }\n  for (int i=0; i<n; i++) {\n    cin >> t >> u;\n    --t;\n    for (int j=0; j<u; j++) {\n      cin >> v;\n      --v;\n      a[t][v] = 1;\n    }\n  }\n  for (int i=0; i<n; i++) {\n    for (int j=0; j<n; j++) {\n      for (int k=0; k<n; k++) {\n        if (a[j][i] == -1 || a[i][k] == -1) continue;\n        if (a[j][k] == -1) {\n          a[j][k] = a[j][i] + a[i][k];\n        } else if (a[j][k] > a[j][i] + a[i][k]) {\n          a[j][k] = a[j][i] + a[i][k];\n        }\n      }\n    }\n  }\n  cin >> m;\n  for (int i=0; i<m; i++) {\n    cin >> t >> u >> v;\n    --t;\n    --u;\n    if (a[t][u] < v) {\n      cout << a[t][u]+1 << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define SUB 101\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nvoid debug();\n\nint main(){\n\n \n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n\n    for(int k=0;k<maxx;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  // cout << \"maxx =\" << maxx << endl;\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n\n  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  //   debug();\n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=maxx;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;  \n\n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      if(mem == n)break;\n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\nvoid debug(){\n  for(int i=1;i<=10;i++){\n    if(i==1){\n      cout << \"   \";\n      for(int k=1;k<=maxx;k++){\n\tprintf(\"%3d\",k);\n      }\n      cout << endl;\n      for(int k=1;k<=maxx;k++)printf(\"___\");\n      cout << endl;\n    }\n\n    for(int j=1;j<=maxx;j++){\n      if(j == 1)cout << i << \" |\";\n      printf(\"%3d\",net[i][j]);\n    }\n    cout << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bits//stdc++.h>\n#include<functional>\nusing namespace std;\nstruct P{\n\tint cost,pos;\n};\nbool operator<(P a,P b) {return a.cost<b.cost;}\nbool operator>(P a,P b) {return a.cost>b.cost;}\nlong long a[101];\nconst long long inf=800000000;\nvector<long long>e[101];\nint main() {\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint r,k,c;\n\t\tcin>>r>>k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin>>c;\n\t\t\te[r].push_back(c);\n\t\t}\n\t}\n\tint p;\n\tcin>>p;\n\tfor(int z=0;z<p;z++){\n\t\tint s,d,v;\n\t\tcin>>s>>d>>v;\n\t\tfill(a,a+n+1,inf);\n\t\tpriority_queue<P>p;\n\t\tp.push(P{1,s});\n\t\ta[s]=1;\n\t\twhile(!p.empty()){\n\t\t\tP t=p.top();p.pop();\n\t\t\tfor(int i=0;i<(int)e[t.pos].size();i++){\n\t\t\t\tif(a[t.pos]+1<a[e[t.pos][i]]){\n\t\t\t\t\ta[e[t.pos][i]]=a[t.pos]+1;\n\t\t\t\t\tp.push(P{a[t.pos]+1,e[t.pos][i]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(a[d]<=v) cout<<a[d]<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint router[200][200];\nint b[200][200];\n\nint main(void){\n  int N;\n  cin >> N;\n  for(int n=0; n < N; n++){\n    int r, k;\n    cin >> r >> k;\n    for(int i=0; i < k; i++){\n      int tmp; cin >> tmp;\n      b[r][tmp] = 1;\n    }\n  }\n\n\n  int pac_n;\n  cin >> pac_n;\n  for(int p=0; p < pac_n; p++){\n    int start, des, ttl; cin >> start >> des >> ttl;\n    \n    queue<pair<int, int> > que;   //<id, now_ttl>\n    que.push(make_pair(start, ttl));\n    bool flg = false;\n    for(int x = 0; x < N+1; x++){\n      for(int y = 0; y < N+1; y++){\n        router[x][y] = b[x][y];\n      }\n    }\n    while(!que.empty()){\n      pair<int, int> q = que.front(); que.pop();\n      if(q.first == des){\n        cout << ttl - q.second + 1<< endl;\n        flg = true;\n        break;\n      }\n      if(q.second != 1){\n        for(int i=0; i <= N; i++){\n          if(router[q.first][i] == 1){\n            router[q.first][i] = 0;\n            que.push(make_pair(i, q.second - 1));\n          }\n        }\n      }\n    }\n    if(!flg)\n      cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n#include <set>\n\nusing namespace std;\n\ntypedef struct {\n  int *ks;\n  int length;\n} node;\n\nnode *nodes;\n\n\nint dikstra(int s, int e, int deep){\n  int c=0;\n\n  list<int> que;\n  set<int> done;\n  que.push_back(s);\n\n  int flag = 1;\n\n  while(flag){\n    c++;\n    if(c >= deep) return -1;\n\n    int len = que.size();\n    for(int i=0;flag&&i<len;i++){\n      for(set<int>::iterator it = done.begin();it!=done.end();it++) que.remove((*it));\n\n      int v = que.front();\n      que.pop_front();\n      done.insert(v);\n\n      for(int j=0;flag&&j<nodes[v].length;j++){\n        if(nodes[v].ks[j]==e){\n          flag=0;\n        }else{\n          que.push_back(nodes[v].ks[j]);\n        }\n      }\n    }\n  }\n  return c+1;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  nodes = new node[n];\n\n  int i,j;\n  int t,u,v;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\", &t,&u);\n    nodes[t-1].ks = new int[u];\n    nodes[t-1].length = u;\n    for(j=0;j<u;j++){\n      scanf(\"%d\", &v);\n      nodes[t-1].ks[j] = v-1;\n    }\n  }\n\n  int m;\n  scanf(\"%d\", &m);\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\", &t, &u, &v);\n    int r;\n    if((r=dikstra(t-1, u-1,v)) != -1) printf(\"%d\\n\", r);\n    else puts(\"NA\");\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n\tint n,r,k,t,p,s,d,v,vec[101][101];\n\tcin>>n;\n\trep(i,n){\n\t\tvec[i][i]=0;\n\t\trep(j,n)\n\t\t\tvec[i][j]=1000000;\n\t}\n\trep(i,n)\n\t\tvec[i][i]=0;\n\trep(i,n){\n\t\tcin>>r>>k;\n\t\trep(j,k){\n\t\t\tcin>>t;\n\t\t\tvec[r-1][t-1]=1;\n\t\t}\n\t}\n\trep(k,n)\n\trep(i,n)\n\trep(j,n){\n\t\tvec[i][j]=min(vec[i][j],vec[i][k]+vec[k][j]);\n\t}\n\tcin>>p;\n\trep(i,p){\n\t\tcin>>s>>d>>v;\n\t\ts--;\n\t\td--;\n\t\tif(vec[s][d]+1<=v)\n\t\tcout<<vec[s][d]+1<<endl;\n\t\telse\n\t\tcout<<\"NA\"<<endl;\n\t\t\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Packet Transportation\n//Level: 2\n//Category: グラフ,Graph,全点対間最短距離\n//Note:\n\n/**\n * 全点対間の最短距離を求めておけば良い。\n * オーダーは O(N^3)。\n */\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate <typename T>\nstruct Maybe {/*{{{*/\n    T val;\n    bool valid;\n\n    Maybe() : valid(false) {}\n    Maybe(T &t) : val(t), valid(true) {}\n\n    T& operator =(const T &rv) {\n        val = rv;\n        valid = true;\n        return val;\n    }\n\n    operator T() const {\n        return valid ? val : T();\n    }\n\n    template<typename Cond>\n    bool update(const T &v, Cond cond) {\n        if(!valid || cond(v, val)) {\n            val = v;\n            valid = true;\n            return true;\n        }\n        return false;\n    }\n\n    bool update(const T &v) {\n        return update(v, less<T>());\n    }\n};/*}}}*/\n\ntemplate<typename T>\nstruct WarshallFloyd {\n    vector<vector<Maybe<T>>> graph;\n    int N;\n\n    WarshallFloyd(int size) : graph(size), N(size) {\n        for(auto &v : graph) {\n            v.resize(size);\n        }\n    }\n\n    void add_edge(int from, int to, const T &dist) {\n        graph[from][to] = dist;\n    }\n\n    void freeze() {\n        for(int k = 0; k < N; ++k) {\n            for(int i = 0; i < N; ++i) {\n                for(int j = 0; j < N; ++j) {\n                    if(graph[i][k].valid && graph[k][j].valid) {\n                        graph[i][j].update(graph[i][k] + graph[k][j]);\n                    }\n                }\n            }\n        }\n    }\n\n    const Maybe<T>& query(int from, int to) {\n        return graph[from][to];\n    }\n};\n\nbool solve(bool first) {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    WarshallFloyd<int> wf(N);\n    for(int i = 0; i < N; ++i) {\n        int from, k;\n        cin >> from >> k;\n        --from;\n        while(k--) {\n            int v;\n            cin >> v;\n            wf.add_edge(from, v-1, 1);\n        }\n    }\n    wf.freeze();\n    int P;\n    cin >> P;\n    while(P--) {\n        int s, d, t;\n        cin >> s >> d >> t;\n        const auto &dist = wf.query(s-1, d-1);\n        if(dist.valid && dist+1 <= t) {\n            cout << dist+1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(2);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\nusing namespace std;\n\n\nint net[110][110];\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nvoid debug();\n\nint main(){\n\n  for(int k=0;k<110;k++)for(int l=0;l<110;l++)net[k][l]=-1; //Syokika\n\n  int n,i,j,p,num,n1,th;\n\n  cin >> n;\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n\n\n\n    for(int k=0;k<110;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  // debug();\n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n\n    if(next.second < 0)break; //I¹ð\n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=110;i++){//¢¯éêðL[Éüêé\n  \n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      \n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\nvoid debug(){\n  for(int i=1;i<=10;i++){\n    if(i==1){\n      cout << \"   \";\n      for(int k=1;k<=10;k++){\n\tprintf(\"%3d\",k);\n      }\n      cout << endl;\n      for(int k=1;k<=10;k++)printf(\"___\");\n      cout << endl;\n    }\n\n    for(int j=1;j<=10;j++){\n      if(j == 1)cout << i << \" |\";\n      printf(\"%3d\",net[i][j]);\n    }\n    cout << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n    vector<int> to;\n    bool isDone;\n    int cost;\n};\n\nconst int MAX_N = 100;\nNode nodes[MAX_N + 1];\nint n;\n\nint dijkstra(int start, int end) {\n    for (int i = 1; i <= n; i++) {\n        nodes[i].isDone = false;\n        nodes[i].cost = -1;\n    }\n    nodes[start].cost = 0;\n    while (true) {\n        int min_idx = -1;\n        for (int i = 1; i <= n; i++) {\n            if (nodes[i].isDone == true || nodes[i].cost < 0) {\n                continue;\n            }\n            if (min_idx < 0 || nodes[i].cost < nodes[min_idx].cost) {\n                min_idx = i;\n            }\n        }\n        if (min_idx < 0) {\n            break;\n        }\n        nodes[min_idx].isDone = true;\n        int cost = nodes[min_idx].cost + 1;\n        for (vector<int>::iterator it = nodes[min_idx].to.begin(); it != nodes[min_idx].to.end(); it++) {\n            if (nodes[*it].cost < 0 || cost < nodes[*it].cost) {\n                nodes[*it].cost = cost;\n            }\n        }\n    }\n    return nodes[end].cost;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int r, k;\n        cin >> r >> k;\n        for (int j = 0; j < k; j++) {\n            int t;\n            cin >> t;\n            nodes[r].to.push_back(t);\n        }\n    }\n    int p;\n    cin >> p;\n    for (int i = 0; i < p; i++) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int cost = 1 + dijkstra(s, d);\n        if (cost > v) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << cost << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n\tint n,r,k,t,p,s,d,v;\n\tint wf[100][100];\n\trep(i,100)rep(j,100)wf[i][j] = 1<<21;\n\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tr--;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\twf[r][t] = 1;\n\t\t}\n\t}\n\trep(k,n)rep(i,n)rep(j,n)wf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n\t\n\tcin >> p;\n\tfor(int i=0;i<p;i++){\n\t\tcin >> s >> d >> v;\n\t\ts--;d--;\n\t\tif(v > wf[s][d] )cout << wf[s][d]+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\twent_num = 1;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t\twent_num++;\n\t}\n\n\tint ttl,checkTable[101],went_num,current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i <= n; i++){\n\t\tfor(int k=1; k <= n; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\n\n\n\t\twhile(!Q.empty() && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 0 && tmp.went_num < n){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+1);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+1;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\n\nint main(){\n  int n;\n\tcin>>n;\n\tint graph[n][n];\n\tfor(int j=0;j<n;j++)\n\t\tfor(int i=0;i<n;i++){\n\t\t\t\tgraph[j][i] = 10000;\n\t\t}\n\tfor(int i=0;i<n;i++){\n\t\tint k,m,l;\n\t\tcin>>k>>m;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcin>>l;\n\t\t\tgraph[k-1][l-1] = 1;\n\t\t}\n\t}\n\t\n\tfor(int k=0;k<n;k++)\n\t\tfor(int j = 0;j<n;j++)\n\t\t\tfor(int i = 0;i<n;i++)\n\t\t\t\tif(graph[i][j]>graph[i][k]+graph[k][j])\n\t\t\t\t\tgraph[i][j] = graph[i][k]+graph[k][j];\n\tint p;\n\tcin>>p;\n\tfor(int i=0;i<p;i++){\n\t\tint s,d,v;\n\t\tcin>>s>>d>>v;\n\t\tif(graph[s-1][d-1]<v)\n\t\t\tcout<<graph[s-1][d-1]+1<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> NODE;\n#define pos first\n#define distance second\n\nint n;\nbool info[100][100];\n\nint bfs(int s,int d){\n\tqueue<NODE> Q;\n\tbool done[100]={false};\n\t\n\tQ.push( make_pair(s,0) );\n\twhile( !Q.empty() ){\n\t\tNODE now = Q.front();\n\t\tQ.pop();\n\t\tdone[now.pos] = true;\n\n\t\tif(now.pos == d){\n\t\t\treturn now.distance;\n\t\t}\n\n\t\tfor(int next=0;next<n;next++){\n\t\t\tif(info[now.pos][next] && !done[next]){\n\t\t\t\tQ.push( make_pair(next,now.distance+1) );\n\t\t\t}\n\t\t}\n\t}\n\treturn INT_MAX;\n}\n\nint main(){\n\tint r,k,t,p,s,d,v;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tr--;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\tinfo[r][t] = true;\n\t\t}\n\t}\t\n\t\n\tcin >> p;\n\tfor(int i=0;i<p;i++){\n\t\tcin >> s >> d >> v;\n\t\ts--;d--;\n\t\tif(v > bfs(s,d) )cout << bfs(s,d)+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\ntypedef pair<int,int> P;\nconst int INF =100000000;\nint n;\nint d[110][110];\nint main()\n{\n  int r,k;\n  while(cin>>n){\n    for(int i = 0;i < 110;i++){\n      for(int j = 0;j <110;j++){\n\td[i][j]= INF;\n      }\n    }\n    for(int i = 1;i <=n;i++){\n      cin>>r>>k;\n      for(int j = 0;j < k;j++){\n\tint x;\n\tcin>>x;\n\td[r][x] = 1;\n      }\n    }\n    for(int k = 1;k <=n;k++){\n      for(int i = 1;i <=n;i++){\n\tfor(int j = 1;j <=n;j++){\n\t  d[i][j] =min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    int p;\n    cin>>p;\n    int s1,d1,v1;\n    for(int i = 0;i <p;i++){\n      cin>>s1>>d1>>v1;\n      if(d[s1][d1]+1<=v1){\n\tcout <<d[s1][d1]+1<<endl;\n      }else{\n\tcout <<\"NA\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N_MAX = 100;\n\nclass Node {\npublic:\n\tint pos, ttl;\n\tNode(int p, int t) : pos(p), ttl(t) {}\n};\n\nint n;\n// adj[from][to] from->toの辺があるか\nbool adj[N_MAX + 1][N_MAX + 1];\nbool visited[N_MAX + 1];\n\nvoid bfs(int src, int dst, int limit) {\n\tqueue<Node> que;\n\tfill(visited, visited + n + 1, false);\n\tque.push(Node(src, limit - 1));\n\twhile (!que.empty()) {\n\t\tNode current = que.front();\n\t\tque.pop();\n\t\tif (current.pos == dst) {\n\t\t\tcout << limit - current.ttl << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (visited[current.pos]) continue;\n\t\tvisited[current.pos] = true;\n\t\tif (current.ttl == 0) continue;\n\t\tfor (int next = 1; next <= n; next++) {\n\t\t\tif (adj[current.pos][next] && !visited[next]) {\n\t\t\t\tque.push(Node(next, current.ttl - 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfill(adj[r], adj[r] + n + 1, false);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tadj[r][t] = true;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tbfs(s, d, v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\nstruct Edge{\n    int to;\n      long long cost;\n};\n\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nvector<Edge> g[100000],rg[100000];\n\nint N;\nconst ll INF = 1e15;\nvector<ll> dijkstra(vector<Edge> g[100000],int s){\n  priority_queue<NODE> Q;\n  Q.push({s,0});\n  vector<ll> res(N+1,INF);\n  while(Q.size()){\n    NODE q= Q.top();Q.pop();\n    if(res[q.pos] == INF){\n      res[q.pos] = q.cost;\n    }\n    else{\n      continue;\n    }\n    for(auto n : g[q.pos]){\n      Q.push({n.to,q.cost+n.cost});\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n,r,k,t,p;\n  int s,d,v;\n  cin >> n;\n  N = n;\n  REP(i,1,n+1){\n    cin >> r >> k;\n    rep(j,k){\n      cin >> t;\n      g[r].push_back(Edge{t,1});\n    }\n  }\n  cin >> p;\n  rep(i,p){\n    cin >> s >> d >> v;\n    auto rt = dijkstra(g,s);\n//     debug(rt[d]);\n    if(rt[d] >= v){\n      cout << \"NA\"<<endl;\n    }\n    else{\n      cout << rt[d]+1<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define X first\n#define Y second\n#define IND first\n#define Z second.first\n#define V second.second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 101;\n\nbool ok[N][N];\nbool used[N];\nint n, res, vv;\n\nint main(void){\n    cin >> n;\n\n    rep(i, n){\n        int r, k; cin >> r >> k;\n        while(k--){\n            int t; cin >> t;\n            ok[r][t] = true;\n        }\n    }\n\n    int p; cin >> p;\n    while(p--){\n        int s, d; cin >> s >> d >> vv;\n        res = INF;\n        COUNT(i, N) used[i] = false;\n\n        queue< pair<int, pii> > q;\n        q.push(mp(s, mp(d, vv)));\n\n        while(!q.empty()){\n            pair<int, pii> cur = q.front();\n            q.pop();\n\n            if(cur.IND == cur.Z){\n                res = vv - cur.V + 1;\n                break;\n            }\n            cur.V--;\n            if(!cur.V || used[cur.IND]) continue;\n            used[cur.IND] = true;\n\n            COUNT(i, N)\n                if(ok[cur.IND][i]){\n                    pair<int, pii> next = mp(i, mp(cur.Z, cur.V));\n                    q.push(next);\n                }\n        }\n     \n        if(res == INF) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(100001);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    vector<bool> check(101, false);\n    queue<int> fq, nq, sq;\n    int cnt = 0;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            if (check[pos]) {\n                continue;\n            } else {\n                check[pos] = true;\n            }\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            }\n            for (int i: g[pos]) {\n                nq.push(i);\n            }\n        }\n        if (c == 0 || nq.empty()) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n        //cout << c << \"====\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAX_N 110\n#define INF (1<<30)\nint rooter_num;\nstruct Node\n{\n  vector<int> edges_to;\n  vector<int> edges_cost;\n  \n  bool done;\n  int cost;\n};\nint dijkstra(int,int);\nvector<Node> A;\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  int a;\n  Node node;\n  /*------------input---------------*/\n  cin>>rooter_num;\n  for(int i=0;i<=rooter_num;i++)\n    {\n      A.push_back(node);\n    }\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r].edges_to.push_back(t);\n\t  A[r].edges_cost.push_back(1);\n\t}\n    }\n  cout<<\"edges_to=\"<<A[1].edges_to[0]<<endl;\n  /*--------------------------------*/\n\n\n  /*-------------search-------------*/\n  cin>>n;\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      a=dijkstra(startNode,goalNode);\n      if(TTL>a)cout<<a+1<<endl;\n      else cout<<\"NA\"<<endl;\n    }\n  /*--------------------------------*/\n  return 0;\n}\nint dijkstra(int start,int goal)\n{\n  int min;\n\n  /*-----init----*/\n  for(int i=0;i<=rooter_num;i++)\n    {\n      A[i].done=false;\n      A[i].cost=INF;\n    }\n  A[start].cost=0;\n  /*-------------*/\n  \n  \n  while(true)\n    {\n      min=INF;\n      for(int i=1;i<rooter_num;i++)\n\t{\n\t  if(A[i].done==false&&min>A[i].cost)\n\t    {\n\t      min=A[i].cost;\n\t    }\n\t}\n      if(min==INF)break;\n      /*\n\t確定ノードでなく,かつ現在一番累計コストの低いノードを探した\n      */\n\n\n      for(int currentNode=1;currentNode<rooter_num;currentNode++)\n\t{\n\t  if(A[currentNode].cost==min)\n\t    {\n\t      A[currentNode].done=true;\n\t      /*\n\t\t上で確定したノードを見つけ出し,マークした。\n\t      */\n\n\t      for(int i=0;i<A[currentNode].edges_to.size();i++)\n\t\t{\n\t\t  int nextNode=A[currentNode].edges_to[i];\n\t\t  \n\t\t  if(A[nextNode].cost>A[currentNode].edges_cost[i]+A[currentNode].cost)\n\t\t    {\n\t\t      A[nextNode].cost=A[currentNode].edges_cost[i]+A[currentNode].cost;\n\t\t    }  \n\t\t}\n\t      /*\n\t\t確定したノードから飛び,現在までの最小累計コストより\n\t\t低くなる場合は最小累計コストを更新する\n\t      */\n\t    }\n\t  \n\t}\n      \n    }\n  \n  return A[goal].cost;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nconst int SIZE = 101;\n\n\nclass Packet\n{\npublic:\n\tPacket( int _now, set< int > _via ) : now( _now ), via( _via ){}\n\tbool isPast( int p )\n\t{\n\t\tif( via.find( p ) != via.end() ){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint now;\n\tset< int > via;\n};\n\nint solve( int table[ SIZE ][ SIZE ], int s, int e, int initTtl, int numRooter )\n{\n\tif( initTtl < 2 ){\n\t\treturn 0;\n\t}\n\tvector< Packet > pList;\n\tfor( int i = 1; i <= numRooter; ++i ){\n\t\tset< int > via;\n\t\tvia.insert( s );\n\t\tif( table[ s ][ i ] ){\n\t\t\tif( i == e ){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tset< int > via2 = via;\n\t\t\tvia2.insert( i );\n\t\t\tpList.push_back( Packet( i, via2 ) );\n\t\t}\n\t}\n\n\tint ttl = initTtl - 1;\n\twhile( pList.size() > 0 ){\n\t\t--ttl;\n\t\tif( ttl < 1 ){\n\t\t\treturn 0;\n\t\t}\n\t\tvector< Packet > pList2;\n\t\tfor( int i = 0; i < pList.size(); ++i ){\n\t\t\tPacket& p = pList[ i ];\n\t\t\tfor( int j = 1; j <= numRooter; ++j ){\n\t\t\t\tif( table[ p.now ][ j ] && !p.isPast( j ) ){\n\t\t\t\t\tif( j == e ){\n\t\t\t\t\t\treturn initTtl - ttl + 1;\n\t\t\t\t\t}\n\t\t\t\t\tset< int > via = p.via;\n\t\t\t\t\tvia.insert( j );\n\t\t\t\t\tpList2.push_back( Packet( j, via ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpList = pList2;\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tint table[ SIZE ][ SIZE ];\n\n\tint n;\n\twhile( cin >> n ){\n\t\tcin.ignore( 100, '\\n' );\n\t\tmemset( table, 0, sizeof(table) );\n\t\tstring s;\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tgetline( cin, s );\n\t\t\tint o = s[ 0 ] - '0';\n\t\t\tfor( int j = 2; j < s.size(); j += 2 ){\n\t\t\t\ttable[ o ][ s[ j ] - '0' ] = true;\n\t\t\t}\n\t\t}\n\t\tint p;\n\t\tcin >> p;\n\t\tfor( int i = 0; i < p; ++i ){\n\t\t\tint from, to, ttl;\n\t\t\tcin >> from >> to >> ttl;\n\t\t\tint result = solve( table, from, to, ttl, n );\n\t\t\tif( result > 0 ){\n\t\t\t\tcout << result << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int maxv=1<<32;\nint main()\n{\n\tint root[101][101];\n\tfor(int i=0;i<10;i++){\n\t\tfor(int i2=0;i2<10;i2++){\n\t\t\troot[i][i2]=maxv;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tint r,k,ch;\n\tcin>>r>>k;\n\t\tfor(int i2=0;i2<k;i2++){\n\t\t\tcin>>ch;\n\t\t\troot[r][ch]=1;\n\t\t}\n\t}\n\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int i2=01;i2<=n;i2++){\n\t\t\t\troot[i][i2]=min(root[i][i2],root[i][k]+root[k][i2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint m;\n\tint s,d,v;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>s>>d>>v;\n\t\tif(root[s][d]<v){\n\t\t\tcout<<root[s][d]+1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint cost[100][100];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tmemset(cost, 0x3f, sizeof(cost));\n\trep(i, n) {\n\t\tint r, k; scanf(\"%d%d\", &r, &k);\n\t\tr--;\n\t\trep(j, k) {\n\t\t\tint t; scanf(\"%d\", &t);\n\t\t\tcost[r][--t] = 1;\n\t\t}\n\t}\n\tfor (int k = 0; k < n; k++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\tint p; scanf(\"%d\", &p);\n\trep(i, p) {\n\t\tint s, d, v; scanf(\"%d%d%d\", &s, &d, &v);\n\t\ts--; d--;\n\t\tif (cost[s][d] >= v)puts(\"NA\");\n\t\telse printf(\"%d\\n\", cost[s][d] + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, P;\nint d[100][100];\n\nint main(){\n    std::cin >> N;\n\n    REP(i, 100){\n        REP(j, 100){\n            if(i == j){d[i][j] = 0;}\n            else{d[i][j] = INF;}\n        }\n    }\n\n    REP(i, N){\n        int from, k;\n        std::cin >> from >> k;\n        --from;\n        \n        REP(j, k){\n            int to;\n            std::cin >> to;\n            --to;\n            \n            d[from][to] = 1;\n        }\n    }\n\n    REP(k, N){\n        REP(i, N){\n            REP(j, N){\n                d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    std::cin >> P;\n    REP(i, P){\n        int s, t, ttl;\n        std::cin >> s >> t >> ttl;\n        --s; --t;\n\n        if(d[s][t] == INF || d[s][t] >= ttl){\n            puts(\"NA\");\n        }else{\n            printf(\"%d\\n\", d[s][t] + 1);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n#define M 1000\ntypedef pair<pair<int, int>, int > P;\n\nvoid disp_p (P p )\n{\n\tint from = p.first.first;\n\tint to   = p.first.second;\n\tint ttl  = p.second;\n\n\tcout << \"from: \" << from << \" to: \" << to << \" ttl: \" << ttl << endl;\n}\n\n// ツパツケツッツトツつェツ経ツ由ツつキツづゥツδ仰ーツタツづ個催短ツ仰猟猟」ツづーツダツイツクツスツトツδ可づ仰づ淞づゥツ。\n// ttl >= ツ個仰嘉環づ按づァ ツ個仰嘉環づーツ陛板つキ\n// ttl < ツ個仰嘉環づ按づァ -1 ツづーツ陛板つキ\nint dijkstra (P packet, vector <vector <int> > t )\n{\n\tint from = packet.first.first;\n\tint to   = packet.first.second;\n\tint ttl  = packet.second;\n\tint res  = 0;\n\tint size = t.size();\n\tvector <int> d (size, M );\n\tvector <bool> v (size, false );\n\tint i,p;\n\n\tv[0] = true;\n\td[from] = 1;\n\n\t// for debug\n//\tdisp_p (packet );\n\n\tdo{\n\t\tint mind = M;\n\t\tfor (i = 1; i < size; ++i){\n\t\t\tif (!v[i] && mind > d[i] ){\n\t\t\t\tmind = d[i];\n\t\t\t\tp = i;\n\t\t\t} // end if\n\t\t} // end for\n\t\t\n\t\tv[p] = true;\n\n\t\tfor (i = 1; i < size; ++i){\n\t\t\tif ( d[p] + t[p][i] < d[i] ){\n\t\t\t\td[i] = d[p] + t[p][i];\n\t\t\t} // end if\n\t\t} // end for\n\t} while ((int)count (v.begin(), v.end(), true ) != size );\n\n\t// for debug\n/*\n\tfor (i = 0; i < size; ++i ){\n\t\tcout << d[i] << ' ';\n\t} // end for\n\tcout << endl;\n*/\t\n\n\tif (d[to] <= ttl ){\n\t\tres = d[to];\n\t}else{\n\t\tres = -1;\n\t} // end if\n\n\treturn res;\n}\n\ntemplate<class T> void disp_t (vector <T> t )\n{\n\tint size = t.size();\n\tint i,j;\n\n\tfor (i = 0; i < size; ++i){\n\t\tfor (j = 0; j < size; ++j){\n\t\t\tif (t[i][j] == M ){\n\t\t\t\tcout << \" 0\";\n\t\t\t}else{\n\t\t\t\tcout << setw(2) << t[i][j];\n\t\t\t} // end if\n\t\t} // end for\n\t\tcout << endl;\n\t} // end for\n}\n\t\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.packet\", \"r\", stdin );\n\tstring str = \"\";\n\tstring res = \"\";\n\tint n;\n\n\tgetline (cin, str );\n\tstringstream ssn(str);\n\tssn >> n;\n\n\tvector <vector <int> > t (n+1, vector <int> (n+1, M) );\n\n\tint i,j;\n\tfor (i = 0; i < n; ++i){\n\t\tint from, num, to;\n\t\tgetline (cin, str );\n\t\tstringstream ss(str);\n\n\t\tss >> from >> num;\n\t\tfor (j = 0; j < num; ++j){\n\t\t\tss >> to;\n\t\t\tt[from][to] = 1;\n\t\t} // end for\n\t} // end for\n\t\n\t// for debug\n//\tdisp_t (t );\n\n\tint p;\n\tgetline (cin, str );\n\tstringstream ssp (str );\n\tssp >> p;\n\t\n\tfor (i = 0; i < p; ++i){\n\t\tP packet;\n\t\tint from, to , ttl;\n\t\tgetline (cin, str );\n\t\tstringstream ss (str );\n\t\tss >> from >> to >> ttl;\n\t\n\t\tpacket.first.first = from;\n\t\tpacket.first.second = to;\n\t\tpacket.second = ttl;\n\n\t\tint res = dijkstra (packet, t );\n\n\t\tif (res == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << res << endl;\n\t\t} // end if\n\t} // end for\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> NODE;\n\nmap< int,vector<int> > info;\n\nint bfs(int s,int d){\n\tqueue<NODE> Q;\n\t\n\tmap<int,bool>done;\n\t\n\t\n\tQ.push( make_pair(s,0) );\n\n\twhile(!Q.empty()){\n\t\tNODE now = Q.front();\n\t\tQ.pop();\n\t\tdone[now.first] = true;\n\t\tif(now.first == d){\n\t\t\treturn now.second;\n\t\t}\n\t\tfor(int i=0;i<info[now.first].size();i++){\n\t\t\tif(!done[info[now.first][i]])\n\t\t\t\tQ.push( make_pair(info[now.first][i],now.second+1));\n\t\t}\n\t}\n\treturn INT_MAX;\n}\n\nint main(){\n\tint n,r,k,t;\n\tint p,s,d,v;\n\t\n\tcin >> n;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tinfo[r].push_back(t);\n\t\t}\n\t}\n\t\n\tcin >> p;\n\t\n\tfor(int i=0;i<p;i++){\n\t\tcin >> s >> d >> v;\n\t\tif(v > bfs(s,d) )cout << bfs(s,d)+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\nconst int INF = 10000000;\nint wf[101][101];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\twf[i][j] = i == j ? 0 : INF;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tint a, t;\n\t\tcin >> a >> t;\n\t\twhile(t--) {\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\twf[a][b] = 1;\n\t\t}\n\t}\n\n\tfor(int k = 1; k <= n; k++)\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\tint q;\n\tcin >> q;\n\twhile(q--) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tif(wf[s][d] >= v) {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << wf[s][d] + 1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcRouterSum(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER)\n\t{\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL)\n\t{\n\t\t//printf(\"start:%d,goal:%d,TTL:%d\\n\",i4StartRouter,i4GoalRouter,i4TTL);\n\t\ti4Ans = CalcRouterSum(i4StartRouter,i4GoalRouter,i4TTL,1);\n\t\tif(i4Ans >= i4TTL+1){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\t//printf(\"--------------\\n\");\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcRouterSum(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum)\n{\n\t//(\"%d -> %d,TTL=%d\\n\",i4Sender,i4Destination,i4TTL);\n\tI4 i4RoopCnt1;\n\tI4 i4MinRouterNum;\n\tI4 i4TmpRouterSum;\n\tI4 i4Return;\n\t\n\t\n\ti4Return = i4TTL+i4RouterSum;\n\t\n\tif(i4Sender == i4Destination)\n\t{\n\t\t//printf(\"RouterSum=%d\\n\",i4RouterSum);\n\t\treturn i4RouterSum;\n\t}\n\telse\n\t{\n\t\tif(i4TTL <= 0)\n\t\t{\n\t\t\t//printf(\"TTL is 0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti4RoopCnt1 = 1;\n\t\t\twhile(u1Connect[i4Sender][i4RoopCnt1] != SENTINEL){\n\t\t\t\tif(u1Connect[i4Sender][i4RoopCnt1] == CONNECT)\n\t\t\t\t{\n\t\t\t\t\ti4TmpRouterSum = CalcRouterSum(i4RoopCnt1,i4Destination,i4TTL-1,i4RouterSum+1);\n\t\t\t\t\tif((i4TmpRouterSum > 0 ) && (i4TmpRouterSum < i4Return))\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"CalcRouterSum()=%d\\n\",i4TmpRouterSum);\n\t\t\t\t\t\ti4Return = i4TmpRouterSum;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\ti4RoopCnt1++;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn i4Return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main()\n{\n  int n;\n  int node[100][100];\n  cin>>n;\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      node[i][j]=0;\n  \n  \n  for(int x=0;x<n;x++)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      queue<P> qu;\n      while(!qu.empty())\n\t{\n\t  qu.pop();\n\t}\n      int ans=-1;\n      bool move[n+1];\n      if(v>1)\n\t{\n\t  for(int i=0;i<=n;i++)\n\t    {\n\t      if(node[s][i]==1)\n\t\tqu.push(P(i,2));\n\t    }\n\t  for(int i=0;i<=n;i++)\n\t    {\n\t      move[i]=true;\n\t    }\n\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  //\t  cout<<\"Queue:\"<<a.first<<\"  \"<<a.second<<endl;\n\t  if(a.first==d)\n\t    {\n\t      ans = a.second;\n\t      break;\n\t    }\n\t  for(int i=1;i<=n;i++)\n\t    {\n\t      if(node[a.first][i]==1)\n\t\t{\n\t\t  if(move[i] && a.second+1<=v)\n\t\t    {\n\t\t      qu.push(P(i,a.second+1));\n\t\t      move[i]=false;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main()\n{\n  int n;\n  int node[100][100];\n  cin>>n;\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      node[i][j]=0;\n  \n  \n  for(int x=0;x<n;x++)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t  //\t  cout<<node[k][tmp]<<endl;\n\t  //  cout<<\"nodeadd:\"<<k<<\" \"<<tmp<<endl;\n\t}\n    }\n  for(int i=0;i<=n;i++,cout<<endl)\n     for(int j=0;j<=n;j++)\n       cout<<node[i][j]<<\"  \";\n\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      queue<P> qu;\n      int ans=-1;\n      for(int i=0;i<=n;i++)\n\t{\n\t  if(node[s][i]==1)\n\t    {\n\t      qu.push(P(i,2));\n\t    }\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  if(a.second>v)\n\t    break;\n\t  if(a.first==d)\n\t    {\n\t      ans = a.second;\n\t      break;\n\t    }\n\t  for(int i=0;i<=n;i++)\n\t    {\n\t      if(node[a.first][i]==1)\n\t\tqu.push(P(i,a.second+1));    \n\t      \n\t    }\n\t}\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[100][100];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<100;i++)\n\t\tfor(int j=0;j<100;j++)\n\t\t\tg[i][j]=9999;\n\tfor(int i=0;i<a;i++)\n\t\tg[i][i]=0;\n\tfor(int i=0;i<a;i++){\n\t\tint b,c;\n\t\tscanf(\"%d%d\",&b,&c);\n\t\tfor(int j=0;j<c;j++){\n\t\t\tint d;\n\t\t\tscanf(\"%d\",&d);\n\t\t\tg[b-1][d-1]=1;\n\t\t}\n\t}\n\tfor(int k=0;k<a;k++)\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\tscanf(\"%d\",&a);\n\twhile(a--){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tif(r<=g[p-1][q-1])printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",g[p-1][q-1]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define INF 1000000000\n\nusing namespace std;\n\nint N;\nint cost[128][128];\nint d[128];\nbool used[128];\n\nvoid dijkstra(int s){\n\t//ツ渉可甘コツ可サ\n\tfor(int i= 0; i < 128; i++){\n\t\td[i] = INF;\n\t\tused[i] = false;\n\t}\n\t\n\td[s] = 0;\n\t\n\twhile(true){\n\t\tint v = -1;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(!used[i] && (v == -1 || d[i] < d[v]))v = i;\n\t\t}\n\t\t\n\t\tif(v == -1)break;\n\t\t\n\t\tused[v] = true;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\td[i] = min(d[i],d[v] + cost[v][i]);\n\t\t}\n\t}\n}\n\t\n\n\n\n\n\nint main(void){\n\t\n\twhile(scanf(\"%d\", &N) != EOF){\n\t\tint P;\n\t\tint r1,k1,t;\n\t\tint s1,d1,v1;\n\t\t\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int j = 0; j < 128; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ツδ仰ーツタツづ個禿偲ヲ\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d\", &r1, &k1);\n\t\t\tfor(int j = 0; j < k1; j++){\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tcost[r1][t]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ツパツケツッツトツづ個禿偲ヲ\n\t\tscanf(\"%d\", &P);\n\t\tfor(int i = 0; i < P; i++){\n\t\t\tscanf(\"%d%d%d\", &s1, &d1, &v1);\n\t\t\tdijkstra(s1);\n\t\t\t\n//\t\t\tfor(int j = 1; j < N; j++)printf(\"%d\\n\", d[i]);\n\t\t\tif(v1 - d[d1] > 0){\n\t\t\t\tprintf(\"%d\\n\",d[d1]+1);\n\t\t\t}else {\n\t\t\t\tputs(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/10/02 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tint G[100][100];\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<n; j++)\n\t\t\tif(i==j)\n\t\t\t\tG[i][j] = 0;\n\t\t\telse\n\t\t\t\tG[i][j] = -1;\n\n\tfor(int i=0; i<n; i++){\n\t\tint r;\n\t\tcin >> r;\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j=0; j<k; j++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tG[r-1][t-1] = 1;\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++)\n\t\t\tcout << G[i][j] << ' ';\n\t\tcout << endl;\n\t}\n*/\n\n\tfor(int k=0; k<n; k++)\n\t\tfor(int i=0; i<n; i++)\n\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\tif(G[i][k]==-1||G[k][j]==-1)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if(G[i][j]==-1||(G[i][j]>G[i][k]+G[k][j]))\n\t\t\t\t\tG[i][j] = G[i][k]+G[k][j];\n\n\tint p;\n\tcin >> p;\n\n\tfor(int i=0; i<p; i++){\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\n\t\tif(G[s-1][d-1]==-1){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(v>=G[s-1][d-1]+1)\n\t\t\tcout << G[s-1][d-1]+1 << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\n#include<queue>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 108;\nbool isConnect[N][N];\n\nint MinRoot(int from,int to,int rootNum)\n{\n\tint distance[N],i;\n\tfill(distance,distance+N,INT_MAX);\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tq.push(make_pair(from,1));\n\twhile(!q.empty())\n\t{\n\t\tp=q.front(); q.pop();\n\t\tif(distance[p.first] <= p.second) continue;\n\n\t\tdistance[p.first] = p.second;\n\n\t\tfor(i=1; i<=rootNum; ++i)\n\t\t{\n\t\t\tif(isConnect[p.first][i])\n\t\t\t{\n\t\t\t\tq.push(make_pair(i,p.second+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn distance[to];\n}\nint main()\n{\n\tint n,connectCount,fromRooterNum,toRooterNum,i,j,p,ttl;\n\n\tfor(i=0;i<N;++i) for(j=0;j<N;++j) isConnect[i][j] = false;\n\n\tscanf(\"%d\",&n);\n\tfor(i=0; i<n; ++i)\n\t{\n\t\tscanf(\"%d%d\",&fromRooterNum,&connectCount);\n\t\tfor(j=0; j<connectCount; ++j)\n\t\t\tscanf(\"%d\",&toRooterNum),isConnect[fromRooterNum][toRooterNum]=true;\n\t}\n\tscanf(\"%d\",&p);\n\tfor(i=0;i<p;++i)\n\t{\n\t\tscanf(\"%d%d%d\",&fromRooterNum,&toRooterNum,&ttl);\n\t\tint minRooter = MinRoot(fromRooterNum,toRooterNum,n);\n\t\tif(minRooter>ttl) puts(\"NA\");\n\t\telse printf(\"%d\\n\",minRooter);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,p;\n  unsigned int dis[101][101];\n  int r,k,t;\n  int s,d,v;\n\n  cin >> n;\n\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      dis[i][j] = (1<<30);\n      if(i==j)dis[i][j] = 0;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      dis[r][t] = 1;\n    }\n  }\n\n  for(int x=1;x<=n;x++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++)dis[i][j] = min(dis[i][j],dis[i][x] + dis[x][j]);\n    }\n  }\n\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> v;\n    if(dis[s][d]+1>v)cout << \"NA\" << endl;\n    else cout << dis[s][d]+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\ntypedef vector<int> vi;\n\nconst int inf=1<<29;\n\nint graph[110][110];\n\nint main(void){\n\trep(i,110)rep(j,110) graph[i][j]=inf;\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tint f;\n\t\tcin >> f; f--;\n\t\tint num;\n\t\tcin >> num;\n\t\trep(j,num){\n\t\t\tint t;\n\t\t\tcin >> t; t--;\n\t\t\tgraph[f][t]=1;\n\t\t}\n\t}\n\trep(k,n)rep(i,n)rep(j,n) graph[i][j]=min( graph[i][j] , graph[i][k]+ graph[k][j]);\n\tint p;\n\tcin >> p;\n\trep(i,p){\n\t\tint s,t,v;\n\t\tcin >> s >> t >> v;\n\t\tint res=graph[s-1][t-1]+1;\n\t\tif(v>=res)\n\t\t\tcout << res <<endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N_MAX = 100;\nconst int INF = 0x7fffff;\n\nclass Node {\npublic:\n\tint pos, ttl;\n\tNode(int p, int t) : pos(p), ttl(t) {}\n};\n\nint n;\n// adj[from][to] from->toの辺があるか\nbool adj[N_MAX + 1][N_MAX + 1];\nint visited[N_MAX + 1];\n\nvoid bfs(int src, int dst, int limit) {\n\tqueue<Node> que;\n\tfill(visited, visited + n + 1, INF);\n\tque.push(Node(src, limit - 1));\n\twhile (!que.empty()) {\n\t\tNode current = que.front();\n\t\tque.pop();\n\t\tif (current.pos == dst) {\n\t\t\tcout << limit - current.ttl << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (current.ttl >= 0 && visited[current.pos] <= current.ttl) continue;\n\t\tvisited[current.pos] = current.ttl;\n\t\tif (current.ttl == 0) continue;\n\t\tfor (int next = 1; next <= n; next++) {\n\t\t\tif (adj[current.pos][next] && visited[next] > current.ttl) {\n\t\t\t\tque.push(Node(next, current.ttl - 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfill(adj[r], adj[r] + n + 1, false);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tadj[r][t] = true;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tbfs(s, d, v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n#define M 100000000\n\n// ツパツケツッツトツつェツ経ツ由ツつキツづゥツδ仰ーツタツづ個催短ツ仰猟猟」ツづーツダツイツクツスツトツδ可づ仰づ淞づゥツ。\n// ttl >= ツ個仰嘉環づ按づァ ツ個仰嘉環づーツ陛板つキ\n// ttl < ツ個仰嘉環づ按づァ -1 ツづーツ陛板つキ\nint dijkstra (int from ,int to, vector <vector <int> > t )\n{\n\tint size = t.size();\n\tvector <int> d (size, M );\n\tvector <bool> v (size, false );\n\tint i,p;\n\n\td[from] = 1;\n\n\tint mind = M;\n\n\tdo{\n\t\tmind = M;\n\t\tfor (i = 1; i < size; ++i){\n\t\t\tif (!v[i] && mind > d[i] ){\n\t\t\t\tmind = d[i];\n\t\t\t\tp = i;\n\t\t\t} // end if\n\t\t} // end for\n\t\t\n\t\tv[p] = true;\n\n\t\tfor (i = 1; i < size; ++i){\n\t\t\tif ( d[p] + t[p][i] < d[i] ){\n\t\t\t\td[i] = d[p] + t[p][i];\n\t\t\t} // end if\n\t\t} // end for\n\t} while (mind != M );\n\t\n\n\treturn d[to];\n}\n\t\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.packet\", \"r\", stdin );\n\tstring str = \"\";\n\tstring res = \"\";\n\tint n;\n\n\tgetline (cin, str );\n\tstringstream ssn(str);\n\tssn >> n;\n\n\tvector <vector <int> > t (n+1, vector <int> (n+1, M) );\n\tvector <vector <int> > memo (n+1, vector <int> (n+1, M ) );\n\tint i,j;\n\tfor (i = 0; i < n; ++i){\n\t\tint from, num, to;\n\t\tgetline (cin, str );\n\t\tstringstream ss(str);\n\n\t\tss >> from >> num;\n\t\tfor (j = 0; j < num; ++j){\n\t\t\tss >> to;\n\t\t\tt[from][to] = 1;\n\t\t} // end for\n\t} // end for\n\t\n\n\tfor (i = 1; i <= n; ++i){\n\t\tfor (j = 1; j <= n; ++j){\n\t\t\tif (i != j ){\n\t\t\t\tmemo[i][j] = dijkstra (i, j, t );\n\t\t\t} // end if\n\t\t}  // end for\n\t} // end for\n\n\n\tint p;\n\tgetline (cin, str );\n\tstringstream ssp (str );\n\tssp >> p;\n\t\n\tfor (i = 0; i < p; ++i){\n\t\tint from, to , ttl;\n\t\tgetline (cin, str );\n\t\tstringstream ss (str );\n\t\tss >> from >> to >> ttl;\n\t\n\t\tint res = -1;\n\t\tif (memo[from][to] <= ttl ){\n\t\t\tres = memo[from][to];\n\t\t}else{\n\t\t\tres = -1;\n\t\t} // end if\t\t\n\n\t\tif (res == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << res << endl;\n\t\t} // end if\n\t} // end for\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Class ------ //\nclass Graph1 {\npublic:\n\t// ------ Variables ------ //\n\tstatic const int INF = 1000000000;\n\tint V; vector<vector<int> > G;\n\n\t// ------ Constructors ------ //\n\tGraph1() : V(0), G(vector<vector<int> >()) {}\n\tGraph1(int v) : V(v), G(vector<vector<int> >(v)) {}\n\tGraph1(vector<vector<int> > g) : V(g.size()), G(g) {}\n\n\t// ------ Basic Functions ------ //\n\tvoid add1(int v1, int v2) { G[v1].push_back(v2); }\n\tvoid add2(int v1, int v2) { add1(v1, v2); add1(v2, v1); }\n\n\t// ------ Algorithms ------ //\n\tvector<int> dist(int s) {\n\t\tqueue<int> que; que.push(s);\n\t\tvector<int> d(V, INF); d[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tif (d[G[u][i]] == INF) {\n\t\t\t\t\td[G[u][i]] = d[u] + 1;\n\t\t\t\t\tque.push(G[u][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n};\nint N, Q, c, u, v; Graph1 G;\nint main() {\n\tcin >> N; G = Graph1(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> u >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> v; G.add1(u - 1, v - 1);\n\t\t}\n\t}\n\tcin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> u >> v >> c;\n\t\tint d = G.dist(u - 1)[v - 1] + 1;\n\t\tif (d > c) cout << \"NA\" << endl;\n\t\telse cout << d << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nint main(){\n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  \n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n}\n\n\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0,yes=10001;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n   \n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; \n    \n    for(i=1;i<=maxx;i++){\n      if(net[next.first][i] == 1)mem++;\n      \n      if(net[next.first][i] == 1 && i == ed ){ //ツ姪堋的ツ地ツ督楪達\n\n\tif(yes >  (c-next.second+1)){\n\t  yes = (c - next.second)+1;\n\n\t}\n\t\n      }\n            \n      if(net[next.first][i] == 1){\n\tNari.push(BVB(i,next.second));\n\n      }\n      \n    }\n       \n  }\n  if(yes != 10001){return yes;}\n  else return -2; \n}"
  },
  {
    "language": "C++",
    "code": "//Memory Limit ExceededÉÈé\n//[ðñ70kByteögpµÄ¢éçµ¢\n//TvCvbg©Í¤Ü­¢ÁÄ¢éÁÛ¢\n//\n\n\n\n#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nvoid debug();\n\nint main(){\n\n \n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n\n    //  for(int k=0;k<maxx;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  // cout << \"maxx =\" << maxx << endl;\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n\n  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  //debug();\n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0,yes=10001;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  \n  //cout << \"FIRST next.second = \" << c << endl;  \n  //cout << \"FIRST         cal = \" << cal << endl;\n  //cout << \"             maxx = \" << maxx  << endl;\n  //cout << \"               ed = \" << ed << endl;\n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    //  cout << \"pop i = \" << next.first << endl;\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //   cout << \"1:next.first =  \" << next.first << endl;\n    //   cout << \"1:next.second = \" << next.second << endl; \n    \n    for(i=1;i<=maxx;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;\n\n      // cout << \"net[\" << next.first << \"][\" << i <<\"] = \" << net[next.first][i] << endl;\n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\n\t/*\t\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"2:   next.second = \" << next.second << endl; \n\t*/\t\n\n\tif(yes >  (c-next.second+1)){\n\t  yes = (c - next.second)+1;\n\t  //\t  cout << \"change yes = \" << yes << endl;\n\t}\n\t\n      }\n            \n\n      if(net[next.first][i] == 1){\n\tNari.push(BVB(i,next.second));\n\t//\tcout << \"push i = \" << i << endl;\n      }\n      \n  \n    }\n      \n    \n  }\n\n  //  cout << \"return yes = \" << yes << endl; \n\n  if(yes != 10001){return yes;}\n  else return -2;\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\nvoid debug(){\n  for(int i=1;i<=maxx;i++){\n    if(i==1){\n      cout << \"   \";\n      for(int k=1;k<=maxx;k++){\n\tprintf(\"%3d\",k);\n      }\n      cout << endl;\n      for(int k=1;k<=maxx;k++)printf(\"___\");\n      cout << endl;\n    }\n\n    for(int j=1;j<=maxx;j++){\n      if(j == 1)cout << i << \" |\";\n      printf(\"%3d\",net[i][j]);\n    }\n    cout << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconst int INF=500;\nusing namespace std;\nint main(){\n  int d[100][100],n,p;\n  cin>>n;\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=INF;\n  for(int i=0,r,k,t;i<n&&cin>>r>>k;i++) for(int j=0;j<k&&cin>>t;j++) d[r-1][t-1]=1;\n  for(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]++;\n  cin>>p;\n  for(int i=0,s,t,v;i<p;i++){\n    cin>>s>>t>>v;\n    if(d[s-1][t-1]>v) cout<<\"NA\"<<endl;\n    else cout<<d[s-1][t-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n;\nint dst[110][110];\nint M = 1001001001; // dekai kazu\n\nint main(){\n\tcin >> n;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tdst[i][j] = M;\n\t\t\tif(i==j) dst[i][j] = 0;\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfor(int j=0; j<k; j++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tdst[r][t] = 1;\n\t\t}\n\t}\n\tfor(int k=1; k<=n; k++){\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\tif(dst[i][k]+dst[k][j] < dst[i][j]){\n\t\t\t\t\tdst[i][j] = dst[i][k]+dst[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint p;\n\tcin >> p;\n\tfor(int i=0; i<p; i++){\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tif(dst[s][d] < v){\n\t\t\tcout << dst[s][d]+1 << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[101];\nint s,d,v;\nint s2,d2;\nint kk[100],n;\nbool flg[102] ;\n\n\nvoid visit(int sn,int dis) {\n  //  for(int i=1;i<=n;i++)cout << flg[i];\n  // cout <<\" \";\n  \n  flg[sn+1] = 1;\n  \n  if(sn == d-1 && dis <=v)  md = min(md,dis);\n  else if(dis < v && dis < md) {\n    for(int i=0;i<ro[sn].size();i++) {\n      \n      if(flg[ro[sn][i]] == 0){\n\t//\tcout <<sn+1 << \"to\"<<ro[sn][i] << endl;\n\tvisit(ro[sn][i]-1,dis+1);\n\tflg[ro[sn][i]] = 0;\n      }\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk[i];\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[kk[i]-1][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n\n\n    for(int i=0;i<=n;i++) flg[i] = 0;\n    md = 10000000;\n   \n    visit(s-1,1);\n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> node[200];\n\nint que(int s,int d,int v)\n{\n  queue<P> qu;\n  int c[200];\n  memset(c,-1,sizeof(c));\n  for(int i=0;i<node[s].size();i++)\n    {\n      if(v-1>0)\n\tqu.push(P(node[s][i],v-1));      \n    }\n  while(!qu.empty())\n    {\n      P a = qu.front();\n      qu.pop();\n      //      cout<<a.first<<\" \"<<a.second<<endl;\n      if(a.first==d)\n\treturn v-a.second+1;\n      for(int i=0;i<node[a.first].size();i++)\n\t{\n\t  if(a.second-1>0)\n\t    {\n\t      if(c[node[a.first][i]]==-1)\n\t\t{\n\t\t  c[node[a.first][i]]=a.second-1;\n\t\t  qu.push(P(node[a.first][i],a.second-1));\t    \n\t\t}\n\t    }\n\t} \n    }\n      return -1;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(;n--;)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k].push_back(tmp);\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      int ans=que(s,d,v);\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n      \n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "&#65279;#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n    //making graph\n    cin >> n;\n    \n    int data[n+1][n+1];\n    \n    for(int i = 0; i <= n; i++){\n      for(int j = 0; j <= n; j++){\n\tdata[i][j] = 0;\n      }\n    }\n    \n    int from, to, conesum;\n\n    for(int i = 0; i < n; i++){\n      cin >> from >> conesum;\n      for(int j = 0; j < conesum; j++){\n\tcin >> to;\n\tdata[from][to] = 1;\n      }\n    }\n    //making graph end\n\n    //judge\n\n    int sumpake;\n    cin >> sumpake;\n\n    queue<int> Q;\n\n    int ttl, myposi, min, sumin, sumina, finish = 0;\n\n    for(int i = 0; i < sumpake; i++){\n      min = 0;\n      cin >> from >> to >> ttl;\n      myposi = from;\n      for(int j = 0; j < ttl; j++){\n\tif(j != 0){\n\t  for(int l = 0; l < sumina; l++){\n\t    //cout << \"sumina \" << sumina << endl;\n\t    if(Q.front() == to){\n\t      min = j;\n\t      finish = 1;\n\t      //cout << \"much\" << endl;\n\t      break;\n\t    }\n\t    myposi = Q.front();\n\t    //cout << \"pop  \" << Q.front()<<endl;\n\t    Q.pop();\n\t    for(int k = 1; k <= n; k++){\n\t      if(data[myposi][k] == 1) {\n\t\tQ.push(k);\n\t\tsumin++;\n\t      }\n\t    }\n\t    \n\t  }\n\t  if(finish == 1) break;\n\t}else{\n\t  sumin = 0;\n\t  for(int k = 1; k <= n; k++){\n\t    if(data[myposi][k] == 1) {\n\t      Q.push(k);\n\t      sumin++;\n\t    }\n\t  }\n\t  \n\t}\n\t//\tfor(int k = 1; k <= n; k++){\n\t//\t    if(data[myposi][k] == 1) {\n\t//\t      Q.push(k);\n\t//\t      sumin++;\n\t//\t    }\n\t//\t}\n\t  sumina = sumin;\n\t  sumin = 0;\n      }\n\n      \n      if(min == 0) cout << \"NA\";\n      else cout << min+1;\n      cout << endl;\n      finish = 0;\n      while(!Q.empty()) Q.pop();\n    }\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define X first\n#define Y second\n#define IND first\n#define Z second.first\n#define V second.second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 101;\n\nbool ok[N][N];\nbool visited[N];\nint n, res, vv;\n\nint main(void){\n    cin >> n;\n\n    rep(i, n){\n        int r, k; cin >> r >> k;\n        while(k--){\n            int t; cin >> t;\n            ok[r][t] = true;\n        }\n    }\n\n    int p; cin >> p;\n    while(p--){\n        int s, d; cin >> s >> d >> vv;\n        res = INF;\n        COUNT(i, N) visited[i] = false;\n\n        queue< pair<int, pii> > q;\n        q.push(mp(s, mp(d, vv)));\n\n        while(!q.empty()){\n            pair<int, pii> cur = q.front();\n            q.pop();\n\n            if(cur.IND == cur.Z){\n                res = vv - cur.V + 1;\n                break;\n            }\n            cur.V--;\n            if(!cur.V || visited[cur.IND]) continue;\n            visited[cur.IND] = true;\n\n            COUNT(i, N)\n                if(ok[cur.IND][i]){\n                    pair<int, pii> next = mp(i, mp(cur.Z, cur.V));\n                    q.push(next);\n                }\n        }\n     \n        if(res == INF) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint d[111][111];\nint n;\nint main(void){\n  cin >> n;\n\n  for(int i = 0; i < n; i++){\n    fill(d[i],d[i]+n,1 << 20);\n    d[i][i] = 0;\n  }\n\n\n  for(int i = 0; i < n; i++){\n    int r,k;\n    cin >> r >> k;\n    for(int j = 0; j < k; j++){\n      int t;\n      cin >> t;\n      d[r - 1][t - 1] = 1;\n    }\n  }\n\n\n  for(int k = 0; k < n; k++){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  int p;\n  cin >> p;\n  for(int i = 0; i < p; i++){\n    int s,g,v;\n    cin >> s >> g >> v;\n    if(d[s-1][g-1] + 1 <= v){\n      cout << d[s-1][g-1] + 1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> dist(n+1, vector<int>(n+1, 1000));\n    for (int i=0; i<n+1; ++i) {\n        dist[i][i] = 0;\n    }\n    int r, k;\n    for (int i=0; i<n; ++i) {\n        cin >> r >> k;\n        int t;\n        for (int j=0; j<k; ++j) {\n            cin >> t;\n            dist[r][t] = 1;\n        }\n    }\n    for (int k=0; k<n+1; ++k) {\n        for (int i=0; i<n+1; ++i) {\n            for (int j=0; j<n+1; ++j) {\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n    int p;\n    cin >> p;\n    int s, d, v;\n    for (int i=0; i<p; ++i) {\n        cin >> s >> d >> v;\n        if (dist[s][d] == 1000 || v < dist[s][d]+1) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << dist[s][d]+1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 28;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ndouble cross(const xy_t &a, const xy_t &b){\n\treturn imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n\treturn real(conj(a) * b);\n}\n\nxy_t projection(const line &l, const xy_t &p){\n\tdouble t = dot(p - l.first, l.first - l.second) / norm(l.first - l.second);\n\treturn l.first + t * (l.first - l.second);\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0) return 1;\n\tif(cross(b, c) < 0) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSP(const line &l, const xy_t &p){\n\treturn abs(l.first- p) + abs(l.second - p) - abs(l.first - l.second) < EPS;\n}\n\nbool intersectSS(const line &s, const line &t){\n\treturn ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 &&\n\t\tccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\ndouble distanceSP(line s, xy_t p){\n\tconst xy_t r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s.first - p), abs(s.second - p));\n}\n\nint g[101][101];\n\nint main(){\n\tint n, p;\n\tint s, d, v;\n\twhile(cin >> n && n){\n\t\tfill(&g[0][0], &g[100][100] + 1, INF);\n\t\trep(i, 101) g[i][i] = 0;\n\t\trep(i, n){\n\t\t\tint a, b, k;\n\t\t\tcin >> a >> k;\n\t\t\trep(j, k){\n\t\t\t\tcin >> b;\n\t\t\t\tg[a][b] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k, 101){\n\t\t\trep(i, 101){\n\t\t\t\trep(j, 101){\n\t\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> p;\n\t\trep(i, p){\n\t\t\tcin >> s >> d >> v;\n\t\t\tint cost = g[s][d];\n\t\t\tif(cost < v){\n\t\t\t\tcout << cost + 1 << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0;i<n;++i)\n\n//ダイグスとらで解くそうです\n\nusing namespace std;\n\ntypedef pair<int,int> DisNum;\n\nvector<int> canto;\n\nint Serch(vector<DisNum> canConnect[102],int from,int to,int hp)\n{\n\tif(from == to)\n\t\treturn -1;\n\tint distance[102] = {};//距離を保存\n\tREP(i,102) distance[i] = INT_MAX;\n\tpriority_queue<DisNum,vector<DisNum>,greater<DisNum> > qu;//行き先のストックをキュー\n\tqu.push(DisNum(0,from));\n\tdistance[from] = 0;\n\twhile(!qu.empty())\n\t{\n\t\tDisNum nowfrom;\n\t\tnowfrom = qu.top();qu.pop();\n\t\tif(distance[nowfrom.second] != nowfrom.first) continue;\n\t\tif(nowfrom.second == to) return nowfrom.first;\n\t\tfor(int i=0;i<canConnect[nowfrom.second].size();++i)\n\t\t{\n\t\t\tint v = canConnect[nowfrom.second][i].second;//今から調べる先の座標\n\t\t\tint n = nowfrom.second;\n\t\t\tif(distance[v] > distance[n] + canConnect[nowfrom.second][i].first)\n\t\t\t{\n\t\t\t\tdistance[v] = distance[n] + canConnect[nowfrom.second][i].first;\n\t\t\t\tqu.push(DisNum(distance[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint maxn;\n\tcanto.clear();\n\tvector<DisNum> canConnect[102];\n\tcin >> maxn;\n\tfor(int i=0;i<maxn;++i)\n\t{\n\t\tint r,k;\n\t\tcin >> r >> k;\n\t\tfor(int j=0;j<k;++j)\n\t\t{\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tcanConnect[r].push_back(DisNum(1,t));\n\t\t}\n\t}\n\tint l;\n\tcin >> l;\n\tfor(int j=0;j<l;++j)\n\t{\n\t\tint s,d,v;\n\t\tcin >> s >> d >> v;\n\t\tint ans = Serch(canConnect,s,d,v) + 1;\n\t\tif(ans <= v)\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main(){\n  int a,b,c,d,e,f,g,now,v[200],m[201][201]={};\n  queue<int> q;\n  cin >> a;\n  for(int i=1;i<=a;i++){\n    cin >>b>>c;\n    for(int j=0;j<c;j++){\n      cin >> d;\n      m[b][d]=1;\n    }\n  }\n  cin >> d;\n  for(int i=0;i<d;i++){\n    cin >> e >> f >> g;\n    q.push(e);\n    for(int j=1;j<=a;j++)v[j]=1200;\n    v[e]=1;\n    while(1){\n      now=q.front();q.pop();\n      if(now==f){\n\tif(v[f]>g){\n\t  cout << \"NA\" << endl;\n\t  break;\n\t}else {\n\t  cout << v[now] << endl;\n\t  break;\n\t}\n      }\n      for(int j=1;j<=a;j++){\n\tif(m[now][j]&&v[j]==1200){\n\t  v[j]=v[now]+1;\n\t  q.push(j);\n\t}\n      }\n      if(q.empty()){\n\tcout<< \"NA\" << endl;\n\tbreak;\n      }\n    }\n    while(!q.empty())q.pop();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n, r, k, t;\nint net[100][100];\n\nvoid warshall_floyd() {\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<n; j++) {\n      for(int k=0; k<n; k++) {\n\tnet[i][j] = min(net[i][j], net[i][k] + net[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n\n  cin>> n;\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<n; j++) {\n      net[i][j] = INF;\n    }\n  }\n\n  for(int i=0; i<n; i++) {\n    cin>> r>> k;  \n    r--;\n    for(int j=0; j<k; j++) {\n      cin>> t;  \n      t--;\n      net[r][t] = 1;\n    }\n  }\n\n  warshall_floyd();\n\n  int p;\n  cin>> p;\n  for(int i=0; i<p; i++) {\n    int s, d, v;\n    cin>> s>> d>> v;\n    s--; d--;\n    if(net[s][d]+1>v) cout<< \"NA\"<< endl;\n    else cout<< net[s][d]+1<< endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#define MAX_N 110\nbool A[MAX_N][MAX_N];\nint rooter_num;\nusing namespace std;\nint bfs(int,int);\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  memset(A,false,sizeof(A));\n  cin>>rooter_num;\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r][t]=true;\n\t}\n    }\n  for(int i=1;i<=rooter_num;i++)\n    {\n      for(int j=1;j<=rooter_num;j++)\n\t{\n\t  cout<<A[i][j];\n\t}\n      cout<<endl;\n    }\n  \n  cin>>n;\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      int a=bfs(startNode,goalNode);\n      if(a>TTL)cout<<\"NA\"<<endl;\n      else cout<<a<<endl;\n    }\n  return 0;\n}\nint bfs(int startNode,int goalNode)\n{\n  queue<int>Q;\n  int visited[rooter_num+1];\n  memset(visited,false,sizeof(visited));\n  int currentNode=startNode;\n  \n  Q.push(currentNode);\n  visited[currentNode]=true;\n  \n  while(!Q.empty())\n    {\n\n      \n      currentNode=Q.front();\n      Q.pop();\n      for(int nextNode=1;nextNode<=rooter_num;nextNode++)\n\t{\n\n\t  if(A[currentNode][nextNode]==false)continue;\n\n\t  if(nextNode==goalNode)return visited[currentNode]+1;\n\t  \n\t  if(visited[nextNode]==false)\n\t    {\n\t      visited[nextNode]=visited[currentNode]+1;\n\t      Q.push(nextNode);\n\t    }\n\t}\n    }\n  return MAX_N;\n}\n\n\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\nusing namespace std;\n\nint main() {\n  int n, m, t, u, v;\n  int a[100][100];\n  cin >> n;\n  for (int i=0; i<n; i++) {\n    for (int j=0; j<n; j++) {\n      a[i][j] = -1;\n    }\n    a[i][i] = 0;\n  }\n  for (int i=0; i<n; i++) {\n    cin >> t >> u;\n    --t;\n    for (int j=0; j<u; j++) {\n      cin >> v;\n      --v;\n      a[t][v] = 1;\n    }\n  }\n  for (int i=0; i<n; i++) {\n    for (int j=0; j<n; j++) {\n      for (int k=0; k<n; k++) {\n        if (a[j][i] == -1 || a[i][k] == -1) continue;\n        if (a[j][k] == -1) {\n          a[j][k] = a[j][i] + a[i][k];\n        } else if (a[j][k] > a[j][i] + a[i][k]) {\n          a[j][k] = a[j][i] + a[i][k];\n        }\n      }\n    }\n  }\n  cin >> m;\n  for (int i=0; i<m; i++) {\n    cin >> t >> u >> v;\n    --t;\n    --u;\n    if (a[t][u] != -1 && a[t][u] < v) {\n      cout << a[t][u]+1 << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> node[200];\n\nint que(int s,int d,int v)\n{\n  queue<P> qu;\n  for(int i=0;i<node[s].size();i++)\n    {\n      if(v-1>0)\n\tqu.push(P(node[s][i],v-1));      \n    }\n  while(!qu.empty())\n    {\n      P a = qu.front();\n      qu.pop();\n      //      cout<<a.first<<\" \"<<a.second<<endl;\n      if(a.first==d)\n\treturn v-a.second+1;\n      for(int i=0;i<node[a.first].size();i++)\n\t{\n\t  if(a.second-1>0)\n\t  qu.push(P(node[a.first][i],a.second-1));      \n\t} \n    }\n      return -1;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(;n--;)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k].push_back(tmp);\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      int ans=que(s,d,v);\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n      \n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 100\n#define INFINITY 2000000000\nusing namespace std;\nint bfs();\nint n,r,k,t,p,s,g,v,u,M[N][N],d[N],result;\nstring color[N];\nint main(){\n  int i,j;\n  cin >> n;\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      M[i][j]=0;\n    }\n  }\n  for(i=0;i<n;i++){\n    cin >> r >> k;\n    for(j=0;j<k;j++){\n      cin >> t;\n      M[r-1][t-1]=1;\n    }\n  }\n  cin >> p;\n  for(i=0;i<p;i++){\n    cin >> s >> g >> v;\n    s--,g--;\n    result=bfs();\n    if(result!=0) cout << result << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}\nint bfs(){\n  int i,j;\n  queue<int> q;\n  for(i=0;i<n;i++) color[i]=\"WHITE\",d[i]=INFINITY;\n  color[s]=\"GLAY\";\n  d[s]=0;\n  q.push(s);\n  while(q.empty()!=1){\n    u=q.front();\n    q.pop();\n    for(i=0;i<n;i++){\n      if(M[u][i]&&color[i]==\"WHITE\"){\n\tcolor[i]=\"GLAY\";\n\td[i]=d[u]+1;\n\tq.push(i);\n      }\n    }\n    color[u]=\"BLACK\";\n  }\n  v-=d[g];\n  if(v>0) return d[g]+1;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define vi vector<int>\n#define VS vector<string>\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define pb push_back\n\n#define INF 1000010\n#define MAX_V 110\n\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\n\nint main(){\n    int n;\n\n    for(int i=0; i < MAX_V; i++) for(int j=0; j < MAX_V; j++) cost[i][j] = INF;\n    for(int i=0; i < MAX_V; i++) cost[i][i] = 0;\n\n    cin >> n;\n    for(int i=0; i < n; i++){\n        int e1;\n        int m;\n        cin >> e1 >> m;\n        for(int j=0; j < m; j++){\n            int e2;\n            cin >> e2;\n            cost[e1-1][e2-1] = 1;\n        }\n    }\n\n    for(int k=0; k < n; k++){\n        for(int i=0; i < n; i++){\n            for(int j=0; j < n; j++) cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n        }\n    }\n\n    cin >> n;\n    for(int i=0; i < n; i++){\n        int e1, e2, t;\n        cin >> e1 >> e2 >> t;\n        if(cost[e1-1][e2-1] != INF && cost[e1-1][e2-1]+1 <= t) cout << cost[e1-1][e2-1]+1 << endl;\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#define MAX_N 110\nbool A[MAX_N][MAX_N];\nint rooter_num;\nusing namespace std;\nint bfs(int,int);\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  int a;\n  memset(A,false,sizeof(A));\n  cin>>rooter_num;\n  /*------------input---------------*/\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r][t]=true;\n\t}\n    }\n  cin>>n;\n  /*-------------search--------------*/\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      a=bfs(startNode,goalNode);\n      if(a<=TTL)cout<<a<<endl;\n      else cout<<\"NA\"<<endl;\n       \n    }\n  return 0;\n}\nint bfs(int startNode,int goalNode)\n{\n  queue<int>Q;\n  int visited[rooter_num+1];\n  memset(visited,0,sizeof(visited));\n  int currentNode=startNode;\n  \n  Q.push(currentNode);\n  visited[currentNode]=1;\n  \n  while(!Q.empty())\n    {\n\n      \n      currentNode=Q.front();\n      Q.pop();\n      for(int nextNode=1;nextNode<=rooter_num;nextNode++)\n\t{\n\n\t  if(A[currentNode][nextNode]==0)continue;\n\n\t  if(nextNode==goalNode)return visited[currentNode]+1;\n\t  \n\t  if(visited[nextNode]<=0)\n\t    {\n\t      visited[nextNode]=visited[currentNode]+1;\n\t      Q.push(nextNode);\n\t    }\n\t}\n    }\n  return MAX_N;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 110\n\n#define INF 999999999\n\nint x[MAX_N][MAX_N];\nint d[MAX_N];\n\nqueue<int>Q;\n\nint bfs(int s, int t){\n\tfor(int i=0;i<MAX_N;i++){\n\t\td[i]=INF;\n\t}\n\td[s]=0;\n\tQ.push(s);\n\twhile(!Q.empty()){\n\t\tint z=Q.front();\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tif(x[z][i]<INF){\n\t\t\t\tif(d[i]==INF){\n\t\t\t\t\td[i]=d[z]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\treturn d[t];\n}\n\nint main(){\n\tint n,m,a,b,c;\n\tfor(int i=0;i<MAX_N;i++){\n\t\tfor(int j=0;j<MAX_N;j++){\n\t\t\tx[i][j]=INF;\n\t\t}\n\t}\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a>>b;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tcin>>c;\n\t\t\tx[a][c]=1;\n\t\t}\n\t}\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tint y=bfs(a,b);\n\t\tif(y>=c){cout<<\"NA\"<<endl;}\n\t\telse{cout<<y+1<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){\n\t\tttl = current = 0;\n\t}\n\n\tvoid copy(Packet t){\n\t\tttl = t.ttl;\n\t\tcurrent = t.current;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = t.checkTable[i];\n\t}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tif(memo[start][goal] != 0){\n\t\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(i);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp.copy(Q.front());\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.ttl > 0 && tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1 && t_limit-tmp.ttl + 1 <= n){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+1+memo[i][goal]);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+1+memo[i][goal];\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p;\n\t\t\t\t\t\tp.copy(tmp);\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n\n#define INF 1000000000\n\nusing namespace std;\n\nint main(void){\n\tint n;\n\tint s, t, num;\n\t\n\tcin >> n;\n\tint d[n][n];\n\tfill((int *)d, (int *)d+n*n, INF);\n\t//for(int i=0;i<n;i++) d[i][i] = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> s;\n\t\tcin >> num;\n\t\tfor(int j=0;j<num;j++){\n\t\t\tcin >> t;\n\t\t\td[s-1][t-1] = 1;\n\t\t}\n\t}\n\t\n\t//WF\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\td[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin >> s >> t >> num;\n\t\td[s-1][t-1]+1 <= num?cout << d[s-1][t-1]+1 << endl:cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[100];\nint s,d,v;\nint s2,d2;\nint kk[100],n;\n\nvoid visit(int sn,int dis) {\n  int x;\n  \n  if(dis <= v) {\n    for(int i=0;i<ro[sn].size();i++) {\n      for(int j=0;j<n;j++)\n\tif(ro[sn][i] == kk[j]) {\n\t  x = j;\n\t  break;\n\t}\n      //   cout <<sn << \"to\"<<x << endl;\n      \n      visit(x,dis+1);\n    }\n    \n    if(sn == d2) md = min(md,dis);\n    \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk[i];\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[i][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n\n   \n    for(int i=0;i<n;i++)\n      if(kk[i] == s) {\n\ts2 = i;\n\tbreak;\n      }\n    \n    for(int i=0;i<n;i++)\n      if(kk[i] == d) {\n\td2 = i;\n\tbreak;\n      }\n    \n    md = 10000000;\n    visit(s2,1);\n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint bfs(int s,int d,int v);\n\nint k[111];\nint t[111][111];\nbool flag[111];\n\nint main(){\n  int r,n,p;\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> r;\n    cin >> k[r];\n    for(int j=0;j<k[r];j++){\n      cin >> t[r][j];\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    int s,d,v;\n    memset(flag,0,sizeof(flag));\n    cin >> s >> d >> v;\n    int ans = bfs(s,d,v);\n    if(ans == -1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}\n\nint bfs(int s,int d,int v){\n  queue<P> que;\n  que.push(P(s,0));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    int now = p.first;\n    int cou = p.second;\n    cou++;\n    if(now == d) return cou;\n    if(flag[now] == false && v-cou > 0){\n      flag[now] = true;\n      for(int i=0;i<k[now];i++){\n\tque.push(P(t[now][i],cou));\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\n/* main??? */\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\n/* ???????????¢??° */\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\n/* ??????????????\\?¶??????±??\\?????¢??° */\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++){\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ???????????±???????????±??\\?????¢??° */\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcSumRouter(i4StartRouter,i4GoalRouter,i4TTL);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ??????????????????????¨????????????°?¨??????¢??° */\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\t/* ?????°??£?¨? */\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\t/* ????????¨ */\n\tI4 i4DefineRouter[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\tI4 i4StarCnt;\n\tI4 i4RoopMax;\n\t\n\t/* ????????? */\n\ti4StarCnt = 0;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\ti4DefineRouter[i4RoopCnt1] = FALSE;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\tif(i4TTL<=i4RouterNum){\t\n\t\ti4RoopMax = i4TTL;\n\t}\n\telse{\n\t\ti4RoopMax = i4RouterNum;\n\t}\n\t\n\ti4DefineRouter[i4Sender] = TRUE;\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<i4RoopMax; i4RoopCnt1++){\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=i4RouterNum; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i4DefineRouter[i4RoopCnt3] != TRUE){\n\t\t\t\t\t\t\ti4StarCnt++;\n\t\t\t\t\t\t\ti4DefineRouter[i4RoopCnt3] = TRUE;\n\t\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif(i4StarCnt > 0){\n\t\t\ti4StarCnt = 0;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX 10000000\nusing namespace std;\n\nint main(){\n  int n,m;\n  int go[101][101];\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++) go[i][j] = MAX;\n  }\n  cin >> n;\n  for(int i=0;i<n;i++){\n    int r,k,tmp;\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> tmp;\n      go[r][tmp] = 1;\n    }\n  }\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      for(int k=1;k<=n;k++){\n\tgo[j][k] = min(go[j][k],go[j][i] + go[i][k]);\n      }\n    }\n  }\n  cin >> m;\n  while(m--){\n    int s,d,ttl;\n    cin >> s >> d >> ttl;\n    if(go[s][d]+1 > ttl) cout << \"NA\" << endl;\n    else cout << go[s][d]+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N_MAX = 100;\n\nint n;\n// adj[from][to] from->toの辺があるか\nbool adj[N_MAX + 1][N_MAX + 1];\nint visited[N_MAX + 1];\n\nvoid bfs(int src, int dst, int limit) {\n\tqueue<int> que;\n\tfill(visited, visited + n + 1, -1);\n\tque.push(src);\n\tvisited[src] = 1;\n\twhile (!que.empty()) {\n\t\tint current = que.front();\n\t\tque.pop();\n\t\tif (current == dst) {\n\t\t\tif (visited[dst] > limit) break;\n\t\t\tcout << visited[dst] << endl;\n\t\t\treturn;\n\t\t}\n\t\tfor (int next = 1; next <= n; next++) {\n\t\t\tif (adj[current][next] && visited[next] == -1) {\n\t\t\t\tque.push(next);\n\t\t\t\tvisited[next] = visited[current] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfill(adj[r], adj[r] + n, false);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tadj[r][t] = true;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tbfs(s, d, v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 1 << 28;\nint n, m;\nint d[102][102];\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      d[i][j] = inf;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int r, k, t;\n    cin >> r >> k;\n    r--;\n    for (int j = 0; j < k; ++j) {\n      cin >> t;\n      t--;\n      d[r][t] = 1;\n    }\n  }\n  \n  for (int i = 0; i < n; ++i) d[i][i] = 0;\n  \n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    int s, de, v;\n    cin >> s >> de >> v;\n    s--; de--;\n    printf(\"(%d,%d) \", s, de);\n    if (d[s][de]+1 <= v) {\n      cout << d[s][de]+1 << endl;\n    } else {\n      //cout << d[s][de] << endl;\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n\nstatic const int NO = -2;\nstatic const int N = 300;\n\n\nint graph[N + 1][N + 1] = {{}};\nint dis[N + 1] = {};\nint n;\n\nvoid bfs(int v){\n  queue<int> Q;\n\n  Q.push(v);\n\n  for(int i = 1; i <= N; i++){\n    dis[i] = NO;\n  }\n\n  dis[v] = 1;\n\n  int u;\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n\n    for(int i = 1;i <= n; i++){\n      if(graph[u][i]==0) continue;\n      if(dis[i]!=NO)continue;\n      dis[i] = dis[u] + 1;\n      Q.push(i);\n\n    }\n  }\n}\n\nint main(){\n\n  int r[N+1] = {};\n  int d[N+1] = {};\n  int k[N+1] = {};\n  int f[N+1] = {};\n  int p,s[N+1] = {};\n  int v[N+1] = {};\n\n\n  //in\n  cin >> n;\n\n  for(int i = 1;i <= n; i++){\n\n    cin >> r[i] >> k[i];\n\n    for(int j = 1;j <= k[i];j++){\n\n      cin >> f[j];\n      graph[r[i]][f[j]] = 1;\n    }\n  }\n\n  cin >> p;\n  for(int i = 1;i <= p; i++){\n    cin >> s[i] >> d[i] >> v[i];\n    bfs(s[i]);\n\n    if(v[i] >= dis[d[i]]) cout << dis[d[i]] << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n\nusing namespace std;\nint a[100][100];\nint main(){\n  int n, r, k, t;\n  scanf(\"%d\", &n);\n  rep(i, n) rep(j, n) a[i][j] = 1<<16;\n  rep(i, n){\n    scanf(\"%d%d\", &r, &k);r--;\n    rep(j, k){\n      scanf(\"%d\", &t);t--;\n      a[r][t] = 1;\n    }\n  }\n\n  // solve\n  rep(i, n) rep(j, n) rep(k, n)\n    a[j][k] = min(a[j][k], a[j][i] + a[i][k]);\n\n  int p, s, d, v;\n  scanf(\"%d\", &p);\n  rep(i, p){\n    scanf(\"%d%d%d\", &s, &d, &v);s--;d--;\n    if(v - a[s][d] > 0) printf(\"%d\\n\", a[s][d] + 1);\n    else puts(\"NA\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n;\n\tcin >> n;\n\tint g[n][n];\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tg[i][j] = 100000000;\n\tint r,k,t;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> r >> k;\n\t\tr--;\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\tg[r][t] = 1;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor(int i = 0; i < p; i++){\n\t\tint s,d,v;\n\t\tcin >> s >> d >> v;\n\t\ts--; d--;\n\t\tvector <int> used(n,false);\n\t\tvector <int> dist(n,100000000);\n\t\tdist[s] = false;\n\t\twhile(1){\n\t\t\tint va = -1;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(used[j] == false && (va == -1 || dist[va] > dist[j]))\n\t\t\t\t\tva = j;\n\t\t\t}\n\t\t\tif(va == -1)\n\t\t\t\tbreak;\n\t\t\tused[va] = true;\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tdist[j] = min(dist[j] , dist[va] + g[va][j]);\t\n\t\t}\n\n\t\tif(v > dist[d])\n\t\t\tcout << dist[d] + 1 << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n    cin >> n;\n    \n    int data[n+1][n+1];\n    \n    for(int i = 0; i <= n; i++){\n      for(int j = 0; j <= n; j++){\n\tdata[i][j] = 0;\n      }\n    }\n    \n    int from, to, conesum;\n\n    for(int i = 0; i < n; i++){\n      cin >> from >> conesum;\n      for(int j = 0; j < conesum; j++){\n\tcin >> to;\n\tdata[from][to] = 1;\n      }\n    }\n\n\n    int sumpake;\n    cin >> sumpake;\n\n    queue<int> Q;\n\n    int ttl, myposi, min, sumin, sumina, finish = 0;\n\n    for(int i = 0; i < sumpake; i++){\n      min = 0;\n      cin >> from >> to >> ttl;\n      myposi = from;\n      for(int j = 0; j < ttl; j++){\n\tif(j != 0){\n\t  for(int l = 0; l < sumina; l++){\n\t    if(Q.front() == to){\n\t      min = j;\n\t      finish = 1;\n\t      break;\n\t    }\n\t    myposi = Q.front();\n\t    Q.pop();\n\t    for(int k = 1; k <= n; k++){\n\t      if(data[myposi][k] == 1) {\n\t\tQ.push(k);\n\t\tsumin++;\n\t      }\n\t    }\n\t    \n\t  }\n\t  if(finish == 1) break;\n\t}else{\n\t  sumin = 0;\n\t  for(int k = 1; k <= n; k++){\n\t    if(data[myposi][k] == 1) {\n\t      Q.push(k);\n\t      sumin++;\n\t    }\n\t  }\n\t  \n\t}\n\t  sumina = sumin;\n\t  sumin = 0;\n      }\n      \n      if(min == 0) cout << \"NA\";\n      else cout << min+1;\n      cout << endl;\n      finish = 0;\n      while(!Q.empty()) Q.pop();\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\nusing namespace std;\n#define INF (1<<24)\nint n;\nint r[101][101];\nmain(){\n  scanf(\"%d\",&n);\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++) r[i][j]=INF;\n  for(int i=0;i<n;i++){\n    int rr,k;\n    scanf(\"%d %d\",&rr,&k);\n    for(int j=0;j<k;j++){\n      int t;\n      scanf(\"%d\",&t);\n      r[rr][t]=1;\n    }\n  }\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      for(int l=1;l<=n;l++)\n\tr[j][l]=min(r[j][l],r[j][i]+r[i][l]);\n  int p;\n  scanf(\"%d\",&p);\n  for(int i=0;i<p;i++){\n    int s,d,v;\n    scanf(\"%d %d %d\",&s,&d,&v);\n    int res=r[s][d]+1;\n    if(res>v) printf(\"NA\\n\");\n    else printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[10000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b,fg;\n  \n  struct mail{\n    int s;\n    int d;\n    int v[101];\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v[1]);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(j=1;j<=p;j++)\n\t{\n\t  packet[i].v[j]=packet[i].v[1];\n\t}\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      //printf(\"A\\n\");\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n      \n      visited[packet[i].s]=1;\n      fg=0;\n      //printf(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\");\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\t  \n\t  for(j=1;j<=n;j++)\n\t    {\n\t      //printf(\"%dB\\n\",packet[i].v[j]);\n\t      //printf(\"%d\\n\",packet[i].v[j]);\n\t      \n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\n\t\t  packet[i].v[j]=packet[i].v[a]-1;\n\t\t  //printf(\"%d==%d\\n\",j,packet[i].d);\n\t\t  if(j==packet[i].d && packet[i].v[j]>0)printf(\"%d\\n\",count[packet[i].d]);\n\t\t  else if(fg==0 && packet[i].v[j]==-1 && a!=packet[i].d)\n\t\t    {\n\t\t      printf(\"NA\\n\");\n\t\t      fg=1;\n\t\t    }\n\t\t  \n\t\t} \n\t      \n\t    }\n\t  //printf(\"\\n\");\n\t}\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nint G[100][100];\nint inf = 123123123;\nbool warshallfloyd(int v){\n  int i, j, k;\n  rep(k, v)rep(i, v)rep(j, v)if(G[i][k] != inf && G[k][j] != inf && G[i][j] > G[i][k] + G[k][j])G[i][j] = G[i][k] + G[k][j];\n  rep(i, v)if(G[i][i] < 0)return false;\n  return true;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    rep(i, n)rep(j, n)G[i][j] = inf;\n    rep(i, n){\n      int2(r, k); --r;\n      rep(j, k){\n        int(t); --t;\n        G[r][t] = 1;\n      }\n    }\n    warshallfloyd(n);\n\n    int(p);\n    for(;p--;){\n      int3(s, d, v);\n      --s; --d;\n      if(G[s][d] < v)printf(\"%d\\n\", G[s][d] + 1);\n      else puts(\"NA\");\n    }\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int maxv=100000;\nint main()\n{\n\tint root[101][101];\n\tfor(int i=0;i<10;i++){\n\t\tfor(int i2=0;i2<=100;i2++){\n\t\t\troot[i][i2]=maxv;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tint r,k,ch;\n\tcin>>r>>k;\n\t\tfor(int i2=0;i2<k;i2++){\n\t\t\tcin>>ch;\n\t\t\troot[r][ch]=1;\n\t\t}\n\t}\n\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int i2=01;i2<=n;i2++){\n\t\t\t\troot[i][i2]=min(root[i][i2],root[i][k]+root[k][i2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint m;\n\tint s,d,v;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>s>>d>>v;\n\t\tif(root[s][d]<v){\n\t\t\tcout<<root[s][d]+1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int maxv=1000;\nint main()\n{\n\tint root[101][101];\n\tfor(int i=0;i<10;i++){\n\t\tfor(int i2=0;i2<10;i2++){\n\t\t\troot[i][i2]=maxv;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tint r,k,ch;\n\tcin>>r>>k;\n\t\tfor(int i2=0;i2<k;i2++){\n\t\t\tcin>>ch;\n\t\t\troot[r][ch]=1;\n\t\t}\n\t}\n\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int i2=01;i2<=n;i2++){\n\t\t\t\troot[i][i2]=min(root[i][i2],root[i][k]+root[k][i2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint m;\n\tint s,d,v;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>s>>d>>v;\n\t\tif(v-root[s][d]>0){\n\t\t\tcout<<root[s][d]+1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,b;\n  int ans=0;\n  int flag[111][111];\n  int box[111][111];\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      box[i][j]=9999;\n      flag[i][j]=0;\n    }\n  }\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      box[r-1][t-1]=1;\n    }\n  }\n  for(int z=0;z<n;z++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tbox[i][j]=min(box[i][j],box[i][z]+box[z][j]);\n      }\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> b;\n    ans=box[s-1][d-1]+1;\n    if(b-ans>=0){\n      cout << box[s-1][d-1]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int INF = (int)1e9;\ntypedef pair<int, int> P;\nstruct Edge {\n    int to, cost;\n    Edge(int t, int c) : to(t), cost(c) { }\n};\n\nint dijkstra(const vector<vector<Edge> > &edges, const int from, const int to) {\n    vector<int> dist(edges.size(), INF);\n    priority_queue<P, vector<P>, greater<P> > Q;\n    Q.push(P(1, from));\n    dist[from] = 1;\n    while(!Q.empty()) {\n        P p = Q.top(); Q.pop();\n        int v = p.second;\n        int d = p.first;\n        if(v == to) break;\n        if(d > dist[v]) continue;\n        for(int i = 0; i < (int)edges[v].size(); i++) {\n            Edge e = edges[v][i];\n            int c = dist[v] + e.cost;\n            if(dist[e.to] > c) {\n                dist[e.to] = c;\n                Q.push(P(c, e.to));\n            }\n        }\n    }\n    return dist[to];\n}\n\nint main() {\n    int n; cin >> n;\n    vector<vector<Edge> > edges(n + 1);\n    for(int i = 0; i < n; i++) {\n        int r, k; cin >> r >> k;\n        for(int j = 0; j < k; j++) {\n            int t; cin >> t;\n            edges[r].push_back(Edge(t, 1));\n        }\n    }\n    int p; cin >> p;\n    for(int i = 0; i < p; i++) {\n        int from, to, ttl;\n        cin >> from >> to >> ttl;\n        int d = dijkstra(edges, from, to);\n        if(d > ttl) {\n            cout << \"NA\" << endl;\n        }\n        else {\n            cout << d << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nint main(){\n    using namespace std;\n\n    int n, M[101][101] = {};\n    cin >> n;\n    for(int i = 0; i < n; ++i){\n        int num, src;\n        cin >> src >> num;\n        for(int j = 0; j < num; ++j){\n            int dest;\n            cin >> dest;\n            M[src][dest] = 1;\n        }\n    }\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; ++i){\n        int src, dest, ttl, d[n + 1];\n        fill(d, d + n + 1, -1);\n\n        cin >> src >> dest >> ttl;\n        d[src] = 1;\n        queue<int> q;\n        q.push(src);\n        while(!q.empty()){\n            int const u = q.front();\n            q.pop();\n            for(int v = 1; v < n + 1; ++v){\n                if(M[u][v] == 1 && d[v] == -1){\n                    d[v] = d[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        if(d[dest] == -1){\n            cout << \"NA\";\n        }else if(ttl - d[dest] >= 0){\n            cout << d[dest];\n        }else{\n            cout << \"NA\";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); i++ )\n#define UREP( i, m, n ) for ( unsigned int i = (unsigned int)( m ); i < (unsigned int)( n ); i++ )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define RALL( c ) (c).rbegin(), (c).rend()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n// 隣接リスト -> min{s, t}\nint dijkstra( vector< vector<PII> > graph, const int start, const int goal )\n{\n\tvector<int> distance( graph.size() );\n\tfill( ALL( distance ), INT_MAX );\n\n\tpriority_queue< PII, vector< PII >, greater< PII > > que; // 累計コスト, ノード番号\n\tque.push( MP( 0, start ) );\n\n\twhile ( !que.empty() )\n\t{\n\t\tint total = que.top().fst;\n\t\tint node = que.top().snd;\n\t\tque.pop();\n\n\t\tif ( total < distance[ node ] )\n\t\t{\n\t\t\tdistance[ node ] = total;\n\n\t\t\tREP( i, 0, graph[ node ].size() )\n\t\t\t{\n\t\t\t\tint to = graph[ node ][i].fst;\n\t\t\t\tint cost = graph[ node ][i].snd;\n\n\t\t\t\tque.push( MP( total + cost, to ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn distance[ goal ];\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tvector< vector< PII > > graph( n );\n\tfor ( auto &row : graph )\n\t{\n\t\trow = vector<PII>();\n\t}\n\n\tREP( dn, 0, n )\n\t{\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tr--;\n\n\t\tREP( dk, 0, k )\n\t\t{\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tt--;\n\n\t\t\tgraph[r].PB( MP( t, 1 ) );\n\t\t}\n\t}\n\n\tint p;\n\tcin >> p;\n\n\tREP( dp, 0, p )\n\t{\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\ts--;\n\t\td--;\n\n\t\tint res = dijkstra( graph, s, d ) + 1;\n\n\t\tif ( res <= v )\n\t\t{\n\t\t\tcout << res << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\t\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main()\n{\n  int n;\n  int node[100][100];\n  cin>>n;\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      node[i][j]=0;\n  \n  \n  for(int x=0;x<n;x++)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      queue<P> qu;\n      int ans=-1;\n      bool move[n+1];\n      if(v>1)\n\t{\n\t  for(int i=0;i<=n;i++)\n\t    {\n\t      if(node[s][i]==1)\n\t\tqu.push(P(i,2));\n\t    }\n\t  for(int i=0;i<=n;i++)\n\t    {\n\t      move[i]=true;\n\t    }\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  //\t  cout<<\"Queue:\"<<a.first<<\"  \"<<a.second<<endl;\n\t  if(a.first==d)\n\t    {\n\t      ans = a.second;\n\t      break;\n\t    }\n\t  for(int i=1;i<=n;i++)\n\t    {\n\t      if(node[a.first][i]==1)\n\t\t{\n\t\t  if(move[i] && a.second+1<=v)\n\t\t    {\n\t\t      qu.push(P(i,a.second+1));\n\t\t      move[i]=false;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n\nclass Dijkstra {\n#define MAX_V 102\n  typedef pair<int, int> P;\n\nprivate:\n  const int INF = 1e9 + 10;\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n        }\n      }\n    }\n\n    return d;\n  }\n};\n\n\nint main() {\n  int n;\n  cin >> n;\n  Dijkstra dijkstra(101);\n  \n  for (int i = 0; i < n; i++) {\n    int r, k;\n    cin >> r >> k;\n    for (int j = 0; j < k; j++) {\n      int t;\n      cin >> t;\n      dijkstra.AddEdge(r, t, 1);\n    }\n  }\n\n  int p;\n  cin >> p;\n\n  for (int i = 0; i < p; i++) {\n    int s, d, v;\n    cin >> s >> d >> v;\n    vector<int> dists = dijkstra.Solve(s);\n    int dist = dists[d];\n    if (dist >= v) {\n      cout << \"NA\" << endl;\n    } else {\n      cout << dist + 1 << endl;\n    }\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // max, min\n\nusing namespace std;\n\nconst int AllaySize = 100;\nconst int Limit = 999999;\n\nint N, P;\nint ConnectR[AllaySize][AllaySize];\nint InitTTL;\n//int Ans[AllaySize][AllaySize];\n\nvoid war(void) {\n  for(int k=1; k<N+1; k++) {\n    for(int i=1; i<N+1; i++) {\n      for(int j=1; j<N+1; j++) {\n\tConnectR[i][j]=min(ConnectR[i][j], ConnectR[i][k]+ConnectR[k][j]);\n      }\n    }\n  } \n}\n\nint main(void) {\n  for(int i=0; i<AllaySize; i++) {\n    for(int j=0; j<AllaySize; j++) {\n      ConnectR[i][j]=Limit;\n      // Ans[i][j]=Limit;\n    }\n  }\n\n  cin>>N;\n  for(int i=0; i<N; i++) { // ルータの接続情報\n    int k;\n    int from, to;\n    cin>>from;\n    cin>>k;\n    for(int j=0; j<k; j++) {\n      cin>>to;\n      ConnectR[from][to] = 1; // 通過可能\n    }\n  }\n\n  war();\n  cin>>P;\n  for(int i=0; i<P; i++) {\n    int from, to;\n    cin>>from;\n    cin>>to;\n    cin>>InitTTL;\n    if(ConnectR[from][to] < InitTTL) {\n      cout<<ConnectR[from][to]+1<<endl; // ?????\n    }\n    else {\n      cout<<\"NA\"<<endl;\n    }\n  }\n  /*\n  for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n      cout<<ConnectR[i][j]<<\" \";\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\n#include<functional>\nusing namespace std;\n\nint main(){\n\tint N,d[100][100]; fill_n((int*)d,100*100,INT_MAX/2);\n\tcin>>N;\n\tfor(int i=0;i<N;i++){\n\t\tint R,K;\n\t\tcin>>R>>K; R--;\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint T;\n\t\t\tcin>>T; T--;\n\t\t\td[R][T] = 1;\n\t\t}\n\t}\n\t\n\tfor(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\td[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\n\tint P; cin>>P;\n\tfor(int i=0;i<P;i++){\n\t\tint S,D,V;\n\t\tcin>>S>>D>>V; S--; D--;\n\t\tif(V<d[S][D]+1) puts(\"NA\");\n\t\telse printf(\"%d\\n\",d[S][D]+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\nint main(){\n\tint n; cin>>n;\n\tvector<vector<int> > e;\n\tvector<int> id(n);\n\tFOR(i,n){\n\t\tcin>>id[i];\n\t\tint x; cin>>x;\n\t\te.push_back(vector<int>(x));\n\t\tFOR(j,x) cin>>e[i][j];\n\t}\n\n\tmap<int,int> mp;\n\tFOR(i,n) mp[id[i]] = i;\n\tFOR(i,n) FOR(j,sz(e[i])) e[i][j] = mp[e[i][j]];\n\n\tvector<vector<int> > dp(n,vector<int>(n,INF));\n\tFOR(i,n) FOR(j,sz(e[i])) dp[i][e[i][j]] = 1;\n\n\tFOR(k,n) FOR(i,n) FOR(j,n) dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\n\tint m; cin>>m;\n\twhile(m--){\n\t\tint s,t,tll; cin>>s>>t>>tll;\n\t\ts = mp[s],t = mp[t];\n\t\tint ans = dp[s][t] + 1;\n\t\tif(ans > tll) printf(\"NA\");\n\t\telse printf(\"%d\",ans);\n\t\t\n\t\tif(m)puts(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_NODE = 110;\n\nvector<int> makeInput(string input){\n    vector<int> ret;\n    stringstream ss(input);\n\n    while(ss >>input) ret.push_back(atoi(input.c_str()));\n    return ret;\n}\n\nint main(){\n    int n;\n    while(cin >>n && n){\n        int d[MAX_NODE][MAX_NODE];\n        REP(i, MAX_NODE) REP(j, MAX_NODE) d[i][j] = INF;\n        REP(i, MAX_NODE) d[i][i] = 0;\n        vector< vector<int> > graph(MAX_NODE, vector<int>(MAX_NODE));\n        string dust_str;\n        getline(cin, dust_str);\n        //make graph\n        REP(i, n){\n            string input;\n            getline(cin, input);\n            vector<int> sum_list = makeInput(input);\n\n            //make\n            REP(j, sum_list[1]){\n                graph[sum_list[0]].push_back(sum_list[j + 2]);\n                d[sum_list[0]][sum_list[j + 2]] = 1;\n            }\n        }\n\n        //ワーシャルフロイド\n        int v = n + 1;\n        REP(k, v){\n            REP(i, v){\n                REP(j, v){\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        //cal ans\n        int m;\n        cin >>m;\n        getline(cin, dust_str);\n        REP(i, m){\n            string input;\n            getline(cin, input);\n            vector<int> sum_list = makeInput(input);\n            int from = sum_list[0], to = sum_list[1], ttl = sum_list[2];\n            if(ttl < (d[from][to] + 1)) cout <<\"NA\" <<endl;\n            else cout <<d[from][to] + 1 <<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\ntypedef pair<int,int> P;\nconst int INF =100000000;\nint n;\nint d[110][110];\nint main()\n{\n  int r,k;\n  while(cin>>n){\n    for(int i = 0;i < 110;i++){\n      for(int j = 0;j <110;j++){\n\td[i][j]= INF;\n      }\n    }\n    for(int i = 1;i <=n;i++){\n      cin>>r>>k;\n      for(int j = 0;j < k;j++){\n\tint x;\n\tcin>>x;\n\td[r][x] = 1;\n      }\n    }\n    for(int i = 1;i <=n;i++){\n      for(int j = 1;j <=n;j++){\n\tfor(int k = 1;k <=n;k++){\n\t  d[i][j] =min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    int p;\n    cin>>p;\n    int s1,d1,v1;\n    for(int i = 0;i <p;i++){\n      cin>>s1>>d1>>v1;\n      if(d[s1][d1]+1<=v1){\n\tcout <<d[s1][d1]+1<<endl;\n      }else{\n\tcout <<\"NA\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101],P[101],D[101],num,min,min_index,current;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <=  t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int index=1; index <= n; index++){\n\t\t\tP[index] = 0;\n\t\t\tD[index] = 1000000000;\n\t\t}\n\n\t\tP[start] = 1;\n\t\tnum = 1;\n\n\t\tfor(int index = 1; index <= n; index++){\n\t\t\tif(index != start && table[start][index] == 1){\n\t\t\t\tif(memo[index][goal] > 0 && memo[index][goal] + 1 <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[index][goal]+1);\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tD[index] = 1;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)continue;\n\n\t\twhile(num < n){\n\t\t\tmin = 1000000000;\n\t\t\tfor(int index=1;index <= n; index++){  //??????????????°?????????????????????????????¢???\n\t\t\t\tif(P[index] == 0 && D[index] < min){ //?????????????????§?????????????????????????????????\n\t\t\t\t\tmin = D[index];\n\t\t\t\t\tmin_index =index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(min == 1000000000)break; //?????????????????????????????????????????°break\n\n\t\t\tP[min_index] = 1; //min_index?????????????????¨??????\n\t\t\tcurrent = min_index;\n\t\t\tnum++; //???????????????????????°???1?¢???????\n\n\t\t\t/*if(memo[current][goal] > 0 && D[current]+memo[current][goal] <= t_limit){\n\t\t\t\tD[goal] = D[current]+memo[current][goal]-1;\n\t\t\t\tbreak;\n\t\t\t}*/\n\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tif(table[current][i] == 1){\t//start???????????????????????¨???????????£????????????\n\t\t\t\t\tD[i] = (D[i] <= (D[current]+1))?D[i]:(D[current]+1); //?????????????????´??\\????????¢??¨???current????????±???????????¢???????????????D??¨??????\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif(D[goal] >= t_limit){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tmemo[start][goal] = D[goal]+1;\n\t\t\tprintf(\"%d\\n\",D[goal]+1);\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\n\n\nint main(){\n\n \n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n\n    for(int k=0;k<maxx;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  // cout << \"maxx =\" << maxx << endl;\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n\n  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  \n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=maxx;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;  \n\n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      if(mem == n)break;\n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n int d[100][100],rn,pn,i,j,to,fr,s1,d1,v1,a,b,c,n;\n for (i=0;i<100;i++) for (j=0;j<100;j++) d[i][j]=999;\n cin >> n;\n for (i=0;i<n;i++) {\n   cin >> to >> rn; \n   for (j=0;j<rn;j++) { cin >> fr; d[to-1][fr-1]=1;}\n }\n for (a=0;a<100;a++) for (b=0;b<100;b++) for (c=0;c<100;c++) d[b][c]=min(d[b][c],d[b][a]+d[a][c]);\n cin >> pn;\n for (i=0;i<pn;i++) {\n   cin >> s1 >> d1 >> v1;\n   if (d[s1-1][d1-1]>v1-1) cout << \"NA\"; else cout << d[s1-1][d1-1]+1;\n   cout << endl;\n }\nreturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 1 << 28;\nint n, m;\nint d[102][102];\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      d[i][j] = inf;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    int r, k, t;\n    cin >> r >> k;\n    r--;\n    for (int j = 0; j < k; ++j) {\n      cin >> t;\n      t--;\n      d[r][t] = 1;\n    }\n  }\n  \n  for (int i = 0; i < n; ++i) d[i][i] = 0;\n  \n  for (int k = 0; k < n; ++k) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  cin >> m;\n  for (int i = 0; i < m; ++i) {\n    int s, de, v;\n    cin >> s >> de >> v;\n    s--; de--;\n    //printf(\"(%d,%d) \", s, de);\n    if (d[s][de]+1 <= v) {\n      cout << d[s][de]+1 << endl;\n    } else {\n      //cout << d[s][de] << endl;\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntypedef std::pair<int, int> pii;\ntypedef std::vector<int> vi;\ntypedef std::vector<double> vd;\ntypedef std::vector<std::string> vs;\ntypedef std::vector<pii> vpii;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { rep(i,v.size()) is >> v[i]; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Array;\ntypedef std::vector<Array> Matrix;\n\nclass Graph {\n  std::vector<Edges> g;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int &src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nmain {\n  int n;\n  cin >> n;\n  Graph g(n);\n  while (n--) {\n    int r, k;\n    cin >> r >> k;\n    --r;\n    while (k--) {\n      int t;\n      cin >> t;\n      --t;\n      g.addArc(r, t);\n    }\n  }\n  n = g.size();\n  Matrix dist(n, Array(n));\n  rep(i, n) {\n    vector<Weight> d = dijkstra<INF>(g, i).first;\n    rep(j, n) dist[i][j] = d[j];\n  }\n  int p;\n  cin >> p;\n  while (p--) {\n    int s, d, v;\n    cin >> s >> d >> v;\n    --s, --d;\n    if (dist[s][d] + 1 > v) {\n      cout << \"NA\" << endl;\n      continue;\n    }\n    cout << dist[s][d] + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> NODE;\n#define mp make_pair\nbool connect[100][100];\n\nint bfs(int s,int g,int t){\n\tqueue<NODE> Q;\n\tint ttl,pos;\n\tQ.push(mp(s,t));\n\twhile(!Q.empty()){\n\t\tpos = Q.front().first;\n\t\tttl = Q.front().second;\n\t\tQ.pop();\n\t\tttl--;\n\t\tif(pos == g)return ttl; \n\t\tif(ttl>0)\n\t\t\tfor(int i=0;i<100;i++)\n\t\t\t\tif(connect[pos][i])\n\t\t\t\t\tQ.push(mp(i,ttl));\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint n,r,k,t;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tr--;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\tconnect[r][t]=true;\n\t\t}\n\t}\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k >> t;\n\t\tr--;k--;\n\t\tif(~bfs(r,k,t))cout << t-bfs(r,k,t) << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <string.h>\n#include <set>\n\n\nusing namespace std;\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        int graph[101][101]={0};\n        for(int roop=0; roop<n; roop++){\n            int r;\n            cin>>r;\n            int k;\n            cin>>k;\n            for(int roop2=0; roop2<k; roop2++){\n                int t;\n                cin>>t;\n                graph[r][t]=1;\n            }\n        }\n        \n        int q;\n        cin>>q;\n        for(int roop=0; roop<q; roop++){\n            int s,d,v;\n            cin>>s>>d>>v;\n            int visit[101]={0};\n            visit[s]=1;\n            queue<pair<int,int> > qu;\n            pair<int,int> now;\n            now.first=s;\n            now.second=v;\n            \n            qu.push(now);\n            bool find=false;\n            \n            \n            while(!qu.empty()){\n                \n                now=qu.front();\n                //cout<<now.first<<\" \"<<now.second<<endl;\n                qu.pop();\n                if(now.first==d){\n                    find=true;\n                    break;\n                }\n                if(now.second>1){\n                    for(int i=1; i<=n; i++){\n                        if(graph[now.first][i]==1&&visit[i]==0){\n                            visit[i]=1;\n                            pair<int,int> temp;\n                            temp.first=i;\n                            temp.second=now.second-1;\n                            qu.push(temp);\n                        }\n                    }\n                }\n            }\n            if(find)cout<<v-now.second+1<<endl;\n            else cout<<\"NA\"<<endl;\n            \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(100001);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    vector<bool> check(101, false);\n    queue<int> fq, nq, sq;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            if (check[pos]) {\n                continue;\n            } else {\n                check[pos] = true;\n            }\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            } else {\n                for (int i: g[pos]) {\n                    nq.push(i);\n                }\n            }\n        }\n        if (c == 0 || nq.empty()) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,int> P;\n\nstatic const double eps = 10e-6;\n\nint dp[101][101];\n\nint main(){\n\tint n;\n\n\tmemset(dp,0x2,sizeof(dp));\n\tscanf(\"%d\",&n);\t\n\tfor(int i=0;i<n;i++){\n\t\tint r,k,t;\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int j=0;j<k;j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tdp[r][t] = 1;\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tdp[j][k] = min(dp[j][i]+dp[i][k],dp[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint p;\n\tscanf(\"%d\",&p);\n\tfor(int i=0;i<p;i++){\n\t\tint s,d,v;\n\t\tscanf(\"%d %d %d\",&s,&d,&v);\n\n\t\tchar buf[128];\n\t\tsprintf(buf,\"%d\",dp[s][d]+1);\n\t\tprintf(\"%s\\n\", dp[s][d] >= v ? \"NA\" : buf);\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0;i<n;++i)\n\n//ダイグスとらで解くそうです\n\nusing namespace std;\n\ntypedef pair<int,int> DisNum;\n\nvector<int> canto;\n\nint Serch(vector<DisNum> canConnect[102],int from,int to,int hp)\n{\n\tint distance[102] = {};//距離を保存\n\tREP(i,102) distance[i] = INT_MAX;\n\tpriority_queue<DisNum,vector<DisNum>,greater<DisNum> > qu;//行き先のストックをキュー\n\tqu.push(DisNum(0,from));\n\tdistance[from] = 0;\n\twhile(!qu.empty())\n\t{\n\t\tDisNum nowfrom;\n\t\tnowfrom = qu.top();qu.pop();\n\t\tif(distance[nowfrom.second] != nowfrom.first) continue;\n\t\tif(nowfrom.second == to) return nowfrom.first;\n\t\tfor(int i=0;i<canConnect[nowfrom.second].size();++i)\n\t\t{\n\t\t\tint v = canConnect[nowfrom.second][i].second;//今から調べる先の座標\n\t\t\tint n = nowfrom.second;\n\t\t\tif(distance[v] > distance[n] + canConnect[nowfrom.second][i].first)\n\t\t\t{\n\t\t\t\tdistance[v] = distance[n] + canConnect[nowfrom.second][i].first;\n\t\t\t\tqu.push(DisNum(distance[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint maxn;\n\tcanto.clear();\n\tvector<DisNum> canConnect[102];\n\tcin >> maxn;\n\tfor(int i=0;i<maxn;++i)\n\t{\n\t\tint r,k;\n\t\tcin >> r >> k;\n\t\tfor(int j=0;j<k;++j)\n\t\t{\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tcanConnect[r].push_back(DisNum(1,t));\n\t\t}\n\t}\n\tint l;\n\tcin >> l;\n\tfor(int j=0;j<l;++j)\n\t{\n\t\tint s,d,v;\n\t\tcin >> s >> d >> v;\n\t\tint ans = Serch(canConnect,s,d,v) + 1;\n\t\tif(ans <= v)\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nvector <int> ro[101],dis;\nqueue <int> Q;\nint n,s,d,v;\nint r,kk;\n\nvoid reset() {\n  dis.resize(n);\n  for(int i=0;i<n;i++) \n    dis[i] = 100000000;\n}\n\n\nint bfs() {\n  Q.push(s);\n  dis[s] = 1;\n  int t,a;\n  while(!Q.empty()) {\n    t = Q.front();\n    Q.pop();\n   \n    for(int i=0;i<ro[t].size();i++) {\n      a = ro[t][i];\n      if(dis[a] > dis[t]+1 ){\n\tdis[a] = dis[t]+1;\n\tif(dis[t]+1 < v && a != d) Q.push(a);\n      }\n    }\n  }\n  return dis[d];\n}\n\nint main() {\n  \n  cin >> n;\n  int a;\n  for(int i=0;i<n;i++) {\n    cin >> r >> kk;\n    ro[r-1].resize(kk);\n    for(int j=0;j<kk;j++) {\n      cin >> a;\n      ro[r-1][j] = a - 1;\n    }\n  }\n  \n  int p;\n  int ans;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n    s--;\n    d--;\n    reset();\n    ans = bfs();\n    if(ans <= v) cout << ans << endl;\n    else cout <<\"NA\" << endl;\n    \n  }\n  \n  return 0;\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define X first\n#define Y second\n#define IND first\n#define Z second.first\n#define V second.second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 101;\n\nbool ok[N][N];\nint n, res, vv;\n\nint main(void){\n    cin >> n;\n\n    rep(i, n){\n        int r, k; cin >> r >> k;\n        while(k--){\n            int t; cin >> t;\n            ok[r][t] = true;\n        }\n    }\n\n    int p; cin >> p;\n    while(p--){\n        int s, d; cin >> s >> d >> vv;\n        res = INF;\n\n        queue< pair<int, pii> > q;\n        q.push(mp(s, mp(d, vv - 1)));\n\n        while(!q.empty()){\n            pair<int, pii> cur = q.front();\n            q.pop();\n\n            if(cur.IND == cur.Z){\n                res = vv - cur.V;\n                break;\n            }\n            if(!cur.V) continue;\n\n            COUNT(i, N)\n                if(ok[cur.IND][i]){\n                    pair<int, pii> next = mp(i, mp(cur.Z, cur.V - 1));\n                    q.push(next);\n                }\n        }\n     \n        if(res == INF) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define MAX 10000000\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge{\n  int to,cost; edge(){}\n  edge(int cost,int to):to(to),cost(cost){}\n};\nvector< vector<edge> > info(110);\nint n,m,co[110],ttl;\n\nvoid init(){\n  for(int i=0;i<110;i++) co[i] = MAX;\n}\n\nint Dijkstra(){\n  init();\n  int s,d;\n  cin >> s >> d >> ttl;\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(0,s));\n  co[s] = 0;\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int now = p.second,c = p.first;\n    if(now == d) return c + 1;\n    for(int i=0;i<info[now].size();i++){\n      edge e = info[now][i];\n      if(e.cost + c < co[e.to]){\n\tque.push(P(e.cost + c,e.to));\n\tco[e.to] = e.cost + c;\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    int r,k,tmp;\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> tmp;\n      info[r].push_back(edge(1,tmp));\n    }\n  }\n  cin >> m;\n  while(m--){\n    int d = Dijkstra();\n    if(d > ttl || d == -1) cout << \"NA\" << endl;\n    else cout << d << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconst int INF=500;\nusing namespace std;\nint main(){\n  int d[100][100],n,p;\n  cin>>n;\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=INF;\n  for(int i=0,r,k,t;i<n&&cin>>r>>k;i++) for(int j=0;j<k&&cin>>t;j++) d[r-1][t-1]=1;\n  for(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]++;\n  cin>>p;\n  for(int i=0,s,t,v;i<p;i++){\n    cin>>s>>t>>v;\n    if(d[s-1][t-1]>v) cout<<\"NA\"<<endl;\n    else cout<<d[s-1][t-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 10000\n\nint n,m,k,s;\nint t[100][100];\n\nint main()\n{\n\tcin >> n;\n\n\tfor(int i=0; i<100; i++)\n\tfor(int j=0; j<100; j++)\n\t\tt[i][j] = INF;\n\n\tfor(int i=0; i<100; i++)\n\t\tt[i][i] = 0;\n\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tcin >> k >> m;\n\t\tfor(int j=0; j<m; j++)\n\t\t{\n\t\t\tcin >> s;\n\t\t\tt[k-1][s-1] = 1;\n\t\t}\n\t}\n\n\tfor(int k=0; k<n; k++)\n\tfor(int i=0; i<n; i++)\n\tfor(int j=0; j<n; j++)\n\t{\n\t\tif(t[i][j]>t[i][k]+t[k][j]) t[i][j] = t[i][k]+t[k][j];\n\t}\n\n\tcin >> n;\n\twhile(n--)\n\t{\n\t\tcin >> k >> s >> m;\n\t\tif(t[k-1][s-1]+1<=m)\n\t\t{\n\t\t\tcout << t[k-1][s-1]+1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\nconst int INF=500;\nusing namespace std;\nint main(void){\n    int d[100][100],n,p;\n    cin>>n;\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=INF;\n    for(int i=0,r,k,t;i<n&&cin>>r>>k;i++) for(int j=0;j<k&&cin>>t;j++) cin>>d[r-1][t-1];\n    for(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cin>>p;\n    for(int i=0,s,t,v;i<p;i++){\n        cin>>s>>t>>v;\n        if(d[s-1][t-1]>v) cout<<\"NA\"<<endl;\n        else cout<<d[s-1][t-1]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint solve( list<int> *router, int from, int to, int ttl ){\n\tset<int> history;\n\tqueue<int> q;\n\tint dist[101];\n\n\tfor( int i = 0;i < 101;i++ ) dist[i] = 9999999;\n\n\thistory.insert( from );\n\tq.push( from );\n\tdist[from] = 1;\n\n\twhile( !q.empty() ){\n\t\tint u = q.front();\n\n\t\tif( dist[u] > ttl ){\n\t\t\tq.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( u == to ){\n\t\t\treturn dist[u];\n\t\t}\n\n\t\tfor( list<int>::iterator it = router[u].begin(); it != router[u].end(); it++ ){\n\t\t\tint v = *it;\n\t\t\tif( history.count( v ) ) continue;\n\t\t\thistory.insert( v );\n\t\t\tdist[v] = dist[u] + 1;\n\t\t\tq.push( v );\n\t\t}\n\t\tq.pop();\n\t}\n\treturn -1;\n}\n\n\n\nint main(void)\n{\n\tint n;\n\tlist<int> router[101];\n\n\tcin >> n;\n\n\tfor( int i = 0;i < n;i++ ){\n\t\tint hoge;\n\t\tint number;\n\t\tint piyo;\n\n\t\tcin >> number >> hoge;\n\n\t\tfor( int j = 0;j < hoge;j++ ){\n\t\t\tcin >> piyo;\n\t\t\trouter[number].push_back( piyo );\n\t\t}\n\t}\n\n\tcin >> n;\n\tint from,to,ttl;\n\tfor( int i = 0;i < n;i++ ){\n\t\tcin >> from >> to >> ttl;\n\t\tint answer = solve( router, from, to, ttl );\n\t\tif( answer == -1 ) cout << \"NA\" << endl;\n\t\telse cout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,b;\n  int ans=0;\n  int box[111][111];\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      box[i][j]=INT_MAX;\n    }\n  }\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      box[r-1][t-1]=1;\n    }\n  }\n  for(int z=0;z<n;z++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tbox[i][j]=min(box[i][j],box[i][z]+box[z][j]);\n      }\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> b;\n    ans=box[s-1][d-1]+1;\n    if(ans<=b){\n      cout << box[s-1][d-1]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<limits.h>\nusing namespace std;\n\nint n;\nint d[103][103];\nvoid wf();\n\nint main(){ \n  while(cin >> n)wf();\n}\n\n\n\n\nvoid wf(){\n  int i1,m,J2;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j)d[i][j]=0;\n      d[i][j]=1000000000;//INT_MAXツつセツづバツグツづゥ\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> i1 >> m;\n    for(int j=0;j<m;j++){\n      cin >> J2;\n      d[i1-1][J2-1]=1;\n    }\n  }\n\n  for(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n  int oh;\n\n  cin >> oh;\n  int st,ed,ttl;\n  for(int i=0;i<oh;i++){\n    cin >> st >> ed >> ttl;\n    if(d[st-1][ed-1]+1 > ttl)cout << \"NA\" << endl;\n    else cout << d[st-1][ed-1]+1 << endl;\n\n  }/*\n for(int i=0;i<n;i++){\n     for(int j=0;j<n;j++)cout << d[i][j] << \" \" ;\n     cout << endl;\n   }\n   */\n\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int INF = 10000;\nconst int VMAX = 108;\n\nint main() {\n  int n;\n  cin >> n;\n  int G[VMAX][VMAX];\n  for (int i = 0; i < VMAX; i++) {\n    for (int j = 0; j < VMAX; j++) {\n      G[i][j] = (i == j ? 0 : INF);\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    int r, k;\n    cin >> r >> k;\n    while (k > 0) {\n      int t;\n      cin >> t;\n      G[r][t] = 1;\n      k--;\n    }\n  }\n\n  for (int k = 0; k < VMAX; k++) {\n    for (int i = 0; i < VMAX; i++) {\n      for (int j = 0; j < VMAX; j++) {\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n      }\n    }\n  }\n\n  int p;\n  cin >> p;\n  for (int i = 0; i < p; i++) {\n    int s, d, v;\n    cin >> s >> d >> v;\n    if (G[s][d] + 1 > v) {\n      cout << \"NA\" << endl;\n    } else {\n      cout << G[s][d] + 1 << endl;\n    }\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>R[105];\n\nint f(int s,int t,int v)\n{\n\tint flg[105][105];\n\tmemset(flg,0x7f,sizeof(flg));\n\tpriority_queue<P>Q;\n\tQ.push(P(1,s));\n\tflg[s][s]=0;\n\tfor(;!Q.empty();)\n\t{\n\t\tP now=Q.top();Q.pop();\n\t\tif(now.second==t)return now.first;\n\t\tif(now.first>=v)continue;\n\t\tint n=now.second;\n\t\tfor(int i=0;i<R[n].size();i++)\n\t\t{\n\t\t\tif(flg[s][R[n][i]]>now.first+1)\n\t\t\t{\n\t\t\t\tflg[s][R[n][i]]=now.first+1;\n\t\t\t\tQ.push(P(now.first+1,R[n][i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint N,M,s,t,v,r;\n\tscanf(\"%d\",&N);\n\tfor(;N--;)\n\t{\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tfor(;t--;)\n\t\t{\n\t\t\tscanf(\"%d\",&v);\n\t\t\tR[s].push_back(v);\n\t\t}\n\t}\n\tscanf(\"%d\",&M);\n\tfor(;M--;)\n\t{\n\t\tscanf(\"%d%d%d\",&s,&t,&v);\n\t\tr=f(s,t,v);\n\t\tif(r!=-1)printf(\"%d\\n\",r);\n\t\telse puts(\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i <= n; i++){\n\t\tfor(int k=1; k <= n; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\n\n\n\t\twhile(!Q.empty() && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+2);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n\nstatic const int NO = -2;\nstatic const int N = 100;\n\n\nint graph[N + 1][N + 1] = {{}};\nint dis[N + 1] = {};\nint n;\n\nvoid bfs(int v){\n  queue<int> Q;\n\n  Q.push(v);\n\n  for(int i = 1; i <= N; i++){\n    dis[i] = NO;\n  }\n\n  dis[v] = 1;\n\n  int u;\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n\n    for(int i = 1;i <= n; i++){\n      if(graph[u][i]==0) continue;\n      if(dis[i]!=NO)continue;\n      dis[i] = dis[u] + 1;\n      Q.push(i);\n\n    }\n  }\n}\n\nint main(){\n\n  int r[N+1] = {};\n  int d[N+1] = {};\n  int k[N+1] = {};\n  int f[N+1] = {};\n  int p,s[N+1] = {};\n  int v[N+1] = {};\n\n\n  //in\n  cin >> n;\n\n  for(int i = 1;i <= n; i++){\n\n    cin >> r[i] >> k[i];\n\n    for(int j = 1;j <= k[i];j++){\n\n      cin >> f[j];\n      graph[i][f[j]] = 1;\n    }\n  }\n\n  cin >> p;\n  for(int i = 1;i <= p; i++){\n    cin >> s[i] >> d[i] >> v[i];\n    bfs(s[i]);\n\n    if(v[i] >= dis[d[i]]) cout << dis[d[i]] << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nint d[105][105];\nint main()\n{\n\tint n,p;\n\tcin >> n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\td[i][j]=INF;\n\t\t\tif(i==j)d[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint r,k;\n\t\tcin >> r >> k;\n\t\tr--;\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint to;\n\t\t\tcin >> to;\n\t\t\tto--;\n\t\t\td[r][to]=1;\n\t\t}\n\t}\n\tfor(int k=0;k<n;k++)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> p;\n\tfor(int i=0;i<p;i++)\n\t{\n\t\tint from,to,TTL;\n\t\tcin >> from >> to >> TTL;\n\t\tfrom--;to--;\n\t\tif(d[from][to]<TTL)cout << d[from][to]+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 101;\n\nbool ok[N][N];\nint n, res, vv;\n\nvoid dfs(int, int, int);\n\nint main(void){\n    cin >> n;\n\n    rep(i, n){\n        int r, k; cin >> r >> k;\n        while(k--){\n            int t; cin >> t;\n            ok[r][t] = true;\n        }\n    }\n\n    int p; cin >> p;\n    while(p--){\n        int s, d; cin >> s >> d >> vv;\n        res = INF;\n\n        dfs(s, d, vv - 1);\n     \n        if(res == INF) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs(int cur, int z, int v){\n    if(cur == z){\n        res = vv - v;\n        return;\n    }\n    if(v == 0) return;\n\n    COUNT(i, n) if(ok[cur][i]) dfs(i, z, v - 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n#define inf INT_MAX/2\nusing namespace std;\nint ok[100][100];\nint main() {\n    int n; scanf(\"%d\",&n);\n    for (int i=0; i<n; i++) for (int j=0; j<n; j++) ok[i][j]=inf;\n    for (int i=0; i<n; i++) {\n        int r,k; scanf(\"%d%d\",&r,&k);\n        for (int j=0; j<k; j++) {\n            int t; scanf(\"%d\",&t);\n            ok[r-1][t-1]=1;\n        }\n    }\n    for (int k=0; k<n; k++) {\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<n; j++) {\n                ok[i][j]=min(ok[i][j],ok[i][k]+ok[k][j]);\n            }\n        }\n    }\n    int p; scanf(\"%d\",&p);\n    for (int i=0; i<p; i++) {\n        int s,d,v; scanf(\"%d%d%d\",&s,&d,&v);\n        if (v<=ok[s-1][d-1]) puts(\"NA\");\n        else printf(\"%d\\n\",ok[s-1][d-1]+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n\nusing namespace std;\n\ntypedef struct {\n  int *ks;\n  int length;\n} node;\n\nnode *nodes;\n\nlist<int> que;\n\nint dikstra(int s, int e, int deep){\n  int c=0;\n\n  que.clear();\n  que.push_back(s);\n\n  int flag = 1;\n\n  while(flag){\n    c++;\n    if(c >= deep) return -1;\n\n    int len = que.size();\n    for(int i=0;flag&&i<len;i++){\n      int v = que.front();\n      que.pop_front();\n      for(int j=0;flag&&j<nodes[v].length;j++){\n        if(nodes[v].ks[j]==e){\n\t  flag=0;\n        }else{\n\t  que.push_back(nodes[v].ks[j]);\n        }\n      }\n    }\n  }\n  return c+1;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  nodes = new node[n];\n\n  int i,j;\n  int t,u,v;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\", &t,&u);\n    nodes[t-1].ks = new int[u];\n    nodes[t-1].length = u;\n    for(j=0;j<u;j++){\n      scanf(\"%d\", &v);\n      nodes[t-1].ks[j] = v-1;\n    }\n  }\n\n  int m;\n  scanf(\"%d\", &m);\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\", &t, &u, &v);\n    int r;\n    if((r=dikstra(t-1, u-1,v)) != -1) printf(\"%d\\n\", r);\n    else puts(\"NA\");\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\ntypedef long long ll;\n\nint d[110][110];\n\nint main(void) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = INF;\n        }\n        d[i][i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n        int r, k;\n        cin >> r >> k;\n        --r;\n        int t;\n        for (int j = 0; j < k; j++) {\n            cin >> t;\n            d[r][t-1] = 1;\n        }\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n    int p;\n    cin >> p;\n    for (int i = 0; i < p; i++) {\n        int s, D, v;\n        cin >> s >> D >> v;\n        if (v >= d[s-1][D-1]) {\n            cout << d[s-1][D-1]+1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1000000000;\n\nint n;\nvector<int> way[128];\n\nint mini(int s, int d, int v);\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tint r, k;\n\t\t\n\t\tscanf(\"%d %d\", &r, &k);\n\t\twhile (k-- > 0){\n\t\t\tint t;\n\t\t\t\n\t\t\tscanf(\"%d\", &t);\n\t\t\tway[r].push_back(t);\n\t\t}\n\t}\n\t\n\tint p;\n\t\n\tscanf(\"%d\", &p);\n\twhile (p-- > 0){\n\t\tint s, d, v;\n\t\t\n\t\tscanf(\"%d %d %d\", &s, &d, &v);\n\t\tint cost = mini(s, d, v);\n\t\tif (cost == INF) puts(\"NA\");\n\t\telse printf(\"%d\\n\", cost);\n\t}\n\t\n\treturn 0;\n}\n\nint mini(int s, int d, int v)\n{\n\tint diff[128];\n\tqueue<P> q;\n\t\n\tfill(diff, diff + n + 1, INF);\n\tq.push(P(s, 1));\n\tdiff[s] = 1;\n\twhile (!q.empty()){\n\t\tP p = q.front(); q.pop();\n\t\t\n\t\tif (diff[p.first] < p.second) continue;\n\t\tfor (int i = 0; i < way[p.first].size(); i++){\n\t\t\tint tmp = way[p.first][i];\n\t\t\t\n\t\t\tif (diff[tmp] > diff[p.first] + 1){\n\t\t\t\tdiff[tmp] = diff[p.first] + 1;\n\t\t\t\tq.push(P(tmp, diff[tmp]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (diff[d] == INF || diff[d] > v) return INF;\n\telse return diff[d];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\n\nint main(){\n  int n;\n\tcin>>n;\n\tint graph[n][n];\n\tfor(int j=0;j<n;j++)\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==j)\n\t\t\t\tgraph[j][i] = 1;\n\t\t\telse\n\t\t\t\tgraph[j][i] = 1000;\n\t\t}\n\tfor(int i=0;i<n;i++){\n\t\tint k,m,l;\n\t\tcin>>k>>m;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcin>>l;\n\t\t\tgraph[k-1][l-1] = 1;\n\t\t}\n\t}\n\t\n\tfor(int j = 0;j<n;j++)\n\t\tfor(int i = 0;i<n;i++)\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\tif(graph[i][j]>graph[i][k]+graph[k][j])\n\t\t\t\t\tgraph[i][j] = graph[i][k]+graph[k][j];\n\tint p;\n\tcin>>p;\n\tfor(int i=0;i<p;i++){\n\t\tint s,d,v;\n\t\tcin>>s>>d>>v;\n\t\tif(graph[s-1][d-1]<v)\n\t\t\tcout<<graph[s-1][d-1]+1<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint d[200][200];\nint main(){\n    int n;\n    cin>>n;\n    rep(i,200)rep(j,200)d[i][j]=1<<29;\n    rep(i,200)d[i][i]=0;\n    rep(i,n){\n        int src,k;\n        cin>>src>>k;\n        src--;\n        rep(j,k){\n            int dst;cin>>dst;\n            dst--;\n            d[src][dst] = 1;\n        }\n    }\n\n    rep(k,n)rep(i,n)rep(j,n)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    int p;cin>>p;\n    rep(i,p){\n        int s,t,ttl;\n        cin>>s>>t>>ttl;--s,--t;\n        if(d[s][t] >= ttl) puts(\"NA\");\n        else printf(\"%d\\n\", d[s][t]+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int dist[100][100];\n    const int INF=1000000;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            dist[i][j]=INF;\n        }\n    }\n    for(int i=0;i<n;i++){\n        int r,k,t;\n        scanf(\"%d%d\",&r,&k);\n        r--;\n        for(int j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            t--;\n            dist[r][t]=1;\n        }\n    }\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n    int p;\n    scanf(\"%d\",&p);\n    for(int i=0;i<p;i++){\n        int s,d,v;\n        scanf(\"%d%d%d\",&s,&d,&v);\n        s--;d--;\n        if(dist[s][d]>=v) printf(\"NA\\n\");\n        else printf(\"%d\\n\",dist[s][d]+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tvvi cost(100, vi(100, INF));\n\n\tint n;\n\tcin >> n;\n\tint r, k, t;\n\tREP(i, n) {\n\t\tcin >> r >> k;\n\t\tREP(j, k) {\n\t\t\tcin >> t;\n\t\t\tcost[r-1][t-1] = 1;\n\t\t}\n\t}\n\n\tREP(k, 100) {\n\t\tREP(i, 100) {\n\t\t\tREP(j, 100) {\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> n;\n\tREP(i, n) {\n\t\tcin >> r >> k >> t;\n\t\tif(cost[r-1][k-1]+1 <= t) {\n\t\t\tcout << cost[r-1][k-1]+1 << endl;\n\t\t} else {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[100];\nint s,d,v;\nint s2,d2;\nint kk[100],n;\nbool flg[101] ;\n\nvoid visit(int sn,int dis) {\n  int x;\n  \n  flg[sn] = 1;\n  \n  if(sn == d2 && dis <=v){\n    md = min(md,dis);\n  }\n  \n  else if(dis <= v) {\n    for(int i=0;i<ro[sn].size();i++) {\n      for(int j=0;j<n;j++)\n\tif(ro[sn][i] == kk[j]) {\n\t  x = j;\n\t  break;\n\t}\n      if(dis == 1){\n\tfor(int i=0;i<=n;i++) flg[i] = 0;\n\t//\tcout <<\"reset\"<<endl;\n\tflg[s2] = 1;\n      }\n      //       cout <<sn+1 << \"to\"<<x+1 << endl;\n      if(flg[x] == 0) visit(x,dis+1);\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk[i];\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[i][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n\n   \n    for(int i=0;i<n;i++){\n      if(kk[i] == s) s2 = i;\n      if(kk[i] == d) d2 = i;\n    }\n\n    for(int i=0;i<=n;i++) flg[i] = 0;\n    md = 10000000;\n   \n    visit(s2,1);\n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint wf[101][101],n;\tcin>>n;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)wf[i][j]=1000000;\n\tfor(int i=0;i<n;i++){\n\t\tint r,k;\tcin>>r>>k;\n\t\tfor(int t;k--;)\tcin>>t,wf[r][t]=1;\n\t}\n\n\tfor(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)wf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n\n\tint p;\tcin>>p;\n\twhile(p--){\n\t\tint s,d,ttl;\tcin>>s>>d>>ttl;\n\t\tif(wf[s][d]<ttl)\tcout<<wf[s][d]+1<<endl;\n\t\telse\tcout<<\"NA\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(101);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    vector<bool> check(101, false);\n    queue<int> fq, nq, sq;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            if (check[pos]) {\n                continue;\n            } else {\n                check[pos] = true;\n            }\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            } else {\n                for (int i: g[pos]) {\n                    nq.push(i);\n                }\n            }\n        }\n        if (c == 0) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define X first\n#define Y second\n#define IND first\n#define Z second.first\n#define V second.second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 101;\n\nbool ok[N][N];\nbool visited[N];\nint n, res, vv;\n\nint main(void){\n    cin >> n;\n\n    rep(i, n){\n        int r, k; cin >> r >> k;\n        while(k--){\n            int t; cin >> t;\n            ok[r][t] = true;\n        }\n    }\n\n    int p; cin >> p;\n    while(p--){\n        int s, d; cin >> s >> d >> vv;\n        res = INF;\n        COUNT(i, N) visited[i] = false;\n\n        queue< pair<int, pii> > q;\n        q.push(mp(s, mp(d, vv - 1)));\n\n        while(!q.empty()){\n            pair<int, pii> cur = q.front();\n            q.pop();\n\n            if(cur.IND == cur.Z){\n                res = vv - cur.V;\n                break;\n            }\n            if(!cur.V || visited[cur.IND]) continue;\n            visited[cur.IND] = true;\n\n            COUNT(i, N)\n                if(ok[cur.IND][i]){\n                    pair<int, pii> next = mp(i, mp(cur.Z, cur.V - 1));\n                    q.push(next);\n                }\n        }\n     \n        if(res == INF) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100\n#define INF 100000\n \nint main()\n{\n    int n;\n    cin >> n;\n    int d[MAX][MAX];\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    d[i][j] = INF;\n\t}\n    }\n    for (int i = 0; i < n; i++) {\n\tint r, k, t;\n\tcin >> r >> k; r--;\n\tfor (int j = 0; j < k; j++) {\n\t    cin >> t; t--;\n\t    d[r][t] = 1;\n\t}\n    }\n    for (int k = 0; k < n; k++) {\n\tfor (int i = 0; i < n; i++) {\n\t    for (int j = 0; j < n; j++) {\n\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t    }\n\t}\n    }\n    \n    int p, s, t, v;\n    cin >> p;\n    for (int i = 0; i < p; i++) {\n\tcin >> s >> t >> v; s--; t--;\n\tif (d[s][t]+1 <= v) {\n\t    cout << d[s][t]+1 << endl;\n\t} else {\n\t    cout << \"NA\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconst int INF=1e9;\nusing namespace std;\nint main(){\n  int d[100][100],n,p;\n  cin>>n;\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=INF;\n  for(int i=0,r,k,t;i<n&&cin>>r>>k;i++) for(int j=0;j<k&&cin>>t;j++) d[r-1][t-1]=1;\n  for(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]++;\n  cin>>p;\n  for(int i=0,s,t,v;i<p;i++){\n    cin>>s>>t>>v;\n    if(d[s-1][t-1]>v) cout<<\"NA\"<<endl;\n    else cout<<d[s-1][t-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(i);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(Q.empty() == false && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(FLG)break;\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+1+memo[i][goal]);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+1+memo[i][goal];\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> node[200];\n\nint que(int s,int d,int v)\n{\n  queue<P> qu;\n  int c[200];\n  memset(c,-1,sizeof(c));\n  for(int i=0;i<node[s].size();i++)\n    {\n      if(v-1>0)\n\tqu.push(P(node[s][i],v-1));      \n    }\n  while(!qu.empty())\n    {\n      P a = qu.front();\n      qu.pop();\n      //      cout<<a.first<<\" \"<<a.second<<endl;\n      if(a.first==d)\n\treturn v-a.second+1;\n      for(int i=0;i<node[a.first].size();i++)\n\t{\n\t  if(a.second-1>0)\n\t    {\n\t      if(c[node[a.first][i]]==-1)\n\t\t{\n\t\t  c[node[a.first][i]]=a.second-1;\n\t\t  qu.push(P(node[a.first][i],a.second-1));\t    \n\t\t}\n\t    }\n\t} \n    }\n      return -1;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(;n--;)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k].push_back(tmp);\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      int ans=que(s,d,v);\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n      \n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    int n,p;\n    int map[101][101];\n    memset(map,10000,sizeof(map));\n    cin >> n;\n    REP(i,n){\n\tint r,k,t;\n\tcin >> r >> k;\n\tREP(j,k){\n\t    cin >> t;\n\t    map[r][t] = 1;\n\t}\n    }\n    n++;\n    while(true){\n\tbool flg = false;\n\tREP(k,n){\n\t    REP(i,n){\n\t\tREP(j,n){\n\t\t    if(map[i][j] > (map[i][k] + map[k][j])){\n\t\t\tflg = true;\n\t\t\tmap[i][j] = map[i][k] + map[k][j];\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif(!flg) break;\n    }\n\n    cin >> p;\n    REP(a,p){\n\tint s,d,v;\n\tcin >> s >> d >> v;\n\tif(map[s][d] < v) cout << map[s][d]+1 << endl;\n\telse cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\n/* main??? */\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\n/* ???????????¢??° */\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\n/* ??????????????\\?¶??????±??\\?????¢??° */\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++){\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ???????????±???????????±??\\?????¢??° */\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcSumRouter(i4StartRouter,i4GoalRouter,i4TTL);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ??????????????????????¨????????????°?¨??????¢??° */\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\t/* ?????°??£?¨? */\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\t/* ????????¨ */\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\tI4 i4RoopMax;\n\t\n\t/* ????????? */\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\tif(i4TTL<=i4RouterNum){\n\t\ti4RoopMax = i4TTL;\n\t}\n\telse{\n\t\ti4RoopMax == i4RouterNum;\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<i4RoopMax; i4RoopCnt1++){\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=i4RouterNum; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i <= n; i++){\n\t\tfor(int k=1; k <= n; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\n\n\n\t\twhile(!Q.empty() && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && (memo[i][goal]+1) < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+2);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <array>\n\nint main() {\n  static int const MaxElement = 100;\n  std::array<std::array<bool, MaxElement>, MaxElement> map = {};\n\n  int n = 0;\n  std::cin >> n;\n  for( int i=0; i<n; ++i ) {\n\tint r = 0, k = 0;\n\tstd::cin >> r >> k;\n\tfor( int j=0; j<k; ++j ) {\n\t  int idx = 0;\n\t  std::cin >> idx;\n\t  map[r-1][idx-1] = true;\n\t}\n  }\n\n  int m = 0;\n  std::cin >> m;\n  for( int i=0; i<m; ++i ) {\n\tint src = 0, dst = 0, ttl = 0;\n\tstd::cin >> src >> dst >> ttl;\n\n\tstd::array<int, MaxElement> distance;\n\tdistance.fill( -1 );\n\n\tstd::queue<int> q;\n\tq.push( src - 1 );\n\tdistance[src-1] = 0;\n\twhile( !q.empty() ) {\n\t  int const u = q.front();\n\t  q.pop();\n\t  for( int v=0; v<n; ++v ) {\n\t\tif ( map[u][v] && distance[v] == -1 ) {\n\t\t  distance[v] = distance[u] + 1;\n\t\t  q.push( v );\n\t\t}\n\t  }\n\t}\n\n\tif ( distance[dst-1] == -1 || ttl - distance[dst-1] <= 0 ) {\n\t  std::cout << \"NA\" << std::endl;\n\t} else {\n\t  std::cout <<  distance[dst-1] + 1 << std::endl;\n\t}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n, r, k, t;\nint net[100][100];\n\nvoid warshall_floyd() {\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<n; j++) {\n      for(int k=0; k<n; k++) {\n\tnet[j][k] = min(net[j][k], net[j][i] + net[i][k]);\n      }\n    }\n  }\n}\n\nint main() {\n\n  cin>> n;\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<n; j++) {\n      net[i][j] = INF;\n    }\n  }\n\n  for(int i=0; i<n; i++) {\n    cin>> r>> k;  \n    r--;\n    for(int j=0; j<k; j++) {\n      cin>> t;  \n      t--;\n      net[r][t] = 1;\n    }\n  }\n\n  warshall_floyd();\n\n  int p;\n  cin>> p;\n  for(int i=0; i<p; i++) {\n    int s, d, v;\n    cin>> s>> d>> v;\n    s--; d--;\n    if(net[s][d]+1>v) cout<< \"NA\"<< endl;\n    else cout<< net[s][d]+1<< endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n\tint table[128][128];\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++)\n\t\t\ttable[i][j] = 10000;\n\t\ttable[i][i] = 0;\n\t}\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\t\tint s, k;\n\n\t\tcin >> s;\n\t\tcin >> k;\n\t\tfor(int j = 0; j < k; j++) {\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\ttable[s][d] = 1;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\tfor(int j = 0; j < 128; j++)\n\t\t\tfor(int k = 0; k < 128; k++)\n\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\n\tint p;\n\tcin >> p;\n\n\tfor(int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tint tmp = table[s][d] + 1;\n\t\tif(v < tmp)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << tmp << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define it vector<int>::iterator\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tvvi cost(n+1,vi(n+1,inf));\n\trep(i,n){\n\t\tint s,m;\n\t\tcin>>s>>m;\n\t\trep(j,m){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tcost[s][t]=1;\n\t\t}\n\t}\n\trep(k,n+1)rep(i,n+1)rep(j,n+1)\n\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\tint m;\n\tcin>>m;\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tint t=cost[a][b]+1;\n\t\tif(t>c)cout<<\"NA\"<<endl;\n\t\telse cout<<t<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcRouterSum(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER)\n\t{\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL)\n\t{\n\t\tprintf(\"start:%d,goal:%d,TTL:%d\\n\",i4StartRouter,i4GoalRouter,i4TTL);\n\t\ti4Ans = CalcRouterSum(i4StartRouter,i4GoalRouter,i4TTL,1);\n\t\tif(i4Ans >= i4TTL+1){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\tprintf(\"--------------\\n\");\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcRouterSum(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum)\n{\n\tprintf(\"%d -> %d,TTL=%d\\n\",i4Sender,i4Destination,i4TTL);\n\tI4 i4RoopCnt1;\n\tI4 i4MinRouterNum;\n\tI4 i4TmpRouterSum;\n\tI4 i4Return;\n\t\n\t\n\ti4Return = i4TTL+i4RouterSum;\n\t\n\tif(i4Sender == i4Destination)\n\t{\n\t\tprintf(\"RouterSum=%d\\n\",i4RouterSum);\n\t\treturn i4RouterSum;\n\t}\n\telse\n\t{\n\t\tif(i4TTL <= 0)\n\t\t{\n\t\t\tprintf(\"TTL is 0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti4RoopCnt1 = 1;\n\t\t\twhile(u1Connect[i4Sender][i4RoopCnt1] != SENTINEL){\n\t\t\t\tif(u1Connect[i4Sender][i4RoopCnt1] == CONNECT)\n\t\t\t\t{\n\t\t\t\t\ti4TmpRouterSum = CalcRouterSum(i4RoopCnt1,i4Destination,i4TTL-1,i4RouterSum+1);\n\t\t\t\t\tif((i4TmpRouterSum > 0 ) && (i4TmpRouterSum < i4Return))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"CalcRouterSum()=%d\\n\",i4TmpRouterSum);\n\t\t\t\t\t\ti4Return = i4TmpRouterSum;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\ti4RoopCnt1++;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn i4Return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    vector<vector<int> > dp(n, vector<int>(n, INF));\n    for (int i = 0; i < n; ++i) {\n      int r, k;\n      cin >> r >> k;\n      --r;\n      for (int j = 0; j < k; ++j) {\n\tint t;\n\tcin >> t;\n\t--t;\n\tdp[r][t] = 1;\n      }\n    }\n\n    for (int k = 0; k < n; ++k) {\n      for (int i = 0; i < n; ++i) {\n\tfor (int j = 0; j < n; ++j)\n\t  dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n      }\n    }\n\n    int p;\n    cin >> p;\n    while (p--) {\n      int s, d, v;\n      cin >> s >> d >> v;\n      --s;\n      --d;\n      if (dp[s][d] < v)\n\tcout << dp[s][d]+1 << endl;\n      else\n\tcout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){\n\t\tttl = current = 0;\n\t}\n\n\tvoid copy(Packet t){\n\t\tttl = t.ttl;\n\t\tcurrent = t.current;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = t.checkTable[i];\n\t}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit;\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int d = 1; d <= n; d++){\n\t\t\t\tif(d != start && table[start][d] == 1){\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(d);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp.copy(Q.front());\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.ttl > 0 && tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1 && t_limit-tmp.ttl + 1 <= n){\n\t\t\t\tfor(int m=1; m <= n; m++){\n\t\t\t\t\tif(m != tmp.current && tmp.checkTable[m] == 0 && table[tmp.current][m] == 1){\n\t\t\t\t\t\tPacket q;\n\t\t\t\t\t\tq.copy(tmp);\n\t\t\t\t\t\tq.ttl--;\n\t\t\t\t\t\tq.set(m);\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <string.h>\n#include <set>\n\n\nusing namespace std;\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        int graph[101][101]={0};\n        for(int roop=0; roop<n; roop++){\n            int r;\n            cin>>r;\n            int k;\n            cin>>k;\n            for(int roop2=0; roop2<k; roop2++){\n                int t;\n                cin>>t;\n                graph[r][t]=1;\n            }\n        }\n        \n        int q;\n        cin>>q;\n        for(int roop=0; roop<q; roop++){\n            int s,d,v;\n            cin>>s>>d>>v;\n            int visit[101]={0};\n            visit[s]=1;\n            queue<pair<int,int>> qu;\n            pair<int,int> now;\n            now.first=s;\n            now.second=v;\n            qu.push(now);\n            bool find=false;\n            \n            \n            while(!qu.empty()){\n                \n                now=qu.front();\n                //cout<<now.first<<\" \"<<now.second<<endl;\n                qu.pop();\n                if(now.first==d){\n                    find=true;\n                    break;\n                }\n                if(now.second>1){\n                    for(int i=1; i<=n; i++){\n                        if(graph[now.first][i]==1&&visit[i]==0){\n                            visit[i]=1;\n                            pair<int,int> temp;\n                            temp.first=i;\n                            temp.second=now.second-1;\n                            qu.push(temp);\n                        }\n                    }\n                }\n            }\n            if(find)cout<<v-now.second+1<<endl;\n            else cout<<\"NA\"<<endl;\n            \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nvector<int> hyou[110];\n\nint hyou2[110];\n\nint bfs(int s, int d) {\n\tqueue<int> q;\n\tq.push(s);\n\tint k;\n\thyou2[s] = 0;\n\twhile (!q.empty()) {\n\t\tk = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < hyou[k].size(); i++) {\n\t\t\tint t = hyou[k][i];\n\t\t\tif (hyou2[t] != -1) {\n\t\t\t} else {\n\t\t\t\thyou2[t] = hyou2[k]+1;\n\t\t\t\tif (t == d) {\n\t\t\t\t\treturn hyou2[t];\n\t\t\t\t}\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint a, b, c;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a >> b;\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> c;\n\t\t\thyou[a].push_back(c);\n\t\t}\n\t}\n\tint k;\n\tint p, q, r;\n\tcin >> k;\n\tfor (int i = 0; i < k; i++) {\n\t\tcin >> p >> q >> r;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\thyou2[j] = -1;\n\t\t}\n\t\tint g = bfs(p, q);\n\t\tif (g != 0 && r > g) {\n\t\t\tcout << g+1 << endl;\n\t\t} else {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,p;\n  int dis[101][101];\n  int r,k,t;\n  int s,d,v;\n\n  cin >> n;\n\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      dis[i][j] = 100;\n      if(i==j)dis[i][j] = 0;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      dis[r][t] = 1;\n    }\n  }\n\n  for(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++)dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j]);\n    }\n  }\n\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> v;\n    if(dis[s][d]+1>v)cout << \"NA\" << endl;\n    else cout << dis[s][d]+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101],P[101],D[101],num,min,min_index,current;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <=  t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int index=1; index <= n; index++){\n\t\t\tP[index] = 0; //???????????????????????¨???????????????\n\t\t\tD[index] = 1000000000; //start??°?????????????????¢?????¨???????????????\n\t\t}\n\n\t\tP[start] = 1; //??????????????°????????????????????¨??????\n\t\tnum = 1;\n\n\t\tfor(int index = 1; index <= n; index++){\n\t\t\tif(index != start && table[start][index] == 1){\n\t\t\t\tD[index] = 1;  //start??°???????????????????????????start??°??????????????¢1??¨??????\n\t\t\t}\n\t\t}\n\n\t\twhile(num < n){\n\t\t\tmin = 1000000000;\n\t\t\tfor(int index=1;index <= n; index++){  //??????????????°?????????????????????????????¢???\n\t\t\t\tif(P[index] == 0 && D[index] < min){ //?????????????????§?????????????????????????????????\n\t\t\t\t\tmin = D[index];\n\t\t\t\t\tmin_index =index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(min == 1000000000)break; //?????????????????????????????????????????°break\n\n\t\t\tP[min_index] = 1; //min_index?????????????????¨??????\n\t\t\tcurrent = min_index;\n\t\t\tnum++; //???????????????????????°???1?¢???????\n\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tif(table[current][i] == 1){\t//start???????????????????????¨???????????£????????????\n\t\t\t\t\tD[i] = (D[i] <= (D[current]+1))?D[i]:(D[current]+1); //?????????????????´??\\????????¢??¨???current????????±???????????¢???????????????D??¨??????\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif(D[goal] >= t_limit){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tmemo[start][goal] = D[goal]+1;\n\t\t\tprintf(\"%d\\n\",D[goal]+1);\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); i++ )\n#define UREP( i, m, n ) for ( unsigned int i = (unsigned int)( m ); i < (unsigned int)( n ); i++ )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define RALL( c ) (c).rbegin(), (c).rend()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n// 隣接リスト -> min{s, t}\nint dijkstra( vector< vector<PII> > graph, const int start, const int goal )\n{\n\tvector<int> distance( graph.size() );\n\tfill( ALL( distance ), INT_MAX );\n\n\tpriority_queue< PII, vector< PII >, greater< PII > > que; // 累計コスト, ノード番号\n\tque.push( MP( 0, start ) );\n\n\twhile ( !que.empty() )\n\t{\n\t\tint total = que.top().fst;\n\t\tint node = que.top().snd;\n\t\tque.pop();\n\n\t\tif ( total < distance[ node ] )\n\t\t{\n\t\t\tdistance[ node ] = total;\n\n\t\t\tREP( i, 0, graph[ node ].size() )\n\t\t\t{\n\t\t\t\tint to = graph[ node ][i].fst;\n\t\t\t\tint cost = graph[ node ][i].snd;\n\n\t\t\t\tque.push( MP( total + cost, to ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn distance[ goal ];\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tvector< vector< PII > > graph( n );\n\n\tREP( dn, 0, n )\n\t{\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tr--;\n\n\t\tREP( dk, 0, k )\n\t\t{\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tt--;\n\n\t\t\tgraph[r].PB( MP( t, 1 ) );\n\t\t}\n\t}\n\n\tint p;\n\tcin >> p;\n\n\tREP( dp, 0, p )\n\t{\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\ts--;\n\t\td--;\n\n\t\tint res = dijkstra( graph, s, d ) + 1;\n\n\t\tif ( res <= v )\n\t\t{\n\t\t\tcout << res << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\t\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n  cin >> n;\n  \n  int data[n+1][n+1];\n  \n  for(int i = 0; i <= n; i++){\n    for(int j = 0; j <= n; j++){\n      data[i][j] = 0;\n    }\n  }\n  \n  int from, to, conesum;\n  \n  for(int i = 0; i < n; i++){\n    cin >> from >> conesum;\n    for(int j = 0; j < conesum; j++){\n      cin >> to;\n      data[from][to] = 1;\n    }\n  }\n  //graph end  \n  \n\n\n  int sumpake;\n  cin >> sumpake;\n  \n    queue<int> Q;\n\n    int ttl, myposi, min, sumin, sumina, finish = 0;\n\n    int come[n+1];\n\n    for(int i = 0; i < sumpake; i++){\n    for(int i = 0; i < n+1; i++) come[i] = 0;\n      min = 0;\n      cin >> from >> to >> ttl;\n      myposi = from;\n      come[myposi] = 1;\n      for(int j = 0; j < ttl; j++){\n\tif(j != 0){\n\t  for(int l = 0; l < sumina; l++){\n\t    if(Q.front() == to){\n\t      min = j;\n\t      finish = 1;\n\t      break;\n\t    }\n\t    myposi = Q.front();\n\t    Q.pop();\n\t    if(come[myposi] == 0){\n\t      for(int k = 1; k <= n; k++){\n\t\tif(data[myposi][k] == 1) {\n\t\t  Q.push(k);\n\t\t  sumin++;\n\t\t}\n\t      }\n\t    }\n\t    come[myposi] = 1;\n\t  }\n\t  if(finish == 1) break;\n\t}else{\n\t  sumin = 0;\n\t  for(int k = 1; k <= n; k++){\n\t    if(data[myposi][k] == 1) {\n\t      Q.push(k);\n\t      sumin++;\n\t    }\n\t  }\n\t  \n\t}\n\t  sumina = sumin;\n\t  sumin = 0;\n      }\n      \n      if(min == 0) cout << \"NA\";\n      else cout << min+1;\n      cout << endl;\n      finish = 0;\n      while(!Q.empty()) Q.pop();\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#define MAX_N 110\n#define INF (1<<30)\nbool A[MAX_N][MAX_N];\nint rooter_num;\nusing namespace std;\nint bfs(int,int);\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  int a;\n  memset(A,false,sizeof(A));\n  cin>>rooter_num;\n  /*------------input---------------*/\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r][t]=true;\n\t}\n    }\n  cin>>n;\n  /*-------------search--------------*/\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      a=bfs(startNode,goalNode);\n      //cout<<\"TTL=\"<<TTL<<\";\"<<\"a-1=\"<<a<<endl;\n      /*\n\t TTLの減少値 = (それまでに通ったルータの数) - 1\n\t 直前のNodeでTTLが1以上ならばパケットが通るので\n\t goal地点でのTTLの減少値がTTLと同等,またはそれ以下ならば\n\t パケットが通る事になる。\n       */\n      if(a<=TTL)cout<<a<<endl;\n      else cout<<\"NA\"<<endl;\n       \n    }\n  return 0;\n}\nint bfs(int startNode,int goalNode)\n{\n  queue<int>Q;\n  int visited[rooter_num+1];\n  /*\n    visitedは既に通過しているかの判定と経由したルータの数を保持する\n  */\n  memset(visited,0,sizeof(visited));\n  /*\n    memsetによって全てを０で初期化する\n  */\n\n  int currentNode=startNode;\n  Q.push(currentNode);\n  visited[currentNode]=1;\n\n  /*-------BFS--------*/  \n  while(!Q.empty())\n    {\n      currentNode=Q.front();\n      Q.pop();\n      for(int nextNode=1;nextNode<=rooter_num;nextNode++)\n\t{\n\n\t  if(A[currentNode][nextNode]==0)continue;\n\t  /*\n\t    接続されていない場合を切り取った\n\t  */\n\t  if(nextNode==goalNode)return visited[currentNode]+1;\n\t  /*\n\t    goalNodeの接続を確認したので探索を打ち切る\n\t  */\n\t  if(visited[nextNode]<=0)\n\t    {\n\t      visited[nextNode]=visited[currentNode]+1;\n\t      Q.push(nextNode);\n\t    }\n\t  /*\n\t    まだ訪れていない(かつ接続出来るNodeを)キューに追加する\n\t   */\n\t}\n    }\n  return INF;\n  /*\n    接続出来ない場合無限大を返す\n   */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n\n#define NONE INT_MAX>>1\n\nvector< vector<int> > WarshallFloyd(vector< vector<int> >A)\n{\n  for(int k=0;k<A.size();k++)\n    for(int i=0;i<A.size();i++)\n      for(int j=0;j<A.size();j++)\n        A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n  return A;\n}\n\nint main()\n{\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,v;\n\n  cin>>n;\n  vector< vector<int> > m(n+1,vector<int>(n+1,NONE));\n  for(int i=0;i<n;i++){\n    cin>>r>>k;\n    for(int j=0;j<k;j++){\n      cin>>t;\n      m[r][t]=1;\n    }\n  }\n  m=WarshallFloyd(m);\n\n  cin>>p;\n  for(int i=0;i<p;i++){\n    cin>>s>>d>>v;\n    if(m[s][d]<v)cout<<m[s][d]+1<<endl;\n    else puts(\"NA\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> NODE;\n\nmap<int,vector<int> > list;\n\nint bfs(int s,int g){\n\tmap<int,bool> done;\n\tqueue< NODE > Q;\n\tQ.push( make_pair(s,1) );\n\twhile(!Q.empty()){\n\t\tNODE q = Q.front();\n\t\tQ.pop();\n\t\tdone[q.first] = true;\n\t\t\n\t\tif(q.first == g){\n\t\t\treturn q.second;\n\t\t}\n\t\tfor(int i=0;i<list[q.first].size();i++){\n\t\t\tif( !done[ list[q.first][i] ] )Q.push( make_pair(list[q.first][i],q.second+1) );\n\t\t}\n\t}\n\tcout << endl;\n\treturn (1<<21);\n}\nint main(){\n\tint n,r,k,t;\n\tint p,s,d,v;\n\tcin >> n;\n\tlist.clear();\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tlist[r].push_back(t);\n\t\t}\n\t}\n\tcin >> p;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> s >> d >> v;\n\t\tint ret = bfs(s,d);\n\t\tif( ret <= v){\n\t\t\tcout << ret << endl; \n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(vector<int> t[],int k[],int b[],int c,int s,int d,int v){\n  int i;\n  if(v==0);\n  else if(s==d){\n    if(b[s]==0||b[s]>c)\n      b[s]=c;\n  }else if(b[s]==0||b[s]>c){\n    b[s]=c;\n    for(i=0;i<k[s];i++)\n      f(t,k,b,c+1,t[s][i],d,v-1);\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int k[101],b[101],n,p,s,d,v;\n  vector<int> t[101],u;\n  cin>>n;\n  for(i=0;i<n;i++){\n    int q,r;\n    cin>>r>>q;\n    k[r]=q;\n    t[r].reserve(k[r]);\n    for(j=0;j<k[r];j++)\n      cin>>t[r][j];\n  }\n  cin>>p;\n  u.reserve(p);\n  for(i=0;i<p;i++){\n    cin>>s>>d>>v;\n    memset(b,0,sizeof(b));\n    f(t,k,b,1,s,d,v);\n    u[i]=b[d];\n  }\n  for(i=0;i<p;i++){\n    if(u[i])\n      cout<<u[i]<<endl;\n    else\n      cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nvoid debug();\n\nint main(){\n\n \n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n\n    for(int k=0;k<maxx;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  // cout << \"maxx =\" << maxx << endl;\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n\n  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  //  debug();\n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=maxx;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;  \n\n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      if(mem == n)break;\n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\nvoid debug(){\n  for(int i=1;i<=maxx;i++){\n    if(i==1){\n      cout << \"   \";\n      for(int k=1;k<=maxx;k++){\n\tprintf(\"%3d\",k);\n      }\n      cout << endl;\n      for(int k=1;k<=maxx;k++)printf(\"___\");\n      cout << endl;\n    }\n\n    for(int j=1;j<=maxx;j++){\n      if(j == 1)cout << i << \" |\";\n      printf(\"%3d\",net[i][j]);\n    }\n    cout << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tvint ch(n+100);\n\tvvint vv;\n\tinitvv(vv,n,n,INF);\n\tvvint tt(n);\n\trep(i,n){\n\t\trep(j,2){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\ttt[i].PB(t);\n\t\t}\n\t\trep(j,tt[i][1]){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\ttt[i].PB(t);\n\t\t}\n\t\tch[tt[i][0]]=i;\n\t}\n\trep(i,n){\n\t\t// int r,k;\n\t\t// cin>>r>>k;\n\t\t// ch[r]=i;\n\t\trep(j,tt[i][1]){\n\t\t\t// int a;\n\t\t\tvv[i][ch[tt[i][j+2]]]=1;\n\t\t}\n\t}\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tvv[i][j]=min(vv[i][j],vv[i][k]+vv[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tcin>>p;\n\trep(i,p){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tint t=vv[ch[a]][ch[b]];\n\t\tif(t>=INF||t+1>c) cout<<\"NA\\n\";\n\t\telse cout<<t+1<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[101];\nint s,d,v;\nint s2,d2;\nint kk[101],n;\nbool flg[102] ;\nint dmap[102][102];\n\nvoid reset() {\n\n  for(int i=0;i<=n;i++) {\n    for(int j=0;j<=n;j++) {\n\tdmap[i][j] = 10000000;\n    }\n  }\n}\n\nvoid visit(int sn,int dis) {\n  int x;\n  \n  flg[sn+1] = 1;\n  if(sn == d && dis <=100)  dmap[s][d] = min(dmap[s][d],dis);\n\n  else if(dis < dmap[s][d]) {\n    for(int i=0;i<ro[sn].size();i++) {\n      \n      if(flg[ro[sn][i]] == 0){\n\t\tcout <<sn+1 << \"to\"<<ro[sn][i] << endl;\n\tvisit(ro[sn][i]-1,dis+1);\n\tflg[ro[sn][i]] = 0;\n      }\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk[i];\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[kk[i]-1][j];\n  }\n\n  reset();\n  for(int k=0;k<=n;k++) flg[k] = 0;\n  for(int i=0;i<n;i++) {\n    for(int j=1;j<=n;j++) {\n      cout <<i+1<<\"kara\"<<j+1<<endl;\n      cout <<\"-------------------------\" <<endl;      \n      d = j;\n      s = i;\n      if(i != j) visit(i,1);\n      cout << dmap[i][j] << endl;\n      \n      for(int i=1;i<=n;i++)cout << flg[i];\n      cout <<\" \";\n   \n      \n    }\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n\n    if(dmap[s-1][d-1] <= v) \n      cout << dmap[s-1][d-1] << endl;\n    else cout << \"NA\" << endl;\n  \n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main(){\n  int a,b,c,d,e,f,g,now,v[101],m[101][101]={};\n  queue<int> q;\n  cin >> a;\n  for(int i=1;i<=a;i++){\n    cin >>b>>c;\n    for(int j=0;j<c;j++){\n      cin >> d;\n      m[i][d]=1;\n    }\n  }\n  cin >> d;\n  for(int i=0;i<d;i++){\n    cin >> e >> f >> g;\n    q.push(e);\n    for(int j=1;j<=a;j++)v[j]=1200;\n    v[e]=1;\n    while(1){\n      now=q.front();q.pop();\n      if(now==f){\n\tif(v[f]>g){\n\t  cout << \"NA\" << endl;\n\t  break;\n\t}else {\n\t  cout << v[now] << endl;\n\t  break;\n\t}\n      }\n      for(int j=1;j<=a;j++){\n\tif(m[now][j]==1&&v[j]==1200){\n\t  v[j]=v[now]+1;\n\t  q.push(j);\n\t}\n      }\n      if(q.empty()){\n\tcout<< \"NA\" << endl;\n\tbreak;\n      }\n    }\n    while(!q.empty())q.pop();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint net[103][103],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nint main(){\n\n  int num,n1,th;\n\n  cin >> n;\n\n\n\n  for(int i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n    for(int j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  \n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c;\n\n\n\n  for(int i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    if(ans(st,ed,c) != -2)cout << ans(st,ed,c) << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n}\n\n\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int yes=10001;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n   \n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; \n    \n    for(int i=1;i<=maxx;i++){\n      \n      if(net[next.first][i] == 1 && i == ed ){ //ツ姪堋的ツ地ツ督楪達\n\n\tif(yes >  (c-next.second+1))yes = (c - next.second)+1;\n\t\n\t\n      }\n            \n      if(net[next.first][i] == 1){\n\tNari.push(BVB(i,next.second));\n\n      }\n      \n    }\n       \n  }\n  if(yes != 10001){return yes;}\n  else return -2; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint d[101][101]={};\nint x[101];\nint n;\nvoid bfs(int);\nint main(){\n  int p;\n  int na[100];\n  int to;\n  int th;\n  int st,go,ttl;\n  //syoki\n  for(int i=0;i<n;i++){\n    x[i]=10000;\n  }\n  //in\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> na[i] >> to;\n    for(int j=0;j<to;j++){\n      cin >> th;\n      d[na[i]][th]=1;\n    }\n  \n  }\n  //in2\n  cin >> p;\n  for(int i=0;i<p;i++){\n    for(int j=0;j<=n;j++){\n      x[j]=10000;\n    }\n    \n    cin>> st >> go >> ttl;\n    x[st]=1;\n    bfs(st);\n    if(x[go]<=ttl && x[go]!=10000)cout << x[go] << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}\n\n///bfs///////////////////////////////////////////\nvoid bfs(int s){\n  queue<int>q;\n  int u;\n  q.push(s);\n  while(!q.empty()){\n    u=q.front();\n    q.pop();\n    for(int v=0;v<=n;v++){\n      if(d[u][v]==1&&x[v]==10000){\n\tx[v]=x[u]+1;\n\tq.push(v);\n      }\n    }\n  }\n  return ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\n#define pf push_front\n#define pb push_back\n#define int long long\nusing namespace std;\nconst int INF=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nconst int N=101;\n\nint net[N][N];\n\nint bfs(int n,int s,int d){\n  vector<int> time(n);\n  queue<int> que;\n  rep(i,n)time[i]=INF;\n  time[s]=0;\n  que.push(s);\n  int u;\n  while(!que.empty()){\n    u=que.front(),que.pop();\n    rep(i,n){\n      if(time[i]>time[u]+net[u][i]){\n        time[i]=time[u]+net[u][i];\n        que.push(i);\n      }\n    }\n  }\n  return time[d];\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  rep(i,n)rep(j,n)net[i][j]=INF;\n  rep(i,n){\n    int r,k;\n    cin>>r>>k;\n    r--;\n    rep(i,k){\n      int t;\n      cin>>t;\n      t--;\n      net[r][t]=1;\n    }\n  }\n\n  int p;\n  cin>>p;\n  rep(i,p){\n    int s,d,v;\n    cin>>s>>d>>v;\n    s--;d--;\n    int ans=bfs(n,s,d)+1;\n\n    if(ans<=v)cout<<ans<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define N 101\n\nint M[N][N];//&#65533;&#1488;&#1677;s&#65533;\nint d[N];//&#65533;m&#65533;[&#65533;h&#65533;&#784;&#65533;\nint pi[N];//&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#30152;&#65533;&#65533;&#65533;&#65533;\n\nvoid initi();\nint BFS(int start,int goal);\n\n\nmain(){\n  initi();\n  int n;\n  cin >> n;\n  for(int i = 0; i< n ; i++){\n    int Bangou,setuzokusu;\n    cin >> Bangou;\n    cin >> setuzokusu;\n    for(int j=0;j < setuzokusu ; j++){\n      int to;\n      cin >> to;\n      M[Bangou][to]=1;\n    }\n  }//&#65533;f&#65533;[&#65533;^&#65533;&#787;&#65533;&#65533;&#834;&#65533;&#65533;&#65533;&#65533;&#1794;\n  \n  \n  cin >> n;\n  for(int i = 0; i < n;i++){\n    int start,goal,TTL,result;\n    cin >> start >> goal >> TTL;\n    if ( (result =BFS(start,goal)+1) > TTL)cout << \"NA\" << endl;\n    else cout << result << endl;\n  }\n  \n  \n  \n  \n  return 0;     \n}\n\n\nvoid initi(){\n        for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++)M[i][j]=0;\n        }\n}\n\nint BFS(int start,int goal){\n        \n  queue<int> Q;//&#65533;L&#65533;&#65533;&#65533;[&#65533;&#65533;&#65533;p&#65533;\n  for(int i=0;i<N;i++){\n    d[i] =1 << 21;\n    pi[i]=0;\n  }\n  \n  d[start]=0;\n  Q.push(start);\n  \n  while(!Q.empty()){//&#65533;L&#65533;&#65533;&#65533;[&#65533;&#65533;&#65533;&#65533;&#65533;&#578;&#514;&#65533;&#65533;&#1794;&#322;&#65533;&#65533;\n    int u=Q.front();\n    Q.pop();\n    //  cout << \"Now u is\" << u << endl;\n    for(int v = 0 ; v <N ; v++){\n      if (M[u][v] && d[v] == 1 << 21){//u&#65533;&#65533;&#65533;&#65533;v&#65533;&#589;s&#65533;&#65533;&#65533;&#269;X&#65533;&#65533;v&#65533;&#771;X&#65533;^&#65533;[&#65533;g&#65533;n&#65533;_&#65533;&#65533;&#65533;&#65533;&#65533;&#779;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#337;&#65533;&#65533;&#782;&#65533;\n        d[v]=d[u]+1;\n        pi[v]=u;//&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#30152;&#65533;&#65533;&#65533;&#65533;\n        Q.push(v);\n        //cout <<\"from \"  <<u << \"to\" <<v << endl;\n      }\n    }\n  }\n\n  //for(int i=1;i<8;i++)cout << d[i]<< \" \";\n  //cout << endl;\n  \n  \n  return d[goal];\n        \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nconst int INF = 1<<29;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tvvi dist(n, vi(n, INF));\n\t\n\trep(i, n){\n\t\tint r, k;\n\t\tscanf(\"%d%d\", &r, &k);\n\t\t--r;\n\t\trep(j, k){\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tdist[r][a-1] = 1;\n\t\t}\n\t}\n\t\n\trep(k, n) rep(i, n) rep(j, n)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\n\tint p;\n\tscanf(\"%d\", &p);\n\trep(i, p){\n\t\tint s, d, v;\n\t\tscanf(\"%d%d%d\", &s, &d, &v);\n\t\t--s;\n\t\t--d;\n\t\tif(dist[s][d]+1 <= v)\n\t\t\tprintf(\"%d\\n\", dist[s][d]+1);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint n, a[101][101], s, t, u;\n\t\n\twhile(cin >> n){\n\t\tfill(&a[0][0], &a[n][n], 99999);\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\ta[i][i] = 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s >> t;\n\t\t\twhile(t--){\n\t\t\t\tcin >> u;\n\t\t\t\ta[s][u] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\ta[i][j] = (a[i][j] > a[i][k]+a[k][j])? a[i][k]+a[k][j] : a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> n;\n\t\twhile(n--){\n\t\t\tcin >> s >> t >> u;\n\t\t\tif(a[s][t]+1 <= u){\n\t\t\t\tcout << a[s][t]+1 << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n \nconst int INF = 100000000;\nint a[101][101];\n\nvoid solve(int n) {\n  \n  for(int i = 0 ; i < n ; i++)\n    for(int j = 0 ; j < n ; j++)\n      a[i][j] = INF;\n  \n  for(int i = 0 ; i < n ; i++) {\n    int r, k;\n    cin >> r >> k;\n    for(int j = 0 ; j < k ; j++) {\n      int t;\n      cin >> t;\n      a[r-1][t-1] = 1;\n    }\n  }\n  \n  for(int k = 0 ; k < n ; k++)\n    for(int i = 0 ; i < n ; i++)\n      for(int j = 0 ; j < n ; j++)\n\ta[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n  \n  int m;\n  cin >> m;\n  for(int i = 0 ; i < m ; i++) {\n    int s, d, v;\n    cin >> s >> d >> v;\n    if(a[s-1][d-1]+1 > v) cout << \"NA\" << endl;\n    else cout << a[s-1][d-1]+1 << endl;\n  }\n}\n\nint main() {\n  int n;\n  while(cin >> n) {\n    solve(n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 110\n\n#define INF 999999999\n\nint x[MAX_N][MAX_N];\nint d[MAX_N];\n\nqueue<int>Q;\n\nint bfs(int s, int t){\n\tfor(int i=0;i<MAX_N;i++){\n\t\td[i]=INF;\n\t}\n\td[s]=0;\n\tQ.push(s);\n\twhile(!Q.empty()){\n\t\tint z=Q.front();\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tif(x[z][i]<INF){\n\t\t\t\tif(d[i]==INF){\n\t\t\t\t\td[i]=d[z]+1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\treturn d[t];\n}\n\nint main(){\n\tint n,m,a,b,c;\n\tfor(int i=0;i<MAX_N;i++){\n\t\tfor(int j=0;j<MAX_N;j++){\n\t\t\tx[i][j]=INF;\n\t\t}\n\t}\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a>>b;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tcin>>c;\n\t\t\tx[a][c]=1;\n\t\t}\n\t}\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tint y=bfs(a,b);\n\t\tif(y>=c){cout<<\"NA\"<<endl;}\n\t\telse{cout<<y+1<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<string>\n#include<iostream>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<stack>\n#include<queue>\n#include <algorithm>\n#include<math.h>\n#include<set>\n#include<map>\n#include<iomanip>\n\n//#include<bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nint main() {\n\n\tbool y[105][105] = {};\n\n\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint a,b; cin >> a>>b;\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\ty[a][z] = 1;\n\t\t}\n\t}\n\t\n\tint p; cin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, t;\n\t\tcin >> s >> d >> t;\n\t\tqueue<int>Q;\n\t\tQ.push(s);\n\t\tint h = 1;\n\t\tint R[105] = {};\n\t\tfor (int j = 0; j <= 102; j++)\n\t\t\tR[j] = 999999;\n\t\tR[s] = 1;\n\t\twhile (Q.size()) {\n\t\t\tint v = Q.front();\n\t\t\th = R[v];\n\t\t\th++;\n\t\t\n\t\t\t\n\t\t\tbool F[105] = {};\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (y[v][j] && R[j] > h) {\n\t\t\t\t\tR[j] = h;\n\t\t\t\t\tQ.push(j);\n\t\t\t\t}\n\n\n\n\t\t\t}\n\t\t\tQ.pop();\t\n\t\t}\n/*\t\tfor (int j = 0; j < n; j++)\n\t\t\tcout << R[j] << \" \";*/\n\t\tif (R[d] <= t)cout << R[d] << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\t\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); i++ )\n#define UREP( i, m, n ) for ( unsigned int i = (unsigned int)( m ); i < (unsigned int)( n ); i++ )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define RALL( c ) (c).rbegin(), (c).rend()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\ntypedef vector<char> VC;\ntypedef vector< VC > VVC;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tVVI res( n, VI( n, INT_MAX / 10 ) );\n\n\tREP( i, 0, n )\n\t{\n\t\tint from, num;\n\t\tcin >> from >> num;\n\n\t\tfrom--;\n\n\t\tREP( j, 0, num )\n\t\t{\n\t\t\tint to;\n\t\t\tcin >> to;\n\n\t\t\tto--;\n\n\t\t\tres[ from ][ to ] = 1;\n\t\t}\n\t}\n\n\tconst int N = res.size();\n\n\tREP( k, 0, N )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tREP( j, 0, N )\n\t\t\t{\n\t\t\t\tres[i][j] = min( res[i][j], res[i][k] + res[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\n\tint p;\n\tcin >> p;\n\n\tREP( i, 0, p )\n\t{\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\n\t\ts--;\n\t\td--;\n\n\t\tint dist = res[s][d] + 1;\n\n\t\tif ( dist <= v )\n\t\t{\n\t\t\tcout << dist << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define MAX 100\n#define INF (1<<21)\nint n, L[MAX][MAX], S[MAX];\n\nint bfs( int s, int t ){\n    queue<int> q; q.push(s);\n    int u, v, d[MAX];\n    rep(i, n) d[i] = INF;\n    d[s] = 1;\n    while( !q.empty() ){\n\tu = q.front(); q.pop();\n\trep(i, S[u]){\n\t    v = L[u][i];\n\t    if ( d[v] == INF ){\n\t\td[v] = d[u] + 1;\n\t\tq.push(v);\n\t    }\n\t}\n    }\n    return d[t];\n}\n\nmain(){\n    int s, t, tl, q, c;\n    cin >> n;\n    rep(i, n){\n\tcin >> s; s--; cin >> S[s];\n\trep(j, S[s]){\n\t    cin >> L[s][j]; L[s][j]--;\n\t}\n    }\n    cin >> q;\n    rep(i, q){\n\tcin >> s >> t >> tl;\n\tc = bfs(s-1, t-1);\n\tif ( c <= tl ) cout << c << endl;\n\telse cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define f first\n#define P pair<int,int>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int n,p,m,t,s;\n  cin>>n;\n  vector<int>a[n+1];\n  r(i,n){cin>>p>>m;\n    while(m--)cin>>t,a[p].push_back(t);\n  }\n  cin>>m;\n  while(m--){\n    bool v[n+1];\n    r(i,n+1)v[i]=0;\n    cin>>s>>t>>p;p--;\n    queue<P>q;\n    q.push(make_pair(s,0));\n    v[s]=1;\n    while(!q.empty()){\n      P w=q.front();q.pop();\n      if(w.f==t){cout<<w.S+1<<endl;goto L;}\n      r(i,a[w.f].size()){\n        if(!v[a[w.f][i]]&&w.S+1<=p){\n          q.push(make_pair(a[w.f][i],w.S+1));\n          v[a[w.f][i]]=1;\n        }\n      }     \n    }\n    cout<<\"NA\"<<endl;\n    if(0)L:n++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nint main(){\n    using namespace std;\n\n    int n, M[101][101] = {};\n    cin >> n;\n    for(int i = 0; i < n; ++i){\n        int num, src;\n        cin >> src >> num;\n        for(int j = 0; j < num; ++j){\n            int dest;\n            cin >> dest;\n            M[src][dest] = 1;\n        }\n    }\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; ++i){\n        int src, dest, ttl, d[n + 1];\n        fill(d, d + n + 1, -1);\n\n        cin >> src >> dest >> ttl;\n        d[src] = 0;\n        queue<int> q;\n        q.push(src);\n        while(!q.empty()){\n            int const u = q.front();\n            q.pop();\n            for(int v = 1; v < n + 1; ++v){\n                if(M[u][v] == 1 && d[v] == -1){\n                    d[v] = d[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        if(ttl - d[dest] > 0){\n            cout << d[dest] + 1;\n        }else{\n            cout << \"NA\";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Node {\n    vector<int> to;\n    bool isDone;\n    int cost;\n};\n\nconst int MAX_N = 100;\nNode nodes[MAX_N + 1];\nint n;\n\nint dijkstra(int start, int end) {\n    for (int i = 1; i <= n; i++) {\n        nodes[i].isDone = false;\n        nodes[i].cost = -1;\n    }\n    nodes[start].cost = 0;\n    while (true) {\n        queue<int> qu;\n        for (int i = 1; i <= n; i++) {\n            if (nodes[i].isDone == true || nodes[i].cost < 0) {\n                continue;\n            }\n            qu.push(i);\n        }\n        if (qu.empty() == true) {\n            break;\n        }\n        while (qu.empty() == false) {\n            int idx = qu.front();\n            qu.pop();\n            nodes[idx].isDone = true;\n            for (vector<int>::iterator it = nodes[idx].to.begin(); it != nodes[idx].to.end(); it++) {\n                if (nodes[*it].cost < 0) {\n                    nodes[*it].cost = nodes[idx].cost + 1;\n                }\n            }\n        }\n    }\n    return nodes[end].cost;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int r, k;\n        cin >> r >> k;\n        for (int j = 0; j < k; j++) {\n            int t;\n            cin >> t;\n            nodes[r].to.push_back(t);\n        }\n    }\n    int p;\n    cin >> p;\n    for (int i = 0; i < p; i++) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int cost = 1 + dijkstra(s, d);\n        if (v < cost) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << cost << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n\nstatic const int NO = -2;\nstatic const int N = 100;\n\n\nint graph[N + 1][N + 1] = {{}};\nint dis[N + 1] = {};\nint n;\n\nvoid bfs(int v){\n  queue<int> Q;\n\n  Q.push(v);\n\n  for(int i = 1; i <= N; i++){\n    dis[i] = NO;\n  }\n\n  dis[v] = 1;\n\n  int u;\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n\n    for(int i = 1;i <= n; i++){\n      if(graph[u][i]==0) continue;\n      if(dis[i]!=NO)continue;\n      dis[i] = dis[u] + 1;\n      Q.push(i);\n\n    }\n  }\n}\n\nint main(){\n\n  int r[N] = {};\n  int d[N] = {};\n  int k[N] = {};\n  int f[N] = {};\n  int p,s[N] = {};\n  int v[N] = {};\n\n\n  //in\n  cin >> n;\n\n  for(int i = 1;i <= n; i++){\n\n    cin >> r[i] >> k[i];\n\n    for(int j = 1;j <= k[i];j++){\n\n      cin >> f[j];\n      graph[i][f[j]] = 1;\n    }\n  }\n\n  cin >> p;\n  for(int i = 1;i <= p; i++){\n    cin >> s[i] >> d[i] >> v[i];\n    bfs(s[i]);\n\n    if(v[i] >= dis[d[i]]) cout << dis[d[i]] << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main(){\n  int a,b,c,d,e,f,g,now,v[200],m[201][201]={};\n  queue<int> q;\n  cin >> a;\n  for(int i=1;i<=a;i++){\n    cin >>b>>c;\n    for(int j=0;j<c;j++){\n      cin >> d;\n      m[i][d]=1;\n    }\n  }\n  cin >> d;\n  for(int i=0;i<d;i++){\n    cin >> e >> f >> g;\n    q.push(e);\n    for(int j=1;j<=a;j++)v[j]=1200;\n    v[e]=1;\n    while(1){\n      now=q.front();q.pop();\n      if(now==f){\n\tif(v[f]>g){\n\t  cout << \"NA\" << endl;\n\t  break;\n\t}else {\n\t  cout << v[now] << endl;\n\t  break;\n\t}\n      }\n      for(int j=1;j<=a;j++){\n\tif(m[now][j]==1&&v[j]==1200){\n\t  v[j]=v[now]+1;\n\t  q.push(j);\n\t}\n      }\n      if(q.empty()){\n\tcout<< \"NA\" << endl;\n\tbreak;\n      }\n    }\n    while(!q.empty())q.pop();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\ntypedef pair<int,int> P;\nconst int INF =10000000;\nint n;\nint d[101][101];\nint main()\n{\n  int r,k;\n  while(cin>>n){\n    for(int i = 0;i < 101;i++){\n      for(int j = 0;j <101;j++){\n\td[i][j]= INF;\n\tif(i==j)\n\t  d[i][j] = 0;\n      }\n    }\n    for(int i = 1;i <=n;i++){\n      cin>>r;\n      cin>>k;\n      for(int j = 0;j < k;j++){\n\tint x;\n\tcin>>x;\n\td[r][x] = 1;\n      }\n    }\n    for(int i = 1;i <=n;i++){\n      for(int j = 1;j <=n;j++){\n\tfor(int k = 1;k <=n;k++){\n\t  d[i][j] =min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    int p;\n    cin>>p;\n    int s1,d1,v1;\n    for(int i = 0;i <p;i++){\n      cin>>s1>>d1>>v1;\n      if(d[s1][d1]+1<=v1){\n\tcout <<d[s1][d1]+1<<endl;\n      }else{\n\tcout <<\"NA\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\nint ans(int,int,int);\n\nint main(){\n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n\n    if(num >= maxx)maxx = num;\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  // cout << \"maxx =\" << maxx << endl;\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n\n  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  \n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=maxx;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;  \n\n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      if(mem == n)break;\n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(101);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    queue<int> fq, nq, sq;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            } else {\n                for (int i: g[pos]) {\n                    nq.push(i);\n                }\n            }\n        }\n        if (c == 0) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcDijikstra(i4StartRouter,i4GoalRouter,i4TTL,1);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++){\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<MAX_ROUTER; i4RoopCnt1++){\n\t\tif(i4TTL <= i4RoopCnt1){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\t;\n\t\t}\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=MAX_ROUTER; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[100][100];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<100;i++)\n\t\tfor(int j=0;j<100;j++)\n\t\t\tg[i][j]=1999999999;\n\tfor(int i=0;i<a;i++)\n\t\tg[i][i]=0;\n\tfor(int i=0;i<a;i++){\n\t\tint b,c;\n\t\tscanf(\"%d%d\",&b,&c);\n\t\tfor(int j=0;j<c;j++){\n\t\t\tint d;\n\t\t\tscanf(\"%d\",&d);\n\t\t\tg[b-1][d-1]=1;\n\t\t}\n\t}\n\tfor(int k=0;k<a;k++)\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\tscanf(\"%d\",&a);\n\twhile(a--){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tr=min(r,10000);\n\t\t\n\t\tif(r<=g[p-1][q-1])printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",g[p-1][q-1]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nint cost[100][100];\nint n;\nvoid wf(){\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n}\n\nmain(){\n  cin>>n;\n  rep(i,n)rep(j,n)cost[i][j]=2<<24;\n\n  rep(i,n){\n    int r;\n    cin>>r;--r;\n    int k;\n    cin>>k;\n    rep(j,k){\n      int t;\n      cin>>t;t--;\n      cost[r][t]=1;\n    }\n  }\n  wf();\n  int p;\n  cin>>p;\n  rep(i,p){\n    int s,d,v;\n    cin>>s>>d>>v;--s,--d;\n    int c=cost[s][d];\n    if(c<v)cout<<c+1<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 5000;\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\nconst int INF = 100000000;\n\nint prevv[MAX_V];\n\nclass Situation{\npublic:\n\tint ttl;\n\tint node;\n\tint dist;\n\n\tSituation();\n\tSituation(int ttl_,int node_,int dist_){\n\t\tttl=ttl_;\n\t\tnode=node_;\n\t\tdist=dist_;\n\t}\n\n\tbool operator<(const Situation &sit)const{\n\t\treturn sit.dist > this->dist;\n\t}\n};\n\nvoid dijkstra(int s,int ttl){\n\tpriority_queue<Situation > que;\n\tfill(d,d+MAX_V,INF);\n\td[s] = 0;\n\tque.push(Situation(ttl,s,0));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.node;\n\t\tif(d[v] < p.dist)\n\t\t\tcontinue;\n\t\tif(p.ttl<=1)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(p.ttl-1,e.to,d[e.to]));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tint from;\n\t\tcin>>from;\n\t\tint m;\n\t\tcin>>m;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint to;\n\t\t\tcin>>to;\n\t\t\tedge e;\n\t\t\te.cost=1;\n\t\t\te.to=to;\n\t\t\tG[from].push_back(e);\n\t\t}\n\t}\n\tint l;\n\tcin>>l;\n\tfor(int j = 0; j < l; j++){\n\t\tint s,dd,v;\n\t\tcin>>s>>dd>>v;\n\t\tdijkstra(s,v);\n\t\tif(d[dd]==INF)\n\t\t\tcout<<\"NA\"<<endl;\n\t\telse\n\t\t\tcout<<d[dd]+1<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i <= 101; i++){\n\t\tfor(int k=1; k <= 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\n\n\n\t\twhile(!Q.empty() && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && (memo[i][goal]+1) < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+2);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), -1);\n    dist[start] = 0;\n    queue<int> q;\n    q.push(start);\n\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            int u = edges[v][i];\n            if(dist[u] == -1){\n                dist[u] = dist[v] + 1;\n                q.push(u);\n            }\n        }\n    }\n}\n\nvoid shortestPath(const vector<vector<int> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int> > edges(n+1);\n    for(int i=0; i<n; ++i){\n        int r, k;\n        cin >> r >> k;\n        edges[r].resize(k);\n        for(int j=0; j<k; ++j)\n            cin >> edges[r][j];\n    }\n    vector<vector<int> > dist;\n    shortestPath(edges, dist);\n\n    int p;\n    cin >> p;\n    for(int i=0; i<p; ++i){\n        int s, d, v;\n        cin >> s >> d >> v;\n        int num = dist[s][d];\n        if(num == -1 || num >= v)\n            cout << \"NA\" << endl;\n        else\n            cout << (num+1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[100];\nint s,d,v;\nint s2,d2;\nint kk[100],n;\nbool flg[101] ;\n\nvoid visit(int sn,int dis) {\n  int x;\n  \n  flg[sn] = 1;\n  \n  if(sn == d2 && dis <=v){\n    md = min(md,dis);\n    // cout << md <<\" \"<<sn <<\" \"<<d2 << endl;\n  }\n  \n  else if(dis <= v) {\n    for(int i=0;i<ro[sn].size();i++) {\n      for(int j=0;j<n;j++)\n\tif(ro[sn][i] == kk[j]) {\n\t  x = j;\n\t  break;\n\t}\n      if(dis == 1){\n\tfor(int i=0;i<=n;i++) flg[i] = 0;\n\t//\tcout <<\"reset\"<<endl;\n\tflg[s2] = 1;\n      }\n      //       cout <<sn+1 << \"to\"<<x+1 << endl;\n      if(flg[x] == 0) visit(x,dis+1);\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk[i];\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[i][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n\n   \n    for(int i=0;i<n;i++){\n      if(kk[i] == s) s2 = i;\n      if(kk[i] == d) d2 = i;\n    }\n\n    for(int i=0;i<=n;i++) flg[i] = 0;\n    \n    for(int i=0;i<n;i++) \n    md = 10000000;\n    visit(s2,1);\n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\twent_num = 1;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t\twent_num++;\n\t}\n\n\tint ttl,checkTable[101],went_num,current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tfor(int i=1; i <= n; i++){\n\t\t\tfor(int k=1; k <= n; k++){\n\t\t\t\ttable[i][k] = 0;\n\t\t\t\tmemo[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d\",&r,&k);\n\t\t\tfor(int p=0;p < k; p++){\n\t\t\t\tscanf(\"%d\",&to);\n\t\t\t\ttable[r][to] = 1;\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\",&num_of_packet);\n\n\t\tqueue<Packet> Q;\n\t\tbool FLG;\n\n\t\tfor(int i=0; i < num_of_packet; i++){\n\t\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\t\tFLG = false;\n\n\t\t\tif(memo[start][goal] != 0){\n\t\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(i);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\twhile(!Q.empty() && FLG == false){\n\t\t\t\ttmp = Q.front();\n\t\t\t\tQ.pop();\n\n\t\t\t\tif(tmp.current == goal){\n\t\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(tmp.ttl > 1 && tmp.went_num < n){\n\t\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < tmp.ttl){\n\t\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+1);\n\t\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+1;\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!FLG){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 101;\n\nbool ok[N][N];\nint n, res, vv;\n\nvoid dfs(int, int, int);\n\nint main(void){\n    cin >> n;\n\n    rep(i, n){\n        int r, k; cin >> r >> k;\n        while(k--){\n            int t; cin >> t;\n            ok[r][t] = true;\n        }\n    }\n\n    int p; cin >> p;\n    while(p--){\n        int s, d; cin >> s >> d >> vv;\n        res = INF;\n\n        dfs(s, d, vv - 1);\n     \n        if(res == INF) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs(int cur, int z, int v){\n    if(cur == z){\n        res = vv - v;\n        return;\n    }\n    if(v == 0) return;\n\n    COUNT(i, n) if(ok[cur][i]) dfs(i, z, v - 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n#define M 1000\ntypedef pair<pair<int, int>, int > P;\n\nvoid disp_p (P p )\n{\n\tint from = p.first.first;\n\tint to   = p.first.second;\n\tint ttl  = p.second;\n\n\tcout << \"from: \" << from << \" to: \" << to << \" ttl: \" << ttl << endl;\n}\n\n// ツパツケツッツトツつェツ経ツ由ツつキツづゥツδ仰ーツタツづ個催短ツ仰猟猟」ツづーツダツイツクツスツトツδ可づ仰づ淞づゥツ。\n// ttl >= ツ個仰嘉環づ按づァ ツ個仰嘉環づーツ陛板つキ\n// ttl < ツ個仰嘉環づ按づァ -1 ツづーツ陛板つキ\nint dijkstra (int from , int to, vector <vector <int> > t )\n{\n//\tint from = packet.first.first;\n//\tint to   = packet.first.second;\n//\tint ttl  = packet.second;\n//\tint res  = 0;\n\tint size = t.size();\n\tvector <int> d (size, M );\n\tvector <bool> v (size, false );\n\tint i,p;\n\n\tv[0] = true;\n\td[from] = 1;\n\n\t// for debug\n//\tdisp_p (packet );\n\tint mind = M;\n\n\tdo{\n\t\tmind = M;\n\t\tfor (i = 1; i < size; ++i){\n\t\t\tif (!v[i] && mind > d[i] ){\n\t\t\t\tmind = d[i];\n\t\t\t\tp = i;\n\t\t\t} // end if\n\t\t} // end for\n\t\t\n\t\tv[p] = true;\n\n\t\tfor (i = 1; i < size; ++i){\n\t\t\tif ( d[p] + t[p][i] < d[i] ){\n\t\t\t\td[i] = d[p] + t[p][i];\n\t\t\t} // end if\n\t\t} // end for\n//\t} while ((int)count (v.begin(), v.end(), true ) != size );\n\t} while (mind != M );\n\t// for debug\n/*\n\tfor (i = 0; i < size; ++i ){\n\t\tcout << d[i] << ' ';\n\t} // end for\n\tcout << endl;\n*/\t\n/*\n\tif (d[to] <= ttl ){\n\t\tres = d[to];\n\t}else{\n\t\tres = -1;\n\t} // end if\n*/\n\treturn d[to];\n}\n\ntemplate<class T> void disp_t (vector <T> t )\n{\n\tint size = t.size();\n\tint i,j;\n\n\tfor (i = 0; i < size; ++i){\n\t\tfor (j = 0; j < size; ++j){\n\t\t\tif (t[i][j] == M ){\n\t\t\t\tcout << \" 0\";\n\t\t\t}else{\n\t\t\t\tcout << setw(2) << t[i][j];\n\t\t\t} // end if\n\t\t} // end for\n\t\tcout << endl;\n\t} // end for\n}\n\t\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.packet\", \"r\", stdin );\n\tstring str = \"\";\n\tstring res = \"\";\n\tint n;\n\n\tgetline (cin, str );\n\tstringstream ssn(str);\n\tssn >> n;\n\n\tvector <vector <int> > t (n+1, vector <int> (n+1, M) );\n\tvector <vector <int> > memo (n+1, vector <int> (n+1, M ) );\n\tint i,j;\n\tfor (i = 0; i < n; ++i){\n\t\tint from, num, to;\n\t\tgetline (cin, str );\n\t\tstringstream ss(str);\n\n\t\tss >> from >> num;\n\t\tfor (j = 0; j < num; ++j){\n\t\t\tss >> to;\n\t\t\tt[from][to] = 1;\n\t\t} // end for\n\t} // end for\n\t\n\n\tfor (i = 1; i <= n; ++i){\n\t\tfor (j = 1; j <= n; ++j){\n\t\t\tif (i != j ){\n\t\t\t\tmemo[i][j] = dijkstra (i, j, t );\n\t\t\t} // end if\n\t\t}  // end for\n\t} // end for\n\n\t// for debug\n//\tdisp_t (memo );\n\n\tint p;\n\tgetline (cin, str );\n\tstringstream ssp (str );\n\tssp >> p;\n\t\n\tfor (i = 0; i < p; ++i){\n\t\tint from, to , ttl;\n\t\tgetline (cin, str );\n\t\tstringstream ss (str );\n\t\tss >> from >> to >> ttl;\n\t\n\t\tint res = memo[from][to];\n\t\tif (memo[from][to] <= ttl ){\n\t\t\tres = memo[from][to];\n\t\t}else{\n\t\t\tres = -1;\n\t\t} // end if\t\t\n\n\t\tif (res == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << res << endl;\n\t\t} // end if\n\t} // end for\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Node{\npublic:\n\tvector< int > e_to;\n\tvector< int > e_cost;\n\t\n\tbool def;\n\tint min_cost;\n\t\n\tNode(){\n\t\tdef = false;\n\t\tmin_cost = -1;\n\t}\n};\nbool operator==(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost == ot2.min_cost;\n}\nbool operator!=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 == ot2);\n}\nbool operator<(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost < ot2.min_cost;\n}\nbool operator>(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost > ot2.min_cost;\n}\nbool operator<=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 > ot2);\n}\nbool operator>=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 < ot2);\n}\n\nclass Dijkstra{\n\tpriority_queue< Node, vector< Node >, greater< Node > > que;\n\tvector< Node > nodes;\n\t\npublic:\n\tvoid Init(int node_num){\n\t\tnodes.resize(node_num);\n\t\tfor(int i = 0; i < node_num; ++i){\n\t\t\tnodes[i] = Node();\n\t\t}\n\t}\n\t\n\tvoid Put(int id, int to, int cost){\n\t\tnodes[id].e_to.push_back(to);\n\t\tnodes[id].e_cost.push_back(cost);\n\t}\n\t\n\tint Run(int s, int t){\n\t\t\n\t\tfor(vector< Node >::iterator it = nodes.begin(); it != nodes.end(); ++it){\n\t\t\tit->min_cost = -1;\n\t\t\tit->def = false;\n\t\t}\n\t\t\n\t\tnodes[s].min_cost = 0;\n\t\tque.push(nodes[s]);\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tNode def_node = que.top();\n\t\t\tque.pop();\n\t\t\n\t\t\tif(def_node.def)continue;\n\t\t\n\t\t\tdef_node.def = true;\n\t\t\n\t\t\tfor(int i = 0; i < def_node.e_to.size(); ++i){\n\t\t\t\tint to = def_node.e_to[i];\n\t\t\t\tint cost = def_node.min_cost + def_node.e_cost[i];\n\t\t\t\t\n\t\t\t\tif(nodes[to].min_cost == -1 || cost < nodes[to].min_cost){\n\t\t\t\t\tnodes[to].min_cost = cost;\n\t\t\t\t\tque.push(nodes[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes[t].min_cost;\n\t}\n};\n\n\nint main(){\n\tint n, r, k, t, p, s, d, v;\n\tDijkstra dijk;\n\t\n\t\n\tcin >> n;\n\t\n\tdijk.Init(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> r >> k;\n\t\t\n\t\tfor(int j = 0; j < k; ++j){\n\t\t\tcin >> t;\n\t\t\tdijk.Put(r - 1, t - 1, 1);\n\t\t}\n\t}\n\t\n\tcin >> p;\n\t\n\tfor(int i = 0; i < p; ++i){\n\t\tcin >> s >> d >> v;\n\t\t\n\t\tint res = dijk.Run(s - 1, d - 1);\n\t\t\n\t\tif(res >= v || res == -1){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << res + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\treturn 0;\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER)\n\t{\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL)\n\t{\n\t\tprintf(\"start:%d,goal:%d,TTL:%d\\n\",i4StartRouter,i4GoalRouter,i4TTL);\n\t\ti4Ans = CalcDijikstra(i4StartRouter,i4GoalRouter,i4TTL,1);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\tprintf(\"--------------\\n\");\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum)\n{\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tif(i4TTL <= i4RoopCnt1)\n\t\t{\n\t\t\tprintf(\"TTL over\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE)\n\t\t\t{\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=MAX_ROUTER; i4RoopCnt3++)\n\t\t\t\t{\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t\tprintf(\"%d -> %d\\n\",i4RoopCnt2,i4RoopCnt3);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"search finish\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <deque>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N_MAX = 100;\n\nclass Node {\npublic:\n\tint pos, ttl;\n\tNode(int p, int t) : pos(p), ttl(t) {}\n};\n\nint n;\n// adj[from][to] from->toの辺があるか\nbool adj[N_MAX + 1][N_MAX + 1];\nbool visited[N_MAX + 1];\n\nvoid bfs(int src, int dst, int limit) {\n\tdeque<Node> que;\n\tfill(visited, visited + n, false);\n\tque.push_back(Node(src, limit - 1));\n\twhile (!que.empty()) {\n\t\tNode current = que.front();\n\t\tque.pop_front();\n\t\tif (current.pos == dst) {\n\t\t\tcout << limit - current.ttl << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (visited[current.pos]) continue;\n\t\tvisited[current.pos] = true;\n\t\tif (current.ttl == 0) continue;\n\t\tfor (int next = 1; next <= n; next++) {\n\t\t\tif (adj[current.pos][next]) {\n\t\t\t\tque.push_back(Node(next, current.ttl - 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfill(adj[r], adj[r] + n, false);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tadj[r][t] = true;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tbfs(s, d, v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 999999\nusing namespace std;\nint n, p;\nint r, k;\nint t;\nint s, d, v, cost[110][110];\nvoid warshall_floyd();\nint main(){\n  cin >> n;\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(i == j) cost[i][j] = 0;\n      else{\n\tcost[i][j] = INF;\n      }\n    }\n  }\n  for(int i = 1; i <= n; i++){\n    cin >> r >> k;\n    for(int j = 0; j < k; j++){\n      cin >> t;\n      cost[r][t] = 1;\n    }\n  }\n  warshall_floyd();\n  cin >> p;\n  for(int i = 0; i < p;i++){\n    cin >> s >> d >> v;\n    if(cost[s][d] + 1 <= v) cout << cost[s][d] + 1 << endl;\n    else cout << \"NA\" << endl;\n  }\n}\n\nvoid warshall_floyd(){\n  for(int k = 1; k <= n; k++){\n    for(int i = 1; i <= n; i++){\n      for(int j = 1; j <= n; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(vector<int> t[],int k[],int b[],int c,int s,int d,int v){\n  int i;\n  if(s==d){\n    if(b[s]==0)\n      b[s]=c;\n    else\n      if(b[s]>c)\n\tb[s]=c;\n  }else if(v==1);\n  else if(b[s]==0||b[s]>c){\n    b[s]=c;\n    for(i=0;i<k[s];i++)\n      f(t,k,b,c+1,t[s][i],d,v-1);\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int k[101],b[101],n,p,s,d,v;\n  vector<int> t[101],u;\n  cin>>n;\n  for(i=0;i<n;i++){\n    int q,r;\n    cin>>r>>q;\n    k[r]=q;\n    t[r].reserve(k[r]);\n    for(j=0;j<k[r];j++)\n      cin>>t[r][j];\n  }\n  cin>>p;\n  u.reserve(p);\n  for(i=0;i<p;i++){\n    cin>>s>>d>>v;\n    memset(b,0,sizeof(b));\n    f(t,k,b,1,s,d,v);\n    u[i]=b[d];\n  }\n  for(i=0;i<p;i++){\n    if(u[i])\n      cout<<u[i]<<endl;\n    else\n      cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//59\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  vector<int> e[101];\n  for(int i=0;i<n;i++){\n    int r,k;\n    cin>>r>>k;\n    while(k--){\n      int t;\n      cin>>t;\n      e[r].push_back(t);\n    }\n  }\n  int p;\n  cin>>p;\n  while(p--){\n    int s,d,v;\n    cin>>s>>d>>v;\n    queue<pair<int,int> > que;\n    que.push(make_pair(1,s));\n    while(!que.empty()){\n      int c=que.front().second;\n      if(c==d||que.front().first>v)break;\n      for(int i=0;i<e[c].size();i++){\n\tque.push(make_pair(que.front().first+1,e[c][i]));\n      }\n      que.pop();\n    }\n    if(que.empty()||que.front().first>v){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().first<<endl;\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int maxv=100000;\nint main()\n{\n\tint root[101][101];\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int i2=0;i2<=100;i2++){\n\t\t\troot[i][i2]=maxv;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tint r,k,ch;\n\tcin>>r>>k;\n\t\tfor(int i2=0;i2<k;i2++){\n\t\t\tcin>>ch;\n\t\t\troot[r][ch]=1;\n\t\t}\n\t}\n\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int i2=01;i2<=n;i2++){\n\t\t\t\troot[i][i2]=min(root[i][i2],root[i][k]+root[k][i2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint m;\n\tint s,d,v;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>s>>d>>v;\n\t\tif(root[s][d]<v){\n\t\t\tcout<<root[s][d]+1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define INF 9999999\nusing namespace std;\nint n, p;\nint r, k;\nint t;\nint s, d, v, cost[100][100];\nvoid warshall_floyd();\nint main(){\n  cin >> n;\n  for(int i = 0; i <= n; i++){\n    for(int j = 0; j <= n; j++){\n      if(i == j) cost[i][j] = 0;\n      else{\n\tcost[i][j] = INF;\n      }\n    }\n  }\n  for(int i = 1; i <= n; i++){\n    cin >> r >> k;\n    for(int j = 0; j < k; j++){\n      cin >> t;\n      cost[i][t] = 1;\n    }\n  }\n  warshall_floyd();\n  cin >> p;\n  for(int i = 0; i < p;i++){\n    cin >> s >> d >> v;\n    if(cost[s][d] + 1 <= v) cout << cost[s][d] + 1 << endl;\n    else cout << \"NA\" << endl;\n  }\n}\n\nvoid warshall_floyd(){\n  for(int k = 1; k <= n; k++){\n    for(int i = 1; i <= n; i++){\n      for(int j = 1; j <= n; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define MAX 100\n\nint main(){\n  int n,v;\n  int G[MAX][MAX];\n\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      G[i][j] = INF;\n    }\n  }\n\n  scanf(\"%d\" ,&n);\n\n  for(int i = 0 ; i < n ; i++){\n    for(int j = 0 ; j < n ; j++){\n      G[i][j] = INF;\n    }\n  }\n  \n  int r,k,t;\n  for(int i = 0 ; i < n ; i++){\n    scanf(\"%d %d\" ,&r ,&k); r--;\n    while(k--){\n      scanf(\"%d\" ,&t); t--;\n      G[r][t] = 1;\n    }\n  }\n\n  for(int k = 0 ; k < n ; k++){\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tG[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n      }\n    }\n  }\n\n  int a,b,c;\n  scanf(\"%d\" ,&v);\n  while(v--){\n    scanf(\"%d %d %d\" ,&a ,&b ,&c);\n    a--,b--;\n    if(G[a][b] == INF || G[a][b] + 1 > c){\n      puts(\"NA\");\n    }else{\n      printf(\"%d\\n\" ,G[a][b] + 1);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nstatic const int INF = 1e9;\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvector< vector<int> > d(n + 1, vector<int>(n + 1));\n\tfor (int i = 0; i < n + 1; ++i)\n\t{\n\t\tfor (int j = 0; j < n + 1; ++j)\n\t\t{\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfor (int j = 0; j < k; ++j)\n\t\t{\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\td[r][t] = 1;\n\t\t}\n\t}\n\tfor (int k = 1; k < n + 1; ++k)\n\t{\n\t\tfor (int i = 1; i < n + 1; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j < n + 1; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; ++i)\n\t{\n\t\tint start, dist, v;\n\t\tcin >> start >> dist >> v;\n\t\tif (d[start][dist] + 1 <= v)\n\t\t{\n\t\t\tcout << d[start][dist] + 1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nconst int SIZE = 101;\n\n\nclass Packet\n{\npublic:\n\tPacket( int _now, set< int > _via ) : now( _now ), via( _via ){}\n\tbool isPast( int p )\n\t{\n\t\tif( via.find( p ) != via.end() ){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint now;\n\tset< int > via;\n};\n\nint solve( int table[ SIZE ][ SIZE ], int s, int e, int initTtl, int numRooter )\n{\n\tif( initTtl < 2 ){\n\t\treturn 0;\n\t}\n\tvector< Packet > pList;\n\tfor( int i = 1; i <= numRooter; ++i ){\n\t\tset< int > via;\n\t\tvia.insert( s );\n\t\tif( table[ s ][ i ] ){\n\t\t\tif( i == e ){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tset< int > via2 = via;\n\t\t\tvia2.insert( i );\n\t\t\tpList.push_back( Packet( i, via2 ) );\n\t\t}\n\t}\n\n\tint ttl = initTtl;\n\twhile( pList.size() > 0 ){\n\t\t--ttl;\n\t\tif( ttl < 1 ){\n\t\t\treturn 0;\n\t\t}\n\t\tvector< Packet > pList2;\n\t\tfor( int i = 0; i < pList.size(); ++i ){\n\t\t\tPacket& p = pList[ i ];\n\t\t\tif( p.now == e ){\n\t\t\t\treturn p.via.size();\n\t\t\t}\n\t\t\tfor( int j = 1; j <= numRooter; ++j ){\n\t\t\t\tif( table[ p.now ][ j ] && !p.isPast( j ) ){\n\t\t\t\t\tset< int > via = p.via;\n\t\t\t\t\tvia.insert( j );\n\t\t\t\t\tpList2.push_back( Packet( j, via ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpList = pList2;\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tint table[ SIZE ][ SIZE ];\n\n\tint n;\n\twhile( cin >> n ){\n\t\tcin.ignore( 100, '\\n' );\n\t\tmemset( table, 0, sizeof(table) );\n\t\tstring s;\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tgetline( cin, s );\n\t\t\tint o = s[ 0 ] - '0';\n\t\t\tfor( int j = 4; j < s.size(); j += 2 ){\n\t\t\t\ttable[ o ][ s[ j ] - '0' ] = true;\n\t\t\t}\n\t\t}\n\t\tint p;\n\t\tcin >> p;\n\t\tfor( int i = 0; i < p; ++i ){\n\t\t\tint from, to, ttl;\n\t\t\tcin >> from >> to >> ttl;\n\t\t\tint result = solve( table, from, to, ttl, n );\n\t\t\tif( result > 0 ){\n\t\t\t\tcout << result << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\n/* main??? */\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\n/* ???????????¢??° */\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\n/* ??????????????\\?¶??????±??\\?????¢??° */\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++){\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ???????????±???????????±??\\?????¢??° */\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcSumRouter(i4StartRouter,i4GoalRouter,i4TTL);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ??????????????????????¨????????????°?¨??????¢??° */\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\t/* ?????°??£?¨? */\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\t/* ????????¨ */\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\tI4 i4RoopMax;\n\t\n\t/* ????????? */\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\tif(i4TTL<=i4RouterNum){\n\t\ti4RoopMax = i4TTL;\n\t}\n\telse{\n\t\ti4RoopMax = i4RouterNum;\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<i4RoopMax; i4RoopCnt1++){\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=i4RouterNum; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int n,a,b,c,d,k,DATA[101][101];\n  for(int i=0;i<=101;i++){\n    for(int j=0;j<=101;j++){\n      DATA[i][j]=10000000;\n    }\n  }\n\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> a >> k;\n    for(int j=0;j<k;j++){\n      cin >> b;\n      DATA[a][b]=1;\n    }\n  }\n\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      for(k=1;k<=n;k++){\n\tif(DATA[j][k]>DATA[j][i]+DATA[i][k]){\n\t  DATA[j][k] = DATA[j][i]+DATA[i][k];\n\t}\n      }\n    }\n  }\n\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> a >> b >> c;\n    if(DATA[a][b]>=c) cout << \"NA\" << endl;\n    else cout << DATA[a][b]+1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n  cin >> n;\n  \n  int data[n+1][n+1];\n  \n  for(int i = 0; i <= n; i++){\n    for(int j = 0; j <= n; j++){\n      data[i][j] = 0;\n    }\n  }\n  \n  int from, to, conesum;\n  \n  for(int i = 0; i < n; i++){\n    cin >> from >> conesum;\n    for(int j = 0; j < conesum; j++){\n      cin >> to;\n      data[from][to] = 1;\n    }\n  }\n  \n  \n  int sumpake;\n  cin >> sumpake;\n  \n    queue<int> Q;\n\n    int ttl, myposi, min, sumin, sumina, finish = 0;\n\n    for(int i = 0; i < sumpake; i++){\n      min = 0;\n      cin >> from >> to >> ttl;\n      myposi = from;\n      for(int j = 0; j < ttl; j++){\n\tif(j != 0){\n\t  for(int l = 0; l < sumina; l++){\n\t    if(Q.front() == to){\n\t      min = j;\n\t      finish = 1;\n\t      break;\n\t    }\n\t    myposi = Q.front();\n\t    Q.pop();\n\t    for(int k = 1; k <= n; k++){\n\t      if(data[myposi][k] == 1) {\n\t\tQ.push(k);\n\t\tsumin++;\n\t      }\n\t    }\n\t    \n\t  }\n\t  if(finish == 1) break;\n\t}else{\n\t  sumin = 0;\n\t  for(int k = 1; k <= n; k++){\n\t    if(data[myposi][k] == 1) {\n\t      Q.push(k);\n\t      sumin++;\n\t    }\n\t  }\n\t  \n\t}\n\t  sumina = sumin;\n\t  sumin = 0;\n      }\n      \n      if(min == 0) cout << \"NA\";\n      else cout << min+1;\n      cout << endl;\n      finish = 0;\n      while(!Q.empty()) Q.pop();\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n;\n\tint d[101][101];\n\tREP(i, 101)REP(j, 101) d[i][j] = (i == j ? 0 : INF);\n\tcin >> n;\n\tREP(i, n)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tREP(j, b)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tk--;\n\t\t\td[i][k] = 1;\n\t\t}\n\t}\n\tREP(k, n)REP(i, n)REP(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\tint q;\n\tcin >> q;\n\twhile (q--)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (d[a][b] < c) cout << d[a][b]+1 << endl;\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 0144\n#include <iostream>\n#include <vector>\n#include <queue>\n#define  N    1000\nusing namespace std;\n\nvoid p_transport(int s, int d, int v, vector<vector<int> > R){\n\tvector<int> dis;\n\n\tfor(int i=0;i<R.size();i++)\n\t\tif(i == s)\n\t\t\tdis.push_back(1);\n\t\telse\n\t\t\tdis.push_back(N);\n\n\tqueue<int> ver;\n\tver.push(s);\n\n\twhile(!ver.empty()){\n\t\tint x = ver.front();\n\t\tfor(int i=0;i<R[x].size();i++)\n\t\t\tif(dis[R[x][i]] > dis[x] + 1){\n\t\t\t\tdis[R[x][i]] = dis[x] + 1;\n\t\t\t\tver.push(R[x][i]);\n\t\t\t}\n\t\tver.pop();\n\t}\n\n\tif(dis[d] <= v)\n\t\tcout<<dis[d]<<endl;\n\telse\n\t\tcout<<\"NA\"<<endl;\n}\n\nint main(){\n\tint n, r, k, t;\n\tvector<vector<int> > router;\n\n\tcin>>n;\n\trouter.resize(n+1);\n\n\tfor(int i=0;i<n;i++){\n\t\tcin>>r>>k;\n\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>t;\n\t\t\trouter[r].push_back(t);\n\t\t}\n\t}\n\n\tint p, s, d, v;\n\tcin>>p;\n\n\tfor(int i=0;i<p;i++){\n\t\tcin>>s>>d>>v;\n\n\t\tp_transport(s, d, v, router);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n#define INFTY 10000000\n\nint n,u,k;\nint s,d,v,TTL;\nint M[101][101],D[101];\n\nvoid bfs( int s ){\n  \n  queue <int> Q;\n\n  for( int i = 1; i <= n; i++ ) D[i] = INFTY;\n\n  D[s] = 0;\n  Q.push(s);\n     \n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    for( int l = 1; l <= n; l++ ){\n      if( M[u][l] == 0 ) continue;\n      if( D[l] != INFTY ) continue;\n      D[l] = D[u] + 1;\n      //cout << \"l\" << \" \" << l << \" \" <<  \"D[l]\" << \" \" << D[l] << \" \" <<\n      //\t\"D[u]\" << \" \" << D[u] << endl;\n      Q.push(l);\n\n      if ( D[l]+1 > TTL ){\n\tcout << \"NA\" << endl;\n\treturn;\n      }else if( l == d ){\n\tcout << D[l]+1 << endl;\n\t//\tcout << \"TTL\" << \" \" << TTL << endl;\n\treturn;\n      }\n\n    }\n\n  }\n \n}\n\nint main(){\n  cin >> n;\n  for( int i = 1; i <= n; i++ ){\n    cin >> u;\n    cin >> k;\n    for( int j = 0; j < k; j++ ){\n      int v;\n      cin >> v;\n      M[u][v] = 1;\n    }\n  }\n\n  /* for( int i = 1; i <= n; i++ ){\n    for( int j = 1; j <= n; j++ ) cout << M[i][j] << \" \";\n    cout << endl;\n    }*/\n  \n  int p; cin >> p; \n  for( int i = 0; i < p; i++ ){\n  cin >> s >> d >> TTL;\n  bfs(s);\n  // cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcRouterSum(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\treturn 0;\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER)\n\t{\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL)\n\t{\n\t\t//printf(\"start:%d,goal:%d,TTL:%d\\n\",i4StartRouter,i4GoalRouter,i4TTL);\n\t\ti4Ans = CalcRouterSum(i4StartRouter,i4GoalRouter,i4TTL,1);\n\t\tif(i4Ans >= i4TTL+1){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\t//printf(\"--------------\\n\");\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcRouterSum(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum)\n{\n\t//printf(\"%d -> %d,TTL=%d\\n\",i4Sender,i4Destination,i4TTL);\n\tI4 i4RoopCnt1;\n\tI4 i4MinRouterNum;\n\tI4 i4TmpRouterSum;\n\tI4 i4Return;\n\t\n\t\n\ti4Return = i4TTL+i4RouterSum;\n\t\n\tif(i4Sender == i4Destination)\n\t{\n\t\t//printf(\"RouterSum=%d\\n\",i4RouterSum);\n\t\treturn i4RouterSum;\n\t}\n\telse\n\t{\n\t\tif(i4TTL <= 0)\n\t\t{\n\t\t\t//printf(\"TTL is 0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti4RoopCnt1 = 1;\n\t\t\twhile(u1Connect[i4Sender][i4RoopCnt1] != SENTINEL){\n\t\t\t\tif(u1Connect[i4Sender][i4RoopCnt1] == CONNECT)\n\t\t\t\t{\n\t\t\t\t\ti4TmpRouterSum = CalcRouterSum(i4RoopCnt1,i4Destination,i4TTL-1,i4RouterSum+1);\n\t\t\t\t\tif((i4TmpRouterSum > 0 ) && (i4TmpRouterSum < i4Return))\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"CalcRouterSum()=%d\\n\",i4TmpRouterSum);\n\t\t\t\t\t\ti4Return = i4TmpRouterSum;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\ti4RoopCnt1++;\n\t\t\t}\n\t\t\treturn i4Return;\n\t\t}\n\t}\n\treturn i4Return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main()\n{\n  int n;\n  int node[100][100];\n  cin>>n;\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      node[i][j]=0;\n  \n  \n  for(int x=0;x<n;x++)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      queue<P> qu;\n      int ans=-1;\n      bool move[n+1];\n      if(v>1)\n\t{\n\t  for(int i=0;i<=n;i++)\n\t    {\n\t      if(node[s][i]==1)\n\t\tqu.push(P(i,2));\n\t    }\n\t  for(int i=0;i<=n;i++)\n\t    {\n\t      move[i]=true;\n\t    }\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  //\t  cout<<\"Queue:\"<<a.first<<\"  \"<<a.second<<endl;\n\t  if(a.first==d)\n\t    {\n\t      ans = a.second;\n\t      break;\n\t    }\n\t  for(int i=1;i<=n;i++)\n\t    {\n\t      if(node[a.first][i]==1)\n\t\t{\n\t\t  if(move[i] && a.second+1<=v)\n\t\t    {\n\t\t      qu.push(P(i,a.second+1));\n\t\t      move[i]=false;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = 1<<24;\nconst int size = 101;\nint n, p;\nint CN[size][size];\nint CNcnt[size];\nint MC[size];\n\ntypedef pair <int, int> Node;\ntypedef priority_queue <Node, vector <Node>, greater <Node> > QUEUE;\n\nvoid dijkstra( int start, int goal, int ttl ) {\n    QUEUE Q;\n    Node start_node( 1, start );\n    MC[start] = 1;\n    Q.push( start_node );\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        int router = node.second;\n        int cost = node.first;\n\n        if ( router == goal ) {\n            cout << cost << endl;\n            return;\n        }\n\n        for ( int i = 0; i < CNcnt[router]; i++ ) {\n            int next_router = CN[router][i] - 1;\n            int next_cost = cost + 1;\n            \n            if ( next_cost >= ttl + 1 ) continue;\n            if ( next_cost >= MC[next_router] ) continue;\n            MC[next_router] = next_cost;\n            Node next_node( next_cost, next_router );\n            Q.push( next_node );\n        }\n    }\n\n    cout << \"NA\" << endl;\n}\n\nvoid init() {\n    for ( int i = 0; i < size; i++ ) {\n        MC[i] = inf;\n    }\n}\n\nvoid solve() {\n    cin >> p;\n    for ( int i = 0; i < p; i++ ) {\n        int start, goal, ttl;\n        cin >> start >> goal >> ttl;\n        init();\n        dijkstra( start-1, goal-1, ttl );\n    }\n}\n\nvoid input() {\n    cin >> n;\n    for ( int i = 0; i < n; i++ ) {\n        int r, k;\n        cin >> r >> k;\n        CNcnt[r-1] = k;\n        for ( int j = 0; j < k; j++ ) {\n            cin >> CN[r-1][j];\n        }\n    }\n}\n\nint main( void ) {\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(101);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    vector<bool> check(101, false);\n    queue<int> fq, nq, sq;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            if (check[pos]) {\n                continue;\n            } else {\n                check[pos] = true;\n            }\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            } else {\n                for (int i: g[pos]) {\n                    nq.push(i);\n                }\n            }\n        }\n        if (c == 0 || nq.empty()) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main()\n{\n  int n;\n  int node[100][100];\n  cin>>n;\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      node[i][j]=0;\n  \n  \n  for(int x=0;x<n;x++)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      queue<P> qu;\n      int ans=-1;\n      if(v>1)\n\tfor(int i=0;i<=n;i++)\n\t  {\n\t    if(node[s][i]==1)\n\t      qu.push(P(i,2));\n\t  }\n      bool move[n+1];\n      for(int i=0;i<=n;i++)\n\t{\n\t  move[i]=true;\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  //\t  cout<<\"Queue:\"<<a.first<<\"  \"<<a.second<<endl;\n\t  if(a.first==d)\n\t    {\n\t      ans = a.second;\n\t      break;\n\t    }\n\t  if(a.second<v)    \n\t    for(int i=1;i<=n;i++)\n\t      {\n\t\tif(node[a.first][i]==1)\n\t\t  {\n\t\t    if(move[i])\n\t\t      {\n\t\t\tqu.push(P(i,a.second+1));\n\t\t\tmove[i]=false;\n\t\t      }\n\t\t  }\n\t      }\n\t}\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint n,i,j,k,a,b,c,cost[101][101];\n\tchar cc;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) cost[i][j] = 1<<15;\n\t\tcin>>a>>b;\n\t\tfor(j=0;j<b;j++){\n\t\t\tcin >> c;\n\t\t\tcost[a][c]=1;\n\t\t}\n\t}\n\tfor(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++)\n\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b>>c;\n\t\tif(cost[a][b]<c || cost[a][b]>=1<<15) cout << cost[a][b]+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\n\nstruct edge{ \n\tint to, cost;\n\tedge(int to, int cost) :to(to), cost(cost){};\n};\nvector<edge> G[110];\n\nint n, r, k, t;\nint p, s, d, v;\n\nint dis[110];\n\nvoid dijkstra(int start){\n\tdis[start] = 0;\n\n\tpriority_queue<P> que;\n\tque.push(P(0, start));\n\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint a = p.second;\n\n\t\tif (dis[a] < p.first)continue;\n\n\t\tfor (int i = 0; i < G[a].size(); i++){\n\t\t\tedge e = G[a][i];\n\t\t\tif (dis[e.to] > dis[a] + e.cost){\n\t\t\t\tdis[e.to] = dis[a] + e.cost;\n\t\t\t\tque.push(P(dis[e.to], e.to));\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tREP(i, n){\n\t\tcin >> r >> k;\n\t\tREP(j, k){\n\t\t\tcin >> t;\n\t\t\tG[r].push_back(edge(t, 1));\n\t\t}\n\t}\n\tcin >> p;\n\tREP(i, p){\n\t\tREP(j, 110)dis[j] = INF;\n\t\tcin >> s >> d >> v;\n\t\tdijkstra(s);\n\t\tif (dis[d] + 1 <= v)cout << dis[d] + 1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint i, j, n, r, k, t, p, s, _d, v, ans;\nint dic(int d[][100]) {\n  int mi = s, f[100] = {};\n  vector <int> cost(100, 100000000);\n  cost[s] = 0; //テ・ツ、ツァテ、ツコツ?\n  for(i = 0; i < n; i++) {\n    f[mi] = 1;\n    for(j = 0; j < n; j++)  if(d[mi][j] == 1 && !f[j] && cost[j] > cost[mi] + 1) cost[j] = cost[mi] + 1;\n    int min = 200000000;\n    for(j = 0; j < n; j++)  if(!f[j] && min > cost[j]) min = cost[mi = j];\n  }\n  return cost[_d];\n}    \n\nint main() {\n  while(cin >> n) {\n    int d[100][100] = {};\n    for(i = 0; i < n; i++) {//\n      cin >> r >> k;\n      r--;\n      while(k--) {\n\tcin >> t;\n\tt--;\n\td[r][t] = 1;\n      }\n    }\n    cin >> p;\n    while(p--) {\n      cin >> s >> _d >> v;\n      s--; _d--;\n      ans = dic(d) + 1;\n      if(ans <= v)  cout << ans << endl;\n      else cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nconst int INF = 100000000;\nint adj[110][110];\n\nint main() {\n  int n,p,r,k,t,s,d,v;\n\n  for(int i=0; i<110; ++i) {\n    for(int j=0; j<110; ++j) {\n      adj[i][j] = INF;\n    }\n  }\n\n  cin>>n;\n  for(int i=0; i<n; ++i) {\n    cin>>r>>k;\n    r--;\n    for(int j=0; j<k; ++j) {\n      cin>>t;\n      t--;\n      adj[r][t] = 1;\n    }\n  }\n\n  for(int k=0; k<n; ++k) {\n    for(int i=0; i<n; ++i) {\n      for(int j=0; j<n; ++j) {\n\tadj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);\n      }\n    }\n  }\n  \n  cin>>p;\n  for(int i=0; i<p; ++i) {\n    cin>>s>>d>>v;\n    s--,d--;\n    if(adj[s][d]+1 <= v) cout<<adj[s][d]+1<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define INF 1e9\n\nint d[101][101];\nint n;\n\nvoid init(){\n\tfor(int i = 0; i < 101; i++){\n\t\tfor(int j = 0; j < 101; j++)\td[i][j] = INF;\n\t}\n}\n\nvoid solve(){\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++)\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint np;\n\tinit();\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint v, e;\n\t\tcin >> v >> e;\n\t\tfor(int j = 0; j < e; j++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\td[v][t] = 1;\n\t\t}\n\t}\n\tsolve();\n\tcin >> np;\n\tfor(int i = 0; i < np; i++){\n\t\tint s, g, ttl;\n\t\tcin >> s >> g >> ttl;\n\t\tif(d[s][g] != INF && d[s][g] + 1 <= ttl){\n\t\t\tprintf(\"%d\\n\", d[s][g] + 1);\n\t\t}else{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> p;\nvector<int> V[101];\nint cost[101];\n\nvoid dijkstra(int s,int d,int v1) {\n  priority_queue<p,vector<p>, greater<p> > que;\n  for(int i=0;i<101;i++) {\n    cost[i] = INF;\n  }\n  cost[s] = 1;\n  que.push(p(0,s));\n\n  while(!que.empty()) {\n    p v = que.top();que.pop();\n    int P = v.second;\n    if(cost[P] < v.first) continue;\n    for(unsigned int i=0;i<V[P].size();i++) {\n      int to = V[P][i];\n      if(cost[to] > cost[P] + 1) {\n        cost[to] = cost[P] + 1;\n        que.push(p(cost[to],to));\n      }\n    }\n  }\n  if(v1 - cost[d] >= 0)\n    cout << cost[d] << endl;\n  else\n    cout << \"NA\" << endl;\n}\n\nint main() {\n  int n,t,k,r,p,s,d,v;\n  string str;\n  while(cin >> n) {\n\n    for(int i=0;i<n;i++) {\n      cin >> r >> k;\n      for(int j=0;j<k;j++) {\n        cin >> t;\n        V[r].push_back(t);\n      }\n    }\n\n    cin >> p;\n    for(int i=0;i<p;i++) {\n      cin >> s >> d >> v;\n      dijkstra(s,d,v);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\nint dist[100][100];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)dist[i][j]=INF;\n\tfor(int i=0;i<n;i++)dist[i][i]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint r,k,t;\n\t\tcin>>r>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>t;\n\t\t\tdist[r-1][t-1]=1;\n\t\t}\n\t}\n\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)\n\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\tint p;\n\tcin>>p;\n\tfor(int i=0;i<p;i++){\n\t\tint s,d,v;\n\t\tcin>>s>>d>>v;\n\t\tif(dist[s-1][d-1]<v)cout<<dist[s-1][d-1]+1<<endl;\n\t\telse cout<<\"NA\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> dp(n, vector<int>(n, INF<int>));\n    for (int i = 0; i < n; ++i) dp[i][i] = 0;\n    for (int i = 0; i < n; ++i) {\n        int r, k;\n        cin >> r >> k;\n        for (int j = 0; j < k; ++j) {\n            int x;\n            cin >> x;\n            dp[r-1][x-1] = 1;\n        }\n    }\n    for (int k = 0; k < n; ++k) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        a--; b--;\n        if(dp[a][b] >= c) puts(\"NA\");\n        else cout << dp[a][b]+1 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n  while(1){\n  int n;\n    cin >> n;\n    if(n == 0) break;\n    \n    int data[n+1][n+1];\n    \n    for(int i = 0; i <= n; i++){\n      for(int j = 0; j <= n; j++){\n\tdata[i][j] = 0;\n      }\n    }\n    \n    int from, to, conesum;\n\n    for(int i = 0; i < n; i++){\n      cin >> from >> conesum;\n      for(int j = 0; j < conesum; j++){\n\tcin >> to;\n\tdata[from][to] = 1;\n      }\n    }\n\n\n    int sumpake;\n    cin >> sumpake;\n\n    queue<int> Q;\n\n    int ttl, myposi, min, sumin, sumina, finish = 0;\n\n    for(int i = 0; i < sumpake; i++){\n      min = 0;\n      cin >> from >> to >> ttl;\n      myposi = from;\n      for(int j = 0; j < ttl; j++){\n\tif(j != 0){\n\t  for(int l = 0; l < sumina; l++){\n\t    if(Q.front() == to){\n\t      min = j;\n\t      finish = 1;\n\t      break;\n\t    }\n\t    myposi = Q.front();\n\t    Q.pop();\n\t    for(int k = 1; k <= n; k++){\n\t      if(data[myposi][k] == 1) {\n\t\tQ.push(k);\n\t\tsumin++;\n\t      }\n\t    }\n\t    \n\t  }\n\t  if(finish == 1) break;\n\t}else{\n\t  sumin = 0;\n\t  for(int k = 1; k <= n; k++){\n\t    if(data[myposi][k] == 1) {\n\t      Q.push(k);\n\t      sumin++;\n\t    }\n\t  }\n\t  \n\t}\n\t  sumina = sumin;\n\t  sumin = 0;\n      }\n      \n      if(min == 0) cout << \"NA\";\n      else cout << min+1;\n      cout << endl;\n      finish = 0;\n      while(!Q.empty()) Q.pop();\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,b;\n  int ans=0;\n  int box[111][111];\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      box[i][j]=INT_MAX;\n    }\n  }\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      box[r-1][t-1]=1;\n    }\n  }\n  for(int z=0;z<n;z++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tbox[i][j]=min(box[i][j],box[i][z]+box[z][j]);\n      }\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> b;\n    ans=box[s-1][d-1]+1;\n    if(ans<=b){\n      cout << box[s-1][d-1]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Packet Transportation\n//Level: 2\n//Category: グラフ,Graph,全点対間最短距離\n//Note:\n\n/**\n * 全点対間の最短距離を求めておけば良い。\n * オーダーは O(N^3)。\n */\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate <typename T>\nstruct Maybe {/*{{{*/\n    T val;\n    bool valid;\n\n    Maybe() : valid(false) {}\n    Maybe(T &t) : val(t), valid(true) {}\n\n    T& operator =(const T &rv) {\n        val = rv;\n        valid = true;\n        return val;\n    }\n\n    operator T() {\n        return valid ? val : T();\n    }\n\n    template<typename Cond>\n    bool update(const T &v, Cond cond) {\n        if(!valid || cond(v, val)) {\n            val = v;\n            valid = true;\n            return true;\n        }\n        return false;\n    }\n\n    bool update(const T &v) {\n        return update(v, less<T>());\n    }\n};/*}}}*/\n\ntemplate<typename T>\nstruct WarshallFloyd {\n    vector<vector<Maybe<T>>> graph;\n    int N;\n\n    WarshallFloyd(int size) : graph(size), N(size) {\n        for(auto &v : graph) {\n            v.resize(size);\n        }\n    }\n\n    void add_edge(int from, int to, const T &dist) {\n        graph[from][to] = dist;\n    }\n\n    void freeze() {\n        for(int k = 0; k < N; ++k) {\n            for(int i = 0; i < N; ++i) {\n                for(int j = 0; j < N; ++j) {\n                    if(graph[i][k].valid && graph[k][j].valid) {\n                        graph[i][j].update(graph[i][k] + graph[k][j]);\n                    }\n                }\n            }\n        }\n    }\n\n    const Maybe<T>& query(int from, int to) {\n        return graph[from][to];\n    }\n};\n\nbool solve(bool first) {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    WarshallFloyd<int> wf(N);\n    for(int i = 0; i < N; ++i) {\n        int from, k;\n        cin >> from >> k;\n        --from;\n        while(k--) {\n            int v;\n            cin >> v;\n            wf.add_edge(from, v-1, 1);\n        }\n    }\n    wf.freeze();\n    int P;\n    cin >> P;\n    while(P--) {\n        int s, d, t;\n        cin >> s >> d >> t;\n        const auto &dist = wf.query(s-1, d-1);\n        if(dist.valid && dist.val+1 <= t) {\n            cout << dist.val+1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(2);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> NODE;\n#define pos first\n#define depth second\n\nbool info[100][100];\n\nint bfs(int s,int d){\n\tqueue<NODE> Q;\n\tbool done[100]={false};\n\t\n\tQ.push( make_pair(s,0) );\n\twhile( !Q.empty() ){\n\t\t/* queueツづ個静ヲツ督ェツづ個ノツーツドツづーツ訪ツ姪「ツ催渉づ敖づ可つオツづowツ陛渉青板づ可禿シツづェツ、ツキツδーツつゥツづァツ偲ヲツづィツ渉慊つュ */\n\t\tNODE now = Q.front();\n\t\tQ.pop();\n\t\tdone[now.pos] = true;\n\n\t\tif(now.pos == d){\n\t\t\treturn now.depth;\n\t\t}\n\n\t\tfor(int next=0;next<100;next++){\n\t\t\tif( !done[next] && info[now.pos][next] ){\n\t\t\t\tQ.push( make_pair(next,now.depth+1) );\n\t\t\t}\n\t\t}\n\t}\n\treturn INT_MAX;\n}\n\nint main(){\n\tint n,r,k,t,p,s,d,v;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tr--;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\tinfo[r][t] = true;\n\t\t}\n\t}\t\n\t\n\tcin >> p;\n\tfor(int i=0;i<p;i++){\n\t\tcin >> s >> d >> v;\n\t\ts--;d--;\n\t\tif(v > bfs(s,d) )cout << bfs(s,d)+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n\nconst int INFTY = 1 << 22;\n\nusing namespace std;\n\nclass Rooter{\n  public:\nRooter(){\n  this->cost = INFTY;\n  this->done = false;\n}\n  int cost;\n  bool done;\n  vector<int> vcon;\n};\n\nvoid BFS( int start, map< int, Rooter > &G ){\n  queue< Rooter * > q;\n\n  G[ start ].cost = 1;\n  G[ start ].done = true;\n  q.push( &G[start] );\n\n  while( !q.empty() ){\n    Rooter *r = q.front();\n    q.pop();\n\n    for(int i = 0; i < r->vcon.size(); i++){\n      if( G[ r->vcon[i]].done ){\n\tcontinue;\n      }\n      G[ r->vcon[i] ].cost = min( G[ r->vcon[i] ].cost , r->cost + 1 );\n      q.push( &G[ r->vcon[i] ] );\n      G[ r->vcon[i] ].done = true;\n    }\n  }\n}\n\nvoid ResetGraph( map< int, Rooter > &G, vector<int> &vId ){\n  for(int i = 0; i < vId.size(); i++){\n    G[ vId[i] ].cost = INFTY;\n    G[ vId[i] ].done = false;\n  }\n}\n\nint main(void){\n  int n, p;\n  vector< int > vId;\n  map< int, Rooter > G;\n\n  cin >> n;\n  \n  for(int i = 0; i < n; i++){\n    int no;\n    int cnum;\n    Rooter r;\n\n    cin >> no >> cnum;\n    vId.push_back( no );\n    for(int j = 0; j < cnum; j++){\n      int connect;\n      cin >> connect;\n      r.vcon.push_back( connect );\n    }\n    G[ no ] = r;\n  }\n\n  cin >> p;\n  for(int i = 0; i < p; i++){\n    int s, d, ttl;\n\n    cin >> s >> d >> ttl;\n    ResetGraph( G, vId );\n    BFS( s, G );\n    if( G[d].cost <= ttl ){\n      cout << G[d].cost << '\\n';\n    }else{\n      cout << \"NA\\n\";\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n,r,k,t1,t2;\n  cin >> n;\n  int graph[n+1][n+1];\n  for(int i=0;i<n+1;i++){\n    for(int j=0;j<n+1;j++){\n      graph[i][j] = 1000000;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    int t;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      graph[r][t] = 1;\n    }\n  }\n\n\n  //ワーシャルフロイド\n  for(int k=1;k<n+1;k++){\n    for(int i=1;i<n+1;i++){\n      for(int j=1;j<n+1;j++){\n\tgraph[i][j] = min( graph[i][j] , graph[i][k] + graph[k][j]);\n      }\n    }\n  }\n\n\n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++){\n    int s,d,v;\n    cin >> s >> d >> v;\n    if(v-graph[s][d] <= 0) cout << \"NA\" << endl;\n    else cout << graph[s][d]+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\nusing namespace std;\n\n\nint net[110][110],n;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nvoid debug();\n\nint main(){\n\n  for(int k=0;k<110;k++)for(int l=0;l<110;l++)net[k][l]=-1; //Syokika\n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n\n\n\n    for(int k=0;k<110;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  // debug();\n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=110;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;  \n\n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      if(mem == n)break;\n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\nvoid debug(){\n  for(int i=1;i<=10;i++){\n    if(i==1){\n      cout << \"   \";\n      for(int k=1;k<=10;k++){\n\tprintf(\"%3d\",k);\n      }\n      cout << endl;\n      for(int k=1;k<=10;k++)printf(\"___\");\n      cout << endl;\n    }\n\n    for(int j=1;j<=10;j++){\n      if(j == 1)cout << i << \" |\";\n      printf(\"%3d\",net[i][j]);\n    }\n    cout << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int d[100][100];\n    int n;\n    scanf(\"%d\",&n);\n    fill(*d,*d+100*100,1<<25);\n    for(int i=0;i<n;i++)d[i][i]=0;\n    for(int i=0;i<n;i++){\n        int r,k;\n        scanf(\"%d%d\",&r,&k);\n        r--;\n        for(int j=0;j<k;j++){\n            int t;\n            scanf(\"%d\",&t);\n            t--;\n            d[r][t]=1;\n        }\n    }\n\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n    int m;\n    scanf(\"%d\",&m);\n    while(m--){\n        int s,g,t;\n        scanf(\"%d%d%d\",&s,&g,&t);\n        s--;g--;\n        int val=d[s][g];\n        if(t<=val)puts(\"NA\");\n        else printf(\"%d\\n\",val+1);\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nint dist[100][100];\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tfill(dist[0], dist[100], INF);\n\tREP(i, n) dist[i][i] = 0;\n\tREP(i, n) {\n\t\tint r, k;\n\t\tscanf(\"%d %d\", &r, &k);\n\t\tr--;\n\t\tREP(j, k) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tt--;\n\t\t\tdist[r][t] = 1;\n\t\t}\n\t}\n\t\n\tREP(k, n) REP(i, n) REP(j, n)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\n\tint p;\n\tcin >> p;\n\tREP(i, p) {\n\t\tint s, d, v;\n\t\tscanf(\"%d %d %d\", &s, &d, &v);\n\t\ts--; d--;\n\t\tif (dist[s][d] == INF || dist[s][d] >= v) puts(\"NA\");\n\t\telse printf(\"%d\\n\", dist[s][d] + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,b;\n  int ans=0;\n  int box[111][111];\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      box[i][j]=(1<<21);\n    }\n  }\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      box[r-1][t-1]=1;\n    }\n  }\n  for(int z=0;z<n;z++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tbox[i][j]=min(box[i][j],box[i][z]+box[z][j]);\n      }\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> b;\n    ans=box[s-1][d-1]+1;\n    if(ans<=b){\n      cout << box[s-1][d-1]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n  cin >> n;\n  \n  int data[n+1][n+1];\n  \n  for(int i = 0; i <= n; i++){\n    for(int j = 0; j <= n; j++){\n      data[i][j] = 0;\n    }\n  }\n  \n  int from, to, conesum;\n  \n  for(int i = 0; i < n; i++){\n    cin >> from >> conesum;\n    for(int j = 0; j < conesum; j++){\n      cin >> to;\n      data[from][to] = 1;\n    }\n  }\n  \n  \n  int sumpake;\n  cin >> sumpake;\n  \n    queue<int> Q;\n\n    int ttl, myposi, min, sumin, sumina, finish = 0;\n\n    for(int i = 0; i < sumpake; i++){\n      min = 0;\n      cin >> from >> to >> ttl;\n      if(ttl == 0) {\n\tcout << \"NA\" << endl;\n\tcontinue;\n      }\n      myposi = from;\n      for(int j = 0; j < ttl; j++){\n\tif(j != 0){\n\t  for(int l = 0; l < sumina; l++){\n\t    if(Q.front() == to){\n\t      min = j;\n\t      finish = 1;\n\t      break;\n\t    }\n\t    myposi = Q.front();\n\t    Q.pop();\n\t    for(int k = 1; k <= n; k++){\n\t      if(data[myposi][k] == 1) {\n\t\tQ.push(k);\n\t\tsumin++;\n\t      }\n\t    }\n\t    \n\t  }\n\t  if(finish == 1) break;\n\t}else{\n\t  sumin = 0;\n\t  for(int k = 1; k <= n; k++){\n\t    if(data[myposi][k] == 1) {\n\t      Q.push(k);\n\t      sumin++;\n\t    }\n\t  }\n\t  \n\t}\n\t  sumina = sumin;\n\t  sumin = 0;\n      }\n      \n      if(min == 0) cout << \"NA\";\n      else cout << min+1;\n      cout << endl;\n      finish = 0;\n      while(!Q.empty()) Q.pop();\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 110\n\n#define INF 999999999\n\nint x[MAX_N][MAX_N];\nint d[MAX_N];\n\nqueue<int>Q;\n\nint bfs(int s, int t){\n\tfor(int i=0;i<MAX_N;i++){\n\t\td[i]=INF;\n\t}\n\td[s]=0;\n\tQ.push(s);\n\twhile(!Q.empty()){\n\t\tint z=Q.front();\n\t\tfor(int i=0;i<MAX_N;i++){\n\t\t\tif(x[z][i]<INF){\n\t\t\t\tif(d[i]==INF){\n\t\t\t\t\td[i]=d[z]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\treturn d[t];\n}\n\nint main(){\n\tint n,m,a,b,c;\n\tfor(int i=0;i<MAX_N;i++){\n\t\tfor(int j=0;j<MAX_N;j++){\n\t\t\tx[i][j]=INF;\n\t\t}\n\t}\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a>>b;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tcin>>c;\n\t\t\tx[a][c]=1;\n\t\t}\n\t}\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tint y=bfs(a,b);\n\t\tif(y>=c){cout<<\"NA\"<<endl;}\n\t\telse{cout<<c-y<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\nusing namespace std;\n#define SUB 101\n\nint net[SUB][SUB],n;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\nvoid debug();\n\nint main(){\n\n  for(int k=0;k<SUB;k++)for(int l=0;l<SUB;l++)net[k][l]=-1; //Syokika\n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n\n\n\n    for(int k=0;k<SUB;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  // debug();\n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=SUB;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;  \n\n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      if(mem == n)break;\n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\nvoid debug(){\n  for(int i=1;i<=10;i++){\n    if(i==1){\n      cout << \"   \";\n      for(int k=1;k<=10;k++){\n\tprintf(\"%3d\",k);\n      }\n      cout << endl;\n      for(int k=1;k<=10;k++)printf(\"___\");\n      cout << endl;\n    }\n\n    for(int j=1;j<=10;j++){\n      if(j == 1)cout << i << \" |\";\n      printf(\"%3d\",net[i][j]);\n    }\n    cout << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define MM\t1000000\nusing namespace std;\nint main(void)\n{\n\tint i,j,n,p,k[101],t[101][100];\n\tint s,d,leng[101],r,flg[101],f,v,ii,jj,x;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\t{\n\t\tscanf(\"%d\",&r);\n\t\tscanf(\"%d\",&k[r]);\n\t\tfor(j=0;j<k[r];j++)\t{\n\t\t\tscanf(\"%d\",&t[r][j]);\n\t\t}\n\t}\n\tscanf(\"%d\",&p);\n\tfor(i=0;i<p;i++)\t{\n\t\tscanf(\"%d %d %d\",&s,&d,&v);\n\t\tf=0;\n\t\tfor(j=1;j<=n;j++)\t{\n\t\t\tflg[j]=0;\tleng[j]=MM;\n\t\t}\n\t\tleng[s]=1;\n\t\tfor(j=1;j<v;j++)\t{\n\t\t\tfor(ii=1;ii<=n;ii++)\t{\n\t\t\t\tif(leng[ii]==j)\t{\n\t\t\t\t\tfor(jj=0;jj<k[ii];jj++)\t{\n\t\t\t\t\t\tx=t[ii][jj];\n\t\t\t\t\t\tif(leng[x]>j+1)\t{\n\t\t\t\t\t\t\tleng[x]=j+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x==d)\t{\n\t\t\t\t\t\t\tf=1;\n\t\t\t\t\t\t\tii=n+1;\n\t\t\t\t\t\t\tj=v;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f==1)\t{\n\t\t\tprintf(\"%d\\n\",leng[d]);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\n\nconst int INF = 1<<28;\n\nint N;\nGraph G;\n  \nint bfs(int src, int dst) {\n  queue<int> que;\n  vector<int> cost(N, INF);\n  que.push(src);\n  cost[src] = 0;\n  while(que.size()) {\n    const int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i) {\n      int nv = G[v][i];\n      if(cost[nv] != INF) continue;\n      cost[nv] = cost[v] + 1;\n      que.push(nv);\n    }\n  }\n  return cost[dst];\n}\n\nint main() {\n  cin >> N;\n  G.resize(N);\n  vector<vector<int> > to(N);\n  map<int,int> id;\n  for(int i = 0; i < N; ++i) {\n    int r, k;\n    cin >> r >> k;\n    id[r] = i;\n    to[i].resize(k);\n    for(int j = 0; j < k; ++j) {\n      cin >> to[i][j];\n    }\n  }\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < to[i].size(); ++j) {\n      G[i].push_back(id[to[i][j]]);\n    }\n  }\n\n  int p;\n  cin >> p;\n  while(p--) {\n    int s, d, v;\n    cin >> s >> d >> v;\n    s = id[s];\n    d = id[d];\n    int res = bfs(s, d);\n    if(res < v) {\n      cout << res+1 << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\treturn 0;\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER)\n\t{\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL)\n\t{\n\t\ti4Ans = CalcDijikstra(i4StartRouter,i4GoalRouter,i4TTL,1);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum)\n{\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tif(i4TTL <= i4RoopCnt1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE)\n\t\t\t{\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=MAX_ROUTER; i4RoopCnt3++)\n\t\t\t\t{\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst int INF = 1e6;\nint main(void){\n  int n;\n  int cost[100][100];\n  REP(i,100)REP(j,100)cost[i][j] = (i!=j)?INF:0;\n  cin>>n;\n  REP(i,n){\n    int r,k;\n    cin>>r>>k;\n    r--;\n    while(k--){\n      int t;\n      cin>>t;\n      t--;\n      cost[r][t] = 1;\n    }\n  }\n  int p;\n  cin>>p;\n  REP(k,n)REP(i,n)REP(j,n)cost[i][j] = min(cost[i][j],cost[i][k]+cost[k][j]);\n  while(p--){\n    int s,d,v;\n    cin>>s>>d>>v;\n    int c = cost[s-1][d-1];\n    c++;\n    if(c<=v)cout<<c<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include <map>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> P;\n\nqueue<P> qu;\n\nint main()\n{\n  int table[200][200];\n  int n;\n  cin>>n;\n  for(int x=0;x<n;x++) // ノード数\n    {\n      int r;   // ノード番号\n      int k;   // rにつながるノード数\n      cin>>r>>k;\n      for(int i=0;i<k;i++)\n\t{\n\t  int t; // rにつながるノード番号\n\t  cin>>t;\n\t  table[r][t]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(int x=0;x<p;x++)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      int ans = -1;\n      queue<P> qu;\n      int c[200];\n      memset(c,-1,sizeof(c));  //経路到達情報の初期化\n      if(v>1)                   //TTLが1のときは追加しない\n\tfor(int i=0;i<200;i++)\n\t  if(table[s][i]==1)    //s->iの経路があればキューに追加\n\t    qu.push(P(i,2));\n       \n      while(!qu.empty()) {     //キューが空になるまで続ける\n\tP a = qu.front(); qu.pop(); //キューの先頭を取出\n\t//\tcout<<a.first<<\"  \"<<a.second<<endl;\n\t//a.firstがゴールなら、終了\n\tif(a.first==d) { ans=a.second;break; }\n\tif(a.second+1<=v) { // パケットのTTLが0にならないとき\n\t  for(int i=0;i<200;i++) {\n\t    //隣接かつ今までそのノードに到達していなければキューに追加\n\t    if(table[a.first][i]==1 && c[i]==-1) {\n\t      c[i] = 1;\n\t      qu.push(P(i,a.second+1));\n\t    }\n\t  }\n\t}\n\t\n      }\n      if(ans!=-1)\n\tcout<<ans<<endl;\n      else\n\tcout<<\"NA\"<<endl;\n      \n    }\n  \n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n\nstatic const int NO = -2;\nstatic const int N = 300;\n\n\nint graph[N + 1][N + 1] = {{}};\nint dis[N + 1] = {};\nint n;\n\nvoid bfs(int v){\n  queue<int> Q;\n\n  Q.push(v);\n\n  for(int i = 1; i <= N; i++){\n    dis[i] = NO;\n  }\n\n  dis[v] = 1;\n\n  int u;\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n\n    for(int i = 1;i <= n; i++){\n      if(graph[u][i]==0) continue;\n      if(dis[i]!=NO)continue;\n      dis[i] = dis[u] + 1;\n      Q.push(i);\n\n    }\n  }\n}\n\nint main(){\n\n  int r[N+1] = {};\n  int d[N+1] = {};\n  int k[N+1] = {};\n  int f[N+1] = {};\n  int p,s[N+1] = {};\n  int v[N+1] = {};\n\n\n  //in\n  cin >> n;\n\n  for(int i = 1;i <= n; i++){\n\n    cin >> r[i] >> k[i];\n\n    for(int j = 1;j <= k[i];j++){\n\n      cin >> f[j];\n      graph[i][f[j]] = 1;\n    }\n  }\n\n  cin >> p;\n  for(int i = 1;i <= p; i++){\n    cin >> s[i] >> d[i] >> v[i];\n    bfs(s[i]);\n\n    if(v[i] >= dis[d[i]]) cout << dis[d[i]] << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,b;\n  int ans=0;\n  int box[111][111];\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      box[i][j]=INT_MAX;\n    }\n  }\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      box[r-1][t-1]=1;\n    }\n  }\n  for(int z=0;z<n;z++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tbox[i][j]=min(box[i][j],box[i][z]+box[z][j]);\n      }\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> b;\n    ans=box[s-1][d-1]+1;\n    if(ans<=b){\n      cout << box[s-1][d-1]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\nconst int INF = 1 << 20;\nstruct P\n{\n\tint r1, k1;\n\tvint ok;\n};\n\n\nint main()\n{\n    int n, p;\n\tcin >> n;\n\tcin.ignore();\n\t\n\tvector<P> v(n);\n\trep(i, n)\n\t{\n\t\tcin >> v[i].r1;\n\t\t\n\t\tint k1;\n\t\tcin >> k1;\n\t\t\n\t\trep(j, k1)\n\t\t{\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tv[i].ok.push_back(buf);\n\t\t}\n\t}\n\t\n\tcin >> p;\n\t\n\tvector<vint> G(n, vint(n, INF));\n\t\n\trep(i, n)\n\t{\n\t\trep(j, v[i].ok.size())\n\t\t{\n\t\t\tG[v[i].r1 - 1][v[i].ok[j] - 1] = 1;\n\t\t}\n\t}\n\t\n\trep(k, n) rep(i, n) rep(j, n)\n\t\tchmin(G[i][j], G[i][k] + G[k][j]);\n\t\t\n\trep(i, p)\n\t{\n\t\tint s1, d1, v1;\n\t\tcin >> s1 >> d1 >> v1;\n\t\t\n\t\tint cost = G[s1 - 1][d1 - 1];\n\t\tif(cost == INF || v1 <= cost)\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << cost + 1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){\n\t\tttl = current = 0;\n\t}\n\n\tvoid copy(Packet t){\n\t\tttl = t.ttl;\n\t\tcurrent = t.current;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = t.checkTable[i];\n\t}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tif(memo[start][goal] != 0){\n\t\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int d = 1; d <= n; d++){\n\t\t\t\tif(d != start && table[start][d] == 1){\n\t\t\t\t\tif(memo[d][goal] > 0 && memo[d][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[d][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[d][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(d);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp.copy(Q.front());\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.ttl > 0 && tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1 && t_limit-tmp.ttl + 1 <= n){\n\t\t\t\tfor(int m=1; m <= n; m++){\n\t\t\t\t\tif(m != tmp.current && tmp.checkTable[m] == 0 && table[tmp.current][m] == 1){\n\t\t\t\t\t\tif(memo[m][goal] > 0 && (memo[m][goal]+1) < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[m][goal]+2);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[m][goal]+2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket q;\n\t\t\t\t\t\tq.copy(tmp);\n\t\t\t\t\t\tq.ttl--;\n\t\t\t\t\t\tq.set(m);\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main()\n{\n  int n;\n  int node[100][100];\n  cin>>n;\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      node[i][j]=0;\n  \n  \n  for(int x=0;x<n;x++)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      queue<P> qu;\n      int ans=-1;\n      if(v>1)\n\tfor(int i=0;i<=n;i++)\n\t  {\n\t    if(node[s][i]==1)\n\t      qu.push(P(i,2));\n\t  }\n      bool move[n+1];\n      for(int i=0;i<=n;i++)\n\t{\n\t  move[i]=true;\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  //\t  cout<<\"Queue:\"<<a.first<<\"  \"<<a.second<<endl;\n\t  if(a.first==d)\n\t    {\n\t      ans = a.second;\n\t      break;\n\t    }\n\t    for(int i=1;i<=n;i++)\n\t      {\n\t\tif(node[a.first][i]==1)\n\t\t  {\n\t\t    if(move[i])\n\t\t      {\n\t\t\tqu.push(P(i,a.second+1));\n\t\t\tmove[i]=false;\n\t\t      }\n\t\t  }\n\t      }\n\t}\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n\nusing namespace std;\n\ntypedef struct {\n  int *ks;\n  int length;\n} node;\n\nnode *nodes;\n\nlist<int> que;\n\nint dikstra(int s, int e, int deep){\n  int c=0;\n\n  que.clear();\n  que.push_back(s);\n\n  while(1){\n    c++;\n    if(c >= deep) return -1;\n\n    int len = que.size();\n    for(int i=0;i<len;i++){\n      int v = que.front();\n      que.pop_front();\n      for(int j=0;j<nodes[v].length;j++){\n        if(nodes[v].ks[j]==e) return c+1;\n        que.push_back(nodes[v].ks[j]);\n      }\n    }\n  }\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  nodes = new node[n];\n\n  int i,j;\n  int t,u,v;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\", &t,&u);\n    nodes[t-1].ks = new int[u];\n    nodes[t-1].length = u;\n    for(j=0;j<u;j++){\n      scanf(\"%d\", &v);\n      nodes[t-1].ks[j] = v-1;\n    }\n  }\n\n  int m;\n  scanf(\"%d\", &m);\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\", &t, &u, &v);\n    int r;\n    if((r=dikstra(t-1, u-1,v)) != -1) printf(\"%d\\n\", r);\n    else puts(\"NA\");\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){\n\t\tttl = current = 0;\n\t}\n\n\tvoid copy(Packet t){\n\t\tttl = t.ttl;\n\t\tcurrent = t.current;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = t.checkTable[i];\n\t}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tif(memo[start][goal] != 0){\n\t\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(i);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.ttl > 0 && tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+1+memo[i][goal]);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+1+memo[i][goal];\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p;\n\t\t\t\t\t\tp.copy(tmp);\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,P[101],D[101],num,min,min_index,current,Distance[101][101];\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tDistance[i][k] = 1000000000;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tfor(int i = 1; i<= n; i++){\n\t\tfor(int k=1; k <= n; k++){\n\t\t\tif(i != k){\n\t\t\t\tstart = i, goal = k;\n\n\t\t\t\tfor(int index=1; index <= n; index++){\n\t\t\t\t\tP[index] = 0;\n\t\t\t\t\tD[index] = 1000000000;\n\t\t\t\t}\n\n\t\t\t\tP[start] = 1;\n\t\t\t\tnum = 1;\n\n\t\t\t\tfor(int index = 1; index <= n; index++){\n\t\t\t\t\tif(index != start && table[start][index] == 1){\n\t\t\t\t\t\tD[index] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile(num < n){\n\t\t\t\t\tmin = 1000000000;\n\t\t\t\t\tfor(int index=1;index <= n; index++){\n\t\t\t\t\t\tif(P[index] == 0 && D[index] < min){\n\t\t\t\t\t\t\tmin = D[index];\n\t\t\t\t\t\t\tmin_index =index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(min == 1000000000)break;\n\n\t\t\t\t\tP[min_index] = 1;\n\t\t\t\t\tcurrent = min_index;\n\t\t\t\t\tnum++;\n\t\t\t\t\tfor(int index=1; index <= n; index++){\n\t\t\t\t\t\tif(table[current][index] == 1){\n\t\t\t\t\t\t\tD[index] = (D[index] <= (D[current]+1))?D[index]:(D[current]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tDistance[start][goal] = D[goal];\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tif(Distance[start][goal] >= t_limit){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",Distance[start][goal]+1);\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){\n\t\tttl = current = 0;\n\t}\n\n\tvoid copy(Packet t){\n\t\tttl = t.ttl;\n\t\tcurrent = t.current;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = t.checkTable[i];\n\t}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tif(memo[start][goal] != 0){\n\t\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int d = 1; d <= n; d++){\n\t\t\t\tif(d != start && table[start][d] == 1){\n\t\t\t\t\tif(memo[d][goal] > 0 && memo[d][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[d][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[d][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(d);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp.copy(Q.front());\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.ttl > 0 && tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1 && t_limit-tmp.ttl + 1 <= n){\n\t\t\t\tfor(int m=1; m <= n; m++){\n\t\t\t\t\tif(m != tmp.current && tmp.checkTable[m] == 0 && table[tmp.current][m] == 1){\n\t\t\t\t\t\tif(memo[m][goal] > 0 && memo[m][goal] < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+1+memo[m][goal]);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+1+memo[m][goal];\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p;\n\t\t\t\t\t\tp.copy(tmp);\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(m);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[100][100];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<100;i++)\n\t\tfor(int j=0;j<100;j++)\n\t\t\tg[i][j]=1999999999;\n\tfor(int i=0;i<a;i++)\n\t\tg[i][i]=0;\n\tfor(int i=0;i<a;i++){\n\t\tint b,c;\n\t\tscanf(\"%d%d\",&b,&c);\n\t\tfor(int j=0;j<c;j++){\n\t\t\tint d;\n\t\t\tscanf(\"%d\",&d);\n\t\t\tg[b-1][d-1]=1;\n\t\t}\n\t}\n\tfor(int k=0;k<a;k++)\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\tscanf(\"%d\",&a);\n\twhile(a--){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tif(r<=g[p-1][q-1])printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",g[p-1][q-1]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct edge_t {\n    int from, to, cost;\n    edge_t(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    bool operator<(const edge_t &o) const {\n        return (cost < o.cost);\n    }\n    bool operator>(const edge_t &o) const {\n        return (cost > o.cost);\n    }\n};\nstruct state_t {\n    int v;\n    int min_cost;\n    state_t(int v, int min_cost) : v(v), min_cost(min_cost) {}\n    bool operator<(const state_t &o) const {\n        return (min_cost < o.min_cost);\n    }\n    bool operator>(const state_t &o) const {\n        return (min_cost > o.min_cost);\n    }\n};\ntypedef vector<edge_t> vertex_t;\nstruct graph_t {\n    vector<vertex_t> g;\n\n    graph_t() {}\n\n    graph_t(int vertex_count) {\n        g.resize(vertex_count);\n    }\n    graph_t(vector<vertex_t> g) : g(g) {}\n\n    inline vertex_t& operator[](int index) {\n        return g[index];\n    }\n\n    inline void push_back(vertex_t v) {\n        g.push_back(v);\n    }\n\n    void dijkstra(int s, vector<int> &min_cost) {\n        min_cost.resize(g.size());\n        priority_queue< state_t, vector<state_t>, greater<state_t> > q;\n        \n        fill(min_cost.begin(), min_cost.end(), INF);\n\n        min_cost[s] = 0;\n        q.push(state_t(s, 0));\n\n        while (!q.empty()) {\n            state_t p = q.top(); q.pop();\n            int v = p.v;\n            if (min_cost[v] < p.min_cost) continue;\n            for (int i = 0; i < g[v].size(); i++) {\n                edge_t e = g[v][i];\n                if (min_cost[e.to] > min_cost[v] + e.cost)  {\n                    min_cost[e.to] = min_cost[v] + e.cost;\n                    q.push(state_t(e.to, min_cost[e.to]));\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    graph_t graph(n+1);\n    for (int i = 1; i <= n; i++) {\n        int r; cin >> r;\n        int k; cin >> k;\n        for (int j = 0; j < k; j++) {\n            int t; cin >> t;\n            graph[r].push_back(edge_t(r, t, 1));\n        }\n    }\n\n    vector<int> min_cost;\n    int p; cin >> p;\n    for (int i = 0; i < p; i++) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        graph.dijkstra(s, min_cost);\n        if (min_cost[d] < v) {\n            cout << min_cost[d]+1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 100\n#define INF 100000\n\nint main(){\n  int n;\n  cin >> n;\n  int d[MAX][MAX];\n  for(int i = 0 ; i < n ; i++){\n    for(int j = 0 ; j < n ; j++){\n      d[i][j] = INF;\n    }\n  }\n  for(int i = 0 ; i < n ; i++){\n    int r,k,t;\n    cin >> r >> k; r--;\n    for(int j = 0 ; j < k ; j++){\n      cin >> t; t--;\n      d[r][t] = 1;\n    }\n  }\n  for(int k = 0 ; k < n ; k++){\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n        d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n  }\n  int p,s,t,v;\n  cin >> p;\n  for(int i = 0 ; i < p ; i++){\n    cin >> s >> t >> v; s--; t--;\n    if(d[s][t]+1 <= v){\n      cout << d[s][t]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nconst int SIZE = 101;\n\n\nclass Packet\n{\npublic:\n\tPacket( int _now, set< int > _via ) : now( _now ), via( _via ){}\n\tbool isPast( int p )\n\t{\n\t\tif( via.find( p ) != via.end() ){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint now;\n\tset< int > via;\n};\n\nint solve( int table[ SIZE ][ SIZE ], int s, int e, int initTtl, int numRooter )\n{\n\tif( initTtl < 2 ){\n\t\treturn 0;\n\t}\n\tvector< Packet > pList;\n\tfor( int i = 1; i <= numRooter; ++i ){\n\t\tset< int > via;\n\t\tvia.insert( s );\n\t\tif( table[ s ][ i ] ){\n\t\t\tif( i == e ){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tset< int > via2 = via;\n\t\t\tvia2.insert( i );\n\t\t\tpList.push_back( Packet( i, via2 ) );\n\t\t}\n\t}\n\n\tint ttl = initTtl;\n\twhile( pList.size() > 0 ){\n\t\t--ttl;\n\t\tif( ttl < 1 ){\n\t\t\treturn 0;\n\t\t}\n\t\tvector< Packet > pList2;\n\t\tfor( int i = 0; i < pList.size(); ++i ){\n\t\t\tPacket& p = pList[ i ];\n\t\t\tif( p.now == e ){\n\t\t\t\treturn p.via.size();\n\t\t\t}\n\t\t\tfor( int j = 1; j <= numRooter; ++j ){\n\t\t\t\tif( table[ p.now ][ j ] && !p.isPast( j ) ){\n\t\t\t\t\tset< int > via = p.via;\n\t\t\t\t\tvia.insert( j );\n\t\t\t\t\tpList2.push_back( Packet( j, via ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpList = pList2;\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tint table[ SIZE ][ SIZE ];\n\n\tint n;\n\twhile( cin >> n ){\n\t\tcin.ignore( 100, '\\n' );\n\t\tmemset( table, 0, sizeof(table) );\n\t\tstring s;\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tgetline( cin, s );\n\t\t\tint o = s[ 0 ] - '0';\n\t\t\tfor( int j = 2; j < s.size(); j += 2 ){\n\t\t\t\ttable[ o ][ s[ j ] - '0' ] = true;\n\t\t\t}\n\t\t}\n\t\tint p;\n\t\tcin >> p;\n\t\tfor( int i = 0; i < p; ++i ){\n\t\t\tint from, to, ttl;\n\t\t\tcin >> from >> to >> ttl;\n\t\t\tint result = solve( table, from, to, ttl, n );\n\t\t\tif( result > 0 ){\n\t\t\t\tcout << result << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[101];\nint s,d,v;\nint s2,d2;\nint kk,n;\nbool flg[102] ;\n\n\nvoid visit(int sn,int dis) {\n  //  for(int i=1;i<=n;i++)cout << flg[i];\n  // cout <<\" \";\n  \n  if(sn == d-1 && dis <=v)  md = min(md,dis);\n  else if(dis < v && dis < md) {\n    for(int i=0;i<ro[sn].size();i++) {\n      if(flg[ro[sn][i]] == 0){\n\t//\tcout <<sn+1 << \"to\"<<ro[sn][i] << endl;\n\tflg[ro[sn][i]] = 1;\n\tvisit(ro[sn][i]-1,dis+1);\n\tflg[ro[sn][i]] = 0;\n      }\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk;\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[kk-1][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n    \n    for(int j=0;j<=n;j++) flg[j] = 0;\n    md = 10000000;\n    flg[s]  = 1;   \n    visit(s-1,1);\n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint net[103][103],n,maxx=0;\ntypedef pair<int,int> BVB;\nint ans(int,int,int);\n\nint main(){\n  int num,n1,th,pkn,st,ed,c;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){ \n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n    for(int j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }\n  \n  for(int m=0;m<maxx;m++)for(int n=0;n<maxx;n++)if(net[m][n]!=1)net[m][n]=0;\n\n  cin >> pkn;\n\n  for(int i=0;i<pkn;i++){\n    cin >> st >> ed >> c;\n\n\n    if(ans(st,ed,c) != -2)cout << ans(st,ed,c) << endl;\n    else cout << \"NA\" << endl;\n\n  }\n\n}\n\n\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int yes=10001;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n   \n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; \n    \n    for(int i=1;i<=maxx;i++){\n      \n      if(net[next.first][i] == 1 && i == ed ){\n\n\tif(yes >  (c-next.second+1))yes = (c - next.second)+1;\n\t\n\t\n      }\n            \n      if(net[next.first][i] == 1){\n\tNari.push(BVB(i,next.second));\n\n      }\n      \n    }\n       \n  }\n  if(yes != 10001){return yes;}\n  else return -2; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,b;\n  int ans=0;\n  int box[111][111];\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      box[i][j]=INT_MAX;\n    }\n  }\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      box[r-1][t-1]=1;\n    }\n  }\n  for(int z=0;z<n;z++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tbox[i][j]=min(box[i][j],box[i][z]+box[z][j]);\n      }\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> b;\n    ans=box[s-1][d-1]+1;\n    if(ans<=b){\n      cout << box[s-1][d-1]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n    //making graph\n    cin >> n;\n    \n    int data[n+1][n+1];\n    \n    for(int i = 0; i <= n; i++){\n      for(int j = 0; j <= n; j++){\n\tdata[i][j] = 0;\n      }\n    }\n    \n    int from, to, conesum;\n\n    for(int i = 0; i < n; i++){\n      cin >> from >> conesum;\n      for(int j = 0; j < conesum; j++){\n\tcin >> to;\n\tdata[from][to] = 1;\n      }\n    }\n    //making graph end\n\n    //judge\n\n    int sumpake;\n    cin >> sumpake;\n\n    queue<int> Q;\n\n    int ttl, myposi, min, sumin, sumina, finish = 0;\n\n    for(int i = 0; i < sumpake; i++){\n      min = 0;\n      cin >> from >> to >> ttl;\n      myposi = from;\n      for(int j = 0; j < ttl; j++){\n\tif(j != 0){\n\t  for(int l = 0; l < sumina; l++){\n\t    //cout << \"sumina \" << sumina << endl;\n\t    if(Q.front() == to){\n\t      min = j;\n\t      finish = 1;\n\t      //cout << \"much\" << endl;\n\t      break;\n\t    }\n\t    myposi = Q.front();\n\t    //cout << \"pop  \" << Q.front()<<endl;\n\t    Q.pop();\n\t    for(int k = 1; k <= n; k++){\n\t      if(data[myposi][k] == 1) {\n\t\tQ.push(k);\n\t\tsumin++;\n\t      }\n\t    }\n\t    \n\t  }\n\t  if(finish == 1) break;\n\t}else{\n\t  sumin = 0;\n\t  for(int k = 1; k <= n; k++){\n\t    if(data[myposi][k] == 1) {\n\t      Q.push(k);\n\t      sumin++;\n\t    }\n\t  }\n\t  \n\t}\n\t//\tfor(int k = 1; k <= n; k++){\n\t//\t    if(data[myposi][k] == 1) {\n\t//\t      Q.push(k);\n\t//\t      sumin++;\n\t//\t    }\n\t//\t}\n\t  sumina = sumin;\n\t  sumin = 0;\n      }\n\n      \n      if(min == 0) cout << \"NA\";\n      else cout << min+1;\n      cout << endl;\n      finish = 0;\n      while(!Q.empty()) Q.pop();\n    }\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n#define INFTY 10000000\n\nint n,u,k;\nint s,d,v,TTL;\nint M[101][101],D[101];\n\nvoid bfs( int s ){\n  \n  queue <int> Q;\n  for( int i = 1; i <= n; i++ ) D[i] = INFTY;\n\n  D[s] = 1;\n  Q.push(s);\n     \n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    for( int l = 1; l <= n; l++ ){\n      if( M[u][l] == 0 ) continue;\n      if( D[l] != INFTY ) continue;\n      D[l] = D[u] + 1;\n      // cout << \"l\" << \" \" << l << \" \" <<  \"D[l]\" << \" \" << D[l] << \" \" <<\n      // \t\"D[u]\" << \" \" << D[u] << endl;\n      Q.push(l);\n\n      if ( D[l] > TTL ){\n\tcout << \"NA\" << endl;\n\treturn;\n      }else if( l == d ){\n\tcout << D[l] << endl;\n\t//\tcout << \"TTL\" << \" \" << TTL << endl;\n\treturn;\n      }\n\n    }\n\n  }\n \n}\n\nint main(){\n  cin >> n;\n  for( int i = 1; i <= n; i++ ){\n    cin >> u;\n    cin >> k;\n    for( int j = 0; j < k; j++ ){\n      int v;\n      cin >> v;\n      M[u][v] = 1;\n    }\n  }\n    \n  int p; cin >> p; \n  for( int i = 0; i < p; i++ ){\n  cin >> s >> d >> TTL;\n  bfs(s);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(100001);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    vector<bool> check(100001, false);\n    queue<int> fq, nq, sq;\n    int cnt = 0;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            if (check[pos]) {\n                continue;\n            } else {\n                check[pos] = true;\n            }\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            }\n            for (int i: g[pos]) {\n                nq.push(i);\n            }\n        }\n        if (c == 0 || nq.empty()) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n        //cout << c << \"====\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconst int INF=1e9;\nusing namespace std;\nint main(){\n  int d[100][100],n,p;\n  cin>>n;\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=INF;\n  for(int i=0,r,k,t;i<n&&cin>>r>>k;i++) for(int j=0;j<k&&cin>>t;j++) d[r-1][t-1]=1;\n  for(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j]++;\n  cin>>p;\n  for(int i=0,s,t,v;i<p;i++){\n    cin>>s>>t>>v;\n    if(d[s-1][t-1]>v) cout<<\"NA\"<<endl;\n    else cout<<d[s-1][t-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\t\tp.set(i);\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && (memo[i][goal]+1) < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+2);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)break;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#define MAX_N 110\nbool A[MAX_N][MAX_N];\nint rooter_num;\nusing namespace std;\nint bfs(int,int);\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  int a;\n  memset(A,false,sizeof(A));\n  cin>>rooter_num;\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r][t]=true;\n\t}\n    }\n  cin>>n;\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      a=bfs(startNode,goalNode);\n      //    cout<<\"TTL=\"<<TTL<<\";\"<<\"a-1=\"<<a<<endl;\n      if(a-1<TTL)cout<<a<<endl;\n      else cout<<\"NA\"<<endl;\n       \n    }\n  return 0;\n}\nint bfs(int startNode,int goalNode)\n{\n  queue<int>Q;\n  int visited[rooter_num+1];\n  memset(visited,0,sizeof(visited));\n  int currentNode=startNode;\n  \n  Q.push(currentNode);\n  visited[currentNode]=1;\n  \n  while(!Q.empty())\n    {\n\n      \n      currentNode=Q.front();\n      Q.pop();\n      for(int nextNode=1;nextNode<=rooter_num;nextNode++)\n\t{\n\n\t  if(A[currentNode][nextNode]==0)continue;\n\n\t  if(nextNode==goalNode)return visited[currentNode]+1;\n\t  \n\t  if(visited[nextNode]==0)\n\t    {\n\t      visited[nextNode]=visited[currentNode]+1;\n\t      Q.push(nextNode);\n\t    }\n\t}\n    }\n  return MAX_N;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n\tint d[101][101];\n\tfor(int i=1;i<=100;i++)for(int j=1;j<=100;j++)d[i][j]=10000000;\n\tint n;\n\t\tint a,b,c;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>c;\n\t\tfor(cin>>a;a>0;a--){\n\t\t\tcin>>b;\n\t\t\td[c][b]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(d[i][j]<1000)cout<<d[i][j]<<\" \";\n\t\t\telse cout<<\"+ \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n\t*/\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(j!=k)if(d[j][k]>d[j][i]+d[i][k])d[j][k]=d[j][i]+d[i][k];\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\t\n\t\t\tif(d[i][j]<1000)cout<<d[i][j]<<\" \";\n\t\t\telse cout<<\"+ \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n\t*/\n\tfor(cin>>n;n>0;n--){\n\t\tcin>>a>>b>>c;\n\t\tif(d[a][b]<c)cout<<d[a][b]+1<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//59\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  vector<int> e[101];\n  for(int i=0;i<n;i++){\n    int r,k;\n    cin>>r>>k;\n    while(k--){\n      int t;\n      cin>>t;\n      e[r].push_back(t);\n    }\n  }\n  int p;\n  cin>>p;\n  while(p--){\n    int s,d,v;\n    cin>>s>>d>>v;\n    queue<pair<int,int> > que;\n    que.push(make_pair(1,s));\n    bool p[101]={};\n    while(!que.empty()){\n      int c=que.front().second;\n      if(c==d||que.front().first>v)break;\n      if(!p[c]){\n\tfor(int i=0;i<e[c].size();i++){\n\t  que.push(make_pair(que.front().first+1,e[c][i]));\n\t}\n      }\n      p[c]=true;\n      que.pop();\n    }\n    if(que.empty()||que.front().first>v){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().first<<endl;\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX 10000000\nusing namespace std;\n\nint main(){\n  int n,m;\n  int go[101][101];\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++) go[i][j] = MAX;\n  }\n  cin >> n;\n  for(int i=0;i<n;i++){\n    int r,k,tmp;\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> tmp;\n      go[r][tmp] = 1;\n    }\n  }\n  cin >> m;\n  while(m--){\n    int s,d,ttl;\n    cin >> s >> d >> ttl;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  go[j][k] = min(go[j][k],go[j][i] + go[i][k]);\n\t}\n      }\n    }\n    if(go[s][d]+1 > ttl) cout << \"NA\" << endl;\n    else cout << go[s][d]+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[101];\nint s,d,v;\nint s2,d2;\nint kk[100],n;\nbool flg[102] ;\n\nvoid visit(int sn,int dis) {\n  int x;\n\n  //  for(int i=1;i<=n;i++)cout << flg[i];\n  // cout <<\" \";\n  \n  flg[sn+1] = 1;\n  \n  if(sn == d-1 && dis <=v)  md = min(md,dis);\n\n  else if(dis <= v && dis < md) {\n    for(int i=0;i<ro[sn].size();i++) {\n      \n      if(flg[ro[sn][i]] == 0){\n\t//\tcout <<sn+1 << \"to\"<<ro[sn][i] << endl;\n\tvisit(ro[sn][i]-1,dis+1);\n\tflg[ro[sn][i]] = 0;\n      }\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk[i];\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[i][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n\n\n    for(int i=0;i<=n;i++) flg[i] = 0;\n    md = 10000000;\n   \n    visit(s-1,1);\n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\n\nvector<int> G[MAX_N];\n\nvoid init(){\n\tfor(int i=0 ; i < MAX_N ; i++ ) G[i].clear();\n}\n\nvoid add_edge(int u, int v ){\n\tG[u].push_back( v );\n}\n\nint solve(int s, int g, int t){\n\tbool memo[MAX_N];\n\tfor(int i=0 ; i < MAX_N ; i++ ) memo[i] = false;\n\tqueue<P> q;\n\tq.push( P(0,s) );\n\t\n\twhile( !q.empty() ){\n\t\tint cnt = q.front().first;\n\t\tint v = q.front().second;\n\t\tq.pop();\n\t\tmemo[v] = true;\n\t\t\n\t\tif( v == g ){\n\t\t\treturn cnt+1;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\t\tint to = G[v][i];\n\t\t\tif( cnt+1 < t && !memo[to] ){\n\t\t\t\tq.push( P(cnt+1,to) );\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint u, k;\n\t\t\tcin >> u >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tadd_edge( u , v );\n\t\t\t}\n\t\t}\n\t\tint p;\n\t\tcin >> p;\n\t\tfor(int j=0 ; j < p ; j++ ){\n\t\t\tint s, g, t;\n\t\t\tcin >> s >> g >> t;\n\t\t\tint ans = solve( s , g , t );\n\t\t\tif( ans == INF )\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\telse\n\t\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_NODE = 100;\n\nvector<int> makeInput(string input){\n    vector<int> ret;\n    stringstream ss(input);\n\n    while(ss >>input) ret.push_back(atoi(input.c_str()));\n    return ret;\n}\n\nint main(){\n    int n;\n    while(cin >>n && n){\n        int d[MAX_NODE][MAX_NODE];\n        REP(i, MAX_NODE) REP(j, MAX_NODE) d[i][j] = INF;\n        REP(i, MAX_NODE) d[i][i] = 0;\n        vector< vector<int> > graph(MAX_NODE, vector<int>(MAX_NODE));\n        string dust_str;\n        getline(cin, dust_str);\n        //make graph\n        REP(i, n){\n            string input;\n            getline(cin, input);\n            vector<int> sum_list = makeInput(input);\n\n            //make\n            REP(j, sum_list[1]){\n                graph[sum_list[0]].push_back(sum_list[j + 2]);\n                d[sum_list[0]][sum_list[j + 2]] = 1;\n            }\n        }\n\n        //ワーシャルフロイド\n        int v = n + 1;\n        REP(k, v){\n            REP(i, v){\n                REP(j, v){\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        //cal ans\n        int m;\n        cin >>m;\n        getline(cin, dust_str);\n        REP(i, m){\n            string input;\n            getline(cin, input);\n            vector<int> sum_list = makeInput(input);\n            int from = sum_list[0], to = sum_list[1], ttl = sum_list[2];\n            if(ttl < (d[from][to] + 1)) cout <<\"NA\" <<endl;\n            else cout <<d[from][to] + 1 <<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tint n, p;\n\tbool route[101][101];\n\t\n\tfor(int i=0; i<=100; ++i)\n\tfor(int j=0; j<=100; ++j)\n\troute[i][j]=false;\n\t\n\tscanf(\" %d\", &n);\n\tfor(int i=0; i<n; ++i){\n\t\tint r, k;\n\t\tscanf(\" %d %d\", &r, &k);\n\t\tfor(int j=0; j<k; ++j){\n\t\t\tint t;\n\t\t\tscanf(\" %d\", &t);\n\t\t\troute[r][t]=true;\n\t\t}\n\t}\n\t\n\tscanf(\" %d\", &p);\n\tfor(int i=0; i<p; ++i){\n\t\tint cost[101];\n\t\tfor(int j=0; j<=100; ++j) cost[j]=1000;\n\t\t\n\t\tint s, d, v;\n\t\tscanf(\" %d %d %d\", &s, &d, &v);\n\t\t\n\t\t//bfs\n\t\tqueue<int> que;\n\t\tcost[s]=1;\n\t\tque.push(s);\n\t\twhile( !que.empty() ){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\tif(route[v][j] && cost[j] > cost[v]+1){\n\t\t\t\t\tcost[j]=cost[v]+1;\n\t\t\t\t\tque.push(j);\t\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tif(cost[d] <= v) printf(\"%d\\n\", cost[d]);\n\t\telse printf(\"NA\\n\");\n\t}\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\n\nint V,n,r,k,t,p,s,d,v,D[1001];\nvector<edge> g[1001];\n\nint main(){\n\twhile(cin>>n&&n){\n\t\trep(i,n)g[i].clear();\n\t\trep(i,n){\n\t\t\tcin>>r>>k;\n\t\t\trep(j,k){\n\t\t\t\tedge e;\n\t\t\t\tcin>>t;\n\t\t\t\te.to=t;\n\t\t\t\te.cost=1;\n\t\t\t\tg[r].push_back(e);\n\t\t\t}\n\t\t}\n\t\tcin>>p;\n\t\trep(h,p){\n\t\t\tcin>>s>>d>>v;\n\t\t\tpriority_queue<P,vector<P>,greater<P> > q;\n\t\t\tfill(D,D+n+1,INF);\n\t\t\tD[s]=0;\n\t\t\tq.push(P(0,s));\n\t\t\twhile(!q.empty()){\n\t\t\t\tP pp=q.top();q.pop();\n\t\t\t\tint vv=pp.second;\n\t\t\t\tif(D[vv]<pp.first)continue;\n\t\t\t\trep(j,g[vv].size()){\n\t\t\t\t\tedge e=g[vv][j];\n\t\t\t\t\tif(D[e.to]>D[vv]+e.cost){\n\t\t\t\t\t\tD[e.to]=D[vv]+e.cost;\n\t\t\t\t\t\tq.push(P(D[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(D[d]<v)cout<<D[d]+1<<endl;\n\t\t\telse cout<<\"NA\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n  int *ks;\n  int length;\n} node;\n\nnode *nodes;\n\nint dikstra(int s, int e, int deep){\n  int c=0;\n  queue<int> stk;\n  stk.push(s);\n\n  while(1){\n    c++;\n    if(c >= deep) return -1;\n    int len = stk.size();\n    for(int i=0;i<len;i++){\n\n      int v = stk.front();\n      stk.pop();\n\n      for(int j=0;j<nodes[v].length;j++){\n        if(nodes[v].ks[j]==e) return c+1;\n        stk.push(nodes[v].ks[j]);\n      }\n    }\n  }\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  nodes = new node[n];\n\n  int i,j;\n  int t,u,v;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\", &t,&u);\n    nodes[t-1].ks = new int[u];\n    nodes[t-1].length = u;\n    for(j=0;j<u;j++){\n      scanf(\"%d\", &v);\n      nodes[t-1].ks[j] = v-1;\n    }\n  }\n\n  int m;\n  scanf(\"%d\", &m);\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\", &t, &u, &v);\n    int r;\n    if((r=dikstra(t-1, u-1,v)) != -1) printf(\"%d\\n\", r);\n    else puts(\"NA\");\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nconst int INF = (1<<21);\n\nclass state{\npublic:\n  int d,n;\n  state(int d=0,int n=0):d(d),n(n){}\n};\n\nint main(){\n  int n;\n  while(cin >> n){\n    bool d[100][100];\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) d[i][j] = false;\n    for(int i=0;i<n;i++){\n      int a,b;\n      cin >> a >> b;\n      a--;\n      for(int j=0;j<b;j++){\n\tint c;\n\tcin >> c;\n\tc--;\n\td[a][c] = true;\n      }\n    }\n\n    int m;\n    cin >> m;\n    while(m--){\n      int a,b,c;\n      queue<state> Q;\n      bool f[100];\n      for(int i=0;i<n;i++) f[i] = false;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n\n      state u(a,1);\n      int ans = INF;\n      Q.push(u);\n\n      while(!Q.empty()){\n\tu = Q.front();\n\tQ.pop();\n\tf[u.d] = true;\n\n\tif(u.d == b){\n\t  if(u.n <= c) ans = u.n;\n\t  break;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t  if(!f[i] && d[u.d][i]){\n\t    state v = u;\n\t    v.d = i;\n\t    v.n++;\n\t    Q.push(v);\n\t  }\n\t}\n      }\n\n      if(ans == INF) cout << \"NA\" << endl;\n      else cout << ans << endl;\n\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep0(i,n) for(i=0;i<(n);i++)\n#define repp(i,m,n) for(int i=(m);i<(n);i++)\n\n#define PUTLINE cout<<__LINE__<<endl;\n\nvector<int> edges[110];\nint dis[110];\n\nint main() {\n\tint n;\n\tcin>>n;\n\tint r,k;\n\trep(i,n){\n\t\tcin>>r>>k;\n\t\twhile(k--){\n\t\t\tedges[r-1].push_back(in()-1);\n\t\t}\n\t}\n\tint p;\n\tcin>>p;\n\trep(i,p){\n\t\tint s,d,v;\n\t\tcin>>s>>d>>v;\n\t\ts--;d--;\n\t\trep(j,n)dis[j]=100100100;\n\t\tpriority_queue<pint,vector<pint>,greater<pint> > que;\n\t\tque.push(mp(0,s));\n\t\twhile(!que.empty()){\n\t\t\tpint v=que.top();\n\t\t\tque.pop();\n\t\t\tif(dis[v.second]<=v.first)continue;\n\t\t\tdis[v.second]=v.first;\n\t\t\trep(j,edges[v.second].size()){\n\t\t\t\tque.push(mp(v.first+1,edges[v.second][j]));\n\t\t\t}\n\t\t}\n\t\tif(dis[d]>=v)cout<<\"NA\"<<endl;\n\t\telse cout<<dis[d]+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n,INF=1<<28;\n  cin >> n;\n  int d[n+1][n+1];\n  fill(d[0],d[n+1],INF);\n  for(int i=1; i<=n; i++) d[i][i]=0;\n  for(int i=0; i<n; i++) {\n    int x,m;\n    cin >> x >> m;\n    for(int j=0; j<m; j++) {\n      int y;\n      cin >> y;\n      d[x][y]=1;\n    }\n  }\n  for(int k=1; k<=n; k++) {\n    for(int i=1; i<=n; i++) {\n      for(int j=1; j<=n; j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    }\n  }\n  int q;\n  cin >> q;\n  while(q--) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    if(d[x][y]+1<=z) cout << d[x][y]+1 << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\n#define MAX 100000\n\nint main(){\n  int n;\n  int dist[100][100];\n  scanf(\"%d\",&n);\n  REP(i,n){\n    int k, m;\n    scanf(\"%d%d\",&k,&m);\n    REP(j,n) dist[k-1][j] = MAX;\n    dist[k-1][k-1] = 0;\n    REP(j,m){\n      int d;\n      scanf(\"%d\",&d);\n      dist[k-1][d-1] = 1;\n    }\n  }\n\n  REP(k,n) REP(i,n) REP(j,n)\n    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n  int m;\n  scanf(\"%d\",&m);\n  REP(i,m){\n    int a, b, c;\n    scanf(\"%d%d%d\",&a,&b,&c);\n    if(dist[a-1][b-1] == MAX || dist[a-1][b-1] + 1 > c)\n      puts(\"NA\");\n    else\n      printf(\"%d\\n\",dist[a-1][b-1]+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n  int *ks;\n  int length;\n} node;\n\nnode *nodes;\n\nint dikstra(int s, int e){\n  int c=0;\n  queue<int> stk;\n  stk.push(s);\n\n  while(1){\n    c++;\n    int len = stk.size();\n    for(int i=0;i<len;i++){\n\n      int v = stk.front();\n      stk.pop();\n\n      for(int j=0;j<nodes[v].length;j++){\n        if(nodes[v].ks[j]==e) return c+1;\n        stk.push(nodes[v].ks[j]);\n      }\n    }\n  }\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  nodes = new node[n];\n\n  int i,j;\n  int t,u,v;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\", &t,&u);\n    nodes[t-1].ks = new int[u];\n    nodes[t-1].length = u;\n    for(j=0;j<u;j++){\n      scanf(\"%d\", &v);\n      nodes[t-1].ks[j] = v-1;\n    }\n  }\n\n  int m;\n  scanf(\"%d\", &m);\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\", &t, &u, &v);\n    int r;\n    if(v >= (r=dikstra(t-1, u-1))) printf(\"%d\\n\", r);\n    else puts(\"NA\");\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\n/* main??? */\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\n/* ???????????¢??° */\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\n/* ??????????????\\?¶??????±??\\?????¢??° */\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++){\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ???????????±???????????±??\\?????¢??° */\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcSumRouter(i4StartRouter,i4GoalRouter,i4TTL);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ??????????????????????¨????????????°?¨??????¢??° */\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\t/* ?????°??£?¨? */\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\t/* ????????¨ */\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\tI4 i4RoopMax;\n\t\n\t/* ????????? */\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\tif(i4TTL<=i4RouterNum){\n\t\ti4RoopMax = i4TTL;\n\t}\n\telse{\n\t\ti4RoopMax == i4RouterNum;\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<i4RoopMax; i4RoopCnt1++){\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=i4RouterNum; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint n,i,j,k,a,b,c,cost[101][101];\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>a>>b;\n\t\tfor(j=1;j<=n;j++) cost[a][j] = 1<<15;\n\t\tfor(j=0;j<b;j++){\n\t\t\tcin >> c;\n\t\t\tcost[a][c]=1;\n\t\t}\n\t}\n\tfor(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++)\n\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b>>c;\n\t\tif(cost[a][b]<c && cost[a][b]<(1<<15)) cout << cost[a][b]+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> d(n, vector<int>(n, INF));\n    for(int i=0; i<n; ++i) {\n        d[i][i] = 0;\n\n        int r, k;\n        cin >> r >> k;\n        for(int j=0; j<k; ++j) {\n            int t;\n            cin >> t;\n            d[r-1][t-1] = 1;\n        }\n    }\n    for(int k=0; k<n; ++k) {\n        for(int i=0; i<n; ++i) {\n            for(int j=0; j<n; ++j) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n    int p;\n    cin >> p;\n    for(int i=0; i<p; ++i) {\n        int s, g, v;\n        cin >> s >> g >> v;\n        if(d[s-1][g-1] + 1 <= v) {\n            cout << d[s-1][g-1] + 1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(101);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    vector<bool> check(101, false);\n    queue<int> fq, nq, sq;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            if (check[pos]) {\n                continue;\n            } else {\n                check[pos] = true;\n            }\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            } else {\n                for (int i: g[pos]) {\n                    nq.push(i);\n                }\n            }\n        }\n        if (c == 0 || nq.empty()) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint node[200][200];\nint main()\n{\n  int n;\n  cin>>n;\n  memset(node,-1,sizeof(node));\n  for(int x=0;x<n;x++)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(int x=0;x<p;x++)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      int ans=-1;\n      \n      queue<P> qu;\n      int c[200];\n      memset(c,-1,sizeof(c));\n      for(int i=0;i<200;i++)\n\t{\n\t  if(v-1>0)\n\t    if(node[s][i]==1)\n\t      qu.push(P(i,2));\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  //      cout<<a.first<<\" \"<<a.second<<endl;\n\t  if(a.first==d)\n\t    {\n\t      ans=a.second;\n\t      break;\n\t    }\n\t  for(int i=0;i<200;i++)\n\t    {\n\t      if(node[a.first][i]==1)\n\t\t{\n\t\t  if(a.second+1<=v)\n\t\t    {\n\t\t      if(c[i]==-1)\n\t\t\t{\n\t\t\t  c[i]=1;\n\t\t\t  qu.push(P(i,a.second+1));\t    \n\t\t\t}\n\t\t    }\n\t\t}\n\t    } \n\t}\n      \n      \n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n      \n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint md = 10000000;\nvector <int> ro[101];\nint s,d,v;\nint s2,d2;\nint kk[101],n;\nbool flg[102] ;\nint dmap[102][102];\n\nvoid reset() {\n\n  for(int i=0;i<=n;i++) {\n    for(int j=0;j<=n;j++) {\n\tdmap[i][j] = 10000000;\n    }\n  }\n}\n\nvoid visit(int sn,int dis) {\n  int x;\n\n  //  for(int i=1;i<=n;i++)cout << flg[i];\n  // cout <<\" \";\n  \n  flg[sn+1] = 1;\n  \n  if(sn == d && dis <=100)  dmap[s][d] = min(dmap[s][d],dis);\n\n  else if(dis <= 100 && dis < dmap[s][d]) {\n    for(int i=0;i<ro[sn].size();i++) {\n      \n      if(flg[ro[sn][i]] == 0){\n\t//\tcout <<sn+1 << \"to\"<<ro[sn][i] << endl;\n\tvisit(ro[sn][i]-1,dis+1);\n\tflg[ro[sn][i]] = 0;\n      }\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n  int a;\n    \n  for(int i=0;i<n;i++) {\n    cin >> kk[i];\n    cin >> a;\n    ro[i].resize(a);\n    for(int j=0;j<a;j++) cin >> ro[kk[i]-1][j];\n  }\n\n  reset();\n  for(int k=0;k<=n;k++) flg[k] = 0;\n  for(int i=0;i<n;i++) {\n    for(int j=0;j<n;j++) {\n      \n      d = j;\n      s = i;\n      if(i != j) visit(i,1);\n    }\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n\n    if(dmap[s-1][d-1] <= v) \n      cout << dmap[s-1][d-1] << endl;\n    else cout << \"NA\" << endl;\n  \n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcDijikstra(i4StartRouter,i4GoalRouter,i4TTL);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcDijikstra(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++){\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<MAX_ROUTER; i4RoopCnt1++){\n\t\tif(i4TTL <= i4RoopCnt1){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\t;\n\t\t}\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=MAX_ROUTER; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int n,a,b,c,d,k,DATA[101][101];\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      DATA[i][j]=1000000;\n    }\n  }\n\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> a >> k;\n    for(int j=0;j<k;j++){\n      cin >> b;\n      DATA[a][b]=1;\n    }\n  }\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=n;j++){\n      for(k=1;k<=n;k++){\n\tif(DATA[j][k]>DATA[j][i]+DATA[i][k]){\n\t  DATA[j][k] = DATA[j][i]+DATA[i][k];\n\t}\n      }\n    }\n  }\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> a >> b >> c;\n    if(DATA[a][b]>=c) cout << \"NA\" << endl;\n    else cout << DATA[a][b]+1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint main() {\n\tint n, p, r, k, t, s, d, v;\n\tcin >> n;\n\tint m[100][100] = {};\n\trep(i,n) {\n\t\tcin >> r >> k;\n\t\trep(j,k) {\n\t\t\tcin >> t;\n\t\t\tm[r-1][t-1] = 1;\n\t\t}\n\t}\n\tint ret[100][100] = {};\n\trep(i,100) {\n\t\tret[i][i] = 1;\n\t}\n\trep(i,n) {\n\t\tqueue<int> q;\n\t\tq.push(i);\n\t\twhile(!q.empty()) {\n\t\t\tint a = q.front(); q.pop();\n\t\t\trep(j,n) {\n\t\t\t\tif(m[a][j] && ret[i][j]==0) {\n\t\t\t\t\tq.push(j);\n\t\t\t\t\tret[i][j] = ret[i][a]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcin >> p;\n\trep(i,p) {\n\t\tcin >> s >> d >> v;\n\t\t--s,--d;\n\t\tif(ret[s][d] > v) cout<< \"NA\" << endl;\n\t\telse cout << ret[s][d] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint CntData[101][101];\nconst int INF = 1000000;\n\nvoid Init() {\n\tfor (int i = 1; i < 101; i++) {\n\t\tfor (int j = 1; j < 101; j++) {\n\t\t\tCntData[i][j] = INF;\n\t\t}\n\t}\n}\n\nvoid solve(int n) {\n\tfor (int k = 1; k < n; k++) {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tCntData[i][j] = min(CntData[i][j], CntData[i][k] + CntData[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, p, r, k, t;\n\n\tInit();\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> r >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tcin >> t;\n\t\t\tCntData[r][t] = 1;\n\t\t}\n\t}\n\tsolve(n+1);\n\t\n\tcin >> p;\n\twhile (p--) {\n\t\tcin >> r >> k >> t;\n\t\tif (t > CntData[r][k]) {\n\t\t\tcout << CntData[r][k]+1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcRouterSum(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum);\n\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\treturn 0;\n}\n\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER)\n\t{\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL)\n\t{\n\t\t//printf(\"start:%d,goal:%d,TTL:%d\\n\",i4StartRouter,i4GoalRouter,i4TTL);\n\t\ti4Ans = CalcRouterSum(i4StartRouter,i4GoalRouter,i4TTL,1);\n\t\tif(i4Ans >= i4TTL+1){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\t//printf(\"--------------\\n\");\n\t}\n\telse\n\t{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\nI4 CalcRouterSum(I4 i4Sender,I4 i4Destination,I4 i4TTL,I4 i4RouterSum)\n{\n\t//printf(\"%d -> %d,TTL=%d\\n\",i4Sender,i4Destination,i4TTL);\n\tI4 i4RoopCnt1;\n\tI4 i4MinRouterNum;\n\tI4 i4TmpRouterSum;\n\tI4 i4Return;\n\t\n\t\n\ti4Return = i4TTL+i4RouterSum;\n\t\n\tif(i4Sender == i4Destination)\n\t{\n\t\t//printf(\"RouterSum=%d\\n\",i4RouterSum);\n\t\treturn i4RouterSum;\n\t}\n\telse\n\t{\n\t\tif(i4TTL <= 0)\n\t\t{\n\t\t\tprintf(\"TTL is 0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti4RoopCnt1 = 1;\n\t\t\twhile(u1Connect[i4Sender][i4RoopCnt1] != SENTINEL){\n\t\t\t\tif(u1Connect[i4Sender][i4RoopCnt1] == CONNECT)\n\t\t\t\t{\n\t\t\t\t\ti4TmpRouterSum = CalcRouterSum(i4RoopCnt1,i4Destination,i4TTL-1,i4RouterSum+1);\n\t\t\t\t\tif((i4TmpRouterSum > 0 ) && (i4TmpRouterSum < i4Return))\n\t\t\t\t\t{\n\t\t\t\t\t\t//printf(\"CalcRouterSum()=%d\\n\",i4TmpRouterSum);\n\t\t\t\t\t\ti4Return = i4TmpRouterSum;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\ti4RoopCnt1++;\n\t\t\t}\n\t\t\treturn i4Return;\n\t\t}\n\t}\n\treturn i4Return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Class ------ //\nclass Graph1 {\npublic:\n\t// ------ Variables ------ //\n\tstatic const int INF = 1000000000;\n\tint V; vector<vector<int> > G;\n\n\t// ------ Constructors ------ //\n\tGraph1() : V(0), G(vector<vector<int> >()) {}\n\tGraph1(int v) : V(v), G(vector<vector<int> >(v)) {}\n\tGraph1(vector<vector<int> > g) : V(g.size()), G(g) {}\n\n\t// ------ Basic Functions ------ //\n\tvoid add1(int v1, int v2) { G[v1].push_back(v2); }\n\tvoid add2(int v1, int v2) { add1(v1, v2); add1(v2, v1); }\n\n\t// ------ Algorithms ------ //\n\tvector<int> dist(int s) {\n\t\tqueue<int> que; que.push(s);\n\t\tvector<int> d(V, INF); d[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tif (d[G[u][i]] == INF) {\n\t\t\t\t\td[G[u][i]] = d[u] + 1;\n\t\t\t\t\tque.push(G[u][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n};\nint N, Q, c, u, v; Graph1 G;\nint main() {\n\tcin >> N; G = Graph1(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> u >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> v; G.add1(u - 1, v - 1);\n\t\t}\n\t}\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> u >> v >> c;\n\t\tint d = G.dist(u - 1)[v - 1] + 1;\n\t\tif (d > c) cout << \"NA\" << endl;\n\t\telse cout << d << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i <= n; i++){\n\t\tfor(int k=1; k <= n; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\n\n\n\t\twhile(!Q.empty() && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1 && t_limit-tmp.ttl + 1 <= n){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && (memo[i][goal]+1) < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+2);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#define INF 999999\nusing namespace std;\nint n, p;\nint r, k;\nint t;\nint s, d, v, cost[110][110];\nvoid warshall_floyd();\nint main(){\n  cin >> n;\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(i == j) cost[i][j] = 0;\n      else{\n\tcost[i][j] = INF;\n      }\n    }\n  }\n  for(int i = 1; i <= n; i++){\n    cin >> r >> k;\n    for(int j = 0; j < k; j++){\n      cin >> t;\n      cost[i][t] = 1;\n    }\n  }\n  warshall_floyd();\n  cin >> p;\n  for(int i = 0; i < p;i++){\n    cin >> s >> d >> v;\n    if(cost[s][d] + 1 <= v) cout << cost[s][d] + 1 << endl;\n    else cout << \"NA\" << endl;\n  }\n}\n\nvoid warshall_floyd(){\n  for(int k = 1; k <= n; k++){\n    for(int i = 1; i <= n; i++){\n      for(int j = 1; j <= n; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nint main()\n{\n\tint n; cin>>n;\n\tvvi dp(n,vi(n,INFTY));\n\trep(i,n)\n\t\tdp[i][i]=0;\n\trep(i,n){\n\t\tint r,k; cin>>r>>k;\n\t\trep(j,k){\n\t\t\tint t; cin>>t;\n\t\t\tdp[r-1][t-1]=1;\n\t\t}\n\t}\n\t\n\trep(k,n) rep(i,n) rep(j,n)\n\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\n\tint p; cin>>p;\n\trep(i,p){\n\t\tint s,d,v; cin>>s>>d>>v;\n\t\tif(dp[s-1][d-1]<v)\n\t\t\tcout<<dp[s-1][d-1]+1<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#define MAX_N 110\nbool A[MAX_N][MAX_N];\nint rooter_num;\nusing namespace std;\nint bfs(int,int);\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  int a;\n  memset(A,false,sizeof(A));\n  cin>>rooter_num;\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r][t]=true;\n\t}\n    }\n  cin>>n;\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      a=bfs(startNode,goalNode);\n      //    cout<<\"TTL=\"<<TTL<<\";\"<<\"a-1=\"<<a<<endl;\n      if(a-1<TTL)cout<<a<<endl;\n      else cout<<\"NA\"<<endl;\n       \n    }\n  return 0;\n}\nint bfs(int startNode,int goalNode)\n{\n  queue<int>Q;\n  int visited[rooter_num+1];\n  memset(visited,0,sizeof(visited));\n  int currentNode=startNode;\n  \n  Q.push(currentNode);\n  visited[currentNode]=1;\n  \n  while(!Q.empty())\n    {\n\n      \n      currentNode=Q.front();\n      Q.pop();\n      for(int nextNode=1;nextNode<=rooter_num;nextNode++)\n\t{\n\n\t  if(A[currentNode][nextNode]==0)continue;\n\n\t  if(nextNode==goalNode)return visited[currentNode]+1;\n\t  \n\t  if(visited[nextNode]<=0)\n\t    {\n\t      visited[nextNode]=visited[currentNode]+1;\n\t      Q.push(nextNode);\n\t    }\n\t}\n    }\n  return MAX_N;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n#define INFTY 10000000\n\nint n,u,k;\nint s,d,v,TTL;\nint M[101][101],D[101];\n\nvoid bfs( int s ){\n  \n  queue <int> Q;\n  for( int i = 1; i <= n; i++ ) D[i] = INFTY;\n\n  D[s] = 1;\n  Q.push(s);\n     \n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    for( int l = 1; l <= n; l++ ){\n      if( M[u][l] == 0 ) continue;\n      if( D[l] != INFTY ) continue;\n      D[l] = D[u] + 1;\n      // cout << \"l\" << \" \" << l << \" \" <<  \"D[l]\" << \" \" << D[l] << \" \" <<\n      // \t\"D[u]\" << \" \" << D[u] << endl;\n      Q.push(l);\n\n     \n    }\n\n  }\n  if ( D[d] > TTL ){\n    cout << \"NA\" << endl;\n    return;\n  }else{\n    cout << D[d] << endl;\n    //\tcout << \"TTL\" << \" \" << TTL << endl;\n    return;\n  }\n  \n \n}\n\nint main(){\n  cin >> n;\n  for( int i = 1; i <= n; i++ ){\n    cin >> u;\n    cin >> k;\n    for( int j = 0; j < k; j++ ){\n      int v;\n      cin >> v;\n      M[u][v] = 1;\n    }\n  }\n    \n  int p; cin >> p; \n  for( int i = 0; i < p; i++ ){\n  cin >> s >> d >> TTL;\n  bfs(s);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <deque>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N_MAX = 100;\n\nclass Node {\npublic:\n\tint pos, ttl;\n\tNode(int p, int t) : pos(p), ttl(t) {}\n};\n\nint n;\n// adj[from][to] from->toの辺があるか\nbool adj[N_MAX + 1][N_MAX + 1];\nbool visited[N_MAX + 1];\n\nvoid bfs(int src, int dst, int limit) {\n\tdeque<Node> que;\n\tfill(visited, visited + n, false);\n\tque.push_back(Node(src, limit - 1));\n\twhile (!que.empty()) {\n\t\tNode current = que.front();\n\t\tque.pop_front();\n\t\tif (current.pos == dst) {\n\t\t\tcout << limit - current.ttl << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (visited[current.pos]) continue;\n\t\tvisited[current.pos] = true;\n\t\tif (current.ttl == 0) continue;\n\t\tfor (int next = 1; next <= n; next++) {\n\t\t\tif (adj[current.pos][next] && !visited[current.pos]) {\n\t\t\t\tque.push_back(Node(next, current.ttl - 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfill(adj[r], adj[r] + n, false);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tadj[r][t] = true;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tbfs(s, d, v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main(){\n  int a,b,c,d,e,f,g,now,v[101],m[101][101]={};\n  queue<int> q;\n  cin >> a;\n  for(int i=1;i<=a;i++){\n    cin >>b>>c;\n    for(int j=0;j<c;j++){\n      cin >> d;\n      m[i][d]=1;\n    }\n  }\n  cin >> d;\n  for(int i=0;i<d;i++){\n    cin >> e >> f >> g;\n    q.push(e);\n    for(int j=1;j<=a;j++)v[j]=1200;\n    v[e]=1;\n    while(1){\n      now=q.front();q.pop();\n      if(now==f){\n\tif(v[f]>g){\n\t  cout << \"NA\" << endl;\n\t  break;\n\t  }else {\n\t  cout << v[now] << endl;\n\t  break;\n\t}\n      }\n      for(int j=1;j<=a;j++){\n\tif(m[now][j]==1&&v[j]==1200){\n\t  v[j]=v[now]+1;\n\t  q.push(j);\n\t}\n      }\n      if(q.empty()){\n\tcout<< \"NA\" << endl;\n\tbreak;\n      }\n    }\n    while(!q.empty())q.pop();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\nint main(){\n\tint n; cin>>n;\n\tvector<vector<int> > e;\n\tvector<int> id(n);\n\tFOR(i,n){\n\t\tcin>>id[i];\n\t\tint x; cin>>x;\n\t\te.push_back(vector<int>(x));\n\t\tFOR(j,x) cin>>e[i][j];\n\t}\n\n\tmap<int,int> mp;\n\tFOR(i,n) mp[id[i]] = i;\n\tFOR(i,n) FOR(j,sz(e[i])) e[i][j] = mp[e[i][j]];\n\n\tvector<vector<int> > dp(n,vector<int>(n,INF));\n\tFOR(i,n) FOR(j,sz(e[i])) dp[i][e[i][j]] = 1;\n\n\tFOR(k,n) FOR(i,n) FOR(j,n) dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\n\tint m; cin>>m;\n\twhile(m--){\n\t\tint s,t,tll; cin>>s>>t>>tll;\n\t\ts = mp[s],t = mp[t];\n\t\tint ans = dp[s][t] + 1;\n\t\tif(ans > tll) printf(\"NA\");\n\t\telse printf(\"%d\",ans);\n\t\t\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n,p;\n\tmap<int,int> num;\n\tint cost[101][101];\n\tcin >> n;\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= n;j++) cost[i][j] = INF;\n\t\tcost[i][i] = 0;\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tint r,k;\n\t\tcin >> r >> k;\n\t\tfor(int j = 0;j < k;j++){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tcost[r][t] = 1;\n\t\t}\n\t}\n\tfor(int k = 0;k <= n;k++){\n\t\tfor(int i = 0;i <= n;i++){\n\t\t\tfor(int j = 0;j <= n;j++) cost[i][j] = min(cost[i][j],cost[i][k] + cost[k][j]);\n\t\t}\n\t}\n\tcin >> p;\n\tfor(int i = 0;i < p;i++){\n\t\tint s,d,v;\n\t\tcin >> s >> d >> v;\n\t\tif(cost[s][d] >= v) cout << \"NA\" << endl;\n\t\telse cout << cost[s][d] + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n    //making graph\n    cin >> n;\n    \n    int data[n+1][n+1];\n    \n    for(int i = 0; i <= n; i++){\n      for(int j = 0; j <= n; j++){\n\tdata[i][j] = 0;\n      }\n    }\n    \n    int from, to, conesum;\n\n    for(int i = 0; i < n; i++){\n      cin >> from >> conesum;\n      for(int j = 0; j < conesum; j++){\n\tcin >> to;\n\tdata[from][to] = 1;\n      }\n    }\n    //making graph end\n\n    //judge\n\n    int sumpake;\n    cin >> sumpake;\n\n    queue<int> Q;\n\n    int ttl, myposi, min, sumin, sumina, finish = 0;\n\n    for(int i = 0; i < sumpake; i++){\n      min = 0;\n      cin >> from >> to >> ttl;\n      myposi = from;\n      for(int j = 0; j < ttl; j++){\n\tif(j != 0){\n\t  for(int l = 0; l < sumina; l++){\n\t    //cout << \"sumina \" << sumina << endl;\n\t    if(Q.front() == to){\n\t      min = j;\n\t      finish = 1;\n\t      //cout << \"much\" << endl;\n\t      break;\n\t    }\n\t    myposi = Q.front();\n\t    //cout << \"pop  \" << Q.front()<<endl;\n\t    Q.pop();\n\t    for(int k = 1; k <= n; k++){\n\t      if(data[myposi][k] == 1) {\n\t\tQ.push(k);\n\t\tsumin++;\n\t      }\n\t    }\n\t    \n\t  }\n\t  if(finish == 1) break;\n\t}else{\n\t  sumin = 0;\n\t  for(int k = 1; k <= n; k++){\n\t    if(data[myposi][k] == 1) {\n\t      Q.push(k);\n\t      sumin++;\n\t    }\n\t  }\n\t  \n\t}\n\t//\tfor(int k = 1; k <= n; k++){\n\t//\t    if(data[myposi][k] == 1) {\n\t//\t      Q.push(k);\n\t//\t      sumin++;\n\t//\t    }\n\t//\t}\n\t  sumina = sumin;\n\t  sumin = 0;\n      }\n\n      \n      if(min == 0) cout << \"NA\";\n      else cout << min+1;\n      cout << endl;\n      finish = 0;\n      while(!Q.empty()) Q.pop();\n    }\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n\nusing namespace std;\nint a[100][100];\nint main(){\n  int n, r, k, t;\n  scanf(\"%d\", &n);\n  rep(i, n) rep(j, n) a[i][j] = 1<<16;\n  rep(i, n){\n    scanf(\"%d%d\", &r, &k);r--;\n    rep(j, k){\n      scanf(\"%d\", &t);t--;\n      a[r][t] = 1;\n    }\n  }\n\n  // solve\n  rep(i, n) rep(j, n) rep(k, n)\n    a[j][k] = min(a[j][k], a[j][i] + a[i][k]);\n\n  int p, s, d, v;\n  scanf(\"%d\", &p);\n  rep(i, p){\n    scanf(\"%d%d%d\", &s, &d, &v);s--;d--;\n    if(v - a[s][d]) printf(\"%d\\n\", a[s][d] + 1);\n    else puts(\"NA\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define SUB 103\n\nint net[SUB][SUB],n,maxx=0;\n\ntypedef pair<int,int> BVB;\n\n\nint ans(int,int,int);\n\n\n\nint main(){\n\n \n\n  int i,j,p,num,n1,th;\n\n  cin >> n;\n\n\n\n  for(i=0;i<n;i++){ //net's info\n    \n    cin >> num >> n1;\n    if(num >= maxx)maxx = num;\n\n\n    for(int k=0;k<maxx;k++)net[num][k]=0;    //siyoukanou\n\n    for(j=0;j<n1;j++){\n      cin >> th;\n      net[num][th]=1;\n    }\n\n  }//net's info\n  // cout << \"maxx =\" << maxx << endl;\n  for(int m=0;m<maxx;m++){\n    for(int n=0;n<maxx;n++){\n      if(net[m][n]!=1)net[m][n]=0;\n    }\n  }\n\n  \n\n  int pkn;\n\n  cin >> pkn;\n\n  int st,ed,c,answer;\n\n  \n\n\n\n  for(i=0;i<pkn;i++){//pack's info\n    cin >> st >> ed >> c;\n\n\n    answer = ans(st,ed,c);\n\n    if(answer != -2)cout << answer << endl;\n    else cout << \"NA\" << endl;\n\n  }//pack's info\n\n\n\n}\n\n\n\n//L[(ÊÌzñÅà¢¢¯Ç)ÉÇñÇñüêÄ¢«TTLªO¢ÉÈéOÉÚInÉBÅ«é©Ç¤©ð²×é\n//[^ÍÚInÉBµ½n_ÌTTL©çvZµÄ¾·\nint ans(int st,int ed,int c){\n  queue<BVB> Nari;\n  int i,j,k,l,cal=0,mem=0;\n  BVB next,fr;\n\n  fr.first=st;\n  fr.second=c;\n  Nari.push(fr);\n  /*\n  cout << \"FIRST next.second = \" << c << endl;  \n  cout << \"FIRST cal = \" << cal << endl;\n  */  \n\n  if(st == ed && c != 0)return 1;\n\n\n  while(1){\n    next=Nari.front();\n    Nari.pop();\n    next.second=next.second-1;\n\n    if(fr.second == (next.second+1) && next.second == 0 && next.first != ed)return -2;\n\n    if(next.second < 0)break; //I¹ð\n    //cout << \"next.second = \" << next.second << endl; \n    \n    for(i=1;i<=maxx;i++){//¢¯éêðL[Éüêé\n      if(net[next.first][i] == 1)mem++;  \n\n    \n      \n      if(net[next.first][i] == 1 && i == ed ){ //ÚInB\n\t/*\t\n\tcout << \"GOOOOOOOOOL!!! i = \" << i <<endl;\n\tcout << \"             cal = \" << cal << endl;\n\tcout << \"     next.second = \" << next.second << endl; \n\t*/\n\n\treturn (fr.second - next.second)+1;\n\t\n      }\n      \n      if(net[next.first][i] == 1)Nari.push(BVB(i,next.second));\n      \n      if(mem == n)break;\n    }\n      \n    \n  }\n\n  return -2;\n  \n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef vector<int> vi;\nint main(){\n  int n,m; cin>>n;\n\n  int adj[100][100]={0};\n  rep(i,n){\n    int r,k,t; cin>>r>>k, r--;\n    rep(j,k)cin>>t,adj[r][t-1]=1;\n  }\n  cin>>m;\n  vi frontier,next; frontier.reserve(100),next.reserve(100);\n  int cost[100];\n  rep(i,m){\n    int s,d,v; cin>>s>>d>>v,s--,d--;\n    frontier.clear(); frontier.push_back(s);\n    rep(j,n)cost[j]=9999; cost[s]=0;\n    for(int step=0;step<v-1&&cost[d]==9999;step++){\n      next.clear();\n      rep(j,frontier.size())rep(h,n)if(adj[frontier[j]][h]&&cost[h]>step+1)\n\tcost[h]=step+1,next.push_back(h);\n      frontier=next;\n    }\n    if(cost[d]!=9999)cout<<cost[d]+1<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n#include <set>\n\nusing namespace std;\n\ntypedef struct {\n  int *ks;\n  int length;\n} node;\n\nnode *nodes;\n\n\nint dikstra(int s, int e, int deep){\n  int c=0;\n\n  list<int> que;\n  set<int> done;\n  set<int> done2;\n  que.push_back(s);\n  done.insert(s);\n\n  while(1){\n    c++;\n    if(c >= deep) return -1;\n\n    done2.clear();\n\n    int len = que.size();\n    for(int i=0;i<len;i++){\n\n      int v = que.front();\n      que.pop_front();\n\n      for(int j=0;j<nodes[v].length;j++){\n        if(nodes[v].ks[j]==e){\n          return c+1;\n        }else{\n          int k = nodes[v].ks[j];\n          if(done.find(k) == done.end()){\n            que.push_back(k);\n            done2.insert(k);\n          }\n        }\n      }\n    }\n    done.insert(done2.begin(), done2.end());\n  }\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  nodes = new node[n];\n\n  int i,j;\n  int t,u,v;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\", &t,&u);\n    nodes[t-1].ks = new int[u];\n    nodes[t-1].length = u;\n    for(j=0;j<u;j++){\n      scanf(\"%d\", &v);\n      nodes[t-1].ks[j] = v-1;\n    }\n  }\n\n  int m;\n  scanf(\"%d\", &m);\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\", &t, &u, &v);\n    int r;\n    if((r=dikstra(t-1, u-1,v)) != -1) printf(\"%d\\n\", r);\n    else puts(\"NA\");\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i <= n; i++){\n\t\tfor(int k=1; k <= n; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(t_limit <= 1){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tFLG = true;\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tif(memo[start][goal] != 0){\n\t\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\t\t}\n\n\n\t\twhile(Q.empty() == false && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && (memo[i][goal]+1) < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+2);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>R[105];\n\nint f(int s,int t,int v)\n{\n\tint flg[105][105];\n\tmemset(flg,0x7f,sizeof(flg));\n\tpriority_queue<P>Q;\n\tQ.push(P(1,s));\n\tflg[s][s]=0;\n\tfor(;!Q.empty();)\n\t{\n\t\tP now=Q.top();Q.pop();\n\t\tif(now.second==t)return now.first;\n\t\tnow.first++;\n\t\tif(now.first>v)continue;\n\t\tint n=now.second;\n\t\tfor(int i=0;i<R[n].size();i++)\n\t\t{\n\t\t\tif(flg[s][R[n][i]]>now.first)\n\t\t\t{\n\t\t\t\tflg[s][R[n][i]]=now.first;\n\t\t\t\tQ.push(P(now.first,R[n][i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint N,M,s,t,v,r;\n\tscanf(\"%d\",&N);\n\tfor(;N--;)\n\t{\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tfor(;t--;)\n\t\t{\n\t\t\tscanf(\"%d\",&v);\n\t\t\tR[s].push_back(v);\n\t\t}\n\t}\n\tscanf(\"%d\",&M);\n\tfor(;M--;)\n\t{\n\t\tscanf(\"%d%d%d\",&s,&t,&v);\n\t\tr=f(s,t,v);\n\t\tif(r!=-1)printf(\"%d\\n\",r);\n\t\telse puts(\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nclass WarshallFloyd {\npublic:\n    static const int inf = 1<<29;\n    int m_num;\n    vector<vector<int> > m;\n    void init(int n){\n        m_num = n;\n        m.resize(n);\n        REP(i,n){\n            m[i] = vector<int>(n,inf);\n            m[i][i] = 0;\n        }\n    }\n    void add(int u, int v, int e){\n        dbgchk(u < 0 || u >= m_num || v < 0 || v >= m_num || u == v);\n        m[u][v] = e;\n    }\n    void solve(){\n        int n = m_num;\n        REP(k,n) REP(i,n) REP(j,n)\n            m[i][j] = MIN(m[i][j], m[i][k] + m[k][j]);\n    }\n    int get(int u, int v){\n        dbgchk(u < 0 || u >= m_num || v < 0 || v >= m_num);\n        return m[u][v];\n    }\n};\n\nint main(){\n    WarshallFloyd wf;\n    int n, p;\n    cin >> n;\n    wf.init(n);\n    REP(i,n){\n        int r, k, t;\n        cin >> r >> k;\n        REP(j,k){\n            cin >> t;\n            wf.add(r-1,t-1,1);\n        }\n    }\n    wf.solve();\n\n    cin >> p;\n    REP(i,p){\n        int s,d,v;\n        cin >> s >> d >> v;\n        int step = wf.get(s-1,d-1);\n        if(step == wf.inf || step >= v){\n            cout << \"NA\" << endl;\n        } else {\n            cout << step+1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nint pass[200][200];\nint n;\n\nint dijk(int s,int g){\n    int d[200];\n    bool used[200];\n    rep(i,200)d[i]=999999999;\n    rep(i,200)used[i]=false;\n    d[s]=0;\n    \n    while(1){\n        int v=-1;\n        rep(u,n){\n            if(!used[u]&&(v==-1||d[u]<d[v]))v=u;\n        }\n        if(v==-1)break;\n        \n        used[v]=true;\n        \n        rep(u,n){\n            d[u] = min(d[u],d[v]+pass[v][u]);\n        }\n    }\n    return d[g];\n}\n\n\nint main(){\n    while(cin>>n){\n        rep(i,200)rep(j,200)pass[i][j]=999999999;\n        rep(i,200)pass[i][i]=0;\n        rep(i,n){\n            int r,k;\n            cin>>r>>k;\n            r--;\n            rep(j,k){\n                int x;\n                cin>>x;\n                x--;\n                pass[r][x]=1;\n            }\n        }\n        int p;\n        cin>>p;\n        rep(i,p){\n            int s,g,v;\n            cin>>s>>g>>v;\n            s--,g--;\n            int res = dijk(s,g)+1;\n            if(res<=v)cout<<res<<endl;\n            else cout<<\"NA\"<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//59\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  vector<int> e[101];\n  for(int i=0;i<n;i++){\n    int r,k;\n    cin>>r>>k;\n    while(k--){\n      int t;\n      cin>>t;\n      e[r].push_back(t);\n    }\n  }\n  int p;\n  cin>>p;\n  while(p--){\n    int s,d,v;\n    cin>>s>>d>>v;\n    queue<pair<int,int> > que;\n    que.push(make_pair(1,s));\n    while(!que.empty()){\n      int c=que.front().second;\n      if(c==d)break;\n      for(int i=0;i<e[c].size();i++){\n\tque.push(make_pair(que.front().first+1,e[c][i]));\n      }\n      que.pop();\n    }\n    if(que.empty()||que.front().first>v){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().first<<endl;\n    }\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\nint main(){\n    int n, r, k, t;\n    cin >> n;\n\n    map<int, vector<int>> path;\n    for(int i = 0; i < n; i++){\n        cin >> r >> k;\n        for(int j = 0; j < k; j++){\n            cin >> t;\n            path[r].push_back(t);\n        }\n    }\n\n    int p, s, d, v;\n    cin >> p;\n    for(int i = 0; i < p; i++){\n        cin >> s >> d >> v;\n        queue<pair<int, int>> q;\n        set<int> appear;\n\n        q.push({s,1});\n\n        int ans = -1;\n        while(!q.empty()){\n            pair<int,int> p = q.front();    q.pop();\n            if(appear.find(p.first) != appear.end())   continue;\n            \n            if(p.first == d){\n                ans = p.second;\n                break;\n            }\n\n            appear.insert(p.first);\n\n            for(int j = 0; j < path[p.first].size(); j++){\n                if(appear.find(path[p.first][j]) == appear.end()){\n                    q.push({path[p.first][j], p.second+1});\n                }\n            }\n        }\n\n        if(ans == -1 || ans > v){\n            cout << \"NA\" << endl;\n        }else{\n            cout << ans << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\n/* main??? */\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\n/* ???????????¢??° */\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\n/* ??????????????\\?¶??????±??\\?????¢??° */\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++){\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ???????????±???????????±??\\?????¢??° */\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcSumRouter(i4StartRouter,i4GoalRouter,i4TTL);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ??????????????????????¨????????????°?¨??????¢??° */\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\t/* ?????°??£?¨? */\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\t/* ????????¨ */\n\tI4 i4DefineRouter[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\tI4 i4StarCnt;\n\tI4 i4RoopMax;\n\t\n\t/* ????????? */\n\ti4StarCnt = 0;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\ti4DefineRouter[i4RoopCnt1] = FALSE;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\tif(i4TTL<=i4RouterNum){\t\n\t\ti4RoopMax = i4TTL;\n\t}\n\telse{\n\t\ti4RoopMax = i4RouterNum;\n\t}\n\t\n\ti4DefineRouter[i4Sender] = TRUE;\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<i4RoopMax; i4RoopCnt1++){\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=i4RouterNum; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=i4RouterNum; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i4DefineRouter[i4RoopCnt3] != TRUE){\n\t\t\t\t\t\t\ti4StarCnt++;\n\t\t\t\t\t\t\ti4DefineRouter[i4RoopCnt3] = TRUE;\n\t\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif(i4StarCnt > 0){\n\t\t\ti4StarCnt = 0;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint d[101][101]={};\nint x[101];\nint n;\nvoid bfs(int);\nint main(){\n  int p;\n  int na[100];\n  int to;\n  int th;\n  int st,go,ttl;\n  //syoki\n  for(int i=0;i<n;i++){\n    x[i]=10000;\n  }\n  //in\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> na[i] >> to;\n    for(int j=0;j<to;j++){\n      cin >> th;\n      d[na[i]][th]=1;\n    }\n  \n  }\n  //in2\n  cin >> p;\n  for(int i=0;i<p;i++){\n    for(int j=0;j<=n;j++){\n      x[j]=10000;\n    }\n    \n    cin>> st >> go >> ttl;\n    x[st]=1;\n    bfs(st);\n    if(x[go]<=ttl)cout << x[go] << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}\n\n///bfs///////////////////////////////////////////\nvoid bfs(int s){\n  queue<int>q;\n  int u;\n  q.push(s);\n  while(!q.empty()){\n    u=q.front();\n    q.pop();\n    for(int v=0;v<=n;v++){\n      if(d[u][v]==1&&x[v]==10000){\n\tx[v]=x[u]+1;\n\tq.push(v);\n      }\n    }\n  }\n  return ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int maxv=100000;\nint main()\n{\n\tint root[101][101];\n\tfor(int i=0;i<10;i++){\n\t\tfor(int i2=0;i2<100;i2++){\n\t\t\troot[i][i2]=maxv;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tint r,k,ch;\n\tcin>>r>>k;\n\t\tfor(int i2=0;i2<k;i2++){\n\t\t\tcin>>ch;\n\t\t\troot[r][ch]=1;\n\t\t}\n\t}\n\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int i2=01;i2<=n;i2++){\n\t\t\t\troot[i][i2]=min(root[i][i2],root[i][k]+root[k][i2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint m;\n\tint s,d,v;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>s>>d>>v;\n\t\tif(root[s][d]<v){\n\t\t\tcout<<root[s][d]+1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main()\n{\n  int n;\n  int node[100][100];\n  cin>>n;\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      node[i][j]=0;\n  \n  \n  for(int x=0;x<n;x++)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t  //\t  cout<<node[k][tmp]<<endl;\n\t  //  cout<<\"nodeadd:\"<<k<<\" \"<<tmp<<endl;\n\t}\n    }\n\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      queue<P> qu;\n      int ans=-1;\n      for(int i=0;i<=n;i++)\n\t{\n\t  if(node[s][i]==1)\n\t    {\n\t      qu.push(P(i,2));\n\t    }\n\t}\n      while(!qu.empty())\n\t{\n\t  P a = qu.front();\n\t  qu.pop();\n\t  if(a.second>v)\n\t    break;\n\t  if(a.first==d)\n\t    {\n\t      ans = a.second;\n\t      break;\n\t    }\n\t  for(int i=0;i<=n;i++)\n\t    {\n\t      if(node[a.first][i]==1)\n\t\tqu.push(P(i,a.second+1));    \n\t      \n\t    }\n\t}\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000;\nint edge[100][100];\n\nvoid WF(int n){\n\tfor(int k = 0;k < n;++k){\n\t\tfor(int i = 0;i < n;++i){\n\t\t\tfor(int j = 0;j < n;++j){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tedge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, p, r, k, t, a;\n\tfor(int i = 0;i < 100;++i){\n\t\tfor(int j = 0;j < 100;++j){\n\t\t\tedge[i][j] = INF;\n\t\t}\n\t}\n\tcin >> n;\n\tfor(int i = 0;i < n;++i){\n\t\tcin >> r >> k;\n\t\t--r;\n\t\tfor(int j = 0;j < k;++j){\n\t\t\tcin >> a;\n\t\t\t--a;\n\t\t\tedge[r][a] = 1;\n\t\t}\n\t}\n\tWF(n);\n\tcin >> p;\n\tfor(int i = 0;i < p;++i){\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\t--s;\n\t\t--d;\n\t\tif(edge[s][d] + 1 <= v) cout << edge[s][d] + 1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define INF (1 << 30)\n#define MAX_E 10000\n#define MAX_V 1000\n\nstruct edge{\n\tint from;\n\tint to;\n\tint cost;\n};\n\nedge es[MAX_E];\nint d[MAX_V];\nint V, E;// V???????????°???E????????°\n\n// O(VE)??§????????????????????????????????§??????\n\nvoid shortest_path(int s){\n\tfor(int i = 1; i <= V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\twhile(true){\n\t\tbool update = false;\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tedge e = es[i];\n\t\t\tif(d[e.from] != INF && d[e.to] > d[e.from] + e.cost){\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tif(!update){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint n, p;\n\t\n\tcin >> n;\n\t\n\tint from_, num, to_, length;\n\t\n\tV = n;\n\t\n\tE = 0;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> from_ >> num;\n\t\tfor(int j = 0; j < num; j++){\n\t\t\tcin >> to_;\n\t\t\tes[E].from = from_;\n\t\t\tes[E].to = to_;\n\t\t\tes[E].cost = 1;\n\t\t\tE++;\n\t\t}\n\t}\n\t\n\tcin >> p;\n\t\n\tfor(int i = 0; i < p; i++){\n\t\tcin >> from_ >> to_ >> length;\n\t\tshortest_path(from_);\n\t\tif(d[to_] < length){\n\t\t\tprintf(\"%d\\n\", d[to_] + 1);\n\t\t}else{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector <int> ro[1000];\nint s,d,v;\nint s2,d2;\nint kk,n,r,md;\nbool flg[10000] ;\n\n\nvoid visit(int sn,int dis) {\n  //  for(int i=1;i<=n;i++)cout << flg[i];\n  // cout <<\" \";\n  \n  if(sn == d-1 && dis <=v)  md = min(md,dis);\n  else if(dis < v && dis < md) {\n    for(int i=0;i<ro[sn].size();i++) {\n      if(flg[ro[sn][i]] == 0){\n\t//\tcout <<sn+1 << \"to\"<<ro[sn][i] << endl;\n\tflg[ro[sn][i]] = 1;\n\tvisit(ro[sn][i]-1,dis+1);\n\tflg[ro[sn][i]] = 0;\n      }\n    } \n  }\n}\n  \nint main() {\n\n  cin >> n;\n    \n  for(int i=0;i<n;i++) {\n    cin >> r >> kk;\n    ro[r-1].resize(kk);\n    for(int j=0;j<kk;j++) cin >> ro[r-1][j];\n  }\n  \n  int p;\n  cin >> p;\n  for(int i=0;i<p;i++) {\n    cin >> s >> d >> v;\n    \n    for(int j=1;j<=n;j++) flg[j] = 0;\n    md = 10000000;\n    flg[s]  = 1;   \n    visit(s-1,1);\n    \n    if(md != 10000000) cout << md <<endl;\n    else cout << \"NA\" <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint d[1000][1000]={};\nint x[100];\nint n;\nint nm=0;\nvoid bfs(int);\nint main(){\n  int p;\n  int na[100];\n  int to;\n  int th;\n  int st,go,ttl;\n  //syoki\n  for(int i=0;i<n;i++){\n    x[i]=10000;\n  }\n  //in\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> na[i] >> to;\n    if(na[i]>nm)nm=na[i];\n    for(int j=0;j<to;j++){\n      cin >> th;\n      d[na[i]][th]=1;\n    }\n  \n  }\n  //in2\n  cin >> p;\n  for(int i=0;i<p;i++){\n    for(int j=0;j<=nm;j++){\n      x[j]=10000;\n    }\n    \n    cin>> st >> go >> ttl;\n    x[st]=1;\n    bfs(st);\n    if(x[go]<=ttl)cout << x[go] << endl;\n    else cout << \"NA\" << endl;\n  }\n  return 0;\n}\n\n///bfs///////////////////////////////////////////\nvoid bfs(int s){\n  queue<int>q;\n  int u;\n  q.push(s);\n  while(!q.empty()){\n    u=q.front();\n    q.pop();\n    for(int v=0;v<=nm;v++){\n      if(d[u][v]==1&&x[v]==10000){\n\tx[v]=x[u]+1;\n\tq.push(v);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\n\nint main(){\n  int n;\n\tcin>>n;\n\tint graph[n][n];\n\tfor(int j=0;j<n;j++)\n\t\tfor(int i=0;i<n;i++)\n\t\t\tgraph[j][i] = 1000;\n\tfor(int i=0;i<n;i++){\n\t\tint k,m,l;\n\t\tcin>>k>>m;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcin>>l;\n\t\t\tgraph[k-1][l-1] = 1;\n\t\t}\n\t}\n\t\n\tfor(int j = 0;j<n;j++)\n\t\tfor(int i = 0;i<n;i++)\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\tif(graph[i][j]>graph[i][k]+graph[k][j])\n\t\t\t\t\tgraph[i][j] = graph[i][k]+graph[k][j];\n\tint p;\n\tcin>>p;\n\tfor(int i=0;i<p;i++){\n\t\tint s,d,v;\n\t\tcin>>s>>d>>v;\n\t\tif(graph[s-1][d-1]<v)\n\t\t\tcout<<graph[s-1][d-1]+1<<endl;\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Nature of Prime Numbers\n//Level: 1\n//Category: やるだけ\n//Note: 問題文が読みにくい\n\n/**\n * 問題文がかなり分かりにくいが、要するに\n * ・a_i = i^2 mod n (1 ≦ i < n)\n * ・S = unique set of a_i\n * ・d_j = (a - b) mod n (a, b ∈ S, a≠b)\n * ・e_j = max(0, min(d_j, n-d_j))\n * としたとき、e_jのヒストグラムを作れば良い。\n * 問題文の残りの部分は、nが素数かつn≡3 (mod 4) のときに、e_jのヒストグラムが\n * 平らになることを主張している。\n */\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nbool solve(bool first) {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    set<int> s;\n    for(int i = 0; i < N-1; ++i) {\n        s.insert((i+1)*(i+1) % N);\n    }\n    vector<int> hist((N-1)/2, 0);\n    for(auto it1 = begin(s); it1 != end(s); ++it1) {\n        for(auto it2 = begin(s); it2 != it1; ++it2) {\n            int e = (*it1 - *it2 + N) % N;\n            if(e > (N-1)/2) e = N - e;\n            hist[e-1]++;\n        }\n    }\n    for(int i : hist) {\n        cout << i*2 << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(2);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Node{\npublic:\n\tvector< int > e_to;\n\tvector< int > e_cost;\n\t\n\tbool def;\n\tint min_cost;\n\t\n\tNode(){\n\t\tdef = false;\n\t\tmin_cost = -1;\n\t}\n};\nbool operator==(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost == ot2.min_cost;\n}\nbool operator!=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 == ot2);\n}\nbool operator<(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost < ot2.min_cost;\n}\nbool operator>(const Node& ot1, const Node& ot2){\n\treturn ot1.min_cost > ot2.min_cost;\n}\nbool operator<=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 > ot2);\n}\nbool operator>=(const Node& ot1, const Node& ot2){\n\treturn !(ot1 < ot2);\n}\n\nclass Dijkstra{\n\tpriority_queue< Node, vector< Node >, greater< Node > > que;\n\tvector< Node > nodes;\n\t\npublic:\n\tvoid Init(int node_num){\n\t\tnodes.resize(node_num);\n\t\tfor(int i = 0; i < node_num; ++i){\n\t\t\tnodes[i] = Node();\n\t\t}\n\t}\n\t\n\tvoid Put(int id, int to, int cost){\n\t\tnodes[id].e_to.push_back(to);\n\t\tnodes[id].e_cost.push_back(cost);\n\t}\n\t\n\tint Run(int s, int t){\n\t\t\n\t\tfor(vector< Node >::iterator it = nodes.begin(); it != nodes.end(); ++it){\n\t\t\tit->min_cost = -1;\n\t\t\tit->def = false;\n\t\t}\n\t\t\n\t\tnodes[s].min_cost = 0;\n\t\tque.push(nodes[s]);\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tNode def_node = que.top();\n\t\t\tque.pop();\n\t\t\n\t\t\tif(def_node.def)continue;\n\t\t\n\t\t\tdef_node.def = true;\n\t\t\n\t\t\tfor(int i = 0; i < def_node.e_to.size(); ++i){\n\t\t\t\tint to = def_node.e_to[i];\n\t\t\t\tint cost = def_node.min_cost + def_node.e_cost[i];\n\t\t\t\t\n\t\t\t\tif(nodes[to].min_cost == -1 || cost < nodes[to].min_cost){\n\t\t\t\t\tnodes[to].min_cost = cost;\n\t\t\t\t\tque.push(nodes[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes[t].min_cost;\n\t}\n};\n\n\nint main(){\n\tint n, r, k, t, p, s, d, v;\n\tDijkstra dijk;\n\t\n\t\n\tcin >> n;\n\t\n\tdijk.Init(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> r >> k;\n\t\t\n\t\tfor(int j = 0; j < k; ++j){\n\t\t\tcin >> t;\n\t\t\tdijk.Put(r - 1, t - 1, 1);\n\t\t}\n\t}\n\t\n\tcin >> p;\n\t\n\tfor(int i = 0; i < p; ++i){\n\t\tcin >> s >> d >> v;\n\t\t\n\t\tint res = dijk.Run(s - 1, d - 1);\n\t\t\n\t\tif(res >= v){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << res + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int INF = 100000;\nint d[100][100];\nvoid init()\n{\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tif(i == j){\n\t\t\t\td[i][j] = 0;\n\t\t\t}else{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tinit();\n\tfor(int i=0;i<n;i++){\n\t\tint a,m;\n\t\tcin >> a >> m;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\td[a-1][b-1] = 1;\n\t\t}\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint dis = d[i][k]+d[k][j];\n\t\t\t\tif(dis < d[i][j]){\n\t\t\t\t\td[i][j] = dis;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor(int j=0;j<p;j++){\n\t\tint a,b,pket;\n\t\tcin >> a >> b >> pket;\n\t\tif(d[a-1][b-1]+1 <= pket && d[a-1][b-1] != INF)\n\t\t\tcout << d[a-1][b-1]+1  << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\n#define INF 1e+8\n#define EPS 1e-9\n#define PB push_back\n#define fi first\n#define se second\n#define reps(i,j,k) for(int i = j; i < k; i++)\n#define rep(i,j) reps(i,0,j)\nusing namespace std;\nconst int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\ntypedef long long ll;\ntypedef pair<int,int> Pii;\nint D[128][128];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep(i,128)rep(j,128)D[i][j] = INF;\n\trep(i,n){\n\t\tint index;\n\t\tscanf(\"%d\",&index);\n\t\tint sub;\n\t\tscanf(\"%d\",&sub);\n\t\trep(j,sub){\n\t\t\tint tmp;\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tD[index][tmp] = 1;\n\t\t}\n\t}\n\trep(k,101){\n\t\trep(i,101){\n\t\t\trep(j,101){\n\t\t\t\tD[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint m;\n\tscanf(\"%d\",&m);\n\trep(i,m){\n\t\tint a,b,cost;\n\t\tscanf(\"%d%d%d\",&a,&b,&cost);\n\t\tif(D[a][b]+1 <= cost )printf(\"%d\\n\",D[a][b]+1);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef vector<int> vi;\nint main(){\n  int n,m; cin>>n;\n\n  int adj[100][100]={0};\n  rep(i,n){\n    int r,k,t; cin>>r>>k, r--;\n    rep(j,k)cin>>t,adj[r][t-1]=1;\n  }\n  cin>>m;\n  rep(i,m){\n    int s,d,v; cin>>s>>d>>v,s--,d--;\n    vi frontier; frontier.push_back(s);\n    int cost[n]; rep(j,n)cost[j]=9999; cost[s]=0;\n    for(int step=0;step<v-1&&cost[d]==9999;step++){\n      vi next;\n      rep(j,frontier.size())rep(h,n)if(adj[frontier[j]][h]&&cost[h]>step+1)\n\tcost[h]=step+1,next.push_back(h);\n      frontier=next;\n    }\n    if(cost[d]!=9999)cout<<cost[d]+1<<endl;\n    else cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // max, min\n\nusing namespace std;\n\nconst int AllaySize = 1000;\nconst int Limit = 999999;\n\nint N, P;\nint ConnectR[AllaySize][AllaySize];\nint InitTTL;\n//int Ans[AllaySize][AllaySize];\n\nvoid war(void) {\n  for(int k=1; k<N+1; k++) {\n    for(int i=1; i<N+1; i++) {\n      for(int j=1; j<N+1; j++) {\n\tConnectR[i][j]=min(ConnectR[i][j], ConnectR[i][k]+ConnectR[k][j]);\n      }\n    }\n  } \n}\n\nint main(void) {\n  for(int i=0; i<AllaySize; i++) {\n    for(int j=0; j<AllaySize; j++) {\n      ConnectR[i][j]=Limit;\n      // Ans[i][j]=Limit;\n    }\n  }\n\n  cin>>N;\n  for(int i=0; i<N; i++) { // ルータの接続情報\n    int k;\n    int from, to;\n    cin>>from;\n    cin>>k;\n    for(int j=0; j<k; j++) {\n      cin>>to;\n      ConnectR[from][to] = 1; // 通過可能\n    }\n  }\n\n  war();\n  cin>>P;\n  for(int i=0; i<P; i++) {\n    int from, to;\n    cin>>from;\n    cin>>to;\n    cin>>InitTTL;\n    if(ConnectR[from][to] < InitTTL) {\n      cout<<ConnectR[from][to]+1<<endl; // ?????\n    }\n    else {\n      cout<<\"NA\"<<endl;\n    }\n  }\n  /*\n  for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n      cout<<ConnectR[i][j]<<\" \";\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(v, f, l) for (int v = (f), v##_ = (l); v < v##_; ++v)\n#define rep(v, n) reps(v, 0, n)\n#define lep(v, n) reps(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\ntemplate<typename T> void show(T& a, char del='\\n', char last='\\n'){ rep(i, a.size() - 1) cout << a[i] << del; cout << a[a.size() - 1] << last; }\n\nconst int INF = 1 << 29;\n\nint main()\n{\n  int g[128][128];\n  rep(i, 128) rep(j, 128) g[i][j] = INF;\n  rep(i, 128) g[i][i] = 0;\n  int n = in();\n  rep(i, n){\n    int f = in() - 1;\n    rep(j, in()){\n      g[f][in() - 1] = 1;\n    }\n  }\n  rep(k, n){\n    rep(i, n){\n      rep(j, n){\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n      }\n    }\n  }\n  rep(p, in()){\n    int f, t, v;\n    f = in() - 1;\n    t = in() - 1;\n    v = in();\n    if (g[f][t] + 1 <= v) printf(\"%d\\n\", g[f][t] + 1);\n    else puts(\"NA\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<21\n\nusing namespace std;\n\nint main()\n{\t\n\tint n;\n\tcin >> n;\n\t\n\tint a[101][101];\n\trep(i,101) rep(j,101) a[i][j] = INF;\n\n\trep(i,n)\n\t{\n\t\tint r,k,temp;\n\t\tcin >> r >> k;\n\t\t\t\n\t\trep(j,k)\n\t\t{\n\t\t\tcin >> temp;\n\t\t\ta[r-1][temp-1] = 1;\n\t\t}\n\t}\n\n\trep(k,n)\n\t{\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,n)\n\t\t\t{\n\t\t\t\ta[i][j] = min(a[i][j],a[i][k]+a[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint p;\n\tcin >> p;\n\trep(i,p)\n\t{\n\t\tint from,to,cost;\n\t\tcin >> from >> to >> cost;\n\t\t\n\t\tif(cost > a[from-1][to-1])\n\t\t{\n\t\t\tcout << a[from-1][to-1] + 1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> NODE;\n#define pos first\n#define depth second\n\nmap< int,vector<int> > info;\nint bfs(int s,int d){\n\tqueue<NODE> Q;\n\tmap<int,bool>done;\n\t\n\tQ.push( make_pair(s,0) );\n\twhile( !Q.empty() ){\n\t\t/* queueツづ個静ヲツ督ェツづ個ノツーツドツづーツ訪ツ姪「ツ催渉づ敖づ可つオツづowツ陛渉青板づ可禿シツづェツ、ツキツδーツつゥツづァツ偲ヲツづィツ渉慊つュ */\n\t\tNODE now = Q.front();\n\t\tQ.pop();\n\t\tdone[now.pos] = true;\n\n\t\tif(now.pos == d){\n\t\t\treturn now.depth;\n\t\t}\n\n\t\tfor(int i=0;i<info[now.pos].size();i++){\n\t\t\tif( !done[info[now.pos][i]] ){\n\t\t\t\tQ.push( make_pair(info[now.pos][i], now.depth+1) );\n\t\t\t}\n\t\t}\n\t}\n\treturn INT_MAX;\n}\n\nint main(){\n\tint n,r,k,t,p,s,d,v;\n\t\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r >> k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin >> t;\n\t\t\tinfo[r].push_back(t);\n\t\t}\n\t}\t\n\t\n\tcin >> p;\n\tfor(int i=0;i<p;i++){\n\t\tcin >> s >> d >> v;\n\t\t \n\t\tif(v > bfs(s,d) )cout << bfs(s,d)+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAX_N 110\n#define INF (1<<30)\nint rooter_num;\nstruct Node\n{\n  vector<int> edges_to;\n  vector<int> edges_cost;\n  \n  bool done;\n  int cost;\n};\nint dijkstra(int,int);\nvector<Node> A;\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  int a;\n  Node node;\n  /*------------input---------------*/\n  cin>>rooter_num;\n  for(int i=0;i<=rooter_num;i++)\n    {\n      A.push_back(node);\n    }\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r].edges_to.push_back(t);\n\t  A[r].edges_cost.push_back(1);\n\t}\n    }\n  /*--------------------------------*/\n\n\n  /*-------------search-------------*/\n  cin>>n;\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      a=dijkstra(startNode,goalNode);\n      if(TTL>a)cout<<a+1<<endl;\n      else cout<<\"NA\"<<endl;\n    }\n  /*--------------------------------*/\n  return 0;\n}\nint dijkstra(int start,int goal)\n{\n  int min;\n\n  /*-----init----*/\n  for(int i=0;i<=rooter_num;i++)\n    {\n      A[i].done=false;\n      A[i].cost=INF;\n    }\n  A[start].cost=0;\n  /*-------------*/\n  \n  \n  while(true)\n    {\n      min=INF;\n      for(int i=1;i<rooter_num;i++)\n\t{\n\t  if(A[i].done==false&&min>A[i].cost)\n\t    {\n\t      min=A[i].cost;\n\t    }\n\t}\n      if(min==INF)break;\n      /*\n\t確定ノードでなく,かつ現在一番累計コストの低いノードを探した\n      */\n\n\n      for(int currentNode=1;currentNode<rooter_num;currentNode++)\n\t{\n\t  if(A[currentNode].cost==min)\n\t    {\n\t      A[currentNode].done=true;\n\t      /*\n\t\t上で確定したノードを見つけ出し,マークした。\n\t      */\n\n\t      for(int i=0;i<A[currentNode].edges_to.size();i++)\n\t\t{\n\t\t  int nextNode=A[currentNode].edges_to[i];\n\t\t  \n\t\t  if(A[nextNode].cost>A[currentNode].edges_cost[i]+A[currentNode].cost)\n\t\t    {\n\t\t      A[nextNode].cost=A[currentNode].edges_cost[i]+A[currentNode].cost;\n\t\t    }  \n\t\t}\n\t      /*\n\t\t確定したノードから飛び,現在までの最小累計コストより\n\t\t低くなる場合は最小累計コストを更新する\n\t      */\n\t    }\n\t  \n\t}\n      \n    }\n  \n  return A[goal].cost;\n}\n\n\t  \n      \n\t             \n\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX_N 110\nbool A[MAX_N][MAX_N];\nint rooter_num;\nusing namespace std;\nint bfs(int,int);\nint main()\n{\n  int n,startNode,goalNode,TTL;\n  int r,k,t;\n  memset(A,false,sizeof(A));\n  cin>>rooter_num;\n  for(int i=0;i<rooter_num;i++)\n    {\n      cin>>r>>k;\n      for(int j=0;j<k;j++)\n\t{\n\t  cin>>t;\n\t  A[r][t]=true;\n\t}\n    }\n  for(int i=1;i<=rooter_num;i++)\n    {\n      for(int j=1;j<=rooter_num;j++)\n\t{\n\t  cout<<A[i][j];\n\t}\n      cout<<endl;\n    }\n  \n  cin>>n;\n  for(int i=0;i<n;i++)\n    {\n      cin>>startNode>>goalNode>>TTL;\n      int a=bfs(startNode,goalNode);\n      if(a>TTL)cout<<\"NA\"<<endl;\n      else cout<<a<<endl;\n    }\n}\nint bfs(int startNode,int goalNode)\n{\n  queue<int>Q;\n  int visited[rooter_num+1];\n  memset(visited,false,sizeof(visited));\n  int currentNode=startNode;\n  \n  Q.push(currentNode);\n  visited[currentNode]=true;\n  \n  while(!Q.empty())\n    {\n\n      \n      currentNode=Q.front();\n      Q.pop();\n      for(int nextNode=1;nextNode<=rooter_num;nextNode++)\n\t{\n\n\t  if(A[currentNode][nextNode]==false)continue;\n\n\t  if(nextNode==goalNode)return visited[currentNode]+1;\n\t  \n\t  if(visited[nextNode]==false)\n\t    {\n\t      visited[nextNode]=visited[currentNode]+1;\n\t      Q.push(nextNode);\n\t    }\n\t}\n    }\n  return MAX_N;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-6;\n\nusing namespace std;\n\nint main()\n{\n\tint d[101][101];\n\tconst int Inf = 100000000;\n\tfor (int i = 1; i < 101; ++i)\n\t\tfor (int j = 1; j < 101; ++j)\n\t\t\td[i][j] = Inf;\n\tfor (int i = 1; i < 101; ++i)\n\t\td[i][i] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tint no, m;\n\t\tscanf(\"%d %d\", &no, &m);\n\t\twhile (m--)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\td[no][t] = 1;\n\t\t}\n\t}\n\tfor (int k = 1; k < 101; ++k)\n\t\tfor (int i = 1; i < 101; ++i)\n\t\t\tfor (int j = 1; j < 101; ++j)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\tint p;\n\tscanf(\"%d\", &p);\n\twhile (p--)\n\t{\n\t\tint src, dest, ttl;\n\t\tscanf(\"%d %d %d\", &src, &dest, &ttl);\n\t\tint r = d[src][dest] + 1;\n\t\tif (ttl >= r)\n\t\t\tprintf(\"%d\\n\", r);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define MAX 10000000\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge{\n  int to,cost; edge(){}\n  edge(int cost,int to):to(to),cost(cost){}\n};\nvector< vector<edge> > info(101);\nint n,m,co[101],ttl;\n\nvoid init(){\n  for(int i=0;i<=100;i++) co[i] = MAX;\n}\n\nint Dijkstra(){\n  init();\n  int s,d;\n  cin >> s >> d >> ttl;\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(0,s));\n  co[s] = 0;\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int now = p.second,c = p.first;\n    if(now == d) return c + 1;\n    for(int i=0;i<info[now].size();i++){\n      edge e = info[now][i];\n      if(e.cost + c < co[e.to]){\n\tque.push(P(e.cost + c,e.to));\n\tco[e.to] = e.cost + c;\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    int r,k,tmp;\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> tmp;\n      info[r].push_back(edge(1,tmp));\n    }\n  }\n  cin >> m;\n  while(m--){\n    int d = Dijkstra();\n    if(d > ttl) cout << \"NA\" << endl;\n    else cout << d << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint root[101][101];\n\nint main(void){\n\tint n,m;\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\troot[i][j]=1000000;\n\t\t}\n\t\troot[i][i]=1;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\",&c);\n\t\t\troot[a][c]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\troot[j][k]=min(root[j][k],root[j][i]+root[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&m);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tif(c>=root[a][b]+1)printf(\"%d\\n\",root[a][b]+1);\n\t\telse printf(\"NA\\n\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n \n\n\n\nconst int MAX_V = 100;\n \nint d[MAX_V][MAX_V];\nint V;\n  \nvoid warshall_floyd_init(){\n    for(int i = 0; i < V; i++){\n        for(int j = 0; j < V; j++){\n            if(i == j) d[i][i] = 0;\n            else d[i][j] = INF;\n        }\n    }\n}\n \nvoid warshall_floyd() {\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n\n\n\n int main(){\n \tcin>>V;\n \twarshall_floyd_init();\n \tint r, k, t;\n \tfor(int i = 0; i < V; i++){\n \t\tcin>>r>>k;\n \t\tr--;\n \t\tfor(int j = 0; j < k; j++){\n \t\t\tcin>>t;\n \t\t\tt--;\n \t\t\td[r][t] = 1;\n \t\t}\n \t}\n \twarshall_floyd();\n\n \tint p;\n \tcin>>p;\n \tfor(int i = 0; i < p; i++){\n \t\tcin>>r>>k>>t;\n \t\tr--; k--;\n \t\tif(d[r][k] < t){\n \t\t\tcout<<d[r][k] + 1<<endl;\n \t\t}\n \t\telse cout<<\"NA\"<<endl;\n \t}\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nint main(){\n    using namespace std;\n\n    int n, M[101][101] = {};\n    cin >> n;\n    for(int i = 0; i < n; ++i){\n        int num, src;\n        cin >> src >> num;\n        for(int j = 0; j < num; ++j){\n            int dest;\n            cin >> dest;\n            M[src][dest] = 1;\n        }\n    }\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; ++i){\n        int src, dest, ttl, d[n + 1];\n        fill(d, d + n + 1, -1);\n\n        cin >> src >> dest >> ttl;\n        d[src] = 1;\n        queue<int> q;\n        q.push(src);\n        while(!q.empty()){\n            int const u = q.front();\n            q.pop();\n            for(int v = 1; v < n + 1; ++v){\n                if(M[u][v] == 1 && d[v] == -1){\n                    d[v] = d[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        if(ttl - d[dest] >= 0){\n            cout << d[dest];\n        }else{\n            cout << \"NA\";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n;\n  int r,k,t;\n  int p;\n  int s,d,b;\n  int ans=0;\n  int box[111][111];\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      box[i][j]=(1<<21);\n    }\n  }\n  for(int i=0;i<n;i++){\n    cin >> r >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      box[r-1][t-1]=1;\n    }\n  }\n  for(int z=0;z<n;z++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tbox[i][j]=min(box[i][j],box[i][z]+box[z][j]);\n      }\n    }\n  }\n  cin >> p;\n  for(int i=0;i<p;i++){\n    cin >> s >> d >> b;\n    ans=box[s-1][d-1]+1;\n    if(ans<=b){\n      cout << box[s-1][d-1]+1 << endl;\n    }else{\n      cout << \"NA\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  Graph g(n);\n  while(n--) {\n    int a;\n    cin >> a;\n    int s;\n    cin >> s;\n    while(s--) {\n      int d;\n      cin >> d;\n      g[a-1].push_back(Edge(a-1,d-1,1));\n    }\n  }\n  int m;\n  cin >> m;\n  while(m--) {\n    int s,d,t;\n    cin >>s>>d>>t;\n    vector<int> v;\n    shortestPath(g,s-1,v);\n    if (v[d-1]<t)\n      cout << v[d-1]+1 << endl;\n    else\n      cout << \"NA\"<< endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\nconst int INF = 1 << 20;\n\nint main()\n{\n    int n, p;\n\tcin >> n;\n\t\n\tvector<vint> G(n, vint(n, INF));\n\t\n\trep(i, n)\n\t{\n\t\tint r1, k1;\n\t\t\n\t\tcin >> r1 >> k1;\n\t\t\n\t\trep(j, k1)\n\t\t{\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\n\t\t\tG[r1 - 1][buf - 1] = 1;\n\t\t}\n\t}\n\t\n\t\n\trep(k, n) rep(i, n) rep(j, n)\n\t\tchmin(G[i][j], G[i][k] + G[k][j]);\n\t\n\t\n\tcin >> p;\n\t\n\trep(i, p)\n\t{\n\t\tint s1, d1, v1;\n\t\tcin >> s1 >> d1 >> v1;\n\t\t\n\t\tint cost = G[s1 - 1][d1 - 1];\n\t\t\n\t\tif(cost == INF || v1 <= cost)\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << cost + 1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[100][100];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<100;i++)\n\t\tfor(int j=0;j<100;j++)\n\t\t\tg[i][j]=99999999;\n\tfor(int i=0;i<a;i++)\n\t\tg[i][i]=0;\n\tfor(int i=0;i<a;i++){\n\t\tint b,c;\n\t\tscanf(\"%d%d\",&b,&c);\n\t\tfor(int j=0;j<c;j++){\n\t\t\tint d;\n\t\t\tscanf(\"%d\",&d);\n\t\t\tg[b-1][d-1]=1;\n\t\t}\n\t}\n\tfor(int k=0;k<a;k++)\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\tscanf(\"%d\",&a);\n\twhile(a--){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tr=min(r,10000);\n\t\t\n\t\tif(r<=g[p-1][q-1])printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",g[p-1][q-1]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <memory.h>\n\nint G[100][100] = {0}; // [from][to] = 0, 1\nint k[100];            // edgenum\nint n;\nint qhead = 0, qtail = 0;\nint queue[100];\nint cost[100], dat[100];\n\nvoid bfs(int);\nvoid PushQueue(int);\nint PopQueue();\nint isQueueEmpty();\n\nint main (void) {\n  int i, j;\n  int from_edge, to_edge;\n\n  scanf(\"%d\", &n);\n  \n  for(i = 0; i < n; i++) {\n    scanf(\"%d\", &from_edge);\n    scanf(\"%d\", &k[from_edge-1]);\n    for(j = 0; j < k[from_edge-1]; j++) {\n      scanf(\"%d\", &to_edge);\n      G[from_edge-1][to_edge-1] = 1;\n    }\n  }\n\n  //for (i = 0; i < n; i++) {\n  //  for (j = 0; j < n; j++) {\n  //    printf(\"%d \", G[i][j]);\n  //  }\n  //  printf(\"\\n\");\n  //}\n\n  int n_packet;\n  int from_node, to_node, ttl;\n\n  scanf(\"%d\", &n_packet);\n  \n  for (i = 0; i < n_packet; i++) {\n    scanf(\"%d\", &from_node);\n    scanf(\"%d\", &to_node);\n    scanf(\"%d\", &ttl);\n\n    cost[from_node-1] = 0;\n    qhead = 0; qtail = 0;\n    bfs(from_node);\n\n    //for (j = 0; j < n; j++) { printf(\"cost[%d] = %d\\n\", j, cost[j]); }\n\n    if (cost[to_node-1] < ttl) {\n      printf(\"%d\\n\", cost[to_node-1] + 1);  // senderの通過も含める\n    } else {\n      printf(\"NA\\n\");\n    }\n  }\n\n  return 0;\n}\n\nvoid bfs(int st_node) {\n  int i;\n  int u, v = st_node - 1;\n  int visited[n];\n\n  for (i = 0; i < n; i++) {\n    visited[i] = 0;\n  }\n  \n  PushQueue(v);\n  visited[v] = 1;\n\n  while(!isQueueEmpty()) {\n    u = PopQueue();\n    //printf(\"u:%d\\n\", u);\n    for(v = 0; v < n; v++) {\n      if(G[u][v] && !visited[v]) {\n\tPushQueue(v);\n\tcost[v] = cost[u] + 1;\n\tvisited[v] = 1;\n      }\n    }\n\n  }\n}\n\nvoid PushQueue(int num) {\n  queue[qtail] = num;\n  qtail++;\n}\nint PopQueue() {\n  int ret;\n\n  ret = queue[qhead];\n  qhead++;\n  return ret;\n}\n\nint isQueueEmpty() {\n  if (qtail == qhead) return 1; // Queue is empty.\n\n  return 0; // Queue exists.\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>R[105];\n\nint f(int s,int t,int v)\n{\n\tint flg[105][105],r=-1;\n\tmemset(flg,0x7f,sizeof(flg));\n\tpriority_queue<P>Q;\n\tQ.push(P(1,s));\n\tflg[s][s]=0;\n\tfor(;!Q.empty();)\n\t{\n\t\tP now=Q.top();Q.pop();\n\t\tif(now.second==t)\n\t\t{\n\t\t\tif(r==-1)r=now.first;\n\t\t\telse r=min(r,now.first);\n\t\t\tcontinue;\n\t\t}\n\t\tnow.first++;\n\t\tif(now.first>v)continue;\n\t\tint n=now.second;\n\t\tfor(int i=0;i<R[n].size();i++)\n\t\t{\n\t\t\tif(flg[s][R[n][i]]>now.first)\n\t\t\t{\n\t\t\t\tflg[s][R[n][i]]=now.first;\n\t\t\t\tQ.push(P(now.first,R[n][i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nint main()\n{\n\tint N,M,s,t,v,r;\n\tscanf(\"%d\",&N);\n\tfor(;N--;)\n\t{\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tfor(;t--;)\n\t\t{\n\t\t\tscanf(\"%d\",&v);\n\t\t\tR[s].push_back(v);\n\t\t}\n\t}\n\tscanf(\"%d\",&M);\n\tfor(;M--;)\n\t{\n\t\tscanf(\"%d%d%d\",&s,&t,&v);\n\t\tr=f(s,t,v);\n\t\tif(r!=-1)printf(\"%d\\n\",r);\n\t\telse puts(\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.*;\n\npublic class Main\n{\n    static final int inf = 99999;\n    int[][] a;\n\n    Main(){\n\tScanner sc = new Scanner(System.in);\n\tint n, m, s, t;\n\n\twhile(sc.hasNext()){\n\t    n = sc.nextInt();\n\t    a = new int[n+1][n+1];\n\n\t    for(int i = 0; i <= n; ++i)\n\t\tfor(int j = i+1; j <= n; ++j)\n\t\t    a[i][j] = a[j][i] = inf;\n\n\t    for(int i = 0; i < n; ++i){\n\t\ts = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tfor(int j = 0; j < m; ++j){\n\t\t    t = sc.nextInt();\n\t\t    a[s][t] = 1;\n\t\t}\n\t    }\n\n\t    for(int k = 1; k <= n; ++k)\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t    for(int j = 1; j <= n; ++j)\n\t\t\ta[i][j] = Math.min(a[i][j], a[i][k]+a[k][j]);\n\n\t    n = sc.nextInt();\n\t    for(int i = 0; i < n; ++i){\n\t\ts = sc.nextInt();\n\t\tt = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(a[s][t] < u)\n\t\t    System.out.println(Integer.toString(a[s][t]+1));\n\t\telse\n\t\t    System.out.println(\"NA\");\n\t    }\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <climits>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint main() {\n\tint n, p, r, k, t, s, d, v;\n\tcin >> n;\n\tint m[100][100] = {};\n\trep(i,n) {\n\t\tcin >> r >> k;\n\t\trep(j,k) {\n\t\t\tcin >> t;\n\t\t\tm[r-1][t-1] = 1;\n\t\t}\n\t}\n\tint ret[100][100] = {};\n\trep(i,100) {\n\t\tret[i][i] = 1;\n\t}\n\trep(i,n) {\n\t\tqueue<int> q;\n\t\tq.push(i);\n\t\twhile(!q.empty()) {\n\t\t\tint a = q.front(); q.pop();\n\t\t\trep(j,n) {\n\t\t\t\tif(m[a][j] && ret[i][j]==0) {\n\t\t\t\t\tq.push(j);\n\t\t\t\t\tret[i][j] = ret[i][a]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcin >> p;\n\trep(i,p) {\n\t\tcin >> s >> d >> v;\n\t\t--s,--d;\n\t\tif(ret[s][d] > v || ret[s][d] == 0) cout<< \"NA\" << endl;\n\t\telse cout << ret[s][d] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int IINF = INT_MAX;\n\nint main() {\n    int n, d[105][105];\n    while(cin >> n){\n        for(int i=0;i<n;i++) fill(d[i], d[i]+n, IINF/3);\n        for(int i=0;i<n;i++){\n            int r, k;\n            cin >> r >> k;\n            r--;\n            for(int j=0;j<k;j++){\n                int t;\n                cin >> t;\n                t--;\n                d[r][t] = 1;\n            }\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n        int p;\n        cin >> p;\n        for(int i=0;i<p;i++){\n            int s, g, v;\n            cin >> s >> g >> v;\n            s--; g--;\n            if(d[s][g] < v){\n                cout << d[s][g]+1 << endl;\n            }\n            else{\n                cout << \"NA\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n int use[100],d[100][100],rn,pn,i,j,to,fr,s1,d1,v1,a,b,c,n;\n for (i=0;i<100;i++) for (j=0;j<100;j++) { d[i][j]=999999999; use[i]=0;}\n cin >> n;\n for (i=0;i<n;i++) {\n   cin >> to >> rn; \n   for (j=0;j<rn;j++) { cin >> fr; d[to-1][fr-1]=1; use[to-1]=1; use[fr-1]=1;}\n }\n for (a=0;a<100;a++) for (b=0;b<100;b++) for (c=0;c<100;c++) \n     if (use[a]==1 && use[b]==1 && use[c]==1) d[b][c]=min(d[b][c],d[b][a]+d[a][c]); \n cin >> pn;\n for (i=0;i<pn;i++) {\n   cin >> s1 >> d1 >> v1;\n   if (d[s1-1][d1-1]>v1-1) cout << \"NA\"; else cout << d[s1-1][d1-1]+1;\n   cout << endl;\n }\nreturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\n\nint main(){\n    int n; cin >>n;\n    vector< vector<int> > v(n, vector<int>());\n    REP(i, n){\n        int s, nn; cin >>s >>nn; s--;\n        REP(j, nn){\n            int e; cin >>e; e--;\n            v[s].push_back(e);\n        }\n    }\n\n    int c; cin >>c;\n    REP(i, c){\n        int s, e, t; cin >>s >>e >>t; s--; e--;\n        queue<P> open;\n        open.push( P(s, t) );\n        vector<int> closed(n, -1);\n\n        while(!open.empty()){\n            P now = open.front(); open.pop();\n            int place = now.first, ttl = now.second;\n            if(ttl <= 0 || ttl <= closed[place]) continue;\n            closed[place] = ttl;\n            int s = v[place].size();\n            REP(i, s) open.push( P(v[place][i], ttl - 1) );\n        }\n        if(closed[e] == -1) cout <<\"NA\" <<endl;\n        else cout <<t - closed[e] + 1 <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 5000;\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\nconst int INF = 100000000;\n\nint prevv[MAX_V];\n\nclass Situation{\npublic:\n\tint ttl;\n\tint node;\n\tint dist;\n\n\tSituation();\n\tSituation(int ttl_,int node_,int dist_){\n\t\tttl=ttl_;\n\t\tnode=node_;\n\t\tdist=dist_;\n\t}\n\n\tbool operator<(const Situation &sit)const{\n\t\treturn sit.dist > this->dist;\n\t}\n};\n\nvoid dijkstra(int s,int ttl){\n\tpriority_queue<Situation > que;\n\tfill(d,d+MAX_V,INF);\n\td[s] = 0;\n\tque.push(Situation(ttl,s,0));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.node;\n\t\tif(d[v] < p.dist)\n\t\t\tcontinue;\n\t\tif(ttl<=1)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(ttl-1,e.to,d[e.to]));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tint from;\n\t\tcin>>from;\n\t\tint m;\n\t\tcin>>m;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint to;\n\t\t\tcin>>to;\n\t\t\tedge e;\n\t\t\te.cost=1;\n\t\t\te.to=to;\n\t\t\tG[from].push_back(e);\n\t\t}\n\t}\n\tint l;\n\tcin>>l;\n\tfor(int j = 0; j < l; j++){\n\t\tint s,dd,v;\n\t\tcin>>s>>dd>>v;\n\t\tdijkstra(s,v);\n\t\tif(d[dd]==INF)\n\t\t\tcout<<\"NA\"<<endl;\n\t\telse\n\t\t\tcout<<d[dd]+1<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int , int> pii;\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\nconst int INF = 1<<30;\n\nint n ;\nvector<int> way[120];\n\nint mini(int s,int d,int v);\n\nint main(void){\n  cin>>n;\n  rep(i,n){\n    int r,k;\n    cin>>r>>k;\n    while(k--){\n      int t;\n      cin>>t;\n      way[r].push_back(t);\n    }\n  }\n  int p;\n  cin>>p;\n  \n  while(p--){\n    int s,d,v;\n    cin>>s>>d>>v;\n    int cost = mini(s,d,v);\n    if(cost == INF) cout<< \"NA\" << endl;\n    else cout<< cost << endl;\n  }\n  return 0;\n  \n  \n}\nint mini(int s, int d, int v)\n{\n    int diff[128];\n    queue<pii> q;\n     \n    fill(diff, diff + n + 1, INF);\n    q.push(pii(s, 1));\n    diff[s] = 1;\n    while (!q.empty()){\n        pii p = q.front(); q.pop();\n         \n        if (diff[p.first] < p.second) continue;\n        for (int i = 0; i < way[p.first].size(); i++){\n            int tmp = way[p.first][i];\n             \n            if (diff[tmp] > diff[p.first] + 1){\n                diff[tmp] = diff[p.first] + 1;\n                q.push(pii(tmp, diff[tmp]));\n            }\n        }\n    }\n     \n    if (diff[d] == INF || diff[d] > v) return INF;\n    else return diff[d];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 99999999;\nstruct SEdge\n{\n\tint To;\n\tint Cost;\n};\nvector<int> d;\nvector< vector<SEdge> > G;\n\nvoid Dijkstra(int s)\n{\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > PQue;\n\tPQue.push(P(0, s));\n\twhile(!PQue.empty())\n\t{\n\t\tP p = PQue.top();\n\t\tPQue.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 0; i < G[v].size(); ++i)\n\t\t{\n\t\t\tSEdge e = G[v][i];\n\t\t\tif(d[e.To] > d[v] + e.Cost)\n\t\t\t{\n\t\t\t\td[e.To] = d[v] + e.Cost;\n\t\t\t\tPQue.push(P(d[e.To], e.To));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\td.resize(n);\n\tG.resize(n);\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tint From, To_Size;\n\t\tcin >> From >> To_Size;\n\t\t--From;\n\t\tvector<int> Vec(To_Size);\n\t\tfor(int j = 0; j < To_Size; ++j)\n\t\t{\n\t\t\tcin >> Vec[j];\n\t\t\t--Vec[j];\n\t\t\tSEdge e;\n\t\t\te.To = Vec[j];\n\t\t\te.Cost = 1;\n\t\t\tG[From].push_back(e);\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor(int i = 0; i < p; ++i)\n\t{\n\t\tint s, g, vp;\n\t\tcin >> s >> g >> vp;\n\t\t--s;\n\t\t--g;\n\t\tDijkstra(s);\n\t\tif(d[g] + 1 <= vp)\n\t\t{\n\t\t\tcout << d[g] + 1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\nint n,a,b,c,p;\nvector <int> t[100][100];\nint u[100][100];\nint no[100],in[100];\nint in2[100][100];\nint INF = (1<<24);\n\nint change(int x){\n  for(int i=0;i<n;i++)if(no[i]==x)return i;\n}\nvector<int> x,z;\n\n\nint main(){\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++){\n      u[i][j]=(i==j?0: INF );\n      if(i==j)continue;\n      t[i][j].push_back(i);\n      t[i][j].push_back(j);\n    }\n  cin>>n;\n\n  for(int i=0;i<n;i++){\n    cin>>no[i];\n    cin>>in[i];\n    for(int j=0;j<in[i];j++){\n      cin>>in2[i][j];\n    }\n  }\n  \n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<in[i];j++){\n     u[i][change(in2[i][j])]=1;\n    }\n  }\n\n  \n\n\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(u[i][k]+u[k][j]<u[i][j]){\n\t  u[i][j]=u[i][k]+u[k][j];\n\n\t  /*\n\t  t[i][j].clear();\n\t  x=t[i][k];\n\t  z=t[k][j];\n\t  for(int l=0;l<(int)x.size();l++)t[i][j].push_back(x[l]);\n\t  t[i][j].push_back(no[j]);\n\t  for(int l=0;l<(int)z.size();l++)t[i][j].push_back(z[l]);\n\t  */\n\t}\n      }\n    }\n  }\n  cin>>p;\n  while(p--){\n    cin>>a>>b>>c;\n    if(u[change(a)][change(b)]+1>c)cout<<\"NA\"<<endl;\n    else{\n      cout<<u[change(a)][change(b)]+1<<endl;\n      /*cout<<t[change(a)][change(b)].size()<<endl;\n      \n      for(int i=0;i<(int)t[change(a)][change(b)].size();i++){\n\tif(i)cout<<' ';\n\tcout<<t[change(a)][change(b)][i];\n      }\n      cout<<endl;\n      */\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint n,i,j,k,a,b,c,cost[101][101];\n\tchar cc;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) cost[i][j] = 1<<15;\n\t\tcin>>a>>b;\n\t\tfor(j=0;j<b;j++){\n\t\t\tcin >> c;\n\t\t\tcost[a][c]=1;\n\t\t}\n\t}\n\tfor(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++)\n\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b>>c;\n\t\tif(cost[a][b]<c && cost[a][b]<1<<15) cout << cost[a][b]+1 << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = 1000;\n\nint main()\n{\n    int n, p;\n    cin >> n;\n    int w[n+1][n+1];\n    for(int i = 1; i <= n; i++) \n        for(int j = 1; j <= n; j++) \n            w[i][j] = (i==j) ? 0 : INF;\n\n    int r,k,t;\n    for(int i = 1; i <= n; i++) {\n        cin >> r >> k;\n        for(int j = 0; j < k; j++) {\n            cin >> t;\n            w[r][t] = 1;\n        }\n    }\n\n    for(int k = 1; k <= n; k++) {\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) {\n                w[i][j] = min(w[i][j], w[i][k] + w[k][j]);\n            }\n        }\n    }\n    \n    cin >> p;\n    int s,d,v;\n    for(int i = 0; i < p; i++) {\n        cin >> s >> d >> v;\n        if(w[s][d] + 1 <= v) {\n            cout << w[s][d] + 1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nint wf[110][110];\n\nint main(){\n    int n, p;\n    REP(i,110){\n        REP(j,110) wf[i][j] = 1<<29;\n        wf[i][i] = 0;\n    }\n    cin >> n;\n    REP(i,n){\n        int r, k, t;\n        cin >> r >> k;\n        REP(j,k){\n            cin >> t;\n            wf[r-1][t-1] = 1;\n        }\n    }\n    REP(k,n) REP(i,n) REP(j,n){\n        if(wf[i][j] > wf[i][k] + wf[k][j]) wf[i][j] = wf[i][k] + wf[k][j];\n    }\n\n    cin >> p;\n    REP(i,p){\n        int s,d,v;\n        cin >> s >> d >> v;\n        int step = wf[s-1][d-1];\n        if(step == 1<<29 || step >= v){\n            cout << \"NA\" << endl;\n        } else {\n            cout << step+1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dp[110][110];\nint n;\nvoid WF(){\n\tlol(k,n){\n\t\tlol(i,n){\n\t\t\tlol(j,n){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tcin>>n;\n\tlol(i,n)lol(j,n)dp[i][j]=mod;\n\tlol(i,n){\n\t\tint r,k;cin>>r>>k;r--;\n\t\twhile(k--){\n\t\t\tint a;cin>>a;a--;\n\t\t\tdp[r][a]=1;\n\t\t}\n\t}\n\tWF();\n\tint q;cin>>q;\n\twhile(q--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;a--,b--;\n\t\tint tmp=dp[a][b]+1;\n\t\tif(tmp<=c)cout<<tmp<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n#define INFTY 2000000000\n\nint n,u,k;\nint s,d,v,TTL;\nint M[101][101],D[101];\n\nvoid bfs( int s ){\n  \n  queue <int> Q;\n  for( int i = 1; i <= n; i++ ) D[i] = INFTY;\n\n  D[s] = 1;\n  Q.push(s);\n     \n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    for( int l = 1; l <= n; l++ ){\n      if( M[u][l] == 0 ) continue;\n      if( D[l] != INFTY ) continue;\n      D[l] = D[u] + 1;\n      // cout << \"l\" << \" \" << l << \" \" <<  \"D[l]\" << \" \" << D[l] << \" \" <<\n      // \t\"D[u]\" << \" \" << D[u] << endl;\n      Q.push(l);\n\n      if ( D[l] > TTL ){\n\tcout << \"NA\" << endl;\n\treturn;\n      }else if( l == d ){\n\tcout << D[l] << endl;\n\t//\tcout << \"TTL\" << \" \" << TTL << endl;\n\treturn;\n      }\n\n    }\n\n  }\n \n}\n\nint main(){\n  cin >> n;\n  for( int i = 1; i <= n; i++ ){\n    cin >> u;\n    cin >> k;\n    for( int j = 0; j < k; j++ ){\n      int v;\n      cin >> v;\n      M[u][v] = 1;\n    }\n  }\n    \n  int p; cin >> p; \n  for( int i = 0; i < p; i++ ){\n  cin >> s >> d >> TTL;\n  bfs(s);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int maxv=100000;\nint main()\n{\n\tint root[101][101];\n\tfor(int i=0;i<10;i++){\n\t\tfor(int i2=0;i2<10;i2++){\n\t\t\troot[i][i2]=maxv;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tint r,k,ch;\n\tcin>>r>>k;\n\t\tfor(int i2=0;i2<k;i2++){\n\t\t\tcin>>ch;\n\t\t\troot[r][ch]=1;\n\t\t}\n\t}\n\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int i2=01;i2<=n;i2++){\n\t\t\t\troot[i][i2]=min(root[i][i2],root[i][k]+root[k][i2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint m;\n\tint s,d,v;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>s>>d>>v;\n\t\tif(root[s][d]<v){\n\t\t\tcout<<root[s][d]+1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* ????????????????????????????????????????????? */\n#include <stdio.h>\n\n/* ?????°???????????? */\ntypedef\tvoid\t\t\tVD;\ntypedef\tsigned char\t\tI1;\ntypedef unsigned char \tU1;\ntypedef\tsigned short\tI2;\ntypedef unsigned short \tU2;\ntypedef\tsigned int\t\tI4;\ntypedef unsigned int \tU4;\n\n/* ?????°?????? */\n#define MAX_ROUTER 100\n#define MAX_TTL 10000\n\n#define CONNECT 1\n#define DISCONNECT 0\n#define SENTINEL -1\n\n#define TRUE 1\n#define FALSE 0\n\n#define INPUT_SUCCESS 0\n#define INPUT_ERORR -1\n\n/* ????????????????????£?¨? */\nVD setInit(VD);\nI1 inputConnectInfo(VD);\nI1 inputTransmitPacket(VD);\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL);\n/* ??°?????????????????° */\nI1 u1Connect[MAX_ROUTER+1][MAX_ROUTER+1];\nI4 i4RouterNum;\n\n/* main??? */\nI4 main(VD)\n{\n\tI1 i1ErrorCheck;\n\tI4 i4CalcNum;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tsetInit();\n\ti1ErrorCheck = inputConnectInfo();\n\tif(i1ErrorCheck == INPUT_SUCCESS){\n\t\tscanf(\"%d\",&i4CalcNum);\n\t\tfor( i4RoopCnt1=0; i4RoopCnt1<i4CalcNum; i4RoopCnt1++)\n\t\t{\n\t\t\tinputTransmitPacket();\n\t\t}\n\t}\n\telse{\n\t\t;\n\t}\n\treturn 0;\n}\n\n/* ???????????¢??° */\nVD setInit(VD)\n{\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\t\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++)\n\t{\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++)\n\t\t{\n\t\t\tu1Connect[i4RoopCnt1][i4RoopCnt2] = DISCONNECT;\n\t\t}\n\t}\n\treturn;\n}\n\n/* ??????????????\\?¶??????±??\\?????¢??° */\nI1 inputConnectInfo(VD)\n{\n\tI1 i1Return;\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RouterCnt;\n\tI4 i4ConnectNum;\n\tI4 i4AccessPoint;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d\",&i4RouterNum);\n\tif(i4RouterNum <= (I4)MAX_ROUTER){\n\t\tfor( i4RoopCnt1=1; i4RoopCnt1<=i4RouterNum; i4RoopCnt1++){\n\t\t\tscanf(\"%d%d\",&i4RouterCnt,&i4ConnectNum);\n\t\t\tfor( i4RoopCnt2=0; i4RoopCnt2<i4ConnectNum; i4RoopCnt2++){\n\t\t\t\tscanf(\"%d\",&i4AccessPoint);\n\t\t\t\tu1Connect[i4RouterCnt][i4AccessPoint] = CONNECT;\n\t\t\t}\n\t\t\tu1Connect[i4RouterCnt][i4RouterNum+1] = SENTINEL;\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ???????????±???????????±??\\?????¢??° */\nI1 inputTransmitPacket(VD)\n{\n\tI1 i1Return;\n\tI4 i4StartRouter;\n\tI4 i4GoalRouter;\n\tI4 i4TTL;\n\tI4 i4Ans;\n\t\n\ti1Return = INPUT_SUCCESS;\n\t\n\tscanf(\"%d%d%d\",&i4StartRouter,&i4GoalRouter,&i4TTL);\n\tif(i4TTL <= MAX_TTL){\n\t\ti4Ans = CalcSumRouter(i4StartRouter,i4GoalRouter,i4TTL);\n\t\tif(i4Ans > 0){\n\t\t\tprintf(\"%d\\n\",i4Ans);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\telse{\n\t\ti1Return = INPUT_ERORR;\n\t}\n\treturn i1Return;\n}\n\n/* ??????????????????????¨????????????°?¨??????¢??° */\nI4 CalcSumRouter(I4 i4Sender,I4 i4Destination,I4 i4TTL)\n{\n\t/* ?????°??£?¨? */\n\tI1 i1StarTable[MAX_ROUTER+1][MAX_ROUTER+1];\t/* ????????¨ */\n\tI4 i4MinVal[MAX_ROUTER+1];\n\tI4 i4RoopCnt1;\n\tI4 i4RoopCnt2;\n\tI4 i4RoopCnt3;\n\tI4 i4RoopMax;\n\t\n\t/* ????????? */\n\tfor( i4RoopCnt1=1; i4RoopCnt1<=MAX_ROUTER; i4RoopCnt1++){\n\t\ti4MinVal[i4RoopCnt1] = 0;\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++){\n\t\t\ti1StarTable[i4RoopCnt1][i4RoopCnt2] = FALSE;\n\t\t}\n\t}\n\t\n\tif(i4TTL<=MAX_ROUTER){\n\t\ti4RoopMax = i4TTL;\n\t}\n\telse{\n\t\ti4RoopMax == MAX_ROUTER;\n\t}\n\t\n\ti1StarTable[1][i4Sender] = TRUE;\n\t\n\tfor(i4RoopCnt1=1; i4RoopCnt1<i4RoopMax; i4RoopCnt1++){\n\t\tfor(i4RoopCnt2=1; i4RoopCnt2<=MAX_ROUTER; i4RoopCnt2++){\n\t\t\tif(i1StarTable[i4RoopCnt1][i4RoopCnt2] == TRUE){\n\t\t\t\tfor(i4RoopCnt3=1; i4RoopCnt3<=MAX_ROUTER; i4RoopCnt3++){\n\t\t\t\t\tif(u1Connect[i4RoopCnt2][i4RoopCnt3] == CONNECT){\n\t\t\t\t\t\tif(i4RoopCnt3 == i4Destination){\n\t\t\t\t\t\t\treturn i4RoopCnt1+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti1StarTable[i4RoopCnt1+1][i4RoopCnt3] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include <map>\n#include <queue>\n#include<string.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint node[200][200];\n\nint que(int s,int d,int v)\n{\n  queue<P> qu;\n  int c[200];\n  memset(c,-1,sizeof(c));\n  for(int i=0;i<200;i++)\n    {\n      if(v-1>0)\n\tif(node[s][i]==1)\n\t  qu.push(P(i,v-1));\n    }\n  while(!qu.empty())\n    {\n      P a = qu.front();\n      qu.pop();\n      //      cout<<a.first<<\" \"<<a.second<<endl;\n      if(a.first==d)\n\treturn v-a.second+1;\n      for(int i=0;i<200;i++)\n\t{\n\t  if(node[a.first][i]==1)\n\t    {\n\t      if(a.second-1>0)\n\t\t{\n\t\t  if(c[i]==-1)\n\t\t    {\n\t\t      c[i]=a.second-1;\n\t\t      qu.push(P(i,a.second-1));\t    \n\t\t    }\n\t\t}\n\t    }\n\t} \n    }\n      return -1;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  memset(node,-1,sizeof(node));\n  for(;n--;)\n    {\n      int k,t;\n      cin>>k>>t;\n      for(int i=0;i<t;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  node[k][tmp]=1;\n\t}\n    }\n  int p;\n  cin>>p;\n  for(;p--;)\n    {\n      int s,d,v;\n      cin>>s>>d>>v;\n      int ans=que(s,d,v);\n      if(ans==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<ans<<endl;\n      \n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define pb push_back \n\nint bfs(int s, int t, int c);\n\nvector<vector<int> > g(101);\n\nint main()\n{\n    int n;\n    cin >> n;\n    loop(i, n) {\n        int r, k, t;\n        cin >> r >> k;\n        loop(j, k) {\n            cin >> t;\n            g[r].pb(t);\n        }\n    }\n    int p;\n    cin >> p;\n    loop (i, p) {\n        int s, d, v;\n        cin >> s >> d >> v;\n        int ans = bfs(s, d, v);\n        if (ans != -1) {\n            cout << v-ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\nint bfs(int s, int t, int c)\n{\n    queue<int> fq, nq, sq;\n    fq.push(s);\n    while (1) {\n        c--;\n        while (!fq.empty()) {\n            int pos = fq.front(); fq.pop();\n            //cout << pos << endl;\n            if (pos == t) {\n                return c;\n            } else {\n                for (int i: g[pos]) {\n                    nq.push(i);\n                }\n            }\n        }\n        if (c == 0) {\n            return -1;\n        }\n        fq = nq;\n        nq = sq;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N_MAX = 100;\nconst int INF = 0x7fffff;\n\nclass Node {\npublic:\n\tint pos, ttl;\n\tNode(int p, int t) : pos(p), ttl(t) {}\n};\n\nint n;\n// adj[from][to] from->toの辺があるか\nbool adj[N_MAX + 1][N_MAX + 1];\nint visited[N_MAX + 1];\n\nvoid bfs(int src, int dst, int limit) {\n\tqueue<Node> que;\n\tfill(visited, visited + n + 1, INF);\n\tque.push(Node(src, limit - 1));\n\twhile (!que.empty()) {\n\t\tNode current = que.front();\n\t\tque.pop();\n\t\tif (current.pos == dst) {\n\t\t\tcout << limit - current.ttl << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (visited[current.pos] <= current.ttl) continue;\n\t\tvisited[current.pos] = current.ttl;\n\t\tif (current.ttl == 0) continue;\n\t\tfor (int next = 1; next <= n; next++) {\n\t\t\tif (adj[current.pos][next] && visited[next] > current.ttl) {\n\t\t\t\tque.push(Node(next, current.ttl - 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfill(adj[r], adj[r] + n + 1, false);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tadj[r][t] = true;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tbfs(s, d, v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint main(){\n    int n;\n    cin>>n;\n    int d[200][200];\n    rep(i,200){\n        rep(j,200){\n            if(i==j)d[i][j] = 0;\n            else d[i][j] = 1<<20;\n        }\n    }\n    rep(i,n){\n        int src,k;\n        cin>>src>>k;\n        src--;\n        rep(j,k){\n            int dst;cin>>dst;\n            dst--;\n            d[src][dst] = 1;\n        }\n    }\n\n    rep(k,n)rep(i,n)rep(j,n){\n        d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n    }\n\n    int p;cin>>p;\n    rep(i,p){\n        int s, t, ttl;\n        cin >> s >> t >> ttl;\n        --s; --t;\n        if(d[s][t] >= ttl) puts(\"NA\");\n        else printf(\"%d\\n\", d[s][t] + 1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n\nusing namespace std;\n\ntypedef struct {\n  int *ks;\n  int length;\n} node;\n\nnode *nodes;\n\n\nint dikstra(int s, int e, int deep){\n  int c=0;\n\n  list<int> que;\n  que.push_back(s);\n\n  int flag = 1;\n\n  while(flag){\n    c++;\n    if(c >= deep) return -1;\n\n    int len = que.size();\n    for(int i=0;flag&&i<len;i++){\n      int v = que.front();\n      que.pop_front();\n      for(int j=0;flag&&j<nodes[v].length;j++){\n        if(nodes[v].ks[j]==e){\n\t  flag=0;\n        }else{\n\t  que.push_back(nodes[v].ks[j]);\n        }\n      }\n    }\n  }\n  return c+1;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n\n  nodes = new node[n];\n\n  int i,j;\n  int t,u,v;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\", &t,&u);\n    nodes[t-1].ks = new int[u];\n    nodes[t-1].length = u;\n    for(j=0;j<u;j++){\n      scanf(\"%d\", &v);\n      nodes[t-1].ks[j] = v-1;\n    }\n  }\n\n  int m;\n  scanf(\"%d\", &m);\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\", &t, &u, &v);\n    int r;\n    if((r=dikstra(t-1, u-1,v)) != -1) printf(\"%d\\n\", r);\n    else puts(\"NA\");\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconst int INF = 10000000;\n\nusing namespace std;\n\n/** Problem0144 : Packet Transportation **/\nint G[101][101];\nint V;\n\nint main()\n{\n\tint r, k, t;\n\t\n\trep(i, 101) rep(j, 101) G[i][j]=INF;\n\t\n\t\n\tcin >> V;\n\trep(i, V) {\n\t\tcin >> r >> k;\n\t\trep(j, k) {\n\t\t\tcin >> t;\n\t\t\tG[r-1][t-1]=1;\n\t\t}\n\t}\n\t\n\t// Warshall-Floyd法\n\trep(k, V)\n\t\trep(i, V)\n\t\t\trep(j, V)\n\t\t\t\tG[i][j] = min(G[i][j], G[i][k]+G[k][j]);\n\t\t\t\n\t\n\tint p, s, d, v;\n\tcin >> p;\n\t\n\trep(i, p) {\n\t\tcin >> s >> d >> v;\n\t\tif (G[s-1][d-1] < v)\n\t\t\tcout << G[s-1][d-1]+1 << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long  ll;\n\nconst int INF = 1e9;\n\nvoid WarshallFloyd(vector<vector<int>> &d) {\n    int n = d.size();\n\n    for (int k = 0; k < n; ++k)\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\nint main()\n{\n    int n, k, t, s, d, v;\n\n    cin >> n;\n    vector<vector<int>> g(n, vector<int>(n, INF));\n\n    for (int i = 0; i < n; ++i)\n        g[i][i] = 0;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> s >> k;\n        --s;\n        while (k--) {\n            cin >> t;\n            g[s][t - 1] = 1;\n        }\n    }\n\n    WarshallFloyd(g);\n\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> s >> d >> v;\n        --s, --d;\n        if (g[s][d] + 1 > v)\n            cout << \"NA\\n\";\n        else\n            cout << g[s][d] + 1 << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n\t_HT _OUT(H &&h, T... t){out(h);out(t...);}\n\ttemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n\tstruct range{\n\t\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\t\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\ntemplate <typename T>\nusing V = vector<T>;\n\nint main() {\n\tint n {in};\n\tV<V<int>> d(n, V<int>(n, INT_MAX / 2));\n\trange rn(n);\n\ttimes (i, n) {\n\t\tint t {(int) in - 1};\n\t\ttimes(j, in)\n\t\t\td[t][(int) in - 1] = 1;\n\t}\n\tfor (int k: rn)\n\t\tfor (int i: rn)\n\t\t\tfor (int j: rn)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\ttimes(i, in) {\n\t\tint s {(int) in - 1}, e {(int) in - 1}, v {in};\n\t\tif (d[s][e] < v)\n\t\t\toutl(d[s][e] + 1);\n\t\telse\n\t\t\toutl(\"NA\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\twent_num = 1;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t\twent_num++;\n\t}\n\n\tint ttl,checkTable[101],went_num,current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i <= n; i++){\n\t\tfor(int k=1; k <= n; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\n\n\n\t\twhile(!Q.empty() && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1 && tmp.went_num < n){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+1);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+1;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Packet{\n\tPacket(){}\n\n\tPacket(int arg_ttl,int loc){\n\t\tttl = arg_ttl;\n\t\tfor(int i=0; i < 101; i++)checkTable[i] = 0;\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tvoid set(int loc){\n\t\tcheckTable[loc] = 1;\n\t\tcurrent = loc;\n\t}\n\n\tint ttl,checkTable[101],current;\n};\n\nint main(){\n\n\tint n,r,k,to,table[101][101],num_of_packet,start,goal,t_limit,memo[101][101];\n\tPacket tmp;\n\n\tfor(int i=1; i < 101; i++){\n\t\tfor(int k=1; k < 101; k++){\n\t\t\ttable[i][k] = 0;\n\t\t\tmemo[i][k] = 0;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\",&r,&k);\n\t\tfor(int p=0;p < k; p++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\ttable[r][to] = 1;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_of_packet);\n\n\tqueue<Packet> Q;\n\tbool FLG;\n\n\tfor(int i=0; i < num_of_packet; i++){\n\t\tscanf(\"%d %d %d\",&start,&goal,&t_limit);\n\n\t\tFLG = false;\n\n\t\tif(memo[start][goal] != 0){\n\t\t\tif(memo[start][goal] <= t_limit){\n\t\t\t\tprintf(\"%d\\n\",memo[start][goal]);\n\t\t\t}else{\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i != start && table[start][i] == 1){\n\t\t\t\tif(memo[i][goal] > 0 && memo[i][goal] < t_limit){\n\t\t\t\t\tprintf(\"%d\\n\",memo[i][goal]+1);\n\t\t\t\t\tmemo[start][goal] = memo[i][goal]+1;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPacket p(t_limit-1,start);\n\t\t\t\tp.set(i);\n\t\t\t\tQ.push(p);\n\t\t\t}\n\t\t}\n\n\n\n\t\twhile(!Q.empty() && FLG == false){\n\t\t\ttmp = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(tmp.current == goal){\n\t\t\t\tprintf(\"%d\\n\",t_limit - tmp.ttl+1);\n\t\t\t\tFLG = true;\n\n\t\t\t\twhile(!Q.empty())Q.pop();\n\n\t\t\t\tmemo[start][goal] = t_limit - tmp.ttl+1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.ttl > 1){\n\t\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\t\tif(i != tmp.current && tmp.checkTable[i] == 0 && table[tmp.current][i] == 1){\n\t\t\t\t\t\tif(memo[i][goal] > 0 && (memo[i][goal]+1) < tmp.ttl){\n\t\t\t\t\t\t\tprintf(\"%d\\n\",t_limit-tmp.ttl+memo[i][goal]+2);\n\t\t\t\t\t\t\tmemo[start][goal] = t_limit-tmp.ttl+memo[i][goal]+2;\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\twhile(!Q.empty())Q.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPacket p = tmp;\n\t\t\t\t\t\tp.ttl--;\n\t\t\t\t\t\tp.set(i);\n\t\t\t\t\t\tQ.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n;\n\tint d[101][101];\n\tREP(i, 101)REP(j, 101) d[i][j] = (i == j ? 0 : INF);\n\tcin >> n;\n\tREP(i, n)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tREP(j, b)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tk--;\n\t\t\td[a][k] = 1;\n\t\t}\n\t}\n\tREP(k, 101)REP(i, 101)REP(j, 101) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\tint q;\n\tcin >> q;\n\twhile (q--)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tif (d[a][b] < c) cout << d[a][b]+1 << endl;\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint main()\n{\n    int n, p;\n    cin >> n;\n    int w[n+1][n+1];\n    for(int i = 1; i <= n; i++) \n        for(int j = 1; j <= n; j++) \n            w[i][j] = (i==j) ? 0 : INF;\n\n    int r,k,t;\n    for(int i = 1; i <= n; i++) {\n        cin >> r >> k;\n        for(int j = 0; j < k; j++) {\n            cin >> t;\n            w[r][t] = 1;\n        }\n    }\n\n    for(int k = 1; k <= n; k++) {\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) {\n                w[i][j] = min(w[i][j], w[i][k] + w[k][j]);\n            }\n        }\n    }\n    \n    cin >> p;\n    int s,d,v;\n    for(int i = 0; i < p; i++) {\n        cin >> s >> d >> v;\n        if(w[s][d] + 1 <= v) {\n            cout << w[s][d] + 1 << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint eg[101][101];\nint d[101][101];\nint const MAX=10000;\nint main(){\n    int n;\n    cin >> n;\n    for (int i=0;i<n;i++){\n        int nt;\n        cin >> nt;\n        string str;\n        getline(cin,str);\n        stringstream ss;\n        ss << str;\n        while (!ss.eof()){\n            int to;\n            ss >> to;\n            eg[nt][to]=1;\n        }\n    }\n    for(int f=1;f<=n;f++)for(int t=1;t<=n;t++){\n        d[f][t]=f==t?0:(eg[f][t]==1?1:MAX);\n    }\n    for(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){\n        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    }\n    int rn;\n    cin >> rn;\n    for (int i=0;i<rn;i++){\n        int from,to,ttl;\n        cin >> from >> to >> ttl;\n        if (d[from][to]+1>ttl)cout << \"NA\";\n        else cout << d[from][to]+1;\n        cout << endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<functional>\n#include<unordered_map>\nusing namespace std;\n\nvector<int>rinsetu[100]{};\nunordered_map<int, int>taiou;\nint main() {\n\tint a;\n\tcin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\ttaiou[c] = b;\n\t\tfor (int e = 0; e < d; e++) {\n\t\t\tint f; scanf(\"%d\", &f);\n\t\t\trinsetu[b].push_back(f);\n\t\t}\n\t}\n\tint b; cin >> b;\n\tfor (int c = 0; c < b; c++) {\n\t\tint g, h, i; scanf(\"%d%d%d\", &g, &h, &i);\n\t\tint e[100]{};\n\t\tmemset(e, -1, sizeof(e));\n\t\tqueue<int>Q;\n\t\te[taiou[g]] = 1;\n\t\tQ.push(g);\n\t\twhile (Q.size()) {\n\t\t\tint o = Q.front(); Q.pop();\n\t\t\to = taiou[o];\n\t\t\tif (e[o] > i)break;\n\t\t\tfor (int p : rinsetu[o]) {\n\t\t\t\tif (e[taiou[p]] == -1) {\n\t\t\t\t e[taiou[p]] = e[o] + 1; Q.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (e[taiou[h]] == -1||e[taiou[h]]>i)puts(\"NA\");\n\t\telse cout << e[taiou[h]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// 1 to 0-indexed\nvector<int> G[100];\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> Piii;\n\nint bfs(int S, int T, int TTL) {\n  \n  int memo[100];\n  memset(memo, -1, sizeof(memo));\n  memo[S] = 0;\n  queue<Piii> Q;\n  Q.push(Piii(0, Pii(S, TTL)));\n  while(!Q.empty()) {\n    \n    Piii piii = Q.front(); Q.pop();\n    \n    int cost = piii.first;\n    int now = piii.second.first;\n    int ttl = piii.second.second;\n    \n    if(now == T) return cost;\n    if(memo[now] < cost) continue;\n\n    if(ttl <= 1) continue;\n    \n    for(int i=0; i<G[now].size(); i++) {\n      int to = G[now][i];\n      if(memo[to] == -1) {\n\tmemo[to] = cost + 1;\n\tQ.push(Piii(cost+1, Pii(to, ttl-1)));\n      }\n    }\n  }\n  \n  return -1;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N) {\n    \n    for(int i=0; i<100; i++) G[i].clear();\n    \n    for(int i=0; i<N; i++) {\n      int r; cin >> r; r--;\n      int k; cin >> k;\n      for(int i=0; i<k; i++) {\n\tint x; cin >> x; x--;\n\tG[r].push_back(x);\n      }\n    }\n    \n    int Q; cin >> Q;\n    while(Q--) {\n      int s, t, v;\n      cin >> s >> t >> v; s--, t--;\n      int res = bfs(s, t, v);\n      if(res >= 0) {\n\tcout << res+1 << endl;\n      }\n      else {\n\tcout << \"NA\" << endl;\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int s = 0, int d = 0, Weight w = 0)\n    : src(s), dst(d), weight(w) {\n  }\n};\n\nusing Edges  = vector<Edge>;\nusing Graph  = vector<Edges>;\nusing Array  = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, const int &a, const int &b, const Weight &w = 1) {\n  g[a].emplace_back(a, b, w);\n}\n\nvoid addEdge(Graph &g, const int &a, const int &b, const Weight &w = 1) {\n  addArc(g, a, b, w);\n  addArc(g, b, a, w);\n}\n\n// deps: graph-basic\nMatrix warshallFloyd(const Graph &g) {\n  int n = g.size();\n  Matrix d(n, Array(n, INF));\n  rep(i, n) d[i][i] = 0;\n  rep(i, n) for (auto &e : g[i]) cmin(d[e.src][e.dst], e.weight);\n  rep(k, n) rep(i, n) rep(j, n) {\n    if (d[i][k] != INF && d[k][j] != INF) cmin(d[i][j], d[i][k] + d[k][j]);\n  }\n  return d;\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  Graph g(n);\n  while (n--) {\n    int r, k;\n    cin >> r >> k;\n    --r;\n    while (k--) {\n      int t;\n      cin >> t;\n      --t;\n      addArc(g, r, t);\n    }\n  }\n  Matrix t = warshallFloyd(g);\n  int p;\n  cin >> p;\n  while (p--) {\n    int s, d, v;\n    cin >> s >> d >> v;\n    --s, --d;\n    if (t[s][d] + 1 > v) {\n      cout << \"NA\" << endl;\n      continue;\n    }\n    cout << t[s][d] + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N_MAX = 100;\nconst int INF = 0x7fffff;\n\nclass Node {\npublic:\n\tint pos, ttl;\n\tNode(int p, int t) : pos(p), ttl(t) {}\n};\n\nint n;\n// adj[from][to] from->toの辺があるか\nbool adj[N_MAX + 1][N_MAX + 1];\nint visited[N_MAX + 1];\n\nvoid bfs(int src, int dst, int limit) {\n\tqueue<Node> que;\n\tfill(visited, visited + n + 1, INF);\n\tque.push(Node(src, limit - 1));\n\twhile (!que.empty()) {\n\t\tNode current = que.front();\n\t\tque.pop();\n\t\tif (current.pos == dst) {\n\t\t\tcout << limit - current.ttl << endl;\n\t\t\treturn;\n\t\t}\n\t\tif (current.ttl >= 0 && visited[current.pos] <= current.ttl) continue;\n\t\tvisited[current.pos] = current.ttl;\n\t\tif (current.ttl == 0) continue;\n\t\tfor (int next = 1; next <= n; next++) {\n\t\t\tif (adj[current.pos][next] && visited[next] > current.ttl && current.ttl > 0) {\n\t\t\t\tque.push(Node(next, current.ttl - 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NA\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k;\n\t\tcin >> r >> k;\n\t\tfill(adj[r], adj[r] + n + 1, false);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tadj[r][t] = true;\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\tbfs(s, d, v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int INF = 100;\nint d[100][100];\nvoid init()\n{\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tif(i == j){\n\t\t\t\td[i][j] = 0;\n\t\t\t}else{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tinit();\n\tfor(int i=0;i<n;i++){\n\t\tint a,m;\n\t\tcin >> a >> m;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\td[a-1][b-1] = 1;\n\t\t}\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint dis = d[i][k]+d[k][j];\n\t\t\t\tif(dis < d[i][j]){\n\t\t\t\t\td[i][j] = dis;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tcin >> p;\n\tfor(int j=0;j<p;j++){\n\t\tint a,b,pket;\n\t\tcin >> a >> b >> pket;\n\t\tif(d[a-1][b-1] >= pket)\n\t\t\tcout << \"NA\" << endl;\n\t\telse{\n\t\t\tcout << d[a-1][b-1]+1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint main() {\n\tvector<int> a[100];\n\tint b[100];\n\tbool l[100];\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, k, t;\n\t\tcin >> r >> k;\n\t\tr--;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\ta[r].push_back(t);\n\t\t}\n\t\tsort(a[r].begin(), a[r].end());\n\t}\n\tint p;\n\tcin >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tint s, d, v;\n\t\tcin >> s >> d >> v;\n\t\ts--;\n\t\td--;\n\t\tfill(b, b + n, 100000);\n\t\tb[s] = 0;\n\t\tfill(l, l + n, false);\n\t\tl[s] = true;\n\t\tint sum = 0;\n\t\tmultimap<int, int> m;\n\t\tfor (int j = 0; j < a[s].size(); j++) {\n\t\t\tm.insert(map<int, int>::value_type(1, a[s][j]));\n\t\t}\n\t\tmultimap<int, int>::iterator it = m.begin();\n\t\twhile (!l[d]) {\n\t\t\tit = m.begin();\n\t\t\tsum=(*it).first+1;\n\t\t\tif (sum > v) break;\n\t\t\tint e = (*it).second;\n\t\t\tm.erase(it);\n\t\t\tfor (int j = 0; j < a[e].size(); j++) {\n\t\t\t\tl[a[e][j]] = true;\n\t\t\t\tb[a[e][j]] = min(b[a[e][j]],sum);\n\t\t\t}\n\t\t}\n\t\tif (l[d]) {\n\t\t\tcout << b[d] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport Data.Foldable (foldMap)\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\nimport Data.Array\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n \nreadInt = read :: String -> Int\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\nfnBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\nfnBin op f g x = op (f x) $ g x\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nmodifyArray :: (Ix i, MArray a e m) => a i e -> i -> (e -> e) -> m ()\nmodifyArray arr ix f = readArray arr ix >>= writeArray arr ix . f\n-- end of templete\n\nwf :: IOUArray (Int,Int) Int -> [Int] -> IO ()\nwf arr range = do\n    forM_ range $ \\k -> do\n        forM_ range $ \\i -> do\n            forM_ range $ \\j -> do\n                t <- readArray arr (i, j)\n                u <- readArray arr (i, k)\n                v <- readArray arr (k, j)\n                when (u/=(-1) && v/=(-1)) $ do\n                    let w = u + v in when (t==(-1) || w<t) $ writeArray arr (i, j) w\n                    return ()\n\nmain = do\n    n <- getInt\n    arr <- newArray ((1,1),(n,n)) (-1) :: IO (IOUArray (Int,Int) Int)\n    replicateM_ n $ do\n        (r:k:ts) <- getInts\n        writeArray arr (r,r) 0\n        forM_ ts $ \\t -> writeArray arr (r,t) 1\n    wf arr [1..n]\n    p <- getInt\n    replicateM_ p $ do\n        [s, d, v] <- getInts\n        x <- (+1) <$> readArray arr (s, d)\n        putStrLn $ cond (show x) \"NA\" $ v>=x && x/=0"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\nint main(){\n\tint n,m,c[105][105],d[105],used[105],i,j,x,y,z,v;\n\tmemset(c,0,sizeof(c));\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)c[i][j]=1000000;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(j=0;j<y;j++){\n\t\t\tscanf(\"%d\",&z);\n\t\t\tc[x][z]=1;\n\t\t}\n\t}\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t//memset(d,-1,sizeof(d));\n\t\tfor(i=1;i<=n;i++)d[i]=1000000;\n\t\tmemset(used,0,sizeof(used));\n\t\td[x]=0;\n\t\twhile(1){\n\t\t\tv=-1;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(used[i]==0 && (v==-1 || d[v]>d[i]))v=i;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=1;\n\t\t\t//printf(\"%d:%d\\n\",v,d[v]);\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\td[i]=min(d[i],d[v]+c[v][i]);\n\t\t\t}\n\t\t}\n\t\tif(d[y]+1>z)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",d[y]+1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint Q[101],head=0,tail=0,n,t[101][101],d[101],k[100];\nvoid enqueue(int x){\n  Q[tail++]=x;\n}\nint dequeue(){\n  return Q[head++];\n}\nvoid bfs(int s){\n  int u,v,w;\n  for(v=0;v<=n;v++) d[v]=10000;\n  d[s]=0;\n  enqueue(s);\n  while(head!=tail){\n    u=dequeue();\n    for(v=0;v<=n;v++){\n\tif(t[u][v]==1&&d[v]==10000){\n\t  d[v]=d[u]+1;\n\t  enqueue(v);\n      }\n    }\n  }\n}\n\nmain(){\n  int p,i,j,s,dd,TTL,r[100],m,tt[101][101];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\",&r[i],&k[i]);\n    for(j=0;j<k[i];j++){\n      tt[r[i]][j]=10000;\n      scanf(\"%d\",&tt[r[i]][j]);\n    }\n  }\n  for(i=0;i<=n;i++){\n    for(j=0;j<=n;j++){\n      t[i][j]=0;\n    }\n  }\n\n  for(i=0;i<=n;i++){\n    for(j=0;j<k[i];j++){\n      for(m=0;m<=n;m++){\n\tif(tt[r[i]][j]==m) t[r[i]][m]=1;\n      }\n    }\n  }\n\n\n  scanf(\"%d\",&p);\n  for(i=0;i<p;i++){\n    scanf(\"%d%d%d\",&s,&dd,&TTL);\n    bfs(s);\n\n    if(d[dd]<TTL) printf(\"%d\\n\",d[dd]+1);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 10000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 10000;\n    for(i = 0; i < 100; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 10000) break;\n    f[p] = 1;\n\n    for(i = 0; i < 100; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, r1, k1, p, temp;\n  int pacet[100][3];\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 10000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &pacet[i][0], &pacet[i][1], &pacet[i][2]);\n  }\n\n  for(i = 0; i < p; i++) {\n    temp = dijkstra(pacet[i][0], pacet[i][1]);\n    if(pacet[i][2] - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,i,j,k,min,mi,a,b,m;\n  int d[101][101]={0};\n  int c[101][101]={0};\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&a,&m);\n    while(m--){\n      scanf(\"%d\",&b);\n      d[a][b]=1;\n    }\n  }\n  for(i=1;i<=n;i++){\n    c[mi=i][i]=0;\n    int f[101]={0};\n    for(j=0;j<n;j++){\n      f[mi]=1;\n      for(k=1;k<=n;k++){\n\tif(f[k]||d[mi][k]==0)continue;\n\tif(c[i][k]==0||c[i][k]>c[i][mi]+1)c[i][k]=c[i][mi]+1;\n      }\n      min=2100000000;\n      for(k=1;k<=n;k++){\n\tif(f[k]||c[i][k]==0)continue;\n\tif(min>c[i][k])min=c[i][mi=k];\n      }\n    }\n    //for(j=0;j<n;j++)printf(\"%d \",c[i][j+1]);printf(\"\\n\");\n  }\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%d %d %d\",&a,&b,&k);\n    if(c[a][b]<k&&c[a][b])printf(\"%d\\n\",c[a][b]+1);\n    else                  printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 10000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 10000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 10000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, r1, k1, p, temp;\n  int pacet[100][3];\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 10000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &pacet[i][0], &pacet[i][1], &pacet[i][2]);\n  }\n\n  for(i = 0; i < p; i++) {\n    temp = dijkstra(pacet[i][0], pacet[i][1]);\n    if(pacet[i][2] - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m;\nint t[101][101];\n\nint que[2000];\nint qa,qb;\n\nint calc(int start,int goal){\n  int i,pos;\n  int visited[101];\n  int cost[101];\n  \n  for(i=0;i<101;i++){\n    visited[i]=0;\n    cost[i]=0;\n  }\n  qa=0;\n  qb=1;\n  que[0]=start;\n  visited[start]=1;\n  \n  while(qa<qb){\n    pos=que[qa];\n    qa++;\n    if(pos==goal)return cost[pos];\n    \n    for(i=1;i<=n;i++){\n      if(t[pos][i]==0)continue;\n      if(visited[i]==1)continue;\n      visited[i]=1;\n      que[qb]=i;\n      qb++;\n      cost[i]=cost[pos]+1;\n    }\n  }\n  return 9999;\n}\n\nint main(){\n  int i,j;\n  int id,k,l;\n  int s,d,v;\n  int ans;\n  \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&id,&k);\n    for(j=0;j<k;j++){\n      scanf(\"%d\",&l);\n      t[id][l]=1;\n    }\n  }\n\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d\",&s,&d,&v);\n    ans=calc(s,d)+1;\n    if(ans<=v||ans==10000)printf(\"%d\\n\",ans);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 10000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 10000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 10000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, r1, k1, p, s1, d1, v1, temp;\n  int pacet[100][3];\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 10000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &s1, &d1, &v1);\n    temp = dijkstra(s1, d1);\n    if(v1 - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????????????????±????´????????????????????????? */\n\ts4_t_oi = (S4)0;\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\", s4_tp_result[s4_t_oi2]);\n\t\t}\n\n\t\t/* ????????\\?????????????????? */\n\t\tif (s4_t_oi2 != s4_t_oi - 1) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100], d[100], f[100];\n\nint dijkstra(int s, int g){\n  int min, p, i, j;\n  for(i=0;i<100;i++){\n    d[i]=100000;\n    f[i]=0;\n  }\n  d[s]=0;\n  while(1){\n    min=100000;\n    for(i=0;i<100;i++){\n      if(d[i]<min && f[i]==0){\n\tmin=d[i];\n\tp=i;\n      }\n    }\n    \n    if(min==100000) break;\n    f[p]=1;\n    for(j=0;j<100;j++){\n      if(r[p][j]==1){\n\tif(d[p]+r[p][j]<d[j])\n\t  d[j]=r[p][j]+d[p];\n      }\n    }\n  }\n \n  return d[g]+1;\n}\n\nmain(){\n  int s, g, n, o, k, t, i, j, a, p, TTL;\n\n  for(i=0;i<100;i++){\n    for(j=0;j<100;j++){\n      r[i][j]=0;\n    }\n  }\n\n  scanf(\"%d\", &n);\n\n  for(j=0;j<n;j++){\n    scanf(\"%d %d\", &o, &k);\n    for(i=0;i<k;i++){\n      scanf(\"%d\", &t);\n      r[o-1][t-1]=1;\n    }\n  }\n\n  scanf(\"%d\", &p);\n\n  for(j=0;j<p;j++){\n    scanf(\"%d %d %d\", &s, &g, &TTL);\n    a = dijkstra(s-1, g-1);\n\n    if(a <= TTL){\n      printf(\"%d\\n\", a);\n    }\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(b=0;b<101;b++)\n\tcount[b]=0;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \t      \n\t    }\n\t}\n        if(count[packet[i].d]<=packet[i].v && count[packet[i].d]!=0)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint n,m,i,j,k,ch,r,live;\nint e[1000][1000];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&ch,&k);\n\t\tfor(;k>0;k--){\n\t\t\tscanf(\"%d\",&r);\n\t\t\te[ch][r]=1;\n\t\t}\n\t}\n\t\n\tm=1;\n\twhile(1){\n\t\tch=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tif(i!=j && e[i][j]==0){\n\t\t\t\t\tfor(k=1;k<=n;k++){\n\t\t\t\t\t\tif(e[k][j]==1 && e[i][k]==m){\n\t\t\t\t\t\t\te[i][j]=e[i][k]+1;\n\t\t\t\t\t\t\tch++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ch<1)break;\n\t\tm++;\n\n\t}\n\n\tscanf(\"%d\",&m);\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d %d %d\",&ch,&r,&live);\n\t\tif(e[ch][r]>0 && live>e[ch][r])printf(\"%d\\n\",e[ch][r]+1); else printf(\"NA\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//from PKU1125\nmain(){\n\tint i,n,f,k,t,dist[101][101];\n\tscanf(\"%d\",&n);\n\t\t/*initialize*/\n\t\tmemset(dist,11,sizeof(dist));\n\t\tfor(i=1;i<=n;i++){\n\t\t\tdist[i][i]=0;\n\t\t\tscanf(\"%d%d\",&f,&k);\n\t\t\tfor(;k;k--){\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tdist[f][t]=1;\n\t\t\t}\n\t\t}\n\n\t\t{/*warshall-floyd*/\n\t\t\tint k,i,j;\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])\n\t\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j];\n\t\t}\n\n\t\t{/*query*/\n\t\t\tfor(scanf(\"%d\",&k);k;k--){\n\t\t\t\tscanf(\"%d%d%d\",&f,&t,&n);\n\t\t\t\tprintf(dist[f][t]<n?\"%d\\n\":\"NA\\n\",dist[f][t]+1);\n\t\t\t}\n\t\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "n,r,k,m[101][101],t[101],p;\ni,j,s,d,v0,v,f;\nmain(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&r,&k);\n\t\tfor(;k--;){\n\t\t\tscanf(\"%d\",&d);\n\t\t\tm[r][d]=1;\n\t\t}\n\t}\n\tscanf(\"%d\",&p);\n\tfor(;p--;){\n\t\tscanf(\"%d%d%d\",&s,&d,&v0);\n\t\tmemset(t,0,sizeof(t));\n\t\tt[s]=v=v0;\n\t\tf=1;\n\t\twhile(f&&!t[d]&&--v){\n\t\t\tf=0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(t[i]==v+1){\n\t\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\t\tif(m[i][j]&&t[j]==0)\n\t\t\t\t\t\t\tt[j]=v,f=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t[d])\n\t\t\tprintf(\"%d\\n\",v0-t[d]+1);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(b=0;b<101;b++)\n\tcount[b]=0;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \t      \n\t    }\n\t}\n        if(count[packet[i].d]<=packet[i].v && count[packet[i].d]!=0)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}\n#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(b=0;b<101;b++)\n\tcount[b]=0;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \t      \n\t    }\n\t}\n        if(count[packet[i].d]<=packet[i].v && count[packet[i].d]!=0)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 101\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint visited[N]; /* already visited flag */\n\nint que[N][2];  /* queue for bfs {rooter id, num of rooter} */\nint wp,rp;      /* write pointer, read pointer for queue */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n \n \nint check(int s,int d,int v){\n    int i,ret,id,num,nextid;\n\n    for(i=0;i<N;i++)visited[i]=0;\n\n    /* init que */\n    wp=0;\n    rp=0;\n\n    visited[s]=1;\n    /* push que */\n    que[wp][0]=s;\n    que[wp][1]=1;\n    wp++;\n\n    while(rp<wp){\n        /* pop que */\n        id=que[rp][0];\n        num=que[rp][1];\n        rp++;\n\n        if(id==d) return num; /* goal(return num of rooter) */\n        if(num>=v) continue;/* TTL is too small */\n\n        /* check next rooter */\n        for(i=0;root[id][i];i++){\n            nextid=root[id][i];\n\n            if(visited[nextid]) continue; /* already visited */\n            visited[nextid]=1;\n\n            /* push que */\n            que[wp][0]=nextid;\n            que[wp][1]=num+1;\n            wp++;\n        }\n    }\n\n    return 0;/* can't alive */\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 100000000\n#define N_MAX 100\n#define P_MAX 10000\n\nint MIN(int x, int y);\n\nint n;                             /* ?????????????????° */\nint r;                             /* ??????????????? */\nint k;                             /* ???????????¨??´??\\??\\?¶??????????????????????????????° */\nint t;                             /* ??????????????\\?¶??????± */\nint p;                             /* ?????±??????????????° */\nint s;                             /* ??????????????????????????? */\nint d;                             /* ???????????????????????? */\nint v;                             /* TTL */\nint rute[N_MAX + 1][N_MAX + 1];    /* ???????????? */\nint ans[P_MAX];                    /* ?????? */\n\nint main(void)\n{\n    int i, j, l;\n\n    /* ????????? */\n    for (i = 0; i < N_MAX + 1; ++i){\n        for (j = 0; j < N_MAX + 1; ++j){\n            rute[i][j] = INF;\n        }\n    }\n\n    scanf(\"%d\", &n);\n    for (i = 1; i <= n; i++){\n        scanf(\"%d%d\", &r, &k);\n        for (j = 1; j <= k; j++){\n            scanf(\"%d\", &t);\n            rute[r][t] = 1;\n        }\n    }\n\n    /* ????????????????????? */\n    for (l = 1; l <= n; l++){\n        for (i = 1; i <= n; i++){\n            for (j = 1; j <= n; j++){\n                rute[i][j] = MIN(rute[i][j], rute[i][l] + rute[l][j]);\n            }\n        }\n    }\n\n    /* ?????±???????????±?????????????????¨?????? */\n    scanf(\"%d\", &p);\n    for (i = 0; i < p; ++i)\n    {\n        scanf(\"%d%d%d\", &s, &d, &v);\n        if (rute[s][d] + 1 <= v){\n            ans[i] = rute[s][d] + 1;\n        }\n        else\n        {\n            ans[i] = 0;\n        }\n    }\n\n    for (i = 0; i < p; ++i)\n    {\n        if (ans[i] == 0){\n            printf(\"NA\\n\");\n        }\n        else\n        {\n            printf(\"%d\\n\", ans[i]);\n        }\n    }\n\n    return (0);\n}\nint MIN(int x, int y){\n\n    if (x < y){\n        return(x);\n    }\n    else{\n        return(y);\n    }\n\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????????????????±????´????????????????????????? */\n\ts4_t_oi = (S4)0;\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA \");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d \", s4_tp_result[s4_t_oi2]);\n\t\t}\n\n\t\t/* ????????\\?????????????????? */\n\t\tif (s4_t_oi2 != s4_t_oi - 1) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int n;      // [^\n    int r;      // [^Ô\n    int k;      // Ú±\n    int t;      // Ú±[^Ô\n    int p;      // pPbg\n    int s, d, v;// pPbgîñ\n    int connect[101][101];\n    int i, j;\n    int steps, step[101];\n    int flag;\n    \n    memset(connect, 0, sizeof(connect));\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++){\n        scanf(\"%d\", &r);\n        scanf(\"%d\", &k);\n        for (j = 0; j < k; j++){\n            scanf(\"%d\", &t);\n            connect[r][t] = 1;\n        }\n    }\n    \n    scanf(\"%d\", &p);\n    for (i = 0; i < p; i++){\n        memset(step, 0, sizeof(step));\n    \n        scanf(\"%d%d%d\", &s, &d, &v);\n        step[s] = 1;\n        steps = 1;\n        do {\n            flag = 0;\n            for (j = 1; j <= n; j++){\n                if (step[j] == steps){\n                    for (k = 1; k <= n; k++){\n                        if (connect[j][k] == 1){\n                            if (step[k] == 0){\n                                step[k] = steps + 1;\n                                flag = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            steps++;\n        } while (flag == 1);\n//    printf(\"<%d, %d=%d>\\n\", step[d], i, p);\n        if (step[d] == 0 || step[d] > v){\n            printf(\"NA\\n\");\n        }\n        else {\n            printf(\"%d\\n\", step[d]);\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint Q[101],head,tail,n,t[101][101],d[101],k[100];\nvoid enqueue(int x){\n  Q[tail++]=x;\n}\nint dequeue(){\n  return Q[head++];\n}\nvoid bfs(int s){\n  int u,v,w;\n  for(v=0;v<=n;v++) d[v]=10000;\n  d[s]=0;\n  enqueue(s);\n  while(head!=tail){\n    u=dequeue();\n    for(v=0;v<=n;v++){\n\tif(t[u][v]==1&&d[v]==10000){\n\t  d[v]=d[u]+1;\n\t  enqueue(v);\n      }\n    }\n  }\n}\n\nmain(){\n  int p,i,j,s,dd,TTL,r[100],m,tt[101][101];\n  scanf(\"%d\",&n);\n  head=0;\n  tail=0;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\",&r[i],&k[i]);\n    for(j=0;j<k[i];j++){\n      tt[r[i]][j]=10000;\n      scanf(\"%d\",&tt[r[i]][j]);\n    }\n  }\n  for(i=0;i<=n;i++){\n    for(j=0;j<=n;j++){\n      t[i][j]=0;\n    }\n  }\n\n  for(i=0;i<=n;i++){\n    for(j=0;j<k[i];j++){\n      for(m=0;m<=n;m++){\n\tif(tt[r[i]][j]==m) t[r[i]][m]=1;\n      }\n    }\n  }\n\n\n  scanf(\"%d\",&p);\n  for(i=0;i<p;i++){\n    scanf(\"%d%d%d\",&s,&dd,&TTL);\n    bfs(s);\n\n    if(d[dd]<TTL) printf(\"%d\\n\",d[dd]+1);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 102\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint visited[N]; /* already visited flag */\n\nint que[N][2];  /* queue for bfs {id,TTL} */\nint wp,rp;      /* write pointer, read pointer for queue */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n \n \nint check(int s,int d,int v){\n    int i,ret,nows,nowv,nexts;\n\n    for(i=0;i<N;i++)visited[i]=0;\n\n    /* init que */\n    wp=0;\n    rp=0;\n\n    visited[s]=1;\n    /* push que */\n    que[wp][0]=s;\n    que[wp][1]=v;\n    wp++;\n\n    while(rp<wp){\n        /* pop que */\n        nows=que[rp][0];\n        nowv=que[rp][1];\n        rp++;\n\n        if(nows==d) return v-nowv+1; /* goal(return num of rooter) */\n        if(--nowv<=0) continue;/* TTL is too small */\n\n        /* check next rooter */\n        for(i=0;root[nows][i];i++){\n            nexts=root[nows][i];\n\n            if(visited[nexts]) continue; /* already visited */\n            visited[nexts]=1;\n\n            /* push que */\n            que[wp][0]=nexts;\n            que[wp][1]=nowv;\n            wp++;\n        }\n    }\n\n    return 0;/* can't alive */\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 10000000\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  /*\n  for(i=1;i<=n;i++)\n    {\n      for(j=1;j<=n;j++)\n\t{\n\t  printf(\"%d\",router[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n  */\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint Q[1010],head,tail,n,t[101][101],d[101],k[100];\nvoid enqueue(int x){\n  Q[tail++]=x;\n}\nint dequeue(){\n  return Q[head++];\n}\nvoid bfs(int s){\n  int u,v,w;\n  for(v=0;v<=n;v++) d[v]=10000;\n  d[s]=0;\n  enqueue(s);\n  while(head!=tail){\n    u=dequeue();\n    for(v=0;v<=n;v++){\n\tif(t[u][v]==1&&d[v]==10000){\n\t  d[v]=d[u]+1;\n\t  enqueue(v);\n      }\n    }\n  }\n}\n\nmain(){\n  int p,i,j,s,dd,TTL,r[101],m,tt[101][101];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\",&r[i],&k[i]);\n    for(j=0;j<k[i];j++){\n      tt[r[i]][j]=10000;\n      scanf(\"%d\",&tt[r[i]][j]);\n    }\n  }\n  for(i=0;i<=n;i++){\n    for(j=0;j<=n;j++){\n      t[i][j]=0;\n    }\n  }\n\n  for(i=0;i<n;i++){\n    for(j=0;j<k[i];j++){\n      for(m=0;m<=n;m++){\n\tif(tt[r[i]][j]==m) t[r[i]][m]=1;\n      }\n    }\n  }\n\n\n  scanf(\"%d\",&p);\n  for(i=0;i<p;i++){\n    scanf(\"%d%d%d\",&s,&dd,&TTL);\n    head=0;\n    tail=0;\n    bfs(s);\n\n    if(d[dd]<TTL) printf(\"%d\\n\",d[dd]+1);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n\n#define MAX_V 100\n\nconst int INF = 1000000000;\n\nint V;\nint d[MAX_V][MAX_V];\n\nvoid\nwarshall_floyd()\n{\n\tfor (int k = 0; k < V; ++k)\n\t{\n\t\tfor (int i = 0; i < V; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < V; ++j)\n\t\t\t{\n\t\t\t\tint t = d[i][k] + d[k][j];\n\t\t\t\tif (t < d[i][j])\n\t\t\t\t\td[i][j] = t;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\nmain(int argc, char **argv)\n{\n\tscanf(\"%d\", &V);\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tfor (int j = 0; j < V; ++j)\n\t\t\td[i][j] = (i == j) ? 0 : INF;\n\t}\n\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tint r, k;\n\t\tscanf(\"%d%d\", &r, &k);\n\t\tfor (int j = 0; j < k; ++j)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\td[r - 1][t - 1] = 1;\n\t\t}\n\t}\n\n\twarshall_floyd();\n\n\tint p;\n\tscanf(\"%d\", &p);\n\tfor (int i = 0; i < p; ++i)\n\t{\n\t\tint f, t, v;\n\t\tscanf(\"%d%d%d\", &f, &t, &v);\n\t\tint c = d[f - 1][t - 1] + 1;\n\t\tif (c <= v)\n\t\t\tprintf(\"%d\\n\", c);\n\t\telse\n\t\t\tprintf(\"NA\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 101\n\n\nint root[N][N] = {0};\nint gone[N] = {0};\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    int ans;\n    \n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[k][j] = t;\n        }\n    }\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\":\"NA\",ans);\n    }\n    return 0;\n}\n\n\nint check(int s,int d,int v){\n    int i,ret;\n    if(s==d)return 1;\n    if(v<=0)return 0;\n    gone[s]=1;\n    for(i=0;root[s][i];i++){\n        if( ret = check(root[s][i],d,v-1) ) return ret + 1;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "n,r,k,m[101][101],t[101],p;\ni,j,s,d,v0,v,f;\nmain(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&r,&k);\n\t\tfor(;k--;){\n\t\t\tscanf(\"%d\",&d);\n\t\t\tm[r][d]=1;\n\t\t}\n\t}\n\tscanf(\"%d\",&p);\n\tfor(;p--;){\n\t\tscanf(\"%d%d%d\",&s,&d,&v0);\n\t\tmemset(t,0,sizeof(t));\n\t\tt[s]=v=v0;\n\t\tf=1;\n\t\twhile(f&&!t[d]&&--v>0){\n\t\t\tf=0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(t[i]==v+1){\n\t\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\t\tif(m[i][j]&&t[j]==0)\n\t\t\t\t\t\t\tt[j]=v,f=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t[d])\n\t\t\tprintf(\"%d\\n\",v0-t[d]+1);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100], d[100], f[100];\n\nint dijkstra(int s, int g){\n  int min, p, i, j;\n  for(i=0;i<100;i++){\n    d[i]=100000;\n    f[i]=0;\n  }\n  d[s]=0;\n  while(1){\n    min=100000;\n    for(i=0;i<100;i++){\n      if(d[i]<min && f[i]==0){\n\tmin=d[i];\n\tp=i;\n      }\n    }\n    \n    if(min==100000) break;\n    f[p]=1;\n    for(j=0;j<100;j++){\n      if(r[p][j]==1){\n\tif(d[p]+r[p][j]<d[j])\n\t  d[j]=r[p][j]+d[p];\n      }\n    }\n  }\n \n  return d[p];\n}\n\nmain(){\n  int s, g, n, o, k, t, i, j, a, p, TTL;\n\n  for(i=0;i<100;i++){\n    for(j=0;j<100;j++){\n      r[i][j]=0;\n    }\n  }\n\n  scanf(\"%d\", &n);\n\n  for(j=0;j<n;j++){\n    scanf(\"%d %d\", &o, &k);\n    for(i=0;i<k;i++){\n      scanf(\"%d\", &t);\n      r[o-1][t-1]=1;\n    }\n  }\n\n  scanf(\"%d\", &p);\n\n  for(j=0;j<p;j++){\n    scanf(\"%d %d %d\", &s, &g, &TTL);\n    a = dijkstra(s-1, g-1);\n\n    if(a <= TTL){\n      printf(\"%d\\n\", a);\n    }\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)1;\n\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\ts4_t_hop++;\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex];\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\tprintf(\"%d\\n\", s4_t_hop);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count;\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      count=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count++;\t\n\t\t} \t      \n\t    }\n\t}\n        if(count<=packet[i].v && count!=0)printf(\"%d\\n\",count);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m;\nint t[101][101];\n\nint que[2000];\nint qa,qb;\n\nint calc(int start,int goal){\n  int i,pos;\n  int visited[101];\n  int cost[101];\n  \n  for(i=0;i<101;i++){\n    visited[i]=0;\n    cost[i]=0;\n  }\n  qa=0;\n  qb=1;\n  que[0]=start;\n  visited[start]=1;\n  \n  while(qa<qb){\n    pos=que[qa];\n    qa++;\n    if(pos==goal)return cost[pos];\n    \n    for(i=1;i<=n;i++){\n      if(t[pos][i]==0)continue;\n      if(visited[i]==1)continue;\n      visited[i]=1;\n      que[qb]=i;\n      qb++;\n      cost[i]=cost[pos]+1;\n    }\n  }\n  return 9999;\n}\n\nint main(){\n  int i,j;\n  int id,k,l;\n  int s,d,v;\n  int ans;\n  \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&id,&k);\n    for(j=0;j<k;j++){\n      scanf(\"%d\",&l);\n      t[id][l]=1;\n    }\n  }\n\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d\",&s,&d,&v);\n    ans=calc(s,d)+1;\n    if(ans<=v||ans==9999)printf(\"%d\\n\",ans);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 102\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint gone[N];    /* already gone flag */\n\nint que[N][2];  /* queue for bfs {id,TTL} */\nint wp,rp;      /* write pointer, read pointer for queue */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n \n \nint check(int s,int d,int v){\n    int i,ret,ts,tv;\n\n    for(i=0;i<N;i++)gone[i]=0;\n\n    /* init que */\n    wp=0;\n    rp=0;\n\n    /* push que */\n    que[wp][0]=s;\n    que[wp][1]=v;\n    wp++;\n    gone[s]=1;\n\n    while(rp<wp){\n        /* pop que */\n        ts=que[rp][0];\n        tv=que[rp][1]-1;\n        rp++;\n\n        if(tv==0) continue;/* TTL is too small */\n\n        /* check next rooter */\n        for(i=0;root[ts][i];i++){\n            if(gone[root[ts][i]]) continue; /* already gone */\n            gone[root[ts][i]]=1;\n            if(root[ts][i]==d) return v-tv+1; /* goal(return num of rooter) */\n            /* push que */\n            que[wp][0]=root[ts][i];\n            que[wp][1]=tv;\n            wp++;\n        }\n    }\n\n    return 0;/* can't alive */\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0144: Packet Transportation\n// 2017.8.9\n\n#include <stdio.h>\n\n#define MAX 100\nchar visited[MAX + 2];\nchar cost[MAX + 2][MAX + 2], len[MAX + 2];\nchar Q[2][MAX + 2], end[2];\nint n;\n\nint search(int s, int g, int v);\n\nint main(void)\n{\n\tint r, k, t;\n\tint P, s, d, v;\n\tint i, j;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &r, &k), len[r] = k;\n\t\tfor (j = 0; j < k; j++) scanf(\"%d\", &t), cost[r][j] = t;\n\t}\n\tscanf(\"%d\", &P);\n\tfor (i = 0; i < P; i++) {\n\t\tscanf(\"%d%d%d\", &s, &d, &v);\n\t\tif (s == d) puts(v >= 1 ? \"1\" : \"NA\");\n\t\telse if (v <= 1) puts(\"NA\");\n\t\telse {\n\t\t\tif ((j = search(s, d, v)) >= 0) printf(\"%d\\n\", j);\n\t\t\telse puts(\"NA\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int s, int g, int lim)\n{\n\tint i, k, k1, k2, step;\n\tint e, a, b;\n\n\tfor (i = 1; i <= n; i++) visited[i] = 0;\n\tQ[0][0] = s, end[0] = 1, visited[s] = 1, step = 2;\n\tfor (k1 = 0, k2 = 1; ; k2 = k1, k1 = !k2) {\n\t\tfor (e = 0, i = end[k1] - 1; i >= 0; i--) {\n\t\t\ta = Q[k1][i], k = len[a];\n\t\t\twhile (k-- > 0) {\n\t\t\t\tif ((b = cost[a][k]) == g) return step;\n\t\t\t\tif (!visited[b]) Q[k2][e++] = b, visited[b] = 1;\n\t\t\t}\n\t\t}\n\t\tif (e == 0) return -1;\n\t\tend[k2] = e;\n\t\tif (++step > lim) return -1;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 101\n\n\nint check(int s,int d,int v);\n\nint root[N][N] = {0};\nint gone[N] = {0};\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n    \n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        while(1){\n            scanf(\"%d%c\",&t,&c);\n            root[k][j] = t;\n            if(c=='\\n')break;\n        }\n    }\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n\n\nint check(int s,int d,int v){\n    int i,ret;\n    if(s==d)return 1;\n    if(v<=0)return 0;\n    gone[s]=1;\n    for(i=0;root[s][i];i++){\n        if( ret = check(root[s][i],d,v-1) ) return ret + 1;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 101\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint distance[N]; /* already visited flag */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n  \n  \nint check(int s,int d,int v){\n    int i,ret,id,num,nextid;\n\n    for(i=0;i<N;i++)distance[i]=0;\n\n    distance[s]=1;\n\n    for(i=1;i<v;i++){\n        for(j=0;j<N;j++){\n            if(distance[j]==i){\n                for(k=0;root[id][k]>0;k++){\n                    nextid=root[id][k];\n                    if(distance[nextid]==0){\n                        distance[nextid]=i+1;\n                    }\n                }\n            }\n        }\n    }\n\n    return distance[d];\n}"
  },
  {
    "language": "C",
    "code": "//from PKU1125\nmain(){\n\tint i,n,f,k,t,dist[101][101];\n\tscanf(\"%d\",&n);\n\t\t/*initialize*/\n\t\tmemset(dist,11,sizeof(dist));\n\t\tfor(i=1;i<=n;i++){\n\t\t\tdist[i][i]=0;\n\t\t\tscanf(\"%d%d\",&f,&k);\n\t\t\tfor(;k;k--){\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tdist[f][t]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t{/*warshall-floyd*/\n\t\t\tint k,i,j;\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])\n\t\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j];\n\t\t}\n\t\t\n\t\t{/*query*/\n\t\t\tfor(scanf(\"%d\",&k);k;k--){\n\t\t\t\tscanf(\"%d%d%d\",&f,&t,&n);\n\t\t\t\tprintf(dist[f][t]<n?\"%d\\n\":\"NA\\n\",dist[f][t]+1);\n\t\t\t}\n\t\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MIN(A,B) \\\n  ( (B) < (A) ? (B) : (A) )\n#define INFTY 19980725\n#define N 100\n\n/** ルータの総数 */\nstatic int n;\n/** ネットワークの隣接行列 */\nstatic int g[ N + 1 ][ N + 1 ] = { { 0 } };\n/** パケットの個数 */\nstatic int p;\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i, j, k;\n\n  /* ルータの個数の読み込みと隣接行列の初期化 */\n  scanf ( \"%d\", &n );\n  for ( i = 1; i <= n; ++i )\n  for ( j = 1; j <= n; ++j )\n  {\n    g[ i ][ j ] = ( i == j ? 0 : INFTY );\n  }\n\n  /* ネットワーク状態の読み込み */\n  for ( i = 0; i < n; ++i )\n  {\n    int r, k;\n\n    scanf ( \"%d%d\", &r, &k );\n    for ( j = 0; j < k; ++j )\n    {\n      int t;\n\n      scanf ( \"%d\", &t );\n      g[ r ][ t ] = 1;\n    }\n  }\n\n  /* ワーシャルフロイド法による最短経路の算出 */\n  for ( k = 1; k <= n; ++k )\n  for ( i = 1; i <= n; ++i )\n  for ( j = 1; j <= n; ++j )\n  {\n    g[ i ][ j ] = MIN( g[ i ][ j ], g[ i ][ k ] + g[ k ][ j ] );\n  }\n\n  /* パケット情報の読み込みと処理 */\n  scanf ( \"%d\", &p );\n  for ( i = 0; i < p; ++i )\n  {\n    int s, d, v;\n\n    scanf ( \"%d%d%d\", &s, &d, &v );\n    if ( g[ s ][ d ] + 1 <= v )\n    {\n      printf ( \"%d\\n\", g[ s ][ d ] + 1 );\n    }\n    else\n    {\n      puts ( \"NA\" );\n    }\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint Q[101],head=0,tail=0,n,t[101][101],d[101],k[100];\nvoid enqueue(int x){\n  Q[tail++]=x;\n}\nint dequeue(){\n  return Q[head++];\n}\nint isEmpty(){\n  return(head==tail);\n}\nvoid bfs(int s){\n  int u,v,w;\n  for(v=0;v<=n;v++) d[v]=10000;\n  d[s]=0;\n  enqueue(s);\n  while(head!=tail){\n    u=dequeue();\n    for(v=0;v<=n;v++){\n\tif(t[u][v]==1&&d[v]==10000){\n\t  d[v]=d[u]+1;\n\t  enqueue(v);\n      }\n    }\n  }\n}\n\nmain(){\n  int p,i,j,s,dd,TTL,r[100],m,tt[101][101];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\",&r[i],&k[i]);\n    for(j=0;j<k[i];j++){\n      tt[r[i]][j]=10000;\n      scanf(\"%d\",&tt[r[i]][j]);\n    }\n  }\n  for(i=0;i<=n;i++){\n    for(j=0;j<=n;j++){\n      t[i][j]=0;\n    }\n  }\n\n  for(i=0;i<=n;i++){\n    for(j=0;j<k[i];j++){\n      for(m=0;m<=n;m++){\n\tif(tt[r[i]][j]==m) t[r[i]][m]=1;\n      }\n    }\n  }\n\n\n  scanf(\"%d\",&p);\n  for(i=0;i<p;i++){\n    scanf(\"%d%d%d\",&s,&dd,&TTL);\n    bfs(s);\n\n    if(d[dd]<TTL) printf(\"%d\\n\",d[dd]+1);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????????????????±????´????????????????????????? */\n\ts4_t_oi = (S4)0;\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\", s4_tp_result[s4_t_oi2]);\n\t\t}\n\n\t\t/* ????????\\?????????????????? */\n\t\tif (s4_t_oi2 != s4_t_oi - 1) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF (1 << 28)\n#define N 100\n\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nint n;\nint table[N][N];\n\n// Warshall-Floyd\nvoid warshall_floyd(){\n    int i, j, k;\n    \n    for(i = 0; i < n; ++i){\n        for(j = 0; j < n; ++j){\n            for(k = 0; k < n; ++k){\n                table[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n            }\n        }\n    }\n}\n\nint main(){\n    int i, j;\n    int r, k, t;\n    int p, s, d, v;\n    \n    for(i = 0; i < N; ++i){\n        for(j = 0; j < N; ++j){\n            table[i][j] = INF;\n        }\n    }\n    \n    scanf(\"%d\", &n);\n    \n    for(i = 0; i < n; ++i){\n        scanf(\"%d %d\", &r, &k);\n        \n        for(j = 0; j < k; ++j){\n            scanf(\"%d\", &t);\n            \n            table[r - 1][t - 1] = 1;\n        }\n    }\n    \n    warshall_floyd();\n    \n    scanf(\"%d\", &p);\n    \n    for(i = 0; i < p; ++i){\n        scanf(\"%d %d %d\", &s, &d, &v);\n        \n        if(table[s - 1][d - 1] + 1 > v){\n            printf(\"NA\\n\");\n        }\n        \n        else {\n            printf(\"%d\\n\", table[s - 1][d - 1] + 1);\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "n,r,k,m[101][101],t[101];i,j,s,d,V,v,f;main(){scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"%d%d\",&r,&k);for(;k--;m[r][d]=1)scanf(\"%d\",&d);}scanf(\"%*d\");for(;~scanf(\"%d%d%d\",&s,&d,&V);){memset(t,0,sizeof(t));t[s]=v=V;f=1;while(f&&!t[d]&&--v>0){f=0;for(i=1;i<=n;i++)if(t[i]==v+1)for(j=1;j<=n;j++)if(m[i][j]&&!t[j])t[j]=v,f=1;}t[d]?printf(\"%d\\n\",V-t[d]+1):puts(\"NA\");}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 102\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint gone[N];    /* already gone flag */\n\nint que[N][2];  /* queue for bfs {id,TTL} */\nint wp,rp;      /* write pointer, read pointer for queue */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n \n \nint check(int s,int d,int v){\n    int i,ret,ts,tv;\n\n    for(i=0;i<N;i++)gone[i]=0;\n\n    /* init que */\n    wp=0;\n    rp=0;\n\n    /* push que */\n    que[wp][0]=s;\n    que[wp][1]=v;\n    wp++;\n    gone[s]=1;\n\n    while(rp<wp){\n        /* pop que */\n        ts=que[rp][0];\n        tv=que[rp][1];\n        rp++;\n\n        if(ts==d) return v-tv+1; /* goal(return num of rooter) */\n        if(--tv==0) continue;/* TTL is too small */\n\n        /* check next rooter */\n        for(i=0;root[ts][i];i++){\n            if(gone[root[ts][i]]) continue; /* already gone */\n            gone[root[ts][i]]=1;\n            /* push que */\n            que[wp][0]=root[ts][i];\n            que[wp][1]=tv;\n            wp++;\n        }\n    }\n\n    return 0;/* can't alive */\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 101\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint gone[N];    /* already gone flag */\n\nint que[N][2];  /* queue for bfs {id,TTL} */\nint wp,rp;      /* write pointer, read pointer for queue */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n \n \nint check(int s,int d,int v){\n    int i,ret,ts,tv;\n\n    for(i=0;i<N;i++)gone[i]=0;\n\n    /* init que */\n    wp=0;\n    rp=0;\n\n    /* push que */\n    que[wp][0]=s;\n    que[wp][1]=v;\n    wp++;\n\n    while(rp<wp){\n        /* pop que */\n        ts=que[rp][0];\n        tv=que[rp][1]-1;\n        rp++;\n\n        gone[ts]=1;\n        if(tv==0) continue;/* TTL is too small */\n\n        /* check next rooter */\n        for(i=0;root[ts][i];i++){\n            if(gone[root[ts][i]]) continue; /* already gone */\n            if(root[ts][i]==d) return v-tv+1; /* goal(return num of rooter) */\n            /* push que */\n            que[wp][0]=root[ts][i];\n            que[wp][1]=tv;\n            wp++;\n        }\n    }\n\n    return 0;/* can't alive */\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[10000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b,fg;\n  \n  struct mail{\n    int s;\n    int d;\n    int v[101];\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v[1]);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(j=1;j<=p;j++)\n\t{\n\t  packet[i].v[j]=packet[i].v[1];\n\t}\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\t{\n\tvisited[b]=0;\n\t}\n      \n      visited[packet[i].s]=1;\n      fg=0;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\t  \n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\n\t\t  packet[i].v[j]=packet[i].v[a]-1;\n\n\t\t  if(j==packet[i].d && packet[i].v[j]>0)printf(\"%d\\n\",count[packet[i].d]);\n\t\t  else if(fg==0 && packet[i].v[j]==-1 && a!=packet[i].d)\n\t\t    {\n\t\t      printf(\"NA\\n\");\n\t\t      fg=1;\n\t\t    }\n\t\t  \n\t\t} \n\t      \n\t    }\n\n\t}\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\ts4_t_oi = (S4)0;\n\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", s4_tp_result[s4_t_oi2]);\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m;\nint t[101][101];\n\nint que[2000];\nint qa,qb;\n\nint calc(int start,int goal){\n  int i,pos;\n  int visited[101];\n  int cost[101];\n  \n  for(i=0;i<101;i++){\n    visited[i]=0;\n    cost[i]=0;\n  }\n  qa=0;\n  qb=1;\n  que[0]=start;\n  visited[start]=1;\n  \n  while(qa<qb){\n    pos=que[qa];\n    qa++;\n    if(pos==goal)return cost[pos];\n    \n    for(i=1;i<=n;i++){\n      if(t[pos][i]==0)continue;\n      if(visited[i]==1)continue;\n      visited[i]=1;\n      que[qb]=i;\n      qb++;\n      cost[i]=cost[pos]+1;\n    }\n  }\n  return 9999;\n}\n\nint main(){\n  int i,j;\n  int id,k,l;\n  int s,d,v;\n  int ans;\n  \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&id,&k);\n    for(j=0;j<k;j++){\n      scanf(\"%d\",&l);\n      t[id][l]=1;\n    }\n  }\n\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d\",&s,&d,&v);\n    ans=calc(s,d)+1;\n    if(ans<=v&&ans!=10000)printf(\"%d\\n\",ans);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint ru_ta_num;\nint map[100][100];\n\nint main(void) {\n\tint i,j,k;\n\tint ru_ta_id;\n\tint ru_ta_connect_num;\n\tint ru_ta_connect;\n\tint packet_num;\n\tint packet_from,packet_to,packet_ttl;\n\tscanf(\"%d\",&ru_ta_num);\n\tfor(i=0;i<ru_ta_num;i++) {\n\t\tfor(j=0;j<ru_ta_num;j++) {\n\t\t\tmap[i][j]=100000;\n\t\t}\n\t\tmap[i][i]=0;\n\t}\n\tfor(i=0;i<ru_ta_num;i++) {\n\t\tscanf(\"%d%d\",&ru_ta_id,&ru_ta_connect_num);\n\t\tru_ta_id--;\n\t\tfor(j=0;j<ru_ta_connect_num;j++) {\n\t\t\tscanf(\"%d\",&ru_ta_connect);\n\t\t\tmap[ru_ta_id][ru_ta_connect-1]=1;\n\t\t}\n\t}\n\tfor(k=0;k<ru_ta_num;k++) {\n\t\tfor(i=0;i<ru_ta_num;i++) {\n\t\t\tfor(j=0;j<ru_ta_num;j++) {\n\t\t\t\tif(map[i][k]+map[k][j]<map[i][j]) {\n\t\t\t\t\tmap[i][j]=map[i][k]+map[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&packet_num);\n\tfor(i=0;i<packet_num;i++) {\n\t\tscanf(\"%d%d%d\",&packet_from,&packet_to,&packet_ttl);\n\t\tpacket_from--;packet_to--;\n\t\tif(packet_ttl<map[packet_from][packet_to]+1) {\n\t\t\tputs(\"NA\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\",map[packet_from][packet_to]+1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\tprintf(\"%d\\n\", s4_t_hop);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 101\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint gone[N];    /* already gone flag */\n\nint que[N][2];  /* queue for bfs {id,TTL} */\nint wp,rp;      /* write pointer, read pointer for queue */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n \n \nint check(int s,int d,int v){\n    int i,ret,ts,tv;\n\n    for(i=0;i<N;i++)gone[i]=0;\n\n    /* init que */\n    wp=0;\n    rp=0;\n\n    /* push que */\n    que[wp][0]=s;\n    que[wp][1]=v;\n    wp++;\n    gone[s]=1;\n\n    while(rp<wp){\n        /* pop que */\n        ts=que[rp][0];\n        tv=que[rp][1]-1;\n        rp++;\n\n        if(tv==0) continue;/* TTL is too small */\n\n        /* check next rooter */\n        for(i=0;root[ts][i];i++){\n            if(gone[root[ts][i]]) continue; /* already gone */\n            gone[root[ts][i]]=1;\n            if(root[ts][i]==d) return v-tv+1; /* goal(return num of rooter) */\n            /* push que */\n            que[wp][0]=root[ts][i];\n            que[wp][1]=tv;\n            wp++;\n        }\n    }\n\n    return 0;/* can't alive */\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b,fg;\n  \n  struct mail{\n    int s;\n    int d;\n    int v[101];\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v[1]);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(j=1;j<=p;j++)\n\t{\n\t  packet[i].v[j]=packet[i].v[1];\n\t}\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\t{\n\tvisited[b]=0;\n\t}\n      \n      visited[packet[i].s]=1;\n      fg=0;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\t  \n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\n\t\t  packet[i].v[j]=packet[i].v[a]-1;\n\n\t\t  if(j==packet[i].d && packet[i].v[j]>0)printf(\"%d\\n\",count[packet[i].d]);\n\t\t  else if(fg==0 && packet[i].v[j]==-1 && a!=packet[i].d)\n\t\t    {\n\t\t      printf(\"NA\\n\");\n\t\t      fg=1;\n\t\t    }\n\t\t  \n\t\t} \n\t      \n\t    }\n\n\t}\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,r[101][101]={0};\nint f(int t,int g,int p,int c,int d[101]){\n  if(p==c)return 102;\n  if(t==g)return c;\n  int i,h,min=102;\n  for(i=1;i<=n;i++){\n    if(d[i]==0&&r[t][i]==1){\n      d[i]=1;\n      c++;\n      h=f(i,g,p,c,d);\n      c--;\n      d[i]=0;\n    if(min>h)min=h;\n    }\n  }\n  return min;\n}\nint main(){\n  int i,j,s,g,d,t=-1,c;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&s,&c);\n    for(j=0;j<c;j++){\n      scanf(\"%d\",&g);\n      r[s][g]=1;\n    }\n  }\n  \n  scanf(\"%d\",&d);\n  for(i=0;i<d;i++){\n    int a[101]={0};\n    scanf(\"%d %d %d\",&s,&g,&c);\n    t=f(s,g,c,0,a);\n    if(t==102)printf(\"NA\\n\");\n    else    printf(\"%d\\n\",t+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  /*\n  for(i=1;i<=n;i++)\n    {\n      for(j=1;j<=n;j++)\n\t{\n\t  printf(\"%d\",router[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n  */\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(b=0;b<101;b++)\n\tcount[b]=0;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(b=0;b<101;b++)\n\tcount[b]=0;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \t      \n\t    }\n\t}\n        if(count[packet[i].d]<=packet[i].v && count[packet[i].d]!=0)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100], d[100], f[100];\n\nint dijkstra(int s, int g){\n  int min, p, i, j;\n  for(i=0;i<100;i++){\n    d[i]=1000;\n    f[i]=0;\n  }\n  d[s]=0;\n  while(1){\n    min=1000;\n    for(i=0;i<100;i++){\n      if(d[i]<min && f[i]==0){\n\tmin=d[i];\n\tp=i;\n      }\n      if(min==1000) break;\n      f[p]=1;\n      for(j=0;j<100;j++){\n\tif(r[p][j]==1){\n\t  if(d[p]+r[p][j]<d[j])\n\t    d[j]=r[p][j]+d[p];\n\t}\n      }\n    }\n  }\n  return min;\n}\n\nmain(){\n  int s, g, n, o, k, t, i, j, a, p, TTL;\n\n  for(i=0;i<100;i++){\n    for(j=0;j<100;j++){\n      r[i][j]=0;\n    }\n  }\n\n  scanf(\"%d\", &n);\n\n  for(j=0;j<n;j++){\n    scanf(\"%d %d\", &o, &k);\n    for(i=0;i<k;i++){\n      scanf(\"%d\", &t);\n      r[o-1][t-1]=1;\n    }\n  }\n\n  scanf(\"%d\", &p);\n\n  for(j=0;j<p;j++){\n    scanf(\"%d %d %d\", &s, &g, &TTL);\n    a = dijkstra(s, g);\n    if(a <= TTL-1){\n      printf(\"%d\\n\", a);\n    }\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????????????????±????´????????????????????????? */\n\ts4_t_oi = (S4)0;\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", s4_tp_result[s4_t_oi2]);\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b,fg;\n  \n  struct mail{\n    int s;\n    int d;\n    int v[101];\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v[1]);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(j=1;j<=p;j++)\n\t{\n\t  packet[i].v[j]=packet[i].v[1];\n\t}\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      //printf(\"A\\n\");\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\t{\n\tvisited[b]=0;\n\t}\n      \n      visited[packet[i].s]=1;\n      fg=0;\n      //printf(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\");\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\t  \n\t  for(j=1;j<=n;j++)\n\t    {\n\t      //printf(\"%dB\\n\",packet[i].v[j]);\n\t      //printf(\"%d\\n\",packet[i].v[j]);\n\t      \n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\n\t\t  packet[i].v[j]=packet[i].v[a]-1;\n\t\t  //printf(\"%d==%d\\n\",j,packet[i].d);\n\t\t  if(j==packet[i].d && packet[i].v[j]>0)printf(\"%d\\n\",count[packet[i].d]);\n\t\t  else if(fg==0 && packet[i].v[j]==-1 && a!=packet[i].d)\n\t\t    {\n\t\t      printf(\"NA\\n\");\n\t\t      fg=1;\n\t\t    }\n\t\t  \n\t\t} \n\t      \n\t    }\n\t  //printf(\"\\n\");\n\t}\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  /*\n  for(i=1;i<=n;i++)\n    {\n      for(j=1;j<=n;j++)\n\t{\n\t  printf(\"%d\",router[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n  */\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v && count[packet[i].d]!=0)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint Q[101],head,tail,n,t[101][101],d[101],k[100];\nvoid enqueue(int x){\n  Q[tail++]=x;\n}\nint dequeue(){\n  return Q[head++];\n}\nvoid bfs(int s){\n  int u,v,w;\n  for(v=0;v<=n;v++) d[v]=10000;\n  d[s]=0;\n  enqueue(s);\n  while(head!=tail){\n    u=dequeue();\n    for(v=0;v<=n;v++){\n\tif(t[u][v]==1&&d[v]==10000){\n\t  d[v]=d[u]+1;\n\t  enqueue(v);\n      }\n    }\n  }\n}\n\nmain(){\n  int p,i,j,s,dd,TTL,r[100],m,tt[101][101];\n  scanf(\"%d\",&n);\n  head=0;\n  tail=0;\n  for(i=0;i<n;i++){\n    scanf(\"%d%d\",&r[i],&k[i]);\n    for(j=0;j<k[i];j++){\n      tt[r[i]][j]=10000;\n      scanf(\"%d\",&tt[r[i]][j]);\n    }\n  }\n  for(i=0;i<=n;i++){\n    for(j=0;j<=n;j++){\n      t[i][j]=0;\n    }\n  }\n\n  for(i=0;i<n;i++){\n    for(j=0;j<k[i];j++){\n      for(m=0;m<=n;m++){\n\tif(tt[r[i]][j]==m) t[r[i]][m]=1;\n      }\n    }\n  }\n\n\n  scanf(\"%d\",&p);\n  for(i=0;i<p;i++){\n    scanf(\"%d%d%d\",&s,&dd,&TTL);\n    bfs(s);\n\n    if(d[dd]<TTL) printf(\"%d\\n\",d[dd]+1);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "n,r,k,m[101][101],t[101],p;\ni,j,s,d,v0,v;\nmain(){\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&r,&k);\n\t\tfor(;k--;){\n\t\t\tscanf(\"%d\",&d);\n\t\t\tm[r][d]=1;\n\t\t}\n\t}\n\tscanf(\"%d\",&p);\n\tfor(;p--;){\n\t\tscanf(\"%d%d%d\",&s,&d,&v0);\n\t\tmemset(t,0,sizeof(t));\n\t\tt[s]=v=v0;\n\t\twhile(--v){\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(t[i]==v+1){\n\t\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\t\tif(m[i][j]&&t[j]==0)\n\t\t\t\t\t\t\tt[j]=v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t[d])\n\t\t\tprintf(\"%d\\n\",v0-t[d]+1);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(b=0;b<101;b++)\n\tcount[b]=0;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \t      \n\t    }\n\t}\n        if(count[packet[i].d]<=packet[i].v && count[packet[i].d]!=0)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n\n      for(b=0; b<101; b++)\n\tcount[b]=N;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  /*\n  for(i=1;i<=n;i++)\n    {\n      for(j=1;j<=n;j++)\n\t{\n\t  printf(\"%d\",router[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n  */\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint bfs(int,int,int);\nvoid push(int);\nint pop(void);\nint empty(void);\n\nint n,que[100000],graph[101][101],head=0,tail=0,vst[101],count[101];\n\nint main(void){\n  int r,k,t,p,s,d,v,i,j;\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&r,&k);\n\n    for(j=0;j<k;j++){\n      scanf(\"%d\",&t);\n      graph[r][t]=1;\n    }\n  }\n  \n  scanf(\"%d\",&p);\n\n  for(i=0;i<p;i++){\n    scanf(\"%d %d %d\",&s,&d,&v);\n\n    if(bfs(s,d,v)<=v && bfs(s,d,v)>0) printf(\"%d\\n\",bfs(s,d,v));\n    else printf(\"NA\\n\");\n  }\n\n  return 0;\n}\n\nint bfs(int s,int d,int v){\n  int u,i,j;\n\n  for(i=0;i<=n;i++)vst[i]=count[i]=0;\n  \n  count[s]=1;\n  push(s);\n  vst[s]=1;\n\n  while(!empty()){\n    u=pop();\n\n    for(i=1;i<=n;i++){\n      if(!vst[i] && graph[u][i]){\n\tpush(i);\n\tvst[i]=1;\n\tcount[i]=count[u]+1;\n      }\n    }\n  }\n\n  return count[d];\n}\n\nvoid push(int a){\n  que[tail++]=a;\n}\n\nint pop(void){\n  int res=que[head++];\n  return res;\n}\n\nint empty(void){\n  return tail==head?1:0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0144: Packet Transportation\n// 2017.8.9\n\n#include <stdio.h>\n\n#define MAX 100\nchar visited[MAX + 2];\nchar cost[MAX + 2][MAX + 2], len[MAX + 2];\nchar Q[2][MAX + 2], end[2];\nint n;\n\nint search(int s, int g, int v);\n\nint main(void)\n{\n\tint r, k, t;\n\tint P, s, d, v;\n\tint i, j;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &r, &k), len[r] = k;\n\t\tfor (j = 0; j < k; j++) scanf(\"%d\", &t), cost[r][j] = t;\n\t}\n\tscanf(\"%d\", &P);\n\tfor (i = 0; i < P; i++) {\n\t\tscanf(\"%d%d%d\", &s, &d, &v);\n\t\tif (v <= 1) puts(\"NA\");\n\t\telse {\n\t\t\tif ((j = search(s, d, v)) >= 0) printf(\"%d\\n\", j);\n\t\t\telse puts(\"NA\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int s, int g, int lim)\n{\n\tint i, k, k1, k2, step;\n\tint e, a, b;\n\n\tfor (i = 1; i <= n; i++) visited[i] = 0;\n\tQ[0][0] = s, end[0] = 1, visited[s] = 1;\n\tfor (k1 = 0, k2 = 1, step = 2; ; k2 = k1, k1 = !k2, step++) {\n\t\tfor (e = 0, i = end[k1] - 1; i >= 0; i--) {\n\t\t\ta = Q[k1][i];\n\t\t\tfor (k = len[a]; k-- > 0; ) {\n\t\t\t\tif ((b = cost[a][k]) == g) return step;\n\t\t\t\tif (!visited[b]) Q[k2][e++] = b, visited[b] = 1;\n\t\t\t}\n\t\t}\n\t\tif (e == 0) return -1;\n\t\tend[k2] = e;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  /*\n  for(i=1;i<=n;i++)\n    {\n      for(j=1;j<=n;j++)\n\t{\n\t  printf(\"%d\",router[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n  */\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(b=0;b<101;b++)\n\tcount[b]=0;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v && count[packet[i].d!=0])printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "q=100,wf[100][100];main(n,r,k,t){\n\tfor(n=0;n<q;)for(r=0;r<q;)wf[n++][r++]=(1<<21);\n\tfor(scanf(\"%d\",&n);n--;)\n\t\tfor(scanf(\"%d%d\",&r,&k);k--;wf[r-1][t-1]=1)\n\t\t\tscanf(\"%d\",&t);\n\tfor(k=0;k<q;k++)for(n=0;n<q;n++)for(r=0;r<q;r++)\n\twf[n][r]=wf[n][r]>wf[n][k]+wf[k][r]?wf[n][k]+wf[k][r]:wf[n][r];\n\tfor(scanf(\"%d\",&n);n--;){\n\t\tscanf(\"%d%d%d\",&r,&k,&t),r--,k--;\n\t\tif(t > wf[r][k])printf(\"%d\",wf[r][k]+1);\n\t\telse puts(\"NA\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 10000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 10000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 10000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1]; // oR·é[^Ì\n}\n\nint main() {\n  int i, j, r1, k1, p, temp;\n  int pacet[100][3];\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 10000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &pacet[i][0], &pacet[i][1], &pacet[i][2]);\n  }\n\n  for(i = 0; i < p; i++) {\n    temp = dijkstra(pacet[i][0], pacet[i][1]);\n    printf(\"temp:%d\\n\", temp);\n    if(pacet[i][2] - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\t  \n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]-1<packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????????????????±????´????????????????????????? */\n\ts4_t_oi = (S4)0;\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\", s4_tp_result[s4_t_oi2]);\n\t\t}\n\n\t\t/* ????????\\?????????????????? */\n\t\tif (s4_t_oi2 != s4_t_oi - 1) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "n,m[101][101],t[101];\ni,j,r,d,V,v;\nmain(){\n\tscanf(\"%d\",&n);\n\tfor(i=n++;i--;)\n\t\tfor(scanf(\"%d%d\",&r,&j);j--;m[r][d]=1)\n\t\t\tscanf(\"%d\",&d);\n\tfor(;~scanf(\"%*d%d%d%d\"+!!V*3,&r,&d,&v);t[d]?printf(\"%d\\n\",V-t[d]+1):puts(\"NA\"))\n\t\tfor(memset(t,0,404),r=t[r]=V=v;r&&!t[d]&&--v;)\n\t\t\tfor(r=0,i=n;--i;)\n\t\t\t\tfor(j=n;t[i]==v+1&&--j;)\n\t\t\t\t\tm[i][j]&!t[j]?r=t[j]=v:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\t  visited[packet[i].s]=1;\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,i,j,k,min,mi,a,b,m;\n  int d[101][101]={0};\n  int c[101][101]={0};\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&a,&m);\n    while(m--){\n      scanf(\"%d\",&b);\n      d[a][b]=1;\n    }\n  }\n  for(i=1;i<=n;i++){\n    c[mi=i][i]=0;\n    int f[101]={0};\n    for(j=0;j<n;j++){\n      f[mi]=1;\n      for(k=1;k<=n;k++){\n\tif(f[k]||d[mi][k]==0)continue;\n\tif(c[i][k]==0||c[i][k]>c[i][mi]+1)c[i][k]=c[i][mi]+1;\n      }\n      min=2100000000;\n      for(k=1;k<=n;k++){\n\tif(f[k]||c[i][k]==0)continue;\n\tif(min>c[i][k])min=c[i][mi=k];\n      }\n    }\n  }\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%d %d %d\",&a,&b,&k);\n    if(c[a][b]<k)printf(\"%d\\n\",c[a][b]+1);\n    else         printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 100000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 100000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 100000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1];\n}\n\nint main() {\n  int i, j, r1, k1, p, s1, d1, v1, temp;\n\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 100000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &s1, &d1, &v1);\n    temp = dijkstra(s1, d1);\n    if(v1 - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\ts4_t_oi = (S4)0;\n\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", s4_tp_result[s4_t_oi2]);\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????????????????±????´????????????????????????? */\n\ts4_t_oi = (S4)0;\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", s4_tp_result[s4_t_oi2]);\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[10000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b,fg;\n  \n  struct mail{\n    int s;\n    int d;\n    int v[101];\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v[1]);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(j=1;j<=p;j++)\n\t{\n\t  packet[i].v[j]=packet[i].v[1];\n\t}\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      //printf(\"A\\n\");\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\t{\n\tvisited[b]=0;\n\t}\n      \n      visited[packet[i].s]=1;\n      fg=0;\n      //printf(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\");\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\t  \n\t  for(j=1;j<=n;j++)\n\t    {\n\t      //printf(\"%dB\\n\",packet[i].v[j]);\n\t      //printf(\"%d\\n\",packet[i].v[j]);\n\t      \n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\n\t\t  packet[i].v[j]=packet[i].v[a]-1;\n\t\t  //printf(\"%d==%d\\n\",j,packet[i].d);\n\t\t  if(j==packet[i].d && packet[i].v[j]>0)printf(\"%d\\n\",count[packet[i].d]);\n\t\t  else if(fg==0 && packet[i].v[j]==-1 && a!=packet[i].d)\n\t\t    {\n\t\t      printf(\"NA\\n\");\n\t\t      fg=1;\n\t\t    }\n\t\t  \n\t\t} \n\t      \n\t    }\n\t  //printf(\"\\n\");\n\t}\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  /*\n  for(i=1;i<=n;i++)\n    {\n      for(j=1;j<=n;j++)\n\t{\n\t  printf(\"%d\",router[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n  */\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=N;\n\t    \n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==N)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100000\n\nint main(void)\n{\n  int n,p,r,k,t,a,count[101];\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[N];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t);\n\t  router[r][t]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  /*\n  for(i=1;i<=n;i++)\n    {\n      for(j=1;j<=n;j++)\n\t{\n\t  printf(\"%d\",router[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n  */\n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(b=0;b<101;b++)\n\tcount[b]=0;\n\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n\n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v && count[packet[i].d]!=0)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n\n\nVD main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)1;\n\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\ts4_t_hop++;\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex];\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\tprintf(\"%d\\n\", s4_t_hop);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\nint main(){\n\tint n,m,c[105][105],d[105],used[105],i,j,x,y,z,v;\n\tmemset(c,0,sizeof(c));\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)c[i][j]=1000000;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(j=0;j<y;j++){\n\t\t\tscanf(\"%d\",&z);\n\t\t\tc[x][z]=1;\n\t\t}\n\t}\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t//memset(d,-1,sizeof(d));\n\t\tfor(i=1;i<=n;i++)d[i]=1000000;\n\t\tmemset(used,0,sizeof(used));\n\t\td[x]=0;\n\t\twhile(1){\n\t\t\tv=-1;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(used[i]==0 && (v==-1 || v>d[i]))v=i;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=1;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\td[i]=min(d[i],d[v]+c[v][i]);\n\t\t\t}\n\t\t}\n\t\t//for(i=1;i<=n;i++)printf(\"%d:%d\\n\",i,d[i]);\n\t\tif(d[y]>100 || d[y]>=z)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",d[y]+1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n\n{\nint n,p,r,k,t,a,count[101];\n\nint queue[1000000],head=0,tail=0;\n\nint router[101][101],visited[101],i,j,b;\n\nstruct mail{\n\nint s;\n\nint d;\n\nint v;\n\n}packet[100000];\n\nfor(i=0;i<101;i++)\n\n{\n\nfor(j=0;j<101;j++)\n\n{\n\nrouter[i][j]=0;\n\n}\n\n}\n\nscanf(\"%d\",&n);\n\nfor(i=1;i<=n;i++)\n\n{\n\nscanf(\"%d%d\",&r,&k);\n\nfor(j=1;j<=k;j++)\n\n{\n\nscanf(\"%d\",&t);\n\nrouter[r][t]=1;\n\n}\n\n}\n\nfor(i=1;i<=n;i++)\n\n{\n\nrouter[i][i]=0;\n\n}\n\nscanf(\"%d\",&p);\n\nfor(i=1;i<=p;i++)\n\n{\n\nscanf(\"%d%d%d\",&packet[i].s ,&packet[i].d ,&packet[i].v);\n\n}\n\nfor(i=1;i<=p;i++)\n\n{\n\nfor(b=0;b<101;b++)\n\ncount[b]=0;\n\ncount[packet[i].s]=1;\n\nqueue[tail++]=packet[i].s;\n\nfor(b=0;b<101;b++)\n\nvisited[b]=0;\n\nvisited[packet[i].s]=1;\n\nwhile(head!=tail)\n\n{\na=queue[head++];\n\nfor(j=1;j<=n;j++)\n\n{\n\nif(router[a][j]==1 && visited[j]==0)\n\n{\n\nqueue[tail++]=j;\n\nvisited[j]=1;\n\ncount[j]=count[a]+1;\n\n}\n\n}\n\n}\n\nif(count[packet[i].d<=packet[i].v && count[packet[i].d] != 0)printf(\"%d\\n\",count[packet[i].d]);\n\nelse printf(\"NA\\n\");\n\n}\n\nreturn 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\nint main(){\n\tint n,m,c[105][105],d[105],used[105],i,j,x,y,z,v;\n\tmemset(c,0,sizeof(c));\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)c[i][j]=1000000;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(j=0;j<y;j++){\n\t\t\tscanf(\"%d\",&z);\n\t\t\tc[x][z]=1;\n\t\t}\n\t}\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t//memset(d,-1,sizeof(d));\n\t\tfor(i=1;i<=n;i++)d[i]=1000000;\n\t\tmemset(used,0,sizeof(used));\n\t\td[x]=0;\n\t\twhile(1){\n\t\t\tv=-1;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(used[i]==0 && (v==-1 || v>d[i]))v=i;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=1;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\td[i]=min(d[i],d[v]+c[v][i]);\n\t\t\t}\n\t\t}\n\t\t//for(i=1;i<=n;i++)printf(\"%d:%d\\n\",i,d[i]);\n\t\tif(d[y]+1>z)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",d[y]+1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint r[100][100];\nint n;\n\nint dijkstra(int start, int goal) {\n  int i;\n  int minimum, p;\n  int d[100], f[100];\n\n  for(i = 0; i < 100; i++) {\n    d[i] = 10000;\n    f[i] = 0;\n  }\n  d[start-1] = 1;\n  while(1) {\n    minimum = 10000;\n    for(i = 0; i < n; i++) {\n      if(d[i] < minimum && f[i] == 0) {\n\tminimum = d[i];\n\tp = i;\n      }\n    }\n    if(minimum == 10000) break;\n    f[p] = 1;\n\n    for(i = 0; i < n; i++) {\n      if(d[p] + r[p][i] < d[i]) {\n\td[i] = d[p] + r[p][i];\n      }\n    }\n  }\n\n  return d[goal-1]; // oR·é[^Ì\n}\n\nint main() {\n  int i, j, r1, k1, p, temp;\n  int pacet[100][3];\n  for(i = 0; i < 100; i++)\n    for(j = 0; j < 100; j++)\n      r[i][j] = 10000;\n\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d\", &r1, &k1);\n    for(j = 0; j < k1; j++) {\n      scanf(\"%d\", &temp);\n      r[r1-1][temp-1] = 1;\n    }\n  }\n  scanf(\"%d\", &p);\n  for(i = 0; i < p; i++) {\n    scanf(\"%d %d %d\", &pacet[i][0], &pacet[i][1], &pacet[i][2]);\n  }\n\n  for(i = 0; i < p; i++) {\n    temp = dijkstra(pacet[i][0], pacet[i][1]);\n    if(pacet[i][2] - temp < 0) {\n      printf(\"NA\\n\");\n    } else {\n      printf(\"%d\\n\", temp);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nint main(void)\n{\n    int i, j, k;\n    int n;\n    int dist[101][101];\n    int t, from, to;\n    \n    scanf(\"%d\", &n);\n    \n        for (i = 1; i <= n; i++){\n            for (j = 1; j <= n; j++){\n                dist[i][j] = 1000000;\n            }\n            dist[i][i] = 0;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d\", &from);\n            scanf(\"%d\", &k);\n            \n            for (j = 0; j < k; j++){\n                scanf(\"%d\", &to);\n                dist[from][to] = 1;\n            }\n        }\n        \n        for (k = 1; k <= n; k++){\n            for (i = 1; i <= n; i++){\n                for (j = 1; j <= n; j++){\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        \n        scanf(\"%d\", &n);\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d\", &from, &to, &j);\n            \n            if (dist[from][to] < j){\n                printf(\"%d\\n\", dist[from][to] + 1);\n            }\n            else {\n                printf(\"NA\\n\");\n            }\n        }\n        \n        return (0);\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????????????????±????´????????????????????????? */\n\ts4_t_oi = (S4)0;\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\", s4_tp_result[s4_t_oi2]);\n\t\t}\n\n\t\t/* ????????\\?????????????????? */\n\t\tif (s4_t_oi2 != s4_t_oi - 1) {\n\t\t\tprintf(\"\\n);\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n\n\nVD main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????± */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)0; u4_t_ri < u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)1;\n\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_si][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni < u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\ts4_t_hop++;\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex];\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\tprintf(\"%d\\n\", s4_t_hop);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[1000000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b;\n  \n  struct mail{\n    int s;\n    int d;\n    int v;\n  }packet[101];\n  \n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n      \n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n\t    \n      visited[packet[i].s]=1;\n\n      while(head!=tail)\n\t{\n\t  \n\t  a=queue[head++];\n\t  \n\t  for(j=1;j<=n;j++)\n\t    {\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\t\n\t\t} \n\t      \n\t    }\n\n\t}\n        if(count[packet[i].d]<=packet[i].v)printf(\"%d\\n\",count[packet[i].d]);\n\telse printf(\"NA\\n\");\n\t\t  \n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint bfs(int,int,int);\nvoid push(int);\nint pop(void);\nint empty(void);\n\nint n,que[1000000],graph[101][101],head=0,tail=0,vst[101],count[101];\n\nint main(void){\n  int r,k,t,p,s,d,v,i,j;\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&r,&k);\n\n    for(j=0;j<k;j++){\n      scanf(\"%d\",&t);\n      graph[r][t]=1;\n    }\n  }\n  \n  scanf(\"%d\",&p);\n\n  for(i=0;i<p;i++){\n    scanf(\"%d %d %d\",&s,&d,&v);\n\n    if(bfs(s,d,v)<=v && bfs(s,d,v)>0) printf(\"%d\\n\",bfs(s,d,v));\n    else printf(\"NA\\n\");\n  }\n\n  return 0;\n}\n\nint bfs(int s,int d,int v){\n  int u,i,j;\n\n  for(i=0;i<=n;i++)vst[i]=count[i]=0;\n  \n  count[s]=1;\n  push(s);\n  vst[s]=1;\n\n  while(!empty()){\n    u=pop();\n\n    for(i=1;i<=n;i++){\n      if(!vst[i] && graph[u][i]){\n\tpush(i);\n\tvst[i]=1;\n\tcount[i]=count[u]+1;\n      }\n    }\n  }\n\n  return count[d];\n}\n\nvoid push(int a){\n  que[tail++]=a;\n}\n\nint pop(void){\n  int res=que[head++];\n  return res;\n}\n\nint empty(void){\n  return tail==head?1:0;\n}"
  },
  {
    "language": "C",
    "code": "q=100,wf[100][100];main(n,r,k,t){for(n=0;n<q;)for(r=0;r<q;)wf[n++][r++]=999;for(scanf(\"%d\",&n);n--;)for(scanf(\"%d%d\",&r,&k);k--;wf[r-1][t-1]=1)scanf(\"%d\",&t);for(k=0;k<q;k++)for(n=0;n<q;n++)for(r=0;r<q;r++)wf[n][r]=wf[n][r]>wf[n][k]+wf[k][r]?wf[n][k]+wf[k][r]:wf[n][r];for(scanf(\"%d\",&n);n--;){scanf(\"%d%d%d\",&r,&k,&t),r--,k--;if(t > wf[r][k])printf(\"%d\",wf[r][k]+1);else puts(\"NA\");}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\nint main(){\n\tint n,m,c[105][105],d[105],used[105],i,j,x,y,z,v;\n\tmemset(c,0,sizeof(c));\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)c[i][j]=1000000;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(j=0;j<y;j++){\n\t\t\tscanf(\"%d\",&z);\n\t\t\tc[x][z]=1;\n\t\t}\n\t}\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t//memset(d,-1,sizeof(d));\n\t\tfor(i=1;i<=n;i++)d[i]=1000000;\n\t\tmemset(used,0,sizeof(used));\n\t\td[x]=0;\n\t\twhile(1){\n\t\t\tv=-1;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(used[i]==0 && (v==-1 || v>d[i]))v=i;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=1;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\td[i]=min(d[i],d[v]+c[v][i]);\n\t\t\t}\n\t\t}\n\t\t//for(i=1;i<=n;i++)printf(\"%d:%d\\n\",i,d[i]);\n\t\tif(d[y]==1000000 || d[y]>=z)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",d[y]+1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 102\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint visited[N]; /* already visited flag */\n\nint que[N][2];  /* queue for bfs {id,TTL} */\nint wp,rp;      /* write pointer, read pointer for queue */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n \n \nint check(int s,int d,int v){\n    int i,ret,nows,nowv,nexts;\n\n    for(i=0;i<N;i++)visited[i]=0;\n\n    /* init que */\n    wp=0;\n    rp=0;\n\n    /* push que */\n    que[wp][0]=s;\n    que[wp][1]=v;\n    wp++;\n    visited[s]=1;\n\n    if(s==d)return 0;\n\n    while(rp<wp){\n        /* pop que */\n        nows=que[rp][0];\n        nowv=que[rp][1];\n        rp++;\n\n        if(nows==d) return v-nowv+1; /* goal(return num of rooter) */\n        if(--nowv==0) continue;/* TTL is too small */\n\n        /* check next rooter */\n        for(i=0;root[nows][i];i++){\n            nexts=root[nows][i];\n\n            if(visited[nexts]) continue; /* already visited */\n            visited[nexts]=1;\n\n            /* push que */\n            que[wp][0]=nexts;\n            que[wp][1]=nowv;\n            wp++;\n        }\n    }\n\n    return 0;/* can't alive */\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n\n{\nint n,p,r,k,t,a,count[101];\n\nint queue[1000000],head=0,tail=0;\n\nint router[101][101],visited[101],i,j,b;\n\nstruct mail{\n\nint s;\n\nint d;\n\nint v;\n\n}packet[100000];\n\nfor(i=0;i<101;i++)\n\n{\n\nfor(j=0;j<101;j++)\n\n{\n\nrouter[i][j]=0;\n\n}\n\n}\n\nscanf(\"%d\",&n);\n\nfor(i=1;i<=n;i++)\n\n{\n\nscanf(\"%d%d\",&r,&k);\n\nfor(j=1;j<=k;j++)\n\n{\n\nscanf(\"%d\",&t);\n\nrouter[r][t]=1;\n\n}\n\n}\n\nfor(i=1;i<=n;i++)\n\n{\n\nrouter[i][i]=0;\n\n}\n\nscanf(\"%d\",&p);\n\nfor(i=1;i<=p;i++)\n\n{\n\nscanf(\"%d%d%d\",&packet[i].s ,&packet[i].d ,&packet[i].v);\n\n}\n\nfor(i=1;i<=p;i++)\n\n{\n\nfor(b=0;b<101;b++)\n\ncount[b]=0;\n\ncount[packet[i].s]=1;\n\nqueue[tail++]=packet[i].s;\n\nfor(b=0;b<101;b++)\n\nvisited[b]=0;\n\nvisited[packet[i].s]=1;\n\nwhile(head!=tail)\n\n{\na=queue[head++];\n\nfor(j=1;j<=n;j++)\n\n{\n\nif(router[a][j]==1 && visited[j]==0)\n\n{\n\nqueue[tail++]=j;\n\nvisited[j]=1;\n\ncount[j]=count[a]+1;\n\n}\n\n}\n\n}\n\nif(count[packet[i].d<=packet[i].v && count[packet[i].d] != 0)printf(\"%d\\n\",count[packet[i].d]);\n\nelse printf(\"NA\\n\");\n\n}\n\nreturn 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n\n#define VD void\n#define U4 unsigned int\n#define U1 unsigned char\n#define S4 int\n\n/* ---------- ?????°?????? ------------ */\n#define MAX_COUNT_ROUTER\t(100)\t\t/* ?????????????????§??° */\n#define MAX_CNT_PACKET\t\t(1000)\t\t/* PACKET????????§??° */\n\n#define NOT_CONNECTED\t\t(0)\t\t\t/* ???????????\\?¶??????? */\n#define IS_CONNECTED\t\t(1)\t\t\t/* ???????????\\?¶??????? */\n#define END_SEARCH\t\t\t(-1)\t\t/* ??¢?´¢????±???????????????? */\n\n#define IS_COMPLETE\t\t\t(1)\t\t\t/* ??¢?´¢?????? */\n#define\tNOT_COMPLETE\t\t(0)\t\t\t/* ??¢?´¢????????? */\n\n#define NA\t\t\t\t\t(-1)\t\t/* #NA */\n\n\n\nS4 main()\n{\n\t/* ---------- ?????°?????? ---------- */\n\tU4 u4_t_numRouter;\t\t/* ?????????????????? */\n\tU1 u1_t_delimiter;\t\t/* ??????????????? */\n\tS4 s4_t_TTL;\t\t\t/* TTL */\n\tS4 s4_t_srcRouter;\t\t/* ???????????????????????? */\n\tS4 s4_t_dstRouter;\t\t/* ????????????????????? */\n\n\tS4 s4_tp_connectedRouter[MAX_COUNT_ROUTER + 1][MAX_COUNT_ROUTER + 1] = { 0 };\t\t/* ???????????\\?¶??????±???????????????????´???????????????? */\n\tS4 s4_tp_searchRouter[MAX_COUNT_ROUTER + 1];\t\t\t\t\t\t\t\t\t\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_tp_nextSearchRouter[MAX_COUNT_ROUTER];\t\t\t\t\t\t\t\t\t\t/* ?¬??????¢?´¢????±???????????????? */\n\tS4 s4_tp_result[MAX_CNT_PACKET];\t\t\t\t\t\t\t\t\t\t\t\t\t/* ??????????´???¨?????? */\n\n\tU1 u1_t_isComplete;\t\t/* ??¢?´¢??????????????° */\n\n\t/* ---------- ???????????° ---------- */\n\tU4 u4_t_routerNumber;\t/* ??????????????? */\n\tU4 u4_t_cntPacket;\t\t/* ?????±????????° */\n\tS4 s4_t_searchRouter;\t/* ??¢?´¢????±???????????????? */\n\tS4 s4_t_nextSearchRouterIndex;\t/* ?¬??????¢?´¢????±????????????????????´???¨?????????????????? */\n\n\t/* ---------- ???????????? ---------- */\n\tU4 u4_t_ri;\t\t\t/* ???????????\\?¶??????±????´?????????? */\n\tU4 u4_t_pi;\t\t\t/* ?????±???????????±????´?????????? */\n\tS4 s4_t_hop;\t\t/* ???????????°(?????????????????±??°) */\n\tS4 s4_t_si;\t\t\t/* ??¢?´¢??¨????????? */\n\tU4 u4_t_ni;\t\t\t/* ?¬??????¢?´¢????±????????????????????´???¨????????? */\n\tU4 u4_t_ci;\t\t\t/* ??¢?´¢????±???????????????????????????¨????????? */\n\tS4 s4_t_oi;\t\t\t/* ??????????????¨????????????????????? */\n\tS4 s4_t_oi2;\t\t/* ??????????????¨????????????????????? */\n\n\t/* ??????????????°?????\\??? */\n\tscanf(\"%d%c\", &u4_t_numRouter, &u1_t_delimiter);\n\n\t/* ---------- ??????????????\\?¶??????±?????\\??? ---------- */\n\tfor (u4_t_ri = (U4)1; u4_t_ri <= u4_t_numRouter; u4_t_ri++) {\n\t\tu1_t_delimiter = ' ';\n\t\t/* ???????????????????????\\?¶??????±?????????????????? */\n\t\twhile (u1_t_delimiter != '\\n') {\n\t\t\tscanf(\"%d%c\", &u4_t_routerNumber, &u1_t_delimiter);\n\t\t\ts4_tp_connectedRouter[u4_t_ri][u4_t_routerNumber] = (S4)IS_CONNECTED;\n\t\t}\n\t}\n\n\t/* ---------- ??¢?´¢ ---------- */\n\tscanf(\"%d%c\", &u4_t_cntPacket, &u1_t_delimiter);\n\n\t/* ?????????????????±????´????????????????????????? */\n\ts4_t_oi = (S4)0;\n\n\t/* ?????±???????????°????????¢?´¢????????? */\n\tfor (u4_t_pi = (U4)0; u4_t_pi < u4_t_cntPacket; u4_t_pi++) {\n\t\t/* ???????????????????????????????????????????????????TTL?????\\??? */\n\t\tscanf(\"%d %d %d%c\", &s4_t_srcRouter, &s4_t_dstRouter, &s4_t_TTL, &u1_t_delimiter);\n\n\t\t/* 1???????????¢?´¢????????????????????´??\\????????£????????????????¢?????????? */\n\t\ts4_tp_searchRouter[0] = s4_t_srcRouter;\n\t\ts4_tp_searchRouter[1] = (S4)END_SEARCH;\n\n\t\tu1_t_isComplete = (U1)NOT_COMPLETE;\n\n\t\ts4_t_hop = (S4)2;\n\t\n\t\t/* ???????????°???TTL????¶???????????????¢?´¢????????????????????§??¢??? */\n\t\twhile ((s4_t_hop <= s4_t_TTL) &&\n\t\t\t   (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\ts4_t_si = (S4)0;\n\t\t\t/* ??¢?´¢????±?????????????????????????????????¢?´¢????????????????????§??¢??? */\n\t\t\twhile ((s4_tp_searchRouter[s4_t_si] != (S4)END_SEARCH) &&\n\t\t\t\t  (u1_t_isComplete != (U1)IS_COMPLETE)) {\n\n\t\t\t\t/* ??¢?´¢????±????????????¨????????????????????´??\\????????£?????????????¢???? */\n\t\t\t\ts4_t_searchRouter = s4_tp_searchRouter[s4_t_si];\n\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][s4_t_dstRouter] == (S4)IS_CONNECTED) {\n\t\t\t\t\tu1_t_isComplete = (U1)IS_COMPLETE;\n\t\t\t\t}\n\n\t\t\t\t/* ?????¨?????¢?´¢????±??????????????????´??\\????????£?????????????????? = ?¬??????¢?´¢????±?????????? */\n\t\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t\tfor (u4_t_ni = (U4)0; u4_t_ni <= u4_t_numRouter; u4_t_ni++) {\n\t\t\t\t\t\tif (s4_tp_connectedRouter[s4_t_searchRouter][u4_t_ni] == (S4)IS_CONNECTED) {\n\t\t\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ni] = (S4)IS_CONNECTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts4_t_si++;\n\t\t\t}\n\n\t\t\tif (u1_t_isComplete != (U1)IS_COMPLETE) {\n\t\t\t\t/* ??¢?´¢????±????????????????????????£???????????????????????¨???????????????????????§??????????????°????¢??????? */\n\t\t\t\ts4_t_hop++;\n\t\t\t}\n\n\t\t\t/* ?¬??????¢?´¢????±???????????????¢?´¢????±?????????????????????? */\n\t\t\ts4_t_nextSearchRouterIndex = (S4)0;\n\t\t\tfor (u4_t_ci = (U4)0; u4_t_ci < u4_t_numRouter; u4_t_ci++) {\n\t\t\t\tif (s4_tp_nextSearchRouter[u4_t_ci] == (S4)IS_CONNECTED) {\n\t\t\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = u4_t_ci;\n\t\t\t\t\ts4_t_nextSearchRouterIndex++;\n\t\t\t\t\t/* ????????? */\n\t\t\t\t\ts4_tp_nextSearchRouter[u4_t_ci] = (S4)NOT_CONNECTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts4_tp_searchRouter[s4_t_nextSearchRouterIndex] = (S4)END_SEARCH;\n\t\t}\n\n\t\t/* TTL??\\????????°?????§????????´??? */\n\t\tif (u1_t_isComplete == (U1)IS_COMPLETE) {\n\t\t\ts4_tp_result[s4_t_oi] = s4_t_hop;\n\t\t}\n\t\telse {\n\t\t\ts4_tp_result[s4_t_oi] = NA;\n\t\t}\n\t\ts4_t_oi++;\n\t}\n\n\t/* ???????????? */\n\tfor (s4_t_oi2 = (S4)0; s4_t_oi2 < s4_t_oi; s4_t_oi2++) {\n\t\tif (s4_tp_result[s4_t_oi2] == (S4)NA) {\n\t\t\tprintf(\"NA \");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d \", s4_tp_result[s4_t_oi2]);\n\t\t}\n\n\t\t/* ????????\\?????????????????? */\n\t\tif (s4_t_oi2 != s4_t_oi - 1) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\treturn((U4)0);\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 101\n\nint check(int s,int d,int v);\n\nint root[N][N]; /* rooter path */\nint distance[N]; /* already visited flag */\n\nint main(){\n    int n,r,k,t;\n    int p,s,d,v;\n    int i,j;\n    char c;\n    int ans;\n\n    /* init root */\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            root[i][j]=0;\n        }\n    }\n\n    /* input */\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&r);\n        scanf(\"%d\",&k);\n        for(j=0;j<k;j++){\n            scanf(\"%d\",&t);\n            root[r][j] = t;\n        }\n    }\n\n\n    scanf(\"%d\",&p);\n    for(i=0;i<p;i++){\n        scanf(\"%d %d %d\",&s,&d,&v);\n        ans = check(s,d,v);\n        printf(ans?\"%d\\n\":\"NA\\n\",ans);\n    }\n    return 0;\n}\n  \n  \nint check(int s,int d,int v){\n    int i,dis,id,nextid;\n\n    for(i=0;i<N;i++)distance[i]=0;\n\n    distance[s]=1;\n\n    for(dis=1;dis<v;dis++){\n        for(id=0;id<N;id++){\n            if(distance[id]==dis){\n                for(i=0;root[id][i]>0;i++){\n                    nextid=root[id][i];\n                    if(distance[nextid]==0){\n                        distance[nextid]=dis+1;\n                    }\n                }\n            }\n        }\n    }\n\n    return distance[d];\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  int n,p,r,k,t[101],a,count[101],flag;\n  int queue[10000],head=0,tail=0;\n  int router[101][101],visited[101],i,j,b,fg;\n\n  struct mail{\n    int s;\n    int d;\n    int v[101];\n  }packet[101];\n\n  for(i=0;i<101;i++)\n    {\n      for(j=0;j<101;j++)\n\t{\n\t  router[i][j]=0;\n\t}\n    }\n  \n  scanf(\"%d\",&n);\n  \n  for(i=1;i<=n;i++)\n    {\n      scanf(\"%d%d\",&r,&k);\n\n      for(j=1;j<=k;j++)\n\t{\n\t  scanf(\"%d\",&t[j]);\n\t  router[r][t[j]]=1;\n\t}\n    }\n  \n  for(i=1;i<=n;i++)\n    {\n      router[i][i]=0;\n    }\n  \n  scanf(\"%d\",&p);\n  \n  for(i=1;i<=p;i++)\n    {\n      scanf(\"%d%d%d\",&packet[i].s,&packet[i].d,&packet[i].v[1]);\n    }\n  \n  for(i=1;i<=p;i++)\n    {\n      for(j=1;j<=p;j++)\n\t{\n\t  packet[i].v[j]=packet[i].v[1];\n\t    }\n    }\n\n  for(i=1;i<=p;i++)\n    {\n      //printf(\"A\\n\");\n      count[packet[i].s]=1;\n      queue[tail++]=packet[i].s;\n      \n      for(b=0;b<=n;b++)\n\tvisited[b]=0;\n      \n      visited[packet[i].s]=1;\n\t  fg=0;\n      //printf(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\");\n      while(head!=tail)\n\t{\n\n\t  a=queue[head++];\n\t \n\t  for(j=1;j<=n;j++)\n\t    {\n\t      //printf(\"%dB\\n\",packet[i].v[j]);\n\t      //printf(\"%d\\n\",packet[i].v[j]);\n\n\t      if(router[a][j]==1 && visited[j]==0)\n\t\t{\n\t\t  queue[tail++]=j;\n\t\t  visited[j]=1;\n\t\t  count[j]=count[a]+1;\n\t\t  packet[i].v[j]=packet[i].v[a]-1;\n\t\t  //printf(\"%d==%d\\n\",j,packet[i].d);\n\t\t  if(j==packet[i].d && packet[i].v[j]>0)printf(\"%d\\n\",count[packet[i].d]);\n\t\t  else if(fg==0 && packet[i].v[j]==-1 && a!=packet[i].d)\n\t\t    {\nprintf(\"NA\\n\");\n fg=1;\n\t\t    }\n\t\t \n\t\t} \n\n\t    }\n\t  //printf(\"\\n\");\n\t}\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nfun main(args:Array<String>):Unit {\n    val n = readLine()!!.toInt()\n    val minRoute = Array(n){from -> Array(n){to -> if (from == to) 0 else Int.MAX_VALUE.toLong()}}\n    repeat(n){\n        val info = readLine()!!.split(' ').map(String::toInt)\n        info.drop(2).forEach { to ->\n            minRoute[info.first() - 1][to - 1] = 1\n        }\n    }\n    for (i in 0 until n) for (from in 0 until n) for (to in 0 until n){\n        if (minRoute[from][to] > minRoute[from][i] + minRoute[i][to])\n            minRoute[from][to] = minRoute[from][i] + minRoute[i][to]\n    }\n    repeat(readLine()!!.toInt()){\n        val (s, d, v) = readLine()!!.split(' ').map(String::toInt)\n        println(if (minRoute[s - 1][d - 1] >= v) \"NA\" else minRoute[s - 1][d - 1] + 1)\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tMap<Integer, List<Integer>> memomap = new HashMap<Integer, List<Integer>>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tmemomap.put(s, memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (Entry<Integer, List<Integer>> entry : memomap.entrySet()) {\n\t\t\tslove(map, memomap, entry.getKey(), entry.getKey(), 1, 0);\n\t\t}\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void slove(int[][] map, Map<Integer, List<Integer>> memomap,\n\t\t\tint i, int s, int n, int bit) {\n\t\tfor (int t : memomap.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, memomap, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\n/**\n * Packet Transportation\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\t// router info\n\t\t\tRouter.setCount(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\tint id, next;\n\t\t\t\tid = Integer.parseInt(st.nextToken());\n\t\t\t\tnext = Integer.parseInt(st.nextToken());\n\t\t\t\tRouter.setRouter(id);\n\t\t\t\tfor (int j = 0; j < next; j++) {\n\t\t\t\t\tRouter.getRouter(id).addNext(\n\t\t\t\t\t\t\tInteger.parseInt(st.nextToken()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// packet info\n\t\t\tint p = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\tint src, dst, ttl, hop;\n\t\t\t\tint d1, d2;\n\t\t\t\tline = br.readLine();\n\t\t\t\td1 = line.indexOf(' ');\n\t\t\t\td2 = line.indexOf(' ', d1 + 1);\n\t\t\t\tsrc = Integer.parseInt(line.substring(0, d1));\n\t\t\t\tdst = Integer.parseInt(line.substring(d1 + 1, d2));\n\t\t\t\tttl = Integer.parseInt(line.substring(d2 + 1));\n\t\t\t\thop = Router.getHops(src, dst, ttl);\n\t\t\t\tif (hop > 0) {\n\t\t\t\t\tSystem.out.println(hop);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Router {\n\n\tint id;\n\tArrayList<Integer> nexts;\n\n\tprivate static Router[] routers;\n\n\tstatic Router[] setCount(int n) {\n\t\tif (routers == null) {\n\t\t\trouters = new Router[n + 1];\n\t\t}\n\t\treturn routers;\n\t}\n\n\tstatic void setRouter(int id) {\n\t\tRouter r = new Router(id);\n\t\trouters[r.id] = r;\n\t}\n\n\tstatic Router getRouter(int id) {\n\t\treturn routers[id];\n\t}\n\n\tstatic int getHops(int src, int dst, int ttl) {\n\n\t\tDeque<Router.Hop> deque = new ArrayDeque<Router.Hop>();\n\t\tboolean[] passed = new boolean[routers.length];\n\t\tint hop = 0;\n\n\t\tRouter r = getRouter(src);\n\t\tdeque.offer(r.new Hop(r, ttl - 1));\n\t\tpassed[r.id] = true;\n\t\twhile (!deque.isEmpty()) {\n\t\t\tHop h = deque.poll();\n\t\t\tif (h.router.id == dst) {\n\t\t\t\thop = ttl - h.ttl;\n\t\t\t\tbreak;\n\t\t\t} else if (h.ttl > 0) {\n\t\t\t\tif (h.router.nexts.size() != 0) {\n\t\t\t\t\tfor (Integer i : h.router.nexts) {\n\t\t\t\t\t\tif (!passed[i]) {\n\t\t\t\t\t\t\tr = getRouter(i);\n\t\t\t\t\t\t\tdeque.offer(r.new Hop(r, h.ttl - 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hop;\n\t}\n\n\t//\n\tprivate Router(int id) {\n\t\tthis.id = id;\n\t\tnexts = new ArrayList<Integer>();\n\t}\n\n\tpublic void addNext(int id) {\n\t\tnexts.add(id);\n\t}\n\n\tprivate class Hop {\n\t\tRouter router;\n\t\tint ttl;\n\n\t\tpublic Hop(Router router, int ttl) {\n\t\t\tthis.router = router;\n\t\t\tthis.ttl = ttl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0144();\n\t}\n\t\n\tvoid AOJ0145(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\tC0145[] c=new C0145[N];\n\t\t\tfor(int i=0; i<N; i++)\tc[i]=new C0145(sc.nextInt(),sc.nextInt());\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C0145{\n\t\tint upper,down;\n\t\tC0145(int u,int d){\tthis.upper=u;\tthis.down=d;\t}\n\t}\n\t\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=120;\n\t\twhile(sc.hasNext()){\n\t\t\tint temp=sc.nextInt();\n\t\t\tMAX=max(MAX,temp);\n\t\t\tqueue.add(temp);\n\t\t}\n\t\tint[] num=new int[MAX],time=new int[MAX],seat=new int[17];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\ttime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"TIME\"+i+\" \"+time[i]);\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"NUM\"+i+\" \"+num[i]);\n\t\tint j=0,min=0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tseat=exit(seat,min,time);\n\t\t\tint temp=find(seat,num[j]);\n\t\t\tif(temp>=0 && min>=j*5){\n\t\t\t\tint q=queue.getFirst();\n\t\t\t\tif(j==q){\n\t\t\t\t\tout.println(max(0,min-j*5));\n\t\t\t\t\tqueue.removeFirst();\n\t\t\t\t}\n\t\t\t\tfor(int i=temp; i<temp+num[j]; i++)\tseat[i]=j;\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\tmin++;\n\t\t\t}\n\t\t\t//debug\n\t\t\t//disp(seat,min-1);\n\t\t}\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] exit(int[] seat,int min,int[] time){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint idx=seat[i],emin=idx*5+time[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tC0144[] close=new C0144[N+1];\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(--now.ttl==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j]){\n\t\t\t\t\t\t\tif(close[j]==null){\n\t\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl,now.c+1));\n\t\t\t\t\t\t\t\tclose[j]=new C0144(j,now.ttl,now.c+1);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(now.c+1<close[j].c || now.ttl>close[j].ttl){\n\t\t\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl,now.c+1));\n\t\t\t\t\t\t\t\t\tclose[j]=new C0144(j,now.ttl,now.c+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.TreeMap;\n\n\n\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic int INF = 2 << 26;\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tint[][] list = new int[n][n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tArrays.fill(list[i], INF);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint r1 = sc.nextInt()-1;\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0; j < k1; j++) {\n\t\t\t\tlist[r1][sc.nextInt()-1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++) {\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tlist[i][j] = Math.min(list[i][j], list[i][k]+list[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0; i < p; i++) {\n\t\t\tint s1 = sc.nextInt();\n\t\t\tint d1 = sc.nextInt();\n\t\t\tint v1 = sc.nextInt();\n\t\t\tint ret = list[s1-1][d1-1]+1;\n\t\t\tif(v1 < ret) {\n\t\t\t\tout.println(\"NA\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(ret);\n\t\t\t}\n\t\t}\n\n\t\tout.flush();\n\t}\n\n}\n\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] floyd(final int[][] adj, final int num){\n\t\tint[][] ret = new int[num][num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\tret[i][j] = adj[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tfor(int i = 0; i < num; i++){\n\t\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\t\tret[i][j] = Math.min(ret[i][j], ret[i][k] + ret[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int roters = Integer.parseInt(sc.nextLine());\n\t\tfinal int[][] adj_roter = new int[roters][roters];\n\t\t\n\t\tfor(int i = 0; i < roters; i++){\n\t\t\tfor(int j = 0; j < roters; j++){\n\t\t\t\tadj_roter[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < roters; i++){\n\t\t\tfinal String[] strs = sc.nextLine().split(\" \");\n\t\t\t\n\t\t\tfinal int start = Integer.parseInt(strs[0]) - 1;\n\t\t\tfinal int count = Integer.parseInt(strs[1]);\n\t\t\t\n\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\tadj_roter[start][Integer.parseInt(strs[j + 2]) - 1] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int[][] adj_min = floyd(adj_roter, roters);\n\t\t\n\t\t\n\t\tfinal int packets = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i = 0; i < packets; i++){\n\t\t\tfinal String[] strs = sc.nextLine().split(\" \");\n\t\t\tfinal int start = Integer.parseInt(strs[0]) - 1;\n\t\t\tfinal int end = Integer.parseInt(strs[1]) - 1;\n\t\t\tfinal int lim = Integer.parseInt(strs[2]);\n\t\t\t\n\t\t\tif(adj_min[start][end] < lim){\n\t\t\t\tSystem.out.println(adj_min[start][end]+1);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 1000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=0;\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min:\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 1000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=1000;\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=0;\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min:\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0147();\n\t}\n\t\n\tvoid AOJ0145(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\tC0145[] c=new C0145[N];\n\t\t\tfor(int i=0; i<N; i++)\tc[i]=new C0145(sc.nextInt(),sc.nextInt());\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C0145{\n\t\tint upper,down;\n\t\tC0145(int u,int d){\tthis.upper=u;\tthis.down=d;\t}\n\t}\n\t\n\t// OK\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=110;\n\t\twhile(sc.hasNext())\tqueue.add(sc.nextInt());\n\t\tint[] num=new int[MAX],atime=new int[MAX],itime=new int[MAX],seat=new int[17],ans=new int[MAX];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\tatime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(i+\": ATIME\"+atime[i]+\" NUM\"+num[i]);\n\t\tint gno=0,min=0;\n\t\twhile(gno<=99){\n\t\t\tseat=exit(seat,min,atime,itime);\n\t\t\tint temp=find(seat,num[gno]);\n\t\t\tif(temp>=0 && min>=gno*5){\n\t\t\t\tans[gno]=max(0,min-gno*5);\n\t\t\t\tfor(int i=temp; i<temp+num[gno]; i++)\tseat[i]=gno;\n\t\t\t\titime[gno]=min;\n\t\t\t\tgno++;\n\t\t\t}else{\n\t\t\t\t//debug\n\t\t\t\t//disp(seat,min);\n\t\t\t\tmin++;\n\t\t\t}\n\t\t}\n\t\t//disp(seat,min);\n\t\twhile(!queue.isEmpty())\tout.println(ans[queue.poll()]);\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<=17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] exit(int[] seat,int min,int[] atime,int[] itime){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint emin=itime[seat[i]]+atime[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\t// WA（原因不明）\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"1NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(now.ttl-1==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl-1,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(((ans<0 || ans>v)?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt()+1,l,i,j,c;int[][]a=new int[n][n];for(int[]b:a)Arrays.fill(b,n);for(i=1;i<n;++i)a[i][i]=0;for(i=1;i<n;++i)for(s.next(),j=s.nextInt();j-->0;)a[i][s.nextInt()]=1;for(c=1;c<n;++c)for(i=1;i<n;++i)for(j=1;j<n;++j)if((l=a[i][c]+a[c][j])<a[i][j])a[i][j]=l;for(n=s.nextInt();n-->0;)System.out.println((l=a[s.nextInt()][s.nextInt()])<s.nextInt()?l+1:\"NA\");}}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tMap<Integer, List<Integer>> memomap = new HashMap<Integer, List<Integer>>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tmemomap.put(s, memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (Integer entry : memomap.keySet()) {\n\t\t\tslove(map, memomap, entry, entry, 1, 1 << entry);\n\t\t}\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] == INF) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else if (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void slove(int[][] map, Map<Integer, List<Integer>> memomap,\n\t\t\tint i, int s, int n, int bit) {\n\t\tfor (int t : memomap.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, memomap, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tMap<Integer, List<Integer>> memomap = new HashMap<Integer, List<Integer>>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tmemomap.put(s, memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (Entry<Integer, List<Integer>> entry : memomap.entrySet()) {\n\t\t\tslove(map, memomap, entry.getKey(), entry.getKey(), 1, 0);\n\t\t}\n\t\tfor(int[] a : map){\n\t\t\tSystem.out.println(Arrays.toString(a));\n\t\t}\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[][] map, Map<Integer, List<Integer>> memomap,\n\t\t\tint i, int s, int n, int bit) {\n\t\tfor (int t : memomap.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, memomap, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tMap<Integer, List<Integer>> memomap = new HashMap<Integer, List<Integer>>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tmemomap.put(s, memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (Entry<Integer, List<Integer>> entry : memomap.entrySet()) {\n\t\t\tslove(map, memomap, entry.getKey(), entry.getKey(), 1, 0);\n\t\t}\n\t\t/*for(int[] a : map){\n\t\t\tSystem.out.println(Arrays.toString(a));\n\t\t}*/\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[][] map, Map<Integer, List<Integer>> memomap,\n\t\t\tInteger i, Integer s, int n, int bit) {\n\t\tfor (int t : memomap.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit ) {\n\t\t\t\tmap[i][t] = Math.min(map[i][t], n);\n\t\t\t\tslove(map, memomap, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tint start, goal, ttl;\n\tLinkedList<Integer>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tgraph = new LinkedList[n];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint u = sc.nextInt() - 1;// [^Ô\n\t\t\tint m = sc.nextInt();\n\t\t\tgraph[u] = new LinkedList<Integer>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tgraph[u].add(v);\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tstart = sc.nextInt() - 1;\n\t\t\tgoal = sc.nextInt() - 1;\n\t\t\tttl = sc.nextInt();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tboolean[] visited = new boolean[n];\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tque.offer(start);\n\t\td[start] = 1;\n\t\tvisited[start] = true;\n\t\tfor (; !que.isEmpty();) {\n\t\t\tint u = que.poll();\n\t\t\tfor (int v : graph[u]) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tque.offer(v);\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tvisited[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[goal] <= ttl) {\n\t\t\tprintln(\"\" + d[goal]);\n\t\t} else {\n\t\t\tprintln(\"NA\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint cnt(int s,int g,int cnt,int xy[][],int n){\n\t\tint result = 0;\n\t\tint c[] = new int [n+1];\n\t\tint d[] = new int [n+1];\n\t\tc[s] = 1;\n\t\tif(s == g)result = 1;\n\t\tfor(int i = 1;i < cnt;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tfor(int k = 1;k < n+1;k++){\n\t\t\t\t\tif(xy[j][k] == 1 && c[j] == i){\n\t\t\t\t\t\td[k] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tc[j] = d[j];\n\t\t\t}\n\t\t\tif(c[g] > 0){\n\t\t\t\tresult = c[g];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tint xy[][] = new int [n+1][n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint r1 = sc.nextInt();\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0;j < k1;j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\txy[r1][t] = 1;\n\t\t\t}\n    \t }\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint TTL = sc.nextInt();\n\t\t\tint ans = cnt(s,d,TTL,xy,n);\n\t\t\tif(ans == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//中身\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tSystem.out.print(xy[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n \npublic class Main {\n\t/**\n\t* @param args\n\t*/\n\tstatic class RT extends HashMap<Integer, int[]>{}\n\tstatic class DS extends HashMap<Integer, Integer>{}\n\tstatic class LS extends ArrayList<Integer>{}\n\tstatic class AS extends HashMap<Integer, DS>{}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tRT\t\tm = new RT();\n\t\tAS\t\to = new AS();\n\t\tint\t\tn = parseNum();\n\t\tint\t\tp = 0;\n\t\tint\t\ts = 0;\n\t\tint\t\td = 0;\n\t\tint\t\tv = 0;\n\t\tint[]\tT = new int[n];\n\n\t\t// ルータの経路を取得\n\t\tfor (int i = 0; i < T.length; i++) {\n\t\t\tint\t\tcr = parseNum();\n\t\t\tint[]\tnr = new int[parseNum()];\n\n\t\t\tfor (int j = 0; j < nr.length; j++) {\n\t\t\t\tnr[j] = parseNum();\n\t\t\t}\n\t\t\tm.put(cr, nr);\n\t\t\tT[i] = cr;\n\t\t}\n\n\t\t// 他のルータまでの距離を取得\n\t\tfor (int i = 0; i < T.length; i++) {\n\t\t\tint\t\tlen = 0;\n\t\t\tint\t\tcnt = 2;\n\t\t\tDS\t\tttl = new DS();\n\t\t\tLS\t\tlst = new LS();\n\n\t\t\tlst.add(T[i]);\n\t\t\tttl.put(T[i], 1);\n\t\t\twhile ((len = lst.size()) > 0) {\n\t\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\t\tint[]\tnp = m.get(lst.remove(0));\n\t\t\t\t\tfor (int k = 0; k < np.length; k++) {\n\t\t\t\t\t\tif (!ttl.containsKey(np[k])) {\n\t\t\t\t\t\t\tttl.put(np[k], cnt);\n\t\t\t\t\t\t\tlst.add(np[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\to.put(T[i], ttl);\n\t\t}\n\n\t\tp = parseNum();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\ts = parseNum();\n\t\t\td = parseNum();\n\t\t\tv = parseNum();\n\t\t\tif (!o.containsKey(s)) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else {\n\t\t\t\tDS\ttmp = o.get(s);\n\t\t\t\tif (!tmp.containsKey(d)) {\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t} else {\n\t\t\t\t\tint\tmax = tmp.get(d);\n\t\t\t\t\tif (v < max) {\n\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(Math.min(v, max));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = 0;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n \n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (skp == 0) {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1 << 28;\n\t\tint n = sc.nextInt();\n\t\tint[][] root = new int[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tArrays.fill(root[i], INF);\n\t\t\troot[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\troot[r][sc.nextInt()] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\troot[i][j] = Math.min(root[i][j], root[i][k] + root[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tint dis = root[s][d];\n\t\t\tif (dis == INF) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else if (dis < v) {\n\t\t\t\tSystem.out.println(dis + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0144();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\t/*\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tfor(int j=1; j<=N; j++)\tif(R[i][j])\tout.print(i+\"-\"+j+\" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(--now.ttl==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=min(ans,now.c+1);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans==Integer.MAX_VALUE?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tint[][] cost;\n\tboolean[] visit;\n\tint[] dist;\n\tint n;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tn = scan.nextInt();\n\t\t\tcost = new int[n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tArrays.fill(cost[i], 100000);\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tint r = scan.nextInt() - 1;\n\t\t\t\tint k = scan.nextInt();\n\t\t\t\tfor(int j = 0;j < k;j++){\n\t\t\t\t\tint t = scan.nextInt() - 1;\n\t\t\t\t\tcost[r][t] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p = scan.nextInt();\n\t\t\tfor(int i = 0;i < p;i++){\n\t\t\t\tint s = scan.nextInt() - 1;\n\t\t\t\tint d = scan.nextInt() - 1;\n\t\t\t\tint v = scan.nextInt();\n\t\t\t\tvisit = new boolean[n];\n\t\t\t\tdist = new int[n];\n\t\t\t\tArrays.fill(dist, 1000000);\n\t\t\t\tdijkstra(s);\n\t\t\t\tSystem.out.println((dist[d]+1 <= v)?Math.min(dist[d]+1,v):\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\tpublic void dijkstra(int start){\n\t\tdist[start] = 0;\n\t\twhile(true){\n\t\t\tint min = 1000000;\n\t\t\tint next = -1;\n\t\t\tfor(int u = 0;u < n;u++){\n\t\t\t\tif(visit[u]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdist[u] = Math.min(dist[u],dist[start] + cost[start][u]);\n\t\t\t\tif(dist[u] < min){\n\t\t\t\t\tmin = dist[u];\n\t\t\t\t\tnext = u;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[start] = true;\n\t\t\tstart = next;\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\n/**\n * Packet Transportation\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tbyte n = Byte.parseByte(line);\n\n\t\t\t// router info\n\t\t\tRouter.setCount(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\tbyte id, next;\n\t\t\t\tid = Byte.parseByte(st.nextToken());\n\t\t\t\tnext = Byte.parseByte(st.nextToken());\n\t\t\t\tRouter.setRouter(id);\n\t\t\t\tfor (int j = 0; j < next; j++) {\n\t\t\t\t\tRouter.getRouter(id)\n\t\t\t\t\t\t\t.addNext(Byte.parseByte(st.nextToken()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// packet info\n\t\t\tint p = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\tbyte src, dst;\n\t\t\t\tint ttl, hop;\n\t\t\t\tint d1, d2;\n\t\t\t\tline = br.readLine();\n\t\t\t\td1 = line.indexOf(' ');\n\t\t\t\td2 = line.indexOf(' ', d1 + 1);\n\t\t\t\tsrc = Byte.parseByte(line.substring(0, d1));\n\t\t\t\tdst = Byte.parseByte(line.substring(d1 + 1, d2));\n\t\t\t\tttl = Integer.parseInt(line.substring(d2 + 1));\n\t\t\t\thop = Router.getHops(src, dst, ttl);\n\t\t\t\tif (hop > 0) {\n\t\t\t\t\tSystem.out.println(hop);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Router {\n\n\tbyte id;\n\tArrayList<Byte> nexts;\n\n\tprivate static Router[] routers;\n\n\tstatic Router[] setCount(byte n) {\n\t\tif (routers == null) {\n\t\t\trouters = new Router[n + 1];\n\t\t}\n\t\treturn routers;\n\t}\n\n\tstatic void setRouter(byte id) {\n\t\tRouter r = new Router(id);\n\t\trouters[r.id] = r;\n\t}\n\n\tstatic Router getRouter(byte id) {\n\t\treturn routers[id];\n\t}\n\n\tstatic int getHops(byte src, byte dst, int ttl) {\n\n\t\tDeque<Router.Hop> deque = new ArrayDeque<Router.Hop>();\n\t\tboolean[] passed = new boolean[routers.length];\n\t\tint hop = 0;\n\n\t\tRouter r = getRouter(src);\n\t\tdeque.offer(r.new Hop(r, ttl - 1));\n\t\tpassed[r.id] = true;\n\t\twhile (!deque.isEmpty()) {\n\t\t\tHop h = deque.poll();\n\t\t\tif (h.router.id == dst) {\n\t\t\t\thop = ttl - h.ttl;\n\t\t\t\tbreak;\n\t\t\t} else if (h.ttl > 0) {\n\t\t\t\tif (h.router.nexts.size() != 0) {\n\t\t\t\t\tfor (Byte i : h.router.nexts) {\n\t\t\t\t\t\tif (!passed[i]) {\n\t\t\t\t\t\t\tr = getRouter(i);\n\t\t\t\t\t\t\tdeque.offer(r.new Hop(r, h.ttl - 1));\n\t\t\t\t\t\t\tpassed[i] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hop;\n\t}\n\n\t//\n\tprivate Router(byte id) {\n\t\tthis.id = id;\n\t\tnexts = new ArrayList<Byte>();\n\t}\n\n\tpublic void addNext(byte id) {\n\t\tnexts.add(id);\n\t}\n\n\tprivate class Hop {\n\t\tRouter router;\n\t\tint ttl;\n\n\t\tpublic Hop(Router router, int ttl) {\n\t\t\tthis.router = router;\n\t\t\tthis.ttl = ttl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1 << 28;\n\t\tint n = sc.nextInt();\n\t\tint[][] root = new int[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tArrays.fill(root[i], INF);\n\t\t\troot[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\troot[r][sc.nextInt()] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\troot[i][j] = Math.min(root[i][j], root[i][k] + root[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tint dis = root[s][d];\n\t\t\tif (dis == INF) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else if (dis < v) {\n\t\t\t\tSystem.out.println(dis+1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tList<List<Integer>> list = new ArrayList<List<Integer>>();\n\t\tMap<Integer, List<Integer>> memomap = new HashMap<Integer, List<Integer>>();\n\t\tlist.add(new ArrayList<Integer>());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tmemomap.put(s, memo);\n\t\t\tlist.add(memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\t/*for (int i = 1; i <= n; i++) {\n\t\t\tslove(map, list, i, i, 1, 0);\n\t\t}*/\n\t\tfor (Entry<Integer, List<Integer>> entry : memomap.entrySet()) {\n\t\t\tslove(map, memomap, entry.getKey(), entry.getKey(), 1, 0);\n\t\t}\n\t\t/*for(int[] a : map){\n\t\t\tSystem.out.println(Arrays.toString(a));\n\t\t}*/\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[][] map, Map<Integer, List<Integer>> memomap,\n\t\t\tInteger i, Integer s, int n, int bit) {\n\t\tfor (int t : memomap.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, memomap, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void slove(int[][] map, List<List<Integer>> list, int i,\n\t\t\tint s, int n, int bit) {\n\t\tfor (int t : list.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, list, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt()+1,l,i,j,c,m;int[][]a=new int[n][n];for(int[]b:a)Arrays.fill(b,n);for(i=1;i<n;++i)a[i][i]=0;for(i=1;i<n;++i)for(s.next(),j=s.nextInt();j-->0;)a[i][s.nextInt()]=1;for(c=1;c<n;++c)for(i=1;i<n;++i)for(j=1;j<n;++j)if((l=a[i][c]+a[c][j])<a[i][j])a[i][j]=l;for(m=s.nextInt();m-->0;)System.out.println((l=a[s.nextInt()][s.nextInt()])<Math.min(s.nextInt(),n)?l+1:\"NA\");}}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 1000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew AOj0144().doIt();\n\t}\n\t\n\tclass AOj0144{\n\t\tint n,d[][];\n\t\t\n\t\tvoid print(){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tSystem.out.print(i+\": \");for(int s=1;s<=n;s++)System.out.printf(\"%7d \",d[i][s]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt(){\n\t\t\tn = Integer.parseInt(in.nextLine());\t\t\t\n\t\t\td = new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)Arrays.fill(d[i],100000);\n\t\t\tfor(int i=0;i<n;i++)d[i][i] = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint num = in.nextInt();\n\t\t\t\tint w = in.nextInt();\n\t\t\t\tfor(int s=0;s<w;s++)d[num][in.nextInt()] = 1;\n\t\t\t}\n\t\t\tfor(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){\n\t\t\t\td[i][j] = Math.min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\n\t\t\t\n//\t\t\tprint();\n\t\t\t\n\t\t\tint packet = in.nextInt();\n\t\t\tfor(int s=0;s<packet;s++){\n\t\t\t\tint start = in.nextInt();\n\t\t\t\tint end = in.nextInt();\n\t\t\t\tint ttl = in.nextInt();\n\t\t\t\tif(d[start][end]==100000||d[start][end]>=ttl)System.out.println(\"NA\");\n\t\t\t\telse System.out.println(d[start][end]+1); \n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tList<List<Integer>> list = new ArrayList<List<Integer>>();\n\t\tlist.add(new ArrayList<>());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanner.next();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tlist.add(memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tslove(map, list, i, i, 1, 1 << i);\n\t\t}\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[][] map, List<List<Integer>> list, int i,\n\t\t\tint s, int n, int bit) {\n\t\tfor (int t : list.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, list, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\tfinal int INF = 100000;\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint [][] data = new int[n+1][n+1];\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(i !=j){\n\t\t\t\t\tdata[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint from = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\twhile(k-- > 0){\n\t\t\t\tint to = sc.nextInt();\n\t\t\t\tdata[from][to] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\t\tdata[i][k] = Math.min(data[i][k], data[i][j] + data[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint p = sc.nextInt();\n\t\twhile(p-- > 0){\n\t\t\tint from = sc.nextInt();\n\t\t\tint to = sc.nextInt();\n\t\t\tint ttl = sc.nextInt();\n\t\t\tif(data[from][to] + 1 <= ttl){\n\t\t\t\tSystem.out.println(data[from][to] + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0144();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(--now.ttl==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Queue<Pair> queue = new LinkedList<Pair>();\n\n\tstatic class Pair {\n\t\tint routerIndex;\n\t\tint cost;\n\n\t\tPair(int index, int cost) {\n\t\t\tthis.routerIndex = index;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tstatic class Router {\n\t\tint number;\n\t\tint degree;\n\t\tRouter next[];\n\t\tint cost;\n\t\tboolean mark;\n\n\t\tRouter(int number) {\n\t\t\tthis.number = number;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tRouter rt[];\n\n\t\tn = sc.nextInt();\n\t\trt = new Router[n + 1];\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\trt[i] = new Router(i);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint number = sc.nextInt();\n\t\t\tint degree = sc.nextInt();\n\t\t\trt[i].degree = degree;\n\t\t\trt[i].next = new Router[degree];\n\t\t\tfor (int j = 0; j < degree; j++) {\n\t\t\t\trt[i].next[j] = rt[sc.nextInt()];\n\t\t\t}\n\t\t}\n\t\tm = sc.nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint start = sc.nextInt();\n\t\t\tint goal = sc.nextInt();\n\t\t\tint tll = sc.nextInt();\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\trt[j].mark = false;\n\t\t\t\trt[j].cost = -1;\n\t\t\t}\n\t\t\tqueue.clear();\n\t\t\tif (!bestWay(rt, n, start, goal, 1)) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else if (rt[goal].cost <= tll) {\n\t\t\t\tSystem.out.println(rt[goal].cost);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean bestWay(Router rt[], int n, int start, int goal, int cost) {\n\t\tif (rt[start].mark) {\n\t\t\treturn false;\n\t\t}\n\t\trt[start].cost = cost;\n\t\tif (start == goal) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < rt[start].degree; i++) {\n\t\t\tPair p = new Pair(rt[start].next[i].number, cost + 1);\n\t\t\tqueue.add(p);\n\t\t}\n\t\trt[start].mark = true;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tPair p = queue.poll();\n\t\t\tif (bestWay(rt, n, p.routerIndex, goal, p.cost)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tprivate static final int MAX = 1000000;\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] map = new int[n+1][n+1];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint from = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tmap[from][sc.nextInt()] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfloyd(map);\n\n\t\tint m = sc.nextInt();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from = sc.nextInt();\n\t\t\tint to = sc.nextInt();\n\t\t\tint rem = sc.nextInt();\n\n\t\t\tif(map[from][to] < MAX && rem >= map[from][to]+1){\n\t\t\t\tSystem.out.println(map[from][to]+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void floyd(int[][] map){\n\t\tint n = map.length-1;\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tmap[i][j] = map[i][j] == 0 ? MAX : map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(i == j) continue;\n\t\t\t\t\tmap[i][j] = Math.min(map[i][j],map[i][k]+map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 100);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor (int i=0;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? root[s][t]+1 : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tList<List<Integer>> list = new ArrayList<List<Integer>>();\n\t\tlist.add(new ArrayList<Integer>());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanner.next();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tlist.add(memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tslove(map, list, i, i, 1, 0);\n\t\t}\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[][] map, List<List<Integer>> list, int i,\n\t\t\tint s, int n, int bit) {\n\t\tfor (int t : list.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, list, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tint start, goal, ttl;\n\tLinkedList<Integer>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tgraph = new LinkedList[n];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint u = sc.nextInt() - 1;// [^Ô\n\t\t\tint m = sc.nextInt();\n\t\t\tgraph[u] = new LinkedList<Integer>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tgraph[u].add(v);\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tstart = sc.nextInt() - 1;\n\t\t\tgoal = sc.nextInt() - 1;\n\t\t\tttl = sc.nextInt();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tboolean[] visited = new boolean[n];\n\t\tint[] d = new int[n];\n\t\tque.offer(start);\n\t\td[start] = 1;\n\t\tvisited[start] = true;\n\t\tfor (; !que.isEmpty();) {\n\t\t\tint u = que.poll();\n\t\t\tfor (int v : graph[u]) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tque.offer(v);\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tvisited[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[goal] <= ttl) {\n\t\t\tprintln(\"\" + d[goal]);\n\t\t} else {\n\t\t\tprintln(\"NA\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tMap<Integer, Set<Integer>> map = new HashMap<Integer, Set<Integer>>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint id = nextInt();\n\t\t\tint num = nextInt();\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\tint x = nextInt();\n\t\t\t\tset.add(x);\n\t\t\t}\n\t\t\tmap.put(id, set);\n\t\t}\n\t\tint m = nextInt();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint start = nextInt();\n\t\t\tint stop = nextInt();\n\t\t\tint live = nextInt();\n\t\t\tint repeat = live-1;\n\t\t\tSet<Integer> temp = new HashSet<Integer>(map.get(start));\n\t\t\tSet<Integer> add = new HashSet<Integer>(map.get(start));\n\t\tout:while( repeat-- > 0 && !temp.contains(stop) ){\n\t\t\t\tSet<Integer> next = new HashSet<Integer>();\n\t\t\t\tfor(Integer x : add){\n\t\t\t\t\tfor(Integer y : map.get(x)){\n\t\t\t\t\t\tif( !temp.contains(y) ){\n\t\t\t\t\t\t\ttemp.add(y);\n\t\t\t\t\t\t\tnext.add(y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadd = new HashSet<Integer>(next);\n\t\t\t}\n\t\t\tif( repeat >= 0 ){\n\t\t\t\twriter.println(live-repeat);\n\t\t\t} else {\n\t\t\t\twriter.println(\"NA\");\n\t\t\t}\n\t\t}\t\t\t\t\t\n\t\twriter.flush();\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main\n{\n    static final int inf = 99999;\n    int[][] a;\n\n    Main(){\n\tScanner sc = new Scanner(System.in);\n\tint n, m, s, t;\n\n\twhile(sc.hasNext()){\n\t    n = sc.nextInt();\n\t    a = new int[n+1][n+1];\n\n\t    for(int i = 0; i <= n; ++i)\n\t\tfor(int j = i+1; j <= n; ++j)\n\t\t    a[i][j] = a[j][i] = inf;\n\n\t    for(int i = 0; i < n; ++i){\n\t\ts = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tfor(int j = 0; j < m; ++j){\n\t\t    t = sc.nextInt();\n\t\t    a[s][t] = 1;\n\t\t}\n\t    }\n\n\t    for(int k = 1; k <= n; ++k)\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t    for(int j = 1; j <= n; ++j)\n\t\t\ta[i][j] = Math.min(a[i][j], a[i][k]+a[k][j]);\n\n\t    n = sc.nextInt();\n\t    for(int i = 0; i < n; ++i){\n\t\ts = sc.nextInt();\n\t\tt = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(a[s][t] < m)\n\t\t    System.out.println(Integer.toString(a[s][t]+1));\n\t\telse\n\t\t    System.out.println(\"NA\");\n\t    }\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt()+1,l,i,j,c,m;int[][]a=new int[n][n];for(int[]b:a)Arrays.fill(b,n);for(i=1;i<n;++i)a[i][i]=0;for(i=1;i<n;++i)for(s.next(),j=s.nextInt();j-->0;)a[i][s.nextInt()]=1;for(c=1;c<n;++c)for(i=1;i<n;++i)for(j=1;j<n;++j)if((l=a[i][c]+a[c][j])<a[i][j])a[i][j]=l;for(m=s.nextInt();m-->0;)System.out.println((l=a[s.nextInt()][s.nextInt()])<s.nextInt()&&l<n?l+1:\"NA\");}}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Packet Transportation\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tboolean[][] f = new boolean[n+1][n+1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint b = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tf[b][sc.nextInt()] = true;\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\twhile(p--!=0){\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint ttl = sc.nextInt();\n\t\t\tboolean[] u = new boolean[n+1];\n\t\t\tu[s] = true;\n\t\t\tint step = 1;\n\t\t\tList<Integer> l = new ArrayList<Integer>();\n\t\t\tl.add(s);\n\t\t\tString ans = \"NA\";\n\t\t\twhile(!l.isEmpty()&&step<=ttl){\n\t\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\t\tfor(int a:l){\n\t\t\t\t\tif(a==t){\n\t\t\t\t\t\tans = step+\"\";\n\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\t\tif(f[a][i]&&!u[i]){\n\t\t\t\t\t\t\tu[i] = true;\n\t\t\t\t\t\t\tnext.add(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0144();\n\t}\n\t\n\tvoid AOJ0145(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\tC0145[] c=new C0145[N];\n\t\t\tfor(int i=0; i<N; i++)\tc[i]=new C0145(sc.nextInt(),sc.nextInt());\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C0145{\n\t\tint upper,down;\n\t\tC0145(int u,int d){\tthis.upper=u;\tthis.down=d;\t}\n\t}\n\t\n\t// OK\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=110;\n\t\twhile(sc.hasNext())\tqueue.add(sc.nextInt());\n\t\tint[] num=new int[MAX],atime=new int[MAX],itime=new int[MAX],seat=new int[17],ans=new int[MAX];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\tatime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(i+\": ATIME\"+atime[i]+\" NUM\"+num[i]);\n\t\tint gno=0,min=0;\n\t\twhile(gno<=99){\n\t\t\tseat=exit(seat,min,atime,itime);\n\t\t\tint temp=find(seat,num[gno]);\n\t\t\tif(temp>=0 && min>=gno*5){\n\t\t\t\tans[gno]=max(0,min-gno*5);\n\t\t\t\tfor(int i=temp; i<temp+num[gno]; i++)\tseat[i]=gno;\n\t\t\t\titime[gno]=min;\n\t\t\t\tgno++;\n\t\t\t}else{\n\t\t\t\t//debug\n\t\t\t\t//disp(seat,min);\n\t\t\t\tmin++;\n\t\t\t}\n\t\t}\n\t\t//disp(seat,min);\n\t\twhile(!queue.isEmpty())\tout.println(ans[queue.poll()]);\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<=17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] exit(int[] seat,int min,int[] atime,int[] itime){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint emin=itime[seat[i]]+atime[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\t// WA（原因不明）\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"1NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(now.ttl-1<=0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl-1,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(((ans<0)?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic short[][] d;\n\tstatic final short INF = Short.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner scan = new Scanner(System.in);\n\t\tshort n = scan.nextShort();\n\t\td = new short[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = i!=j ? INF : 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tshort id = scan.nextShort();\n\t\t\tshort c = scan.nextShort();\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\td[id-1][scan.nextShort()-1]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = (short)Math.min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint p = scan.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tshort s = scan.nextShort();\n\t\t\tshort g = scan.nextShort();\n\t\t\tshort ttl = scan.nextShort();\n\t\t\tout.println(ttl<=d[s-1][g-1] || d[s-1][g-1]==INF ? \"NA\" : d[s-1][g-1]+1);\n\t\t}\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] floyd(final int[][] adj, final int num){\n\t\tint[][] ret = new int[num][num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\tret[i][j] = adj[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tfor(int i = 0; i < num; i++){\n\t\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\t\tret[i][j] = Math.min(ret[i][j], ret[i][k] + ret[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int roters = Integer.parseInt(sc.nextLine());\n\t\tfinal int[][] adj_roter = new int[roters][roters];\n\t\t\n\t\tfor(int i = 0; i < roters; i++){\n\t\t\tfor(int j = 0; j < roters; j++){\n\t\t\t\tadj_roter[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < roters; i++){\n\t\t\tfinal String[] strs = sc.nextLine().split(\" \");\n\t\t\t\n\t\t\tfinal int start = Integer.parseInt(strs[0]) - 1;\n\t\t\tfinal int count = Integer.parseInt(strs[1]);\n\t\t\t\n\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\tadj_roter[start][Integer.parseInt(strs[j + 2]) - 1] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int[][] adj_min = floyd(adj_roter, roters);\n\t\t\n\t\t\n\t\tfinal int packets = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i = 0; i < packets; i++){\n\t\t\tfinal String[] strs = sc.nextLine().split(\" \");\n\t\t\tfinal int start = Integer.parseInt(strs[0]) - 1;\n\t\t\tfinal int end = Integer.parseInt(strs[1]) - 1;\n\t\t\tfinal int lim = Integer.parseInt(strs[2]);\n\t\t\t\n\t\t\tif(adj_min[start][end] < lim){\n\t\t\t\tSystem.out.println(adj_min[start][end]+1);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\tSystem.out.println(adj_min[start][end]+1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tboolean[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new boolean[n][n];\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = true;\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println(bfs(s,t,v));\n\t\t}\n\t}\n\t\n\tString bfs(int s, int t, int v) {\n\t\tLinkedList<V> q = new LinkedList<V>();\n\t\tq.add(new V(s, v-1));\n\t\tboolean[] used = new boolean[n];\n\t\tused[s] = true;\n\t\tfor (;! q.isEmpty();) {\n\t\t\tV cur = q.removeFirst();\n\t\t\tif (t == cur.p) return \"\" + (v - cur.c);\n\t\t\tif (cur.c == 0) continue;\n\t\t\tfor (int i=0;i<n;i++) if (! used[i] && es[cur.p][i] ) {\n\t\t\t\tused[i] = true;\n\t\t\t\tq.add(new V(i, cur.c - 1));\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n\t\n\tclass V {\n\t\tint p, c;\n\t\tV(int p, int c) {\n\t\t\tthis.p = p;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.deepToString;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tHashMap<Integer, Integer> mp;\n\tint getId(int num) {\n\t\tif (mp.containsKey(num)) {\n\t\t\treturn mp.get(num);\n\t\t}\n\t\tint v = mp.size();\n\t\tmp.put(num, v);\n\t\treturn v;\n\t}\n\tstatic final int INF = 1001001001;\n\t\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tmp = new HashMap<Integer,Integer>();\n\t\t\t\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(g[i], INF);\n\t\t\t\tg[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint here = getId(sc.nextInt());\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint there = getId(sc.nextInt());\n\t\t\t\t\tg[here][there] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) g[i][j] = Math.min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t\n\t\t\tint Q = sc.nextInt();\n\t\t\tfor (int q = 0; q < Q; q++) {\n\t\t\t\tint s = getId(sc.nextInt());\n\t\t\t\tint t = getId(sc.nextInt());\n\t\t\t\tint ttl = sc.nextInt();\n\t\t\t\t\n\t\t\t\tint d = g[s][t];\n\t\t\t\tif (d + 1 > ttl) {\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(d + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n, r, k, p;\n\tstatic int[][] router, packet;\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tif(!sc.hasNext())return false;\n\t\tn = sc.nextInt();\n\t\trouter = new int[n+1][n+1];\n\t\tfor(int[] init : router)Arrays.fill(init, 1<<29);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tr = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\trouter[r][t] = 1;\n\t\t\t}\n\t\t}\n\t\tp = sc.nextInt();\n\t\tpacket = new int[p+1][3];\n\t\tfor(int i = 1; i <= p; i++){\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tpacket[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\trouter[i][j] = Math.min(router[i][j], router[i][k] + router[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= p; i++){\n\t\t\tint source = packet[i][0];\n\t\t\tint destination = packet[i][1];\n\t\t\tint TTL = packet[i][2];\n\t\t\tif( router[ source ][ destination ] < TTL ){\n\t\t\t\tSystem.out.println(router[ source ][ destination ]+1);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tList<List<Integer>> list = new ArrayList<List<Integer>>();\n\t\tlist.add(new ArrayList<>());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanner.next();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tlist.add(memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tslove(map, list, i, i, 1, 1 << i);\n\t\t}\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[][] map, List<List<Integer>> list, int i,\n\t\t\tint s, int n, int bit) {\n\t\tfor (int t : list.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, list, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt()+1,l,i,j,c;int[][]a=new int[n][n];for(int[]b:a)Arrays.fill(b,n);for(i=1;i<n;++i)a[i][i]=0;for(i=1;i<n;++i)for(s.next(),j=s.nextInt();j-->0;)a[i][s.nextInt()]=1;for(c=1;c<n;++c)for(i=1;i<n;++i)for(j=1;j<n;++j)if((l=a[i][c]+a[c][j])<a[i][j])a[i][j]=l;for(n=s.nextInt();n-->0;)System.out.println((l=a[s.nextInt()][s.nextInt()])<s.nextInt()&&l>=0?l+1:\"NA\");}}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Queue<Pair> queue = new LinkedList<Pair>();\n\n\tstatic class Pair {\n\t\tint routerIndex;\n\t\tint cost;\n\n\t\tPair(int index, int cost) {\n\t\t\tthis.routerIndex = index;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tstatic class Router {\n\t\tint number;\n\t\tint degree;\n\t\tRouter next[];\n\t\tint cost;\n\t\tboolean mark;\n\n\t\tRouter(int number) {\n\t\t\tthis.number = number;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tRouter rt[];\n\n\t\tn = sc.nextInt();\n\t\trt = new Router[n + 1];\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\trt[i] = new Router(i);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint number = sc.nextInt();\n\t\t\tint degree = sc.nextInt();\n\t\t\trt[i].degree = degree;\n\t\t\trt[i].next = new Router[degree];\n\t\t\tfor (int j = 0; j < degree; j++) {\n\t\t\t\trt[i].next[j] = rt[sc.nextInt()];\n\t\t\t}\n\t\t}\n\t\tm = sc.nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint start = sc.nextInt();\n\t\t\tint goal = sc.nextInt();\n\t\t\tint tll = sc.nextInt();\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\trt[j].mark = false;\n\t\t\t\trt[j].cost = -1;\n\t\t\t}\n\t\t\tqueue.clear();\n\t\t\tif (bestWay(rt, n, start, goal, 1)) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t} else if (rt[goal].cost <= tll) {\n\t\t\t\tSystem.out.println(rt[goal].cost);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean bestWay(Router rt[], int n, int start, int goal, int cost) {\n\t\tif (rt[start].mark) {\n\t\t\treturn false;\n\t\t}\n\t\trt[start].cost = cost;\n\t\tif (start == goal) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < rt[start].degree; i++) {\n\t\t\tPair p = new Pair(rt[start].next[i].number, cost + 1);\n\t\t\tqueue.add(p);\n\t\t}\n\t\trt[start].mark = true;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tPair p = queue.poll();\n\t\t\tif (bestWay(rt, n, p.routerIndex, goal, p.cost)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint cnt(int s,int g,int cnt,int xy[][],int n){\n\t\tint result = 0;\n\t\tint c[] = new int [n+1];\n\t\tc[s] = 1;\n\t\tif(s == g)result = 1;\n\t\tfor(int i = 1;i < cnt;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tfor(int k = 1;k < n+1;k++){\n\t\t\t\t\tif(xy[j][k] == 1 && c[j] == i){\n\t\t\t\t\t\tc[k] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c[g] > 0){\n\t\t\t\tresult = c[g];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tint xy[][] = new int [n+1][n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint r1 = sc.nextInt();\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0;j < k1;j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\txy[r1][t] = 1;\n\t\t\t}\n    \t }\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint TTL = sc.nextInt();\n\t\t\tint ans = cnt(s,d,TTL,xy,n);\n\t\t\tif(ans == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//中身\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tSystem.out.print(xy[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic class State implements Comparable<State>{\n\t\tint v, cost;\n\t\tState(int v, int cost){\n\t\t\tthis.v=v;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(State s) {\n\t\t\treturn this.cost-s.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint n=sc.nextInt();\n\t\t\tboolean[][] edge=new boolean[n+1][n+1];\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tint r=sc.nextInt();\n\t\t\t\tint k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++) {\n\t\t\t\t\tint t=sc.nextInt();\n\t\t\t\t\tedge[r][t]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p=sc.nextInt();\n\t\t\tint[] dis=new int[n+1];\n\t\t\tPriorityQueue<State> pq=new PriorityQueue<>();\n\t\t\tint INF=100000000;\n\t\t\twhile(p-->0) {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint g=sc.nextInt();\n\t\t\t\tint v=sc.nextInt();\n\t\t\t\tpq.clear();\n\t\t\t\tArrays.fill(dis, INF);\n\t\t\t\tpq.add(new State(s, 0));\n\t\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\t\tState state=pq.poll();\n\t\t\t\t\tif(dis[state.v]!=INF) continue;\n\t\t\t\t\tdis[state.v]=state.cost;\n\t\t\t\t\tif(state.v==g) break;\n\t\t\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\t\t\tif(!edge[state.v][i]) continue;\n\t\t\t\t\t\tpq.add(new State(i, state.cost+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dis[g]==INF || dis[g]>=v) System.out.println(\"NA\");\n\t\t\t\telse System.out.println(dis[g]+1);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 1000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=0;\n//\t\t\tfor(int i=0;i<=n;i++)\n//\t\t\t\tfor(int j=0;j<=n;j++)\n//\t\t\t\t\tSystem.out.println(i+\"->\"+j+\"  \"+root[i][j]);\n//\t\t\t\t\t\n\t\t\t\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// create graph from input\n\t\tint numRouter = Integer.parseInt(br.readLine());\n\t\tRouter[] router = new Router[numRouter];\n\t\tString[] routerParameter = null;\n\t\tint routerId, numNextRouter;\n\t\tfor (int i = 0; i < numRouter; i++) {\n\t\t\trouterParameter = br.readLine().split(\" \");\n\t\t\trouterId = Integer.parseInt(routerParameter[0]);\n\t\t\tnumNextRouter = Integer.parseInt(routerParameter[1]);\n\t\t\tint[] nextRouterId = null;\n\t\t\tif (numNextRouter != 0) {\n\t\t\t\tnextRouterId = new int[numNextRouter];\n\t\t\t\tfor (int j = 0; j < nextRouterId.length; j++) {\n\t\t\t\t\tnextRouterId[j] = Integer.parseInt(routerParameter[2 + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trouter[i] = new Router(routerId, nextRouterId);\n\t\t}\n\n\t\t// solve\n\t\tGraph g = null;\n\t\tint numTask = Integer.parseInt(br.readLine());\n\t\tString[] packetData = null;\n\t\tfor (int i = 0; i < numTask; i++) {\n\t\t\t// グラフ初期化\n\t\t\tg = new Graph(router);\n\t\t\t// パケット情報から最短経路長を出力\n\t\t\tpacketData = br.readLine().split(\" \");\n\t\t\tSystem.out.println(g.getCost(Integer.parseInt(packetData[0]), Integer.parseInt(packetData[1]),\tInteger.parseInt(packetData[2])));\n\t\t}\n\t}\n}\n\nclass Graph {\n\tprivate Router[] router;\n\n\tpublic Graph(Router[] router) {\n\t\tthis.router = new Router[router.length];\n\t\tfor (int i = 0; i < router.length; i++) {\n\t\t\tthis.router[i] = new Router(router[i].getId(),\n\t\t\t\t\trouter[i].getNextRouterId());\n\t\t}\n\t}\n\n\tpublic String getCost(int sourceRouterId, int targetRouterId, int TTL) {\n\t\t// 初期化\n\t\tint timeToLive = TTL;\n\t\tRouter r = this.getRouter(sourceRouterId);\n\t\tRouter sourceRouter = new Router(r.getId(), r.getNextRouterId());\n\t\tsourceRouter.setCostFromStart(1);\n\t\t\n\t\t@SuppressWarnings(\"unused\")\n\t\tArrayList<Router> presentRouterList = new ArrayList<Router>();\n\t\tpresentRouterList.add(sourceRouter);\n\t\t@SuppressWarnings(\"unused\")\n\t\tArrayList<Router> nextRouterList = new ArrayList<Router>();\n\n\t\t// 全経路を探索\n\t\twhile (--timeToLive > 0) {\n\t\t\t//基点から行ける点すべてについてコストを伝播させつつ、\n\t\t\t//その行ける点から行ける点を取得する\n\t\t\tfor(int i = 0; i < presentRouterList.size(); i++){\n\t\t\t\tsourceRouter = presentRouterList.get(i);\n\t\t\t\tif (!sourceRouter.getPassed() && sourceRouter.getNextRouterId() != null){\n\t\t\t\t\tfor (int id : sourceRouter.getNextRouterId()) {\n\t\t\t\t\t\tRouter nextRouter = this.getRouter(id);\n\t\t\t\t\t\tnextRouter.updateCostFromStart(sourceRouter.getCostToNext(id));\n\t\t\t\t\t\tif(nextRouter.getId() != targetRouterId)\n\t\t\t\t\t\t\tnextRouterList.add(nextRouter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsourceRouter.setPassed(true);\n\t\t\t}\n\t\t\t\n\t\t\tif(nextRouterList.size() == 0)\tbreak;\n\t\t\t\n\t\t\t//ルーターリストを更新\n\t\t\tpresentRouterList.clear();\n\t\t\tfor(int i = 0; i < nextRouterList.size(); i++){\n\t\t\t\tpresentRouterList.add(nextRouterList.get(i));\n\t\t\t}\n\t\t\tnextRouterList.clear();\n\t\t};\n\n\t\t// targetRouterのcostFromStartを出力\n\t\tint cost = getRouter(targetRouterId).getCostFromStart();\n\t\treturn (cost != Router.MAX_COST) ? String.valueOf(cost) : \"NA\";\n\t}\n\n\tprivate Router getRouter(int id) {\n\t\tfor (Router r : this.router) {\n\t\t\tif (r.getId() == id)\treturn r;\n\t\t}\n\t\treturn null;\n\t}\n}\n\nclass Router {\n\tstatic final int WEIGHT = 1;\n\tstatic final int MAX_COST = 999999;\n\tstatic final int NO_ROUTE = -1;\n\tprivate int id;\n\tprivate int[] nextRouterId;\n\tprivate int costFromStart;\n\tprivate int[] weight;\n\tprivate boolean passed;\n\n\tpublic Router(int id, int[] nextRouterId) {\n\t\tthis.id = id;\n\t\tthis.nextRouterId = nextRouterId;\n\t\tif (nextRouterId != null) {\n\t\t\tthis.weight = new int[nextRouterId.length];\n\t\t\tfor (int i = 0; i < this.weight.length; i++) {\n\t\t\t\tthis.weight[i] = WEIGHT;\n\t\t\t}\n\t\t}\n\t\tthis.costFromStart = MAX_COST;\n\t\tthis.passed = false;\n\t}\n\n\tpublic boolean updateCostFromStart(int cost) {\n\t\tif (cost != NO_ROUTE && cost < this.costFromStart){\n\t\t\tthis.costFromStart = cost;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int getCostToNext(int id) {\n\t\tfor (int i = 0; i < this.nextRouterId.length; i++) {\n\t\t\tif (this.nextRouterId[i] == id)\t\treturn this.costFromStart + this.weight[i];\n\t\t}\n\t\treturn NO_ROUTE;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn this.id;\n\t}\n\tpublic int getCostFromStart() {\n\t\treturn this.costFromStart;\n\t}\n\tpublic int[] getNextRouterId() {\n\t\treturn this.nextRouterId;\n\t}\n\tpublic boolean getPassed(){\n\t\treturn this.passed;\n\t}\n\tpublic void setCostFromStart(int costFromStart) {\n\t\tthis.costFromStart = costFromStart;\n\t}\n\tpublic void setPassed(boolean passed) {\n\t\tthis.passed = passed;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 1000000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=0;\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min:\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic byte[][] d;\n\tstatic final byte INF = Byte.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner scan = new Scanner(System.in);\n\t\tbyte n = scan.nextByte();\n\t\td = new byte[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = i!=j ? INF : 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscan.next();\n\t\t\tbyte c = scan.nextByte();\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\td[i][scan.nextByte()-1]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = (byte)Math.min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint p = scan.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tbyte s = scan.nextByte();\n\t\t\tbyte g = scan.nextByte();\n\t\t\tbyte ttl = scan.nextByte();\n\t\t\tout.println(ttl<=d[s-1][g-1] ? \"NA\" : d[s-1][g-1]+1);\n\t\t}\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new int[n][n];\n\t\tfor (int[] a: es) fill(a, INF);\n\t\tfor (int i=0;i<n;i++) es[i][i] = 0;\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, d = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println((es[s][d] + 1 <= v ? es[s][d] + 1 : \"NA\"));\n\t\t}\n\t}\n\t\n\tString bfs(int s, int t, int v) {\n\t\tLinkedList<V> q = new LinkedList<V>();\n\t\tq.add(new V(s, v));\n\t\tboolean[] used = new boolean[n];\n\t\tused[s] = true;\n\t\tfor (;! q.isEmpty();) {\n\t\t\tV cur = q.removeFirst();\n\t\t\tif (t == cur.p) return \"\" + (v - cur.c + 1);\n\t\t\tif (cur.c == 1) continue;\n\t\t\tfor (int i=0;i<n;i++) if (! used[i] && es[cur.p][i] ) {\n\t\t\t\tused[i] = true;\n\t\t\t\tq.addLast(new V(i, cur.c - 1));\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n\t\n\tclass V {\n\t\tint p, c;\n\t\tV(int p, int c) {\n\t\t\tthis.p = p;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tboolean[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new boolean[n][n];\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = true;\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println(bfs(s,t,v));\n\t\t}\n\t}\n\t\n\tString bfs(int s, int t, int v) {\n\t\tLinkedList<V> q = new LinkedList<V>();\n\t\tq.add(new V(s, v));\n\t\tboolean[] used = new boolean[n];\n\t\tused[s] = true;\n\t\tfor (;! q.isEmpty();) {\n\t\t\tV cur = q.removeFirst();\n\t\t\tif (t == cur.p) return \"\" + (v - cur.c + 1);\n\t\t\tif (cur.c == 1) continue;\n\t\t\tfor (int i=0;i<n;i++) if (! used[i] && es[cur.p][i] ) {\n\t\t\t\tused[i] = true;\n\t\t\t\tq.addLast(new V(i, cur.c - 1));\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n\t\n\tclass V {\n\t\tint p, c;\n\t\tV(int p, int c) {\n\t\t\tthis.p = p;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t{\n\t\t\t\troot[i][i]=0;\n\t\t\t\tArrays.fill(root[i], 1000);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n//\t\t\tfor(int i=0;i<=n;i++)\n//\t\t\t\tfor(int j=0;j<=n;j++)\n//\t\t\t\t\tSystem.out.println(i+\"->\"+j+\"  \"+root[i][j]);\n//\t\t\t\t\t\n\t\t\t\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);int n=s.nextInt()+1,i,j,c,m;long l;long[][]a=new long[n][n];for(long[]b:a)Arrays.fill(b,Integer.MAX_VALUE);for(i=1;i<n;++i)a[i][i]=0;for(i=1;i<n;++i)for(s.next(),j=s.nextInt();j-->0;)a[i][s.nextInt()]=1;for(c=1;c<n;++c)for(i=1;i<n;++i)for(j=1;j<n;++j)if((l=a[i][c]+a[c][j])<a[i][j])a[i][j]=l;for(m=s.nextInt();m-->0;)System.out.println((l=a[s.nextInt()][s.nextInt()])<s.nextInt()?l+1:\"NA\");}}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// create graph from input\n\t\tint numRouter = Integer.parseInt(br.readLine());\n\t\tRouter[] router = new Router[numRouter];\n\t\tString[] routerParameter = null;\n\t\tint routerId, numNextRouter;\n\t\tfor (int i = 0; i < numRouter; i++) {\n\t\t\trouterParameter = br.readLine().split(\" \");\n\t\t\trouterId = Integer.parseInt(routerParameter[0]);\n\t\t\tnumNextRouter = Integer.parseInt(routerParameter[1]);\n\t\t\tint[] nextRouterId = null;\n\t\t\tif (numNextRouter != 0) {\n\t\t\t\tnextRouterId = new int[numNextRouter];\n\t\t\t\tfor (int j = 0; j < nextRouterId.length; j++) {\n\t\t\t\t\tnextRouterId[j] = Integer.parseInt(routerParameter[2 + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trouter[i] = new Router(routerId, nextRouterId);\n\t\t}\n\n\t\t// solve\n\t\tGraph g = null;\n\t\tint numTask = Integer.parseInt(br.readLine());\n\t\tString[] packetData = null;\n\t\tfor (int i = 0; i < numTask; i++) {\n\t\t\t// グラフ初期化\n\t\t\tg = new Graph(router);\n\t\t\t// パケット情報から最短経路長を出力\n\t\t\tpacketData = br.readLine().split(\" \");\n\t\t\tSystem.out.println(g.getCost(Integer.parseInt(packetData[0]), Integer.parseInt(packetData[1]),\tInteger.parseInt(packetData[2])));\n\t\t}\n\t}\n}\n\nclass Graph {\n\tprivate Router[] router;\n\n\tpublic Graph(Router[] router) {\n\t\tthis.router = new Router[router.length];\n\t\tfor (int i = 0; i < router.length; i++) {\n\t\t\tthis.router[i] = new Router(router[i].getId(),\n\t\t\t\t\trouter[i].getNextRouterId());\n\t\t}\n\t}\n\n\tpublic String getCost(int sourceRouterId, int targetRouterId, int TTL) {\n\t\t// 初期化\n\t\tint timeToLive = TTL;\n\t\tRouter r = this.getRouter(sourceRouterId);\n\t\tRouter sourceRouter = new Router(r.getId(), r.getNextRouterId());\n\t\tsourceRouter.setCostFromStart(1);\n\t\t\n\t\t@SuppressWarnings(\"unused\")\n\t\tArrayList<Router> presentRouterList = new ArrayList<Router>();\n\t\tpresentRouterList.add(sourceRouter);\n\t\t@SuppressWarnings(\"unused\")\n\t\tArrayList<Router> nextRouterList = new ArrayList<Router>();\n\n\t\t// 全経路を探索\n\t\twhile (--timeToLive > 0) {\n\t\t\t//基点から行ける点すべてについてコストを伝播させつつ、\n\t\t\t//その行ける点から行ける点を取得する\n\t\t\tfor(int i = 0; i < presentRouterList.size(); i++){\n\t\t\t\tsourceRouter = presentRouterList.get(i);\n\t\t\t\tif (sourceRouter.getNextRouterId() != null){\n\t\t\t\t\tfor (int id : sourceRouter.getNextRouterId()) {\n\t\t\t\t\t\tRouter nextRouter = this.getRouter(id);\n\t\t\t\t\t\tnextRouter.updateCostFromStart(sourceRouter.getCostToNext(id));\n\t\t\t\t\t\tnextRouterList.add(nextRouter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(nextRouterList.size() == 0)\tbreak;\n\t\t\t\n\t\t\t//ルーターリストを更新\n\t\t\tpresentRouterList.clear();\n\t\t\tfor(int i = 0; i < nextRouterList.size(); i++){\n\t\t\t\tpresentRouterList.add(nextRouterList.get(i));\n\t\t\t}\n\t\t\tnextRouterList.clear();\n\t\t};\n\n\t\t// targetRouterのcostFromStartを出力\n\t\tint cost = getRouter(targetRouterId).getCostFromStart();\n\t\treturn (cost != Router.MAX_COST) ? String.valueOf(cost) : \"NA\";\n\t}\n\n\tprivate Router getRouter(int id) {\n\t\tfor (Router r : this.router) {\n\t\t\tif (r.getId() == id)\treturn r;\n\t\t}\n\t\treturn null;\n\t}\n}\n\nclass Router {\n\tstatic final int WEIGHT = 1;\n\tstatic final int MAX_COST = 999999;\n\tstatic final int NO_ROUTE = -1;\n\tprivate int id;\n\tprivate int[] nextRouterId = null;\n\tprivate int costFromStart;\n\tprivate int[] weight;\n\n\tpublic Router(int id, int[] nextRouterId) {\n\t\tthis.id = id;\n\t\tthis.nextRouterId = nextRouterId;\n\t\tif (nextRouterId != null) {\n\t\t\tthis.weight = new int[nextRouterId.length];\n\t\t\tfor (int i = 0; i < this.weight.length; i++) {\n\t\t\t\tthis.weight[i] = WEIGHT;\n\t\t\t}\n\t\t}\n\t\tthis.costFromStart = MAX_COST;\n\t}\n\n\tpublic boolean updateCostFromStart(int cost) {\n\t\tif (cost != NO_ROUTE && cost < this.costFromStart){\n\t\t\tthis.costFromStart = cost;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int getCostToNext(int id) {\n\t\tfor (int i = 0; i < this.nextRouterId.length; i++) {\n\t\t\tif (this.nextRouterId[i] == id)\t\treturn this.costFromStart + this.weight[i];\n\t\t}\n\t\treturn NO_ROUTE;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn this.id;\n\t}\n\tpublic int getCostFromStart() {\n\t\treturn this.costFromStart;\n\t}\n\tpublic int[] getNextRouterId() {\n\t\treturn this.nextRouterId;\n\t}\n\tpublic void setCostFromStart(int costFromStart) {\n\t\tthis.costFromStart = costFromStart;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Queue<Pair> queue = new LinkedList<Pair>();\n\n\tstatic class Pair {\n\t\tint routerIndex;\n\t\tint cost;\n\n\t\tPair(int index, int cost) {\n\t\t\tthis.routerIndex = index;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tstatic class Router {\n\t\tint number;\n\t\tint degree;\n\t\tRouter next[];\n\t\tint cost;\n\t\tboolean mark;\n\n\t\tRouter(int number) {\n\t\t\tthis.number = number;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tRouter rt[];\n\n\t\tn = sc.nextInt();\n\t\trt = new Router[n + 1];\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\trt[i] = new Router(i);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint number = sc.nextInt();\n\t\t\tint degree = sc.nextInt();\n\t\t\trt[i].degree = degree;\n\t\t\trt[i].next = new Router[degree];\n\t\t\tfor (int j = 0; j < degree; j++) {\n\t\t\t\trt[i].next[j] = rt[sc.nextInt()];\n\t\t\t}\n\t\t}\n\t\tm = sc.nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint start = sc.nextInt();\n\t\t\tint goal = sc.nextInt();\n\t\t\tint tll = sc.nextInt();\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\trt[j].mark = false;\n\t\t\t\trt[j].cost = -1;\n\t\t\t}\n\t\t\tqueue.clear();\n\t\t\tbestWay(rt, n, start, goal, 1);\n\n\t\t\tif (rt[goal].cost <= tll) {\n\t\t\t\tSystem.out.println(rt[goal].cost);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean bestWay(Router rt[], int n, int start, int goal, int cost) {\n\t\tif (rt[start].mark) {\n\t\t\treturn false;\n\t\t}\n\t\trt[start].cost = cost;\n\t\tif (start == goal) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < rt[start].degree; i++) {\n\t\t\tPair p = new Pair(rt[start].next[i].number, cost + 1);\n\t\t\tqueue.add(p);\n\t\t}\n\t\trt[start].mark = true;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tPair p = queue.poll();\n\t\t\tif (bestWay(rt, n, p.routerIndex, goal, p.cost)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\n/**\n * Packet Transportation\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\t// router info\n\t\t\tRouter.setCount(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\tint id, next;\n\t\t\t\tid = Integer.parseInt(st.nextToken());\n\t\t\t\tnext = Integer.parseInt(st.nextToken());\n\t\t\t\tRouter.setRouter(id);\n\t\t\t\tfor (int j = 0; j < next; j++) {\n\t\t\t\t\tRouter.getRouter(id).addNext(\n\t\t\t\t\t\t\tInteger.parseInt(st.nextToken()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// packet info\n\t\t\tint p = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\tint src, dst, ttl, hop;\n\t\t\t\tint d1, d2;\n\t\t\t\tline = br.readLine();\n\t\t\t\td1 = line.indexOf(' ');\n\t\t\t\td2 = line.indexOf(' ', d1 + 1);\n\t\t\t\tsrc = Integer.parseInt(line.substring(0, d1));\n\t\t\t\tdst = Integer.parseInt(line.substring(d1 + 1, d2));\n\t\t\t\tttl = Integer.parseInt(line.substring(d2 + 1));\n\t\t\t\thop = Router.getHops(src, dst, ttl);\n\t\t\t\tif (hop > 0) {\n\t\t\t\t\tSystem.out.println(hop);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nclass Router {\n\n\tint id;\n\tArrayList<Integer> nexts;\n\n\tprivate static Router[] routers;\n\n\tstatic Router[] setCount(int n) {\n\t\tif (routers == null) {\n\t\t\trouters = new Router[n + 1];\n\t\t}\n\t\treturn routers;\n\t}\n\n\tstatic void setRouter(int id) {\n\t\tRouter r = new Router(id);\n\t\trouters[r.id] = r;\n\t}\n\n\tstatic Router getRouter(int id) {\n\t\treturn routers[id];\n\t}\n\n\tstatic int getHops(int src, int dst, int ttl) {\n\n\t\tDeque<Router.Hop> deque = new ArrayDeque<Router.Hop>();\n\t\tint hop = 0;\n\n\t\tRouter r = getRouter(src);\n\t\tdeque.offer(r.new Hop(r, ttl - 1));\n\t\twhile (!deque.isEmpty()) {\n\t\t\tHop h = deque.poll();\n\t\t\tif (h.router.id == dst) {\n\t\t\t\thop = ttl - h.ttl;\n\t\t\t\tbreak;\n\t\t\t} else if (h.ttl > 0) {\n\t\t\t\tif (h.router.nexts.size() != 0) {\n\t\t\t\t\tfor (Integer i : h.router.nexts) {\n\t\t\t\t\t\tr = getRouter(i);\n\t\t\t\t\t\tdeque.offer(r.new Hop(r, h.ttl - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hop;\n\t}\n\n\t//\n\tprivate Router(int id) {\n\t\tthis.id = id;\n\t\tnexts = new ArrayList<Integer>();\n\t}\n\n\tpublic void addNext(int id) {\n\t\tnexts.add(id);\n\t}\n\n\tprivate class Hop {\n\t\tRouter router;\n\t\tint ttl;\n\n\t\tpublic Hop(Router router, int ttl) {\n\t\t\tthis.router = router;\n\t\t\tthis.ttl = ttl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tfinal int INF = 1000000001;\n\tpublic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[][] road = new int[n+1][n+1];\n\t\tMap<Integer, Set<Integer>> map = new HashMap<Integer, Set<Integer>>();\n\t\tfor(int i = 0; i < road.length; i++){\n\t\t\tfor(int j = 0; j < road[0].length; j++){\n\t\t\t\troad[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint id = nextInt();\n\t\t\tint num = nextInt();\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\tint x = nextInt();\n\t\t\t\troad[id][x] = 1;\n\t\t\t\tset.add(x);\n\t\t\t}\n\t\t\tmap.put(id, set);\n\t\t}\n\t\tint m = nextInt();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint start = nextInt();\n\t\t\tint stop = nextInt();\n\t\t\tint live = nextInt();\n\t\t\tint repeat = live-1;\n\t\t\tSet<Integer> temp = new HashSet<Integer>(map.get(start));\n\t\t\tSet<Integer> add = new HashSet<Integer>(map.get(start));\n\t\tout:while( repeat-- > 0 && !temp.contains(stop) ){\n\t\t\t\tSet<Integer> next = new HashSet<Integer>();\n\t\t\t\tfor(Integer x : add){\n\t\t\t\t\tfor(Integer y : map.get(x)){\n\t\t\t\t\t\tif( !temp.contains(y) ){\n\t\t\t\t\t\t\tif( road[y][stop] <= repeat ){\n\t\t\t\t\t\t\t\trepeat -= road[y][stop];\n\t\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\troad[start][y] = live-repeat;\n\t\t\t\t\t\t\ttemp.add(y);\n\t\t\t\t\t\t\tnext.add(y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadd = new HashSet<Integer>(next);\n\t\t\t}\n\t\t\tif( repeat >= 0 ){\n\t\t\t\twriter.println(live-repeat);\n\t\t\t} else {\n\t\t\t\twriter.println(\"NA\");\n\t\t\t}\n\t\t}\t\t\t\t\t\n\t\twriter.flush();\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tint[][] cost;\n\tboolean[] visit;\n\tint[] dist;\n\tint n;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tn = scan.nextInt();\n\t\t\tcost = new int[n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tArrays.fill(cost[i], 100);\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tint r = scan.nextInt() - 1;\n\t\t\t\tint k = scan.nextInt();\n\t\t\t\tfor(int j = 0;j < k;j++){\n\t\t\t\t\tint t = scan.nextInt() - 1;\n\t\t\t\t\tcost[r][t] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p = scan.nextInt();\n\t\t\tfor(int i = 0;i < p;i++){\n\t\t\t\tint s = scan.nextInt() - 1;\n\t\t\t\tint d = scan.nextInt() - 1;\n\t\t\t\tint v = scan.nextInt();\n\t\t\t\tvisit = new boolean[n];\n\t\t\t\tdist = new int[n];\n\t\t\t\tArrays.fill(dist, 100);\n\t\t\t\tdijkstra(s);\n\t\t\t\tSystem.out.println((dist[d]+1 <= v)?Math.min(dist[d]+1,v):\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\tpublic void dijkstra(int start){\n\t\tdist[start] = 0;\n\t\twhile(true){\n\t\t\tint min = 100;\n\t\t\tint next = -1;\n\t\t\tfor(int u = 0;u < n;u++){\n\t\t\t\tif(visit[u]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdist[u] = Math.min(dist[u],dist[start] + cost[start][u]);\n\t\t\t\tif(dist[u] < min){\n\t\t\t\t\tmin = dist[u];\n\t\t\t\t\tnext = u;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[start] = true;\n\t\t\tstart = next;\n\t\t\tif(start == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tArrayList<LinkedList<Integer>> adjacent;\n\tScanner sc;\n\t\n\tclass Pair{\n\t\tint first;\n\t\tint second;\n\t\tPair(int e1,int e2){\n\t\t\tfirst=e1;second=e2;\n\t\t}\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tString bfs(int dep,int dest,int TTL,int n){\n\t\tLinkedList<Pair> que=new LinkedList<Pair>();\n\t\tque.addLast(new Pair(dep,1));\n\n\t\tboolean[] visited=new boolean[n];\n\t\tArrays.fill(visited,false);\n\t\tvisited[dep]=true;\n\t\t\n\t\twhile(!que.isEmpty()){\n\t\t\tPair node=que.pollFirst();\n\t\t\tif(node.first==dest)return Integer.toString(node.second);\n\t\t\t\t\n\t\t\tif(++node.second<=TTL){\n\t\t\t\tfor(int next :adjacent.get(node.first)){\n\t\t\t\t\tif(!visited[next]){\n\t\t\t\t\t\tque.addLast(new Pair(next,node.second));\n\t\t\t\t\t\tvisited[next]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\tint n=ni();\n\t\tadjacent=new ArrayList<LinkedList<Integer>>();\n\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint r=ni(), k=ni();\n\t\t\tfor(int j=0;j<k;++j){\n\t\t\t\tadjacent.add(new LinkedList<Integer>());\n\t\t\t\tadjacent.get(r-1).add(ni()-1);\n\t\t\t}\n\t\t}\n\t\t//debug(adjacent);\n\t\t\n\t\tint m=ni();\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint dep=ni()-1,dest=ni()-1,TTL=ni();\n\t\t\tSystem.out.println(bfs(dep,dest,TTL,n));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tArrayList<LinkedList<Integer>> adjacent;\n\tScanner sc;\n\t\n\tclass Pair{\n\t\tint first;\n\t\tint second;\n\t\tPair(int e1,int e2){\n\t\t\tfirst=e1;second=e2;\n\t\t}\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tString bfs(int dep,int dest,int TTL,int n){\n\t\tLinkedList<Pair> que=new LinkedList<Pair>();\n\t\tque.addLast(new Pair(dep,1));\n\n\t\tboolean[] visited=new boolean[n];\n\t\tArrays.fill(visited,false);\n\t\tvisited[dep]=true;\n\t\t\n\t\twhile(!que.isEmpty()){\n\t\t\tPair node=que.pollFirst();\n\t\t\tif(node.first==dest)return Integer.toString(node.second);\n\t\t\t\t\n\t\t\tif(++node.second<=TTL){\n\t\t\t\tfor(int next :adjacent.get(node.first)){\n\t\t\t\t\tif(!visited[next]){\n\t\t\t\t\t\tque.addLast(new Pair(next,node.second));\n\t\t\t\t\t\tvisited[next]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\tint n=ni();\n\t\tadjacent=new ArrayList<LinkedList<Integer>>();\n\t\tfor(int i=0;i<n;++i)adjacent.add(new LinkedList<Integer>());\n\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint r=ni(), k=ni();\n\t\t\tfor(int j=0;j<k;++j){\n\t\t\t\tadjacent.get(r-1).add(ni()-1);\n\t\t\t}\n\t\t}\n\t\t//debug(adjacent);\n\t\t\n\t\tint m=ni();\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint dep=ni()-1,dest=ni()-1,TTL=ni();\n\t\t\tSystem.out.println(bfs(dep,dest,TTL,n));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0144();\n\t}\n\t\n\tvoid AOJ0145(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\tC0145[] c=new C0145[N];\n\t\t\tfor(int i=0; i<N; i++)\tc[i]=new C0145(sc.nextInt(),sc.nextInt());\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C0145{\n\t\tint upper,down;\n\t\tC0145(int u,int d){\tthis.upper=u;\tthis.down=d;\t}\n\t}\n\t\n\t// OK\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=110;\n\t\twhile(sc.hasNext())\tqueue.add(sc.nextInt());\n\t\tint[] num=new int[MAX],atime=new int[MAX],itime=new int[MAX],seat=new int[17],ans=new int[MAX];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\tatime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(i+\": ATIME\"+atime[i]+\" NUM\"+num[i]);\n\t\tint gno=0,min=0;\n\t\twhile(gno<=99){\n\t\t\tseat=exit(seat,min,atime,itime);\n\t\t\tint temp=find(seat,num[gno]);\n\t\t\tif(temp>=0 && min>=gno*5){\n\t\t\t\tans[gno]=max(0,min-gno*5);\n\t\t\t\tfor(int i=temp; i<temp+num[gno]; i++)\tseat[i]=gno;\n\t\t\t\titime[gno]=min;\n\t\t\t\tgno++;\n\t\t\t}else{\n\t\t\t\t//debug\n\t\t\t\t//disp(seat,min);\n\t\t\t\tmin++;\n\t\t\t}\n\t\t}\n\t\t//disp(seat,min);\n\t\twhile(!queue.isEmpty())\tout.println(ans[queue.poll()]);\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<=17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] exit(int[] seat,int min,int[] atime,int[] itime){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint emin=itime[seat[i]]+atime[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\t// WA（原因不明）\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"1NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(now.ttl-1==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl-1,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(((ans<0 || ans>v)?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint cnt(int s,int g,int cnt,int xy[][],int n){\n\t\tint result = 0;\n\t\tint c[] = new int [n+1];\n\t\tint d[] = new int [n+1];\n\t\tc[s] = 1;\n\t\tif(s == g && cnt > 0)result = 1;\n\t\tfor(int i = 1;i < cnt;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tfor(int k = 1;k < n+1;k++){\n\t\t\t\t\tif(xy[j][k] == 1 && c[j] == i){\n\t\t\t\t\t\td[k] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tc[j] = d[j];\n\t\t\t}\n\t\t\tif(c[g] > 0){\n\t\t\t\tresult = c[g];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i == 101){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tint xy[][] = new int [n+1][n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint r1 = sc.nextInt();\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0;j < k1;j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\txy[r1][t] = 1;\n\t\t\t}\n    \t }\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint TTL = sc.nextInt();\n\t\t\tint ans = cnt(s,d,TTL,xy,n);\n\t\t\tif(ans == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//中身\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tSystem.out.print(xy[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 100000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=0;\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min:\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// create graph from input\n\t\tint numRouter = Integer.parseInt(br.readLine());\n\t\tRouter[] router = new Router[numRouter];\n\t\tString[] routerParameter = null;\n\t\tint routerId, numNextRouter;\n\t\tfor (int i = 0; i < numRouter; i++) {\n\t\t\trouterParameter = br.readLine().split(\" \");\n\t\t\trouterId = Integer.parseInt(routerParameter[0]);\n\t\t\tnumNextRouter = Integer.parseInt(routerParameter[1]);\n\t\t\tint[] nextRouterId = null;\n\t\t\tif (numNextRouter != 0) {\n\t\t\t\tnextRouterId = new int[numNextRouter];\n\t\t\t\tfor (int j = 0; j < nextRouterId.length; j++) {\n\t\t\t\t\tnextRouterId[j] = Integer.parseInt(routerParameter[2 + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trouter[i] = new Router(routerId, nextRouterId);\n\t\t}\n\n\t\t// solve\n\t\tGraph g = null;\n\t\tint numTask = Integer.parseInt(br.readLine());\n\t\tString[] packetData = null;\n\t\tfor (int i = 0; i < numTask; i++) {\n\t\t\t// グラフ初期化\n\t\t\tg = new Graph(router);\n\t\t\t// パケット情報から最短経路長を出力\n\t\t\tpacketData = br.readLine().split(\" \");\n\t\t\tSystem.out.println(g.getCost(Integer.parseInt(packetData[0]), Integer.parseInt(packetData[1]),\tInteger.parseInt(packetData[2])));\n\t\t}\n\t}\n}\n\nclass Graph {\n\tprivate Router[] router;\n\n\tpublic Graph(Router[] router) {\n\t\tthis.router = new Router[router.length];\n\t\tfor (int i = 0; i < router.length; i++) {\n\t\t\tthis.router[i] = new Router(router[i].getId(),\n\t\t\t\t\trouter[i].getNextRouterId());\n\t\t}\n\t}\n\n\tpublic String getCost(int sourceRouterId, int targetRouterId, int TTL) {\n\t\t// 初期化\n\t\tint timeToLive = TTL;\n\t\tRouter r = this.getRouter(sourceRouterId);\n\t\tRouter sourceRouter = new Router(r.getId(), r.getNextRouterId());\n\t\tsourceRouter.setCostFromStart(1);\n\t\t\n\t\t@SuppressWarnings(\"unused\")\n\t\tArrayList<Router> presentRouterList = new ArrayList<Router>();\n\t\tpresentRouterList.add(sourceRouter);\n\t\t@SuppressWarnings(\"unused\")\n\t\tArrayList<Router> nextRouterList = new ArrayList<Router>();\n\n\t\t// 全経路を探索\n\t\twhile (--timeToLive > 0) {\n\t\t\t//基点から行ける点すべてについてコストを伝播させつつ、\n\t\t\t//その行ける点から行ける点を取得する\n\t\t\tfor(int i = 0; i < presentRouterList.size(); i++){\n\t\t\t\tsourceRouter = presentRouterList.get(i);\n\t\t\t\tif (sourceRouter.getNextRouterId() != null){\n\t\t\t\t\tfor (int id : sourceRouter.getNextRouterId()) {\n\t\t\t\t\t\tRouter nextRouter = this.getRouter(id);\n\t\t\t\t\t\tnextRouter.updateCostFromStart(sourceRouter.getCostToNext(id));\n\t\t\t\t\t\tif(nextRouter.getId() != targetRouterId)\n\t\t\t\t\t\t\tnextRouterList.add(nextRouter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(nextRouterList.size() == 0)\tbreak;\n\t\t\t\n\t\t\t//ルーターリストを更新\n\t\t\tpresentRouterList.clear();\n\t\t\tfor(int i = 0; i < nextRouterList.size(); i++){\n\t\t\t\tpresentRouterList.add(nextRouterList.get(i));\n\t\t\t}\n\t\t\tnextRouterList.clear();\n\t\t};\n\n\t\t// targetRouterのcostFromStartを出力\n\t\tint cost = getRouter(targetRouterId).getCostFromStart();\n\t\treturn (cost != Router.MAX_COST) ? String.valueOf(cost) : \"NA\";\n\t}\n\n\tprivate Router getRouter(int id) {\n\t\tfor (Router r : this.router) {\n\t\t\tif (r.getId() == id)\treturn r;\n\t\t}\n\t\treturn null;\n\t}\n}\n\nclass Router {\n\tstatic final int WEIGHT = 1;\n\tstatic final int MAX_COST = 999999;\n\tstatic final int NO_ROUTE = -1;\n\tprivate int id;\n\tprivate int[] nextRouterId = null;\n\tprivate int costFromStart;\n\tprivate int[] weight;\n\n\tpublic Router(int id, int[] nextRouterId) {\n\t\tthis.id = id;\n\t\tthis.nextRouterId = nextRouterId;\n\t\tif (nextRouterId != null) {\n\t\t\tthis.weight = new int[nextRouterId.length];\n\t\t\tfor (int i = 0; i < this.weight.length; i++) {\n\t\t\t\tthis.weight[i] = WEIGHT;\n\t\t\t}\n\t\t}\n\t\tthis.costFromStart = MAX_COST;\n\t}\n\n\tpublic boolean updateCostFromStart(int cost) {\n\t\tif (cost != NO_ROUTE && cost < this.costFromStart){\n\t\t\tthis.costFromStart = cost;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic int getCostToNext(int id) {\n\t\tfor (int i = 0; i < this.nextRouterId.length; i++) {\n\t\t\tif (this.nextRouterId[i] == id)\t\treturn this.costFromStart + this.weight[i];\n\t\t}\n\t\treturn NO_ROUTE;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn this.id;\n\t}\n\tpublic int getCostFromStart() {\n\t\treturn this.costFromStart;\n\t}\n\tpublic int[] getNextRouterId() {\n\t\treturn this.nextRouterId;\n\t}\n\tpublic void setCostFromStart(int costFromStart) {\n\t\tthis.costFromStart = costFromStart;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic byte[][] d;\n\tstatic final byte INF = Byte.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner scan = new Scanner(System.in);\n\t\tbyte n = scan.nextByte();\n\t\td = new byte[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = i!=j ? INF : 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscan.next();\n\t\t\tbyte c = scan.nextByte();\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\td[i][scan.nextByte()-1]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = (byte)Math.min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint p = scan.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tbyte s = scan.nextByte();\n\t\t\tbyte g = scan.nextByte();\n\t\t\tshort ttl = scan.nextShort();\n\t\t\tout.println(ttl<=d[s-1][g-1] || d[s-1][g-1]==Byte.MAX_VALUE ? \"NA\" : d[s-1][g-1]+1);\n\t\t}\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic byte[][] d;\n\tstatic final byte INF = Byte.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner scan = new Scanner(System.in);\n\t\tbyte n = scan.nextByte();\n\t\td = new byte[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = i!=j ? INF : 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscan.next();\n\t\t\tbyte c = scan.nextByte();\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\td[i][scan.nextByte()-1]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = (byte)Math.min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint p = scan.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tbyte s = scan.nextByte();\n\t\t\tbyte g = scan.nextByte();\n\t\t\tshort ttl = scan.nextShort();\n\t\t\tout.println(ttl<=d[s-1][g-1] ? \"NA\" : d[s-1][g-1]+1);\n\t\t}\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[][] cost = new int[n+1][n+1];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint r = sc.nextInt();\n\t\t\tint u = sc.nextInt();\n\t\t\tfor(int j=0;j<u;j++) cost[r][sc.nextInt()] = 1;\n\t\t}\n\t\tfor(int i=0;i<n;i++) cost[i][i] = 0;\n\t\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(cost[j][i]!=Integer.MAX_VALUE && cost[i][k]!=Integer.MAX_VALUE){\n\t\t\t\t\t\tcost[j][k] = Math.min(cost[j][k], cost[j][i]+cost[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tint p = sc.nextInt();\n\t\tfor(int i=0;i<p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tif(cost[s][d]>=v) System.out.println(\"NA\");\n\t\t\telse System.out.println(cost[s][d]+1);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0144();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\tif(--now.ttl==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=now.c+1;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 10000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=0;\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min:\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint n = sc.nextInt() + 1;\n\n\t\tint[][] d = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrays.fill(d[i], Integer.MAX_VALUE >> 3);\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint r = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint z= sc.nextInt();\n\t\t\t\td[r][z] = 1;\n\t\t\t}\n\t\t}\n\n\t\tboolean end = false;\n\t\tfor (; !end;) {\n\t\t\tend = true;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\t\tfor (int k = 1; k < n; k++) {\n\t\t\t\t\t\tif (d[i][j] > d[i][k] + d[k][j]) {\n\t\t\t\t\t\t\td[i][j] = d[i][k] + d[k][j];\n\t\t\t\t\t\t\tend = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0; i < p ; i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(d[s][g] + 1 > v ? \"NA\":(d[s][g]+1)  );\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Queue<Pair> queue = new LinkedList<Pair>();\n\t\n\tstatic class Pair {\n\t\tint nextNumber;\n\t\tint cost;\n\t\t\n\t\tPair(int nextNumber, int cost) {\n\t\t\tthis.nextNumber = nextNumber;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\t\n\tstatic class Router {\n\t\tint number;\n\t\tint degree;\n\t\tRouter next[];\n\t\tint cost;\n\t\tboolean mark;\n\t\t\n\t\tRouter(int number) {\n\t\t\tthis.number = number;\n\t\t}\n\t}\n\t\n\tpublic static void main(String srgs[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tRouter rt[];\n\t\t\n\t\tn = sc.nextInt();\n\t\trt = new Router[n + 1];\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\trt[i] = new Router(i);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint number = sc.nextInt();\n\t\t\tint degree = sc.nextInt();\n\t\t\trt[number].next = new Router[degree];\n\t\t\trt[number].degree = degree;\n\t\t\tfor (int j = 0; j < degree; j++) {\n\t\t\t\tint nextIndex = sc.nextInt();\n\t\t\t\trt[number].next[j] = rt[nextIndex];\n\t\t\t}\n\t\t}\n\t\t\n\t\tm = sc.nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint start = sc.nextInt();\n\t\t\tint goal = sc.nextInt();\n\t\t\tint ttl = sc.nextInt();\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\trt[j].mark = false;\n\t\t\t\trt[j].cost = Integer.MAX_VALUE;\n\t\t\t}\n\t\t\tqueue.clear();\n\t\t\tbestWay(rt, start, goal, 1);\n\t\t\tif (rt[goal].cost <= ttl) {\n\t\t\t\tSystem.out.println(rt[goal].cost);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean bestWay(Router rt[], int start, int goal, int cost) {\n\t\tif (rt[start].mark) {\n\t\t\treturn false;\n\t\t}\n\t\trt[start].mark = true;\n\t\trt[start].cost = cost;\n\t\tif (rt[goal].mark) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < rt[start].degree; i++) {\n\t\t\tPair p = new Pair(rt[start].next[i].number, cost + 1);\n\t\t\tqueue.add(p);\n\t\t}\n\t\t\n\t\twhile (!queue.isEmpty()) {\n\t\t\tPair p = queue.poll();\n\t\t\tif (bestWay(rt, p.nextNumber, goal, p.cost)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tArrayList<LinkedList<Integer>> adjacent;\n\tScanner sc;\n\t\n\tclass Pair{\n\t\tint first;\n\t\tint second;\n\t\tPair(int e1,int e2){\n\t\t\tfirst=e1;second=e2;\n\t\t}\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tString bfs(int dep,int dest,int TTL,int n){\n\t\tLinkedList<Pair> que=new LinkedList<Pair>();\n\t\tque.addLast(new Pair(dep,1));\n\n\t\tboolean[] visited=new boolean[n];\n\t\tArrays.fill(visited,false);\n\t\tvisited[dep]=true;\n\t\t\n\t\twhile(!que.isEmpty()){\n\t\t\tPair node=que.pollFirst();\n\t\t\tif(node.first==dest)return Integer.toString(node.second);\n\t\t\t\t\n\t\t\tif(++node.second<=TTL){\n\t\t\t\tfor(int next :adjacent.get(node.first)){\n\t\t\t\t\tif(!visited[next]){\n\t\t\t\t\t\tque.addLast(new Pair(next,node.second));\n\t\t\t\t\t\tvisited[next]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"NA\";\n\t}\n\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\tint n=ni();\n\t\tadjacent=new ArrayList<LinkedList<Integer>>();\n\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint r=ni(), k=ni();\n\t\t\tfor(int j=0;j<k;++j){\n\t\t\t\tadjacent.add(new LinkedList<Integer>());\n\t\t\t\tadjacent.get(r-1).add(ni()-1);\n\t\t\t}\n\t\t}\n\t\tdebug(adjacent);\n\t\t\n\t\tint m=ni();\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint dep=ni()-1,dest=ni()-1,TTL=ni();\n\t\t\tSystem.out.println(bfs(dep,dest,TTL,n));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args) \n    {\n        Scanner in=new Scanner(System.in);\n        while(in.hasNext())\n        {\n            int n=in.nextInt();\n            int root[][]=new int[n+1][n+1];\n            for(int i=0;i<=n;i++)\n                Arrays.fill(root[i], 1000);\n            for(int i=0;i<n;i++)\n            {\n                int r=in.nextInt();\n                int k=in.nextInt();\n                for(int j=0;j<k;j++)\n                    root[r][in.nextInt()]=1;\n            }\n            for(int i=0;i<=n;i++)\n                root[i][i]=0;\n            for (int j=1;j<=n;j++)//ワーシャルフロイド\n                for(int k=1;k<=n;k++)\n                    for(int i=1;i<=n;i++)\n                    {\n                        //j->kへ行くのにiを経由した方が良いかどうか\n                        int c=root[j][i]+root[i][k];\n                        root[j][k]=Math.min(root[j][k],c);\n                    }\n            int p=in.nextInt();\n            for(int i=0;i<p;i++)\n            {\n                int s=in.nextInt(),t=in.nextInt();\n                int TTL=in.nextInt();\n                int min=root[s][t]+1;\n                System.out.println(min<=TTL ? min:\"NA\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\n\t\tint size = Integer.parseInt(line);\n\t\tNode[] nodes = new Node[size];\n\t\tfor(int i=0; i<size; i++){\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint id = Integer.parseInt(tmp[0])-1;\n\t\t\tnodes[id] = new Node();\n\t\t\tint n_to = Integer.parseInt(tmp[1]);\n\t\t\tfor(int j=2; j<2+n_to; j++){\n\t\t\t\tint to = Integer.parseInt(tmp[j])-1;\n\t\t\t\tnodes[id].add_edge(to, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tline = in.readLine();\n\t\tsize = Integer.parseInt(line);\n\t\tfor(int i=0; i<size; i++){\n\t\t\tNode[] clone = deepClone(nodes);\n\t\t\tline = in.readLine();\n\t\t\tString[] tmp = line.split(\" \");\n\t\t\tint s = Integer.parseInt(tmp[0])-1;\n\t\t\tint g = Integer.parseInt(tmp[1])-1;\n\t\t\tint ttl = Integer.parseInt(tmp[2]);\n\t\t\tint total = calcCost(clone, s, g);\n\t\t\tif(ttl >= total && total != -1){\n\t\t\t\tSystem.out.println(total);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int calcCost(Node[] nodes, int s, int g){\n\t\tList<Node> que = new ArrayList<Node>();\n\t\tnodes[s].cost = 1;\n\t\tque.add(nodes[s]);\n\t\tNode done = null;\n\t\twhile(que.size()!=0){\n\t\t\tdone = que.get(0);\n\t\t\tque.remove(0);\n\t\t\tdone.visited = true;\n\t\t\tfor(int i=0; i<done.edge_to.size(); i++){\n\t\t\t\tint cost = done.cost + done.edge_cost.get(i);\n\t\t\t\tint to = done.edge_to.get(i);\n\t\t\t\tif(nodes[to].cost < 0 || cost < nodes[to].cost){\n\t\t\t\t\tnodes[to].cost = cost;\n\t\t\t\t\tif(!que.contains(nodes[to])){\n\t\t\t\t\t\tque.add(nodes[to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes[g].cost;\n\t}\n\t\n\tpublic Node[] deepClone(Node[] nodes){\n\t\tint m = nodes.length;\n\t\tNode[] clone = new Node[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tclone[i] = new Node(nodes[i]);\n\t\t}\n\t\treturn clone;\n\t}\n}\n\nclass Node{\n\tint cost;\n\tboolean visited;\n\tList<Integer> edge_to;\n\tList<Integer> edge_cost;\n\t\n\tpublic Node(){\n\t\tthis.cost = -1;\n\t\tthis.visited = false;\n\t\tthis.edge_cost = new ArrayList<Integer>();\n\t\tthis.edge_to = new ArrayList<Integer>();\n\t}\n\t\n\tpublic Node(Node n){\n\t\tthis.cost = n.cost;\n\t\tthis.visited = n.visited;\n\t\tthis.edge_to = new ArrayList<Integer>(n.edge_to);\n\t\tthis.edge_cost = new ArrayList<Integer>(n.edge_cost);\n\t}\n\t\n\tpublic void add_edge(int to, int cost){\n\t\tthis.edge_cost.add(cost);\n\t\tthis.edge_to.add(to);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0144();\n\t}\n\t\n\tvoid AOJ0145(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\tC0145[] c=new C0145[N];\n\t\t\tfor(int i=0; i<N; i++)\tc[i]=new C0145(sc.nextInt(),sc.nextInt());\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C0145{\n\t\tint upper,down;\n\t\tC0145(int u,int d){\tthis.upper=u;\tthis.down=d;\t}\n\t}\n\t\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=120;\n\t\twhile(sc.hasNext()){\n\t\t\tint temp=sc.nextInt();\n\t\t\tMAX=max(MAX,temp);\n\t\t\tqueue.add(temp);\n\t\t}\n\t\tint[] num=new int[MAX],time=new int[MAX],seat=new int[17];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\ttime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"TIME\"+i+\" \"+time[i]);\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"NUM\"+i+\" \"+num[i]);\n\t\tint j=0,min=0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tseat=exit(seat,min,time);\n\t\t\tint temp=find(seat,num[j]);\n\t\t\tif(temp>=0 && min>=j*5){\n\t\t\t\tint q=queue.getFirst();\n\t\t\t\tif(j==q){\n\t\t\t\t\tout.println(max(0,min-j*5));\n\t\t\t\t\tqueue.removeFirst();\n\t\t\t\t}\n\t\t\t\tfor(int i=temp; i<temp+num[j]; i++)\tseat[i]=j;\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\tmin++;\n\t\t\t}\n\t\t\t//debug\n\t\t\t//disp(seat,min-1);\n\t\t}\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] exit(int[] seat,int min,int[] time){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint idx=seat[i],emin=idx*5+time[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"1NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(now.ttl-1==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl-1,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Queue<Pair> queue = new LinkedList<Pair>();\n\n\tstatic class Pair {\n\t\tint routerIndex;\n\t\tint cost;\n\n\t\tPair(int index, int cost) {\n\t\t\tthis.routerIndex = index;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tstatic class Router {\n\t\tint number;\n\t\tint degree;\n\t\tRouter next[];\n\t\tint cost;\n\t\tboolean mark;\n\n\t\tRouter(int number) {\n\t\t\tthis.number = number;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tRouter rt[];\n\n\t\tn = sc.nextInt();\n\t\trt = new Router[n + 1];\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\trt[i] = new Router(i);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint number = sc.nextInt();\n\t\t\tint degree = sc.nextInt();\n\t\t\trt[i].degree = degree;\n\t\t\trt[i].next = new Router[degree];\n\t\t\tfor (int j = 0; j < degree; j++) {\n\t\t\t\trt[i].next[j] = rt[sc.nextInt()];\n\t\t\t}\n\t\t}\n\t\tm = sc.nextInt();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint start = sc.nextInt();\n\t\t\tint goal = sc.nextInt();\n\t\t\tint tll = sc.nextInt();\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\trt[j].mark = false;\n\t\t\t}\n\t\t\tqueue.clear();\n\t\t\tbestWay(rt, n, start, goal, 0);\n\n\t\t\tif (rt[goal].cost + 1 <= tll) {\n\t\t\t\tSystem.out.println(rt[goal].cost + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean bestWay(Router rt[], int n, int start, int goal, int cost) {\n\t\tif (rt[start].mark) {\n\t\t\treturn false;\n\t\t}\n\t\trt[start].cost = cost;\n\t\tif (start == goal) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < rt[start].degree; i++) {\n\t\t\tPair p = new Pair(rt[start].next[i].number, cost + 1);\n\t\t\tqueue.add(p);\n\t\t}\n\t\trt[start].mark = true;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tPair p = queue.poll();\n\t\t\tif (bestWay(rt, n, p.routerIndex, goal, p.cost)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\n/**\n * Packet Transportation\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tbyte n = Byte.parseByte(line);\n\n\t\t\t// router info\n\t\t\tRouter.setCount(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\tbyte id, next;\n\t\t\t\tid = Byte.parseByte(st.nextToken());\n\t\t\t\tnext = Byte.parseByte(st.nextToken());\n\t\t\t\tRouter.setRouter(id);\n\t\t\t\tfor (int j = 0; j < next; j++) {\n\t\t\t\t\tRouter.getRouter(id)\n\t\t\t\t\t\t\t.addNext(Byte.parseByte(st.nextToken()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// packet info\n\t\t\tint p = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\tbyte src, dst, ttl, hop;\n\t\t\t\tint d1, d2;\n\t\t\t\tline = br.readLine();\n\t\t\t\td1 = line.indexOf(' ');\n\t\t\t\td2 = line.indexOf(' ', d1 + 1);\n\t\t\t\tsrc = Byte.parseByte(line.substring(0, d1));\n\t\t\t\tdst = Byte.parseByte(line.substring(d1 + 1, d2));\n\t\t\t\tttl = Byte.parseByte(line.substring(d2 + 1));\n\t\t\t\thop = Router.getHops(src, dst, ttl);\n\t\t\t\tif (hop > 0) {\n\t\t\t\t\tSystem.out.println(hop);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Router {\n\n\tbyte id;\n\tArrayList<Byte> nexts;\n\n\tprivate static Router[] routers;\n\n\tstatic Router[] setCount(byte n) {\n\t\tif (routers == null) {\n\t\t\trouters = new Router[n + 1];\n\t\t}\n\t\treturn routers;\n\t}\n\n\tstatic void setRouter(byte id) {\n\t\tRouter r = new Router(id);\n\t\trouters[r.id] = r;\n\t}\n\n\tstatic Router getRouter(byte id) {\n\t\treturn routers[id];\n\t}\n\n\tstatic byte getHops(byte src, byte dst, byte ttl) {\n\n\t\tDeque<Router.Hop> deque = new ArrayDeque<Router.Hop>();\n\t\tboolean[] passed = new boolean[routers.length];\n\t\tbyte hop = 0;\n\n\t\tRouter r = getRouter(src);\n\t\tdeque.offer(r.new Hop(r, (byte) (ttl - 1)));\n\t\tpassed[r.id] = true;\n\t\twhile (!deque.isEmpty()) {\n\t\t\tHop h = deque.poll();\n\t\t\tif (h.router.id == dst) {\n\t\t\t\thop = (byte) (ttl - h.ttl);\n\t\t\t\tbreak;\n\t\t\t} else if (h.ttl > 0) {\n\t\t\t\tif (h.router.nexts.size() != 0) {\n\t\t\t\t\tfor (Byte i : h.router.nexts) {\n\t\t\t\t\t\tif (!passed[i]) {\n\t\t\t\t\t\t\tr = getRouter(i);\n\t\t\t\t\t\t\tdeque.offer(r.new Hop(r, (byte) (h.ttl - 1)));\n\t\t\t\t\t\t\tpassed[i] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hop;\n\t}\n\n\t//\n\tprivate Router(byte id) {\n\t\tthis.id = id;\n\t\tnexts = new ArrayList<Byte>();\n\t}\n\n\tpublic void addNext(byte id) {\n\t\tnexts.add(id);\n\t}\n\n\tprivate class Hop {\n\t\tRouter router;\n\t\tbyte ttl;\n\n\t\tpublic Hop(Router router, byte ttl) {\n\t\t\tthis.router = router;\n\t\t\tthis.ttl = ttl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new int[n][n];\n\t\tfor (int[] a: es) fill(a, INF);\n\t\tfor (int i=0;i<n;i++) es[i][i] = 0;\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, d = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println((es[s][d] + 1 <= v ? es[s][d] + 1 : \"NA\"));\n\t\t}\n\t}\n\t\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 1000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=1000;\n\t\t\t//\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t//\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t//\t\t\t\t\tSystem.out.println(i+\"->\"+j+\"  \"+root[i][j]);\n\t\t\t//\t\t\t\t\t\n\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min : \"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tint root[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(root[i], 1000);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint r=in.nextInt();\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)\n\t\t\t\t\troot[r][in.nextInt()]=1;\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=0;\n\t\t\tfor (int i=1;i<=n;i++)//ワーシャルフロイド\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=root[j][i]+root[i][k];\n\t\t\t\t\t\troot[j][k]=Math.min(root[j][k],c);\n\t\t\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\troot[i][i]=0;\n\t\t\tint p=in.nextInt();\n\t\t\tfor(int i=0;i<p;i++)\n\t\t\t{\n\t\t\t\tint s=in.nextInt(),t=in.nextInt();\n\t\t\t\tint TTL=in.nextInt();\n\t\t\t\tint min=root[s][t]+1;\n\t\t\t\tSystem.out.println(min<=TTL ? min:\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main\n{\n    static final int inf = 99999;\n    int[][] a;\n\n    Main(){\n\tScanner sc = new Scanner(System.in);\n\tint n, m, s, t;\n\n\twhile(sc.hasNext()){\n\t    n = sc.nextInt();\n\t    a = new int[n+1][n+1];\n\n\t    for(int i = 0; i <= n; ++i)\n\t\tfor(int j = i+1; j <= n; ++j)\n\t\t    a[i][j] = a[j][i] = inf;\n\n\t    for(int i = 0; i < n; ++i){\n\t\ts = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tfor(int j = 0; j < m; ++j){\n\t\t    t = sc.nextInt();\n\t\t    a[s][t] = 1;\n\t\t}\n\t    }\n\n\t    for(int k = 1; k <= n; ++k)\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t    for(int j = 1; j <= n; ++j)\n\t\t\ta[i][j] = Math.min(a[i][j], a[i][k]+a[k][j]);\n\n\t    n = sc.nextInt();\n\t    for(int i = 0; i < n; ++i){\n\t\ts = sc.nextInt();\n\t\tt = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tif(a[s][t] < u)\n\t\t    System.out.println(Integer.toString(a[s][t]+1));\n\t\telse\n\t\t    System.out.println(\"NA\");\n\t    }\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tMap<Integer, List<Integer>> memomap = new HashMap<Integer, List<Integer>>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tmemomap.put(s, memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (Entry<Integer, List<Integer>> entry : memomap.entrySet()) {\n\t\t\tslove(map, memomap, entry.getKey(), entry.getKey(), 1, 0);\n\t\t}\n\t\tfor(int[] a : map){\n\t\t\tSystem.out.println(Arrays.toString(a));\n\t\t}\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[][] map, Map<Integer, List<Integer>> memomap,\n\t\t\tint i, int s, int n, int bit) {\n\t\tfor (int t : memomap.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, memomap, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic byte[][] d;\n\tstatic final byte INF = Byte.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner scan = new Scanner(System.in);\n\t\tbyte n = scan.nextByte();\n\t\td = new byte[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = i!=j ? INF : 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbyte id = scan.nextByte();\n\t\t\tbyte c = scan.nextByte();\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\td[id-1][scan.nextByte()-1]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = (byte)Math.min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint p = scan.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tbyte s = scan.nextByte();\n\t\t\tbyte g = scan.nextByte();\n\t\t\tshort ttl = scan.nextShort();\n\t\t\tout.println(ttl<=d[s-1][g-1] || d[s-1][g-1]==INF ? \"NA\" : d[s-1][g-1]+1);\n\t\t}\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\n\t\tList<List<Integer>> list = new ArrayList<List<Integer>>();\n\t\tlist.add(new ArrayList<Integer>());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanner.next();\n\t\t\tint m = scanner.nextInt();\n\t\t\tList<Integer> memo = new ArrayList<Integer>();\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmemo.add(scanner.nextInt());\n\t\t\t}\n\t\t\tlist.add(memo);\n\t\t}\n\t\tint[][] map = new int[n + 1][n + 1];\n\t\tint INF = 1 << 28;\n\t\tfor (int[] m : map) {\n\t\t\tArrays.fill(m, INF);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tslove(map, list, i, i, 1, 1 << i);\n\t\t}\n\t\tint nn = scanner.nextInt();\n\t\tfor (int i = 0; i < nn; i++) {\n\t\t\tint s = scanner.nextInt();\n\t\t\tint t = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (map[s][t] < m) {\n\t\t\t\tSystem.out.println(map[s][t] + 1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static void slove(int[][] map, List<List<Integer>> list, int i,\n\t\t\tint s, int n, int bit) {\n\t\tfor (int t : list.get(s)) {\n\t\t\tint a = bit | 1 << t;\n\t\t\tif (a != bit && map[i][t] > n) {\n\t\t\t\tmap[i][t] = n;\n\t\t\t\tslove(map, list, i, t, n + 1, a);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0144\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            Graph gh = new Graph();\n            int n = RInt();\n            for (int i = 0 ; i < n ; i++)\n            {\n                int[] items = RIntAr();\n                gh.SetGraph(items[0], items.Skip(2).ToArray());\n            }\n\n            int p = RInt();\n            for (int i = 0 ; i < p ; i++)\n            {\n                int[] sdv = RIntAr();\n                int distance = gh.GetDistance(sdv[0], sdv[1]);\n                Console.WriteLine((distance < sdv[2] && distance != -1) ? (distance + 1).ToString() : \"NA\");\n            }\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\npublic class Graph\n{\n    public class Node\n    {\n        public List<KeyValuePair<int, int>> Vertex { get; internal set; }\n        public bool IsVisited { get; internal set; }\n        public int Depth { get; internal set; }\n\n        public Node(List<int> v)\n        {\n            Vertex = v.Select(x => new KeyValuePair<int, int>(x, -1)).ToList();\n            Depth = -1;\n        }\n    }\n\n    public Dictionary<int, Node> Adj { get; set; }\n    public int Count { get { return Adj.Count; } }\n\n    public Graph()\n    {\n        Adj = new Dictionary<int, Node>();\n    }\n\n    /// <summary>\n    /// 指定した頂点をセットする\n    /// </summary>\n    /// <param name=\"index\">頂点u</param>\n    /// <param name=\"item\">頂点uに接続する頂点</param>\n    public void SetGraph(int index, int[] item)\n    {\n        if (item == null)\n        {\n            Adj.Add(index, new Node(new List<int>()));\n        }\n        else\n        {\n            Adj.Add(index, new Node(item.ToList()));\n        }\n    }\n\n    /// <summary>\n    /// 訪問済フラグをクリアする\n    /// </summary>\n    private void InitVisitFlag()\n    {\n        foreach (KeyValuePair<int, Node> item in Adj) item.Value.IsVisited = false;\n    }\n\n    /// <summary>\n    /// 頂点間の最小頂点数を返す\n    /// </summary>\n    /// <param name=\"start\">始点</param>\n    /// <param name=\"end\">終点</param>\n    /// <returns>\n    /// 始点と終点の距離\n    /// 始点と終点が連結されていない場合は-1を返す\n    /// </returns>\n    public int GetDistance(int start, int end)\n    {\n        InitVisitFlag();\n        Queue<Node> que = new Queue<Node>();\n\n        Adj[start].IsVisited = true;\n        Adj[start].Depth = 0;\n\n        if (start == end) return Adj[start].Depth;\n        que.Enqueue(Adj[start]);\n\n        while (que.Count() != 0)\n        {\n            Node node = que.Dequeue();\n            foreach (KeyValuePair<int, int> vertex in node.Vertex)\n            {\n                if (!Adj[vertex.Key].IsVisited)\n                {\n                    Adj[vertex.Key].IsVisited = true;\n                    Adj[vertex.Key].Depth = node.Depth + 1;\n\n                    if (vertex.Key == end) return Adj[vertex.Key].Depth;\n                    que.Enqueue(Adj[vertex.Key]);\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\nnamespace Test1 {\n\n\n\n\n\n    class ClassMain {\n\n\n       static int[,] rooterTrans = new int[101, 101];\n\n        static void rue(int[,] roots){\n            int n = roots.GetLength(0);\n            bool changes ;\n            do {\n                changes = false;\n                for (int a = 1; a < n; a++) {\n                    for (int b = 0; b < n; b++) {\n                        if (a == b) { continue; }\n                        if (roots[a, b] != 0) {\n                            //a->b\n                            for (int c = 1; c < n; c++) {\n                                if (c == a || c == b) { continue; }\n                                if (roots[b, c] != 0) {\n                                    //a->b, b->c.\n                                    int newCost = roots[a, b] + roots[b, c]-1;\n                                    if (roots[a, c] == 0||newCost<roots[a,c]) {\n                                        roots[a, c] = newCost;\n                                        //Console.WriteLine(a + \",\" + b + \",\" + c + \".\" + roots[a, c]);\n                                        //Console.WriteLine(\"ab,\" + roots[a,b] + \" bc,\"+roots[b,c]);\n                                        //roots[c, a] = newCost;\n                                        changes = true;\n                                    }//if [a,c]==0\n                                }//if[b,c]!=0\n                            }//Loop c\n                        }//if [a,b] != 0\n                    }//Loop b\n                }//Loop a\n                Console.WriteLine(changes);\n            } while (changes);\n        }\n\n\n\n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int n = int.Parse(line);\n                if (n == 0) { break; }\n                rooterTrans = new int[n+1, n+1];\n                for (int i = 0; i < n; i++) {\n                    int[] ints = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    rooterTrans[ints[0], ints[0]] = 1;\n                    for (int j = 0; j < ints[1]; j++) {\n                        rooterTrans[ints[0], ints[2 + j]] = 2;\n                        //rooterTrans[ints[2+j], ints[0]] = 2;\n                    }\n                }\n                for (int i = 0; i < n+1; i++) {\n                    for (int j = 0; j < n+1; j++) {\n                       // Console.Write(rooterTrans[i, j]+\",\");\n                    } \n                    //Console.WriteLine();\n                }\n                rue(rooterTrans);\n                //Rooters init.\n                int pn = int.Parse(Console.ReadLine());\n                for (int i = 0; i < pn; i++) {\n                    int[] ints = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    int cost=rooterTrans[ints[0],ints[1]];\n                    if (cost == 0 || cost > ints[2]) {\n                        Console.WriteLine(\"NA\");\n                    }\n                    else {\n                        Console.WriteLine(cost);\n                    }\n                }\n                break;\n            }\n        }\n    \n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly int INF = int.MaxValue / 2;\n\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            int[,] map = new int[n + 1, n + 1];\n\n            for (int i = 1; i <= n; i++)\n            {\n                for (int j = 1; j <= n; j++)\n                {\n                    map[i, j] = INF;\n                }\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                int id = input[0];\n                int len = input[1];\n\n                for (int j = 0; j < len; j++)\n                {\n                    map[id, input[2 + j]] = 1;\n                }\n            }\n\n            for (int k = 1; k <= n; k++)\n            {\n                for (int i = 1; i <= n; i++)\n                {\n                    for (int j = 1; j <= n; j++)\n                    {\n                        map[i, j] = Math.Min(map[i, j], map[i, k] + map[k, j]);\n                    }\n                }\n            }\n\n            int p = int.Parse(Console.ReadLine());\n\n            while (p-- > 0)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                int from = input[0];\n                int to = input[1];\n                int maxV = input[2];\n\n                int v = map[from, to] + 1;\n\n                if (v > maxV) sb.AppendLine(\"NA\");\n                else sb.AppendLine(v.ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace AOJ.Volume1\n{\n    public class PacketTransportation\n    {\n        // ルータの接続情報\n        // node[1,2]はルータ1からルータ2に接続できるかを表す\n        // 0→接続不可,1→接続可能\n        private static int[,] node;\n\n        private static int Calc(int n, int start, int goal, int cost)\n        {\n            // 直接つながっている場合は終了\n            if (node[start, goal] == 1) { return cost + 1; }\n\n            // 自分に隣接するルータを深さ優先探索\n            int ret = 0;\n            for (int i = 1; i <= n; i++)\n            {\n                int tmp = 0;\n                if (node[start, i] == 1) { tmp = Calc(n, i, goal, cost + 1); }\n                if (tmp > 0) { ret = ret == 0 ? tmp : Math.Min(ret, tmp); }\n            }\n\n            return ret;\n        }\n\n        public static int Main()\n        {\n            int n = int.Parse(Console.ReadLine());\n            // 接続情報初期化\n            node = new int[n + 1, n + 1];\n            for (int i = 0; i < n; i++)\n            {\n                var input = Console.ReadLine().Split(' ');\n                int no = int.Parse(input[0]);\n                int node_cnt = int.Parse(input[1]);\n                for (int j = 2; j < node_cnt + 2; j++) { node[no, int.Parse(input[j])] = 1; }\n            }\n\n            int packet_cnt = int.Parse(Console.ReadLine());\n            for (int i = 0; i < packet_cnt; i++)\n            {\n                var input = Console.ReadLine().Split(' ');\n                int start = int.Parse(input[0]);\n                int goal = int.Parse(input[1]);\n                int ttl = int.Parse(input[2]);\n\n                int cost = Calc(n, start, goal, 1);\n                if (cost == 0) { Console.WriteLine(\"NA\"); }\n                else\n                {\n                    if (cost <= ttl) { Console.WriteLine(cost); }\n                    else { Console.WriteLine(\"NA\"); }\n                }\n            }\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ.Volume1\n{\n    public class PacketTransportation\n    {\n        // ルータの接続情報\n        // node[1,2]はルータ1からルータ2に接続できるかを表す\n        // 0→接続不可,1→接続可能\n        private static int[,] edge;\n\n        private struct Rooter\n        {\n            public int No;\n            public int Cost;\n            public bool Confirm;\n        }\n\n        private static Rooter[] node;\n\n        private static void Calc(int n, int start)\n        {\n            // ダイクストラ法で各ルータの距離を計算\n            // 配列を初期化\n            node = new Rooter[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                node[i].No = i;\n                node[i].Cost = -1;\n                node[i].Confirm = false;\n            }\n\n            node[start].Cost = 0;\n            node[start].Confirm = true;\n\n            var que = new Queue<Rooter>();\n            que.Enqueue(node[start]);\n            while (que.Count > 0)\n            {\n                var r = que.Dequeue();\n                for (int i = 1; i <= n; i++)\n                {\n                    if ((edge[r.No, i] == 1) && (node[i].Confirm == false))\n                    {\n                        // 今回はすべてのルータ間の距離が同じなので発見次第確定\n                        node[i].Cost = r.Cost + 1;\n                        node[i].Confirm = true;\n                        que.Enqueue(node[i]);\n                    }\n                }\n            }\n\n            return;\n        }\n\n        public static int Main()\n        {\n            int n = int.Parse(Console.ReadLine());\n            // 接続情報初期化\n            edge = new int[n + 1, n + 1];\n            for (int i = 0; i < n; i++)\n            {\n                var input = Console.ReadLine().Split(' ');\n                int no = int.Parse(input[0]);\n                int node_cnt = int.Parse(input[1]);\n                for (int j = 2; j < node_cnt + 2; j++) { edge[no, int.Parse(input[j])] = 1; }\n            }\n\n            int packet_cnt = int.Parse(Console.ReadLine());\n            for (int i = 0; i < packet_cnt; i++)\n            {\n                var input = Console.ReadLine().Split(' ');\n                int start = int.Parse(input[0]);\n                int goal = int.Parse(input[1]);\n                int ttl = int.Parse(input[2]);\n\n                // 距離を計算\n                Calc(n, start);\n                if (node[goal].Confirm == false) { Console.WriteLine(\"NA\"); }\n                else if (node[goal].Cost >= ttl) { Console.WriteLine(\"NA\"); }\n                else { Console.WriteLine(node[goal].Cost + 1); }\n            }\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class C\n{\n    public const int INF = 999999999;\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var dp = new int[n, n];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                if (i == j) dp[i, j] = 0;\n                else dp[i, j] = C.INF;\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var r = int.Parse(line[0]) - 1;\n            var k = int.Parse(line[1]);\n            for (int j = 0; j < k; j++)\n                dp[r, int.Parse(line[j + 2]) - 1] = 1;\n        }\n        goWarshall(dp);\n        var p = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < p; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var s = int.Parse(line2[0]);\n            var d = int.Parse(line2[1]);\n            var v = int.Parse(line2[2]);\n            if (dp[s - 1, d - 1] == C.INF | dp[s - 1, d - 1] + 1 > v) Console.WriteLine(\"NA\");\n            else Console.WriteLine(dp[s - 1, d - 1] +1);\n        }\n    }\n    public static void goWarshall(int[,] dp)\n    {\n        var n = dp.GetLength(0);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                for (int k = 0; k < n; k++)\n                        dp[j, k] = Math.Min(dp[j, k], dp[j, i] + dp[i, k]);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly int INF = int.MaxValue / 2;\n\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            int[,] map = new int[n + 1, n + 1];\n\n            for (int i = 1; i <= n; i++)\n            {\n                for (int j = 1; j <= n; j++)\n                {\n                    map[i, j] = INF;\n                }\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                int from = input[0];\n                int len = input[1];\n\n                for (int j = 0; j < len; j++)\n                {\n                    int to = input[2 + j];\n\n                    map[from, to] = 1;\n                }\n            }\n\n            for (int k = 1; k <= n; k++)\n            {\n                for (int i = 1; i <= n; i++)\n                {\n                    for (int j = 1; j <= n; j++)\n                    {\n                        map[i, j] = Math.Min(map[i, j], map[i, k] + map[k, j]);\n                    }\n                }\n            }\n\n            int p = int.Parse(Console.ReadLine());\n\n            while (p-- > 0)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                int from = input[0];\n                int to = input[1];\n                int maxV = input[2];\n\n                int v = map[from, to] + 1;\n\n                if (v > maxV) sb.AppendLine(\"NA\");\n                else sb.AppendLine(v.ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n    void run()\n    {\n        Scanner cin = new Scanner();\n        int n = cin.nextInt();\n        int[,] dist = new int[n, n];\n        int MAX = 1000000009;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                dist[i, j] = MAX;\n            }\n        }\n        for (int i = 0; i < n; i++)\n        {\n            int a = cin.nextInt() - 1;\n            int num = cin.nextInt();\n            for (int j = 0; j < num; j++)\n            {\n                dist[a, cin.nextInt() - 1] = 1;\n            }\n        }\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dist[i, j] = Math.Min(dist[i, j], dist[i, k] + dist[k, j]);\n                }\n            }\n        }\n\n        int T = cin.nextInt();\n        for (int i = 0; i < T; i++)\n        {\n            int s = cin.nextInt() - 1;\n            int d = cin.nextInt() - 1;\n            int t = cin.nextInt();\n            if (dist[s, d] + 1 <= t) Console.WriteLine(dist[s,d] + 1);\n            else Console.WriteLine(\"NA\");\n        }\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n\nnamespace Test1 {\n\n\n\n\n\n    class ClassMain {\n\n\n       static int[,] rooterTrans = new int[101, 101];\n\n        static void rue(int[,] roots){\n            int n = roots.GetLength(0);\n            bool changes ;\n            do {\n                changes = false;\n                for (int a = 1; a < n; a++) {\n                    for (int b = 0; b < n; b++) {\n                        if (a == b) { continue; }\n                        if (roots[a, b] != 0) {\n                            //a->b\n                            for (int c = 1; c < n; c++) {\n                                if (c == a || c == b) { continue; }\n                                if (roots[b, c] != 0) {\n                                    //a->b, b->c.\n                                    int newCost = roots[a, b] + roots[b, c]-1;\n                                    if (roots[a, c] == 0||newCost<roots[a,c]) {\n                                        roots[a, c] = newCost;\n                                        //Console.WriteLine(a + \",\" + b + \",\" + c + \".\" + roots[a, c]);\n                                        //Console.WriteLine(\"ab,\" + roots[a,b] + \" bc,\"+roots[b,c]);\n                                        //roots[c, a] = newCost;\n                                        changes = true;\n                                    }//if [a,c]==0\n                                }//if[b,c]!=0\n                            }//Loop c\n                        }//if [a,b] != 0\n                    }//Loop b\n                }//Loop a\n                //Console.WriteLine(changes);\n            } while (changes);\n        }\n\n\n\n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int n = int.Parse(line);\n                if (n == 0) { break; }\n                rooterTrans = new int[n+1, n+1];\n                for (int i = 0; i < n; i++) {\n                    int[] ints = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    rooterTrans[ints[0], ints[0]] = 1;\n                    for (int j = 0; j < ints[1]; j++) {\n                        rooterTrans[ints[0], ints[2 + j]] = 2;\n                        //rooterTrans[ints[2+j], ints[0]] = 2;\n                    }\n                }\n                for (int i = 0; i < n+1; i++) {\n                    for (int j = 0; j < n+1; j++) {\n                       // Console.Write(rooterTrans[i, j]+\",\");\n                    } \n                    //Console.WriteLine();\n                }\n                rue(rooterTrans);\n                //Rooters init.\n                int pn = int.Parse(Console.ReadLine());\n                for (int i = 0; i < pn; i++) {\n                    int[] ints = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                    int cost=rooterTrans[ints[0],ints[1]];\n                    if (cost == 0 || cost > ints[2]) {\n                        Console.WriteLine(\"NA\");\n                    }\n                    else {\n                        Console.WriteLine(cost);\n                    }\n                }\n                break;\n            }\n        }\n    \n    }\n\n\n\n    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n    void run()\n    {\n        Scanner cin = new Scanner();\n        int n = cin.nextInt();\n        int[,] dist = new int[n, n];\n        int MAX = 1000000009;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                dist[i, j] = MAX;\n            }\n        }\n        for (int i = 0; i < n; i++)\n        {\n            cin.nextInt();\n            int num = cin.nextInt();\n            for (int j = 0; j < num; j++)\n            {\n                dist[i, cin.nextInt() - 1] = 1;\n            }\n        }\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dist[i, j] = Math.Min(dist[i, j], dist[i, k] + dist[k, j]);\n                }\n            }\n        }\n\n        int T = cin.nextInt();\n        for (int i = 0; i < T; i++)\n        {\n            int s = cin.nextInt() - 1;\n            int d = cin.nextInt() - 1;\n            int t = cin.nextInt();\n            if (dist[s, d] + 1 <= t) Console.WriteLine(dist[s,d] + 1);\n            else Console.WriteLine(\"NA\");\n        }\n\n    }\n\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nw=(0..n=g[0]).map{|i|[100]*(n+1)}\nn.times{f,_,*t=g;t.map{|i|w[f][i]=1}}\nn.times{|k|k+=1;n.times{|i|i+=1;n.times{|j|j+=1;(a=w[i][k]+w[k][j])<w[i][j]&&w[i][j]=a}}}\ng[0].times{s,d,v=g;c=w[s][d]+1;puts c>v ?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\ndp = Array.new(n) { Array.new n }\nn.times do |i|\n  gets.split.map(&:to_i).drop(1).each {|j| dp[i][j-1] = 1 }\n  dp[i][i] = 0\nend\nn.times do |k|\n  n.times do |i|\n    n.times do |j|\n      dp[i][j] = dp[i][k] + dp[k][j] if dp[i][k] && dp[k][j] && (!dp[i][j] || dp[i][k] + dp[k][j] < dp[i][j])\n    end\n  end\nend\ngets.to_i.times do\n  s, d, v = gets.split.map(&:to_i)\n  puts dp[s-1][d-1] && dp[s-1][d-1] + 1 <= v ? dp[s-1][d-1] + 1 : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "Infinity = 1000000\n\ndef floydwarshall graph\n  n = graph.size\n  dist = Array.new(n).map{Array.new(n, Infinity)}\n  n.times do |i|\n    dist[i][i] = 0\n  end\n  n.times do |i|\n    graph[i].each do |edge|\n      dist[i][edge] = 1\n    end\n  end\n\n  n.times do |k|\n    n.times do |u|\n      n.times do |v|\n        newPop = dist[u][k] + dist[k][v]\n        if newPop < dist[u][v]\n          dist[u][v] = newPop\n        end\n      end\n    end\n  end\n  dist\nend\n\n#ネットワーク取得\nn = $stdin.gets.to_i\ngraph = Array.new(n).map{Array.new}\nn.times do\n  input = $stdin.gets.split(\" \").map(&:to_i)\n  input[1].times do |t|\n    graph[input[0] - 1] << input[t + 2] - 1\n  end\nend\n\ndist = floydwarshall graph\n\n#パケット処理\n$stdin.gets.to_i.times do\n  s, d, v = $stdin.gets.split(\" \").map(&:to_i)\n  if dist[s - 1][d - 1] + 1 <= v\n    puts dist[s - 1][d - 1] + 1\n  else\n    puts \"NA\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g.drop 2}\ngets.to_i.times{s,d,v=g\nt=[s]\nu=[]\nc=v\n(u+=t;t=t.flat_map{|i|m[i]}.uniq-u)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nr=1..n=gets.to_i\nw=[0]+r.map{[0]+[100]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.each{|k|r.each{|i|r.each{|j|(a=w[i][k]+w[k][j])<w[i][j]&&w[i][j]=a}}}\ngets.to_i.times{s,d,v=g;c=w[s][d]+1;puts c>v ?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[[]]+(\"1\\n\"..gets).map{g.drop 2}\ngets.to_i.times{s,d,v=g\nn=m.map{|a|a.dup}\nt=[s]\nc=v\n(t.map{|i|n.map!{|a|a-[i]}};t=t.flat_map{|i|n[i]}.uniq)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g[2..-1]}\ngets.to_i.times{s,d,v=g\nt=[s]\nc=1\n(c+=1;t=t.flat_map{|i|m[i]}.uniq)until c>v||t.index(d)\nputs c>v ?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[[]]+(\"1\\n\"..gets).map{g.drop 2}\ngets.to_i.times{s,d,v=g\nn=m.dup\nt=[s]\nc=0\n(t.map{|i|n.map!{|a|a-[i]}};t=t.flat_map{|i|n[i]}.uniq)until(c+=1)>v||t.index(d)\nputs c>v ?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[[]]+(1..g[0]).map{g.drop 2}\ng[0].times{s,d,v=g\nn=m.dup\nt=[s]\nc=0\n(t.map{|i|n.map!{|a|a-[i]}};t=t.flat_map{|i|n[i]}.uniq)until(c+=1)>v||t.index(d)\nputs c>v ?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g.drop 2}\ngets.to_i.times{s,d,v=g\nt=[s]\nu=[]\nc=v\n(u+=t;t=t.flat_map{|i|m[i]}.uniq-u.uniq!)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "root=(1..gets.to_i).map{\n  r,k,*t=gets.split.map(&:to_i)\n  [r,t]\n}.to_h\n\ngets.to_i.times{\n  s,d,v=gets.split.map(&:to_i)\n  q=[[s,1]]\n  ret = while q[0]\n    id,num=q.shift\n    break num if id==d\n    next if num>=v\n    root[id].each{|i|\n      q.push([i,num+1])\n    }\n  end\n  puts (ret||\"NA\")\n}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g.drop 2}\ngets.to_i.times{s,d,v=g\nt=[s]\nu=[]\nc=v\n(u|=t;t=t.flat_map{|i|m[i]}.uniq-u)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g.drop(2).sort}\ngets.to_i.times{s,d,v=g\nt=[s]\nu=[]\nc=v\n(u+=t;t=t.flat_map{|i|m[i]}.uniq.sort-u.sort!)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "Infinity = 1000000\n\ndef bellman graph, s\n  n = graph.size\n  dist = Array.new(n, Infinity)\n  dist[s] = 0\n\n  #始点以外のすべての点について最短経路計算を行う\n  (1..n).each do |u|\n    #すべての辺をもとに最短経路を更新\n    n.times do |i|\n      graph[i].each do |v|\n        newLength = dist[i] + 1\n        if newLength < dist[v]\n           raise Exception.new(\"negative cycle found.\") if i == n\n          dist[v] = newLength\n        end\n      end\n    end\n  end\n  dist\nend\n\n#ネットワーク取得\nn = $stdin.gets.to_i\ngraph = Array.new(n).map{Array.new}\nn.times do\n  input = $stdin.gets.split(\" \").map(&:to_i)\n  input[1].times do |t|\n    graph[input[0] - 1] << input[t + 2] - 1\n  end\nend\n\n#パケット処理\n$stdin.gets.to_i.times do\n  s, d, v = $stdin.gets.split(\" \").map(&:to_i)\n  dist = bellman(graph, s - 1)\n  if dist[d - 1] + 1 <= v\n    puts dist[d - 1] + 1\n  else\n    puts \"NA\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[[]]+(\"1\\n\"..gets).map{g.drop 2}\ngets.to_i.times{s,d,v=g\nn=m.dup\nt=[s]\nc=v\n(t.map{|i|n.map!{|a|a-[i]}};t=t.flat_map{|i|n[i]}.uniq)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[[]]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.map{|k|w.map!{|i|i=i.zip(w[k]).map{|a,b|[a,b+i[k]].min}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g[2..-1]}\ngets.to_i.times{s,d,v=g\nt=[s]\nc=1\n(c+=1;t=t.flat_map{|i|m[i]})until c>v||t.index(d)\nputs c>v ?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "Infinity = 1000000\n\ndef dijkstra graph, s\n  n = graph.size\n  dist = Array.new(n, Infinity)\n  visited = Array.new(n, false)\n  dist[s] = 0\n  loop do\n    min = -1\n    sd = Infinity\n    n.times do |i|\n      if (! visited[i]) && dist[i] < sd\n        min = i\n        sd = dist[i]\n      end\n    end\n    break if min == -1\n    visited[min] = true\n    graph[min].each do |node|\n      newLen = dist[min] + 1\n      if(newLen < dist[node])\n        dist[node] = newLen\n      end\n    end\n  end\n  dist\nend\n\n#ネットワーク取得\nn = $stdin.gets.to_i\ngraph = Array.new(n).map{Array.new}\nn.times do\n  input = $stdin.gets.split(\" \").map(&:to_i)\n  input[1].times do |t|\n    graph[input[0] - 1] << input[t + 2] - 1\n  end\nend\n\n#パケット処理\n$stdin.gets.to_i.times do\n  s, d, v = $stdin.gets.split(\" \").map(&:to_i)\n  dist = dijkstra(graph, s - 1)\n  if dist[d - 1] + 1 <= v\n    puts dist[d - 1] + 1\n  else\n    puts \"NA\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.map{|k|r.map{|i|r.map{|j|(a=(b=w[i])[k]+w[k][j])<b[j]&&b[j]=a}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g.drop(2).sort}\ngets.to_i.times{s,d,v=g\nt=[s]\nu=[]\nc=v\n(u+=t;t=t.flat_map{|i|m[i]}.uniq-u)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "address = $<.gets.to_i.times.map do\n  r, k, *t = $<.gets.split.map(&:to_i)\n  [r, t]\nend.to_h\n\n$<.gets.to_i.times do\n  s, d, v = $<.gets.split.map(&:to_i)\n  queue = [s]\n  dist = {}\n  dist[s] = 1\n  until !(now = queue.shift) or now == d\n    address[now].each do |nxt|\n      unless dist[nxt]\n        dist[nxt] = dist[now] + 1\n        queue << nxt\n      end\n    end\n  end\n  d = dist[now]\n  puts d && (d <= v) ? d : \"NA\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "root=(1..gets.to_i).map{\n  r,k,*t=gets.split.map(&:to_i)\n  [r,t]\n}.to_h\n\ngets.to_i.times{\n  s,d,v=gets.split.map(&:to_i)\n  q=[[s,1]]\n  visited={s=>true}\n  ret = while q[0]\n    id,num=q.shift\n    next if num>v\n    break num if id==d\n    root[id].each{|i|\n      unless visited[i]\n        visited[i]=true\n        q.push([i,num+1])\n      end\n    }\n  end\n  puts (ret||\"NA\")\n}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.strip.to_i\n\nrtmap = {}\n\nn.times.each do\n  eis = gets.strip.split(' ').map{|s| s.to_i}\n  r = eis.shift\n  k = eis.shift\n\n  rtmap[r] = { :id => r, :nbrs => eis }\nend\n\npn = gets.strip.to_i\n\npn.times.each do\n  src, dst, ttl = gets.strip.split(' ').map{|s| s.to_i}\n\n  rtmap.values.each{|nd| nd[:dist] = nil}\n\n  rtmap[src][:dist] = 1\n  queue = [src]\n\n  while ! queue.empty?\n    id = queue.shift\n    dist0 = rtmap[id][:dist]\n\n    for nid in rtmap[id][:nbrs]\n      node = rtmap[nid]\n      if node[:dist].nil?\n        node[:dist] = dist0 + 1\n        queue.push nid\n      end\n    end\n  end\n\n  ddist = rtmap[dst][:dist]\n  puts (! ddist.nil? && ddist <= ttl) ? ddist : \"NA\"\nend"
  },
  {
    "language": "Ruby",
    "code": "# Node\nclass Node\n  attr_accessor :id, :edges, :cost, :done\n\n  def initialize(id, edges = [], cost = nil, done = false)\n    @id, @edges, @cost, @done = id, edges, cost, done\n  end\nend\n\n# Edge\nclass Edge\n  attr_accessor :to, :cost\n\n  def initialize(to, cost)\n    @to, @cost = to, cost\n  end\nend\n\n# Dijkstra\nclass Dijkstra\n  attr_accessor :nodes\n\n  def initialize(data)\n    @nodes = {}\n    data.each do |id, edges|\n      edges.map! { |edge| Edge.new(*edge) }\n      @nodes[id] = Node.new(id, edges)\n    end\n  end\n\n  def start(start_id)\n    @nodes.each do |id, node|\n      node.done = false\n      node.cost = node.id == start_id ? 0 : -1\n    end\n\n    loop do\n      done_node = nil\n      @nodes.each do |id, node|\n        next if node.done || node.cost < 0\n        done_node = node if done_node.nil? || node.cost < done_node.cost\n      end\n      break if done_node.nil?\n      done_node.done = true\n      done_node.edges.each do |edge|\n        node = @nodes[edge.to]\n        cost = done_node.cost + edge.cost\n        node.cost = cost if node.cost < 0 || cost < node.cost\n      end\n    end\n  end\nend\n\ndata = {}\n\nn = gets.chomp.to_i\n\nn.times do\n  r, k, *t = gets.chomp.split.map(&:to_i)\n  data[r] ||= []\n  k.times do |i|\n    data[r] << [t[i], 1]\n  end\nend\n\np = gets.chomp.to_i\n\np.times do\n  s, d, v = gets.chomp.split.map(&:to_i)\n  clone = Marshal.load(Marshal.dump(data))\n  dijkstra = Dijkstra.new(clone)\n  dijkstra.start(s)\n  puts (dijkstra.nodes[d].cost + 1 <= v) ? dijkstra.nodes[d].cost + 1 : :NA\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g.drop 2}\ngets.to_i.times{s,d,v=g\nt=[s]\nu=[]\nc=v\n(u+=t;u.uniq!;t=t.flat_map{|i|m[i]}.uniq-u)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nm=[0]+(\"1\\n\"..gets).map{g.drop 2}\ngets.to_i.times{s,d,v=g\nt=[s]\nu=[]\nc=v\n(u+=t;t=t.flat_map{|i|m[i]}-u)until(c-=1)<0||t.index(d)\nputs c<0?:NA:v-c}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nr=1..n=gets.to_i\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.each{|k|r.each{|i|r.each{|j|(a=w[i][k]+w[k][j])<w[i][j]&&w[i][j]=a}}}\ngets.to_i.times{s,d,v=g;c=w[s][d]+1;puts c>v ?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\ndp = Array.new(n) { Array.new n }\nn.times do |i|\n  r, _, *ts = gets.split.map(&:to_i)\n  ts.each {|j| dp[r-1][j-1] = 1 }\n  dp[i][i] = 0\nend\nn.times do |k|\n  n.times do |i|\n    n.times do |j|\n      dp[i][j] = dp[i][k] + dp[k][j] if dp[i][k] && dp[k][j] && (!dp[i][j] || dp[i][k] + dp[k][j] < dp[i][j])\n    end\n  end\nend\ngets.to_i.times do\n  s, d, v = gets.split.map(&:to_i)\n  puts dp[s-1][d-1] && dp[s-1][d-1] + 1 <= v ? dp[s-1][d-1] + 1 : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.map{|k|r.map{|i|r.map{|j|(a=(b=w[i])[k]+w[k][j])<b[j]&&b[j]=a}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "# Node\nclass Node\n  attr_accessor :id, :edges, :cost, :done\n\n  def initialize(id, edges = [], cost = nil, done = false)\n    @id, @edges, @cost, @done = id, edges, cost, done\n  end\nend\n\n# Edge\nclass Edge\n  attr_accessor :to, :cost\n\n  def initialize(to, cost)\n    @to, @cost = to, cost\n  end\nend\n\n# Dijkstra\nclass Dijkstra\n  attr_accessor :nodes\n\n  def initialize(data)\n    @nodes = {}\n    data.each do |id, edges|\n      edges.map! { |edge| Edge.new(*edge) }\n      @nodes[id] = Node.new(id, edges)\n    end\n  end\n\n  def start(start_id)\n    @nodes.each do |id, node|\n      node.done = false\n      node.cost = node.id == start_id ? 0 : -1\n    end\n\n    loop do\n      done_node = nil\n      @nodes.each do |id, node|\n        next if node.done || node.cost < 0\n        done_node = node if done_node.nil? || node.cost < done_node.cost\n      end\n      break if done_node.nil?\n      done_node.done = true\n      done_node.edges.each do |edge|\n        node = @nodes[edge.to]\n        cost = done_node.cost + edge.cost\n        node.cost = cost if node.cost < 0 || cost < node.cost\n      end\n    end\n  end\nend\n\ndata = {}\n\nn = gets.chomp.to_i\n\nn.times do\n  r, k, *t = gets.chomp.split.map(&:to_i)\n  data[r] ||= []\n  k.times do |i|\n    data[r] << [t[i], 1]\n  end\nend\n\np = gets.chomp.to_i\n\np.times do\n  s, d, v = gets.chomp.split.map(&:to_i)\n  clone = Marshal.load(Marshal.dump(data))\n  dijkstra = Dijkstra.new(clone)\n  dijkstra.start(s)\n  puts (dijkstra.nodes[d].cost != -1 && dijkstra.nodes[d].cost + 1 <= v) ? dijkstra.nodes[d].cost + 1 : :NA\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nw=(0..n=g[0]).map{|i|[101]*(n+1)}\nn.times{f,_,*t=g;t.map{|i|w[f][i]=1}}\nn.times{|k|k+=1;n.times{|i|i+=1;n.times{|j|j+=1;(a=w[i][k]+w[k][j])<w[i][j]&&w[i][j]=a}}}\ng[0].times{s,d,v=g;c=w[s][d]+1;puts c>v ?:NA:c}"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nhash = Hash.new\n\nclass Node\n    attr_accessor :no\n    attr_accessor :children\nend\n\nN.times do\n    info = gets.chomp.split(\" \").map(&:to_i)\n    no = info.shift\n    child_size = info.shift\n    node = Node.new\n    node.no = no\n    node.children = info\n    hash[no] = node\nend\n\nhash.values.each do |node|\n    node.children = node.children.map {|i| hash[i] } \nend\n\nmemo = {}\n\nP = gets.to_i\nP.times do\n    s,d,v=gets.chomp.split(\" \").map(&:to_i)\n\n    node = hash[s]\n    if node != nil && memo[node.no] == nil\n        memo[node.no] = {}\n        memo[node.no][node.no] = 1\n        nexts = [node]\n        distance = 2\n        while !nexts.empty?\n            nexts = nexts.map {|e| e.children }.flatten.uniq\n\n            nexts_pre = []\n            nexts.each do |next_node|\n                if memo[node.no][next_node.no] == nil\n                    memo[node.no][next_node.no] = distance\n                    nexts_pre.push(next_node)\n                end\n            end\n            nexts = nexts_pre\n            distance += 1\n        end\n    end\n\n    distance = memo.dig(s, d)\n    if distance == nil || distance > v\n        puts \"NA\"\n    else\n        puts distance\n    end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.each{|k|r.each{|i|r.each{|j|(a=(b=w[i])[k]+w[k][j])<b[j]&&b[j]=a}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nconst INF = 1<<31\n\nfunc main() {\n\tscanner.Scan()\n\tn, _ := strconv.Atoi(scanner.Text())\n\tarr := make([][]int, n)\n\tfor i := range arr {\n\t\tarr[i] = make([]int, n)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tarr[i][j] = INF\n\t\t}\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tscanner.Scan()\n\t\tbuf := strings.Split(scanner.Text(), \" \")\n\t\tinput := make([]int, len(buf))\n\t\tfor j := range input {\n\t\t\tinput[j], _ = strconv.Atoi(buf[j])\n\t\t}\n\t\tx, k := input[0]-1, input[1]\n\t\tfor j := 0; j < k; j++ {\n\t\t\ty := input[j+2]-1\n\t\t\tarr[x][y] = 1\n\t\t}\n\t}\n\tfor k := 0; k < n; k++ {\n\t\tarr[k][k] = 0\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif arr[i][k] >= INF {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor j := 0; j < n; j++ {\n\t\t\t\tif arr[k][j] >= INF {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tarr[i][j] = min(arr[i][j], arr[i][k]+arr[k][j])\n\t\t\t}\n\t\t}\n\t}\n\tscanner.Scan()\n\tp, _ := strconv.Atoi(scanner.Text())\n\tfor i := 0; i < p; i++ {\n\t\tscanner.Scan()\n\t\tbuf := strings.Split(scanner.Text(), \" \")\n\t\tinput := make([]int, len(buf))\n\t\tfor j := range input {\n\t\t\tinput[j], _ = strconv.Atoi(buf[j])\n\t\t}\n\t\ts, d, v := input[0]-1, input[1]-1, input[2]\n\t\tif arr[s][d] < v {\n\t\t\tfmt.Println(arr[s][d]+1)\n\t\t} else {\n\t\t\tfmt.Println(\"NA\")\n\t\t}\n\t}\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\n\nconst int V = 111;\nint cost[V][V];\n\nvoid main(){\n\tint n, r, t, s, d, v, p, ans;\n\tstring[] str;\n\treadf(\"%d\\n\", &n);\n\tfor (int i = 0; i < V; i++) {\n\t\tcost[i][] = 999999999;\n\t\tcost[i][i] = 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tstr = split(readln());\n\t\tr = to!int(str[0]);\n\t\tfor (int j = 2; j < str.length; j++) {\n\t\t\tt = to!int(str[j]);\n\t\t\tcost[r][t] = 1;\n\t\t}\n\t}\n\n\twarshall_floyd();\n\n\treadf(\"%d\\n\", &p);\n\tfor (int i = 0; i < p; i++) {\n\t\treadf(\"%d %d %d\\n\", &s, &d, &v);\n\t\tans = cost[s][d] + 1;\n\t\tif (ans > v) writeln(\"NA\");\n\t\telse writeln(ans);\n\t}\n}\n\nvoid warshall_floyd(){\n\tfor (int k = 0; k < V; k++)\n\t\tfor (int i = 0; i < V; i++)\n\t\t\tfor (int j = 0; j < V; j++)\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nvoid main(){\n    auto n = readInt();\n    auto m = new long[][](n, n);\n    const long inf = long.max/n;\n    foreach(i; iota(n)) {\n        foreach(j; iota(n)) {\n            m[i][j] = inf;\n        }\n        m[i][i] = 0;\n    }\n    foreach(i; iota(n)) {\n        auto l = readInts();\n        auto r = l[0];\n        auto k = l[1];\n        auto t = l[2..$];\n        foreach(j; iota(k)) {\n            m[r-1][t[j]-1] = 1;\n        }\n    }\n    foreach(i; iota(n)) {\n        foreach(j; iota(n)) {\n            foreach(k; iota(n)) {\n                m[j][k] = min(m[j][k], m[j][i] + m[i][k]);\n            }\n        }\n    }\n    auto p = readLong();\n    foreach(i; iota(p)) {\n        int s, d, v;\n        readlnTo(s, d, v);\n        auto u = m[s-1][d-1] + 1;\n        writeln(u <= v ? u.to!string: \"NA\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "\nimport std.stdio, std.typecons, std.array, std.conv;\n\nalias Tuple!(int, \"id\", int, \"hop\") Node;\n\nvoid main() {\n  int number, n; readf(\"%d\\n\", &number);\n  int[][int] edges;\n  foreach(i; 0..number) {\n    int from, k;\n    scanf(\"%d %d\", &from, &k);\n    foreach(j; 0..k) {\n      int to;\n      scanf(j == k - 1 ? \"%d\\n\" : \"%d \", &to);\n      edges[from] ~= to;\n    }\n    if (k == 0) edges[from] = [];\n  }\n  scanf(\"%d\\n\", &n);\n  foreach(i; 0..n) {\n    int to, from, ttl, ans = -1;\n    Node[] queue;\n    int[] used = new int[](number + 1);\n    scanf(\"%d %d %d\", &from, &to, &ttl);\n    queue ~= Node(from, 1);\n    used[from] = true; \n    while(!queue.empty) {\n      Node node = queue.front;\n      if (node.id == to) {ans = node.hop; break;}\n      queue.popFront;\n      foreach(j; edges[node.id]) {\n        if (!used[j]) {\n          queue ~= Node(j, node.hop + 1);\n          used[j] = true;\n        }\n      }\n    }\n    writeln((ans == -1 || ans > ttl) ? \"NA\" : ans.to!string);\n  }\n}"
  },
  {
    "language": "Python",
    "code": "# AOJ 0144 Packet Transportation\n# Python3 2018.6.23 bal4u\n\nINF = 0x7fffffff\nn = int(input())\narr = [[INF for j in range(n)] for i in range(n)]\nfor i in range(n):\n\ta = list(map(int, input().split()))\n\tx, k = a[0]-1, a[1]\n\tfor j in range(k):\n\t\ty = a[j+2]-1\n\t\tarr[x][y] = 1\nfor k in range(n):\n\tarr[k][k] = 0\n\tfor i in range(n):\n\t\tif arr[i][k] >= INF: continue\n\t\tfor j in range(n):\n\t\t\tif arr[k][j] >= INF: continue\n\t\t\tarr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j])\np = int(input())\nfor i in range(p):\n\ts, d, v = map(int, input().split())\n\ts,d = s-1, d-1\n\tprint(arr[s][d]+1 if arr[s][d] < v else \"NA\")\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\n\n\nclass Graph(object):\n    \"\"\" single source shortest path \"\"\"\n    class Status(Enum):\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n        white = 1  # ????¨????\n        gray = 2  # ?¨???????\n        black = 3  #?¨???????\n\n    def __init__(self, n, data):\n        num_of_nodes = n+1\n        self.color = [Graph.Status.white] * num_of_nodes  # ????????????????¨??????¶???\n        self.M = [[float('inf')] * num_of_nodes for _ in range(num_of_nodes)]\n        for i in range(num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)  # data????????????????????£??\\??????(?????\\?¶???¨???????????????????????§????????????)\n        self.d = [float('inf')] * num_of_nodes  # ?§???????????????????(?????????)\n        self.p = [-1] * num_of_nodes  # ????????????????????????????¨?????????????????????????\n\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            # ??\\??????????????§??????????????¨?????????????????????u???????????????\n            for i in range(len(self.d)):\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????±???????????????????S??¨??\\?¶?????????????????????????????????????????°???????????????????\n                    mincost = self.d[i]\n                    u = i  # u??????????????????ID\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black  # ?????????u???S????±???????????????´???\n            for v in range(len(self.d)):\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n                    # v????????????????????????????????°??????S???????????£???u????????????????????????????????????????????°??????????????±??§??´??°??????\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n\n\ndef main(args):\n    n = int(input())\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n\n    packets = []\n    p = int(input())\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n\n\n\n    memo = [[0]*(n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        g = Graph(n, network)\n        g.dijkstra(i)\n        for j in range(1, n+1):\n            if i == j:\n                continue\n            if g.d[j] == float('inf'):\n                memo[i][j] = float('inf')\n            else:\n                path = [j]\n                u = j\n                while g.p[u] != i:\n                    path.append(g.p[u])\n                    u = g.p[u]\n                path.append(i)\n                memo[i][j] = len(path)\n\n\n    for s, d, v in packets:\n        if memo[s][d] <= v:\n            print(memo[s][d])\n        else:\n            print('NA')\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "n = input()\nE0 = {}\nV = set()\nfor i in xrange(n):\n    ipt = map(int, raw_input().split())\n    r = ipt[0]; k = ipt[1]; T = ipt[2:]\n    E0[r] = T\n    V.add(r)\nE = {v: {} for v in V}\nfor v in V:\n    for t in E0[v]:\n        E[v][t] = 1\nMAX = 10**18\nfor k in V:\n    for i in V:\n        for j in V:\n            if k in E[i] and j in E[k]:\n                E[i][j] = min(E[i].get(j, MAX), E[i][k] + E[k][j])\np = input()\nfor i in xrange(p):\n    s, d, v = map(int, raw_input().split())\n    print \"NA\"*(v <= E[s].get(d, MAX))or E[s][d]+1"
  },
  {
    "language": "Python",
    "code": "inf = 2**31\n\nn = int(raw_input())\nG = [[inf]*n for _ in range(n)]\nref = {}\ninputs = [map(int,raw_input().split()) for _ in range(n)]\nfor i in range(n): ref[inputs[i][0]] = i\nfor i in range(n):\n    for j in inputs[i][2:]:\n        G[i][ref[j]] = 1\n        \nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            G[i][j] = min(G[i][j],G[i][k]+G[k][j])\n            \np = int(raw_input())\nfor loop in range(p):\n    s,d,v = map(int,raw_input().split())\n    dist = G[ref[s]][ref[d]]\n    print dist+1 if dist+1 <= v else \"NA\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nn = int(input())\nrlst = [None] * (n + 1)\nfor _ in range(n):\n  lst = list(map(int, input().split()))\n  r = lst[0]\n  lst = lst[2:]\n  rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n  s, d, v = map(int, input().split())\n  visited = [False] * (n + 1)\n  visited[s] = True\n  que = deque()\n  que.append((s, 1))\n  while que:\n    node, dist = que.pop()\n    if node == d:\n      print(dist)\n      break\n    if dist < v:\n      for to in rlst[node]:\n        if not visited[to]:\n          que.append((to, dist + 1))\n  else:\n    print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nn=int(raw_input())\nr=[map(int,raw_input().split()) for _ in xrange(n)]\nm=int(raw_input())\npa=[map(int,raw_input().split()) for _ in xrange(m)]\nfor i in xrange(m):\n    d=[1]*n\n    q=deque([pa[i][0]])\n    used=[False]*n\n    used[pa[i][0]-1]=True\n    while len(q)!=0:\n        f=0\n        p=q.popleft()\n        p-=1\n        if d[p]==pa[i][2]:break\n        for j in r[p][2:]:\n            j-=1\n            if pa[i][1]-1==j:\n                f=1\n                d[j]+=d[p]\n                break\n            if used[r[j][0]-1]:continue\n            q.append(j+1)\n            d[j]=d[p]+1\n            used[j]=True\n        if f==1:\n            break\n    if f==1:\n        print(d[j])\n    else:\n        print(\"NA\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nn=input()\nr=[map(int,raw_input().split()) for _ in xrange(n)]\nm=input()\npa=[map(int,raw_input().split()) for _ in xrange(m)]\nfor i in xrange(m):\n    d=[1]*n\n    q=deque([pa[i][0]])\n    used=[False]*n\n    used[pa[i][0]-1]=True\n    while len(q)!=0:\n        f=0\n        p=q.popleft()\n        p-=1\n        if d[p]==pa[i][2]:continue\n        for j in r[p][2:]:\n            j-=1\n            if pa[i][1]-1==j:\n                f=1\n                d[j]+=d[p]\n                break\n            if used[r[j][0]-1]:continue\n            q.append(j+1)\n            d[j]=d[p]+1\n            used[j]=True\n        if f==1:\n            break\n    if f==1:\n        print(d[j])\n    else:\n        print(\"NA\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nn = int(input())\nrlst = [None] * (n + 1)\n#print(rlst)\nfor _ in range(n):\n  lst = list(map(int, input().split()))\n  r = lst[0]\n  print(r)\n  lst = lst[2:]\n  rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n  s, d, v = map(int, input().split())\n  visited = [False] * (n + 1)\n  visited[s] = True\n  que = deque()\n  que.append((s, 1))\n  while que:\n    node, dist = que.pop()\n    if node == d:\n      print(dist)\n      break\n    if dist < v:\n      for to in rlst[node]:\n        if not visited[to]:\n          que.append((to, dist + 1))\n  else:\n    print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nn = int(input())\nrlst = [None] * (n + 1)\nfor _ in range(n):\n  lst = list(map(int, input().split()))\n  r = lst[0]\n  lst = lst[2:]\n  rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n  s, d, v = map(int, input().split())\n  visited = [False] * (n + 1)\n  visited[s] = True\n  que = deque()\n  que.append((s, 0))\n  while que:\n    node, dist = que.pop()\n    if node == d:\n      print(dist + 1)\n      break\n    if dist < v - 1:\n      for to in rlst[node]:\n        if not visited[to]:\n          que.append((to, dist + 1))\n  else:\n    print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "def f1(r, g, ttl, c, res):\n    global max_c\n    c += 1\n    if r == g:\n        max_c = c\n        return True\n    ttl -= 1\n    if ttl == 0:\n        return\n    elif max_c is not None and c >= max_c-1:\n        return\n    elif r in res:\n        return\n    else:\n        res.append(r)\n        for r in dic[r]:\n            if f1(r, g, ttl, c, res[:]):\n                return\n\ndic = {}\nfor i in range(input()):\n    line = map(int, raw_input().split())\n    dic[line[0]] = line[2:]\n\nfor i in range(input()):\n    s, g, ttl = map(int, raw_input().split())\n    max_c = None\n    f1(s, g, ttl, 0, [])\n    if max_c:\n        print max_c\n    else:\n        print 'NA'"
  },
  {
    "language": "Python",
    "code": "def solve(A):\n  s,d,v = A\n  C = [-1 for _ in [0]*(n+1)]\n  c = 1\n  C[s] = c\n  SP = M[s]\n  while 1:\n    if SP==[]: return \"NA\"\n    c += 1\n    X = []\n    for p in SP:\n      if C[p]>0: continue\n      C[p] = c\n      for e in M[p]:\n        if C[e]<0 and e not in SP: X.append(e)\n      if p==d:\n        if C[p]>v: return \"NA\"\n        else: return C[p]\n    SP = X\n\nn = int(raw_input())\nM = {}\n\nfor _ in [0]*n:\n  x = map(int, raw_input().split())\n  M[x[0]]=x[2:]\nfor _ in [0]*int(raw_input()):\n  print solve(map(int,raw_input().split()))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\n\n\nclass Graph(object):\n    \"\"\" single source shortest path \"\"\"\n    class Status(Enum):\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n        white = 1  # ????¨????\n        gray = 2  # ?¨???????\n        black = 3  #?¨???????\n\n    def __init__(self, n, data):\n        self.num_of_nodes = n+1\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????¨??????¶???\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)  # data????????????????????£??\\??????(?????\\?¶???¨???????????????????????§????????????)\n        self.d = [float('inf')] * self.num_of_nodes  # ?§???????????????????(?????????)\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????¨?????????????????????????\n\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            # ??\\??????????????§??????????????¨?????????????????????u???????????????\n            for i in range(len(self.d)):\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????±???????????????????S??¨??\\?¶?????????????????????????????????????????°???????????????????\n                    mincost = self.d[i]\n                    u = i  # u??????????????????ID\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black  # ?????????u???S????±???????????????´???\n            for v in range(len(self.d)):\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n                    # v????????????????????????????????°??????S???????????£???u????????????????????????????????????????????°??????????????±??§??´??°??????\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n\n    def warshallFloyd(self):\n        for k in range(self.num_of_nodes):\n            for i in range(self.num_of_nodes):\n                for j in range(self.num_of_nodes):\n                    if self.M[i][k] + self.M[k][j] < self.M[i][j]: \n                        self.M[i][j] = self.M[i][k] + self.M[k][j]\n\n\ndef main(args):\n    n = int(input())\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n\n    packets = []\n    p = int(input())\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n\n    g = Graph(n, network)\n    g.warshallFloyd()\n\n    for s, d, v in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d]+1)\n        else:\n            print('NA')\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def solve(A):\n  s,d,v = A\n  C = [-1 for _ in [0]*(n+1)]\n  c = 1\n  C[s] = c\n  SP = M[s]\n  while 1:\n    if SP==[]: return \"NA\"\n    c += 1\n    X = []\n    for p in SP:\n      if C[p]>0: continue\n      C[p] = c\n      X += [e for e in M[p] if C[e]<0 and e not in SP]\n      if p==d: return [C[d],\"NA\"][C[p]>v]\n    SP = X\n\nn = int(raw_input())\nM = {}\n\nfor _ in [0]*n:\n  x = map(int, raw_input().split())\n  M[x[0]] = x[2:]\nfor _ in [0]*int(raw_input()):\n  print solve(map(int,raw_input().split()))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\n\n\nclass Graph(object):\n    \"\"\" single source shortest path \"\"\"\n    class Status(Enum):\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n        white = 1  # ????¨????\n        gray = 2  # ?¨???????\n        black = 3  #?¨???????\n\n    def __init__(self, n, data):\n        self.num_of_nodes = n+1\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????¨??????¶???\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n        for i in range(self.num_of_nodes):\n            self.M[i][i] = 0\n        self._make_matrix(data)  # data????????????????????£??\\??????(?????\\?¶???¨???????????????????????§????????????)\n        self.d = [float('inf')] * self.num_of_nodes  # ?§???????????????????(?????????)\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????¨?????????????????????????\n\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            # ??\\??????????????§??????????????¨?????????????????????u???????????????\n            for i in range(len(self.d)):\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????±???????????????????S??¨??\\?¶?????????????????????????????????????????°???????????????????\n                    mincost = self.d[i]\n                    u = i  # u??????????????????ID\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black  # ?????????u???S????±???????????????´???\n            for v in range(len(self.d)):\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n                    # v????????????????????????????????°??????S???????????£???u????????????????????????????????????????????°??????????????±??§??´??°??????\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n\n    def warshallFloyd(self):\n        V = self.num_of_nodes\n        for k in range(V):\n            for i in range(V):\n                for j in range(V):\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\n\n\n\ndef main(args):\n    n = int(input())\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n\n    packets = []\n    p = int(input())\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n\n    g = Graph(n, network)\n    g.warshallFloyd()\n\n    for s, d, v in packets:\n        if g.M[s][d] < v:\n            print(g.M[s][d]+1)\n        else:\n            print('NA')\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "n=int(raw_input())\ng=[[1000000]*n for _ in xrange(n)]\nfor i in xrange(n):\n    g[i][i]=0\nfor i in xrange(n):\n    r=map(int,raw_input().split())\n    for j in r[2:]:\n        g[r[0]-1][j-1]=1\nfor k in xrange(n):\n    for i in xrange(n):\n        for j in xrange(n):\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j])\nm=int(raw_input())\nfor i in xrange(m):\n    s,d,v=map(int,raw_input().split())\n    s-=1\n    d-=1\n    if g[s][d]<v:\n        print(g[s][d]+1)\n    else:\n        print('NA')"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0144\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom enum import Enum\n\n\nclass Graph(object):\n    \"\"\" single source shortest path \"\"\"\n    class Status(Enum):\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n        white = 1  # ????¨????\n        gray = 2  # ?¨???????\n        black = 3  #?¨???????\n\n    def __init__(self, n, data):\n        num_of_nodes = n+1\n        self.color = [Graph.Status.white] * num_of_nodes  # ????????????????¨??????¶???\n        self.M = [[float('inf')] * num_of_nodes for _ in range(num_of_nodes)]\n        self._make_matrix(data)  # data????????????????????£??\\??????(?????\\?¶???¨???????????????????????§????????????)\n        self.d = [float('inf')] * num_of_nodes  # ?§???????????????????(?????????)\n        self.p = [-1] * num_of_nodes  # ????????????????????????????¨?????????????????????????\n\n    def _make_matrix(self, data):\n        for d in data:\n            r = d[0]\n            for t in d[2:]:\n                self.M[r][t] = 1\n\n    def dijkstra(self, start):\n        self.d[start] = 0\n        self.p[start] = -1\n        while True:\n            mincost = float('inf')\n            # ??\\??????????????§??????????????¨?????????????????????u???????????????\n            for i in range(len(self.d)):\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????±???????????????????S??¨??\\?¶?????????????????????????????????????????°???????????????????\n                    mincost = self.d[i]\n                    u = i  # u??????????????????ID\n            if mincost == float('inf'):\n                break\n            self.color[u] = Graph.Status.black  # ?????????u???S????±???????????????´???\n            for v in range(len(self.d)):\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n                    # v????????????????????????????????°??????S???????????£???u????????????????????????????????????????????°??????????????±??§??´??°??????\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n                        self.d[v] = self.d[u] + self.M[u][v]\n                        self.p[v] = u\n                        self.color[v] = Graph.Status.gray\n\n\ndef main(args):\n    n = int(input())\n    network = []\n    for _ in range(n):\n        network.append([int(x) for x in input().split()])\n\n    packets = []\n    p = int(input())\n    for _ in range(p):\n        packets.append([int(x) for x in input().split()])\n\n    for s, d, v in packets:\n        g = Graph(n, network)\n        g.dijkstra(s)\n        path = [d]\n        u = d\n        while g.p[u] != s:\n            path.append(g.p[u])\n            u = g.p[u]\n        path.append(s)\n\n        if len(path) > v:\n            print('NA')\n        else:\n            print(len(path))\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "\"\"\"\ndef find(s,p,g,box,cost):\n    for i in rooter[p]:\n        if i==g:box.append(cost+1)\n        elif i==s:continue\n        else:find(s,i,g,box,cost+1)\n    return box\nrooter={}\nfor i in range(int(input())):\n    N=list(map(int,input().split()))\n    box=[]\n    for j in N[2:]:box.append(j)\n    rooter[N[0]]=box\n\nfor i in range(int(input())):\n    s,g,v=map(int,input().split())\n    cost=1\n    box=[]\n    ans=min(find(s,s,g,box,cost))\n    if ans<=v:print(ans)\n    else:print(\"NA\")\n\"\"\"\nfrom collections import deque\n\nn = int(input())\nrlst = [None] * (n + 1)\nfor _ in range(n):\n    lst = list(map(int, input().split()))\n    r = lst[0]\n    lst = lst[2:]\n    rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n    s, d, v = map(int, input().split())\n    visited = [False] * (n + 1)\n    visited[s] = True\n    que = deque()\n    que.append((s, 0))\n    while que:\n        node, dist = que.popleft()\n        if node == d:\n            if dist < v:\n                print(dist + 1)\n            else:\n                print(\"NA\")\n            break\n        for to in rlst[node]:\n            if not visited[to]:\n                que.append((to, dist + 1))\n                visited[to] = True\n    else:\n        print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nn = int(input())\nrlst = [None] * (n + 1)\nfor _ in range(n):\n  lst = list(map(int, input().split()))\n  r = lst[0]\n  lst = lst[2:]\n  rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n  s, d, v = map(int, input().split())\n  visited = [False] * (n + 1)\n  visited[s] = True\n  que = deque()\n  que.append((s, 0))\n  while que:\n    node, dist = que.pop()\n    if node == d:\n      print(dist + 1)\n      break\n    if dist < v - 1:\n      for to in rlst[node]:\n        if not visited[to]:\n          que.append((to, dist + 1))\n          visited[to] = True\n  else:\n    print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "class Graph():\n    from collections import namedtuple\n    __Pair = namedtuple(\"Pair\", \"cost point\")\n\n    def __init__(self, element_count):\n        self.__element_count = element_count\n        self.__adjacency_iist = [[] for _ in range(element_count)]\n\n    def get_path(self, begin_Point, end_point, cost):\n        item = self.__Pair(cost, end_point)\n        self.__adjacency_iist[begin_Point].append(item)\n\n    def dijkstra(self, begin_Point):\n\n        from sys import maxsize as MAX_VALUE\n        from queue import PriorityQueue\n        state_table = {\"NotVisited\": 0, \"Stay\": 1, \"Visited\": 2}\n\n        # 初期化\n        pq = PriorityQueue()\n        cost_table = [MAX_VALUE for _ in range(self.__element_count)]\n        visit_state = [state_table[\"NotVisited\"]\n                       for _ in range(self.__element_count)]\n\n        # 処理\n        cost_table[begin_Point] = 0\n        pq.put_nowait(self.__Pair(0, begin_Point))\n\n        while not pq.empty():\n\n            min_item = pq.get_nowait()\n            min_point, min_cost = min_item.point, min_item.cost\n\n            visit_state[min_point] = state_table[\"Visited\"]\n\n            if min_cost <= cost_table[min_point]:\n\n                for cost, point in self.__adjacency_iist[min_point]:\n                    if visit_state[point] != state_table[\"Visited\"]:\n\n                        if cost_table[min_point] + cost < cost_table[point]:\n                            cost_table[point] = cost_table[min_point] + cost\n                            visit_state[point] = state_table[\"Stay\"]\n                            pq.put_nowait(self.__Pair(cost_table[point], point))\n\n        return cost_table\n\n\nrouter_count = int(input())\n\ngraph = Graph(router_count)\n\nfor _ in range(router_count):\n    data = [int(item) for item in input().split(\" \")]\n    data[0] -= 1\n\n    for lp in range(data[1]):\n        graph.get_path(data[0], data[2 + lp] - 1, 1)\n\nfor _ in range(int(input())):\n\n    sender, destination, ttl = [int(item) for item in input().split(\" \")]\n\n    costs = graph.dijkstra(sender - 1)\n    cost = costs[destination - 1] + 1\n\n    if cost <= ttl:\n        print(cost)\n    else:\n        print(\"NA\")\n\n"
  },
  {
    "language": "Python",
    "code": "n=input()\nINF=1e100000\nR=[[INF]*n for i in range(n)]\nfor i in range(n):\n    connect=map(int,raw_input().split())\n    for i in connect[2:]:\n        R[connect[0]-1][i-1]=1\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            R[i][j]=min(R[i][j],R[i][k]+R[k][j])\np=input()\nfor i in range(p):\n    s1,d1,v1=map(int,raw_input().split())\n    d=R[s1-1][d1-1]+1\n    if v1>=d:\n        print d\n    else:\n        print \"NA\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nn = int(input())\nrlst = [None] * (n + 1)\nfor _ in range(n):\n  lst = list(map(int, input().split()))\n  r = lst[0]\n  lst = lst[2:]\n  rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n  s, d, v = map(int, input().split())\n  visited = [False] * (n + 1)\n  visited[s] = True\n  que = deque()\n  que.append((s, 0))\n  while que:\n    node, dist = que.popleft()\n    if node == d:\n      if dist < v:\n        print(dist + 1)\n      else:\n        print(\"NA\")\n      break\n    for to in rlst[node]:\n      if not visited[to]:\n        que.append((to, dist + 1))\n        visited[to] = True\n  else:\n    print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nn = int(input())\nrlst = [None] * (n + 1)\nfor _ in range(n):\n  lst = list(map(int, input().split()))\n  r = lst[0]\n  lst = lst[2:]\n  rlst[r] = lst\n\np = int(input())\n\nfor _ in range(p):\n  s, d, v = map(int, input().split())\n  visited = [False] * (n + 1)\n  visited[s] = True\n  que = deque()\n  que.append((s, 0))\n  while que:\n    node, dist = que.pop()\n    if node == d:\n      if dist < v:\n        print(dist + 1)\n      else:\n        print(\"NA\")\n      break\n    for to in rlst[node]:\n      if not visited[to]:\n        que.append((to, dist + 1))\n        visited[to] = True\n  else:\n    print(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\n\nn=int(input())\nrouter={}\nfor _ in range(n):\n    t=[int(i) for i in input().split(\" \")]\n    r=t[0]\n    k=t[1]\n    t=t[2::]\n    router[r]=t\n\ndef transport(s,g):\n    distance=[10**10 for i in range(n+1)]\n    distance[s]=0\n    next=[s]\n    for i in range(1,n+1):\n        _next=[]\n        for j in next:\n            _next+=router[j]\n        next=list(set(_next))\n        for j in next:\n            distance[j]=min(i,distance[j])\n    return distance[g]+1\n\n\n\np=int(input())\nfor _ in range(p):\n    s,d,v=[int(i) for i in input().split(\" \")]\n    t=transport(s,d)\n    if t<=v:\n        print(t)\n    else:\n        print(\"NA\")\n\n"
  },
  {
    "language": "Rust",
    "code": "fn main(){\n  let n: usize = read();\n  let inf: usize = 100000;\n  let mut rv: Vec<Vec<usize>> = vec![vec![inf;n];n];\n  \n  for _ in 0 .. n {\n    let rkt: Vec<usize> = read_vec();\n    let r = rkt[0] - 1;\n    for t in rkt.iter().skip(2) {\n      rv[r][t-1] = 1;\n    }\n  }\n\n  for k in 0 .. n {\n    for i in 0 .. n {\n      for j in 0 .. n {\n        if rv[i][j] > rv[i][k] + rv[k][j] {\n          rv[i][j] = rv[i][k] + rv[k][j];\n        }\n      }\n    }\n  }\n\n  let p: usize = read();\n\n  for _ in 0 .. p {\n    let sdv: Vec<usize> = read_vec();\n    let s = sdv[0] - 1;\n    let d = sdv[1] - 1;\n    let v = sdv[2];\n\n    if v > rv[s][d] {\n      println!(\"{}\", rv[s][d] + 1);\n    } else {\n      println!(\"NA\");\n    }\n\n  }\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  }
]