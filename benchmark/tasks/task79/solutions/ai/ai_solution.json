[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int* edges;\n    int edge_count;\n} Router;\n\ntypedef struct {\n    int front, rear, size;\n    unsigned capacity;\n    int* array;\n} Queue;\n\nQueue* createQueue(unsigned capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->capacity = capacity;\n    queue->front = queue->size = 0;\n    queue->rear = capacity - 1;\n    queue->array = (int*)malloc(queue->capacity * sizeof(int));\n    return queue;\n}\n\nint isFull(Queue* queue) {\n    return (queue->size == queue->capacity);\n}\n\nint isEmpty(Queue* queue) {\n    return (queue->size == 0);\n}\n\nvoid enqueue(Queue* queue, int item) {\n    if (isFull(queue))\n        return;\n    queue->rear = (queue->rear + 1) % queue->capacity;\n    queue->array[queue->rear] = item;\n    queue->size++;\n}\n\nint dequeue(Queue* queue) {\n    if (isEmpty(queue))\n        return -1;\n    int item = queue->array[queue->front];\n    queue->front = (queue->front + 1) % queue->capacity;\n    queue->size--;\n    return item;\n}\n\nint BFS(Router* routers, int src, int dest, int router_count) {\n    int* distances = (int*)malloc(router_count * sizeof(int));\n    for (int i = 0; i < router_count; i++)\n        distances[i] = -1;\n    distances[src] = 0;\n\n    Queue* queue = createQueue(router_count);\n    enqueue(queue, src);\n\n    while (!isEmpty(queue)) {\n        int current = dequeue(queue);\n        for (int i = 0; i < routers[current].edge_count; i++) {\n            int neighbor = routers[current].edges[i];\n            if (distances[neighbor] == -1) {\n                distances[neighbor] = distances[current] + 1;\n                enqueue(queue, neighbor);\n                if (neighbor == dest) {\n                    free(queue->array);\n                    free(queue);\n                    int result = distances[dest];\n                    free(distances);\n                    return result;\n                }\n            }\n        }\n    }\n    free(queue->array);\n    free(queue);\n    free(distances);\n    return -1;\n}\n\nint main() {\n    int router_count, connection_count, packet_count;\n    scanf(\"%d %d %d\", &router_count, &connection_count, &packet_count);\n\n    Router* routers = (Router*)malloc(router_count * sizeof(Router));\n    for (int i = 0; i < router_count; i++) {\n        routers[i].edges = NULL;\n        routers[i].edge_count = 0;\n    }\n\n    for (int i = 0; i < connection_count; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        routers[a].edge_count++;\n        routers[a].edges = (int*)realloc(routers[a].edges, routers[a].edge_count * sizeof(int));\n        routers[a].edges[routers[a].edge_count - 1] = b;\n    }\n\n    for (int i = 0; i < packet_count; i++) {\n        int src, dest;\n        scanf(\"%d %d\", &src, &dest);\n        if (src == dest) {\n            printf(\"0\\n\");\n            continue;\n        }\n        int hops = BFS(routers, src, dest, router_count);\n        if (hops == -1)\n            printf(\"NA\\n\");\n        else\n            printf(\"%d\\n\", hops);\n    }\n\n    for (int i = 0; i < router_count; i++) {\n        free(routers[i].edges);\n    }\n    free(routers);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:29:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RouterNetwork {\n    public static int findShortestPath(int[][] connections, int source, int destination, int ttl) {\n        int n = connections.length;\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            graph.put(i, new ArrayList<>());\n            for (int j = 0; j < connections[i].length; j++) {\n                if (connections[i][j] == 1) {\n                    graph.get(i).add(j);\n                }\n            }\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        Set<Integer> visited = new HashSet<>();\n        queue.offer(new int[]{source, 0, ttl});\n        visited.add(source);\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int router = current[0];\n            int distance = current[1];\n            int remainingTTL = current[2];\n            \n            if (router == destination) {\n                return distance;\n            }\n            \n            if (remainingTTL <= 0) {\n                continue;\n            }\n            \n            for (int neighbor : graph.get(router)) {\n                if (!visited.contains(neighbor)) {\n                    queue.offer(new int[]{neighbor, distance + 1, remainingTTL - 1});\n                    visited.add(neighbor);\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        int[][] connections = {\n            {0, 1, 0, 0},\n            {1, 0, 1, 1},\n            {0, 1, 0, 1},\n            {0, 1, 1, 0}\n        };\n        int source = 0;\n        int destination = 3;\n        int ttl = 3;\n        \n        int result = findShortestPath(connections, source, destination, ttl);\n        \n        if (result == -1) {\n            System.out.println(\"NA\");\n        } else {\n            System.out.println(result);\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:29:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    unordered_map<int, vector<int>> graph;\n    \n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n    }\n    \n    int P;\n    cin >> P;\n    \n    for (int i = 0; i < P; ++i) {\n        int s, d;\n        cin >> s >> d;\n        \n        if (s == d) {\n            cout << 0 << endl;\n            continue;\n        }\n        \n        queue<pair<int, int>> q;\n        unordered_map<int, bool> visited;\n        q.push({s, 0});\n        visited[s] = true;\n        int result = -1;\n        \n        while (!q.empty()) {\n            auto current = q.front();\n            q.pop();\n            \n            for (int neighbor : graph[current.first]) {\n                if (neighbor == d) {\n                    result = current.second + 1;\n                    while (!q.empty()) q.pop();\n                    break;\n                }\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push({neighbor, current.second + 1});\n                }\n            }\n            if (result != -1) break;\n        }\n        \n        if (result != -1) {\n            cout << result << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:30:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_ROUTERS 1001\n\nint graph[MAX_ROUTERS][MAX_ROUTERS];\nint visited[MAX_ROUTERS];\nint n;\n\nint bfs(int start, int end) {\n    int queue[MAX_ROUTERS];\n    int dist[MAX_ROUTERS];\n    int front = 0, rear = 0;\n\n    memset(visited, 0, sizeof(visited));\n    memset(dist, 0x3f, sizeof(dist));\n\n    queue[rear++] = start;\n    dist[start] = 0;\n    visited[start] = 1;\n\n    while (front < rear) {\n        int current = queue[front++];\n\n        if (current == end) return dist[end];\n\n        for (int next = 1; next <= n; next++) {\n            if (graph[current][next] && !visited[next]) {\n                queue[rear++] = next;\n                visited[next] = 1;\n                dist[next] = dist[current] + 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    memset(graph, 0, sizeof(graph));\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = 1;\n    }\n\n    for (int i = 0; i < k; i++) {\n        int start, end, ttl;\n        scanf(\"%d %d %d\", &start, &end, &ttl);\n\n        int min_routers = bfs(start, end);\n\n        if (min_routers == -1 || min_routers > ttl) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", min_routers);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:30:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <climits>\nusing namespace std;\n\nclass Solution {\npublic:\n    string findShortestPath(int n, vector<vector<int>>& connections, int source, int destination, int ttl) {\n        unordered_map<int, vector<int>> graph;\n        for (const auto& conn : connections) {\n            graph[conn[0]].push_back(conn[1]);\n        }\n        \n        queue<pair<int, int>> q;\n        q.push({source, ttl});\n        \n        unordered_map<int, int> visited;\n        visited[source] = 0;\n        \n        while (!q.empty()) {\n            int current = q.front().first;\n            int remainingTTL = q.front().second;\n            q.pop();\n            \n            if (current == destination) {\n                return to_string(visited[current]);\n            }\n            \n            if (remainingTTL == 0) continue;\n            \n            for (int neighbor : graph[current]) {\n                if (visited.count(neighbor) == 0 || visited[current] + 1 < visited[neighbor]) {\n                    visited[neighbor] = visited[current] + 1;\n                    q.push({neighbor, remainingTTL - 1});\n                }\n            }\n        }\n        \n        return \"NA\";\n    }\n};\n\nint main() {\n    int n, m, source, destination, ttl;\n    cin >> n >> m;\n    \n    vector<vector<int>> connections(m, vector<int>(2));\n    for (int i = 0; i < m; i++) {\n        cin >> connections[i][0] >> connections[i][1];\n    }\n    \n    cin >> source >> destination >> ttl;\n    \n    Solution sol;\n    cout << sol.findShortestPath(n, connections, source, destination, ttl) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:30:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RouterPath {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.putIfAbsent(u, new ArrayList<>());\n            graph.get(u).add(v);\n        }\n        \n        int P = scanner.nextInt();\n        for (int i = 0; i < P; i++) {\n            int src = scanner.nextInt();\n            int dest = scanner.nextInt();\n            int ttl = scanner.nextInt();\n            \n            int result = bfs(graph, src, dest, ttl);\n            if (result == -1) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(result);\n            }\n        }\n    }\n    \n    private static int bfs(Map<Integer, List<Integer>> graph, int src, int dest, int ttl) {\n        if (src == dest) return 0;\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{src, 0});\n        Set<Integer> visited = new HashSet<>();\n        visited.add(src);\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int node = current[0];\n            int hops = current[1];\n            \n            if (hops >= ttl) continue;\n            \n            if (!graph.containsKey(node)) continue;\n            \n            for (int neighbor : graph.get(node)) {\n                if (neighbor == dest) {\n                    return hops + 1;\n                }\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.add(new int[]{neighbor, hops + 1});\n                }\n            }\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 18:33:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque, defaultdict\n\ndef min_routers_to_destination(router_connections, packets):\n    def bfs_min_routes(source, destination):\n        if source == destination:\n            return 0\n        \n        visited = set()\n        queue = deque([(source, 0)])\n        \n        while queue:\n            router, steps = queue.popleft()\n            \n            if router in visited:\n                continue\n            \n            visited.add(router)\n            \n            for neighbor in router_connections[router]:\n                if neighbor == destination:\n                    return steps + 1\n                if neighbor not in visited:\n                    queue.append((neighbor, steps + 1))\n        \n        return 'NA'\n    \n    results = []\n    for source, destination in packets:\n        results.append(bfs_min_routes(source, destination))\n    \n    return results\n\n# Example Usage\n# Define router connections (adjacency list)\nrouter_connections = {\n    0: [1, 2],\n    1: [2, 3],\n    2: [3],\n    3: [4],\n    4: []\n}\n\n# Define the packets as tuples of (source, destination)\npackets = [\n    (0, 3),  # From router 0 to router 3\n    (1, 4),  # From router 1 to router 4\n    (0, 2),  # From router 0 to router 2\n    (2, 0),  # From router 2 to router 0, unreachable\n]\n\n# Call the function and print results\nresults = min_routers_to_destination(router_connections, packets)\nprint(results)  # Output: [2, 2, 1, 'NA']",
    "timestamp": "2025-08-12 23:27:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class NetworkRouter {\n    \n    static class Packet {\n        int source;\n        int destination;\n\n        Packet(int source, int destination) {\n            this.source = source;\n            this.destination = destination;\n        }\n    }\n\n    public static Map<Integer, List<Integer>> buildGraph(int[][] connections) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] connection : connections) {\n            graph.putIfAbsent(connection[0], new ArrayList<>());\n            graph.get(connection[0]).add(connection[1]);\n        }\n        return graph;\n    }\n\n    public static int findMinRouters(Map<Integer, List<Integer>> graph, int source, int destination) {\n        if (source == destination) return 0;\n        \n        Queue<int[]> queue = new LinkedList<>();\n        Set<Integer> visited = new HashSet<>();\n        \n        queue.offer(new int[] {source, 0});\n        visited.add(source);\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int currentRouter = current[0];\n            int depth = current[1];\n\n            for (int neighbor : graph.getOrDefault(currentRouter, Collections.emptyList())) {\n                if (neighbor == destination) {\n                    return depth + 1;\n                }\n\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.offer(new int[] {neighbor, depth + 1});\n                }\n            }\n        }\n        \n        return Integer.MAX_VALUE;\n    }\n\n    public static List<String> routePackets(int[][] connections, Packet[] packets) {\n        Map<Integer, List<Integer>> graph = buildGraph(connections);\n        List<String> result = new ArrayList<>();\n\n        for (Packet packet : packets) {\n            int minRouters = findMinRouters(graph, packet.source, packet.destination);\n            if (minRouters == Integer.MAX_VALUE) {\n                result.add(\"NA\");\n            } else {\n                result.add(String.valueOf(minRouters));\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[][] connections = {{1, 2}, {2, 3}, {1, 3}, {3, 4}, {4, 5}, {5, 6}};\n        Packet[] packets = {new Packet(1, 4), new Packet(2, 6), new Packet(3, 1), new Packet(5, 6)};\n        \n        List<String> results = routePackets(connections, packets);\n        for (String result : results) {\n            System.out.println(result);\n        }\n    }\n}",
    "timestamp": "2025-08-12 23:27:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_ROUTERS 1000\n\ntypedef struct {\n    int connections[MAX_ROUTERS];\n    int count;\n} Router;\n\nvoid findShortestPath(Router network[], int numRouters, int src, int dst, int* result) {\n    int dist[MAX_ROUTERS];\n    int visited[MAX_ROUTERS] = {0};\n    for (int i = 0; i < numRouters; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[src] = 0;\n\n    for (int count = 0; count < numRouters - 1; count++) {\n        int min = INT_MAX, minIndex;\n        for (int v = 0; v < numRouters; v++)\n            if (!visited[v] && dist[v] <= min) {\n                min = dist[v];\n                minIndex = v;\n            }\n        \n        int u = minIndex;\n        visited[u] = 1;\n\n        for (int i = 0; i < network[u].count; i++) {\n            int neighbor = network[u].connections[i];\n            if (!visited[neighbor] && dist[u] != INT_MAX && dist[u] + 1 < dist[neighbor])\n                dist[neighbor] = dist[u] + 1;\n        }\n    }\n\n    *result = dist[dst] == INT_MAX ? -1 : dist[dst];\n}\n\nint main() {\n    int numRouters, numPackets;\n\n    printf(\"Enter the number of routers: \");\n    scanf(\"%d\", &numRouters);\n\n    Router network[MAX_ROUTERS];\n    for (int i = 0; i < numRouters; i++) {\n        network[i].count = 0;\n    }\n\n    for (int i = 0; i < numRouters; i++) {\n        printf(\"Enter the number of connections for router %d: \", i);\n        scanf(\"%d\", &network[i].count);\n        printf(\"Enter the connected router numbers: \");\n        for (int j = 0; j < network[i].count; j++) {\n            scanf(\"%d\", &network[i].connections[j]);\n        }\n    }\n\n    printf(\"Enter the number of packets: \");\n    scanf(\"%d\", &numPackets);\n\n    for (int p = 0; p < numPackets; p++) {\n        int src, dst;\n        printf(\"Enter source and destination router numbers for packet %d: \", p + 1);\n        scanf(\"%d %d\", &src, &dst);\n\n        int result;\n        findShortestPath(network, numRouters, src, dst, &result);\n\n        if (result == -1)\n            printf(\"Packet %d: NA\\n\", p + 1);\n        else\n            printf(\"Packet %d: %d\\n\", p + 1, result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-12 23:28:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef min_routers_to_destination(n, connections, source, destination, ttl):\n    # Create adjacency list\n    graph = defaultdict(list)\n    for router, connected_routers in enumerate(connections):\n        for connected_router in connected_routers:\n            graph[router].append(connected_router)\n    \n    # BFS to find shortest path\n    queue = deque([(source, 0)])\n    visited = set([source])\n    \n    while queue:\n        current_router, path_length = queue.popleft()\n        \n        # Reached destination\n        if current_router == destination:\n            return path_length\n        \n        # Exceeded TTL\n        if path_length >= ttl:\n            continue\n        \n        # Explore connected routers\n        for next_router in graph[current_router]:\n            if next_router not in visited:\n                visited.add(next_router)\n                queue.append((next_router, path_length + 1))\n    \n    return 'NA'",
    "timestamp": "2025-08-12 23:28:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    \n    adj = {}\n    for _ in range(N):\n        u = data[idx]\n        idx += 1\n        k = int(data[idx])\n        idx += 1\n        neighbors = data[idx:idx + k]\n        idx += k\n        adj[u] = neighbors\n    \n    M = int(data[idx])\n    idx += 1\n    \n    queries = []\n    for _ in range(M):\n        s = data[idx]\n        d = data[idx + 1]\n        ttl = int(data[idx + 2])\n        queries.append((s, d, ttl))\n        idx += 3\n    \n    results = []\n    for s, d, ttl in queries:\n        if s == d:\n            results.append(0)\n            continue\n        \n        visited = {}\n        q = deque()\n        q.append((s, 0))\n        visited[s] = True\n        found = False\n        \n        while q:\n            current, hops = q.popleft()\n            if current == d:\n                results.append(hops)\n                found = True\n                break\n            if hops + 1 > ttl - 1:\n                continue\n            if current in adj:\n                for neighbor in adj[current]:\n                    if neighbor not in visited:\n                        visited[neighbor] = True\n                        q.append((neighbor, hops + 1))\n        \n        if not found:\n            results.append(\"NA\")\n    \n    for res in results:\n        print(res)\n\nsolve()",
    "timestamp": "2025-08-12 23:28:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <climits>\n\nusing namespace std;\n\n// Function to find the minimum number of routers each packet must pass through\nvector<string> findMinRouters(int numRouters, vector<vector<int>>& connections,\n                              int numPackets, vector<pair<int, int>>& packets) {\n    vector<string> results(numPackets, \"NA\");\n    \n    for (int i = 0; i < numPackets; ++i) {\n        int startRouter = packets[i].first;\n        int endRouter = packets[i].second;\n        \n        // A vector to keep track of the minimum distance to each router\n        vector<int> minDistance(numRouters + 1, INT_MAX);\n        minDistance[startRouter] = 0;\n        \n        // BFS queue\n        queue<int> q;\n        q.push(startRouter);\n        \n        while (!q.empty()) {\n            int currentRouter = q.front();\n            q.pop();\n            \n            for (int nextRouter : connections[currentRouter]) {\n                if (minDistance[currentRouter] + 1 < minDistance[nextRouter]) {\n                    minDistance[nextRouter] = minDistance[currentRouter] + 1;\n                    q.push(nextRouter);\n                }\n            }\n        }\n        \n        if (minDistance[endRouter] != INT_MAX) {\n            results[i] = to_string(minDistance[endRouter]);\n        }\n    }\n    \n    return results;\n}\n\nint main() {\n    int numRouters, numConnections;\n    cin >> numRouters >> numConnections;\n    \n    vector<vector<int>> connections(numRouters + 1);\n    \n    for (int i = 0; i < numConnections; ++i) {\n        int from, to;\n        cin >> from >> to;\n        connections[from].push_back(to);\n    }\n    \n    int numPackets;\n    cin >> numPackets;\n    \n    vector<pair<int, int>> packets(numPackets);\n    for (int i = 0; i < numPackets; ++i) {\n        cin >> packets[i].first >> packets[i].second;\n    }\n    \n    vector<string> results = findMinRouters(numRouters, connections, numPackets, packets);\n    \n    for (const string& result : results) {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:50:26"
  }
]