[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_CITIES 100\n\nint n;\nint A[MAX_CITIES][MAX_CITIES];\nint roads[MAX_CITIES][MAX_CITIES];\n\nbool floyd_warshall() {\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (A[i][k] + A[k][j] < A[i][j]) return false;\n                if (A[i][k] + A[k][j] == A[i][j] && i != j) {\n                    roads[i][k] = 1;\n                    roads[k][j] = 1;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint calculate_total_road_length() {\n    int total_length = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (roads[i][j]) {\n                total_length += A[i][j];\n            }\n        }\n    }\n    return total_length;\n}\n\nint solve() {\n    memset(roads, 0, sizeof(roads));\n    \n    if (!floyd_warshall()) return -1;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i != j && A[i][j] == 0) return -1;\n        }\n    }\n    \n    return calculate_total_road_length();\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n    \n    int result = solve();\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int **A = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        A[i] = (int *)malloc(N * sizeof(int));\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n    \n    int possible = 1;\n    long long total = 0;\n    \n    for (int i = 0; i < N && possible; i++) {\n        for (int j = i + 1; j < N && possible; j++) {\n            int needed = 1;\n            for (int k = 0; k < N; k++) {\n                if (k == i || k == j) continue;\n                if (A[i][k] + A[k][j] < A[i][j]) {\n                    possible = 0;\n                    break;\n                } else if (A[i][k] + A[k][j] == A[i][j]) {\n                    needed = 0;\n                }\n            }\n            if (needed) {\n                total += A[i][j];\n            }\n        }\n    }\n    \n    if (!possible) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%lld\\n\", total);\n    }\n    \n    for (int i = 0; i < N; i++) {\n        free(A[i]);\n    }\n    free(A);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> A(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> A[i][j];\n        }\n    }\n\n    long long total = 0;\n    bool possible = true;\n\n    for (int k = 0; k < N && possible; ++k) {\n        for (int i = 0; i < N && possible; ++i) {\n            for (int j = 0; j < N && possible; ++j) {\n                if (A[i][j] > A[i][k] + A[k][j]) {\n                    possible = false;\n                }\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<vector<bool>> needed(N, vector<bool>(N, true));\n    for (int k = 0; k < N; ++k) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (i != j && j != k && i != k && A[i][j] == A[i][k] + A[k][j]) {\n                    needed[i][j] = false;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (needed[i][j]) {\n                total += A[i][j];\n            }\n        }\n    }\n\n    cout << total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] A = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = scanner.nextInt();\n            }\n        }\n\n        long totalLength = 0;\n        boolean possible = true;\n\n        for (int i = 0; i < N && possible; i++) {\n            for (int j = i + 1; j < N && possible; j++) {\n                boolean isNecessary = true;\n                for (int k = 0; k < N; k++) {\n                    if (k == i || k == j) continue;\n                    if (A[i][k] + A[k][j] < A[i][j]) {\n                        possible = false;\n                        break;\n                    } else if (A[i][k] + A[k][j] == A[i][j]) {\n                        isNecessary = false;\n                    }\n                }\n                if (possible && isNecessary) {\n                    totalLength += A[i][j];\n                }\n            }\n        }\n\n        System.out.println(possible ? totalLength : -1);\n    }\n}",
    "timestamp": "2025-08-05 23:15:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RoadNetwork {\n    public static long calculateMinRoadNetwork(int N, int[][] A) {\n        // Check symmetry and diagonal conditions\n        for (int i = 0; i < N; i++) {\n            if (A[i][i] != 0) return -1;\n            for (int j = 0; j < N; j++) {\n                if (A[i][j] != A[j][i]) return -1;\n            }\n        }\n\n        // Floyd-Warshall algorithm to verify shortest paths\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (A[i][j] > A[i][k] + A[k][j]) return -1;\n                }\n            }\n        }\n\n        // Construct minimum spanning tree using Kruskal's algorithm\n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                edges.add(new Edge(i, j, A[i][j]));\n            }\n        }\n        Collections.sort(edges);\n\n        UnionFind uf = new UnionFind(N);\n        long totalRoadLength = 0;\n\n        for (Edge edge : edges) {\n            if (uf.union(edge.u, edge.v)) {\n                totalRoadLength += edge.weight;\n            }\n        }\n\n        return uf.connectedComponents == 1 ? totalRoadLength : -1;\n    }\n\n    static class Edge implements Comparable<Edge> {\n        int u, v, weight;\n        \n        Edge(int u, int v, int weight) {\n            this.u = u;\n            this.v = v;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n\n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n        int connectedComponents;\n\n        UnionFind(int N) {\n            parent = new int[N];\n            rank = new int[N];\n            connectedComponents = N;\n            for (int i = 0; i < N; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n\n            if (rootX == rootY) return false;\n\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            connectedComponents--;\n            return true;\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:16:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long buildRoads(int N, vector<vector<int>>& A) {\n        // Check if the matrix is symmetric and valid\n        for (int i = 0; i < N; i++) {\n            if (A[i][i] != 0) return -1;\n            for (int j = 0; j < N; j++) {\n                if (A[i][j] != A[j][i]) return -1;\n                if (A[i][j] < 0) return -1;\n            }\n        }\n\n        // Floyd-Warshall to verify distances\n        vector<vector<int>> dist = A;\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        // Check if input matches computed shortest paths\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (dist[i][j] != A[i][j]) return -1;\n            }\n        }\n\n        // Kruskal's algorithm to find minimum spanning tree\n        vector<tuple<int,int,int>> edges;\n        for (int i = 0; i < N; i++) {\n            for (int j = i+1; j < N; j++) {\n                edges.push_back({A[i][j], i, j});\n            }\n        }\n\n        sort(edges.begin(), edges.end());\n        \n        vector<int> parent(N);\n        for (int i = 0; i < N; i++) parent[i] = i;\n\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n\n        long long totalRoadLength = 0;\n        for (auto& [w, u, v] : edges) {\n            int pu = find(u), pv = find(v);\n            if (pu != pv) {\n                parent[pu] = pv;\n                totalRoadLength += w;\n            }\n        }\n\n        // Check if all cities are connected\n        int root = find(0);\n        for (int i = 1; i < N; i++) {\n            if (find(i) != root) return -1;\n        }\n\n        return totalRoadLength;\n    }\n};",
    "timestamp": "2025-08-05 23:16:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_min_road_network(N, A):\n    import numpy as np\n\n    # Check if distances form a valid metric\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                if A[i][j] > A[i][k] + A[k][j]:\n                    return -1\n\n    # Calculate the minimum spanning tree total weight\n    total_length = 0\n    for u in range(N):\n        for v in range(u + 1, N):\n            possible = True\n            for k in range(N):\n                if k != u and k != v:\n                    if A[u][v] == A[u][k] + A[k][v]:\n                        possible = False\n                        break\n            if possible:\n                total_length += A[u][v]\n\n    return total_length\n\n# Example usage\nN = 4\nA = [\n    [0, 1, 4, 6],\n    [1, 0, 2, 5],\n    [4, 2, 0, 3],\n    [6, 5, 3, 0]\n]\nprint(find_min_road_network(N, A))",
    "timestamp": "2025-08-13 14:17:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TakahashiKingdom {\n\n    public static int findValidNetwork(int[][] A) {\n        int N = A.length;\n        int totalLength = 0;\n        \n        // Check if the given matrix satisfies triangle inequality\n        for (int u = 0; u < N; u++) {\n            for (int v = 0; v < N; v++) {\n                if (u == v) continue;\n                boolean isDirectlyConnected = true;\n                \n                for (int k = 0; k < N; k++) {\n                    if (k == u || k == v) continue;\n                    if (A[u][v] > A[u][k] + A[k][v]) {\n                        // If there's a shorter path through another city, invalid\n                        return -1;\n                    } else if (A[u][v] == A[u][k] + A[k][v]) {\n                        // u and v should not have a direct road if an indirect path is equal\n                        isDirectlyConnected = false;\n                    }\n                }\n                \n                if (isDirectlyConnected) {\n                    totalLength += A[u][v];\n                }\n            }\n        }\n        \n        // Since all roads are bidirectional and counted twice, divide result by 2\n        return totalLength / 2;\n    }\n\n    public static void main(String[] args) {\n        int[][] A = {\n            { 0, 3, 1 },\n            { 3, 0, 1 },\n            { 1, 1, 0 }\n        };\n        System.out.println(findValidNetwork(A));\n    }\n}",
    "timestamp": "2025-08-13 14:17:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 1000000000\n\nint is_possible(int N, int A[][N], int dist[][N]) {\n    for (int k = 0; k < N; ++k) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                    return 0;\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nint calculate_min_road_length(int N, int A[][N]) {\n    int dist[N][N];\n    int used[N][N];\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dist[i][j] = A[i][j];\n            used[i][j] = 1;\n        }\n    }\n  \n    if (!is_possible(N, A, dist)) {\n        return -1;\n    }\n\n    int total_length = 0;\n    for (int k = 0; k < N; ++k) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (i != j && dist[i][j] == dist[i][k] + dist[k][j]) {\n                    used[i][j] = 0;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (used[i][j]) {\n                total_length += A[i][j];\n            }\n        }\n    }\n\n    return total_length;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int A[N][N];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    int result = calculate_min_road_length(N, A);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:17:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nbool isValidNetwork(const vector<vector<int>>& A, int N) {\n    for (int k = 0; k < N; ++k) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (A[i][j] > A[i][k] + A[k][j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint findShortestRoadLength(const vector<vector<int>>& A, int N) {\n    vector<vector<bool>> used(N, vector<bool>(N, true));\n    for (int k = 0; k < N; ++k) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (i != j && j != k && i != k && A[i][j] == A[i][k] + A[k][j]) {\n                    used[i][j] = false;\n                }\n            }\n        }\n    }\n\n    int totalLength = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (used[i][j]) {\n                totalLength += A[i][j];\n            }\n        }\n    }\n\n    return totalLength;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> A(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> A[i][j];\n        }\n    }\n\n    if (!isValidNetwork(A, N)) {\n        cout << -1 << endl;\n    } else {\n        cout << findShortestRoadLength(A, N) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:17:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_road_network(N, A):\n    # Check symmetry and diagonal conditions\n    for i in range(N):\n        if A[i][i] != 0:\n            return -1\n        for j in range(N):\n            if A[i][j] != A[j][i]:\n                return -1\n    \n    # Floyd-Warshall to verify if given distances are consistent\n    dist = [[A[i][j] for j in range(N)] for i in range(N)]\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dist[i][j] > dist[i][k] + dist[k][j]:\n                    return -1\n                if dist[i][j] != min(dist[i][k] + dist[k][j], dist[i][j]):\n                    return -1\n    \n    # Construct minimal road network\n    roads = set()\n    for i in range(N):\n        for j in range(i+1, N):\n            is_direct_road = True\n            for k in range(N):\n                if k != i and k != j:\n                    if A[i][j] == A[i][k] + A[k][j]:\n                        is_direct_road = False\n                        break\n            if is_direct_road:\n                roads.add((i, j, A[i][j]))\n    \n    # Calculate total road length\n    return sum(road[2] for road in roads)",
    "timestamp": "2025-08-13 14:18:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    A = []\n    for _ in range(N):\n        row = list(map(int, data[index:index+N]))\n        A.append(row)\n        index += N\n    \n    total = 0\n    possible = True\n    \n    for u in range(N):\n        for v in range(u + 1, N):\n            min_possible = float('inf')\n            for k in range(N):\n                if k == u or k == v:\n                    continue\n                if A[u][k] + A[k][v] < min_possible:\n                    min_possible = A[u][k] + A[k][v]\n            if A[u][v] > min_possible:\n                possible = False\n                break\n            if A[u][v] < min_possible:\n                total += A[u][v]\n        if not possible:\n            break\n    \n    if possible:\n        print(total)\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 14:18:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function isValidNetwork(A) {\n  const N = A.length;\n  \n  // Verify shortest path condition\n  for (let k = 0; k < N; k++) {\n    for (let i = 0; i < N; i++) {\n      for (let j = 0; j < N; j++) {\n        if (i !== j && A[i][j] > A[i][k] + A[k][j]) {\n          return -1;\n        }\n      }\n    }\n  }\n  \n  let totalLength = 0;\n  \n  // Calculate the minimum total length\n  for (let i = 0; i < N; i++) {\n    for (let j = i + 1; j < N; j++) {\n      let isDirectEdge = true;\n      for (let k = 0; k < N; k++) {\n        if (k !== i && k !== j && A[i][j] === A[i][k] + A[k][j]) {\n          isDirectEdge = false;\n          break;\n        }\n      }\n      if (isDirectEdge) {\n        totalLength += A[i][j];\n      }\n    }\n  }\n  \n  return totalLength;\n}",
    "timestamp": "2025-08-13 14:18:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findRoadNetwork(N, A) {\n    const roads = new Set();\n    const dist = Array.from({ length: N }, () => Array(N).fill(Infinity));\n\n    for (let i = 0; i < N; i++) {\n        dist[i][i] = 0;\n    }\n\n    for (let k = 0; k < N; k++) {\n        for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n\n    for (let i = 0; i < N; i++) {\n        for (let j = i + 1; j < N; j++) {\n            if (A[i][j] !== dist[i][j]) {\n                return -1;\n            }\n        }\n    }\n\n    for (let k = 0; k < N; k++) {\n        for (let i = 0; i < N; i++) {\n            for (let j = i + 1; j < N; j++) {\n                if (A[i][j] === A[i][k] + A[k][j]) {\n                    roads.add(`${i},${k}`);\n                    roads.add(`${k},${j}`);\n                }\n            }\n        }\n    }\n\n    return roads.size / 2;\n}",
    "timestamp": "2025-08-13 14:18:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N = 0;\n    let A = [];\n    let lineCount = 0;\n\n    rl.on('line', (line) => {\n        if (lineCount === 0) {\n            N = parseInt(line.trim());\n            lineCount++;\n        } else {\n            const row = line.trim().split(' ').map(Number);\n            A.push(row);\n            lineCount++;\n            if (lineCount === N + 1) {\n                rl.close();\n            }\n        }\n    });\n\n    rl.on('close', () => {\n        let totalLength = 0;\n        let possible = true;\n\n        for (let u = 0; u < N; u++) {\n            for (let v = u + 1; v < N; v++) {\n                let isNecessary = true;\n                for (let k = 0; k < N; k++) {\n                    if (k === u || k === v) continue;\n                    if (A[u][v] > A[u][k] + A[k][v]) {\n                        possible = false;\n                        break;\n                    } else if (A[u][v] === A[u][k] + A[k][v]) {\n                        isNecessary = false;\n                        break;\n                    }\n                }\n                if (!possible) break;\n                if (isNecessary) {\n                    totalLength += A[u][v];\n                }\n            }\n            if (!possible) break;\n        }\n\n        if (possible) {\n            console.log(totalLength);\n        } else {\n            console.log(-1);\n        }\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:18:42"
  }
]