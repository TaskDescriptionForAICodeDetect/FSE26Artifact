[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x;\n    int s;\n} Stone;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    Stone stones[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &stones[i].x, &stones[i].s);\n    }\n\n    int dp[n + 2];\n    for (int i = 0; i < n + 2; i++) {\n        dp[i] = INT_MAX;\n    }\n    dp[0] = 0; // starting bank\n\n    for (int i = 0; i <= n; i++) {\n        if (dp[i] == INT_MAX) continue;\n        for (int j = i + 1; j <= i + m + 1 && j <= n + 1; j++) {\n            int danger = 0;\n            if (i != 0 && j != n + 1) {\n                danger = (stones[i - 1].s + stones[j - 1].s) * abs(stones[i - 1].x - stones[j - 1].x);\n            }\n            if (dp[j] > dp[i] + danger) {\n                dp[j] = dp[i] + danger;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dp[n + 1]);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass RiverCrossing {\n    public static int minimumDangerLevel(int n, int m, int[] slipperiness, int[][] stones) {\n        // DP array to store minimum danger levels\n        int[][] dp = new int[n + 1][n + 1];\n        \n        // Initialize dp with maximum values\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        \n        // Initial state\n        dp[0][0] = 0;\n        \n        // Dynamic programming to compute minimum danger\n        for (int row = 0; row <= n; row++) {\n            for (int prevRow = 0; prevRow < row; prevRow++) {\n                // Check if current jump is valid\n                if (row - prevRow > m + 1) continue;\n                \n                // Compute danger for jumps within the same row\n                for (int i = 0; i < stones[row].length; i++) {\n                    for (int j = 0; j < stones[prevRow].length; j++) {\n                        int danger = computeDanger(stones[prevRow][j], stones[row][i], \n                                    slipperiness[prevRow], slipperiness[row]);\n                        \n                        if (dp[prevRow][j] != Integer.MAX_VALUE) {\n                            dp[row][i] = Math.min(dp[row][i], \n                                        dp[prevRow][j] + danger);\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Find minimum danger to cross the river\n        int minDanger = Integer.MAX_VALUE;\n        for (int stone : stones[n]) {\n            minDanger = Math.min(minDanger, dp[n][stone]);\n        }\n        \n        return minDanger;\n    }\n    \n    private static int computeDanger(int startPos, int endPos, \n                                     int startSlip, int endSlip) {\n        return (startSlip + endSlip) * Math.abs(startPos - endPos);\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int n = 5;  // number of rows\n        int m = 2;  // max skippable rows\n        int[] slipperiness = {0, 1, 2, 3, 4, 5};\n        int[][] stones = {\n            {0},       // first row\n            {1, 3},    // second row\n            {2, 4},    // third row\n            {1, 5},    // fourth row\n            {0, 3},    // fifth row\n            {2, 4}     // last row\n        };\n        \n        System.out.println(minimumDangerLevel(n, m, slipperiness, stones));\n    }\n}",
    "timestamp": "2025-08-05 18:47:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> stones(n);\n    for (int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        stones[i].resize(k);\n        for (int j = 0; j < k; ++j) {\n            cin >> stones[i][j];\n        }\n    }\n\n    vector<vector<int>> dp(n, vector<int>(100, INT_MAX)); // Assuming max 100 stones per row\n\n    // Initialize first row\n    for (int j = 0; j < stones[0].size(); ++j) {\n        dp[0][j] = 0;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < stones[i].size(); ++j) {\n            if (dp[i][j] == INT_MAX) continue;\n            for (int skip = 1; skip <= m + 1; ++skip) {\n                if (i + skip >= n) break;\n                for (int k = 0; k < stones[i + skip].size(); ++k) {\n                    int danger = (stones[i][j] + stones[i + skip][k]) * skip;\n                    if (dp[i + skip][k] > dp[i][j] + danger) {\n                        dp[i + skip][k] = dp[i][j] + danger;\n                    }\n                }\n            }\n        }\n    }\n\n    int min_danger = *min_element(dp[n - 1].begin(), dp[n - 1].end());\n    cout << min_danger << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 10\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculateDanger(int currentSlip, int targetSlip, int distance) {\n    return (currentSlip + targetSlip) * distance;\n}\n\nint minimumDangerPath(int n, int m, int* stones, int* slips) {\n    int dp[MAX_N][MAX_M + 1];\n    \n    for (int i = 0; i <= MAX_M; i++) {\n        dp[0][i] = 0;\n    }\n    \n    for (int row = 1; row < n; row++) {\n        for (int skips = 0; skips <= m; skips++) {\n            dp[row][skips] = INT_MAX;\n            \n            for (int prevRow = max(0, row - skips - 1); prevRow < row; prevRow++) {\n                int danger = calculateDanger(slips[prevRow], slips[row], stones[row] - stones[prevRow]);\n                \n                for (int prevSkips = 0; prevSkips <= m; prevSkips++) {\n                    if (dp[prevRow][prevSkips] != INT_MAX) {\n                        dp[row][skips] = min(dp[row][skips], dp[prevRow][prevSkips] + danger);\n                    }\n                }\n            }\n        }\n    }\n    \n    int minDanger = INT_MAX;\n    for (int skips = 0; skips <= m; skips++) {\n        minDanger = min(minDanger, dp[n-1][skips]);\n    }\n    \n    return minDanger;\n}\n\nint main() {\n    int n, m;\n    int stones[MAX_N];\n    int slips[MAX_N];\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &stones[i], &slips[i]);\n    }\n    \n    int result = minimumDangerPath(n, m, stones, slips);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <climits>\n#include <algorithm>\n\nclass RiverCrossing {\npublic:\n    int minimumDangerPath(std::vector<std::vector<int>>& stones, int m) {\n        int n = stones.size();\n        std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, INT_MAX));\n        \n        dp[0][0] = 0;\n        \n        for (int col = 0; col < n; ++col) {\n            for (int row = 0; row <= col; ++row) {\n                if (dp[col][row] == INT_MAX) continue;\n                \n                for (int nextRow = row; nextRow <= std::min(col + m + 1, n); ++nextRow) {\n                    int horizontalDistance = std::abs(nextRow - row);\n                    int dangerLevel = (stones[row][col] + stones[nextRow][col + 1]) * horizontalDistance;\n                    \n                    dp[col + 1][nextRow] = std::min(dp[col + 1][nextRow], dp[col][row] + dangerLevel);\n                }\n            }\n        }\n        \n        int minDanger = INT_MAX;\n        for (int row = 0; row <= n; ++row) {\n            minDanger = std::min(minDanger, dp[n][row]);\n        }\n        \n        return minDanger;\n    }\n};",
    "timestamp": "2025-08-05 18:47:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RiverJump {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] rows = new int[n];\n        int[] slipperiness = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            rows[i] = scanner.nextInt();\n            slipperiness[i] = scanner.nextInt();\n        }\n        \n        long[][] dp = new long[n][m + 2];\n        for (long[] row : dp) {\n            Arrays.fill(row, Long.MAX_VALUE);\n        }\n        \n        for (int k = 0; k <= m + 1; k++) {\n            dp[0][k] = 0;\n        }\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                int skips = i - j - 1;\n                if (skips <= m) {\n                    long danger = (slipperiness[j] + slipperiness[i]) * (rows[i] - rows[j]);\n                    for (int k = skips; k <= m + 1; k++) {\n                        if (dp[j][k - skips] != Long.MAX_VALUE) {\n                            dp[i][k] = Math.min(dp[i][k], dp[j][k - skips] + danger);\n                        }\n                    }\n                }\n            }\n        }\n        \n        long minDanger = Long.MAX_VALUE;\n        for (int k = 0; k <= m + 1; k++) {\n            minDanger = Math.min(minDanger, dp[n - 1][k]);\n        }\n        \n        System.out.println(minDanger);\n    }\n}",
    "timestamp": "2025-08-05 18:48:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_danger(stones, n, m):\n    import heapq\n\n    # Priority queue for Dijkstra's\n    pq = [(0, 0)]  # (danger, row)\n    visited = [False] * n\n    min_danger_from_start = [float('inf')] * n\n    min_danger_from_start[0] = 0\n\n    while pq:\n        current_danger, current_row = heapq.heappop(pq)\n\n        if visited[current_row]:\n            continue\n        visited[current_row] = True\n\n        # Calculate danger level to the opposite bank\n        if current_row == n - 1:\n            return current_danger\n\n        for skip in range(1, m + 1):\n            next_row = current_row + skip\n            if next_row < n and not visited[next_row]:\n                # Find the minimum horizontal danger jump within current and next row\n                min_horizontal_danger = float('inf')\n                for i, (x1, s1) in enumerate(stones[current_row]):\n                    for j, (x2, s2) in enumerate(stones[next_row]):\n                        horizontal_distance = abs(x2 - x1)\n                        temp_danger = (s1 + s2) * horizontal_distance\n                        if temp_danger < min_horizontal_danger:\n                            min_horizontal_danger = temp_danger\n\n                # If a valid path with lower danger is found, update it\n                new_danger = current_danger + min_horizontal_danger\n                if new_danger < min_danger_from_start[next_row]:\n                    min_danger_from_start[next_row] = new_danger\n                    heapq.heappush(pq, (new_danger, next_row))\n\n    return 0\n\n# Example usage:\nn = 5  # total rows\nm = 2  # maximum skips\n# Stones with positions and slipperiness for each row\nstones = [\n    [(0, 5), (2, 6)],  # Row 0: (position, slipperiness)\n    [(1, 3), (3, 2)],\n    [(2, 1), (4, 4)],\n    [(1, 5), (3, 6)],\n    [(2, 7), (4, 3)],\n]\n\nprint(min_danger(stones, n, m))",
    "timestamp": "2025-08-13 00:57:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RiverJumpGame {\n    public static int minTotalDanger(int[][] stones, int m) {\n        int n = stones.length;  // Number of rows\n        int[][] dp = new int[n][stones[0].length];\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        \n        // Initial danger level for the first row\n        Arrays.fill(dp[0], 0);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < stones[i].length; j++) {\n                if (dp[i][j] == Integer.MAX_VALUE) continue;\n\n                for (int k = 1; k <= m && i + k < n; k++) {\n                    for (int l = 0; l < stones[i + k].length; l++) {\n                        int horizontalDistance = Math.abs(j - l);\n                        int danger = (stones[i][j] + stones[i + k][l]) * horizontalDistance;\n                        dp[i + k][l] = Math.min(dp[i + k][l], dp[i][j] + danger);\n                    }\n                }\n            }\n        }\n\n        // Finding the minimum danger to reach the opposite bank (last row)\n        int minDanger = Integer.MAX_VALUE;\n        for (int danger : dp[n - 1]) {\n            minDanger = Math.min(minDanger, danger);\n        }\n        return minDanger;\n    }\n\n    public static void main(String[] args) {\n        int[][] stones = {\n            {2, 3},\n            {3, 4, 1},\n            {5, 2},\n            {1, 3}\n        };\n        int m = 2;\n        System.out.println(minTotalDanger(stones, m)); // Expected output: minimum total danger\n    }\n}",
    "timestamp": "2025-08-13 00:57:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_ROWS 100\n#define MAX_STONES 100\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int sl[MAX_ROWS][MAX_STONES]; // slipperiness\n    int pos[MAX_ROWS][MAX_STONES]; // positions\n    int stone_count[MAX_ROWS]; // stones in each row\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &stone_count[i]);\n        for (int j = 0; j < stone_count[i]; ++j) {\n            scanf(\"%d %d\", &pos[i][j], &sl[i][j]);\n        }\n    }\n\n    int dp[MAX_ROWS][MAX_STONES];\n    for (int j = 0; j < stone_count[0]; ++j) dp[0][j] = 0;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < stone_count[i]; ++j) {\n            dp[i][j] = INT_MAX;\n            for (int k = 0; k < stone_count[i-1]; ++k) {\n                int horizontal_distance = abs(pos[i][j] - pos[i-1][k]);\n                int danger = (sl[i][j] + sl[i-1][k]) * horizontal_distance;\n                dp[i][j] = min(dp[i][j], dp[i-1][k] + danger);\n            }\n            for (int skips = 2; skips <= m && i-skips >= 0; ++skips) {\n                for (int k = 0; k < stone_count[i-skips]; ++k) {\n                    int horizontal_distance = abs(pos[i][j] - pos[i-skips][k]);\n                    int danger = (sl[i][j] + sl[i-skips][k]) * horizontal_distance;\n                    dp[i][j] = min(dp[i][j], dp[i-skips][k] + danger);\n                }\n            }\n        }\n    }\n\n    int min_danger = INT_MAX;\n    for (int j = 0; j < stone_count[n-1]; ++j) {\n        min_danger = min(min_danger, dp[n-1][j]);\n    }\n\n    printf(\"%d\\n\", min_danger);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:57:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_danger_path(n, m, stones):\n    # Initialize DP table with large values\n    dp = [[float('inf')] * len(stones) for _ in range(n)]\n    \n    # First row stones can be reached directly from the bank\n    for j, stone in enumerate(stones[0]):\n        dp[0][j] = 0\n    \n    # Iterate through rows\n    for i in range(1, n):\n        # Try normal jumps and skips\n        for skip in range(1, m + 1):\n            if i - skip < 0:\n                break\n            \n            # Check jumps between stones in current and previous rows\n            for curr_col, curr_stone in enumerate(stones[i]):\n                for prev_col, prev_stone in enumerate(stones[i - skip]):\n                    # Calculate danger level\n                    danger = ((curr_stone + prev_stone) * abs(curr_col - prev_col)) + dp[i - skip][prev_col]\n                    dp[i][curr_col] = min(dp[i][curr_col], danger)\n    \n    # Return minimum danger to reach the last row\n    return min(dp[n - 1])",
    "timestamp": "2025-08-13 00:58:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_danger_to_bank(n, m, stones):\n    if n == 0:\n        return 0\n    \n    # Initialize DP table: dp[i] represents the min danger to reach stone i\n    dp = [float('inf')] * n\n    dp[0] = 0  # starting point\n    \n    for i in range(n):\n        for j in range(1, m + 1):\n            if i + j >= n:\n                # Jump to the opposite bank\n                dp[n - 1] = min(dp[n - 1], dp[i])\n                break\n            else:\n                # Jump to stone i + j\n                danger = (stones[i] + stones[i + j]) * j\n                dp[i + j] = min(dp[i + j], dp[i] + danger)\n    \n    return dp[-1]\n\n# Example usage:\n# n = 4\n# m = 2\n# stones = [1, 2, 3, 4]\n# print(min_danger_to_bank(n, m, stones))  # Output should be 6",
    "timestamp": "2025-08-13 00:58:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Stone {\n    int position;\n    int slipperiness;\n};\n\nint minDanger(int n, int m, vector<vector<Stone>>& river) {\n    // Create a dp array\n    vector<vector<int>> dp(n + 1, vector<int>(river[0].size(), INT_MAX));\n    \n    // Initialize the first row (jump from bank)\n    for (int j = 0; j < river[0].size(); ++j) {\n        dp[0][j] = 0;\n    }\n    \n    // Fill in dp table\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < river[i - 1].size(); ++j) {\n            int currentPos = river[i - 1][j].position;\n            int currentSlip = river[i - 1][j].slipperiness;\n            for (int k = 0; k < river[i - 1].size(); ++k) {\n                int prevPos = river[i - 1][k].position;\n                int prevSlip = river[i - 1][k].slipperiness;\n                // Normal jump\n                int distance = abs(currentPos - prevPos);\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + (prevSlip + currentSlip) * distance);\n            }\n            // Skipped jumps\n            for (int skip = 2; skip <= m + 1 && i - skip >= 0; ++skip) {\n                for (int k = 0; k < river[i - skip].size(); ++k) {\n                    int prevPos = river[i - skip][k].position;\n                    int prevSlip = river[i - skip][k].slipperiness;\n                    int distance = abs(currentPos - prevPos);\n                    dp[i][j] = min(dp[i][j], dp[i - skip][k] + (prevSlip + currentSlip) * distance);\n                }\n            }\n        }\n    }\n    \n    // Find minimum danger on the last row as it represents reaching the opposite bank\n    int minTotalDanger = INT_MAX;\n    int lastRow = river.size();\n    for (int j = 0; j < river[lastRow - 1].size(); ++j) {\n        minTotalDanger = min(minTotalDanger, dp[lastRow][j]);\n    }\n    \n    return minTotalDanger;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<Stone>> river(n + 1); \n\n    for (int i = 0; i < n; ++i) {\n        int numStones;\n        cin >> numStones;\n        for (int j = 0; j < numStones; ++j) {\n            int position, slipperiness;\n            cin >> position >> slipperiness;\n            river[i].push_back({position, slipperiness});\n        }\n    }\n    \n    cout << minDanger(n, m, river) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:57:07"
  }
]