[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\nstruct po{int x,d;};\nlong long dp[155][1001][80];\n\nint calc(po a,po b){return (a.d+b.d)*(abs(a.x-b.x));}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n  \n    vector <po> mp[200];\n    for(int i=0;i<200;i++)mp[i].clear();\n    for(int i=0,k;i<n;i++){\n      cin>>k;\n      mp[i].resize(k);\n      for(int j=0;j<k;j++) cin>>mp[i][j].x>>mp[i][j].d;\n    }\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<(int)mp[i].size();j++) \n\tfor(int k=0;k<=m;k++)dp[i][j][k]=INF;\n    \n    for(int i=0;i<(int)mp[0].size();i++) dp[0][i][0]=0;\n    if(m)for(int i=0;i<(int)mp[1].size();i++) dp[1][i][1]=0;\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)mp[i].size();j++)\n\tfor(int k=0;k<=m;k++){\n\t  for(int l=0;l<(int)mp[i+1].size();l++)\n\t    dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+calc(mp[i][j],mp[i+1][l]));\n\t  \n\t  for(int l=0;l<(int)mp[i+2].size()&&k!=m;l++)\n\t    dp[i+2][l][k+1]=min(dp[i+2][l][k+1],dp[i][j][k]+calc(mp[i][j],mp[i+2][l]));\n\t}\n    }\n    \n    long long ans=INF;\n    for(int i=0;i<(int)mp[n-1].size();i++)\n      for(int j=0;j<=m;j++) ans=min(dp[n-1][i][j],ans);\n    \n    for(int i=0;i<(int)mp[n-2].size();i++)\n      for(int j=0;j<m;j++)  ans=min(dp[n-2][i][j],ans);\n    cout <<ans<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint dp[155][1000][76]={};\nbool p(P a,P b){\n\tif(a.first<b.first){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(1){\n\t\tvector<P>vec[155];\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(!n) break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint r,u;\n\t\t\t\tscanf(\"%d %d\",&r,&u);\n\t\t\t\tvec[i].pb(mp(r,u));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tsort(vec[i].begin(),vec[i].end(),p);\n\t\t}\n\t\tfor(int i=0;i<=150;i++){\n\t\t\tfor(int j=0;j<1000;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint y=vec[1].size();\n\t\tfor(int i=0;i<y;i++){\n\t\t\tdp[1][vec[1][i].first][0]=0;\n\t\t}\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tint eee=vec[i].size();\n\t\t\tfor(int j=0;j<eee;j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tint r=vec[i-1].size();\n\t\t\t\t\tfor(int l=0;l<r;l++){\n\t\t\t\t\t\tdp[i][vec[i][j].first][k]=min(dp[i-1][vec[i-1][l].first][k]+abs(vec[i][j].first-vec[i-1][l].first)*(vec[i-1][l].second+vec[i][j].second),dp[i][vec[i][j].first][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=0 && i!=2){\n\t\t\t\t\t\tint rr=vec[i-2].size();\n\t\t\t\t\t\tfor(int l=0;l<rr;l++){\n\t\t\t\t\t\t\tdp[i][vec[i][j].first][k]=min(dp[i-2][vec[i-2][l].first][k-1]+abs(vec[i][j].first-vec[i-2][l].first)*(vec[i-2][l].second+vec[i][j].second),dp[i][vec[i][j].first][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint rp[10]={};\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tint u=(int)vec[i].size();\n\t\t\t\tfor(int j=0;j<u;j++){\n\t\t\t\t\t\trp[j]=dp[i][vec[i][j].first][k];\n\t\t\t\t}\n\t\t\t\tsort(rp,rp+u);\n\t\t\t\tfor(int l=0;l<u;l++){\n\t\t\t\t\tint q;\n\t\t\t\t\tfor(int e=0;e<u;e++){\n\t\t\t\t\t\tif(rp[l]==dp[i][vec[i][e].first][k]){q=e;}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int g=0;g<u;g++){\n\t\t\t\t\t\tif(q!=g){\n\t\t\t\t\t\t\tdp[i][vec[i][g].first][k]=min(dp[i][vec[i][g].first][k],dp[i][vec[i][q].first][k]+abs(vec[i][g].first-vec[i][q].first)*(vec[i][g].second+vec[i][q].second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<vec[n].size();i++){\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tres=min(res,dp[n][vec[n][i].first][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tREP(i, n - 1) REP(j, stone[i].size()) REP(k, m + 1) {\n\t\t\tpii &from = stone[i][j];\n\t\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2 && k > 0) {\n\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\tpii &to = stone[i + 2][l];\n\t\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\tpii &to = stone[i + 1][l];\n\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tREP(i, n + 1) {\n\t\t\tREP(j, stone[i].size()) {\n\t\t\t\tint pri = INF;\n\t\t\t\tREP(k, m + 1) pri = min(pri, dp[i][j][k]);\n\t\t\t\tprintf(\"%d%c\", pri, j == stone[i].size() - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tif (n > 1) REP(i, stone[n - 2].size()) FOR(j, 1, m + 1) ans = min(ans, dp[n - 2][i][j]);\n\t\tif (ans == INF) ans = 0;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define fr first\n#define sc second\n#define INF 100000000\ntypedef pair<int,int> Pi;\ntypedef pair< Pi,pair<Pi,int> > P;\nstruct Edge{\n  int to,denger;\n  Edge(){}\n  Edge(int to,int denger):to(to),denger(denger){};\n};\nint n,m;\nint m_cost[150][11][(150+1)/2+1];\nvector<vector<Edge> > info;\nint Dijkstra();\nint main(){\n  while(cin >> n >> m && n||m){\n    info.resize(n);\n    for(int i=0,k;i<n;i++){\n      cin >> k;\n      for(int j=0,t,d;j<k;j++){\n        cin >> t >> d;\n        info[i].push_back(Edge(t,d));\n      }\n    }\n    cout << Dijkstra() << endl;\n    info.clear();\n  }\n}\n  int Dijkstra(){\n    for(int i=0;i<150;i++){\n      for(int j=0;j<11;j++){\n        for(int k=0;k<(150+1)/2+1;k++){\n        m_cost[i][j][k] = INF;\n        }\n      }\n    }\n    int ans = INF;\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0,l=info[0].size();i<l;i++){\n    que.push(P(Pi(0,m),make_pair(Pi(0,info[0][i].to),info[0][i].denger)));\n    m_cost[0][i][m] = 0;\n  }\n  if(m != 0){\n    for(int i=0,l=info[1].size();i<l;i++){\n      que.push(P(Pi(0,m-1),make_pair(Pi(1,info[1][i].to),info[1][i].denger)));\n      m_cost[1][i][m-1] = 0;\n    }\n  }\n  while(!que.empty()){\n    P p = que.top();\n    int den = p.fr.fr,limit = p.fr.sc,slip=p.sc.sc;\n    Pi pt = Pi(p.sc.fr.fr,p.sc.fr.sc);\n    que.pop();\n    if(pt.fr + 1 == n){\n      ans = min(ans,den);\n      continue;\n    }\n    for(int j=1;j<3;j++){\n      if(j==2 && (limit == 0 || pt.fr+1==n)) break;\n      if(j==2 && pt.fr + 2 == n){\n        ans = min(ans,den);\n        continue;\n      }\n      if(j==1 && pt.fr + 1 == n){\n        ans = min(ans,den);\n        continue;\n      }\n      for(int i=0,l=info[pt.fr+j].size();i<l;i++){\n        int next_now = info[pt.fr+j][i].to;\n        int next_den = info[pt.fr+j][i].denger;\n        int hmhm = den + (slip + next_den) * abs(next_now - pt.sc);\n        if(hmhm < m_cost[pt.fr+j][i][limit-(j-1)]){\n          m_cost[pt.fr+j][i][limit-(j-1)] = hmhm;\n          que.push(P(Pi(hmhm,limit-(j-1)),make_pair(Pi(pt.fr+j,next_now),next_den)));\n        }\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nsigned main()\n{\n\twhile (scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%d\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%d %d\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\tmemset(memo, -1, sizeof(memo));\n\n\t\trep(i, k[0]) chmin(ans, rec(0, 0, i));\n\n\t\tif (M > 0) rep(i, k[1]) chmin(ans, rec(1, 1, i));\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tX\tfirst\n#define\tSL\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1000000000;\npii river[150][11];\nint memo[150][10][76];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k;\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint x,slip;\tscanf(\"%d%d\",&x,&slip);\n\t\t\t\triver[i][j]=mp(x,slip);\n\t\t\t}\n\t\t\triver[i][k]=mp(-1,-1);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++)for(int j=0;~river[i][j].X;j++)for(int k=0;k<=m;k++)\n\t\t\tmemo[i][j][k]=inf;\n\n\t\tfor(int j=0;~river[0][j].X;j++)\tmemo[0][j][0]=0;\n\t\tfor(int j=0;~river[1][j].X;j++)\tmemo[1][j][1]=0;\n\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;~river[i][j].X;j++){\n\t\t\t\tint cost;\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tfor(int b=0;~river[i-1][b].X;b++){\n\t\t\t\t\t\tif(river[i-1][b].X==inf)\tcontinue;\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-1][b].SL)*abs(river[i][j].X-river[i-1][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-1][b][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=1;k<=m;k++){\n\t\t\t\t\tif(i-2<0)\tcontinue;\n\t\t\t\t\tfor(int b=0;~river[i-2][b].X;b++){\n\t\t\t\t\t\tif(river[i-2][b].X==inf)\tcontinue;\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-2][b].SL)*abs(river[i][j].X-river[i-2][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-2][b][k-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mincost=inf;\n\t\tfor(int j=0;~river[n-1][j].X;j++)for(int k=0;k<=m;k++)\tmincost=min(mincost,memo[n-1][j][k]);\n\t\tfor(int j=0;~river[n-2][j].X;j++)for(int k=0;k<m;k++)\tmincost=min(mincost,memo[n-2][j][k]);\n\t\tprintf(\"%d\\n\",mincost);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\nusing namespace std;\nint dp[80][160][10];\nint x[160][10],d[160][10],k[160];\nint n,m;\nint main(){\n cin>>n>>m;\n for(int i=0;i<n;i++){\n  cin>>k[i];\n  for(int j=0;j<k[i];j++){\n   cin>>x[i][j]>>d[i][j];   \n  }\n  if(!i)for(int mm=0;mm<=m;mm++)for(int j=0;j<k[i];j++)dp[mm][i][j]=0;\n  else for(int mm=0;mm<=m;mm++)for(int j=0;j<k[i];j++)dp[mm][i][j]=1145141919;\n  \n  if(i){\n    for(int mm=0;mm<=m;mm++){\n        for(int j=0;j<k[i];j++){\n         for(int r=0;r<k[i-1];r++){\n          dp[mm][i][j]=min(dp[mm][i][j],dp[mm][i-1][r]+(abs(x[i][j]-x[i-1][r])*(d[i][j]+d[i-1][r]))); \n         }\n        }\n    }\n  }\n  if(i>1){\n   for(int mm=1;mm<=m;mm++){\n    for(int j=0;j<k[i];j++){\n     for(int r=0;r<k[i-2];r++){\n      dp[mm][i][j]=min(dp[mm][i][j],dp[mm-1][i-2][r]+(abs(x[i][j]-x[i-2][r])*(d[i][j]+d[i-2][r])));   \n     }\n    }\n   }\n  }\n }\n int ans=1145141919;\n for(int mm=0;mm<=m;mm++){\n  for(int j=0;j<k[n-1];j++){\n   ans=min(ans,dp[mm][n-1][j]);   \n  }\n }\n cout<<ans<<endl;\n return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 50;\n\nll dist[160][10][80];\n\nstruct S {\n\tint x, y, jump;\n\tll d;\n\tbool operator <(const S& x) const {\n\t\treturn d > x.d;\n\t}\n};\n\nint rec(S s) {\n\treturn dist[s.y][s.x][s.jump];\n}\n\nvoid save(S s) {\n\tdist[s.y][s.x][s.jump] = s.d;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tvector<ll> c[160];\n\t\tvector<ll> x[160];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\tll xx, cc;\n\t\t\t\tcin >> xx >> cc;\n\t\t\t\txx--;\n\t\t\t\tx[i].push_back(xx);\n\t\t\t\tc[i].push_back(cc);\n\t\t\t}\n\t\t}\n\n\t\tfill((ll*)begin(dist), (ll*)end(dist), INF);\n\t\tpriority_queue<S> q;\n\t\tfor(int i = 0; i < x[0].size(); i++) {\n\t\t\tS s = { i, 0, 0, 0 };\n\t\t\tq.push(s);\n\t\t\tsave(s);\n\t\t}\n\n\t\tll ans = 0;\n\t\twhile(q.size()) {\n\t\t\tS s = q.top();\n\t\t\tq.pop();\n\t\t\tif(rec(s) < s.d) continue;\n\t\t\tif(s.y == n) {\n\t\t\t\tans = s.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= 2; i++) {\n\t\t\t\tif(s.jump == m && i == 2) break;\n\t\t\t\tif(s.y + i > n) break;\n\t\t\t\tint nj = s.jump + (i == 2);\n\t\t\t\tif(s.y + i == n) {\n\t\t\t\t\tS ns = { 0, s.y + i, nj, s.d };\n\t\t\t\t\tif(rec(ns) > s.d) {\n\t\t\t\t\t\tq.push(ns);\n\t\t\t\t\t\tsave(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < x[s.y + i].size(); j++) {\n\t\t\t\t\t\tint nx = x[s.y + i][j];\n\t\t\t\t\t\tll cost = (c[s.y][s.x] + c[s.y + i][j]) * abs(x[s.y][s.x] - nx);\n\t\t\t\t\t\tS ns = { j, s.y + i, nj, s.d + cost };\n\t\t\t\t\t\tif(rec(ns) > ns.d) {\n\t\t\t\t\t\t\tq.push(ns);\n\t\t\t\t\t\t\tsave(ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<map>\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> stn[150];\nvector<int> dp[150][80];\nint abs(int a){return a>=0?a:-a;}\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k,l;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<150;i++){\n\t\tstn[i].clear();\n\t\tfor(j=0;j<80;j++)dp[i][j].clear();\n\t}\n\tfor(i=0;i<n;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tfor(j=0;j<t;j++){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\tstn[i].push_back(P(a,b));\n\t\t\tfor(k=0;k<=m;k++)dp[i][k].push_back(INF);\n\t\t}\n\t}\n\tfor(i=0;i<stn[0].size();i++)dp[0][0][i]=0;\n\tif(m>=1)for(i=0;i<stn[1].size();i++)dp[1][1][i]=0;\n\tfor(i=0;i<n-1;i++){\n\t\tfor(j=0;j<=m;j++){\n\t\t\tfor(k=0;k<stn[i].size();k++){\n\t\t\t\tfor(l=0;l<stn[i+1].size();l++){\n\t\t\t\t\tint cost=(stn[i][k].second+stn[i+1][l].second)*abs(stn[i][k].first-stn[i+1][l].first);\n\t\t\t\t\tdp[i+1][j][l]=min(dp[i+1][j][l],dp[i][j][k]+cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j==m||i==n-2)continue;\n\t\t\tfor(k=0;k<stn[i].size();k++){\n\t\t\t\tfor(l=0;l<stn[i+2].size();l++){\n\t\t\t\t\tint cost=(stn[i][k].second+stn[i+2][l].second)*abs(stn[i][k].first-stn[i+2][l].first);\n\t\t\t\t\tdp[i+2][j+1][l]=min(dp[i+2][j+1][l],dp[i][j][k]+cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<stn[n-1].size();i++){\n\t\tfor(j=0;j<=m;j++)ans=min(ans,dp[n-1][j][i]);\n\t}\n\tfor(i=0;i<stn[n-2].size();i++){\n\t\tfor(j=0;j<m;j++)ans=min(ans,dp[n-2][j][i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n\n      int slip[151][11] = {{0}};\n      int flag[151][11][77] = {{{0}}};\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n\n      if(n == 1 && m == 1){printf(\"0\\n\"); continue;}\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n            flag[1][i][0] = 1;\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n            flag[2][i][1] = 1;\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s] = 1;\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n               if(p.f.f != 0) flag[p.f.s+2][i][p.s.s+1] = 1;\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 1005\n#define N 155\n#define S 85\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b,X;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[S][N][M];\n\nint dijkstra(int sy,int sx,int x){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<=(n+1)/2;i++)\n    for(int j=0;j<n;j++)\n      for(int l=0;l<=X;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  if(x<=m)q.push(P1(P(0,x),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  for(int i=0;i<node[n-2].size();i++)\n    for(int j=0;j<m;j++)\n      res=min(res,d[j][n-2][node[n-2][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    X=0;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tX=max(X,a-1);\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x,0));\n    for(int i=0;i<node[1].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x,1));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<long long,long long> P;\n\n#define INF (1000000000000000LL)\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ABS(a) ((a>0)?(a):(-(a)))\n\nint danger(P s, P t) {\n    return (s.second+t.second)*ABS(s.first-t.first);\n}\n\nvoid solve(int n,int m) {\n    vector<P> mp[n];\n    vector<int> ki(n,0);\n\n    for(int i=0; i<n; ++i) {\n        cin >> ki[i];\n        for(int j=0; j<ki[i]; ++j) {\n            long long a,b;\n            cin >> a >> b;\n            mp[i].push_back(P(a,b));\n        }\n    }\n\n    long long dp[m+1][n][10];\n    for(int i=0; i<=m; ++i)\n        for(int j=0; j<n; ++j)\n            for(int k=0; k<10; ++k)\n                dp[i][j][k]=INF;\n    \n    for(int k=0; k<ki[0]; ++k) dp[0][0][k]=0;\n    if(m>0) for(int k=0; k<ki[1]; ++k) dp[1][1][k]=0;\n\n    long long ans=INF;\n\n    for(int i=0; i<=m; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<ki[j]; ++k) {\n                if(j==n-1 || (j==n-2 && i<m)) ans=MIN(ans,dp[i][j][k]);\n                if(j==n-1) continue;\n                for(int l=0; l<ki[j+1]; ++l) {\n                    dp[i][j+1][l]=MIN(dp[i][j+1][l],dp[i][j][k]+danger(mp[j][k],mp[j+1][l]));\n                }\n                if(j==n-2 || i==m) continue;\n                for(int l=0; l<ki[j+2]; ++l) {\n                    dp[i+1][j+2][l]=MIN(dp[i+1][j+2][l],dp[i][j][k]+danger(mp[j][k],mp[j+2][l]));\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return;\n}\n\n\nint main() {\n    while(true) {\n        int n,m;\n        cin >> n >> m;\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 3e18;\n\nint k[151];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n    if (n >= N - 1) return 0;\n\n    if (~memo[n][m][i]) return memo[n][m][i];\n\n    int res = inf;\n\n    rep(j, k[n + 1]) {\n        int dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n        chmin(res, dist + rec(n + 1, m, j));\n    }\n\n    if (m > 0) {\n        if (n + 2 >= N) return 0;\n        rep(j, k[n + 2]) {\n            int dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n            chmin(res, dist + rec(n + 2, m - 1, j));\n        }\n    }\n\n    return memo[n][m][i] = res;\n}\n\nsigned main()\n{\n    while (scanf(\"%lld %lld\", &N, &M), N || M) {\n        rep(i, N) {\n            scanf(\"%lld\", &k[i]);\n\n            stone[i].resize(k[i]);\n\n            rep(j, k[i]) {\n                int x, d; scanf(\"%lld %lld\", &x, &d);\n                stone[i][j].fst = x, stone[i][j].scd = d;\n            }\n        }\n\n        int ans = inf;\n\n        rep(i, k[0]) {\n            memset(memo, -1, sizeof(memo));\n            chmin(ans, rec(0, M, i));\n        }\n\n        printf(\"%lld\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n#define N 153\n#define COL 1001\nusing namespace std;\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\nint dijkstra(int n,int m,int D[][COL],const vector< vector<int> > &T){\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  bool vis[N][COL]={false,};\n  while(!qs.empty()){\n    state now=qs.top();qs.pop();\n    if(now.r==n+1||now.r==n+2)return now.cost;\n    vis[now.r][now.c]=true;\n    for(int k=1;k<=2;++k){for(int i=0;i<T[now.r+k].size();++i){\n\tint nxr=now.r+k,nxc=T[nxr][i],nxcost=now.cost+(now.r==0?0:(D[now.r][now.c]+D[nxr][nxc])*abs(now.c-nxc));\n\tstate next(nxr,nxc,nxcost,now.left-(k-1));if(!vis[nxr][nxc]&&next.left>=0){qs.push(next);}\n      }\n    }\n  }\n  return -1;\n}\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(n==0&&m==0)break;\n    vector< vector<int> > T(n+3);for(int i=0;i<COL;++i){T[0].push_back(i);T[n+1].push_back(i);T[n+2].push_back(i);}\n    int D[N][COL]={{0,},};\n    for(int i=0;i<n;++i){int k;cin>>k;for(int j=0;j<k;++j){int col,danger;cin>>col>>danger;T[i+1].push_back(col);D[i+1][col]=danger;}}\n    cout<<dijkstra(n,m,D,T)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tX\tfirst\n#define\tSL\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1000000000;\npii river[150][11];\nint memo[150][10][76];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k;\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint x,slip;\tscanf(\"%d%d\",&x,&slip);\n\t\t\t\triver[i][j]=mp(x,slip);\n\t\t\t}\n\t\t\triver[i][k]=mp(-1,-1);\n\t\t}\n\n\t\tfor(int j=0;~river[0][j].X;j++){\n\t\t\tmemo[0][j][0]=0;\n\t\t\tfor(int k=1;k<=m;k++)\tmemo[0][j][k]=inf;\n\t\t}\n\t\tfor(int j=0;~river[1][j].X;j++){\n\t\t\tmemo[1][j][1]=0;\n\t\t}\n\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;~river[i][j].X;j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tmemo[i][j][k]=inf;\n\t\t\t\t\tint cost;\n\t\t\t\t\tfor(int b=0;~river[i-1][b].X;b++){\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-1][b].SL)*abs(river[i][j].X-river[i-1][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-1][b][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i-2<0 || k-1<0)\tcontinue;\n\t\t\t\t\tfor(int b=0;~river[i-2][b].X;b++){\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-2][b].SL)*abs(river[i][j].X-river[i-2][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-2][b][k-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mincost=inf;\n\t\tfor(int j=0;~river[n-1][j].X;j++)for(int k=0;k<=m;k++)\tmincost=min(mincost,memo[n-1][j][k]);\n\t\tfor(int j=0;~river[n-2][j].X;j++)for(int k=0;k<m;k++)\tmincost=min(mincost,memo[n-2][j][k]);\n\t\tprintf(\"%d\\n\",mincost);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nconst int INF = 1<<29;\n\nint dp[151][11][80];\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\trep(i, n) rep(j, 11) rep(k, 80) dp[i][j][k] = INF;\n\t\tvector<vector<P> > stone(n);\n\t\trep(i, n){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\trep(j, k){\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tstone[i].push_back(MP(x, d));\n\t\t\t}\t\t\t\n\t\t}\n\t\trep(i, 2) rep(j, stone[0].size()){\n\t\t\tdp[i][j][i] = 0;\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, n){\n\t\t\trep(j, stone[i].size()){\n\t\t\t\tP from = stone[i][j];\n\t\t\t\trep(l, m+1){\n\t\t\t\t\tif(i+1 < n){\n\t\t\t\t\t\trep(k, stone[i+1].size()){\n\t\t\t\t\t\t\tP to = stone[i+1][k];\n\t\t\t\t\t\t\tint cost = abs(from.X-to.X)*(from.Y+to.Y);\n\t\t\t\t\t\t\tdp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][l]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = min(ans, dp[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(l, m){\n\t\t\t\t\tif(i+2 < n){\n\t\t\t\t\t\trep(k, stone[i+2].size()){\n\t\t\t\t\t\t\tP to = stone[i+2][k];\n\t\t\t\t\t\t\tint cost = abs(from.X-to.X)*(from.Y+to.Y);\n\t\t\t\t\t\t\tdp[i+2][k][l+1] = min(dp[i+2][k][l+1], dp[i][j][l]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = min(ans, dp[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint memo[80][150][1001];\n\nint main(){\n  int n,m;\n  while(n=getInt(), m=getInt(), n+m){\n    vector<vector<pair<int,int> > > stone(n);\n    memset(memo, -1, sizeof(memo));\n    REP(i,n){\n      int num = getInt();\n      stone[i] = vector<pair<int,int> >(num);\n      REP(j,num){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    FOR(it,stone[0]) memo[m][0][it->f] = 0;\n    if(m != 0) FOR(it,stone[1]) memo[m-1][1][it->f] = 0;\n\n\n    REP(i,n-1){\n      FOR(it,stone[i]){\n        int j = it->f;\n        int s = it->s;\n        REP(k,m+1){\n          if(memo[k][i][j] != -1){\n            FOR(it2,stone[i+1]){\n              int jj = it2->f;\n              int ss = it2->s;\n              int mm = memo[k][i][j];\n\n              if(memo[k][i+1][jj] == -1)\n                memo[k][i+1][jj] = mm + (s + ss)*abs(j - jj);\n              else\n                memo[k][i+1][jj] = min(memo[k][i+1][jj], mm + (s + ss)*abs(j - jj));\n            }\n\n            if(k != 0 && i != n-2){\n              FOR(it2,stone[i+2]){\n                int jj = it2->f;\n                int ss = it2->s;\n                int mm = memo[k][i][j];\n\n                if(memo[k-1][i+2][jj] == -1)\n                  memo[k-1][i+2][jj] = mm + (s + ss)*abs(j - jj);\n                else\n                  memo[k-1][i+2][jj] = min(memo[k][i+2][jj], mm + (s + ss)*abs(j - jj));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    //puts(\"0:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[0][i][j]); puts(\"\"); }\n    //puts(\"1:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[1][i][j]); puts(\"\"); }\n\n    int ans = INT_MAX;\n    REP(j,n) REP(k,m+1){\n      if(memo[k][n-1][j] != -1)\n        ans = min(ans, memo[k][n-1][j]);\n      if(k != 0){\n        if(memo[k][n-2][j] != -1)\n          ans = min(ans, memo[k][n-2][j]);\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i__=0;__i__<n;__i__++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\nusing namespace std;\n\nlong COST_LIMIT = 1000 * 1000 * 150;\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n, m; cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    // alloc cost table\n    long **cost_table[3];\n    loop(3, i) {\n      cost_table[i] = new long*[10];\n      loop(10, j) {\n        cost_table[i][j] = new long[m + 1];\n      }\n    }\n    int slip[3][10], slip_i[3][10];\n\n    // operation per row\n    loop(n, row_i) {\n      int prev = (row_i + 1) % 3, crr = (row_i + 2) % 3, next = row_i % 3;\n\n      // init arrays\n      loop(10, i) {\n        loop(m + 1, j) cost_table[next][i][j] = -1;\n        slip[next][i] = -1;\n        slip_i[next][i] = -1;\n      }\n\n      // input\n      {\n        int count; cin >> count;\n        loop(count, i) {\n          int index, slipness; cin >> index >> slipness;\n          slip[next][i] = slipness;\n          slip_i[next][i] = index;\n        }\n      }\n\n      // initial values\n      if (row_i == 0) { \n        loop(10, i) {\n          if (slip_i[next][i] != -1) cost_table[next][i][m] = 0;\n        }\n      }\n\n      // // !debug\n      // if (row_i > 0) \n      // {\n      //   cout << \"row: \" << row_i - 1 << endl;\n      //   loop(10, i) {\n      //     if (slip_i[crr][i] == -1) break;\n      //     loop(m + 1, j) {\n      //       cout << cost_table[crr][i][j] << \" \";\n      //     }\n      //     cout << endl;\n      //   }\n      // }\n\n      // normal jump\n      if (row_i < 1) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop(m + 1, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, c_col_i) {\n            if (slip_i[crr][c_col_i] == -1) break;\n            if (cost_table[crr][c_col_i][m_i] == -1) continue;\n            int cost = (slip_i[crr][c_col_i] - slip_i[next][n_col_i]) * \n              (slip[crr][c_col_i] + slip[next][n_col_i]);\n            if (cost < 0) cost = -cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = c_col_i;\n            }\n          }\n          if (min_cost == -1) {\n            cost_table[next][n_col_i][m_i] = min_cost;\n          } else {\n            // // !debug\n            // if (row_i == 2 && m_i == 0) {\n            //   cout << \"from: \" << slip_i[crr][min_col] << \", to: \" <<\n            //     slip_i[next][n_col_i] << endl;\n            //   cout << \"col: \" << n_col_i << \", crr_cost: \" << \n            //     cost_table[crr][min_col][m_i] << \", jump_cost: \" <<\n            //     min_cost << \", min_col: \" << min_col << endl;\n            // }\n            cost_table[next][n_col_i][m_i] = min_cost + cost_table[crr][min_col][m_i];\n            // if (row_i == 2 && m_i == 0) \n            //   cout << cost_table[next][n_col_i][m_i] << endl; \n          }\n        }\n      }\n\n      // big jump from bank\n      if (row_i == 1 && m > 0) {\n        loop(10, n_col_i) {\n          if (slip_i[next][n_col_i] == -1) break;\n          cost_table[next][n_col_i][m - 1] = 0;\n        }\n      }\n\n      // big jump\n      if (row_i < 2) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop_from_to(1, m, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, p_col_i) {\n            if (slip_i[prev][p_col_i] == -1) break;\n            if (cost_table[prev][p_col_i][m_i] == -1) continue;\n            int cost = (slip_i[prev][p_col_i] - slip_i[next][n_col_i]) * \n              (slip[prev][p_col_i] + slip[next][n_col_i]);\n            if (cost < 0) cost = -cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = p_col_i;\n            }\n          }\n          if (min_cost != -1) {\n            int prev_cost = cost_table[prev][min_col][m_i];\n            // cout << \"col\" << n_col_i << \"prev cost:\" << prev_cost << endl;\n            // cout << \"col: \" << n_col_i << \", m: \" << m_i << endl;\n            if (cost_table[next][n_col_i][m_i - 1] == -1 ||\n                cost_table[next][n_col_i][m_i - 1] > prev_cost) {\n              cost_table[next][n_col_i][m_i - 1] = min_cost + prev_cost;\n            }\n          }\n          // int prev_cost = cost_table[prev][min_col][m_i];\n          // if (prev_cost != -1) min_cost += prev_cost;\n          // assign_if_smaller(cost_table[next][n_col_i][m_i - 1], min_cost);\n        }\n      }\n\n    }\n\n    // // !debug\n    // cout << \"row: \" << n - 1 << endl;\n    // loop(10, i) {\n    //   if (slip_i[(n - 1) % 3][i] == -1) break;\n    //   loop(m + 1, j) {\n    //     cout << cost_table[(n - 1) % 3][i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n\n    long min_cost = COST_LIMIT;\n    loop(10, i) {\n      loop(m + 1, j) {\n        int cost = cost_table[(n - 1) % 3][i][j];\n        if (cost == -1) continue;\n        assign_if_smaller(min_cost, cost);\n      }\n    }\n\n    if (n > 1)\n    {\n      loop(10, i) {\n        loop_from_to(1, m, j) {\n          int cost = cost_table[(n - 2) % 3][i][j];\n          if (cost == -1) continue;\n          assign_if_smaller(min_cost, cost);\n        }\n      }\n    }\n\n    cout << min_cost << endl;\n\n    // free cost table\n    loop(3, i) {\n      loop(10, j) delete cost_table[i][j];\n      delete cost_table[i];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 1005\n#define N 155\n#define S 85\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[S][N][M];\n\nint dijkstra(int sy,int sx){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<S;i++)\n    for(int j=0;j<n;j++)\n      for(int l=0;l<n;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  for(int i=0;i<node[n-2].size();i++)\n    for(int j=0;j<m;j++)\n      res=min(res,d[j][n-2][node[n-2][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 155\n#define MAX_K 15\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct State {\n    int dng, x, y, m;\n    State(){}\n    State(int dng, int x, int y, int m) :\n        dng(dng), x(x), y(y), m(m) {}\n\n    bool operator < (const State &s) const {\n        return dng > s.dng;\n    }\n};\n\nint main()\n{\n    int N, M, K, x, d;\n    while (cin >> N >> M, N) {\n        vector<pii> G[MAX_N];\n        for (int i = 0; i < N; i++) {\n            cin >> K;            \n            for (int j = 0; j < K; j++) {\n                cin >> x >> d; \n                G[i].push_back(pii(x, d));\n            }\n        }\n        G[N].push_back(pii(0, 0));\n        \n        int dn[MAX_N][MAX_K][MAX_N];\n        for (int i = 0; i < MAX_N; i++) {\n            for (int j = 0; j < MAX_K; j++) {\n                for (int k = 0; k < MAX_N; k++) {\n                    dn[i][j][k] = INF;\n                }\n            }\n        }\n        \n        priority_queue<State> Q;\n        for (int i = 0; i < 2; i++) {\n            int size = G[i].size();\n            int nm = (i == 1 ? M - 1 : M);\n            for (int j = 0; j < size; j++) {\n                Q.push(State(0, j, i, nm)); \n                dn[i][j][nm] = 0;\n            }\n        }\n                \n        while (!Q.empty()) {\n            State s = Q.top(); Q.pop();\n            int y = s.y, x = s.x, m = s.m;\n            int dng = G[y][x].second;\n            x = G[y][x].first;\n            if (y == N) {\n                cout << s.dng << endl;\n                break;\n            }\n\n            for (int i = 1; i <= 2; i++) {\n                int ny = y + i;\n                if (ny > N) continue;                \n                for (int j = 0; j < (int)G[ny].size(); j++) {\n                    int nx = G[ny][j].first, nd = G[ny][j].second;\n                    int nm = (i == 2 ? m - 1 : m);\n                    int ncost = s.dng + (ny < N ? (dng + nd) * abs(x - nx) : 0);\n\n                    if (nm >= 0 && ncost < dn[ny][j][nm]) {\n                        dn[ny][j][nm] = ncost;\n                        Q.push(State(ncost, j, ny, nm));\n                    }\n                }\n            }\n           \n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n#include<utility>\nusing namespace std;\n#define INF (1<<30)\n\nint dp[150][10][150/2+1];\nvector<pair<int,int> > stone[150];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tfor(int h=0;h<n;h++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tstone[h].resize(k);\n\t\t\tfor(int i=0;i<k;i++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>stone[h][i].first>>stone[h][i].second;\n\t\t\t}\n\t\t}\n\t\tfill_n((int*)dp,sizeof(dp)/sizeof(int),INF);\n\t\tfor(int i=0;i<stone[0].size();i++)dp[0][i][0]=0;\n\t\tfor(int i=0;i<stone[1].size();i++)dp[1][i][1]=0;\n\t\tint ans=INF;\n\t\tfor(int h=0;h<n;h++){\n\t\t\tfor(int i=0;i<stone[h].size();i++){\n\t\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\t\tint v=dp[h][i][j];\n\t\t\t\t\tif(v==INF)continue;\n\t\t\t\t\tif(h+1<n){\n\t\t\t\t\t\tfor(int k=0;k<stone[h+1].size();k++){\n\t\t\t\t\t\t\tdp[h+1][k][j]=min(dp[h+1][k][j]\n\t\t\t\t\t\t\t\t,v+(stone[h][i].second+stone[h+1][k].second)*abs(stone[h][i].first-stone[h+1][k].first));\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}else ans=min(ans,v);\n\t\t\t\t\tif(h+2<n && j<m){\n\t\t\t\t\t\tfor(int k=0;k<stone[h+2].size();k++){\n\t\t\t\t\t\t\tdp[h+2][k][j+1]=min(dp[h+2][k][j+1]\n\t\t\t\t\t\t\t\t,v+(stone[h][i].second+stone[h+2][k].second)*abs(stone[h][i].first-stone[h+2][k].first));\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}else if(j<m)ans=min(ans,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, m;\nint danger[155][1010];\nvector<int> X[155];\nll dp[155][11][80];\n\nconst ll inf = 1LL << 55;\n\nll solve(int col, int row, int jump)\n{\n  if(col >= n-1) return 0;\n  if(col >= n-2 && jump < m) return 0;\n  if(jump > m) return inf;\n  if(~dp[col][row][jump]) return dp[col][row][jump];\n  ll ret = inf;\n  for(int i = 0; i < X[col+1].size(); i++){\n    ll D = (danger[col][X[col][row]] + danger[col+1][X[col+1][i]]) * abs(X[col][row] - X[col+1][i]);\n    ret = min(ret, solve(col + 1, i, jump) + D);\n  }\n  if(jump < m && col < n-2){\n    for(int i = 0; i < X[col+2].size(); i++){\n      ll D = (danger[col][X[col][row]] + danger[col+2][X[col+2][i]]) * abs(X[col][row] - X[col+2][i]);\n      ret = min(ret, solve(col + 2, i, jump + 1) + D);\n    }\n  }\n  return dp[col][row][jump] = ret;\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 155; i++) X[i].clear();\n    for(int i = 0; i < 155; i++){\n      for(int j = 0; j < 11; j++) danger[i][j] = -1;\n    }\n    for(int i = 0; i < n; i++){\n      int k; cin >> k;\n      for(int j = 0; j < k; j++){\n\tint x, d;\n\tcin >> x >> d;\n\t--x;\n\tdanger[i][x] = d;\n\tX[i].push_back(x);\n      }\n    }\n\n    memset(dp, -1, sizeof(dp));\n    ll ans = inf;\n    for(int i = 0; i < X[0].size(); i++){\n      ans = min(ans, solve(0, i, 0));\n    }\n    if(m > 0 && n > 1){\n      for(int i = 0; i < X[1].size(); i++){\n\tans = min(ans, solve(1, i, 1));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 155\n#define M 15\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][N];\n\nint dijkstra(int sy,int sx){\n  int d[N][N][M];\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int l=0;l<n;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x));\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)node[i].clear();\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <queue>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-9\n\nint dp[80][160][160];\nvector<pair<int,int> > vp[160];\n\nint main(){\n\tint n,m;\n\t\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\tint ans = INT_MAX;\n\t\trep(i,80)rep(j,160)rep(k,160)dp[i][j][k]=INT_MAX;\n\t\t\n\t\trep(i,n){\n\t\t\tvector<pair<int,int> > tmp;\n\t\t\tint sz; scanf(\"%d\",&sz);\n\t\t\trep(j,sz){\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\t//printf(\"a,b , %d,%d\\n\",a,b);\n\t\t\t\ttmp.push_back( make_pair(a,b) );\n\t\t\t}\n\t\t\tvp[i] = tmp;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tif( i==0 ){\n\t\t\t\trep(j,vp[0].size()){\n\t\t\t\t\tdp[0][i][vp[0][j].first] = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(l,m+1){\n\t\t\t\t\trep(j,vp[i-1].size())if( dp[l][i-1][vp[i-1][j].first]!=INT_MAX ){ // src 1step\n\t\t\t\t\t\trep(k,vp[i].size()){ //dest\n\t\t\t\t\t\t\tint c = (vp[i-1][j].second+vp[i][k].second) * abs(vp[i-1][j].first-vp[i][k].first);\n\t\t\t\t\t\t\tdp[l][i][vp[i][k].first] = min(dp[l][i][vp[i][k].first], dp[l][i-1][vp[i-1][j].first]+c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( i>1 && l<m ){\n\t\t\t\t\t\trep(j,vp[i-2].size())if( dp[l][i-2][vp[i-2][j].first]!=INT_MAX ){ // src 2step\n\t\t\t\t\t\t\trep(k,vp[i].size()){ //dest\n\t\t\t\t\t\t\t\tint c = (vp[i-2][j].second+vp[i][k].second) * abs(vp[i-2][j].first-vp[i][k].first);\n\t\t\t\t\t\t\t\tdp[l+1][i][vp[i][k].first] = min(dp[l+1][i][vp[i][k].first], dp[l][i-2][vp[i-2][j].first]+c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,n){\n\t\t\trep(j,10){\n\t\t\t\trep(k,m+1){\n\t\t\t\t\tprintf(\"dp[%d][%d][%d] : %d\\n\",k,i,j,dp[k][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\trep(l,m+1){\n\t\t\trep(i,vp[n-1].size()){\n\t\t\t\tans = min(ans, dp[l][n-1][vp[n-1][i].first]);\n\t\t\t}\n\t\t}\n\t\t//rep(i,m+1)rep(j,st_sz[n])\n\t\t//\tans = min(ans,dp[i][n][j]);\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nll d[100][151][1001];\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0) break;\n\tvector< vector< pair<int,int> > > coor(n);\n\tqueue< pair<int,int> > qxy;\n\tqueue<int> qm;\n\tqueue<int> qs;\n\tmemset(d,-1,sizeof(d));\n\tll ans = 100000000;\n\tREP(i,n){\n\t    int k;\n\t    cin >> k;\n\t    REP(j,k){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcoor[i].PB( pair<int,int>(a,b));\n\t\tif(i==0){\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m);\n\t\t    qs.push(b);\n\t\t    d[m][i][a] = 0;\n\t\t}\n\t    }\n\t}\n\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int tm = qm.front();\n\t    int ts = qs.front();\n\t    qxy.pop();\n\t    qm.pop();\n\t    qs.pop();\n//\t    printf(\"d[tm][y][x] = %d\\n\",d[tm][y][x]);\n\t    if(y+1 >= n || (tm > 0 && y+2 >= n)){\n\t\tans = min(ans,d[tm][y][x]);\n\t\tcontinue;\n\t    }\n\t    REP(i,coor[y+1].size()){\n\t\tint nx = coor[y+1][i].first;\n\t\tint ny = y+1;\n\t\tint slip = coor[y+1][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(d[tm][ny][nx] < 0 || d[tm][ny][nx] > v){\n\t\t    d[tm][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t    REP(i,coor[y+2].size()){\n\t\tint nx = coor[y+2][i].first;\n\t\tint ny = y+2;\n\t\tint slip = coor[y+2][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(tm>0 && (d[tm-1][ny][nx] < 0 || d[tm-1][ny][nx] > v )){\n\t\t    d[tm-1][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm-1);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1010;\nint dp[MAX_X][160][80];\n\nint main()\n{\n\tifstream ifs(\"E:\\\\programing\\\\C C++\\\\data\\\\data\\\\2008-ho-t4-in10\");\n\tint n, m;\n\twhile(ifs >> n >> m && n)\n\t{\n\t\trep(x,MAX_X) rep(y,n) rep(d,m+1) dp[x][y][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\trep(i,MAX_X)rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tifs >> s;\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tifs >> x >> d;\n\t\t\t\tr[x][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[x][0][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[x][1][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++) for(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ÊíWv\n\t\t\t\trep(nx, MAX_X) rep(d, m+1) //ë¯xðiÁÄ¢¯Î} èÂ\n\t\t\t\t\tif(dp[nx][y-1][d] != INF)\n\t\t\t\t\t\tchmin(dp[x][y][d], dp[nx][y-1][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// êiÆÎµ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[nx][y-2][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[x][y][d-1], dp[nx][y-2][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\n\t\tint res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[x][n-1][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[x][n-2][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> stone[155];\nint dp[155][15][100];\nsigned main(void)\n{\n  while(true) {\n  int n, m;\n  cin >> n >> m;\n  if(!n) break;\n  REP(i, n) {\n    int k;\n    cin >> k;\n    stone[i].clear();\n    REP(j, k) {\n      int x, d;\n      cin >> x >> d;\n      stone[i].PB({x, d});\n    }\n  }\n  memset(dp, 0x3f, sizeof(dp));\n  REP(i, stone[0].size()) dp[0][i][0] = 0;\n  REP(i, stone[1].size()) dp[1][i][1] = 0;\n  // i??????j??? ???????£???°??????k????????£???\n  REP(i, n-1) REP(j, stone[i].size()) REP(k, m+1) {\n    if(dp[i][j][k] == 0x3f3f3f3f) continue;\n    // (i, j)?????????????£???°??????????????¨???\n    // dp[i+1][l][k] ??? min??§??´??°\n    REP(l, stone[i+1].size()) {\n      int dif = abs(stone[i][j].first - stone[i+1][l].first);\n      int tmp = dif*(stone[i][j].second + stone[i+1][l].second);\n      chmin(dp[i+1][l][k], dp[i][j][k] + tmp);\n    }\n\n    // (i, j)?????????????£???°???????????¨???\n    // dp[i+2][l][k+1] ??? min??§??´??°\n    if(i == n-2 || k == m) continue;\n    REP(l, stone[i+2].size()) {\n      int dif = abs(stone[i][j].first - stone[i+2][l].first);\n      int tmp = dif*(stone[i][j].second + stone[i+2][l].second);\n      chmin(dp[i+2][l][k+1], dp[i][j][k] + tmp);\n    }\n  }\n\n  // n-1?????????min???n-2????????§m-1??\\??????min\n  int ret = INF;\n  REP(i, stone[n-1].size()) REP(k, m+1) chmin(ret, dp[n-1][i][k]);\n  REP(i, stone[n-2].size()) REP(k, m) chmin(ret, dp[n-2][i][k]);\n  cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    int N,M,K,k1,k2,MIN,ANS;\n    while(scanf(\"%d%d\",&N,&M),N + M)\n    {\n        int field[160][4] = {0},dp[160][4][100] = {0};\n        ANS = 10000000;\n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\",&K);\n            for(int j = 0; j < K; j++)\n            {\n                scanf(\"%d%d\",&k1,&k2);\n                field[i + 1][k1 - 1] = k2;\n            }\n        }\n        /*for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 2; i < N + 1; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    if(field[i][k] != 0)\n                    {\n                        dp[i][k][j] = 10000000;\n                        if(j == 0)\n                        {\n                            for(int l = 0; l < 4; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[i][k][0] = min(dp[i][k][0],dp[i - 1][l][0] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                        else if(i >= j * 2)\n                        {\n                            for(int l = 0; l < 4; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 1][l][j] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                                if(field[i - 2][l] != 0 || i - 2 == 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 2][l][j - 1] + (field[i - 2][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /*for(int i = 0; i < N + 1; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        for(int i = 0; i < N + 1; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    printf(\"%2d\",dp[i][k][j]);\n                }\n                printf(\" / \");\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 0; i < M + 1; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                if(field[N][j] != 0)\n                {\n                    ANS = min(ANS,dp[N][j][i]);\n                }\n                if(i < M && field[N - 1][j] != 0)\n                {\n                    ANS = min(ANS,dp[N - 1][j][i]);\n                }\n            }\n        }\n        printf(\"%d\\n\",ANS);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<vector<int>> xs(n), ds(n);\n\t\tvector<vector<vector<int>>> dp(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d; x--;\n\t\t\t\txs[i].push_back(x);\n\t\t\t\tds[i].push_back(d);\n\t\t\t\tdp[i].push_back(vector<int>(m + 1, i == 0 ? 0 : INF));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < (int)xs[i - 1].size(); j++) {\n\t\t\t\tfor (int k = 0; k < (int)xs[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l <= m; l++) {\n\t\t\t\t\t\tdp[i][k][l] = min(dp[i][k][l], dp[i - 1][j][l] + abs(xs[i][k] - xs[i - 1][j]) * (ds[i][k] + ds[i - 1][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 1) continue;\n\t\t\tfor (int j = 0; j < (int)xs[i - 2].size(); j++) {\n\t\t\t\tfor (int k = 0; k < (int)xs[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\t\tdp[i][k][l + 1] = min(dp[i][k][l + 1], dp[i - 2][j][l] + abs(xs[i][k] - xs[i - 2][j]) * (ds[i][k] + ds[i - 2][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (auto last : dp[n - 1]) {\n\t\t\tfor (auto val : last) {\n\t\t\t\tres = min(res, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Stone{\n  int x,d;\n  Stone(){}\n  Stone(int x, int d):x(x),d(d){}\n};\n\nint danger(Stone &a, Stone &b){ return abs(a.x-b.x)*(a.d+b.d);}\n\nconst int INF = 1<<29;\nint N,M;\nvector<Stone>s[256];\nint dp[160][16][80];\n\nint main(){\n  while(scanf(\"%d%d\", &N,&M) && N||M){\n    for(int i=0;i<256;i++) s[i].clear();\n    for(int i=0;i<N;i++){\n      int k; scanf(\"%d\", &k);\n      while(k--){\n\tint x,d; scanf(\"%d%d\",&x,&d);\n\ts[i].push_back(Stone(x,d));\n      }\n    }\n\n    for(int i=0;i<160;i++) for(int j=0;j<16;j++) for(int k=0;k<80;k++) dp[i][j][k] = INF;\n    for(int j=0;j<2;j++) for(int i=0;i<s[j].size();i++) dp[0][i][M-j] = 0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k<s[i+1].size();k++){\n\t  for(int m=0;m<=M;m++) \n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m]+danger(s[i][j],s[i+1][k]));\n\t}\n\tfor(int k=0;k<s[i+2].size();k++){\n\t  for(int m=1;m<=M;m++)\n\t    dp[i+2][k][m-1] = min(dp[i+2][k][m-1], dp[i][j][m]+danger(s[i][j],s[i+2][k]));\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=0;i<s[N-1].size();i++) for(int m=0;m<=M;m++) res = min(res, dp[N-1][i][m]);\n    for(int i=0;i<s[N-2].size();i++) for(int m=1;m<=M;m++) res = min(res, dp[N-2][i][m]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n\n      int slip[152][12] = {{0}};\n      int flag[152][12][78] = {{{0}}};\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n\n      if(n == 1 && m == 1){printf(\"0\\n\"); continue;}\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n            flag[1][i][0] = 1;\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n            flag[2][i][1] = 1;\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s] = 1;\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n               if(p.f.f != 0) flag[p.f.s+2][i][p.s.s+1] = 1;\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (2000000001)\n#define X first\n#define D second\ntypedef pair<int,int> P;\nint N,M;\nvector<P> R[152];\nint dp[151][11][1001];\ninline int ab(int a){ return a>0?a:-a; }\nint solve(int no,int id,int m){\n  if( no >= N ) return 0;\n  if(dp[no][id][m]!=-1) return dp[no][id][m];\n  int ret=INF;\n  for(int i=0;i<(int)R[no].size();i++){\n    ret = min(solve(no+1,i,m)+(R[no-1][id].D+R[no][i].D)*ab(R[no-1][id].X-R[no][i].X),ret);\n  }\n  if(m < M){\n    if(no + 1 >= N)\n      ret = 0;\n    else\n      for(int i=0;i<(int)R[no+1].size();i++){\n\tret = min(solve(no+2,i,m+1)+(R[no-1][id].D+R[no+1][i].D)*ab(R[no-1][id].X-R[no+1][i].X),ret);\n    }\n  }\n  //  printf(\"%d %d %d %d  %d\\n\",no,id,m,ret);\n  return dp[no][id][m]=ret;\n}\nint main(){\n  while(1){\n    scanf(\"%d %d\",&N,&M);\n    if(!N&&!M) break;\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<N;i++){\n      int k;\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tint x,d;\n\tscanf(\"%d %d\",&x,&d);\n\tR[i].push_back(P(x,d));\n\t///\tprintf(\"%d %d\\n\",R[i][j].X,R[i][j].D);\n      }\n    }\n    int res=INF;\n    for(int i=0;i<(int)R[0].size();i++){\n      res = min(res,solve(1,i,0));\n    }\n    if(M>0){\n      for(int i=0;i<(int)R[1].size();i++){\n\tres = min(res,solve(2,i,1));\n      }      \n    }\n    printf(\"%d\\n\",res);\n    for(int i=0;i<N;i++) R[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint dp[150][11][80];\nconst int INF = 1<<30;\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n+m){\n        memset(dp, 0, sizeof(dp));\n        vector<pair<int,int>> v[n];\n        for(int i = 0; i < n; i++){\n            int k;  cin >> k;\n            while(k-- > 0){\n                int x, d; cin >> x >> d;\n                v[i].push_back({x, d});\n                for(int j = 0; j <= m; j++){\n                    dp[i][k][j] = INF;\n                }\n            }\n        }\n        \n        for(int j = 0; j < v[0].size(); j++){\n            dp[0][j][m] = 0;\n        }\n        for(int j = 0; j < v[1].size(); j++){\n            if(m)   dp[1][j][m-1] = 0;\n        }\n        \n        int ans = INF;\n        for(int i = 0; i < n-1; i++){\n            for(int from = 0; from < v[i].size(); from++){\n                for(int mm = m; mm >= 0; mm--){\n                    if(dp[i][from][mm] == INF)   continue;\n                    for(int to = 0; to < v[i+1].size(); to++){\n                        int cost = abs(v[i][from].first-v[i+1][to].first)*(v[i][from].second+v[i+1][to].second);\n                        dp[i+1][to][mm] = min(dp[i+1][to][mm], dp[i][from][mm]+cost);\n                        if(i+1 == n-1)  ans = min(ans, dp[i+1][to][mm]);\n                    }\n                    if(mm == 0)  continue;\n                    if(i == n-2){\n                        ans = min(ans, dp[i][from][mm]);\n                        continue;\n                    }\n                    for(int to = 0; to < v[i+2].size(); to++){\n                        int cost = abs(v[i][from].first-v[i+2][to].first)*(v[i][from].second+v[i+2][to].second);\n                        dp[i+2][to][mm-1] = min(dp[i+2][to][mm-1], dp[i][from][mm]+cost);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k,l;\n  int a[10][150][75],x[10][150],d[10][150],m,n;\n  int mn;\n  while(cin>>n>>m&&n+m){\n    memset(x,-1,sizeof(x));\n    memset(d,-1,sizeof(d));\n    for(i=0;i<n;i++){\n      cin>>k;\n      for(j=0;j<k;j++){\n\tint t,u;\n\tcin>>t>>u;\n\tt--;\n\tx[j][i]=t;\n\td[j][i]=u;\n      }\n    }\n    memset(a,-1,sizeof(a));\n    for(i=0;x[i][0]!=-1;i++)\n      a[i][0][0]=0;\n    if(m){\n      for(i=0;x[i][1]!=-1;i++)\n\ta[i][1][1]=0;\n    }\n    for(i=0;i<n-2;i++){\n      for(j=0;x[j][i]!=-1;j++){\n\tfor(k=0;k<n/2+3;k++){\n\t  if(a[j][i][k]!=-1){\n\t    for(l=0;x[l][i+1]!=-1;l++){\n\t      if(a[l][i+1][k]==-1||a[l][i+1][k]>a[j][i][k]+(d[j][i]+d[l][i+1])*abs(x[j][i]-x[l][i+1]))\n\t\ta[l][i+1][k]=a[j][i][k]+(d[j][i]+d[l][i+1])*abs(x[j][i]-x[l][i+1]);\n\t    }\n\t    if(k!=m){\n\t      for(l=0;x[l][i+2]!=-1;l++){\n\t\tif(a[l][i+2][k+1]==-1||a[l][i+2][k+1]>a[j][i][k]+(d[j][i]+d[l][i+2])*abs(x[j][i]-x[l][i+2]))\n\t\t  a[l][i+2][k+1]=a[j][i][k]+(d[j][i]+d[l][i+2])*abs(x[j][i]-x[l][i+2]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    mn=-1;\n    for(i=0;x[i][n-2]!=-1;i++){\n      for(j=0;j<n/2+3;j++){\n\tif(a[i][n-2][j]!=-1){\n\t  if(j==m){\n\t    for(k=0;x[k][n-1]!=-1;k++){\n\t      if(a[k][n-1][j]==-1||a[k][n-1][j]>a[i][n-2][j]+(d[i][n-2]+d[k][n-1])*abs(x[i][n-2]-x[k][n-1]))\n\t\ta[k][n-1][j]=a[i][n-2][j]+(d[i][n-2]+d[k][n-1])*abs(x[i][n-2]-x[k][n-1]);\n\t    }\n\t  }else if(mn==-1||mn>a[i][n-2][j]){\n\t    mn=a[i][n-2][j];\n\t  }\n\t}\n      }\n    }\n    for(i=0;x[i][n-1]!=-1;i++){\n      for(j=0;j<n/2+3;j++){\n\tif(a[i][n-1][j]!=-1){\n\t  if(mn==-1||mn>a[i][n-1][j])\n\t    mn=a[i][n-1][j];\n\t}\n      }\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint flag[152][12][78] = {{{0}}};\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      int slip[152][12] = {{0}};\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n\n      memset(flag,0,sizeof(flag));\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n            flag[1][i][0] = 1;\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n            flag[2][i][1] = 1;\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         if(flag[p.f.s][p.s.f][p.s.s] == 1) continue;\n         flag[p.f.s][p.s.f][p.s.s] = 1;\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nll n;\nstruct P {\n\tll slip, place;\n};\nP a[152][10];\nll dp[150][10][1000];\nll siz[152];\nll solve(ll i, ll j,ll m) {\n\tif (i == n) return 0;\n\tll sum = 80000000000000000;\n\tfor (ll z = 0; z < siz[i+1]; z++) {\n\t\tll res = (a[i + 1][z].place - a[i][j].place);\n\t\tres = max(res, 0 - res);\n\t\tres *= (a[i + 1][z].slip + a[i][j].slip);\n\t\tif (dp[i + 1][z][m] != -1) {\n\t\t\tsum = min(sum, res + dp[i + 1][z][m]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + 1][z][m] = solve(i + 1, z, m)));\n\t\t}\n\t}\n\tif (m > 0&&i+1!=n) {\n\t\tfor (ll z = 0; z < siz[i+2]; z++) {\n\t\t\tll res = (a[i + 2][z].place - a[i][j].place);\n\t\t\tres = max(res, 0 - res);\n\t\t\tres *= (a[i + 2][z].slip + a[i][j].slip);\n\t\t\tif (dp[i + 2][z][m-1] != -1) {\n\t\t\t\tsum = min(sum, res + dp[i + 2][z][m-1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = min(sum, res + (dp[i + 2][z][m-1] = solve(i + 2, z, m-1)));\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tll m;\n\twhile (cin >> n >> m) {\n\t\tfor (ll i = 1; i <= n; i++) {\n\t\t\tll k;\n\t\t\tcin >> k;\n\t\t\tsiz[i] = k;\n\t\t\tfor (ll j = 0; j < k; j++) {\n\t\t\t\tcin >> a[i][j].place >> a[i][j].slip;\n\t\t\t\tfor (ll z = 0; z <= m; z++)\n\t\t\t\t\tdp[i][j][z] = -1;\n\t\t\t}\n\t\t}\n\t\tll sum = 80000000000000;\n\t\tfor (ll i = 0; i < siz[1]; i++) {\n\t\t\tsum = min(sum, solve(1, i, m));\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<11;i++){\n\t\t\tve[0].push_back(MP(i,0));\n\t\t\tdp[T][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[0].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=min(i/2,M);j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans;\nLL V[160][1010];\nLL mem[160][501][80];\n\nLL cal(int y,int x,int m){\n    LL res=INF;\n    if(mem[y][x][m]!=-1)return mem[y][x][m];\n    if(y>=N)return 0;\n    if(y==0){\n        FOR(i,1,1000){\n            if(V[y+1][i]!=INF)\n            res=cal(y+1,i,m);\n        }\n    }\n    else{\n        if(V[y][x]!=INF){\n            FOR(i,1,1000){\n                    if(m>0&&V[y+1][i]!=INF&&V[y+2][i]!=INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,min(cal(y+2,i,m-1)+d2,res));\n                    }\n                    else if(V[y+1][i]!=INF&&V[y+2][i]==INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,res);\n                    }\n                    else if(V[y+1][i]==INF&&V[y+2][i]!=INF&&m>0){\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+2,i,m)+d2,res);\n                    }\n            }\n        }\n    }\n    return mem[y][x][m]=res;\n}\n\nint main(){\n    cin>>N>>M;\n    memset(mem,-1,sizeof(mem));\n    rep(i,151)rep(j,1001)V[i][j]=INF;\n    FOR(i,1,N){\n        LL t;\n        cin>>t;\n        rep(j,t){\n            LL x,k;\n            cin>>x>>k;\n            V[i][x]=k;\n        }\n    }\n    ans=cal(0,0,M);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF (1000000000)\n\nint dp[151][10][77];\n\ntypedef struct {\n\tint slip;\n\tint coor;\n} ST;\n\nint main(void)\n{\n\tint n, m;\n\tint k[151];\n\tST st[151][10];\n\tint ans;\n\t\n\t\n\tk[150] = 0;\n\tfor (int i = 0; i < 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tfor (int l = 0; l < 77; l++){\n\t\t\t\tdp[i][j][l] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &k[i]);\n\t\tfor (int j = 0; j < k[i]; j++){\n\t\t\tscanf(\"%d%d\", &st[i][j].coor, &st[i][j].slip);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < k[0]; i++){\n\t\tdp[0][i][0] = 0;\n\t}\n\tfor (int i = 0; i < k[1]; i++){\n\t\tdp[1][i][1] = 0;\n\t}\n\t\n\tfor (int i = 0; i < n - 1; i++){\n\t\tfor (int j = 0; j < k[i]; j++){\n\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\tfor (int h = 0; h < k[i + 1]; h++){\n\t\t\t\t\tdp[i + 1][h][l] = min(dp[i + 1][h][l], dp[i][j][l] + ((st[i][j].slip + st[i + 1][h].slip) * abs(st[i][j].coor - st[i + 1][h].coor)));\n\t\t\t\t}\n\t\t\t\tfor (int h = 0; h < k[i + 2]; h++){\n\t\t\t\t\tdp[i + 2][h][l + 1] = min(dp[i + 2][h][l + 1], dp[i][j][l] + (st[i][j].slip + st[i + 2][h].slip) * abs(st[i][j].coor - st[i + 2][h].coor));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans = INF;\n\tfor (int i = 0; i < k[n - 1]; i++){\n\t\tfor (int j = 0; j <= m; j++){\n\t\t\tans = min(ans, dp[n - 1][i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < k[n - 2]; i++){\n\t\tfor (int j = 0; j < m; j++){\n\t\t\tans = min(ans, dp[n - 2][i][j]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<climits>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<P> >v(155);\t\nvector<vector<vector<int> > >dp(155);\nint F(int n1,int k1,int n2,int k2)\n{\n\tP p=v[n1][k1],q=v[n2][k2];\n\treturn (p.first+q.first)*abs(p.second-q.second);\n}\nint main()\n{\n\tint n,m,k,x,d,i,j,l;\n\twhile(scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tfor(i=0;i<155;++i)v[i].clear(),dp[i].clear();\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&k);\n\t\t\tdp[i].resize(k);\n\t\t\tfor(j=0;j<k;++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\",&x,&d);\n\t\t\t\tv[i].push_back(P(d,x));\n\t\t\t\tdp[i][j].resize(m+1);\n\t\t\t\tfill(dp[i][j].begin(),dp[i][j].end(),INT_MAX/4);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<v[0].size();++i)\n\t\t\tdp[0][i][m]=0;\n\t\tif(m)\n\t\t\tfor(i=0;i<v[1].size();++i)\n\t\t\t\tdp[1][i][m-1]=0;\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tfor(j=0;j<dp[i].size();++j)\n\t\t\t{\n\t\t\t\tfor(l=0;l<dp[i+1].size();++l)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<=m;++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tint&r=dp[i+1][l][k];\n\t\t\t\t\t\tr=min(r,dp[i][j][k]+F(i,j,i+1,l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(l=0;l<dp[i+2].size();++l)\n\t\t\t\t{\n\t\t\t\t\tfor(k=1;k<=m;++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tint&r=dp[i+2][l][k-1];\n\t\t\t\t\t\tr=min(r,dp[i][j][k]+F(i,j,i+2,l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=INT_MAX;\n\t\tfor(j=0;j<dp[n-1].size();++j)\n\t\t\tfor(k=0;k<=m;++k)\n\t\t\t\tres=min(res,dp[n-1][j][k]);\n\t\tfor(j=0;j<dp[n-2].size();++j)\n\t\t\tfor(k=1;k<=m;++k)\n\t\t\t\tres=min(res,dp[n-2][j][k]);\n\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 1000000000\nint n,m;\nint d[77][150][10];\nint r[150][1000];\nint f[150][10];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(i=0;i<n;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\td[k][i][j]=INF;\n\t\t}\n\t\tfor(i=0;i<=c[0];i++){\n\t\t\td[m][0][i]=0;\n\t\t}\n\t\tif(m>=1)for(j=0;j<c[1];j++){\n\t\t\td[m-1][1][j]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][k]=min(d[j][i][k],d[j+1][i-2][l]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][k]=min(d[j][i][k],d[j][i-1][l]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][j]);\n\t\t}\n\t\tfor(i=1;i<=m;i++)for(j=0;j<c[n-2];j++){\n\t\t\tans=min(ans,d[i][n-2][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,m;\n  while(cin >> n >> m, n) {\n    int k[n];\n    int x[n][10];\n    int c[n][10];\n    REP(y,n) {\n      cin >> k[y];\n    \n      REP(i,k[y]) {\n        cin >> x[y][i] >> c[y][i];\n      }\n    }\n  \n    int dp[n][10][m+1];           // dp[i][j][k] = i sÚÌ j ÔÚÌÎÉ¢ÄAcèk ñQsòÎµÌWvªÅ«éÆ«ÌÅ¬ë¯x\n    REP(i,n) REP(j,10) REP(l, m+1) dp[i][j][l] = INF;\n    REP(j,k[0])\n      dp[0][j][m] = 0;\n\n    \n    for (int i=1; i<n; ++i) {\n      REP(j,k[i]) {\n        REP(l,m+1) {\n          REP(jj, k[i-1])         // PsWv\n            dp[i][j][l] = min(dp[i][j][l], dp[i-1][jj][l] + (c[i][j]+c[i-1][jj])*abs(x[i][j]-x[i-1][jj]));\n          if (i>=2 && l>=1) {\n            REP(jj, k[i-2]) {\n              dp[i][j][l-1] = min(dp[i][j][l-1], dp[i-2][jj][l] + (c[i][j]+c[i-2][jj])*abs(x[i][j]-x[i-2][jj]));\n            }\n          }\n        }\n      }\n    }\n    int res = INF;\n    REP(i, k[n-1]) {\n      REP(j,m+1)\n        res = min(res, dp[n-1][i][j]);\n    }\n    REP(i, k[n-2]) {\n      for (int j=1;j<=m; ++j)\n        res= min(res, dp[n-2][i][j]);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m;\nll dp[155][80][11],INF=1000000000000000LL;\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  FOR(i,155) FOR(j,80) FOR(k,11) dp[i][j][k]=INF;\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][j]=0LL;\n  for(int i=n-1;i>0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][k]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][k]=min(dp[i][j][k],dp[i+2][j-1][l]+(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][l]+(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  ll mi=INF;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][i]);\n  if(m) FOR(i,x[2].size()) mi=min(mi,dp[2][m-1][i]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int, int> P;\nint n, m;\nint dp[76][150][10], kosu[150];\nP stone[150][10];\nint main()\n{\n\twhile(cin >> n >> m && n)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> kosu[i];\n\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t{\n\t\t\t\tcin >> stone[i][j].F >> stone[i][j].S;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= m; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tfor(int k = 0; k < kosu[j]; k++)\n\t\t\t\t\tdp[i][j][k] = 1 << 30;\n\t\tfor(int i = 0; i < kosu[0]; i++)\n\t\t\tdp[0][0][i] = 0;\n\t\t\t\tfor(int i = 0; i < n - 1; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 1]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int l = 0; l <= m; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdp[l][i + 1][k] = min((stone[i + 1][k].S + stone[i][j].S) * abs(stone[i + 1][k].F - stone[i][j].F) + dp[l][i][j], dp[l][i + 1][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i + 2 < n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 2]; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor(int l = 0; l < m; l++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdp[l + 1][i + 2][k] = min((stone[i + 2][k].S + stone[i][j].S) * abs(stone[i + 2][k].F - stone[i][j].F) + dp[l][i][j], dp[l + 1][i + 2][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tfor(int i = 0; i <= m; i++)\n\t\t\t\t\tfor(int j = 0; j < kosu[n - 1]; j++)\n\t\t\t\t\t\tans = min(ans, dp[i][n - 1][j]);\n\t\t\t\t\tcout << ans << endl;\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n#define for_each(it,a) for(__typeof a.begin() it = a.begin();it!=a.end();it++)\ntemplate<class T> inline void chmin(T& a, T b) { if( b < a ) a = b; }\n\nint n, m;\nstruct edge{\n  int pos, dang;\n  vector < int >  value;\n  edge( int pos, int dang): pos(pos), dang(dang), value( (n + 1) / 2 + 1, INF){};\n};\nint main(){\n\n  while( cin >> n >> m , n){\n    vector< vector < edge > > info(n);\n\n    for(int i = 0; i < n; i++){\n      int k;\n      cin >> k;\n      for(int j = 0; j < k; j++){\n        int t, d;\n        cin >> t >> d;\n        info[i].push_back( edge( t, d));\n      }\n    }\n    for_each( it, info[0]) it -> value[m] = 0;\n    for_each( it, info[1]) it -> value[m - 1] = 0;\n    int ret = INF;\n    for( int i = 0; i < n; i++){\n      for_each( now, info[i]){\n        for(int j = m; j >= 0; j--){ //ジャンプできる残り回数\n          int& cost = now -> value[j], dang = now -> dang, pos = now -> pos;\n          if( cost == INF) continue;\n          if(j > 0){ //ジャンプしてみる\n            if(i + 2 >= n) chmin( ret, cost);\n            else for_each( next, info[i + 2])\n                   chmin( next -> value[j - 1], cost + (dang + next -> dang) * abs( pos - next -> pos));\n          }\n          if(i + 1 >= n) chmin( ret, cost);\n          else for_each( next, info[i + 1])\n                 chmin( next -> value[j], cost + (dang + next -> dang) * abs( pos - next -> pos));\n        }\n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nconst int INF = LLONG_MAX / 3;\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[152][78]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%lld\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%lld%lld\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e >= 2 && j<b) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 2][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    //dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    /*\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n    */\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef vector <VVI> VVVI;\nconst int inf = 1<<28;\nconst int H = 151;\nconst int W = 1001;\nconst int M = 76;\nVVI D;\nVVVI dp;\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        D = VVI( n, VI( W, inf ) );\n        dp = VVVI( n, VVI( W, VI( m, inf ) ) );\n        for ( int i = 0; i < n; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int x, d;\n                cin >> x >> d;\n                -- x;\n                D[n-i-1][x] = d;\n            }\n        }\n        for ( int i = 0; i < 1001; ++ i ) {\n            if ( D[n-1][i] != inf ) dp[n - 1][i][0] = 0;\n        }\n        for ( int i = n-1; i > 0; -- i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                if ( D[i][j] == inf ) continue;\n                for ( int k = 0; k < W; ++ k ) {\n                    if ( i-2 >= 0 && D[i-2][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            if ( D[i-2][k] != inf && D[i][j] != inf )\n                                dp[i-2][k][l+1] = min( dp[i-2][k][l+1], dp[i][j][l]+(D[i-2][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                    if ( i-1 >= 0 && D[i-1][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            if ( D[i-1][k] != inf && D[i][j] != inf )\n                                dp[i-1][k][l] = min( dp[i-1][k][l], dp[i][j][l]+(D[i-1][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                }\n            }\n        }\n        int answer = inf;\n        for ( int i = 0; i < W; ++ i ) {\n            for ( int j = 0; j <= m; ++ j ) {\n                answer = min( answer, dp[0][i][j] );\n            }\n            for ( int j = 0; j < m; ++ j ) {\n                answer = min( answer, dp[1][i][j] );\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\nconst int INF=100000000;\nint main(void){\n\tint n,m;\n\tint st[152],stx[152][11],sts[152][11];\n\tint dp[152][11][76];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(st,0,sizeof(st));\n\t\tmemset(stx,0,sizeof(stx));\n\t\tmemset(sts,0,sizeof(sts));\n\t\tfor(int i=0;i<152;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst[0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&st[i]);\n\t\t\tfor(int j=0;j<st[i];j++){\n\t\t\t\tscanf(\"%d%d\",&stx[i][j],&sts[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<st[0];i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tif(m>=1)for(int i=0;i<st[1];i++){\n\t\t\tdp[1][i][1]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tfor(int k=0;k<st[i];k++){\n\t\t\t\t\tfor(int l=0;l<st[i-1];l++){\n\t\t\t\t\t\tdp[i][k][j]=min(dp[i][k][j],dp[i-1][l][j]+(sts[i][k]+sts[i-1][l])*abs(stx[i][k]-stx[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=m && i>=2)for(int l=0;l<st[i-2];l++){\n\t\t\t\t\t\tdp[i][k][j+1]=min(dp[i][k][j+1],dp[i-2][l][j]+(sts[i][k]+sts[i-2][l])*abs(stx[i][k]-stx[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<st[n-1];k++){\n\t\t\t\tans=min(ans,dp[n-1][k][j]);\n\t\t\t}\n\t\t\tif(j!=m)for(int k=0;k<st[n-2];k++){\n\t\t\t\tans=min(ans,dp[n-2][k][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll n,m;\nvector<P> rocks[150];\nll k;\nll dp[150][10][77];//dp[i][j][k] rock[i][j]?????????k???????????£??????\nconst ll INF=0xffffffffffff;\nint main()\n{while(1){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(!n) return 0;\n\trep(i,150) rocks[i].clear();\n\tfill(dp[0][0],dp[149][10],INF);\n\trep(i,n){\n\t\tscanf(\"%lld\",&k);\n\t\trep(j,k){\n\t\t\tll x,y;\n\t\t\tscanf(\"%lld%lld\",&x,&y);\n\t\t\tx--;\n\t\t\trocks[i].pb(P(x,y));\n\t\t}\n\t}\n\trep(i,rocks[0].size()){\n\t\tdp[0][i][m]=0;\n\t}\n\trep(i,n-1){\n\t\trep(j,rocks[i].size()){\n\t\t\trep(k,m+1){\n\t\t\t\tif(dp[i][j][k]==INF) continue;\n\t\t\t\t//??????\n\t\t\t\trep(l,rocks[i+1].size()){\n\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+abs(rocks[i][j].fr-rocks[i+1][l].fr)*(rocks[i][j].sc+rocks[i+1][l].sc));\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\tif(k>0&&i<n-2){\n\t\t\t\t\trep(l,rocks[i+2].size()){\n\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],dp[i][j][k]+abs(rocks[i][j].fr-rocks[i+2][l].fr)*(rocks[i][j].sc+rocks[i+2][l].sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\trep(i,rocks[n-1].size()){\n\t\trep(j,m+1){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n, m;\nvector<pair<int, int> > data[150];\nint dp[150][10][76];\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    for(int i=0;i<n+2;i++) data[i].clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      for(int j=0;j<a;j++){\n        int b, c;\n        cin >> b >> c;\n        data[i].push_back(pair<int, int>(b, c));\n      }\n    }\n    fill(dp[0][0], dp[150][0], INF);\n    for(int j=0;j<=m;j++){\n      for(int i=0;i<data[j].size();i++){\n        dp[j][i][m-j] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<10;j++){\n        for(int i1=0;i1<=m;i1++){\n          if(dp[i][j][i1] != INF){\n            for(int l=0;l<=m;l++){\n              if(i+1+l >= n) continue;\n              for(int k=0;k<data[i+1+l].size();k++){\n                dp[i+1+l][k][i1-l] = min(dp[i+1+l][k][i1-l],\n                                   dp[i][j][i1] + (data[i][j].second + data[i+1+l][k].second) *\n                                   (abs(data[i][j].first - data[i+1+l][k].first)));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++){\n      for(int i=0;i<10;i++){\n        for(int k=0;k<=m;k++){\n          ans = min(ans, dp[n-1-j][i][k]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n#define INF (1<<30)\n\nint dp[150][150][150/2+1];\nint stone[150][150];\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tfill_n((int*)dp,sizeof(dp)/sizeof(int),INF);\n\t\tfill_n((int*)dp[0],sizeof(dp[0])/sizeof(int),0);\n\t\tfill_n((int*)stone,sizeof(stone)/sizeof(int),0);\n\t\tfor(int h=0;h<n;h++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int i=0;i<k;i++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tstone[h][x-1]=d;\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int h=0;h<n;h++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(stone[h][i]==0)continue;\t\t\t\n\t\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\t\tint v=dp[h][i][j];\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(h+1==n)ans=min(ans,v);\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[h+1][k][j]=min(dp[h+1][k][j],v+(stone[h][i]+stone[h+1][k])*abs(i-k));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j<m){\n\t\t\t\t\t\t\tif(h+2>=n)ans=min(ans,v);\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tdp[h+2][k][j+1]=min(dp[h+2][k][j+1],v+(stone[h][i]+stone[h+2][k])*abs(i-k));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nstruct state {\n  int sum_danger;\n  int danger;\n  int row, col;\n  int jump;\n  state(int s, int d, int r, int c, int j) : sum_danger(s), danger(d), row(r), col(c), jump(j) {}\n  bool operator<(const state& rhs) const\n  {\n    return sum_danger > rhs.sum_danger;\n  }\n};\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M && N != 0) {\n    vector<vector<pair<int,int> > > g(N);\n    for (int i = 0; i < N; i++) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; j++) {\n        int c, d;\n        cin >> c >> d;\n        g[i].push_back(make_pair(c, d));\n      }\n    }\n\n    vector<vector<vector<int> > > tbl(N);\n    for (int i = 0; i < N; i++) {\n      tbl[i] = vector<vector<int> >(g[i].size(), vector<int>(M+1, numeric_limits<int>::max()));\n    }\n    priority_queue<state> q;\n    for (int i = 0; i < g[0].size(); i++) {\n      q.push(state(0, g[0][i].second, 0, g[0][i].first, 0));\n      tbl[0][i][0] = 0;\n    }\n    for (int i = 0; i < g[1].size(); i++) {\n      q.push(state(0, g[1][i].second, 1, g[1][i].first, 1));\n      tbl[1][i][1] = 0;\n    }\n\n    int ans = numeric_limits<int>::max();\n    while (!q.empty()) {\n      const state s = q.top();\n      q.pop();\n\n      if (s.row+1 == N) {\n        ans = min(ans, s.sum_danger);\n        continue;\n      }\n      // normal jump\n      for (int i = 0; i < g[s.row+1].size(); i++) {\n        const int next_col = g[s.row+1][i].first;\n        const int next_danger = g[s.row+1][i].second;\n        const int d = s.sum_danger + (s.danger + next_danger) * abs(next_col - s.col);\n        if (d < tbl[s.row+1][i][s.jump]) {\n          tbl[s.row+1][i][s.jump] = d;\n          q.push(state(d, next_danger, s.row+1, next_col, s.jump));\n        }\n      }\n      if (s.jump < M && s.row+2 <= N) {\n        if (s.row+2 == N) {\n          ans = min(ans, s.sum_danger);\n        } else {\n          // super jump\n          for (int i = 0; i < g[s.row+2].size(); i++) {\n            const int next_col = g[s.row+2][i].first;\n            const int next_danger = g[s.row+2][i].second;\n            const int d = s.sum_danger + (s.danger + next_danger) * abs(next_col - s.col);\n            if (d < tbl[s.row+2][i][s.jump+1]) {\n              tbl[s.row+2][i][s.jump+1] = d;\n              q.push(state(d, next_danger, s.row+2, next_col, s.jump+1));\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(){\n    const int INF = 1e9 + 7;\n    while(true){\n        int N,M;\n        cin>>N>>M;\n        if(N==0 && M==0) break;\n        vector<P> v[151];//v[i]??????i??????????????±?????°?????£????????????v[i][0],v[i][1],...\n        for(int i=1;i<=N;i++){\n            int a;\n            cin>>a;\n            for(int j=0;j<a;j++){\n                int b,c;\n                cin>>b>>c;\n                v[i].push_back(P(b,c));\n            }\n        }\n        int dp[3][80][151][11];//dp[a][Jump][k][l]??§Jump???????????£???????????¨??????k?????????v[k][l]?????§??\\?????¨??????????????????????°????\n        for(int a=0;a<3;a++){\n            for(int b=0;b<80;b++){\n                for(int c=0;c<151;c++){\n                    for(int d=0;d<11;d++){\n                        if( (c==0||c==1) && b==0 ){\n                            dp[a][b][c][d]=0;\n                        }else if(c==2 && b==1){\n                            dp[a][b][c][d]=0;\n                        }else{\n                            dp[a][b][c][d]=INF;\n                        }\n                    }\n                }\n            }\n        }\n        int ans=INF;\n        for(int i=2;i<=N;i++){//i????????????????????´??°????????????\n            for(int j=0;j<=M;j++){//j????????£??????????????????????????§?????????\n                //?????£???????????????ver.\n                int a=(i+2)%3;\n                for(int l=0;l<v[i].size();l++){\n                    int tmp=INF;\n                    for(int s=0;s<v[i-1].size();s++){\n                        int risk = (v[i][l].second + v[i-1][s].second)*abs(v[i][l].first - v[i-1][s].first);\n                        tmp = min(tmp, dp[a][j][i-1][s]+risk);\n                    }\n                    dp[i%3][j][i][l]=min(dp[i%3][j][i][l],tmp);\n                    if(j<M && i==N-1){\n                        ans=min(ans,tmp);\n                    }\n                    if(j<=M && i==N){\n                        ans=min(ans,tmp);\n                    }\n                }\n                //?????£????????????ver.\n                if(i>2 && j<M){\n                    a=(i+1)%3;\n                    for(int l=0;l<v[i].size();l++){\n                        int tmp=INF;\n                        for(int s=0;s<v[i-2].size();s++){\n                            int risk = (v[i][l].second + v[i-2][s].second)*abs(v[i][l].first - v[i-2][s].first);\n                            tmp = min(tmp, dp[a][j][i-2][s]+risk);\n                        }\n                        dp[i%3][j+1][i][l] = min(tmp,dp[i%3][j][i][l]);\n                        if(j+1<M && i==N-1){\n                            ans=min(ans,tmp);\n                        }\n                        if(j+1<=M && i==N){\n                            ans=min(ans,tmp);\n                        }\n                    }\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\t// your code goes here\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >>m;\n\t\tif(n==0){\n\t\t\treturn 0;\n\t\t}\n\t\tint k[152];\n\t\tint x[152][10],d[152][10];\n\t\tk[0]=1;x[0][0]=0;d[0][0]=0;\n\t\tk[n+1]=1;x[n+1][0]=0;d[n+1][0]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> k[i];\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tcin >> x[i][j] >> d[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r[152][10][76];\n\t\tint mr[152];\n\t\tmr[n+1]=0;mr[n]=0;\n\t\tr[n+1][0][0]=0;\n\t\tfor(int j=0;j<k[n];j++){\n\t\t\tr[n][j][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tmr[i]=mr[i+2]+1;\n\t\t\tif(mr[i]>m){mr[i]=m;}\n\t\t\tfor(int j=0;j<k[j];j++){\n\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\tr[i][j][s]=-1;\n\t\t\t\t}\n\t\t\t\tfor(int jj=0;jj<k[i+1];jj++){\n\t\t\t\t\tint dr=(d[i][j]+d[i+1][jj])*abs(x[i][j]-x[i+1][jj]);\n\t\t\t\t\tif(i==0){dr=0;}\n\t\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\t\tif(r[i][j][s]==-1 || (r[i+1][jj][s]!=-1 && r[i+1][jj][s]+dr<r[i][j][s])){\n\t\t\t\t\t\t\tr[i][j][s]=r[i+1][jj][s]+dr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int jj=0;jj<k[i+2];jj++){\n\t\t\t\t\tint dr=(d[i][j]+d[i+2][jj])*abs(x[i][j]-x[i+2][jj]);\n\t\t\t\t\tif(i==0 || i==n-1){dr=0;}\n\t\t\t\t\tfor(int s=1;s<=mr[i];s++){\n\t\t\t\t\t\tif(r[i][j][s]==-1 || (r[i+2][jj][s-1]!=-1 && r[i+2][jj][s-1]+dr<r[i][j][s])){\n\t\t\t\t\t\t\tr[i][j][s]=r[i+2][jj][s-1]+dr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint rr=-1;\n\t\tfor(int s=0;s<=m;s++){\n\t\t\tif(rr==-1 || (r[0][0][s]!=-1 && r[0][0][s]<rr)){\n\t\t\t\trr=r[0][0][s];\n\t\t\t}\n\t\t}\n\t\tcout << rr << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n#define INF (1000000000)\n#define min(x, y) ((x) < (y) ? (x) : (y))\n\n\nint dp[151][10][77];\n\ntypedef struct {\n\tint slip;\n\tint coor;\n} ST;\n\nint main(void)\n{\n\tint n, m;\n\tint k[151];\n\tST st[151][10];\n\tint ans;\n\t\n\t\n\tk[150] = 0;\n\tfor (int i = 0; i < 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tfor (int l = 0; l < 77; l++){\n\t\t\t\tdp[i][j][l] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &k[i]);\n\t\tfor (int j = 0; j < k[i]; j++){\n\t\t\tscanf(\"%d%d\", &st[i][j].coor, &st[i][j].slip);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < k[0]; i++){\n\t\tdp[0][i][0] = 0;\n\t}\n\tfor (int i = 0; i < k[1]; i++){\n\t\tdp[1][i][1] = 0;\n\t}\n\t\n\tfor (int i = 0; i < n - 1; i++){\n\t\tfor (int j = 0; j < k[i]; j++){\n\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\tfor (int h = 0; h < k[i + 1]; h++){\n\t\t\t\t\tdp[i + 1][h][l] = min(dp[i + 1][h][l], dp[i][j][l] + ((st[i][j].slip + st[i + 1][h].slip) * abs(st[i][j].coor - st[i + 1][h].coor)));\n\t\t\t\t}\n\t\t\t\tfor (int h = 0; h < k[i + 2]; h++){\n\t\t\t\t\tdp[i + 2][h][l + 1] = min(dp[i + 2][h][l + 1], dp[i][j][l] + (st[i][j].slip + st[i + 2][h].slip) * abs(st[i][j].coor - st[i + 2][h].coor));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans = INF;\n\tfor (int i = 0; i < k[n - 1]; i++){\n\t\tfor (int j = 0; j <= m; j++){\n\t\t\tans = min(ans, dp[n - 1][i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < k[n - 2]; i++){\n\t\tfor (int j = 0; j < m; j++){\n\t\t\tans = min(ans, dp[n - 2][i][j]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct P{\n  int x,c;\n  P(int x,int c):x(x),c(c){}\n};\nint n;\nvector<P> s[155];\nint dp[155][11][77];\nint solve(int y,int i,int m){\n  if(y >= n) return 0;\n  if(m && y+1 >= n) return 0;\n  if(dp[y][i][m] >= 0) return dp[y][i][m];\n\n  int ret = 1 << 30;\n  for(int j = 0; j < (int)s[y+1].size(); j++){\n    ret = min(ret,solve(y+1,j,m) + ((y)?(s[y][i].c + s[y+1][j].c) * abs(s[y][i].x - s[y+1][j].x):0));\n  }\n  if(m){\n    for(int j = 0; j < (int)s[y+2].size(); j++){\n      ret = min(ret,solve(y+2,j,m-1) + ((y)?(s[y][i].c + s[y+2][j].c) * abs(s[y][i].x - s[y+2][j].x):0));\n    }\n  }\n  return dp[y][i][m] = ret;\n}\nint main(void){\n  while(1){\n    int m;\n    scanf(\"%d%d\",&n,&m); if(!n) break;\n    memset(dp,-1,sizeof(dp));\n    for(int i = 1; i <= n; i++){\n      s[i].clear();\n      int k;\n      scanf(\"%d\",&k);\n      for(int j = 0; j < k; j++){\n\tint x,d;\n\tscanf(\"%d%d\",&x,&d);\n\ts[i].push_back(P(x,d));\n      }\n    }\n    s[0].push_back(P(0,0));\n    /*\n    for(int i = 0; i < (int)s[0].size(); i++){\n      ret = min(ret,solve(0,i,m));\n    }\n    */\n    printf(\"%d\\n\",solve(0,0,m));\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint N,M;\nint K[200];int X[200][10];int D[200][10];\nint dp[200][10][100];\nint INF=1000*1000*1000;\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(N==0&&M==0)return 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&K[i]);\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tscanf(\"%d%d\",&X[i][j],&D[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<K[0];j++)dp[0][j][0]=0;\n\t\tif(M!=0){\n\t\t\tfor(int j=0;j<K[1];j++)dp[1][j][1]=0;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\t\tint dpijk=dp[i][j][k];\n\t\t\t\t\tif(i!=1&&k!=0){\n\t\t\t\t\t\tfor(int l=0;l<K[i-2];l++){\n\t\t\t\t\t\t\tdpijk=min(dpijk,dp[i-2][l][k-1]+(D[i-2][l]+D[i][j])*abs(X[i-2][l]-X[i][j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l=0;l<K[i-1];l++){\n\t\t\t\t\t\tdpijk=min(dpijk,dp[i-1][l][k]+(D[i-1][l]+D[i][j])*abs(X[i-1][l]-X[i][j]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=dpijk;\n\t\t\t\t\t//printf(\"%d,%d,%d:%d\\n\",i,j,k,dpijk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int j=0;j<K[N-1];j++){\n\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\tans=min(ans,dp[N-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<K[N-2];j++){\n\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\tans=min(ans,dp[N-2][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nconst int inf = 1e9;\n\nint dp[155][15][100];\nint stone[155][15];\n\nsigned main()\n{\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        rep(i, n+1) rep(j, 11) stone[i][j] = inf;\n        rep(i, n+1) rep(j, 11) rep(k, m+1) dp[i][j][k] = inf;\n\n        rep(i, n) {\n            int k; cin >> k;\n            rep(j, k) {\n                int x, d; cin >> x >> d;\n                --x;\n                stone[i][x] = d;\n                if (i == 0) dp[0][x][0] = 0;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 11; ++j) {\n                if (stone[i][j] == inf) continue;\n\n                for (int k = 0; k < m+1; ++k) {\n                    if (k < m) {\n                        if (i + 2 >= n) continue;\n\n                        rep(l, 11) {\n                            if (stone[i + 2][l] == inf) continue;\n\n                            dp[i + 2][l][k + 1] = min(\n                                    dp[i + 2][l][k + 1],\n                                    dp[i][j][k] + (stone[i][j] + stone[i + 2][l]) * abs(j-l)\n                                    );\n                        }\n                    }\n\n                    if (i + 1 >= n) continue;\n\n                    rep(l, 11) {\n                        if (stone[i + 1][l] == inf) continue;\n\n                        dp[i + 1][l][k] = min(\n                                dp[i + 1][l][k],\n                                dp[i][j][k] + (stone[i][j] + stone[i + 1][l]) * abs(j-l)\n                                );\n                    }\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j < m + 1; ++j) {\n                mi = min(mi, dp[n - 1][i][j]);\n            }\n        }\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mi = min(mi, dp[n - 2][i][j]);\n            }\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAX_N = 151;\nconst int MAX_M = MAX_N/2+2;\nconst int MAX_K = 11;\nconst int INF = 1<<28;\nint N, M;\nint K[MAX_N];\nint X[MAX_N][MAX_K], D[MAX_N][MAX_K];\nint T[MAX_N][MAX_K][MAX_M];\n\nint calcCost(int si, int sj, int di, int dj) {\n  return (D[si][sj] + D[di][dj]) * abs(X[si][sj] - X[di][dj]);\n}\n\nint solve() {\n  fill(T[0][0], T[MAX_N][0], INF);\n  for(int j = 0; j < K[0]; ++j) {\n    T[0][j][M] = 0;\n  }\n  for(int i = 1; i < N; ++i) {\n    for(int j = 0; j < K[i]; ++j) {\n      for(int m = 0; m <= M; ++m) {\n\tfor(int l = 0; l <= 1; ++l) {\n\t  int pi = i-1-l;\n\t  int pm = m+l;\n\t  if(pm > M) continue;\n\t  if(pi < 0) continue;\n\t  for(int pj = 0; pj < K[pi]; ++pj) {\n\t    T[i][j][m] = min(T[i][j][m],\n\t\t\t     T[pi][pj][pm] + calcCost(pi,pj,i,j));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = INF;\n  for(int j = 0; j < K[N-1]; ++j) {\n    for(int m = 0; m <= M; ++m) {\n      res = min(res, T[N-1][j][m]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    for(int i = 0; i < N; ++i) {\n      cin >> K[i];\n      for(int j = 0; j < K[i]; ++j) {\n\tcin >> X[i][j] >> D[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\n\nconst ll MOD = (ll)1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll HIGHINF = (ll)1e18;\nconst ll LOWINF = (ll)1e15;\nconst long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max<T>(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min<T>(a,b);}\nvoid YN(bool flg) {cout << ((flg) ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << ((flg) ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << ((flg) ? \"yes\" : \"no\") << endl;}\n\nint main() {\n    while(1){\n        int N,M; cin >> N >> M;\n        if(N==0&&M==0) return 0;\n\n        V<ll> c(160,0);\n        V<V<ll>> a(160,V<ll>(10,0)),b(160,V<ll>(10,0));\n        V<V<V<ll>>> dp(160,V<V<ll>>(10,V<ll>(100,LOWINF)));\n        \n        for(int i = 0; i < N; ++i){\n            cin >> c[i];\n            for(int j = 0; j < c[i]; ++j){\n                cin >> a[i][j] >> b[i][j];\n            }\n        }\n\n        for(int j = 0; j < c[0]; ++j) dp[0][j][0] = 0;\n        for(int j = 0; j < c[1]; ++j) dp[1][j][1] = 0;\n        \n        for(int i = 0; i < N; ++i){\n\n            for(int j = 0; j < c[i]; ++j){\n                for(int k = 0; k < c[i+1]; ++k){\n                    ll cost = abs(a[i][j]-a[i+1][k])*(b[i][j]+b[i+1][k]);\n                    for(int n = 0; n <= M; ++n){\n                        chmin(dp[i+1][k][n],dp[i][j][n]+cost);\n                    }\n                }\n            }\n\n            for(int j = 0; j < c[i]; ++j){\n                for(int k = 0; k < c[i+2]; ++k){\n                    ll cost = abs(a[i][j]-a[i+2][k])*(b[i][j]+b[i+2][k]);\n                    for(int n = 0; n <= M; ++n){\n                        chmin(dp[i+2][k][n+1],dp[i][j][n]+cost);\n                    }\n                }\n            }\n\n        }\n\n        ll ans = LOWINF;\n        for(int n = 0; n <= M; ++n) for(int j = 0; j < c[N-1]; ++j) chmin(ans,dp[N-1][j][n]);\n        for(int n = 0; n < M; ++n) for(int j = 0; j < c[N-2]; ++j) chmin(ans,dp[N-2][j][n]);\n\n        cout << ans << endl;    \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77];\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int i = 0; i < 1001; i++)\n\t\t\t\tfill(cur[i],cur[i]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=cur;\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,fin[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main(){\n    int m,n;\n    int inf = 1000000000;\n    \n    while(cin>>n>>m && n){\n        int dp[150][10][76] = {};\n        for(int i=0;i<150;++i){\n            for(int j=0;j<10;++j){\n                for(int k=0;k<76;++k){\n                    dp[i][j][k]=inf;\n                }\n            }\n        }\n        int num[150],s[150][10][2];\n        for(int i=0;i<n;++i){\n            cin>>num[i];\n            for(int j=0;j<num[i];++j) cin>>s[i][j][0]>>s[i][j][1];\n        }\n        for(int i=0;i<num[0];++i) dp[0][i][0]=0;\n        for(int i=0;i<num[1];++i) dp[1][i][1]=0;\n        for(int i=0;i<n-1;++i){\n            for(int j=0;j<num[i];++j){\n                for(int k=0;k<num[i+1];++k){\n                    for(int sk=0;sk<=m;++sk){\n                        dp[i+1][k][sk]=min(dp[i+1][k][sk],dp[i][j][sk]+(s[i][j][1]+s[i+1][k][1])*abs(s[i][j][0]-s[i+1][k][0]));\n                    }\n                }\n                if(i<n-2){\n                    for(int k=0;k<num[i+2];++k){\n                        for(int sk=0;sk<m;++sk){\n                            dp[i+2][k][sk+1]=min(dp[i+2][k][sk+1],dp[i][j][sk]+(s[i][j][1]+s[i+2][k][1])*abs(s[i][j][0]-s[i+2][k][0]));\n                        }\n                    }\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=0;i<num[n-1];++i){\n            for(int j=0;j<=m;++j) ans = min(ans,dp[n-1][i][j]);\n        }\n        for(int i=0;i<num[n-2];++i){\n            for(int j=0;j<=m-1;++j) ans = min(ans,dp[n-2][i][j]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int inf = 999999;\n\nint func(vector<int> vec[151], int a[151][151], int n, int m, int rsk, int p, int q)\n{\n  if(p+1 == n){\n    return rsk;\n  }\n  if(vec[p].size() == 0){\n    return inf;\n  }\n\n  int v = inf, t;\n  if(m > 0){\n    if(p+2 >= n){\n      return rsk;\n    }\n    for(int i = 0; i < vec[p+2].size(); i++){\n      t = q-vec[p+2][i];\n      if(t < 0){\n\tt = -t;\n      }\n      v = min(v, func(vec, a, n, m-1, rsk+(a[p][q]+a[p+2][vec[p+2][i]])*t, p+2, vec[p+2][i]));\n    }\n  }\n\n  for(int i = 0; i < vec[p+1].size(); i++){\n    t = q-vec[p+1][i];\n    if(t < 0){\n      t = -t;\n    }\n    v = min(v, func(vec, a, n, m, rsk+(a[p][q]+a[p+1][vec[p+1][i]])*t, p+1, vec[p+1][i]));\n  }\n\n  return v;\n}\n\nint main()\n{\n  int n, m, s, t, u;\n\n  while(cin>>n>>m && n){\n    vector<int> vec[151];\n    int a[151][151];\n    fill(&a[0][0], &a[150][150], 0);\n\n    for(int i = 0; i < n; i++){\n      cin >> u;\n      while(u--){\n\tcin >> s >> t;\n\tvec[i].push_back(s);\n\ta[i][s] = t;\n      }\n    }\n\n    u = inf;\n    for(int i = 0; i < vec[0].size(); i+=1){\n      u = min(u, func(vec, a, n, m, 0, 0, vec[0][i]));\n    }\n\n    cout << u << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (int)(1e9)\n\nint mb[10];\nint ms[10];\nint m[10][77];\nint mk;\nint mmb[10];\nint mms[10];\nint mm[10][77];\nint mmk;\nint n[10][77];\n\nvector<pair<int,int> > isi[150];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint nn,mn;\n\t\tscanf(\"%d %d\",&nn,&mn);\n\t\tif(nn == 0 && mn == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(int ii = 0; ii < k; ii++)\n\t\t\t{\n\t\t\t\tint x,d;\n\t\t\t\tscanf(\"%d %d\",&x,&d);\n\t\t\t\tisi[i].push_back(make_pair(x,d));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < isi[0].size(); i++)\n\t\t{\n\t\t\tmb[i] = isi[0][i].first;\n\t\t\tms[i] = 0;\n\t\t\tmmb[i] = isi[0][i].first;\n\t\t\tmms[i] = 0;\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tm[i][ii] = 0;\n\t\t\t\tmm[i][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tmk = isi[0].size();\n\t\tmmk = isi[0].size();\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tif(i == 1)\n\t\t\t{\n\t\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t\t{\n\t\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmm[ii][iii] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tmmb[ii] = isi[i][ii].first;\n\t\t\t\t\tmms[ii] = isi[i][ii].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn[ii][iii] = min;\n\t\t\t\t}\n\t\t\t\tfor(int iii = 0; iii < mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n[ii][iii + 1] > min)\n\t\t\t\t\t{\n\t\t\t\t\t\tn[ii][iii + 1] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < mk; ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tmm[ii][iii] = m[ii][iii];\n\t\t\t\t}\n\t\t\t\tmmb[ii] = mb[ii];\n\t\t\t\tmms[ii] = ms[ii];\n\t\t\t}\n\t\t\tmmk = mk;\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tm[ii][iii] = n[ii][iii];\n\t\t\t\t}\n\t\t\t\tmb[ii] = isi[i][ii].first;\n\t\t\t\tms[ii] = isi[i][ii].second;\n\t\t\t}\n\t\t\tmk = isi[i].size();\n\t\t}\n\t\tint allmin = INF;\n\t\tfor(int i = 0; i < mmk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > mm[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = mm[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < mk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > m[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = m[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",allmin);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m, n;) {\n\t\tvector<vector<int> > pos(n), danger(n);\n\t\tvector<vector<vector<int> > > dp(n, vector<vector<int> >(m + 1));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint num;\n\t\t\tcin >> num;\n\n\t\t\tfor(int j = 0; j < m + 1; ++j)\n\t\t\t\tdp[i][j].resize(num, INT_MAX);\n\n\t\t\tfor(int j = 0; j < num; ++j) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tpos[i].push_back(x);\n\t\t\t\tdanger[i].push_back(d);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < m + 1; ++i)\n\t\t\tfor(int j = 0; j < dp[0][i].size(); ++j)\n\t\t\t\tdp[0][i][j] = 0;\n\n\t\tint ans = INT_MAX;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < m + 1; ++j) {\n\t\t\t\tfor(int k = 0; k < dp[i][j].size(); ++k) {\n\t\t\t\t\tif(dp[i][j][k] == INT_MAX)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(j) {\n\t\t\t\t\t\tif(i + 2 >= n)\n\t\t\t\t\t\t\tchmin(ans, dp[i][j][k]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor(int l = 0; l < dp[i + 2][j - 1].size(); ++l)\n\t\t\t\t\t\t\t\tchmin(dp[i + 2][j - 1][l], dp[i][j][k] + (danger[i][k] + danger[i + 2][l]) * abs(pos[i][k] - pos[i + 2][l]));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(i + 1 >= n)\n\t\t\t\t\t\tchmin(ans, dp[i][j][k]);\n\t\t\t\t\telse\n\t\t\t\t\t\tfor(int l = 0; l < dp[i + 1][j].size(); ++l)\n\t\t\t\t\t\t\tchmin(dp[i + 1][j][l], dp[i][j][k] + (danger[i][k] + danger[i + 1][l]) * abs(pos[i][k] - pos[i + 1][l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nsigned main()\n{\n\twhile (scanf(\"%lld %lld\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%lld\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%lld %lld\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\trep(i, k[0]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(0, 0, i));\n\t\t}\n\n\t\tif (M > 0) {\n\t\t\trep(i, k[1]) {\n\t\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\t\tchmin(ans, rec(1, 1, i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n\n      int slip[152][12] = {{0}};\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n\n      int flag[152][12][78] = {{{0}}};\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         if(flag[p.f.s][p.s.f][p.s.s] == 1) continue;\n         flag[p.f.s][p.s.f][p.s.s] =1;\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\nint dp [1502] [152];\nint n, m, s;\nvector<vector<int>> mp;\nvector<pll> st;\nint func(int pos, int stnum, int spc) {\n\tif (spc == m+1)\n\t\treturn -1;\n\tif (stnum == s)\n\t\treturn 0;\n\tif (dp[stnum][spc] != -1)\n\t\treturn dp[stnum][spc];\n\tint res = LLONG_MAX;\n\tint w = st[stnum].first;\n\tint sb = st[stnum].second;\n\tREP(i, mp[pos+1].size()) {\n\t\tint cand = func(pos + 1, mp[pos + 1][i], spc);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0 && mp[pos+1][i] != s) {\n\t\t\tcand += (sb + st[mp[pos + 1][i]].second)*abs(w-st[mp[pos + 1][i]].first);\n\t\t}\n\t\tres = min(res, cand);\n\t}\n\tREP(i, mp[pos + 2].size()) {\n\t\tint cand = func(pos + 2, mp[pos + 2][i], spc+1);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0 && mp[pos + 2][i] != s) {\n\t\t\tcand += (sb + st[mp[pos + 2][i]].second)*abs(w - st[mp[pos + 2][i]].first);\n\t\t}\n\t\tres = min(res,cand);\n\t}\n\tdp[stnum][spc] = res;\n\tif (res == LLONG_MAX)\n\t\tres = -1;\n\treturn res;\n}\n\nsigned main() {\n\twhile (scanf(\"%lld %lld\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tFill(dp, -1);\n\t\tmp.clear();\n\t\tmp.resize(n+2);\n\t\tst.clear();\n\t\ts = 0;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tscanf(\"%lld\", &c);\n\t\t\tREP(j, c) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%lld %lld\", &a, &b);\n\t\t\t\tmp[i].push_back(s);\n\t\t\t\tst.push_back({ a,b });\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tmp[n].push_back(s);\n\t\tst.push_back({ -1,-1 });\n\t\tst.push_back({ -1,-1 });\n\t\tprintf(\"%lld\\n\", func(-1, s+1, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n \nconst int INF = 1<<29;\n \nint dp[256][16][128];\nvector<P> stones[256];\n \nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n   \n    REP(i, N) {\n      stones[i].clear();\n      int k;\n      cin >> k;\n      REP(j, k) {\n    int x, d;\n    cin >> x >> d;\n    stones[i].push_back(P(x, d));\n      }\n    }\n \n    REP(i, N) REP(j, stones[i].size()) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, stones[0].size()) dp[0][j][0] = 0;\n    REP(j, stones[1].size()) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, stones[i+1].size()) {\n    int x_now = stones[i+1][j].first, d_now = stones[i+1][j].second;\n    REP(k, stones[i].size()) {\n      int x_prev = stones[i][k].first, d_prev = stones[i][k].second;\n      int safe = (d_now + d_prev) * abs(x_now - x_prev);\n      REP(m, M+1) {\n        dp[i+1][j][m] = min(dp[i+1][j][m], dp[i][k][m] + safe);\n      }\n    }\n    if (i > 0) {\n      REP(k, stones[i-1].size()) {\n        int x_prev = stones[i-1][k].first, d_prev = stones[i-1][k].second;\n        int safe = (d_now + d_prev) * abs(x_now - x_prev);\n        REP(m, M) {\n          dp[i+1][j][m+1] = min(dp[i+1][j][m+1], dp[i-1][k][m] + safe);\n        }\n      }\n    }\n      }\n    }\n \n    int ans = INF;\n    REP(j, stones[N-1].size()) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, stones[N-2].size()) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  /*\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\t//memset(field,0,sizeof(field));\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tint k;\n\t\t//\tcin>>k;\n\t\t//\tfor(int j = 0; j < k; j++){\n\t\t//\t\tint x,d;\n\t\t//\t\tcin>>x>>d;\n\t\t//\t\tfield[i][x-1]=d;\n\t\t//\t}\n\t\t//}\n\t\t//// ún_ÌÝè\n\t\t//for(int i = 0; i < 1001; i++){\n\t\t//\tif(field[0][i]!=0){\n\t\t//\t\tdp[0][i][m]=0;\n\t\t//\t}\n\t\t//}\n\t\t//int (*fin)[77];\n\t\t//// dpÅÅ¬RXgðßé\n\t\t//for(int i = 1; i < n; i++){\n\t\t//\tswap(cur,prv);\n\t\t//\tswap(pprv,cur);\n\t\t//\tfor(int i = 0; i < 1001; i++)\n\t\t//\t\tfill(cur[i],cur[i]+77,INF);\n\t\t//\t// Ç±ÖWv·é©\n\t\t//\tfor(int j = 0; j < 1001; j++){\n\t\t//\t\tif(field[i][j]==0)\n\t\t//\t\t\tcontinue;\n\t\t//\t\t// Ç±©çWv·é©\n\t\t//\t\tfor(int k = 0;  k < 1001; k++){\n\t\t//\t\t\t// ÇÌRXgÅWv·é©\n\t\t//\t\t\tfor(int l = m; l >= 0; l--){\n\t\t//\t\t\t\t// ÓÂ¤ÉWv\n\t\t//\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t//\t\t\t\tif(i>=2&&l!=m){\n\t\t//\t\t\t\t\t// êÂòÎµÅWv\n\t\t//\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//\tfin=cur;\n\t\t//}\n\t\t//int minRes=INF;\n\t\t//for(int i = 0; i < 1001; i++){\n\t\t//\tfor(int j = 0; j <= m; j++){\n\t\t//\t\tminRes=min(minRes,fin[i][j]);\n\t\t//\t}\n\t\t//}\n\t\t//cout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0)\n\t\t\t\tdp[0][i][m]=0;\n\t\t}\n\t\tif(m!=0){\n\t\t\tfor(int i = 0; i < 1001; i++){\n\t\t\t\tif(field[1][i]!=0)\n\t\t\t\t\tdp[1][i][m-1]=0;\n\t\t\t}\n\t\t}\n\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tif(m!=0&&i==1){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\t\tfill(cur[j],cur[j]+77,INF);\n\t\t\t}\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\tif(field[i-1][k]==0&&(i<=1||field[i-2][k]==0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++)\n\t\t\t\tminRes=min(minRes,cur[i][j]);\n\t\t\tfor(int j = 1; j <= m; j++)\n\t\t\t\tminRes=min(minRes,prv[i][j]);\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n | m)\n\t{\n\t\tint k[200], x[200][16], d[200][16];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", k + i);\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t\tscanf(\"%d%d\", &x[i][j], &d[i][j]);\n\t\t}\n\n\t\tconst int INF = 1 << 26;\n\t\tstatic int dp[200][16][100];\t// row, column, jump left\n\t\tfor (int i = 0; i < 200; ++i)\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tfor (int a = 0; a < 100; ++a)\n\t\t\t\t\tdp[i][j][a] = i == 0 && a == m ? 0 : INF;\n\n\t\tfor (int i = 0; i < n - 1; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t{\n\t\t\t\tfor (int a = 0; a <= m; ++a)\n\t\t\t\t{\n\t\t\t\t\tfor (int b = 0; b < k[i + 1]; ++b)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin_swap(dp[i + 1][b][a]\n\t\t\t\t\t\t, dp[i][j][a] + (d[i][j] + d[i + 1][b]) * abs(x[i][j] - x[i + 1][b]));\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 2 < n && a > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int b = 0; b < k[i + 2]; ++b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin_swap(dp[i + 2][b][a - 1],\n\t\t\t\t\t\t\t\tdp[i][j][a] + (d[i][j] + d[i + 2][b]) * abs(x[i][j] - x[i + 2][b]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = n - 2; i < n; ++i)\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t\tfor (int a = 0; a <= m; ++a)\n\t\t\t\t\tif (i == n - 1 || a > 0)\n\t\t\t\t\t\tmin_swap(res, dp[i][j][a]);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[150][10][76];\nint sec[150][10];\nint val[150][10];\nint size[150];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d\",size+i);\n\t\t\tfor(int j=0;j<size[i];j++){\n\t\t\t\tscanf(\"%d%d\",&sec[i][j],&val[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<10;i++)\n\t\t\tfor(int j=0;j<75;j++)\n\t\t\t\tdp[0][i][j]=99999999;\n\t\tfor(int i=0;i<size[0];i++){\n\t\t\tdp[0][i][b]=0;\n\t\t}\n\t\tfor(int i=0;i<size[1];i++){\n\t\t\tdp[1][i][b-1]=0;\n\t\t}\n\t\tfor(int i=1;i<a;i++){\n\t\t\tfor(int j=0;j<size[i];j++){\n\t\t\t\tint Min=99999999;\n\t\t\t\tfor(int k=0;k<size[i-1];k++){\n\t\t\t\t\tMin=min(Min,dp[i-1][k][b]+(val[i][j]+val[i-1][k])*abs(sec[i][j]-sec[i-1][k]));\n\t\t\t\t}\n\t\t\t\tdp[i][j][b]=Min;\n\t\t\t}\n\t\t\tif(i>1)\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tfor(int k=0;k<size[i];k++){\n\t\t\t\t\tint Min=99999999;\n\t\t\t\t\tfor(int l=0;l<size[i-1];l++){\n\t\t\t\t\t\tMin=min(Min,dp[i-1][l][j]+(val[i][k]+val[i-1][l])*abs(sec[i][k]-sec[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l=0;l<size[i-2];l++){\n\t\t\t\t\t\tMin=min(Min,dp[i-2][l][j+1]+(val[i][k]+val[i-2][l])*abs(sec[i][k]-sec[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][k][j]=Min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=99999999;\n\t\tfor(int i=0;i<size[a-1];i++){\n\t\t\tfor(int j=0;j<b+1;j++){\n\t\t\t\tret=min(ret,dp[a-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\npriority_queue<p4,vector<p4 >,greater<p4 > >Q;\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n\n      int slip[152][12] = {{0}};\n      int flag[152][12][78] = {{{0}}};\n      while(Q.size()) Q.pop();\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n\n      if(n == 1 && m == 1){printf(\"0\\n\"); continue;}\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n            flag[1][i][0] = 1;\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n            flag[2][i][1] = 1;\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s] = 1;\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n               if(p.f.f != 0) flag[p.f.s+2][i][p.s.s+1] = 1;\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    //fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\tfor(int a=0;a<=m;a++){\n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#define int long long\n#define inf 1000000007\ntypedef pair<int, int>P;\nint dp[160][10][80];\nvector<P>s[160];//P(??????,???????????????)\n\nvoid init(int m) {\n\tfor (int i = 0; i < 160; i++) {\n\t\ts[i].clear();\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tfor (int k = 0; k < 80; k++) {\n\t\t\t\tif (!i&&k==m)dp[i][j][k]=0;\n\t\t\t\telse dp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nsigned main() {\n\tint n, m;\n\twhile (cin >> n >> m) {\n\t\tif (!n && !m)break;\n\t\tinit(m);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\ts[i].push_back(P(b, c));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {//?¬?????????????\n\t\t\tfor (int j = 0; j < s[i].size(); j++) {//??????????????????\n\t\t\t\tfor (int k = m; k >= 0; k--) {//???????????§?????£??????\n\t\t\t\t\tfor (int l = 0; l < s[i - 1].size(); l++) {\n\t\t\t\t\t\tint dang = (s[i-1][l].second+s[i][j].second)*abs(s[i][j].first-s[i-1][l].first);\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + dang);\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 1) {\n\t\t\t\t\t\tfor (int l = 0; l < s[i - 2].size(); l++) {\n\t\t\t\t\t\t\tint dang = (s[i - 2][l].second + s[i][j].second)*abs(s[i][j].first - s[i - 2][l].first);\n\t\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 2][l][k + 1] + dang);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 80; j++) {\n\t\t\t\tans = min(ans, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n \nusing namespace std;\n \ntypedef pair<int,int> P;\n \nint main(void){\n \n  int n,m,k,a,b;\n \n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n     \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n   \t\t cin >> a >> b;\n    \tv[i].push_back(make_pair(a,b));\n      }\n    }\n \n    int dp[MAX_N][11][80];\n \n  \tfill(dp[0][0],dp[MAX_N][11],INF);\n  \t\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n    dp[0][i][j]=dp[1][i][j]=0;\n \n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n   \t\t for(int l=m;l>=0;l--){\n     \t\t for(int k=0;k<v[i-1].size();k++){\n       \t\t dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n      \t\t}\n     \t\t if(l<m){\n      \t  \t\tif(i==2)dp[i][j][l]=0;\n      \t\t\t for(int p=0;p<v[i-2].size();p++)\n       \t\t  \t dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n     \t\t }\n   \t\t }\n      }\n    }\n     \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>0)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n \n    cout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint n,m;\nint d[76][151][1001];\n\nint main(){\n    while(true){\n\tcin >> n >> m;\n\tif(n == 0 && m == 0) break;\n\tmemset(d,-1,sizeof(d));\n\tqueue< pair<int,int> > qxy;\n\tqueue<int> qm;\n\tqueue<int> qs;\n\tvector< vector< pair<int,int> > > coor(n);\n\tint ans = INT_MAX/2;\n\tREP(i,n){\n\t    int k;\n\t    cin >> k;\n\t    REP(j,k){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcoor[i].PB( pair<int,int>(a,b));\n\t\tif(i==0){\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m);\n\t\t    qs.push(b);\n\t\t    d[m][i][a] = 0;\n\t\t}else if(i == 1){\n\t\t    if(m == 0) continue;\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m-1);\n\t\t    qs.push(b);\n\t\t    d[m-1][i][a] = 0;\n\t\t}\n\t    }\n\t}\n\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int tm = qm.front();\n\t    int ts = qs.front();\n\t    qxy.pop();\n\t    qm.pop();\n\t    qs.pop();\n\t    if(y+1 >= n || (tm > 0 && y+2 >= n)){\n\t\tans = min(ans,d[tm][y][x]);\n\t\tcontinue;\n\t    }\n\t    REP(i,coor[y+1].size()){\n\t\tint nx = coor[y+1][i].first;\n\t\tint ny = y+1;\n\t\tint slip = coor[y+1][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(d[tm][ny][nx] < 0 || d[tm][ny][nx] > v){\n\t\t    d[tm][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t    if(y+2 >= n) continue;\n\t    REP(i,coor[y+2].size()){\n\t\tint nx = coor[y+2][i].first;\n\t\tint ny = y+2;\n\t\tint slip = coor[y+2][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(tm>0 && (d[tm-1][ny][nx] < 0 || d[tm-1][ny][nx] > v )){\n\t\t    d[tm-1][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm-1);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=(1<<30);\nll dp[160][160][20];\nll k[160];\nll x[160][20],d[160][20];\n\nint main(){\n\twhile(true){\n\t\tint n,m;\tcin>>n>>m;\n\t\tif(n==0)\treturn 0;\n\t\tfor(int i=0;i<160;i++)\tfor(int j=0;j<160;j++)\tfor(int l=0;l<20;l++)\tdp[i][j][l]=INF;\n\t\tmemset(k,0,sizeof(k));\n\t\tmemset(x,0,sizeof(x));\n\t\tmemset(d,0,sizeof(d));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>k[i];\n\t\t\tfor(int j=0;j<k[i];j++)\tcin>>x[i][j]>>d[i][j];\n\t\t}\n\t\tfor(int i=0;i<k[0];i++)\tdp[0][m][i]=0;\n\t\tif(m>=1)\tfor(int i=0;i<k[1];i++)\tdp[1][m-1][i]=0;\n\t\tfor(int a=0;a+1<n;a++){\n\t\t\tfor(int b=m;b>=0;b--){\n\t\t\t\tfor(int c=0;c<k[a];c++){\n\t\t\t\t\tif(dp[a][b][c]==INF)\tcontinue;\n\t\t\t\t\t//１歩前進\n\t\t\t\t\tfor(int i=0;i<k[a+1];i++){\n\t\t\t\t\t\tdp[a+1][b][i]=min(dp[a+1][b][i],dp[a][b][c]+(d[a][c]+d[a+1][i])*abs(x[a][c]-x[a+1][i]));\n\t\t\t\t\t}\n\t\t\t\t\t//２歩前進\n\t\t\t\t\tif(b>0&&a+2<n)\tfor(int i=0;i<k[a+2];i++){\n\t\t\t\t\t\tdp[a+2][b-1][i]=min(dp[a+2][b-1][i],dp[a][b][c]+(d[a][c]+d[a+2][i])*abs(x[a][c]-x[a+2][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans=INF;\n\t\tfor(int i=m;i>=0;i--){\n\t\t\tfor(int j=0;j<k[n-1];j++)\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tfor(int j=0;j<k[n-2];j++)\tans=min(ans,dp[n-2][i][j]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int , int > Pi;\n\nint dp[150][77][11];\nconst int INF = 1 << 30;\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector< vector< Pi > > data(n);\n\n    for(int i = 0; i < n; i++){\n      int k;\n      cin >> k;\n      for(int j = 0; j < k; j++){\n        int a, b;\n        cin >> a >> b;\n        data[i].push_back( make_pair( a, b));\n      }\n    }\n    \n    fill_n( **dp, 150 * 11 * 77, INF);\n    for(int i = 0; i < min( 2, m + 1); i++){\n      for(int j = 0; j < data[i].size(); j++){\n        dp[i][m - i][j] = 0;\n      }\n    }\n\n    int ret = INF;\n    for(int i = 0; i < n; i++){\n      for(int j = m; j >= 0; j--){\n        for(int k = 0; k < data[i].size(); k++){\n          if(dp[i][j][k] == INF) continue;\n          if(i == n - 1){\n            ret = min( ret, dp[i][j][k]);\n          } else {\n            for(int l = 0; l < data[i + 1].size(); l++){\n              dp[i + 1][j][l] = min( dp[i + 1][j][l], dp[i][j][k] + (data[i][k].second + data[i + 1][l].second) * abs(data[i][k].first - data[i + 1][l].first));\n            }\n          }\n          if(j == 0 || i == n - 1) continue;\n          if(i == n - 2){\n            ret = min( ret, dp[i][j][k]);\n          } else {\n            for(int l = 0; l < data[i + 2].size(); l++){\n              dp[i + 2][j - 1][l] = min( dp[i + 2][j - 1][l], dp[i][j][k] + (data[i][k].second + data[i + 2][l].second) * abs(data[i][k].first - data[i + 2][l].first));\n            }\n          }\n        }\n      }\n    }\n    cout << ret << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint dp[151][1001][76];\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvvint vv;\n\t\tinitvv(vv,n,1001,-1);\n\t\trep(i,151) rep(j,1001) rep(k,76) dp[i][j][k]=INF;\n\t\trep(i,n){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\trep(j,t){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tvv[i][a-1]=b;\n\t\t\t}\n\t\t}\n\t\t// puts(\"hoge\");\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// printf(\"%2d\",vv[i][j]);\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\trep(i,2){\n\t\t\trep(j,1001){\n\t\t\t\tif(vv[i][j]!=-1) dp[i][j][i]=0;\n\t\t\t}\n\t\t}\n\t\t// return;\n\t\trep(i,n-1){\n\t\t\trep(j,1001){\n\t\t\t\tif(vv[i][j]==-1) continue;\n\t\t\t\trep(o,76){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tif(o+k>75) continue;\n\t\t\t\t\t\trep(l,1001){\n\t\t\t\t\t\t\tif(vv[i+k+1][l]==-1) continue;\n\t\t\t\t\t\t\tdp[i+k+1][l][o+k]=min(dp[i+k+1][l][o+k],dp[i][j][o]+abs(j-l)*(vv[i][j]+vv[i+k+1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==n-2) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// if(dp[i][j][0]!=INF) printf(\"%2d\",dp[i][j][0]);\n\t\t\t\t// else cout<<\"  \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// if(dp[i][j][1]!=INF) printf(\"%2d\",dp[i][j][1]);\n\t\t\t\t// else cout<<\"  \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\treep(i,n-2,n){\n\t\t\trep(j,n){\n\t\t\t\trep(k,m){\n\t\t\t\t\tans=min(ans,dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout<<ans<<endl;\n\t\trep(i,n){\n\t\t\trep(k,m+1){\n\t\t\t\tans=min(ans,dp[n-1][i][k]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <map>\n#include <vector>\n#include <algorithm>\n#define inf INT_MAX/2\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<P> riv[155];\nint dp[155][1000][80];\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        for (int i=0; i<150; i++) for (int j=0; j<1000; j++) for (int k=0; k<80; k++) {\n            dp[i][j][k]=inf;\n        }\n        for (int i=0; i<n; i++) {\n            int k; scanf(\"%d\",&k);\n            riv[i].clear();\n            for (int j=0; j<k; j++) {\n                int x, d; scanf(\"%d%d\",&x,&d);\n                riv[i].push_back(P(x,d));\n            }\n        }\n        for (int i=0; i<n; i++) {\n            int sz=riv[i].size();\n            for (int j=0; j<sz; j++) {\n                for (int k=0; k<min(i+1,m+1); k++) {\n                    if (i==0) {\n                        dp[i][j][k]=0;\n                    } else {\n                        int sz2=riv[i-1].size();\n                        for (int l=0; l<sz2; l++) {\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-1][l][k]+(int)abs(riv[i][j].f-riv[i-1][l].f)*(riv[i][j].s+riv[i-1][l].s));\n                        }\n                    }\n                    if (k!=0&&i>1) {\n                        int sz2=riv[i-2].size();\n                        for (int l=0; l<sz2; l++) {\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-2][l][k-1]+(int)abs(riv[i][j].f-riv[i-2][l].f)*(riv[i][j].s+riv[i-2][l].s));\n                        }\n                    }\n                }\n            }\n        }\n        int res=inf;\n        for (int i=0; i<riv[n-1].size(); i++) {\n            for (int k=0; k<=m; k++) res=min(res,dp[n-1][i][k]);\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll dp[150][150][10];\nll k[150];\nll x[150][10],d[150][10];\n\nint main(){\n\twhile(true){\n\t\tint n,m;\tcin>>n>>m;\n\t\tif(n==0)\treturn 0;\n\t\tfor(int i=0;i<150;i++)\tfor(int j=0;j<150;j++)\tfor(int l=0;l<10;l++)\tdp[i][j][l]=(1<<30);\n\t\tmemset(k,0,sizeof(k));\n\t\tmemset(x,0,sizeof(x));\n\t\tmemset(d,0,sizeof(d));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>k[i];\n\t\t\tfor(int j=0;j<k[i];j++)\tcin>>x[i][j]>>d[i][j];\n\t\t}\n\t\tfor(int i=0;i<k[0];i++)\tdp[0][m][i]=0;\n\t\tif(m)\tfor(int i=0;i<k[1];i++)\tdp[1][m-1][i]=0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tfor(int j=m;j>=0;j--){\n\t\t\t\tfor(int l=0;l<k[i];l++){\n\t\t\t\t\tif(dp[i][j][l]==(1<<30))\tcontinue;\n\t\t\t\t\tfor(int m=0;m<k[i+1];m++){\n\t\t\t\t\t\tdp[i+1][j][m]=min(dp[i+1][j][m],dp[i][j][l]+(d[i+1][m]+d[i][l])*abs(x[i+1][m]-x[i][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif(i+2<n&&j!=0){\n\t\t\t\t\t\tfor(int m=0;m<k[i+2];m++){\n\t\t\t\t\t\t\tdp[i+2][j-1][m]=min(dp[i+2][j][m],dp[i][j][l]+(d[i+2][m]+d[i][l])*abs(x[i+2][m]-x[i][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans=(1<<30);\n\t\tfor(int i=m;i>=0;i--){\n\t\t\tfor(int j=0;j<k[n-1];j++)\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tfor(int j=0;j<k[n-2];j++)\tans=min(ans,dp[n-2][i][j]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint n, m;\nint l[150];\nint k[150][10][2];\nint dp[150][10][75];\nint INF = 10e8+7;\n\nint main(){\n\twhile(1){\n\t\tmemset(k, 0, sizeof(k));\n\t\tmemset(dp, INF, sizeof(dp));\n\t\tint ans = INF;\n\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d\", &l[i]);\n\t\t\tfor(int j=0; j<l[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &k[i][j][0], &k[i][j][1]);\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i=0; i<n; i++){\n\t\t\tprintf(\"%d\\t\", l[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<l[i]; j++){\n\t\t\t\tprintf(\"%d %d\\t\", k[i][j][0], k[i][j][1]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\n\t\tfor(int i=0; i<l[0]; i++)\n\t\t\tdp[0][i][0] = 0;\n\n\t\tfor(int i=0; i<l[1]; i++)\n\t\t\tdp[1][i][1] = 0;\n\n\t\tfor(int i=0; i<l[1]; i++){\n\t\t\tfor(int j=0; j<l[0]; j++){\n\t\t\t\tdp[1][i][0] = min(dp[1][i][0], (k[1][i][1] + k[0][j][1]) * abs(k[1][i][0] - k[0][j][0]));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=2; i<n; i++){ //gyou\n\t\t\tfor(int i1=0; i1<l[i]; i1++){ //nowishi\n\t\t\t\tfor(int i2=0; i2<l[i-1]; i2++){ //previshi, ichitobi0\n\t\t\t\t\tdp[i][i1][0] = min(dp[i][i1][0], dp[i-1][i2][0] + (k[i-1][i2][1] + k[i][i1][1]) * abs(k[i][i1][0] - k[i-1][i2][0]));\n\t\t\t\t}\n\t\t\t\tfor(int i2=0; i2<l[i-2]; i2++){ //previshi, ichitobiari\n\t\t\t\t\tfor(int i3=1; i3<m+1; i3++){ //ichitobi\n\t\t\t\t\t\tdp[i][i1][i3] = min(dp[i][i1][i3], dp[i-2][i2][i3-1] + (k[i-2][i2][1] + k[i][i1][1]) * abs(k[i-2][i2][0] - k[i][i1][0]));\n\t\t\t\t\t\tdp[i][i1][i3] = min(dp[i][i1][i3], dp[i-1][i2][i3] + (k[i-1][i2][1] + k[i][i1][1]) * abs(k[i-1][i2][0] - k[i][i1][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<l[n-1]; i++){\n\t\t\tfor(int j=0; j<m+1; j++){\n\t\t\t\tans = min(ans, dp[n-1][i][j]);\n//\t\t\t\tif(ans == 12) printf(\"%d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<l[n-2]; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tans = min(ans, dp[n-1][i][j]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAX_N = 151;\nconst int MAX_M = MAX_N/2+2;\nconst int MAX_K = 11;\nconst int INF = 1<<29;\n\nint N, M;\nint K[MAX_N];\nint X[MAX_N][MAX_K], D[MAX_N][MAX_K];\nint T[MAX_N][MAX_K][MAX_M];\n\nint calcCost(int si, int sj, int di, int dj) {\n  return (D[si][sj] + D[di][dj]) * abs(X[si][sj] - X[di][dj]);\n}\n\nint solve() {\n  fill(T[0][0], T[MAX_N][0], INF);\n  for(int j = 0; j < K[0]; ++j) T[0][j][0] = 0;\n  for(int j = 0; j < K[1]; ++j) T[1][j][1] = 0;\n\n  for(int i = 1; i < N; ++i) {\n    for(int j = 0; j < K[i]; ++j) {\n      for(int k = 0; k <= 1; ++k) {\n\tfor(int m = 0; m <= M; ++m) {\n\t  int pi = i-1-k;\n\t  int pm = m-k;\n\t  if(pi < 0) continue;\n\t  if(pm < 0) continue;\n\t  for(int pj = 0; pj < K[pi]; ++pj) {\n\t    T[i][j][m] = min(T[i][j][m],\n\t\t\t     T[pi][pj][pm] + calcCost(pi,pj,i,j));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = INF;\n  for(int j = 0; j < K[N-1]; ++j) {\n    for(int m = 0; m <= M; ++m) {\n      res = min(res, T[N-1][j][m]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    for(int i = 0; i < N; ++i) {\n      cin >> K[i];\n      for(int j = 0; j < K[i]; ++j) {\n\tcin >> X[i][j] >> D[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nll dp[155][10][80];\nint main(void){\n\tint n, m;\n\tvector<pair<ll, ll> > s[151];\n\tREP(i, 155){\n\t\tREP(j, 10){\n\t\t\tfill(dp[i][j], dp[i][j]+80, INF_LL);\n\t\t}\n\t}\n\tcin >> n >> m;\n\tREP(i, n){\n\t\tint k;\n\t\tcin >> k;\n\t\tREP(j, k){\n\t\t\tint x, d;\n\t\t\tcin >> x >> d;\n\t\t\ts[i].push_back({x, d});\n\t\t}\n\t}\n\tREP(i, s[0].size()){\n\t\tdp[0][i][0] = 0;\n\t}\n\tREP(i, s[1].size()){\n\t\tdp[1][i][1] = 0;\n\t}\n\tREP(i, n-1){\n\t\tREP(j, s[i].size()){\n\t\t\tREP(k, m+1){\n\t\t\t\tREP(t, s[i+1].size()){\n\t\t\t\t\tdp[i+1][t][k] = min(dp[i+1][t][k], dp[i][j][k] + (s[i][j].snd+s[i+1][t].snd)*abs(s[i][j].fst-s[i+1][t].fst));\n\t\t\t\t}\n\t\t\t\tif(i < n-2){\n\t\t\t\t\tREP(t, s[i+2].size()){\n\t\t\t\t\t\tdp[i+2][t][k+1] = min(dp[i+2][t][k+1], dp[i][j][k] + (s[i][j].snd+s[i+2][t].snd)*abs(s[i][j].fst-s[i+2][t].fst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res = INF_LL;\n\tREP(j, s[n-1].size()){\n\t\tREP(k, m+1){\n\t\t\tres = min(dp[n-1][j][k], res);\n\t\t}\n\t}\n\tREP(j, s[n-2].size()){\n\t\tREP(k, m){\n\t\t\tres = min(dp[n-2][j][k], res);\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define F 1145141919\nusing namespace std;\nvector<pair<int,int> > v[160];\nint dp[80][160][12],n,m,k;\nint Jump(int a,int b,int c,int d){\n\tif(v[a][b].X==-1||v[c][d].X==-1)return 0;\n\tint ret=abs(v[a][b].X-v[c][d].X);\n\tret*=v[a][b].Y+v[c][d].Y;\n\treturn ret;\n}\nint main(){\n\tpair<int,int> p;\n\tp.X=-1,p.Y=-1;\n\tv[0].push_back(p);\n\twhile(cin>>n>>m&&n){\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>k;v[i].clear();\n\t\twhile(k--){\n\t\t\tcin>>p.X>>p.Y;\n\t\t\tv[i].push_back(p);\n\t\t}\n\t}\n\tv[n+1].clear();p.X=-1,p.Y=-1;v[n+1].push_back(p);\n\tfor(int i=0;i<80;i++)for(int j=0;j<160;j++)for(int k=0;k<12;k++)dp[i][j][k]=F;\n\tfor(int i=0;i<=m;i++)dp[i][0][0]=0;\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int f=0;f<=n;f++){\n\t\t\tfor(int g=0;g<v[f].size();g++){\n\t\t\t\tfor(int k=0;k<v[f+1].size();k++)dp[i][f+1][k]=min(dp[i][f+1][k],dp[i][f][g]+Jump(f,g,f+1,k));\n\t\t\t\tif(f!=n&&i!=m)for(int k=0;k<v[f+2].size();k++)dp[i+1][f+2][k]=min(dp[i+1][f+2][k],dp[i][f][g]+Jump(f,g,f+2,k));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=F;\n\tfor(int i=0;i<=m;i++)ans=min(ans,dp[i][n+1][0]);\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint stone[160][1010];\nint dp[160][1010][100];\nint n,m;\nvector<int> node[160];\nint dist(int a1,int a2,int b1,int b2)\n{\n\tif(a1==0&&a2==0)return 0;\n\treturn (stone[a1][a2]+stone[b1][b2])*abs(a2-b2);\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<160;i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=0;i<100;i++)\n\t\t{\n\t\t\tfor(int j=0;j<1010;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<100;k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<160;i++)\n\t\t{\n\t\t\tfor(int j=0;j<1010;j++)\n\t\t\t{\n\t\t\t\tstone[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i][a]=b;\n\t\t\t\tnode[i].pb(a);\n\t\t\t\tif(i==1)\n\t\t\t\t{\n\t\t\t\t\tdp[i][a][m]=0;\n\t\t\t\t}\n\t\t\t\tif(i==2&&m>0)\n\t\t\t\t{\n\t\t\t\t\tdp[i][a][m-1]=0;\n\t\t\t\t\t//cout << dp[i][a][m-1] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<node[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<node[i+1].size();k++)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=0;l<=m;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][node[i+1][k]][l]=min(dp[i+1][node[i+1][k]][l],dp[i][node[i][j]][l]+dist(i,node[i][j],i+1,node[i+1][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<node[i+2].size();k++)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=0;l<m;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+2][node[i+2][k]][l]=min(dp[i+2][node[i+2][k]][l],dp[i][node[i][j]][l+1]+dist(i,node[i][j],i+2,node[i+2][k]));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<node[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=m;k++)\n\t\t\t\t{\n\t\t\t\t\tcout <<i<<' '<<node[i][j]<<' '<<k<<' '<< dp[i][node[i][j]][k] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t//cout << dp[1][node[1][0]][m] << endl;\n\t\tfor(int i=0;i<=1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<node[n-i].size();k++)\n\t\t\t\t{\n\t\t\t\t\tans=min(ans,dp[n-i][node[n-i][k]][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << dist(1,node[1][0],2,node[2][0])<< endl;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, bool> PIB;\ntypedef vector<int> VI;\ntypedef VI::iterator VII;\nconst int INF = 2e9;\n\nint n, m, ans;\nint k[160];\nint x[160][10];\nint d[160][10];\nint dp[160][80][10];\n\nint main()\n{\n  while(true){\n    scanf(\"%d%d\", &n, &m);\n    if(!n && !m)\n      break;\n\n    for(int i1 = 1; i1 <= n; i1++){\n      scanf(\"%d\", &k[i1]);\n      for(int i3 = 0; i3 < k[i1]; i3++)\n\tscanf(\"%d%d\", &x[i1][i3], &d[i1][i3]);\n    }\n    \n    for(int i1 = 1; i1 <= n; i1++)\n      for(int i2 = 0; i2 <= m; i2++)\n\tfor(int i3 = 0; i3 < 10; i3++)\n\t  dp[i1][i2][i3] = INF;\n    ans = INF;\n\n    for(int i3 = 0; i3 < k[1]; i3++)\n      dp[1][0][i3] = 0;\n    for(int i3 = 0; i3 < k[2]; i3++)\n      dp[2][1][i3] = 0;\n\n    for(int i1 = 2; i1 <= n; i1++)\n      for(int i2 = 0; i2 <= n / 2; i2++){\n\tfor(int i3 = 0; i3 < k[i1]; i3++)\n\t  for(int i4 = 0; i4 < k[i1 - 1]; i4++)\n\t    dp[i1][i2][i3] = min(dp[i1][i2][i3], dp[i1 - 1][i2][i4] + abs(x[i1][i3] - x[i1 - 1][i4]) * (d[i1][i3] + d[i1 - 1][i4]));\n\n\tif(i2 > 0 && i1 > 2)\n\t  for(int i3 = 0; i3 < k[i1]; i3++)\n\t    for(int i4 = 0; i4 < k[i1 - 2]; i4++)\n\t      dp[i1][i2][i3] = min(dp[i1][i2][i3], dp[i1 - 2][i2 - 1][i4] + abs(x[i1][i3] - x[i1 - 2][i4]) * (d[i1][i3] + d[i1 - 2][i4]));\n      }\n\n    for(int i2 = 0; i2 <= m; i2++)\n      for(int i3 = 0; i3 < k[n]; i3++)\n\tans = min(ans, dp[n][i2][i3]);\n    for(int i2 = 0; i2 < m; i2++)\n      for(int i3 = 0; i3 < k[n - 1]; i3++)\n\tans = min(ans, dp[n - 1][i2][i3]);\n    \n    printf(\"%d\\n\", ans);\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1 << 25;\n\nint dist[160][160][80];\n\nstruct S {\n\tint x, y, jump, d;\n\tbool operator <(const S& x) const {\n\t\treturn d > x.d;\n\t}\n};\n\nint rec(S s) {\n\treturn dist[s.y][s.x][s.jump];\n}\n\nvoid save(S s) {\n\tdist[s.y][s.x][s.jump] = s.d;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tvector<int> c[160];\n\t\tvector<int> x[160];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\tint xx, cc;\n\t\t\t\tcin >> xx >> cc;\n\t\t\t\txx--;\n\t\t\t\tx[i].push_back(xx);\n\t\t\t\tc[i].push_back(cc);\n\t\t\t}\n\t\t}\n\n\t\tfill((int*)begin(dist), (int*)end(dist), INF);\n\t\tpriority_queue<S> q;\n\t\tfor(int i = 0; i < x[0].size(); i++) {\n\t\t\tS s = { i, 0, 0, 0 };\n\t\t\tq.push(s);\n\t\t\tsave(s);\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile(q.size()) {\n\t\t\tS s = q.top();\n\t\t\tq.pop();\n\t\t\tif(rec(s) < s.d) continue;\n\t\t\tif(s.y == n) {\n\t\t\t\tans = s.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= 2; i++) {\n\t\t\t\tif(s.jump == m && i == 2) break;\n\t\t\t\tif(s.y + i > n) break;\n\t\t\t\tint nj = s.jump + (i == 2);\n\t\t\t\tif(s.y + i == n) {\n\t\t\t\t\tS ns = { 0, s.y + i, nj, s.d };\n\t\t\t\t\tif(rec(ns) > s.d) {\n\t\t\t\t\t\tq.push(ns);\n\t\t\t\t\t\tsave(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < x[s.y + i].size(); j++) {\n\t\t\t\t\t\tint nx = x[s.y + i][j];\n\t\t\t\t\t\tint cost = (c[s.y][s.x] + c[s.y + i][j]) * abs(x[s.y][s.x] - nx);\n\t\t\t\t\t\tS ns = { j, s.y + i, nj, s.d + cost };\n\t\t\t\t\t\tif(rec(ns) > ns.d) {\n\t\t\t\t\t\t\tq.push(ns);\n\t\t\t\t\t\t\tsave(ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\ntypedef pair<LL, LL> P;\ntypedef pair<LL, P> PP;\nint n, m;\nLL dp[150][10][80];\nvector<P>v[150];\nLL ans = LINF;\n\nint main() {\n\twhile (cin >> n >> m&&n&&m) {\n\t\tfor (int i = 1; i < 150; i++) {\n\t\t\tfor (int j = 0; j < 10; j++)for (int k = 0; k < 80; k++) {\n\t\t\t\tdp[i][j][k] = HINF;\n\t\t\t}\n\t\t\tv[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\tb--;\n\t\t\t\tv[i].eb(mp(b, c));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < v[0].size(); i++)dp[1][i][m - 1] = 0;\n\t\tif (m > 0)for (int i = 0; i < v[1].size(); i++)dp[1][i][m - 1] = 0;\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\tif (i == n - 1 && k > 0)continue;\n\t\t\t\t\tfor (int l = 0; l < v[i + 1].size(); l++) {\n\t\t\t\t\t\tLL cost = (v[i][j].second + v[i + 1][l].second)*abs(v[i][j].first - v[i + 1][l].first);\n\t\t\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t\t\t}\n\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\tfor (int l = 0; l < v[i + 2].size(); l++) {\n\t\t\t\t\t\t\tLL cost = (v[i][j].second + v[i + 2][l].second)*abs(v[i][j].first - v[i + 2][l].first);\n\t\t\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < v[n - 1].size(); i++)for (int j = 0; j <= m; j++)ans = min(ans, dp[n - 1][i][j]);\n\t\tif (m > 0)for (int i = 0; i < v[n - 2].size(); i++)for (int j = 1; j <= m; j++)ans = min(ans, dp[n - 2][i][j]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<vector>\n#import<cstdlib>\nint n,m,k,x,d,h,i,j,D[158][151][10];for(;cin>>n>>m,n;cout<<x<<endl){vector<pair<int,int> >S[151];for(i=0;i++<n;)for(cin>>k;k--;S[i].push_back(make_pair(x,d)))cin>>x>>d;fill(**D,*D[158],x=1e9);for(i=S[1].size();i--;)D[m][1][i]=0;for(i=S[2].size();i--;)D[m-1][2][i]=0;for(h=1;h++<n;)for(i=m;~i;i--)for(j=S[h].size();j--;){for(k=S[h-1].size();k--;)D[i][h][j]=min(D[i][h][j],D[i][h-1][k]+(S[h][j].second+S[h-1][k].second)*abs(S[h][j].first-S[h-1][k].first));for(k=S[h-2].size();k--;)D[i][h][j]=min(D[i][h][j],D[i+1][h-2][k]+(S[h][j].second+S[h-2][k].second)*abs(S[h][j].first-S[h-2][k].first));}for(i=m;~i;i--)for(j=S[n].size();j--;)x=min(x,D[i][n][j]);for(i=m;i;i--)for(j=S[n-1].size();j--;)x=min(x,D[i][n-1][j]);}}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint***dp;\nint N,M;\n\nstruct Info{\n\tInfo(int arg_col,int arg_value){\n\t\tcol = arg_col;\n\t\tvalue = arg_value;\n\t}\n\tint col,value;\n};\n\nint calc(Info left,Info right){\n\treturn (left.value+right.value)*abs(left.col-right.col);\n}\n\nvoid func(){\n\n\tfor(int i = 1; i <= N+1; i++){\n\t\tfor(int k = 1; k <= 1000; k++){\n\t\t\tfor(int p = 0; p <= M; p++){\n\t\t\t\tdp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Info> V[N+1];\n\n\tint num,tmp_col,tmp_value;\n\n\tfor(int row = 1; row <= N; row++){\n\t\tscanf(\"%d\",&num);\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d %d\",&tmp_col,&tmp_value);\n\t\t\tV[row].push_back(Info(tmp_col,tmp_value));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < V[1].size();i++){\n\t\tdp[1][V[1][i].col][M] = 0;\n\t}\n\n\tif(M > 0){\n\t\tfor(int i = 0; i < V[2].size();i++){\n\t\t\tdp[2][V[2][i].col][M-1] = 0;\n\t\t}\n\t}\n\n\tint tmp;\n\n\tfor(int row = 1; row <= N-2; row++){\n\t\tfor(int a = 0; a <= M; a++){\n\t\t\tfor(int b = 0; b < V[row].size();b++){\n\n\t\t\t\tfor(int c = 0; c < V[row+1].size();c++){\n\t\t\t\t\ttmp = calc(V[row][b],V[row+1][c]);\n\t\t\t\t\tdp[row+1][V[row+1][c].col][a] = min(dp[row+1][V[row+1][c].col][a],dp[row][V[row][b].col][a]+tmp);\n\t\t\t\t}\n\n\t\t\t\tif(a != 0){\n\t\t\t\t\tfor(int c = 0; c < V[row+2].size();c++){\n\t\t\t\t\t\ttmp = calc(V[row][b],V[row+2][c]);\n\t\t\t\t\t\tdp[row+2][V[row+2][c].col][a-1] = min(dp[row+2][V[row+2][c].col][a-1],dp[row][V[row][b].col][a]+tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tfor(int a = 0; a <= M; a++){\n\t\tfor(int b = 0; b < V[N-1].size();b++){\n\n\t\t\tfor(int c = 0; c < V[N].size();c++){\n\t\t\t\ttmp = calc(V[N-1][b],V[N][c]);\n\t\t\t\tdp[N][V[N][c].col][a] = min(dp[N][V[N][c].col][a],dp[N-1][V[N-1][b].col][a]+tmp);\n\t\t\t}\n\n\t\t\tif(a != 0){\n\n\t\t\t\tdp[N+1][1][a-1] = min(dp[N+1][1][a-1],dp[N-1][V[N-1][b].col][a]);\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tfor(int a = 0; a <= M; a++){ //75\n\t\tfor(int b = 0; b < V[N].size();b++){\n\n\t\t\tdp[N+1][1][a] = min(dp[N+1][1][a],dp[N][V[N][b].col][a]);\n\n\t\t}\n\t}\n\n\n\tint minimum = BIG_NUM;\n\tfor(int k = 0; k <= M; k++){\n\t\tminimum = min(minimum,dp[N+1][1][k]);\n\t}\n\n\tprintf(\"%d\\n\",minimum);\n}\n\nint main(){\n\n\tdp = new int**[152];\n\tfor(int i = 1; i <= 151; i++){\n\t\tdp[i] = new int*[1001];\n\t\tfor(int k = 1; k <= 1000; k++){\n\t\t\tdp[i][k] = new int[76];\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define sz(v) (int)v.size()\n#define inf (int)(1e9+7)\n#define abs(x) (x >= 0 ? x : -(x))\n#define ceil(a, b) a / b + !!(a % b)\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\ntemplate<typename T> T pow(T a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\n\n\n\n\n\n\n\nint main() {\n    \n    const ll INF = 1e18;\n    const int A = 170, B = 15, C = 80;\n    int n, m;\n\n    while (cin >> n >> m && n) {\n        ll dp[A][B][C]; // 行, その行の石, 何回とばししたか\n        vector<pii> v[170];\n        \n        rep(i, n) {\n            int k;\n            cin >> k;\n            rep(j, k) {\n                int col, val;\n                cin >> col >> val;\n                v[i].eb(col, val);\n            }\n        }\n        \n        fill_n(**dp, A * B * C, INF);\n        rep(j, 15) dp[0][j][0] = 0;\n        rep(j, sz(v[1])) dp[1][j][1] = 0;\n        \n        rep(i, n - 1) {\n            \n            rep(k, sz(v[i])) {\n                rep(l, m + 1) {\n                    rep(j, sz(v[i + 1])) {\n                        ll cost = (v[i + 1][j].S + v[i][k].S) * abs(v[i + 1][j].F - v[i][k].F);\n                        chmin(dp[i + 1][j][l], dp[i][k][l] + cost);\n                        // if (dp[i + 1][j][l] == 5198) cout << v[i + 1][j].F << \" \" << v[i + 1][j].S << \" \" << v[i][k].F << \" \" << v[i][k].S << endl;\n                    }\n                    if (i <= n - 3 && l <= m - 1) {\n                        // if (l == 2) cout << i << \" \" << k << \" \" << l << endl;\n                        rep(j, sz(v[i + 2])) {\n                            \n                            ll cost = (v[i + 2][j].S + v[i][k].S) * abs(v[i + 2][j].F - v[i][k].F); // 後ろのi + 1にしてた!!\n                            \n                            if (dp[i + 2][j][l + 1] > dp[i][k][l] + cost) {\n                                chmin(dp[i + 2][j][l + 1], dp[i][k][l] + cost);\n                                // if (dp[i + 2][k][l + 1] == 27027) cout << i + 2 << \" \" << k << \" \" << l + 1 << \" \" << dp[i][k][l] << \" \" << cost << \" \" << endl;\n                            }\n                            \n                        }\n                    }\n                }\n            }\n        }\n        \n        ll ans = INF;\n        rep(j, B) rep(k, m + 1) chmin(ans, dp[n - 1][j][k]);\n        \n        rep(j, B) rep(k, m) chmin(ans, dp[n - 2][j][k]); // これ忘れてた\n        \n        \n        cout << ans << '\\n';\n        \n        \n        // cout << dp[2][0][1] << endl;\n\n        /*\n        rep(i, n) {\n            cout << endl << \"i \" << i << endl;\n            rep(j, B) {\n                cout << \"j \" << j << endl;\n                rep(k, m + 1) cout << dp[i][j][k] << \" \"; cout << endl;\n            }\n        }*/\n         \n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint k[150];\npair<int,int> stone[150][10];\n\nint memo[100][150][10];\n\nint main(){\n  int n,m;\n  while((n = getInt()) + (m = getInt())){\n    REP(i,n){\n      k[i] = getInt();\n      REP(j,k[i]){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    memset(memo,-1,sizeof(memo));\n\n    typedef pair<int,pair<int,pair<int,int> > > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    REP(i,k[0])\n      pq.push(mp(0,mp(m,mp(i,0))));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n\n      int cost = d.f;\n      int jump = d.s.f;\n      int t    = d.s.s.f;\n      int y    = d.s.s.s;\n      int x    = stone[y][t].f;\n\n      if(y == n){\n        printf(\"%d\\n\",cost);\n        break;\n      }\n\n      if(memo[jump][y][t] != -1) continue;\n      memo[jump][y][t] = cost;\n\n      if(y < n-1){\n        int d = stone[y][t].s;\n        REP(i,k[y+1]){\n          if(memo[jump][y+1][i] != -1) continue;\n          int xx = stone[y+1][i].f;\n          int dd = stone[y+1][i].s;\n#define ABS(a) ((a) < 0 ? -(a) : (a))\n          int cc = cost + (dd + d) * ABS(xx - x);\n          pq.push(mp(cc,mp(jump,mp(i,y+1))));\n        }\n      }else{\n        pq.push(mp(cost,mp(jump,mp(0,n))));\n      }\n\n      if(jump > 0){\n        if(y < n-2){\n          int d = stone[y][t].s;\n          REP(i,k[y+1]){\n            if(memo[jump-1][y+2][i] != -1) continue;\n            int xx = stone[y+2][i].f;\n            int dd = stone[y+2][i].s;\n            int cc = cost + (dd + d) * ABS(xx - x);\n            pq.push(mp(cc,mp(jump-1,mp(i,y+2))));\n          }\n        }else{\n          pq.push(mp(cost,mp(jump-1,mp(0,n))));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n, m;\nvector<pair<int, int> > data[150];\nint dp[150][10][80];\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    for(int i=0;i<n;i++) data[i].clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      for(int j=0;j<a;j++){\n        int b, c;\n        cin >> b >> c;\n        data[i].push_back(pair<int, int>(b, c));\n      }\n    }\n    fill(dp[0][0], dp[150][0], INF);\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[j].size();i++){\n        dp[j][i][m-j] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<data[i].size();j++){\n        for(int i1=0;i1<=m;i1++){\n          if(dp[i][j][i1] != INF){\n            for(int l=0;l<=1;l++){\n              if(i1-l<0) continue;\n              if(i+1+l >= n) continue;\n              for(int k=0;k<data[i+1+l].size();k++){\n                dp[i+1+l][k][i1-l] = min(dp[i+1+l][k][i1-l],\n                                   dp[i][j][i1] + (data[i][j].second + data[i+1+l][k].second) *\n                                   (abs(data[i][j].first - data[i+1+l][k].first)));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[n-1-j].size();i++){\n        for(int k=j;k<=m;k++){\n          ans = min(ans, dp[n-1-j][i][k]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint DP[151][10][76];\nint abs(int a){\n\tif(a<=0)\n\treturn -a;\n\treturn a;\n}\nint main() {\n\twhile(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n==0)\n\tbreak;\n\tint k[151],kiS[151][10],kiP[151][10];\n\tfor(int i=1;i<=n;i++ ){\n\t\tcin >> k[i];\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tcin >> kiP[i][j] >> kiS[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<151;i++)\n\t\tfor(int j=0;j<10;j++)\n\t\t\tfor(int kk=0;kk<76;kk++)\n\t\t\t\tDP[i][j][kk]=1 << 28;\n\tfor(int i=0;i<k[1];i++){\n\tDP[1][i][0]=0;\n\t}\n\tfor(int i=0;i<k[2];i++)\n\tDP[2][i][1]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int kk=0;kk<=min(m,n/2+1);kk++){\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int l=0;l<k[i-1];l++)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-1][l][kk]+(kiS[i][j]+kiS[i-1][l])*(abs(kiP[i][j]-kiP[i-1][l])));\n\t\t\t\tfor(int l=0;l<k[i-1];l++){\n\t\t\t\tif(kk!=0)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-2][l][kk-1]+(kiS[i][j]+kiS[i-2][l])*(abs(kiP[i][j]-kiP[i-2][l])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<k[i];j++)\n\t\t//\tcout << DP[i][j][0] << \" \" << i <<\" \" << j <<  endl;\n\t}*/\n\tint maxer =1 << 28;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tmaxer=min(maxer,DP[n][i][j]);\n\t\t//\tcout << n << \" \" << i << \" \" << j << \" \" << DP[n][i][j]<< endl;\n\t\t\tif(j+1<=m)\n\t\t\tmaxer=min(maxer,DP[n-1][i][m+1]);\n\t\t}\n\t}\n\tcout << maxer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1e+9;\ntypedef pair<int, int> P;\n\nint memo[151][11][80];\nint N, M;\nvector<P> G[151];\n\nint rec(int n, int p, int m){\n\tif(memo[n][p][m] != -1)\n\t\treturn memo[n][p][m];\n\t\t\n\tint res = INF;\n\tif(n > N){\n\t\treturn 0;\n\t}\n\tif(n == N){\n\t\tres = min(res, rec(n + 1, p, m));\n\t}\n\tif(n == N - 1 && m >= 1){\n\t\tres = min(res, rec(n + 2, p, m - 1));\n\t}\n\tif(n == 0){\n\t\tfor(int i = 0; i < G[0].size(); ++i){\n\t\t\tres = min(res, rec(n + 1, i, m));\n\t\t}\n\t\tif(m >= 1){\n\t\t\tfor(int i = 0; i < G[1].size(); ++i){\n\t\t\t\tres = min(res, rec(n + 2, i, m - 1));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i = 0; i < G[n].size(); ++i){\n\t\t\tres = min(res, rec(n + 1, i, m) + (G[n - 1][p].second + G[n][i].second) * abs(G[n][i].first - G[n - 1][p].first));\n\t\t}\n\t\tif(n != N - 1 && m >= 1){\n\t\t\tfor(int i = 0; i < G[n + 1].size(); ++i){\n\t\t\t\tres = min(res, rec(n + 2, i, m - 1) + (G[n - 1][p].second + G[n + 1][i].second) * abs(G[n + 1][i].first - G[n - 1][p].first));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[n][p][m] = res;\n}\n\nint main() {\n\twhile(cin >> N >> M && (N || M)){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor(int i = 0; i <= 150; ++i)\n\t\t\tG[i].clear();\n\t\tint k, d, x;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor(int j = 0; j < k; ++j){\n\t\t\t\tscanf(\"%d%d\", &d, &x);\n\t\t\t\tG[i].push_back(P(d, x));\n\t\t\t}\n\t\t}\n\t\tcout << rec(0, 0, M) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nint danger[155][1010];\nvector<int> X[155];\nint dp[155][1010][80];\n\nconst int inf = 1 << 25;\n\nint solve(int col, int row, int jump)\n{\n  if(col >= n-1) return 0;\n  if(col >= n-2 && jump < m) return 0;\n  if(jump > m) return inf;\n  if(~dp[col][row][jump]) return dp[col][row][jump];\n  int ret = inf;\n  for(int i = 0; i < X[col+1].size(); i++){\n    if(danger[col+1][X[col+1][i]] == inf) continue;\n    int D = (danger[col][row] + danger[col+1][X[col+1][i]]) * abs(row - X[col+1][i]);\n    ret = min(ret, solve(col + 1, X[col+1][i], jump) + D);\n  }\n  if(jump < m && col < n-2){\n    for(int i = 0; i < X[col+2].size(); i++){\n      if(danger[col+2][X[col+2][i]] == inf) continue;\n      int D = (danger[col][row] + danger[col+2][X[col+2][i]]) * abs(row - X[col+2][i]);\n      ret = min(ret, solve(col + 2, X[col+2][i], jump + 1) + D);\n    }\n  }\n  return dp[col][row][jump] = ret;\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 155; i++) X[i].clear();\n    for(int i = 0; i < 155; i++){\n      for(int j = 0; j < 11; j++) danger[i][j] = inf;\n    }\n    for(int i = 0; i < n; i++){\n      int k; cin >> k;\n      for(int j = 0; j < k; j++){\n\tint x, d;\n\tcin >> x >> d;\n\t--x;\n\tdanger[i][x] = d;\n\tX[i].push_back(x);\n      }\n    }\n\n    memset(dp, -1, sizeof(dp));\n    int ans = inf;\n    for(int i = 0; i < X[0].size(); i++){\n      if(danger[0][X[0][i]] == inf) continue;\n      ans = min(ans, solve(0, X[0][i], 0));\n    }\n    if(m > 0 && n > 1){\n      for(int i = 0; i < X[1].size(); i++){\n\tif(danger[1][X[1][i]] == inf) continue;\n\tans = min(ans, solve(1, X[1][i], 1));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//滑りやすさ>=0なら大丈夫.3Dにすると、メモリがたくさんいるので、2つのナップザックを使いまわす。\n#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\n\nint N,M;\nint pos[150][10];\t\t//石のある場所(x座標)\nint list[150][10];\t\t//石の滑りやすさ\nint minest[2][150][10];\t//危険度ナップザック(探索用)\n\nvoid ainst(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid acopy(int *a,int *b,int index){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = b[i];\n\t}\n}\nint amin(int *a,int index){\n\tint min = a[0];\n\tfor(int i = 1;i < index;i++){\n\t\tif(min > a[i])\n\t\t\tmin = a[i];\n\t}\n\treturn min;\n}\nint nap(int n,int mode){\t//mode:0のときは一行飛ばし可能、1のときは不可能\n\tint i,j,l;\n\tint min = 2000000000;\n\tfor(i = 0;i < n-1;i++){\n\t\tfor(j = 0;j < 10;j++){\n\t\t\tif(pos[i][j] == -1)\n\t\t\t\tbreak;\n\t\t\tif(i+2 >= n && mode == 0){\n\t\t\t\tif(min > minest[0][i][j])\n\t\t\t\t\tmin = minest[0][i][j];\n\t\t\t}\n\t\t\tfor(l = 0;l < 10;l++){\n\t\t\t\tswitch(mode){\n\t\t\t\tcase 0:\n\t\t\t\t\tif(i+2 < n && pos[i+2][l] >= 0){\n\t\t\t\t\t\tif(minest[1][i+2][l] == -1 || minest[1][i+2][l] > minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l])){\n\t\t\t\t\t\t\tminest[1][i+2][l] = minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase 1:\n\t\t\t\t\tif(pos[i+1][l] >= 0){\n\t\t\t\t\t\tif(minest[0][i+1][l] == -1 || minest[0][i+1][l] > minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l])){\n\t\t\t\t\t\t\tminest[0][i+1][l] = minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0;i < 10;i++){\n\t\tif(minest[0][n-1][i] != -1 && min > minest[0][n-1][i])\n\t\t\tmin = minest[0][n-1][i];\n\t}\n\treturn min;\n}\nint main(){\n\tint i,j,k;\n\tint mcor,now,saisyo[1000];\n\tint saicor = 0;\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0)\n\t\t\tbreak;\n\t\tsaisyo[saicor] = 2000000000;\n\t\tfor(i = 0;i < N;i++){\n\t\t\tainst(pos[i],10,-1);\n\t\t\tainst(list[i],10,-1);\n\t\t\tainst(minest[0][i],10,-1);\n\t\t\tainst(minest[1][i],10,-1);\n\t\t\tcin >> k;\n\t\t\tfor(j = 0;j < k;j++){\n\t\t\t\tcin >> pos[i][j] >> list[i][j];\n\t\t\t}\n\t\t}\n\t\tainst(minest[0][0],10,0);\n\t\tainst(minest[1][0],10,0);\n\t\t//探索開始\n\t\tfor(mcor = 0;mcor <= M;mcor++){\n\t\t\tif(mcor < M)\n\t\t\t\tnow = nap(N,0);\n\t\t\telse\n\t\t\t\tnow = nap(N,1);\n\t\t\tif(saisyo[saicor] > now)\n\t\t\t\tsaisyo[saicor] = now;\n\t\t\tfor(i = 0;i < N;i++){\n\t\t\t\tacopy(minest[0][i],minest[1][i],10);\n\t\t\t\tainst(minest[1][i],10,-1);\n\t\t\t}\n\t\t\tainst(minest[0][0],10,0);\n\t\t\tainst(minest[1][0],10,0);\n\t\t}\n\t\tsaicor++;\n\t}\n\tfor(i = 0;i < saicor;i++){\n\t\tcout << saisyo[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\nconst int INF = 1e9;\nint n, m; \nint bmemo[160][4];//b[y][x]\nvector<pair<int, int> > b[160];//\nint dp[160][4][80];//dp[y??§?¨?][x??§?¨?][1????£???°????????£??????????????°]\nint main(void){\n\twhile(1){\n\t\t//input\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) return 0;\n\t\trep(i, 160)rep(j, 4) bmemo[i][j] = INF;\n\t\trep(i, n){\n\t\t\tint k; cin >> k;\n\t\t\trep(j, k){//k???????????§?¨?\n\t\t\t\tint x, s; cin >> x >> s; x--;\n\t\t\t\tb[i].push_back(make_pair(x, s));\n\t\t\t\tbmemo[i][x] = s;\n\t\t\t}\n\t\t}\n\n\t\trep(i, 160)rep(j, 4)rep(k, 80) dp[i][j][k] = INF;\n\t\t\n\t\trep(i, 4){\n\t\t\tif(bmemo[0][i] != INF) dp[0][i][0] = 0;\n\t\t}\n\n\n\t\t//??????dp\n\t\tfor (int i = 0; i <  n - 1; ++i){\n\t\t\tfor (int j = 0; j < 4; ++j){\n\t\t\t\tfor (int k = 0; k <= m; ++k){\n\t\t\t\t\t// printf(\"%d %d %d\\n\", i, j, k);\n\t\t\t\t\tif(dp[i][j][k] == INF) continue;\n\t\t\t\t\t//??????????????£?????????\n\t\t\t\t\t// printf(\"ok %d %d %d\\n\", i, j, k);\n\t\t\t\t\tfor(auto next : b[i + 1]){\n\t\t\t\t\t\tint score = (bmemo[i][j] + next.se) * abs(j - next.fi);//?????????????????±??????\n\t\t\t\t\t\t// printf(\"bmemo %d\\n\", bmemo[i][j]);\n\t\t\t\t\t\t// printf(\"score %d\\n\", score );\n\t\t\t\t\t\tdp[i + 1][next.fi][k] = min(dp[i + 1][next.fi][k], dp[i][j][k] + score);\n\t\t\t\t\t\t// printf(\"ue %d\\n\", dp[i + 1][next.fi][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(k == m || i == n - 2) continue;\n\t\t\t\t\tfor(auto next : b[i + 2]){\n\t\t\t\t\t\tint score = (bmemo[i][j] + next.se) * abs(j - next.fi);//?????????????????±??????\n\t\t\t\t\t\t// printf(\"score %d\\n\", score );\n\t\t\t\t\t\tdp[i + 2][next.fi][k + 1] = min(dp[i + 2][next.fi][k + 1], dp[i][j][k] + score);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//????°????????????????\n\t\tint ans = INF;\n\t\tfor (int j = 0; j < 4; ++j){\n\t\t\tfor (int k = 0; k <= m; ++k){\n\t\t\t\tans = min(ans, dp[n - 1][j][k]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//  Pyon-Pyon River Crossing.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int X = 1005;\nconst int Y = 155;\n\nint N, M;\nint memo[Y][X][80];\nint river[Y][X];\n\nint rec(int y, int x, int m)\n{\n\tif(y == N-1 || (y == N-2 && m > 0)) return 0;\n\t\n\tint ans = 1<<30;\n\t\n\trep(nx, X)\n\t{\n\t\tif(river[y+1][nx] > 0)\n\t\t{\n\t\t\tchmin(ans, rec(y+1, nx, m) + (river[y][x] + river[y+1][nx]) * abs(x - nx));\n\t\t}\n\t\t\n\t\tif(river[y+2][nx] > 0 && m > 0)\n\t\t{\n\t\t\tchmin(ans, rec(y+2, nx, m-1) + (river[y][x] + river[y+2][nx] * abs(x - nx)));\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tfor(; cin >> N >> M && (N || M); )\n\t{\n\t\tmemset(memo, -1, sizeof memo);\n\t\tmemset(river, 0, sizeof river);\n\t\t\t\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\trep(j, k)\n\t\t\t{\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\t\n\t\t\t\tcin >> river[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 1<<30;\n\t\trep(x, X) if(river[0][x] > 0) chmin(ans, rec(0, x, M));\n\t\t\n\t\tcout << ans << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint a,b;\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n      for(int j=0;j<80;j++){\n\tdp[0][i][j]=dp[1][i][j]=0;\n\tif(j<m)dp[2][i][j]=0;\n      }    \n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int k=0;k<v[i-1].size();k++){\n\t  for(int l=m;l>=0;l--){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t    if(l<m){\n\t      for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][k].s)*abs(v[i][j].f-v[i-2][k].f));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)\n      for(int j=0;j<=m;j++)\n      ans=min(ans,dp[n][i][j]);\n\n    for(int i=0;i<v[n-1].size();i++)\n      for(int j=1;j<m;j++)\n\tans=min(ans,dp[n-1][i][j]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst ll INF=12345678901234LL;\n// i??????, j????????????, k??????????£???°????????£???????????¨\nll dp[150][10][150];\n\nint k[150];\nint x[150][10], d[150][10];\n\nint main()\n{\n    int n,m;\n    while(scanf(\" %d %d\", &n, &m),n)\n    {\n        rep(i,n)\n        {\n            scanf(\" %d\", &k[i]);\n            rep(j,k[i]) scanf(\" %d %d\", &x[i][j], &d[i][j]);\n        }\n\n        fill(dp[0][0],dp[150][0],INF);\n\n        // 0??????\n        rep(i,k[0]) dp[0][i][0]=0;\n        // 1??????\n        if(m>0) rep(i,k[1]) dp[1][i][1]=0;\n\n        ll ans=INF;\n        rep(r,n)rep(s,k[r])rep(j,min(76,m+1))\n        {\n            if(r==n-1 || (r==n-2 && j<m))\n            {\n                ans = min(ans, dp[r][s][j]);\n                continue;\n            }\n\n            // ??????????????£??????\n            rep(i,k[r+1])\n            {\n                ll add=(d[r][s]+d[r+1][i])*abs(x[r][s]-x[r+1][i]);\n                dp[r+1][i][j] = min(dp[r+1][i][j], dp[r][s][j]+add);\n            }\n\n            // ???????£???°???????????£??????\n            if(j<m)\n            {\n                rep(i,k[r+2])\n                {\n                    ll add=(d[r][s]+d[r+2][i])*abs(x[r][s]-x[r+2][i]);\n                    dp[r+2][i][j+1] = min(dp[r+2][i][j+1], dp[r][s][j]+add);\n                }\n            }\n        }\n\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nint dp[152][1001][77],ma[151][1001];\nint main(void){\n\tint n,m,i,j,k,l,a,x,d,t,mi,mx;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=1000;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tmx=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t\tmx=max(mx,x);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=mx;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=mx;l++){\n\t\t\t\t\t\t\tif(i+1==n+1) dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\telse if(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n+1&&k>0){\n\t\t\t\t\t\t\t\tif(i+2==n+1) dp[i+2][l][k]=min(dp[i+2][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\t\telse if(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=mx;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n+1][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[256][16][128];\nvector<P> stones[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      stones[i].clear();\n      int k;\n      cin >> k;\n      REP(j, k) {\n\tint x, d;\n\tcin >> x >> d;\n\tstones[i].push_back(P(x, d));\n      }\n    }\n\n    REP(i, N) REP(j, stones[i].size()) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, stones[0].size()) dp[0][j][0] = 0;\n    REP(i, N-1) {\n      REP(j, stones[i+1].size()) {\n\tint x_now = stones[i+1][j].first, d_now = stones[i+1][j].second;\n\tREP(k, stones[i].size()) {\n\t  int x_prev = stones[i][k].first, d_prev = stones[i][k].second;\n\t  int safe = (d_now + d_prev) * abs(x_now - x_prev);\n\t  REP(m, M+1) {\n\t    dp[i+1][j][m] = min(dp[i+1][j][m], dp[i][k][m] + safe);\n\t  }\n\t}\n\tif (i > 0) {\n\t  REP(k, stones[i-1].size()) {\n\t    int x_prev = stones[i-1][k].first, d_prev = stones[i-1][k].second;\n\t    int safe = (d_now + d_prev) * abs(x_now - x_prev);\n\t    REP(m, M) {\n\t      dp[i+1][j][m+1] = min(dp[i+1][j][m+1], dp[i-1][k][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, stones[N-1].size()) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rep(i, n) for(int i = 0; i < (n); i++)\n#define fr first\n#define sc second\n#define pb(a) push_back(a)\n#define INF INT_MAX\nusing namespace std;\n\ntypedef pair<int, int> P;\nvector<P> mp[151];\nint n, m, dp[151][1001][76];\n\nvoid initDp(){\n  Rep(i, 151) mp[i].clear();\n  Rep(i, 151){\n    Rep(j, 1001){\n      Rep(k, 76){\n\tdp[i][j][k] = INF;\n      }\n    }\n  }\n}\n\nint solve(int row, int cn, int jump){\n  if(row == n-1 || (row == n-2 && jump > 0)) return 0;\n  int slv = dp[row][cn][jump];\n  if(slv == INF){\n    int col = mp[row][cn].fr;\n    int stn = mp[row][cn].sc;\n    if(row+2 < n && jump > 0){\n      Rep(i, mp[row+2].size()){\n\tint ncol = mp[row+2][i].fr;\n\tint nstn = mp[row+2][i].sc;\n\tint dng  = (stn + nstn) * abs(col - ncol);\n\tslv = min(slv, solve(row+2, i, jump-1)+dng);\n      }\n    }\n    if(row+1 < n){\n      Rep(i, mp[row+1].size()){\n\tint ncol = mp[row+1][i].fr;\n\tint nstn = mp[row+1][i].sc;\n\tint dng  = (stn + nstn) * abs(col - ncol);\n\tslv = min(slv, solve(row+1, i, jump)+dng);\n      }\n    }\n  }\n  return dp[row][cn][jump] = slv;\n}\n\nint main(){\n  while(1){\n    initDp();\n    cin >> n >> m;\n    if(n == 0 && m == 0) return 0;\n    Rep(i, n){\n      int k; cin >> k;\n      Rep(j, k){\n\tint x, d;\n\tcin >> x >> d;\n\tmp[i].pb(P(x-1, d));\n      }\n    }\n    \n    int mn = INF;\n    Rep(i, mp[0].size()){\n      mn = min(mn, solve(0, i, m));\n    }\n    if(m > 0){\n      Rep(i, mp[1].size()){\n\tmn = min(mn, solve(1, i, m-1));\n      }\n    }\n\n    cout << mn << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nll n;\nstruct P {\n\tll slip, place;\n};\nP a[152][10];\nll dp[152][10][1000];\nll siz[152];\nll solve(ll i, ll j,ll m) {\n\tif (i == n) return 0;\n\tll sum = 80000000000000000;\n\tfor (ll z = 0; z < siz[i+1]; z++) {\n\t\tll res = (a[i + 1][z].place - a[i][j].place);\n\t\tres = max(res, 0 - res);\n\t\tres *= (a[i + 1][z].slip + a[i][j].slip);\n\t\tif (dp[i + 1][z][m] != -1) {\n\t\t\tsum = min(sum, res + dp[i + 1][z][m]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + 1][z][m] =\n\t\t\t\tsolve(i + 1, z, m)));\n\t\t}\n\t}\n\tif (m > 0&&i+2<=n) {\n\t\tfor (ll z = 0; z < siz[i+2]; z++) {\n\t\t\tll res = (a[i + 2][z].place - a[i][j].place);\n\t\t\tres = max(res, 0 - res);\n\t\t\tres *= (a[i + 2][z].slip + a[i][j].slip);\n\t\t\tif (dp[i + 2][z][m-1] != -1) {\n\t\t\t\tsum = min(sum, res + dp[i + 2][z][m-1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = min(sum, res + (dp[i + 2][z][m-1] = \n\t\t\t\t\tsolve(i + 2, z, m-1)));\n\t\t\t}\n\t\t}\n\t}\n\telse if (m > 0 && i + 2 == n + 1) {\n\t\tsum = 0;\n\t}\n\treturn sum;\n}\nint main() {\n\tll m;\n\twhile (cin >> n >> m&&(n!=0||m!=0)) {\n\t\tfor (ll i = 1; i <= n; i++) {\n\t\t\tll k;\n\t\t\tcin >> k;\n\t\t\tsiz[i] = k;\n\t\t\tfor (ll j = 0; j < k; j++) {\n\t\t\t\tcin >> a[i][j].place >> a[i][j].slip;\n\t\t\t\tfor (ll z = 0; z <= m; z++)\n\t\t\t\t\tdp[i][j][z] = -1;\n\t\t\t}\n\t\t}\n\t\tll sum = 80000000000000;\n\t\tfor (ll i = 0; i < siz[1]; i++) {\n\t\t\tsum = min(sum, solve(1, i, m));\n\t\t}\n\t\tif (m > 0 && 2 <= n) {\n\t\t\tfor (ll i = 0; i < siz[2]; i++) {\n\t\t\t\tif (dp[2][i][m - 1] != -1)\n\t\t\t\t\tsum = min(sum, dp[2][i][m - 1]);\n\t\t\t\telse\n\t\t\t\t\tsum = min(sum, dp[2][i][m - 1] = solve(2, i, m - 1));\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[256][16][128];\nint stones[256][16][2];\nint col[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tREP(k, 2) cin >> stones[i][j][k];\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tREP(m, M+1) {\n\t  if (dp[i][j][m] == INF) continue;\n\t  int x_now = stones[i][j][0], d_now = stones[i][j][1];\n\t  REP(k, col[i+1]) {\n\t    int x_next = stones[i+1][k][0], d_next = stones[i+1][k][1];\n\t    int safe = (d_now + d_next) * abs(x_now - x_next);\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + safe);\n\t  }\n\t  if (i < N-2 && m < M-1) {\n\t    REP(k, col[i+2]) {\n\t      int x_next = stones[i+2][k][0], d_next = stones[i+2][k][1];\n\t      int safe = (d_now + d_next) * abs(x_now - x_next);\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint dp[3][1000][80];\nint main(){\n  int n,m,k,x,d;\n  while(cin>>n>>m&&(n||m)){\n    vector<P>stone[150];\n    REP(i,n){\n      cin>>k;\n      REP(j,k){\n        cin>>x>>d;x--;\n        stone[i].PB(MP(x,d));\n      }\n    }\n    REP(i,3)REP(j,1000)REP(k,80)dp[i][j][k]=INF;\n    REP(i,stone[0].size())dp[0][stone[0][i].first][0]=0;\n    REP(i,stone[1].size())dp[1][stone[1][i].first][1]=0;\n    REP(i,n-1){\n      REP(j,1000)REP(x,80)dp[(i+2)%3][j][x]=INF;\n      REP(j,stone[i].size()){\n        REP(x,stone[i+1].size()){\n          REP(y,m+1){\n            dp[(i+1)%3][stone[i+1][x].first][y]=min(dp[(i+1)%3][stone[i+1][x].first][y],dp[i%3][stone[i][j].first][y]+(stone[i][j].second+stone[i+1][x].second)*abs(stone[i][j].first-stone[i+1][x].first));\n          }\n        }\n        if(i==n-2){\n          continue;\n        }else{\n          REP(x,stone[i+2].size()){\n            REP(y,m){\n              dp[(i+2)%3][stone[i+2][x].first][y+1]=min(dp[(i+1)%3][stone[i+2][x].first][y+1],dp[i%3][stone[i][j].first][y]+(stone[i][j].second+stone[i+2][x].second)*abs(stone[i][j].first-stone[i+2][x].first));\n            }\n          }\n        }\n      }\n    }\n    int ans=INF;\n    REP(i,stone[n-2].size())REP(j,m)ans=min(ans,dp[(n-2)%3][stone[n-2][i].first][j]);\n    REP(i,stone[n-1].size())REP(j,m+1)ans=min(ans,dp[(n-1)%3][stone[n-1][i].first][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct node{int line,row;};\nstruct edge{int cost; node now,to; };\n\ntypedef pair<int,int> P;\n\nvector<edge>G[MAX_V];\nint n,m;\n\nvoid solved(void){\n  int dp[155][11][80];\n\n for(int i=0;i<101;i++)\n   for(int j=0;j<=10;j++)\n     for(int k=0;k<80;k++)\n     dp[i][j][k]=INF;\n\n for(int i=0;i<11;i++)\n   dp[0][i][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n      edge e=G[i][j];\n      for(int k=0;k<=m;k++){\n\n\tif(i+1==e.to.line)dp[e.to.line][e.to.row][k]=min(dp[e.to.line][e.to.row][k],dp[e.now.line][e.now.row][k]+e.cost);\n\tif(i+2==e.to.line && k!=0)\n\t  dp[e.to.line][e.to.row][m-k]=min(dp[e.to.line][e.to.row][m-k],dp[e.now.line][e.now.row][m-k+1]+e.cost);\n      }\n    }\n  }\n  int ans=INF;    \n    for(int k=0;k<11;k++)\n      for(int j=0;j<=m;j++)\n\tans=min(ans,dp[n+1][k][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n\n    for(int i=0; i<MAX_V; i++)\n      for(int j=0;j<1005;j++)\n      graph[i][j]=0;\n \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n\n    edge e;\n    for(int i=0; i<=n; i++){\n      e.now.line=i;\n      e.now.row=e.to.row=0;\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  int row1=0,row2=0;\n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0 || i>=n){\n\n\t      if(graph[i+1][l]>0 || i+1==n+1){\n\t\te.to.line=i+1;\t      \n\t\te.cost=0;\n\t\te.to.row=row1;\n\t\trow1++;\n\t\tG[i].push_back(e);\n\t      }\n\t      if(graph[i+2][l]>0 || i+2==n+1){\n\t\te.to.line=i+2;\n\t\te.cost=0;\n\t\te.to.row=row2;\n\t\trow2++;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\t        \n\t    if(graph[i+1][l]>0){\n\t      e.to.line=i+1;\n\t      e.to.row=row1;\n\t      row1++;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);    \n\t    }\n\t    if(graph[i+2][l]>0){\n\t      e.to.line=i+2;\t      \n\t      e.to.row=row2;\n\t      row2++;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);  \n\t    }\n\n\t  }\n\t  if(i)e.now.row++;\n\t  if(i==0)break;\n\t}\n      }\n    }\n    solved();  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1000;\nunsigned int dp[MAX_X][5][75];\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n >> m && n)\n\t{\n\t\trep(x,MAX_X) rep(y,n) rep(d,m+1) dp[x][y % 5][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\trep(i,MAX_X)rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tr[x][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[x][0][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[x][1][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++) for(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ツ津環湘ュツジツδδδ督プ\n\t\t\t\trep(nx, MAX_X) rep(d, m+1)\n\t\t\t\t\tif(dp[nx][(y-1) % 5][d] != INF)\n\t\t\t\t\t\tchmin(dp[x][y % 5][d], dp[nx][(y-1) % 5][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// ツ暗ェツ段ツづづ篠つオ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[nx][(y-2) % 5][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[x][y % 5][d-1], dp[nx][(y-2) % 5][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\n\t\tunsigned int res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[x][(n-1) % 5][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[x][(n-2) % 5][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\n#define min3(i,j,k) min(min((i),(j)),(k))\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(void){\n    int n,m,k,a,b;\n    int dp[150][10][76];\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tvector< vector<pii> > s(n,vector<pii>(0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\ts[i].push_back(pii(a,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=m;i++)for(int j=0;j<10;j++)dp[0][j][i]=0;\n\t\tfor(int i=0;i<=m;i++)for(int j=0;j<10;j++)for(int l=1;l<n;l++)dp[l][j][i]=9999999;\n\t\tfor(int i=0;i<=m;i++){\n\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\tint l=s[j].size();\n\t\t\t\tint lb=s[j-1].size();\n\t\t\t\tfor(int w=0;w<l;w++){\n\n\t\t\t\t\tif(i>0 && j>1){\n\t\t\t\t\t\tlb = s[j-2].size();\n\t\t\t\t\t\tfor(int c=0;c<lb;c++){\n\t\t\t\t\t\t\tdp[j][w][i] = min3(dp[j][w][i],\n                                dp[j-1][c][i]+abs(s[j][w].first-s[j-1][c].first)*(s[j][w].second+s[j-1][c].second),\n\t\t\t\t\t\t\t\tdp[j-2][c][i]+abs(s[j][w].first-s[j-2][c].first)*(s[j][w].second+s[j-2][c].second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t    for(int c=0;c<lb;c++){\n                            dp[j][w][i] = min(dp[j][w][i],\n                                dp[j-1][c][i]+abs(s[j][w].first-s[j-1][c].first)*(s[j][w].second+s[j-1][c].second));\n\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 9999999;\n\t\tfor(int i=0;i<s[n-1].size();i++){\n\t\t    ans=min(ans,dp[n-1][i][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\n\nvoid solve(void){\nint dp[1005][101];\n\n for(int i=0;i<1005;i++)\n   for(int j=0;j<=m;j++)\n     dp[i][j]=INF;\n\n   dp[0][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n\tedge e=G[i][j];\n\tfor(int k=0;k<=m;k++){\n\t  if(i+1==e.to)dp[i+1][k]=min(dp[i+1][k],dp[i][k]+e.cost);\n\t  if(i+2==e.to && k!=0)dp[i+2][m-k]=min(dp[i+2][m-k],dp[i][m-k+1]+e.cost);\n\t}\n    }\n  }\n  int ans=INF;\n  for(int j=0;j<=m;j++)\n    ans=min(ans,dp[n+1][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0){\n\t      if(graph[i+1][l]>0){\n\t\te.to=i+1;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      \n\t      if(graph[i+2][l]>0){\n\t\te.to=i+2;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+1==n+1){\n\t      e.to=i+1;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+2==n+1){\n\t      e.to=i+2;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t  }\n\t}\n      }\n    }\n    solve();\n    //cout << dijkstra(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nll dp[151][11][76],ma[151][11];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=10;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=10;l++){\n\t\t\t\t\t\t\tif(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n&&k>0){\n\t\t\t\t\t\t\t\tif(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=5;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=10;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> T;\ntypedef pair<P,P> F;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nmap<F,int> edge;\nint stone[160][1010];\nint n,m;\nint d[160][100];\nbool used[160];\nvector<P> node;\nvoid dijkstra()\n{\n\t//fill(d,d+160,INF);\n\tfor(int i=0;i<160;i++)\n\t{\n\t\tfor(int j=0;j<100;j++)\n\t\t{\n\t\t\td[i][j]=INF;\n\t\t}\n\t}\n\tfill(used,used+160,false);\n\td[0][m]=0;\n\tfor(int i=0;i<node.size();i++)\n\t{\n\t\tfor(int j=0;j<node.size();j++)\n\t\t{\n\t\t\tif(edge.find(F(node[i],node[j]))==edge.end())continue;\n\t\t\tif(node[j].fi-node[i].fi==2)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<m;k++)\n\t\t\t\t{\n\t\t\t\t\td[j][k]=min(d[j][k],d[i][k+1]+edge[F(node[i],node[j])]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=m;k++)\n\t\t\t\t{\n\t\t\t\t\td[j][k]=min(d[j][k],d[i][k]+edge[F(node[i],node[j])]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*priority_queue<T,vector<T>,greater<T> > q;\n\tq.push(T(0,P(0,m)));\n\twhile(!q.empty())\n\t{\n\t\tT a=q.top();\n\t\tq.pop();\n\t\tint x=a.sec.fi,y=a.sec.sec;\n\t\tif(d[x][y]<a.fi)continue;\n\t\tfor(int u=0;u<node.size();u++)\n\t\t{\n\t\t\tif(edge.find(F(node[x],node[u]))==edge.end())continue;\n\t\t\tif(node[u].fi-node[x].fi==2)\n\t\t\t{\n\t\t\t\tif(y==0)continue;\n\t\t\t\tif(d[u][y-1]>d[x][y]+edge[F(node[x],node[u])])\n\t\t\t\t{\n\t\t\t\t\td[u][y-1]=d[x][y]+edge[F(node[x],node[u])];\n\t\t\t\t\tq.push(T(d[u][y-1],P(u,y-1)));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(d[u][y]>d[x][y]+edge[F(node[x],node[u])])\n\t\t\t{\n\t\t\t\td[u][y]=d[x][y]+edge[F(node[x],node[u])];\n\t\t\t\tq.push(T(d[u][y],P(u,y)));\n\t\t\t}\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tint v=-1;\n\t\tfor(int u=0;u<node.size();u++)\n\t\t{\n\t\t\tif(!used[u]&&(v==-1||d[u]<d[v]))v=u;\n\t\t}\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tfor(int u=0;u<node.size();u++)\n\t\t{\n\t\t\tif(edge.find(F(node[v],node[u]))==edge.end())continue;\n\t\t\tif(node[u].fi-node[v].fi==2)\n\t\t\t{\n\t\t\t\tif(nidan[v]==m)continue;\n\t\t\t\tif(d[u]>d[v]+edge[F(node[v],node[u])])\n\t\t\t\t{\n\t\t\t\t\td[u]=d[v]+edge[F(node[v],node[u])];\n\t\t\t\t\tnidan[u]=nidan[v]+1;\n\t\t\t\t}\n\t\t\t\telse if(d[u]==d[v]+edge[F(node[v],node[u])])\n\t\t\t\t{\n\t\t\t\t\tnidan[u]=min(nidan[u],nidan[v]+1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(d[u]>d[v]+edge[F(node[v],node[u])])\n\t\t\t{\n\t\t\t\td[u]=d[v]+edge[F(node[v],node[u])];\n\t\t\t\tnidan[u]=nidan[v];\n\t\t\t}\n\t\t\telse if(d[u]==d[v]+edge[F(node[v],node[u])])\n\t\t\t{\n\t\t\t\tnidan[u]=min(nidan[u],nidan[v]);\n\t\t\t}\n\t\t\telse\n\t\t\t{}\n\t\t}\n\t}*/\n\treturn;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tint ans=INF;\n\t\tnode.clear();\n\t\tedge.clear();\n\t\tmemset(stone,0,sizeof(stone));\n\t\tnode.pb(P(0,0));\n\t\tvector<int> tmp[155];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i][a]=b;\n\t\t\t\tnode.pb(P(i,a));\n\t\t\t\ttmp[i].pb(a);\n\t\t\t}\n\t\t}\n\t\tnode.pb(P(n+1,0));\n\t\tfor(int i=1;i<=2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<tmp[i].size();j++)\n\t\t\t{\n\t\t\t\tedge[F(P(0,0),P(i,tmp[i][j]))]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<tmp[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<tmp[i+1].size();k++)\n\t\t\t\t{\n\t\t\t\t\tedge[F(P(i,tmp[i][j]),P(i+1,tmp[i+1][k]))]=(stone[i][tmp[i][j]]+stone[i+1][tmp[i+1][k]])*(abs(tmp[i][j]-tmp[i+1][k]));\n\t\t\t\t}\n\t\t\t\tif(i!=n-1)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<tmp[i+2].size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tedge[F(P(i,tmp[i][j]),P(i+2,tmp[i+2][k]))]=(stone[i][tmp[i][j]]+stone[i+2][tmp[i+2][k]])*(abs(tmp[i][j]-tmp[i+2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<tmp[n-i].size();j++)\n\t\t\t{\n\t\t\t\tedge[F(P(n-i,tmp[n-i][j]),P(n+1,0))]=0;\n\t\t\t}\n\t\t}\n\t\tdijkstra();\n\t\t//cout <<node.size() << endl;\n\t\t//cout << d[node.size()-1] << endl;\n\t\t//cout << edge[F(node[0],node[1])]<<' '<<edge[F(node[0],node[2])]<<' '<<edge[F(node[1],node[3])]<<' '<<edge[F(node[2],node[3])]<<' '<<edge[F(node[3],node[4])] << endl;\n\t\t/*for(int i=0;i<node.size();i++)\n\t\t{\n\t\t\tcout << node[i].fi <<' ' << node[i].sec<<' '<<d[i]<<endl;\n\t\t}*/\n\t\tfor(int i=0;i<=m;i++)\n\t\t{\n\t\t\tans=min(ans,d[node.size()-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nint main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[150][75]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%d\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%d%d\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e > 2 && j<b) {\n\t\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 1][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = 1 << 29;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nll dp[155][10][80];\nint main(void){\n\tint n, m;\n\twhile(cin >> n >> m && n && m){\n\tvector<pair<ll, ll> > s[151];\n\tREP(i, 155){\n\t\tREP(j, 10){\n\t\t\tfill(dp[i][j], dp[i][j]+80, INF_LL);\n\t\t}\n\t}\n\tREP(i, n){\n\t\tint k;\n\t\tcin >> k;\n\t\tREP(j, k){\n\t\t\tint x, d;\n\t\t\tcin >> x >> d;\n\t\t\ts[i].push_back({x, d});\n\t\t}\n\t}\n\tREP(i, s[0].size()){\n\t\tdp[0][i][0] = 0;\n\t}\n\tREP(i, s[1].size()){\n\t\tdp[1][i][1] = 0;\n\t}\n\tREP(i, n-1){\n\t\tREP(j, s[i].size()){\n\t\t\tREP(k, m+1){\n\t\t\t\tREP(t, s[i+1].size()){\n\t\t\t\t\tdp[i+1][t][k] = min(dp[i+1][t][k], dp[i][j][k] + (s[i][j].snd+s[i+1][t].snd)*abs(s[i][j].fst-s[i+1][t].fst));\n\t\t\t\t}\n\t\t\t\tif(i < n-2){\n\t\t\t\t\tREP(t, s[i+2].size()){\n\t\t\t\t\t\tdp[i+2][t][k+1] = min(dp[i+2][t][k+1], dp[i][j][k] + (s[i][j].snd+s[i+2][t].snd)*abs(s[i][j].fst-s[i+2][t].fst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res = INF_LL;\n\tREP(j, s[n-1].size()){\n\t\tREP(k, m+1){\n\t\t\tres = min(dp[n-1][j][k], res);\n\t\t}\n\t}\n\tREP(j, s[n-2].size()){\n\t\tREP(k, m){\n\t\t\tres = min(dp[n-2][j][k], res);\n\t\t}\n\t}\n\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint memo[100][150][150];\n\nint main(){\n  int n,m;\n  while(n=getInt(), m=getInt(), n+m){\n    vector<vector<pair<int,int> > > stone(n);\n    memset(memo, -1, sizeof(memo));\n    REP(i,n){\n      int num = getInt();\n      stone[i] = vector<pair<int,int> >(num);\n      REP(j,num){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    FOR(it,stone[0]) memo[m][0][it->f] = 0;\n    if(m != 0) FOR(it,stone[1]) memo[m-1][1][it->f] = 0;\n\n\n    REP(i,n-1){\n      FOR(it,stone[i]){\n        int j = it->f;\n        int s = it->s;\n        REP(k,m+1){\n          if(memo[k][i][j] != -1){\n            FOR(it2,stone[i+1]){\n              int jj = it2->f;\n              int ss = it2->s;\n              int mm = memo[k][i][j];\n\n              if(memo[k][i+1][jj] == -1)\n                memo[k][i+1][jj] = mm + (s + ss)*abs(j - jj);\n              else\n                memo[k][i+1][jj] = min(memo[k][i+1][jj], mm + (s + ss)*abs(j - jj));\n            }\n\n            if(k != 0 && i != n-2){\n              FOR(it2,stone[i+2]){\n                int jj = it2->f;\n                int ss = it2->s;\n                int mm = memo[k][i][j];\n\n                if(memo[k-1][i+2][jj] == -1)\n                  memo[k-1][i+2][jj] = mm + (s + ss)*abs(j - jj);\n                else\n                  memo[k-1][i+2][jj] = min(memo[k][i+2][jj], mm + (s + ss)*abs(j - jj));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    //puts(\"0:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[0][i][j]); puts(\"\"); }\n    //puts(\"1:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[1][i][j]); puts(\"\"); }\n\n    int ans = INT_MAX;\n    REP(j,n) REP(k,m+1){\n      if(memo[k][n-1][j] != -1)\n        ans = min(ans, memo[k][n-1][j]);\n      if(k != 0){\n        if(memo[k][n-2][j] != -1)\n          ans = min(ans, memo[k][n-2][j]);\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n#define N 153\n#define COL 1001\nusing namespace std;\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\nint dijkstra(int n,int m,int D[][COL],const vector< vector<int> > &T){\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  bool vis[N][COL]={false,};\n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    if(s.r==n+1||s.r==n+2)return s.cost;\n    vis[s.r][s.c]=true;\n    for(int k=1;k<=2;++k){for(int i=0;i<T[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=T[nxr][i],nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(s.c-nxc);\n\tif(s.r==0||nxr==n+1||nxr==n+2)nxcost=s.cost;\n\tstate next(nxr,nxc,nxcost,s.left-(k-1));if(!vis[nxr][nxc]&&next.left>=0){qs.push(next);}\n      }\n    }\n  }\n  return -1;\n}\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(n==0&&m==0)break;\n    vector< vector<int> > T(n+3);T[n+1].push_back(0);T[n+2].push_back(0);\n    int D[N][COL]={{0,},};\n    for(int i=0;i<n;++i){int k;cin>>k;for(int j=0;j<k;++j){int col,danger;cin>>col>>danger;T[i+1].push_back(col);D[i+1][col]=danger;}}\n    cout<<dijkstra(n,m,D,T)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,m;\n  while(cin >> n >> m, n) {\n    int k[n];\n    int x[n][10];\n    int c[n][10];\n    REP(y,n) {\n      cin >> k[y];\n    \n      REP(i,k[y]) {\n        cin >> x[y][i] >> c[y][i];\n      }\n    }\n  \n    int dp[n][10][m+1];           // dp[i][j][k] = i sÚÌ j ÔÚÌÎÉ¢ÄAcèk ñQsòÎµÌWvªÅ«éÆ«ÌÅ¬ë¯x\n    REP(i,n) REP(j,10) REP(l, m+1) dp[i][j][l] = INF;\n    REP(j,k[0])\n      dp[0][j][m] = 0;\n    if (m>0)\n      REP(j, k[1])\n        dp[1][j][m-1] = 0;\n\n    \n    for (int i=1; i<n; ++i) {\n      REP(j,k[i]) {\n        REP(l,m+1) {\n          REP(jj, k[i-1])         // PsWv\n            dp[i][j][l] = min(dp[i][j][l], dp[i-1][jj][l] + (c[i][j]+c[i-1][jj])*abs(x[i][j]-x[i-1][jj]));\n          if (i>=2 && l>=1) {\n            REP(jj, k[i-2]) {\n              dp[i][j][l-1] = min(dp[i][j][l-1], dp[i-2][jj][l] + (c[i][j]+c[i-2][jj])*abs(x[i][j]-x[i-2][jj]));\n            }\n          }\n        }\n        //    cout << i << \" \" << j << \" \" <<dp[i][j][0] << \" \" <<dp[i][j][1]  << endl;\n      }\n    }\n    int res = INF;\n    REP(i, k[n-1]) {\n      REP(j,m+1)\n        res = min(res, dp[n-1][i][j]);\n    }\n    REP(i, k[n-2]) {\n      for (int j=1;j<=m; ++j)\n        res= min(res, dp[n-2][i][j]);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 50000000000;\n\nint n, m;\nint K[152], x[152][10], d[152][10];\nlong long dp[152][10];\n\nvoid init()\n{\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tmemset(K, 0, sizeof(K));\n\tK[0] = 1;\n\tK[n + 1] = 1;\n\tmemset(x, 0, sizeof(x));\n\tmemset(d, 0, sizeof(d));\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\t\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (m--){\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n - 1) dp[i + 2][k] = min(dp[i + 2][k], dp[i][j]);\n\t\t\t\t\t\telse dp[i + 2][k] = min(dp[i + 2][k], dp[i][j] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long mini = INF;\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tmini = min(mini, dp[n + 1][i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    m=100;\n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\t\t       \n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  \n\t}\n\t\n      }\n    }\n    \n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define INF 1145141919\n\nint N, M;\nint W;\nint T[160][1010];\nint dp[160][1010][80];\n\nint main() {\n  while (cin >> N >> M) {\n    if (N == 0 && M == 0) break;\n    for (int i=0; i<160; i++) {\n      for (int j=0; j<1010; j++) {\n        T[i][j] = -1;\n      }\n    }\n    W = 0;\n    for (int i=0; i<N; i++) {\n      int k;\n      cin >> k;\n      for (int j=0; j<k; j++) {\n        int x, d;\n        cin >> x >> d;\n        T[i][x-1] = d;\n        W = max(W, x);\n      }\n    }\n\n    for (int i=0; i<160; i++) {\n      for (int j=0; j<1010; j++) {\n        for (int m=0; m<80; m++) {\n          dp[i][j][m] = INF;\n        }\n      }\n    }\n    for (int i=0; i<W; i++) {\n      if (T[0][i] > 0) dp[0][i][0] = 0;\n      if (T[1][i] > 0) dp[1][i][1] = 0;\n    }\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<W; j++) {\n        for (int m=0; m<=M; m++) {\n          if (dp[i][j][m] == INF) continue;\n          for (int nj=0; nj<W; nj++) {\n            if (T[i+1][nj] > 0) {\n              dp[i+1][nj][m] = min(dp[i+1][nj][m], dp[i][j][m] + abs(j - nj)*(T[i+1][nj] + T[i][j]));\n            }\n            if (T[i+2][nj] > 0) {\n              dp[i+2][nj][m+1] = min(dp[i+2][nj][m+1], dp[i][j][m] + abs(j - nj)*(T[i+2][nj] + T[i][j]));\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for (int i=0; i<W; i++) {\n      for (int m=0; m<=M; m++) {\n        if (m < M) ans = min(ans, dp[N-2][i][m]);\n        ans = min(ans, dp[N-1][i][m]);\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint DP[151][10][76];\nint main() {\n\twhile(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n==0)\n\tbreak;\n\tint k[151],kiS[151][10],kiP[151][10];\n\tfor(int i=1;i<=n;i++ ){\n\t\tcin >> k[i];\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tcin >> kiP[i][j] >> kiS[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<151;i++)\n\t\tfor(int j=0;j<10;j++)\n\t\t\tfor(int kk=0;kk<76;kk++)\n\t\t\t\tDP[i][j][kk]=1 << 28;\n\tfor(int i=0;i<k[1];i++){\n\tDP[1][i][0]=0;\n\t}\n\tfor(int i=0;i<k[2];i++)\n\tDP[2][i][1]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int kk=0;kk<=min(m,n/2+1);kk++){\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int l=0;l<k[i-1];l++)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-1][l][kk]+(kiS[i][j]+kiS[i-1][l])*(abs(kiP[i][j]-kiP[i-1][l])));\n\t\t\t\tfor(int l=0;l<k[i-1];l++){\n\t\t\t\tif(kk!=0)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-2][l][kk-1]+(kiS[i][j]+kiS[i-2][l])*(abs(kiP[i][j]-kiP[i-2][l])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<k[i];j++)\n\t\t//\tcout << DP[i][j][0] << \" \" << i <<\" \" << j <<  endl;\n\t}*/\n\tint maxer =1 << 28;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tmaxer=min(maxer,DP[n][i][j]);\n\t\t//\tcout << n << \" \" << i << \" \" << j << \" \" << DP[n][i][j]<< endl;\n\t\t\tif(m+1<=m)\n\t\t\tmaxer=min(maxer,DP[n-1][i][m+1]);\n\t\t}\n\t}\n\tcout << maxer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1000000000;\nint n, m;\nvector<vector<P>> map;\nint dp[150][10][80];\n\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tmap.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tfor (int j = 0; j < tmp; j++) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tmap[i].push_back(P(a - 1, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 150; i++)for (int j = 0; j < 10; j++)for (int k = 0; k < 80; k++)dp[i][j][k] = INF;\n\t\tfor (int i = 0; i < map[0].size(); i++) {\n\t\t\tdp[0][map[0][i].first][m] = 0;\n\t\t}\n\t\tfor (int i = 0; i < map[1].size(); i++) {\n\t\t\tif (m != 0)dp[1][map[1][i].first][m - 1] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = 0; j < map[i].size(); j++) {\n\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\tif (i + 1 < n) {\n\t\t\t\t\t\tfor (int l = 0; l < map[i + 1].size(); l++) {\n\t\t\t\t\t\t\tauto now = map[i][j];\n\t\t\t\t\t\t\tauto next = map[i + 1][l];\n\t\t\t\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k],\n\t\t\t\t\t\t\t\tdp[i][j][k] + abs(next.first - now.first) * (now.second + next.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 2 < n && k != 0) {\n\t\t\t\t\t\tfor (int l = 0; l < map[i + 2].size(); l++) {\n\t\t\t\t\t\t\tauto now = map[i][j];\n\t\t\t\t\t\t\tauto next = map[i + 2][l];\n\t\t\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1],\n\t\t\t\t\t\t\t\tdp[i][j][k] + abs(next.first - now.first) * (now.second + next.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < map[n - 2].size(); i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tans = min(ans, dp[n - 2][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < map[n - 1].size(); i++) {\n\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\tans = min(ans, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tmap.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\tint ki;\n\tvector<P> stone[150];\n\tint dp[150][10][80];\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tstone[i].clear();\n\t\t\tfor(int j = 0;j < 10;j++){\n\t\t\t\tfor(int k = 0;k <= m;k++) dp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> ki;\n\t\t\tfor(int j = 0;j < ki;j++){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i].push_back(P(a - 1,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < stone[0].size();i++){\n\t\t\tdp[0][i][0] = 0;\n\t\t}\n\t\tfor(int i = 0;i < stone[1].size();i++){\n\t\t\tdp[1][i][1] = 0;\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tfor(int j = 0;j < stone[i].size();j++){\n\t\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\t\tfor(int l = 0;l < stone[i - 1].size();l++){\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k],dp[i - 1][l][k] + (stone[i][j].second + stone[i - 1][l].second) * abs(stone[i][j].first - stone[i - 1][l].first));\n\t\t\t\t\t}\n\t\t\t\t\tif(i >= 2 && k >= 1){\n\t\t\t\t\t\tfor(int l = 0;l < stone[i - 2].size();l++){\n\t\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k],dp[i - 2][l][k - 1] + (stone[i][j].second + stone[i - 2][l].second) * abs(stone[i][j].first - stone[i - 2][l].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < stone[n - 1].size();i++){\n\t\t\tfor(int j = 0;j <= m;j++){\n\t\t\t\tmi = min(mi,dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#define INF (1000000000)\n#define MOD (1000000007)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\ntypedef vector<long>::iterator VL;\ntypedef vector<long>::iterator VLI;\ntypedef pair<int, int> P;\n\n\nint d[150][1000];\nlong dp[150][1000][100];\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tmemset(d, 0, sizeof(d))\n;\t\tfor (int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; j++){\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tx--;\n\t\t\t\tscanf(\"%d\", &d[i][x]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j < 1000; j++){\n\t\t\t\tfor (int k = 0; k < 100; k++){\n\t\t\t\t\tif (i == 0 && d[i][j] && k == 0) dp[i][j][k] = 0;\n\t\t\t\t\telse dp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 1000; j++){\n\t\t\t\tfor (int k = 0; k < 1000; k++){\n\t\t\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\t\t\tif (d[i][j] && d[i + 1][k]){\n\t\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (d[i][j] + d[i + 1][k]) * abs(j - k));\n\t\t\t\t\t\t\t//printf(\"%d\\n\", dp[i + 1][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i < n - 1 && d[i][j] && d[i + 2][k]){\n\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (d[i][j] + d[i + 2][k]) * abs(j - k));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong mini = INF;\n\t\tfor (int i = 0; i < 1000; i++){\n\t\t\tfor (int j = 0; j <= m; j++){\n\t\t\t\tmini = min(mini, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%ld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int INF=1e9;\nstruct data{\n    int x,d;\n    data(int a,int b){\n        x=a;d=b;\n    }\n};\nint abso(data a,data b){\n    int ans=a.x-b.x;\n    if(ans<0)ans*=-1;\n    return ans;\n}\nint dp[77][200][1001];\nint main(){\n    int n,m;\n    while(cin>>n>>m,n||m){\n        vector<vector<data> >stone(n+2);\n        int k;\n        for(int i=0;i<n;i++){\n            cin>>k;\n            for(int j=0;j<k;j++){\n                int x,d;\n                cin>>x>>d;\n                stone[i+1].push_back(data(x-1,d));\n            }\n        }\n\n\n        for(int i=0;i<1000;i++){\n            stone[0].push_back(data(i,0));\n            stone[n+1].push_back(data(i,0));\n        }\n        fill(dp[0][0],dp[0][0]+77*200*1001,INF);\n        for(int k=0;k<=(n+1)/2;k++){\n            for(int i=0;i<=n;i++){\n                for(int j=0;j<stone[i].size();j++){\n                    data At=stone[i][j];\n                    if(i==0)dp[k][i][At.x]=0;\n                    if(dp[k][i][At.x]==INF)continue;\n                    for(int l=0;l<stone[i+1].size();l++){\n                        data to=stone[i+1][l];\n                        int cost=abso(At,to)*(At.d+to.d);\n                        dp[k][i+1][to.x]=min(dp[k][i+1][to.x],dp[k][i][At.x]+cost);\n\n                    }\n\n                    if(i>=n-1)continue;\n\n                    for(int l=0;l<stone[i+2].size();l++){\n                        data to=stone[i+2][l];\n                        int cost=abso(At,to)*(At.d+to.d);\n                        dp[k+1][i+2][to.x]=min(dp[k+1][i+2][to.x],dp[k][i][At.x]+cost);\n                    }\n\n                }\n            }\n        }\n\n        int Min=INF;\n        for(int i=0;i<=m;i++){\n            for(int j=0;j<1000;j++)\n                Min=min(Min,dp[i][n+1][j]);\n        }\n        cout<<Min<<endl;\n        /*\n        cout<<endl<<endl;\n        int p=1;\n        for(int i=n+1;i>=0;i--){\n            cout<<i<<\":\";\n            for(int j=0;j<10;j++){\n                if(dp[p][i][j]==INF)cout<<\"i \";\n                else cout<<dp[p][i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        */\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)break;\n        vector<vector<vector<int> > > mdan(n,vector<vector<int> >(m+1));\n        vector<vector<pair<int,int> > > sube(n);\n        int ki,x,d;\n        for(int i=0;i<n;i++){\n            scanf(\"%d\",&ki);\n            for(int j=0;j<ki;j++){\n                scanf(\"%d%d\",&x,&d);\n                sube[i].push_back(make_pair(x,d));\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=m;j++){\n                mdan[i][j]=vector<int>(sube[i].size(),-1);\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<sube[i].size();j++){\n                if(i==0)mdan[i][0][j]=0;\n                else{\n                    for(int l=0;l<sube[i-1].size();l++){\n                        for(int k=0;k<=m;k++){\n                            if(mdan[i-1][k][l]!=-1){\n                                int newd=mdan[i-1][k][l]+(sube[i-1][l].second+sube[i][j].second)*abs(sube[i-1][l].first-sube[i][j].first);\n                                if(mdan[i][k][j]==-1||mdan[i][k][j]>newd)mdan[i][k][j]=newd;\n                            }\n                            if(k>0&&i>=2&&mdan[i-2][k-1][l]!=-1){\n                                int newd=mdan[i-2][k-1][l]+(sube[i-2][l].second+sube[i][j].second)*abs(sube[i-2][l].first-sube[i][j].first);\n                                if(mdan[i][k][j]==-1||mdan[i][k][j]>newd)mdan[i][k][j]=newd;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int mi=INT_MAX;\n        for(int l=0;l<sube[n-1].size();l++){\n            for(int k=0;k<=m;k++){\n                if(mdan[n-1][k][l]!=-1)mi=min(mi,mdan[n-1][k][l]);\n            }\n        }\n        printf(\"%d\\n\",mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <cstdlib>\n\nusing namespace std;\n\nint n,m;\n\n\nconst int INF = 999999999;\n\nvector< vector< pair<int,int> > > stones;\nint dp[76][151][11];\n\nint calcd(pair<int,int> a,pair<int,int> b){\n\t//printf(\"CALCD:(%d,%d) -> (%d,%d) : %d\\n\",a.first,a.second,b.first,b.second,(a.second + b.second) * abs(a.first - b.first));\n\treturn (a.second + b.second) * abs(a.first - b.first);\n}\n\nvoid setvalue(int* begin,int* end,int value){\n\tint* pt = begin;\n\twhile(pt != end){\n\t\t*pt = value; \n\t\tpt++;\n\t}\n}\n\nint main(){\n\tint self;\n\tint a,b;\n\tint s,ss;\n\tint x,y;\n\twhile(scanf(\"%d %d\",&n,&m) && (n || m)){\n\t\t//printf(\"%d,%d\\n\",n,m);\n\t\tstones.clear();\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&self);\n\t\t\t//printf(\"%d :\",i);\n\t\t\tvector< pair<int,int> > vv;\n\t\t\tfor(int j=0;j<self;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\t//printf(\"(%d,%d) \",a,b);\n\t\t\t\tvv.push_back(pair<int,int>(a,b));\n\t\t\t\t\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t\tstones.push_back(vv);\n\t\t}\n\t\t\n\t\tsetvalue(&dp[0][0][0],&dp[0][0][0] + 10 * 150 * 76,INF);\n\t\t\n\t\tfor(int k = m;k >= 0;k--){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(int i = 0;i < stones[j].size();i++){\n\t\t\t\t\t//printf(\"%d %d %d\\n\",k,i,j);\n\t\t\t\t\tif(j == 0){\n\t\t\t\t\t\tif(k == m){\n\t\t\t\t\t\t\tdp[k][i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(j > 0){\n\t\t\t\t\t\tself = INF;\n\t\t\t\t\t\tfor(int l = 0;l < stones[j - 1].size();l++){\n\t\t\t\t\t\t\t//printf(\"call (%d,%d) , (%d,%d)\\n\",i,j,j-1,l);\n\t\t\t\t\t\t\ts = calcd(stones[j][i],stones[j - 1][l]) + dp[k][l][j - 1];\n\t\t\t\t\t\t\tif(s < self){\n\t\t\t\t\t\t\t\tself = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[k][i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t\tif(j > 1 && k < m){\n\t\t\t\t\t\tself = INF;\n\t\t\t\t\t\tfor(int l = 0;l < stones[j - 2].size();l++){\n\t\t\t\t\t\t\t//printf(\"call (%d,%d) , (%d,%d)\\n\",i,j,j-2,l);\n\t\t\t\t\t\t\ts = calcd(stones[j][i],stones[j - 2][l]) + dp[k + 1][l][j - 2];\n\t\t\t\t\t\t\tif(s < self){\n\t\t\t\t\t\t\t\tself = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[k][i][j] > self){\n\t\t\t\t\t\t\tdp[k][i][j] = self;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\ts = stones[n - 1].size();\n\t\tfor(int i = 0;i <= m;i++){\n\t\t\tfor(int j = 0;j < s;j++){\n\t\t\t\tif(dp[i][j][n - 1] < ans){\n\t\t\t\t\tans = dp[i][j][n - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int k = m;k >= 0;k--){\n\t\t\tprintf(\"[k:%d]\\n\",k);\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(int i = 0;i < stones[j].size();i++){\n\t\t\t\t\tprintf(\"%d \",dp[k][i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint memo[80][150][10];\n\nint main(){\n  int n,m;\n  while(n=getInt(), m=getInt(), n+m){\n    vector<vector<pair<int,int> > > stone(n);\n    memset(memo, -1, sizeof(memo));\n    REP(i,n){\n      int num = getInt();\n      stone[i] = vector<pair<int,int> >(num);\n      REP(j,num){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    REP(i,stone[0].size()) memo[m][0][i] = 0;\n    if(m != 0) REP(i,stone[1].size()) memo[m-1][1][i] = 0;\n\n    REP(i,n-1){\n      FOR(it,stone[i]){\n        int j = it->f;\n        int s = it->s;\n        int idxj = it - stone[i].begin();\n        REP(k,m+1){\n          if(memo[k][i][idxj] != -1){\n            FOR(it2,stone[i+1]){\n              int jj = it2->f;\n              int ss = it2->s;\n              int idxjj = it2 - stone[i+1].begin();\n              int mm = memo[k][i][idxj];\n\n              if(memo[k][i+1][idxjj] == -1)\n                memo[k][i+1][idxjj] = mm + (s + ss)*abs(j - jj);\n              else\n                memo[k][i+1][idxjj] = min(memo[k][i+1][idxjj], mm + (s + ss)*abs(j - jj));\n            }\n\n            if(k != 0 && i != n-2){\n              FOR(it2,stone[i+2]){\n                int jj = it2->f;\n                int ss = it2->s;\n                int idxjj = it2 - stone[i+2].begin();\n                int mm = memo[k][i][idxj];\n\n                if(memo[k-1][i+2][idxjj] == -1)\n                  memo[k-1][i+2][idxjj] = mm + (s + ss)*abs(j - jj);\n                else\n                  memo[k-1][i+2][idxjj] = min(memo[k][i+2][idxjj], mm + (s + ss)*abs(j - jj));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    //puts(\"0:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[0][i][j]); puts(\"\"); }\n    //puts(\"1:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[1][i][j]); puts(\"\"); }\n\n    int ans = INT_MAX;\n    REP(j,10) REP(k,m+1){\n      if(memo[k][n-1][j] != -1)\n        ans = min(ans, memo[k][n-1][j]);\n      if(k != 0){\n        if(memo[k][n-2][j] != -1)\n          ans = min(ans, memo[k][n-2][j]);\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\nlong long int INF=1000000000;\nint st[152],stx[152][11],sts[152][11];\nlong long int dp[152][11][78];\n\nint main(void){\n\tint n,m;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(st,0,sizeof(st));\n\t\tmemset(stx,0,sizeof(stx));\n\t\tmemset(sts,0,sizeof(sts));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<152;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst[0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&st[i]);\n\t\t\tfor(int j=0;j<st[i];j++){\n\t\t\t\tscanf(\"%d%d\",&stx[i][j],&sts[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<st[0];i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tif(m>=1)for(int i=0;i<st[1];i++){\n\t\t\tdp[1][i][1]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tfor(int k=0;k<st[i];k++){\n\t\t\t\t\tfor(int l=0;l<st[i-1];l++){\n\t\t\t\t\t\tdp[i][k][j]=min(dp[i][k][j],dp[i-1][l][j]+(sts[i][k]+sts[i-1][l])*abs(stx[i][k]-stx[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=m && i>=2)for(int l=0;l<st[i-2];l++){\n\t\t\t\t\t\tdp[i][k][j+1]=min(dp[i][k][j+1],dp[i-2][l][j]+(sts[i][k]+sts[i-2][l])*abs(stx[i][k]-stx[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans=INF;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<st[n-1];k++){\n\t\t\t\tans=min(ans,dp[n-1][k][j]);\n\t\t\t}\n\t\t\tif(j!=m)for(int k=0;k<st[n-2];k++){\n\t\t\t\tans=min(ans,dp[n-2][k][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint n,m;\nint stone[155][11][2];\nint dp[155][11][76];\nint num[155];\nint cost(int a,int b,int c){\n\tif(a==n || (a==n-1 && c<m)){\n\t\treturn 0;\n\t}\n\tif(dp[a][b][c]!=-1) return dp[a][b][c];\n\tint mini=INF;\n\tfor(int i=1;i<=num[a+1];i++){\n\t\tmini=min(mini,(stone[a+1][i][1]+stone[a][b][1])*abs(stone[a][b][0]-stone[a+1][i][0])+cost(a+1,i,c));\n\t}\n\tif(c!=m){\n\tfor(int i=1;i<=num[a+2];i++){\n\t\tmini=min(mini,(stone[a+2][i][1]+stone[a][b][1])*abs(stone[a][b][0]-stone[a+2][i][0])+cost(a+2,i,1+c));\n\t}\n\t}\n\treturn dp[a][b][c]=mini;\n}\nint main(){\n\twhile(scanf(\"%d %d\",&n,&m) && m){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&num[i]);\n\t\t\tfor(int g=1;g<=num[i];g++){\n\t\t\t\tscanf(\"%d %d\",&stone[i][g][0],&stone[i][g][1]);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tint ans=INF;\n\t\tif(num[1]){\n\t\t\tfor(int i=1;i<=num[1];i++){\n\t\t\t\tans=min(ans,cost(1,i,0));\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=1;i<=num[2];i++){\n\t\t\t\tans=min(ans,cost(2,i,1));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        //vector<vector<vector<int> > > dp(3, vector<vector<int> >(10, vector<int>(M+1, 2000*1000*150)));\n        vector<vector<vector<int> > > dp(N, vector<vector<int> >(10, vector<int>(M+1, 2000*1000*150)));\n        for(int i = 0; i < stones[0].size(); ++i) {\n            dp[0][i][M] = 0;\n        }\n        if(M > 0) {\n            for(int i = 0; i < stones[1].size(); ++i) {\n                dp[1][i][M-1] = 0;\n            }\n        }\n        for(int i = 1; i < N; ++i) {\n            /*\n            int curr = i%3;\n            int prev = (i-1)%3;\n            int pp = (i-2)%3;\n            */\n            int curr = i;\n            int prev = i-1;\n            int pp = i-2;\n            if(i > 1) {\n                for(int k = 0; k < stones[i].size(); ++k) {\n                    fill(dp[curr][k].begin(), dp[curr][k].end(), 2000*1000*150);\n                }\n            }\n            if(i > 1) {\n                for(int j = 0; j < stones[i-2].size(); ++j) {\n                    //pp to prev\n                    int sx = stones[i-2][j].first;\n                    int sc = stones[i-2][j].second;\n                    for(int k = 0; k < stones[i-1].size(); ++k) {\n                        int skx = stones[i-1][k].first;\n                        int skc = stones[i-1][k].second;\n                        int cost = (sc+skc) * abs(sx-skx);\n                        for(int m = 0; m <= M; ++m) {\n                            dp[prev][k][m] = min(dp[prev][k][m], dp[pp][j][m]+cost);\n                        }\n                    }\n\n                    //pp to curr\n                    for(int k = 0; k < stones[i].size(); ++k) {\n                        int skx = stones[i][k].first;\n                        int skc = stones[i][k].second;\n                        int cost = (sc+skc) * abs(sx-skx);\n                        for(int m = 0; m < M; ++m) {\n                            dp[curr][k][m] = min(dp[curr][k][m], dp[pp][j][m+1]+cost);\n                        }\n                    }\n                }\n            }\n            for(int j = 0; j < stones[i-1].size(); ++j) {\n                //prev to curr\n                int sx = stones[i-1][j].first;\n                int sc = stones[i-1][j].second;\n                for(int k = 0; k < stones[i].size(); ++k) {\n                    int skx = stones[i][k].first;\n                    int skc = stones[i][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m <= M; ++m) {\n                        dp[curr][k][m] = min(dp[curr][k][m], dp[prev][j][m]+cost);\n                    }\n                }\n            }\n        }\n        int ans = INT_MAX;\n        /*\n        int curr = (N-1) % 3;\n        int prev = (N-2) % 3;\n        */\n        int curr = N-1;\n        int prev = N-2;\n\n        for(int m = 0; m <= M; ++m) {\n            for(int k = 0; k < stones[N-1].size(); ++k) {\n                ans = min(ans, dp[curr][k][m]);\n            }\n            if(m > 0) {\n                for(int k = 0; k < stones[N-2].size(); ++k) {\n                    ans = min(ans, dp[prev][k][m]);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1005;\nll dp[6][MAX_X][80];\n\nint main()\n{\n\t//freopen(\"D:\\\\Users\\\\johnsmith\\\\documents\\\\visual studio 2010\\\\Projects\\\\AOJ2\\\\AOJ2\\\\data\\\\2008-ho-t4-in10\", \"r\", stdin);\n\t//clock_t start = clock();\n\t//ifstream ifs(\"D:\\\\Users\\\\johnsmith\\\\documents\\\\visual studio 2010\\\\Projects\\\\AOJ2\\\\AOJ2\\\\data\\\\2008-ho-t4-in10\");\n\tint n, m;\n\twhile(scanf(\"%d %d\", &n, &m) != EOF && n)\n\t{\n\t\trep(x,MAX_X) rep(y,6) rep(d,m+1) dp[y][x][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\trep(i,MAX_X) rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tscanf(\"%d\", &s);\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\t//ifs >> x >> d;\n\t\t\t\tscanf(\"%d %d\", &x, &d);\n\t\t\t\tr[x][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[0][x][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[1][x][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++)\n\t\t{\n\t\tif(1 < y) memcpy(dp[y%5], dp[5], sizeof(dp[y%5]));\n\t\tfor(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\t\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ツ津環湘ュツジツδδδ督プ\n\t\t\t\trep(nx, MAX_X) rep(d, m+1)\n\t\t\t\t\tif(dp[(y-1)%5][nx][d] != INF)\n\t\t\t\t\t\tchmin(dp[y%5][x][d], dp[(y-1)%5][nx][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// ツ暗ェツ段ツづづ篠つオ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[(y-2)%5][nx][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[y%5][x][d-1], dp[(y-2)%5][nx][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\t\t}\n\t\tll res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[(n-1)%5][x][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[(n-2)%5][x][d]);\n\t\tcout << res << endl;\n\t}\n\t//cout << clock() - start << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[n+2]; \n    for(i=0;i<n+2;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\tfor(int a=0;a<=m;a++){\n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M && N != 0) {\n    vector<vector<pair<int,int> > > g(N);\n    for (int i = 0; i < N; i++) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; j++) {\n        int c, d;\n        cin >> c >> d;\n        g[i].push_back(make_pair(c, d));\n      }\n    }\n\n    vector<vector<vector<int> > > dp(N);\n    for (int i = 0; i < N; i++) {\n      dp[i].resize(g[i].size(), vector<int>(M+1, numeric_limits<int>::max()/2));\n    }\n    for (int i = 0; i < g[0].size(); i++) {\n      dp[0][i][0] = 0;\n    }\n    for (int i = 0; i < g[1].size(); i++) {\n      dp[1][i][1] = 0;\n    }\n\n    int ans = numeric_limits<int>::max();\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < g[i].size(); j++) {\n        for (int m = 0; m <= M; m++) {\n          if (i+1 == N) {\n            ans = min(ans, dp[i][j][m]);\n          } else {\n            for (int k = 0; k < g[i+1].size(); k++) {\n              dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + (g[i][j].second + g[i+1][k].second)*abs(g[i][j].first - g[i+1][k].first));\n            }\n\n            if (i < N-1 && m < M) {\n              if (i+2 == N) {\n                ans = min(ans, dp[i][j][m]);\n              } else {\n                for (int k = 0; k < g[i+2].size(); k++) {\n                  dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + (g[i][j].second + g[i+2][k].second)*abs(g[i][j].first - g[i+2][k].first));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n#define REP(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\n\nlong dist(pair<int, int> s1, pair<int, int> s2) {\n  return abs(s1.first - s2.first) * (s1.second + s2.second);\n}\n\nint main(void) {\n  while(1) {\n    long N, M;\n    vector< pair<long, long> > S[150];\n    vector<long> dp[150][150];\n\n    cin >> N >> M;\n    if(N == 0 && M == 0) break;\n    REP(i, 0, N) {\n      int k;\n      cin >> k;\n      REP(j, 0, k) {\n        long x, d;\n        cin >> x >> d;\n        S[i].push_back(pair<long, long>(x, d));\n      }\n    }\n\n    long ans = INT_MAX;\n    REP(i, 0, N) {\n      REP(j, 0, M + 1) {\n        REP(k, 0, S[i].size()) {\n          long m = INT_MAX;\n          if(i >= 1) {\n            REP(l, 0, S[i - 1].size()) {\n              m = min(m, dp[i - 1][j][l] + dist(S[i][k], S[i - 1][l]));\n            }\n          }\n          if(i >= 2 && j >= 1) {\n            REP(l, 0, S[i - 2].size()) {\n              m = min(m, dp[i - 2][j - 1][l] + dist(S[i][k], S[i - 2][l]));\n            }\n          }\n          if(i == 0 && j == 0) m = 0;\n          if(i == 0 && j >= 1) m = INT_MAX;\n          if(i == 1 && j == 1) m = 0;\n          dp[i][j].push_back(m);\n\n          if(((i == N - 2 && j < M) || (i == N - 1))) {\n            ans = min(ans, m);\n          }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, f1, f2, r[150];\n\nvector<pair<int, int> > R[150]; long long D[150][10][76];\n\nint distance(int x1, int c1, int x2, int c2)\n{\n\tint sums = R[x1][c1].second + R[x2][c2].second;\n\tint dist = R[x1][c1].first - R[x2][c2].first;\n\n\treturn sums * abs(dist);\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &m);\n\n\t\tif (n == 0 && m == 0) break;\n\n\t\tfor (int i = 0; i < n; i++) R[i].clear();\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r[i]);\n\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &f1);\n\t\t\t\tscanf(\"%d\", &f2);\n\n\t\t\t\tR[i].push_back(make_pair(f1, f2));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t{\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 999999999999999999LL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int> >, greater<tuple<long long, int, int, int> > > que;\n\n\t\tfor (int i = 0; i < r[0]; i++)\n\t\t{\n\t\t\tque.push(make_tuple(0LL, 0, 0, i));\n\t\t}\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<long long, int, int, int> state = que.top(); que.pop();\n\n\t\t\tlong long dist = get<0>(state);\n\n\t\t\tint jump = get<1>(state);\n\t\t\tint high = get<2>(state);\n\t\t\tint node = get<3>(state);\n\n\t\t\tif (high + 1 != n)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < r[high + 1]; i++)\n\t\t\t\t{\n\t\t\t\t\tlong long dist2 = dist + distance(high, node, high + 1, i);\n\n\t\t\t\t\tif (D[high + 1][i][jump] > dist2)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[high + 1][i][jump] = dist2;\n\n\t\t\t\t\t\tque.push(make_tuple(dist2, jump, high + 1, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (high + 2 != n && jump != m)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < r[high + 2]; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long dist2 = dist + distance(high, node, high + 2, i);\n\n\t\t\t\t\t\tif (D[high + 2][i][jump + 1] > dist2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[high + 2][i][jump + 1] = dist2;\n\n\t\t\t\t\t\t\tque.push(make_tuple(dist2, jump + 1, high + 2, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong long ret = 999999999999999999LL;\n\n\t\tfor (int i = 0; i < r[n - 1]; i++)\n\t\t{\n\t\t\tret = min(ret, D[n - 1][i][m]);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 100000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nint dp[152][1001][76];\nint s[152][1001];\nint abs(int x){\n\tif(x<0) return -1*x;\n\telse return x;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tfor(int j=1; j<1001; ++j){\n\t\t\t\ts[i][j]=INF;\n\t\t\t\tfor(int k=0; k<=m; ++k){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0; j<k; ++j){\n\t\t\t\tint t1,t2;\n\t\t\t\tcin >> t1 >> t2;\n\t\t\t\ts[i][t1]=t2;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<1001; ++i){\n\t\t\tif(s[1][i]!=INF) dp[1][i][0]=0;\n\t\t}\n\t\tfor(int i=1; i<1001; ++i){\n\t\t\tif(s[2][i]!=INF){\n\t\t\t\tfor(int j=1; j<1001; ++j){\n\t\t\t\t\tif(s[1][j]!=INF){\n\t\t\t\t\t\tdp[2][i][0]=min(dp[2][i][0],(s[2][i]+s[1][j])*abs(i-j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[2][i][1]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=3; i<=n; ++i){\n\t\t\tfor(int j=1; j<1001; ++j){\n\t\t\t\tif(s[i][j]!=INF){\n\t\t\t\t\tfor(int k=0; k<=m; ++k){\n\t\t\t\t\t\tfor(int l=1; l<1001; ++l){\n\t\t\t\t\t\t\tif(s[i-1][l]!=INF&&dp[i-1][l][k]!=INF){\n\t\t\t\t\t\t\t\tdp[i][j][k]=min(dp[i][j][k],(s[i-1][l]+s[i][j])*abs(j-l)+dp[i-1][l][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(s[i-2][l]!=INF&&k!=0&&dp[i-2][l][k-1]!=INF){\n\t\t\t\t\t\t\t\tdp[i][j][k]=min(dp[i][j][k],(s[i-2][l]+s[i][j])*abs(j-l)+dp[i-2][l][k-1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=1; i<1001; ++i){\n\t\t\tfor(int j=0; j<=m; ++j){\n\t\t\t\tans=min(ans,dp[n][i][m]);\n\t\t\t\tif(j<m) ans=min(ans,dp[n-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    int N,M,K,k1,k2,MIN,ANS;\n    while(scanf(\"%d%d\",&N,&M),N + M)\n    {\n        int field[150][4] = {0},dp[150][4][100] = {0};\n        ANS = 10000000;\n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\",&K);\n            for(int j = 0; j < K; j++)\n            {\n                scanf(\"%d%d\",&k1,&k2);\n                field[i][k1 - 1] = k2;\n            }\n        }\n        /*for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 1; i < N; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    if(field[i][k] != 0)\n                    {\n                        dp[i][k][j] = 10000000;\n                        if(j == 0)\n                        {\n                            for(int l = 0; l < 4; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[i][k][0] = min(dp[i][k][0],dp[i - 1][l][0] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                        else if(i > 1)\n                        {\n                            for(int l = 0; l < 4; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 1][l][j] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                                if(field[i - 2][l] != 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 2][l][j - 1] + (field[i - 2][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /*for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    printf(\"%2d\",dp[i][k][j]);\n                }\n                printf(\" / \");\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 0; i < M + 1; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                if(dp[N - 1][j][i] != 0)\n                {\n                    ANS = min(ANS,dp[N - 1][j][i]);\n                }\n            }\n        }\n        printf(\"%d\\n\",ANS);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define UNDEF 2000000000\n\nint n,m,k[151],x[151][10],d[151][10],dp[151][10][76];\n\nint getdp(int col,int row,int rem)\n{\n\tif(col < 151 && row < 10 && rem < 76 && col >= 0 && row >= 0 && rem >= 0)\n\t\treturn dp[col][row][rem];\n\telse\n\t\treturn UNDEF;\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0)\n\t\t\texit(0);\n\t\tfor(int i = 0;i < 151;i++)\n\t\t{\n\t\t\tfor(int j = 0;j < 10;j++)\n\t\t\t{\n\t\t\t\tx[i][j] = UNDEF;\n\t\t\t\td[i][j] = UNDEF;\n\t\t\t\tfor(int l = 0;l < 76;l++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][l] = UNDEF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk[i] = UNDEF;\n\t\t}\n\t\tfor(int i = 0;i < n;i++)\n\t\t{\n\t\t\tcin >> k[i];\n\t\t\tfor(int j = 0;j < k[i];j++)\n\t\t\t{\n\t\t\t\tcin >> x[i][j] >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < k[0];i++)\n\t\t{\n\t\t\tdp[0][i][m] = 0;\n\t\t}\n\t\tif(m > 0 && n > 1)\n\t\t{\n\t\t\tfor(int i = 0;i < k[1];i++)\n\t\t\t{\n\t\t\t\tdp[1][i][m-1] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int col = 1;col < n;col++)\n\t\t{\n\t\t\tfor(int row = 0;row < k[col];row++)\n\t\t\t{\n\t\t\t\tfor(int rem = 0;rem <= m;rem++)\n\t\t\t\t{\n\t\t\t\t\tfor(int t = 0;t < k[col-1];t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(getdp(col-1,t,rem) != UNDEF)\n\t\t\t\t\t\t\tdp[col][row][rem] = min(dp[col][row][rem],getdp(col-1,t,rem)+((d[col][row]+d[col-1][t])*abs(x[col][row]-x[col-1][t])));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int t = 0;t < k[col-2];t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(getdp(col-2,t,rem+1) != UNDEF)\n\t\t\t\t\t\t\tdp[col][row][rem] = min(dp[col][row][rem],getdp(col-2,t,rem+1)+((d[col][row]+d[col-2][t])*abs(x[col][row]-x[col-2][t])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result = UNDEF;\n\t\tfor(int row = 0;row < k[n-1];row++)\n\t\t{\n\t\t\tfor(int rem = 0;rem <= m;rem++)\n\t\t\t{\n\t\t\t\tresult = min(result,dp[n-1][row][rem]);\n\t\t\t}\n\t\t}\n\t\tfor(int row = 0;row < k[n-2];row++)\n\t\t{\n\t\t\tfor(int rem = 1;rem <= m;rem++)\n\t\t\t{\n\t\t\t\tresult = min(result,dp[n-2][row][rem]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) REP(i,0,n)\n#define f first\n#define s second\n#define mpi(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\n#define pi pair<pair<int,int>,pair<int,int> >\nusing namespace std;\nint in(){int x; scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      vector<vector<int> > pos(150);\n      vector<vector<int> > cos(150);\n      int flag[151][10][75] = {0};\n      priority_queue<pi,vector<pi >,greater<pi > >Q;//cost,y,x,slip\n      rep(i,n){\n         int x = in();\n         rep(j,x){\n            pos[i].push_back(in());\n            cos[i].push_back(in());\n         }\n      }\n\n      rep(i,pos[0].size()){\n         Q.push(mpi(0,0,i,0));\n      }\n      rep(i,pos[1].size()){\n         if(m != 0){\n            Q.push(mpi(0,1,i,1));\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         pi p = Q.top(); Q.pop();\n         if(p.f.s == n-1){ans = p.f.f; break;}\n         if(p.f.s == n-2 && m > p.s.s){ans = p.f.f; break;}\n\n         if(flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] == 1) continue;\n         flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] = 1;\n\n         rep(i,pos[p.f.s+1].size()){\n            Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+1][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+1][i]),p.f.s+1,i,p.s.s));\n         }\n\n         rep(i,pos[p.f.s+2].size()){\n            if(p.s.s < m) Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+2][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+2][i]),p.f.s+2,i,p.s.s+1));\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct stone {\n\tint x;\n\tint y;\n\tint slip;\n};\nstruct Edge {\n\tint to;\n\tint time;\n};\nstruct aa {\n\tint now;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tvector<stone>stos;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint k; cin >> k;\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint x, s; cin >> x >> s;\n\t\t\t\tx--;\n\t\t\t\tstos.push_back(stone{ x,i+1,s });\n\t\t\t}\n\t\t}\n\t\tvector<vector<Edge>>es(stos.size()*(M+1) + 2);\n\t\tfor (int i = 0; i < stos.size(); ++i) {\n\t\t\tfor (int j = 0; j <stos.size(); ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tfor (int m = 0; m <= M; ++m) {\n\t\t\t\t\tstone si = stos[i];\n\t\t\t\t\tint iid = i*(M + 1) + m;\n\t\t\t\t\tstone sj = stos[j];\n\t\t\t\t\tint jid = j*(M + 1) + m;\n\t\t\t\t\tif (si.y + 1 == sj.y) {\n\t\t\t\t\t\tes[iid].push_back(Edge{ jid,abs(si.x - sj.x)*(si.slip + sj.slip) });\n\t\t\t\t\t}\n\t\t\t\t\telse if (si.y + 2 == sj.y&&m!=M) {\n\t\t\t\t\t\tes[iid].push_back(Edge{ int(jid+1),abs(si.x - sj.x)*(si.slip + sj.slip) });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst int start = stos.size()*(M + 1);\n\t\tconst int goal = start + 1;\n\t\tfor (int i = 0; i < stos.size(); ++i) {\n\t\t\tstone s(stos[i]);\n\t\t\tfor (int m = 0; m < M; ++m) {\n\t\t\t\tconst int nid = i*(M+1)+ m;\n\t\t\t\tes[nid].push_back(Edge{ nid+ 1,0 });\n\t\t\t\tif (s.y == 2) {\n\t\t\t\t\tes[start].push_back(Edge{ int(nid+ 1), 0});\n\t\t\t\t}\n\t\t\t\tif (s.y == N - 1) {\n\t\t\t\t\tes[nid].push_back(Edge{ goal,0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = 0; m <= M; ++m) {\n\t\t\t\tconst int nid = i*(M + 1) + m;\n\t\t\t\tif (s.y == 1) {\n\t\t\t\t\tes[start].push_back(Edge{ nid, 0 });\n\t\t\t\t}\n\t\t\t\tif (s.y == N) {\n\t\t\t\t\tes[nid].push_back(Edge{ goal,0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tpriority_queue < aa, vector<aa>, Compare > que;\n\t\tque.push(aa{ start,0 });\n\t\tvector<long long int>memo(es.size(), 1e18);\n\t\tmemo[start] = 0;\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (atop.now == goal) {\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : es[atop.now]) {\n\t\t\t\tconst int nexttime = atop.time + e.time;\n\t\t\t\tif (memo[e.to] > nexttime) {\n\t\t\t\t\tmemo[e.to] = nexttime;\n\t\t\t\t\tque.push(aa{ e.to,nexttime });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int INF = (1<<29);\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n || m)){\n    int dp[150][10][80], a[150][10], x[150][10];\n    for(int i=0;i<150;i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<80;k++) dp[i][j][k] = INF;\n\ta[i][j] = INF;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int k;\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint b,c;\n\tcin >> b >> c;\n\tx[i][j] = b;\n\ta[i][j] = c;\n      }\n    }\n    for(int i=0;i<10;i++) dp[0][i][0] = 0;\n\n    for(int i=0;i<n-1;i++){\n      for(int l=0;l<=m;l++){\n\tfor(int j=0;j<10;j++){\n\t  if(a[i][j] == INF) continue;\n\t  for(int k=0;k<10;k++){\n\t    if(a[i+1][k] == INF) continue;\n\t    dp[i+1][k][l] = min(dp[i+1][k][l],dp[i][j][l] + (a[i][j] + a[i+1][k]) * (abs(x[i+1][k]-x[i][j])));\n\t  }\n\t  if(i < n - 2 && l != m){\n\t    for(int k=0;k<10;k++){\n\t      if(a[i+2][k] == INF) continue;\n\t      dp[i+2][k][l+1] = min(dp[i+2][k][l+1],dp[i][j][l] + (a[i][j] + a[i+2][k]) * (abs(x[i+2][k]-x[i][j])));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-1][k][j]);\n    for(int j=0;j<m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-2][k][j]);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint numstone[151];\npair<int,int> stones[151][11];\nint memo[151][151][11]; //memo[ツ甘敖つゥツづァツづ個仰猟猟」][ツ氾イツづ篠つオツ氾イツづ堕づーツつオツつスツ嘉アツ青脳[ツ債。ツづ個暗環置]\nint n,m;\n\nint solve(int i,int j,int k) {\n  if(memo[i][j][k] != -1) return memo[i][j][k];\n  if(i >= n-1) return 0;\n\n  int l,ret = 1<<29;\n  if(j < m) {\n    rep(l,numstone[i+2]) {\n      int cc = stones[i][k].second+stones[i+2][l].second;\n      ret = min(ret, solve(i+2, j+1, l)\n\t\t+ cc*abs(stones[i][k].first-stones[i+2][l].first));\n    }\n  }\n\n  rep(l, numstone[i+1]) {\n    int cc = stones[i][k].second+stones[i+1][l].second;\n    ret = min(ret, solve(i+1, j, l)\n\t      + cc*abs(stones[i][k].first-stones[i+1][l].first));\n  }\n  //printf(\"row: %d double: %d nowpos: %d ret: %d\\n\", i,j,k,ret);\n  return memo[i][j][k] = ret;\n}\n\nint main() {\n  int k,i,j;\n  while(scanf(\"%d%d\", &n, &m), n|m) {\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,151) rep(j,151) rep(k,11) memo[i][j][k] = -1;\n    rep(i,n) {\n      scanf(\"%d\", &k);\n      numstone[i] = k;\n      rep(j,k) {\n\tpair<int,int> p;\n\tscanf(\"%d%d\", &(p.first), &(p.second));\n\tstones[i][j] = p;\n      }\n    }\n\n    int ans = 1<<29;\n    rep(i, numstone[0]) {\n      ans = min(ans, solve(0,0,i));\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[256][16][128];\nvector<P> stones[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      stones[i].clear();\n      int k;\n      cin >> k;\n      REP(j, k) {\n\tint x, d;\n\tcin >> x >> d;\n\tstones[i].push_back(P(x, d));\n      }\n    }\n\n    REP(i, N) REP(j, stones[i].size()) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, stones[0].size()) dp[0][j][0] = 0;\n    REP(j, stones[1].size()) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, stones[i].size()) {\n\tint x_now = stones[i][j].first, d_now = stones[i][j].second;\n\tREP(k, stones[i+1].size()) {\n\t  int x_next = stones[i+1][k].first, d_next = stones[i+1][k].second;\n\t  int safe = (d_now + d_next) * abs(x_now - x_next);\n\t  REP(m, M+1) {\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + safe);\n\t  }\n\t}\n\tif (i < N-2) {\n\t  REP(k, stones[i+2].size()) {\n\t    int x_next = stones[i+2][k].first, d_next = stones[i+2][k].second;\n\t    int safe = (d_now + d_next) * abs(x_now - x_next);\n\t    REP(m, M) {\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, stones[N-1].size()) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, stones[N-2].size()) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m, n;) {\n\t\tvector<vector<int> > pos(n), danger(n);\n\t\tvector<vector<vector<int> > > dp(n, vector<vector<int> >(m + 1));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint num;\n\t\t\tcin >> num;\n\n\t\t\tfor(int j = 0; j < m + 1; ++j)\n\t\t\t\tdp[i][j].resize(num, INT_MAX);\n\n\t\t\tfor(int j = 0; j < num; ++j) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tpos[i].push_back(x);\n\t\t\t\tdanger[i].push_back(d);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < m + 1; ++i)\n\t\t\tfor(int j = 0; j < dp[0][i].size(); ++j)\n\t\t\t\tdp[0][i][j] = 0;\n\n\t\tint ans = INT_MAX;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < m + 1; ++j) {\n\t\t\t\tfor(int k = 0; k < dp[i][j].size(); ++k) {\n\t\t\t\t\tif(dp[i][j][k] == INT_MAX)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(j) {\n\t\t\t\t\t\tif(i + 2 >= n)\n\t\t\t\t\t\t\tchmin(ans, dp[i][j][k]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor(int l = 0; l < dp[i + 2][j - 1].size(); ++l)\n\t\t\t\t\t\t\t\tchmin(dp[i + 2][j - 1][l], dp[i][j][k] + (danger[i][k] + danger[i + 2][l]) * abs(pos[i][k] - pos[i + 2][l]));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(i + 1 >= n)\n\t\t\t\t\t\tchmin(ans, dp[i][j][k]);\n\t\t\t\t\telse\n\t\t\t\t\t\tfor(int l = 0; l < dp[i + 1][j].size(); ++l)\n\t\t\t\t\t\t\tchmin(dp[i + 1][j][l], dp[i][j][k] + (danger[i][k] + danger[i + 1][l]) * abs(pos[i][k] - pos[i + 1][l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nint N, M;\nstd::vector<P> S[153];\nint dp[153][1000][80];\n\nint value(const P& lp, const P& rp){\n    return (lp.second+rp.second) * std::abs(lp.first-rp.first);\n}\n\nint rec(int y, int x, int t){\n    if(y > N){return 0;}\n    if(dp[y][x][t] != -1){return dp[y][x][t];}\n\n    int res = INF;\n    REP(i, S[y+1].size()){\n        res = std::min(res, rec(y+1, i, t) + value(S[y][x], S[y+1][i]));\n    }\n\n    if(t < M){\n        REP(i, S[y+2].size()){\n            res = std::min(res, rec(y+2, i, t+1) + value(S[y][x], S[y+2][i]));\n        }\n    }\n\n    return dp[y][x][t] = res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, N+3){\n            S[i].clear();\n        }\n\n        REP(i, N){\n            int k;\n            std::cin >> k;\n\n            REP(j, k){\n                int x, d;\n                std::cin >> x >> d;\n                x--;\n            \n                S[i+1].push_back(mp(x, d));\n            }\n        }\n\n        REP(i, 1000){\n            S[0].push_back(mp(i, 0));\n            S[N+1].push_back(mp(i, 0));\n            S[N+2].push_back(mp(i, 0));\n        }\n    \n        REP(i, N+3){\n            REP(j, 1000){\n                REP(k, M+1){\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n\n        int res = INF;\n        REP(i, 1000){\n            res = std::min(res, rec(0, i, 0));\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdlib>\nusing namespace std;int main(){typedef pair<int,int> pii;vector<pii>::iterator it;int n, m, k, x, d, h, i, j;for(; cin >> n >> m, n; ){vector<pii> st[151];for( i = 1; i <= n; i++ ){for( cin >> k; k--; ){cin >> x >> d;st[i].push_back( pii( x, d ) );}}int dp[158][151][10];fill( **dp, *dp[158], 1e9 );for( i = st[1].size(); i--; ){dp[m][1][i] = 0;}for( i = st[2].size(); i--; ){dp[m-1][2][i] = 0;}for( h = 2; h <= n; h++ ){for( i = m; i >= 0; i-- ){for( j = st[h].size(); j--; ){for( k = st[h-1].size(); k--; ){x = dp[i][h-1][k]  + ( st[h][j].second + st[h-1][k].second )  * abs( st[h][j].first - st[h-1][k].first );dp[i][h][j] = min( dp[i][h][j], x );}for( k = st[h-2].size(); k--; ){x = dp[i+1][h-2][k]  + ( st[h][j].second + st[h-2][k].second )  * abs( st[h][j].first - st[h-2][k].first );dp[i][h][j] = min( dp[i][h][j], x );}}}}x = 1e9;for( i = m; i >= 0; i-- ){for( j = st[n].size(); j--; ){x = min( x, dp[i][n][j] );}}for( i = m; i > 0; i-- ){for( j = st[n-1].size(); j--; ){x = min( x, dp[i][n-1][j] );}}cout << x << endl;}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define LATTE 1000000000\n\nstruct data{\n    int x,d;\n    data(){}\n    data(int _x,int _d){\n        x=_x; d=_d;\n    }\n};\n\nint abso(int n){\n    if(n<0) return n*-1;\n    return n;\n}\n\nconst int dir[2] = {0,1};\nint dp[152][1001][76];\n\nint main(){\n    int N,M,K;\n    data in;\n    while(cin>>N>>M,N||M){\n        vector<data> stone[152];\n        stone[0].push_back(data(0,0));\n        stone[N+1].push_back(data(0,0));\n        for(int i=1;i<=N;i++){\n            cin>>K;\n            for(int j=0;j<K;j++){\n                cin>>in.x>>in.d;\n                stone[i].push_back(in);\n            }\n        }\n        for(int i=0;i<=N+1;i++)for(int j=0;j<=1000;j++)for(int k=0;k<=M;k++)\n            dp[i][j][k]=LATTE;\n        dp[0][0][0]=0;\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<stone[i].size();j++){\n                for(int k=0;k<=M;k++){\n                    //printf(\"%d \",dp[i][j][k]);\n                    for(int kind=0;kind<2;kind++){\n                        if(k+dir[kind]>M || i+dir[kind]+1>N+1) continue;\n                        for(int l=0;l<stone[i+dir[kind]+1].size();l++){\n                            int latte =\n                                dp[i][stone[i][j].x][k]+\n                                (stone[i][j].d+stone[i+dir[kind]+1][l].d)*\n                                abso(stone[i][j].x-stone[i+dir[kind]+1][l].x);\n                            //printf(\"%d\\n\",latte);\n                            if(i==0 || i+dir[kind]+1==N+1) latte=dp[i][stone[i][j].x][k];\n                            dp[i+dir[kind]+1][stone[i+dir[kind]+1][l].x][k+dir[kind]] =\n                                min(dp[i+dir[kind]+1][stone[i+dir[kind]+1][l].x][k+dir[kind]],latte);\n                        }\n                    }\n                }//puts(\"\");\n            }//puts(\"\");\n        }\n        int ans=LATTE;\n        for(int i=0;i<=M;i++){\n            ans = min(ans,dp[N+1][stone[N+1][0].x][i]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\n#define int ll\nint dp [1500] [150];\nint n, m, s;\nvector<vector<int>> mp;\nvector<pii> st;\nint func(int pos, int stnum, int spc) {\n\tif (spc == m+1)\n\t\treturn -1;\n\tif (stnum == s)\n\t\treturn 0;\n\tif (dp[stnum][spc] != -1)\n\t\treturn dp[stnum][spc];\n\tint res = INT_MAX;\n\tint w = st[stnum].first;\n\tint sb = st[stnum].second;\n\tREP(i, mp[pos+1].size()) {\n\t\tint cand = func(pos + 1, mp[pos + 1][i], spc);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0 && mp[pos+1][i] != s) {\n\t\t\tcand += (sb + st[mp[pos + 1][i]].second)*abs(w-st[mp[pos + 1][i]].first);\n\t\t}\n\t\tres = min(res, cand);\n\t}\n\tREP(i, mp[pos + 2].size()) {\n\t\tint cand = func(pos + 2, mp[pos + 2][i], spc+1);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0 && mp[pos + 2][i] != s) {\n\t\t\tcand += (sb + st[mp[pos + 2][i]].second)*abs(w - st[mp[pos + 2][i]].first);\n\t\t}\n\t\tres = min(res,cand);\n\t}\n\tdp[stnum][spc] = res;\n\tif (res == INT_MAX)\n\t\tres = -1;\n\treturn res;\n}\n\nsigned main() {\n\twhile (scanf(\"%lld %lld\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tFill(dp, -1);\n\t\tmp.clear();\n\t\tmp.resize(n+2);\n\t\tst.clear();\n\t\ts = 0;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tscanf(\"%lld\", &c);\n\t\t\tREP(j, c) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%lld %lld\", &a, &b);\n\t\t\t\tmp[i].push_back(s);\n\t\t\t\tst.push_back({ a,b });\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tmp[n].push_back(s);\n\t\tst.push_back({ -1,-1 });\n\t\tst.push_back({ -1,-1 });\n\t\tprintf(\"%lld\\n\", func(-1, s+1, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//滑りやすさ>=0なら大丈夫.3Dにすると、メモリがたくさんいるので、2つのナップザックを使いまわす。\n#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\n\nint N,M;\nint pos[150][10];\t\t//石のある場所(x座標)\nint list[150][10];\t\t//石の滑りやすさ\nint minest[2][150][10];\t//危険度ナップザック(探索用)\n\nvoid ainst(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid acopy(int *a,int *b,int index){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = b[i];\n\t}\n}\nint amin(int *a,int index){\n\tint min = a[0];\n\tfor(int i = 1;i < index;i++){\n\t\tif(min > a[i])\n\t\t\tmin = a[i];\n\t}\n\treturn min;\n}\nint nap(int n,int mode){\t//mode:0のときは一行飛ばし可能、1のときは不可能\n\tint i,j,l;\n\tint min = 2000000000;\n\tfor(i = 0;i < n-1;i++){\n\t\tfor(j = 0;j < 10;j++){\n\t\t\tif(pos[i][j] == -1)\n\t\t\t\tbreak;\n\t\t\tif(i+2 >= n && mode == 0){\n\t\t\t\tif(min > minest[0][i][j])\n\t\t\t\t\tmin = minest[0][i][j];\n\t\t\t}\n\t\t\tfor(l = 0;l < 10;l++){\n\t\t\t\tswitch(mode){\n\t\t\t\tcase 0:\n\t\t\t\t\tif(i+2 < n && pos[i+2][l] >= 0){\n\t\t\t\t\t\tif(minest[1][i+2][l] == -1 || \n\t\t\t\t\t\t\tminest[1][i+2][l] > minest[0][i][j]+\n\t\t\t\t\t\t\t(list[i][j]+list[i+2][l])*\n\t\t\t\t\t\t\tabs(pos[i][j]-pos[i+2][l])){\n\t\t\t\t\t\t\tminest[1][i+2][l] = minest[0][i][j]\n\t\t\t\t\t\t\t+(list[i][j]+list[i+2][l])\n\t\t\t\t\t\t\t\t*abs(pos[i][j]-pos[i+2][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase 1:\n\t\t\t\t\tif(pos[i+1][l] >= 0){\n\t\t\t\t\t\tif(minest[0][i+1][l] == -1\n\t\t\t\t\t\t\t|| minest[0][i+1][l] > \n\t\t\t\t\t\t\tminest[0][i][j]\n\t\t\t\t\t\t+(list[i][j]+list[i+1][l])\n\t\t\t\t\t\t\t*abs(pos[i][j]-pos[i+1][l])){\n\t\t\t\t\t\t\tminest[0][i+1][l] = \n\t\t\t\t\t\t\t\tminest[0][i][j]+\n\t\t\t\t\t\t\t\t(list[i][j]+list[i+1][l])\n\t\t\t\t\t\t\t\t*abs(pos[i][j]-pos[i+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0;i < 10;i++){\n\t\tif(minest[0][n-1][i] != -1 && min > minest[0][n-1][i])\n\t\t\tmin = minest[0][n-1][i];\n\t}\n\treturn min;\n}\nint main(){\n\tint i,j,k;\n\tint mcor,now,saisyo[1000];\n\tint saicor = 0;\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0)\n\t\t\tbreak;\n\t\tsaisyo[saicor] = 2000000000;\n\t\tfor(i = 0;i < N;i++){\n\t\t\tainst(pos[i],10,-1);\n\t\t\tainst(list[i],10,-1);\n\t\t\tainst(minest[0][i],10,-1);\n\t\t\tainst(minest[1][i],10,-1);\n\t\t\tcin >> k;\n\t\t\tfor(j = 0;j < k;j++){\n\t\t\t\tcin >> pos[i][j] >> list[i][j];\n\t\t\t}\n\t\t}\n\t\tainst(minest[0][0],10,0);\n\t\tainst(minest[1][0],10,0);\n\t\t//探索開始\n\t\tfor(mcor = 0;mcor <= M;mcor++){\n\t\t\tif(mcor < M)\n\t\t\t\tnow = nap(N,0);\n\t\t\telse\n\t\t\t\tnow = nap(N,1);\n\t\t\tif(saisyo[saicor] > now)\n\t\t\t\tsaisyo[saicor] = now;\n\t\t\tfor(i = 0;i < N;i++){\n\t\t\t\tacopy(minest[0][i],minest[1][i],10);\n\t\t\t\tainst(minest[1][i],10,-1);\n\t\t\t}\n\t\t\tainst(minest[0][0],10,0);\n\t\t\tainst(minest[1][0],10,0);\n\t\t}\n\t\tsaicor++;\n\t}\n\tfor(i = 0;i < saicor;i++){\n\t\tcout << saisyo[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> F;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nmap<F,int> edge;\nint stone[160][1010];\nint n,m;\nint d[160];\nbool used[160];\nint nidan[160];\nvector<P> node;\nvoid dijkstra()\n{\n\tfill(d,d+160,INF);\n\tfill(used,used+160,false);\n\tfill(nidan,nidan+160,0);\n\td[0]=0;\n\twhile(1)\n\t{\n\t\tint v=-1;\n\t\tfor(int u=0;u<node.size();u++)\n\t\t{\n\t\t\tif(!used[u]&&(v==-1||d[u]<d[v]))v=u;\n\t\t}\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tfor(int u=0;u<node.size();u++)\n\t\t{\n\t\t\tif(edge.find(F(node[v],node[u]))==edge.end())continue;\n\t\t\tif(node[u].fi-node[v].fi==2)\n\t\t\t{\n\t\t\t\tif(nidan[v]==m)continue;\n\t\t\t\tif(d[u]>d[v]+edge[F(node[v],node[u])])\n\t\t\t\t{\n\t\t\t\t\td[u]=d[v]+edge[F(node[v],node[u])];\n\t\t\t\t\tnidan[u]=nidan[v]+1;\n\t\t\t\t}\n\t\t\t\telse if(d[u]==d[v]+edge[F(node[v],node[u])])\n\t\t\t\t{\n\t\t\t\t\tnidan[u]=min(nidan[u],nidan[v]+1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(d[u]>d[v]+edge[F(node[v],node[u])])\n\t\t\t{\n\t\t\t\td[u]=d[v]+edge[F(node[v],node[u])];\n\t\t\t\tnidan[u]=nidan[v];\n\t\t\t}\n\t\t\telse if(d[u]==d[v]+edge[F(node[v],node[u])])\n\t\t\t{\n\t\t\t\tnidan[u]=min(nidan[u],nidan[v]);\n\t\t\t}\n\t\t\telse\n\t\t\t{}\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tnode.clear();\n\t\tedge.clear();\n\t\tmemset(stone,0,sizeof(stone));\n\t\tnode.pb(P(0,0));\n\t\tvector<int> tmp[155];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i][a]=b;\n\t\t\t\tnode.pb(P(i,a));\n\t\t\t\ttmp[i].pb(a);\n\t\t\t}\n\t\t}\n\t\tnode.pb(P(n+1,0));\n\t\tfor(int j=0;j<tmp[1].size();j++)\n\t\t{\n\t\t\tedge[F(P(0,0),P(1,tmp[1][j]))]=0;\n\t\t}\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<tmp[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<tmp[i+1].size();k++)\n\t\t\t\t{\n\t\t\t\t\tedge[F(P(i,tmp[i][j]),P(i+1,tmp[i+1][k]))]=(stone[i][tmp[i][j]]+stone[i+1][tmp[i+1][k]])*(abs(tmp[i][j]-tmp[i+1][k]));\n\t\t\t\t}\n\t\t\t\tif(i!=n-1)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<tmp[i+2].size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tedge[F(P(i,tmp[i][j]),P(i+2,tmp[i+2][k]))]=(stone[i][tmp[i][j]]+stone[i+2][tmp[i+2][k]])*(abs(tmp[i][j]-tmp[i+2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<tmp[n-i].size();j++)\n\t\t\t{\n\t\t\t\tedge[F(P(n-i,tmp[n-i][j]),P(n+1,0))]=0;\n\t\t\t}\n\t\t}\n\t\tdijkstra();\n\t\t//cout <<node.size() << endl;\n\t\tcout << d[node.size()-1] << endl;\n\t\t//cout << edge[F(node[0],node[1])]<<' '<<edge[F(node[0],node[2])]<<' '<<edge[F(node[1],node[3])]<<' '<<edge[F(node[2],node[3])]<<' '<<edge[F(node[3],node[4])] << endl;\n\t\t/*for(int i=0;i<node.size();i++)\n\t\t{\n\t\t\tcout << node[i].fi <<' ' << node[i].sec<<' '<<d[i]<<endl;\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint k[160];\npair<int,int> stone[160][15];\n\nint memo[100][160][15];\n\nint main(){\n  int n,m;\n  while((n = getInt()) + (m = getInt())){\n    REP(i,n){\n      k[i] = getInt();\n      REP(j,k[i]){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    memset(memo,-1,sizeof(memo));\n\n    typedef pair<int,pair<int,pair<int,int> > > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    REP(i,k[0])\n      pq.push(mp(0,mp(m,mp(i,0))));\n    if(m != 0)\n      REP(i,k[1])\n        pq.push(mp(0,mp(m-1,mp(i,1))));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n\n      int cost = d.f;\n      int jump = d.s.f;\n      int t    = d.s.s.f;\n      int y    = d.s.s.s;\n      int x    = stone[y][t].f;\n\n      if(y == n){\n        printf(\"%d\\n\",cost);\n        break;\n      }\n\n      if(memo[jump][y][t] != -1) continue;\n      memo[jump][y][t] = cost;\n\n      if(y < n-1){\n        int d = stone[y][t].s;\n        REP(i,k[y+1]){\n          if(memo[jump][y+1][i] != -1) continue;\n          int xx = stone[y+1][i].f;\n          int dd = stone[y+1][i].s;\n#define ABS(a) ((a) < 0 ? -(a) : (a))\n          int cc = cost + (dd + d) * ABS(xx - x);\n          pq.push(mp(cc,mp(jump,mp(i,y+1))));\n        }\n      }else{\n        pq.push(mp(cost,mp(jump,mp(0,n))));\n      }\n\n      if(jump > 0){\n        if(y < n-2){\n          int d = stone[y][t].s;\n          REP(i,k[y+1]){\n            if(memo[jump-1][y+2][i] != -1) continue;\n            int xx = stone[y+2][i].f;\n            int dd = stone[y+2][i].s;\n            int cc = cost + (dd + d) * ABS(xx - x);\n            pq.push(mp(cc,mp(jump-1,mp(i,y+2))));\n          }\n        }else{\n          pq.push(mp(cost,mp(jump-1,mp(0,n))));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct P{\n  int x,c;\n  P(int x,int c):x(x),c(c){}\n};\nint n;\nvector<P> s[150];\nint dp[155][11][77];\nint solve(int y,int i,int m){\n  if(y + 1 >= n) return 0;\n  if(dp[y][i][m] >= 0) return dp[y][i][m];\n\n  int ret = 1 << 22;\n  for(int j = 0; j < (int)s[y+1].size(); j++){\n    ret = min(ret,solve(y+1,j,m) + (s[y][i].c + s[y+1][j].c) * abs(s[y][i].x - s[y+1][j].x));\n  }\n  if(m){\n    for(int j = 0; j < (int)s[y+2].size(); j++){\n      ret = min(ret,solve(y+2,j,m-1) + (s[y][i].c + s[y+2][j].c) * abs(s[y][i].x - s[y+2][j].x));\n    }\n  }\n  return dp[y][i][m] = ret;\n}\nint main(void){\n  while(1){\n    int m;\n    scanf(\"%d%d\",&n,&m); if(!n) break;\n    memset(dp,-1,sizeof(dp));\n    for(int i = 0; i < n; i++){\n      s[i].clear();\n      int k;\n      scanf(\"%d\",&k);\n      for(int j = 0; j < k; j++){\n\tint x,d;\n\tscanf(\"%d%d\",&x,&d);\n\ts[i].push_back(P(x,d));\n      }\n    }\n    int ret = 1 << 22;\n    for(int i = 0; i < (int)s[0].size(); i++){\n      ret = min(ret,solve(0,i,m));\n    }\n    printf(\"%d\\n\",ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000000;\n\nint n, m, k[150], x[150][150], d[150][150];\n\nint dp[150][150][100];\n\nint dijkstra() {\n  for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) for (int k = 0; k <= m; k++) dp[i][j][k] = INF;\n  for (int i = 0; i < k[0]; i++) dp[0][x[0][i]][m] = 0;\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < k[i]; j++) {\n      for (int r = 0; r < k[i - 1]; r++)\n        for (int s = 0; s <= m; s++)\n          dp[i][j][s] = min(dp[i][j][s],\n                            dp[i-1][r][s] + (d[i][j] + d[i-1][r]) * abs(x[i][j] - x[i-1][r]));\n      if (i == 1) continue;\n      for (int r = 0; r < k[i - 2]; r++)\n        for (int s = 0; s < m; s++)\n          dp[i][j][s] = min(dp[i][j][s],\n                            dp[i-2][r][s+1] + (d[i][j] + d[i-2][r]) * abs(x[i][j] - x[i-2][r]));\n    }\n  }\n  int ans = INF;\n  for (int i = 0; i < k[n-1]; i++) for (int j = 0; j <= m; j++) ans = min(ans, dp[n-1][i][j]);\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &k[i]);\n      for (int j = 0; j < k[i]; j++) scanf(\"%d%d\", &x[i][j], &d[i][j]), x[i][j]--;\n    }\n    printf(\"%d\\n\", dijkstra());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 50000000000;\n\nint n, m;\nint K[152], x[152][10], d[152][10];\nlong long dp[152][10];\n\nvoid init()\n{\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tmemset(K, 0, sizeof(K));\n\tK[0] = K[n + 1] = 1;\n\tmemset(x, 0, sizeof(x));\n\tmemset(d, 0, sizeof(d));\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\t\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (m--){\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n - 1) dp[i + 2][k] = min(dp[i + 2][k], dp[i][j]);\n\t\t\t\t\t\telse dp[i + 2][k] = min(dp[i + 2][k], dp[i][j] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long mini = INF;\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tmini = min(mini, dp[n + 1][i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\tint ki;\n\tvector<P> stone[150];\n\tint dp[150][10][80];\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tstone[i].clear();\n\t\t\tfor(int j = 0;j < 10;j++){\n\t\t\t\tfor(int k = 0;k <= m;k++) dp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> ki;\n\t\t\tfor(int j = 0;j < ki;j++){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i].push_back(P(a - 1,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < stone[0].size();i++){\n\t\t\tdp[0][i][0] = 0;\n\t\t}\n\t\tfor(int i = 0;i < stone[1].size();i++){\n\t\t\tdp[1][i][1] = 0;\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tfor(int j = 0;j < stone[i].size();j++){\n\t\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\t\tfor(int l = 0;l < stone[i - 1].size();l++){\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k],dp[i - 1][l][k] + (stone[i][j].second + stone[i - 1][l].second) * abs(stone[i][j].first - stone[i - 1][l].first));\n\t\t\t\t\t}\n\t\t\t\t\tif(i >= 2 && k >= 1){\n\t\t\t\t\t\tfor(int l = 0;l < stone[i - 2].size();l++){\n\t\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k],dp[i - 2][l][k - 1] + (stone[i][j].second + stone[i - 2][l].second) * abs(stone[i][j].first - stone[i - 2][l].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < stone[n - 1].size();i++){\n\t\t\tfor(int j = 0;j <= m;j++){\n\t\t\t\tmi = min(mi,dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nint dp[155][155][11];\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\twhile(1)\n\t{\n\t\tint n,lim;\n\t\tvector<P>vec[155];\n\t\tscanf(\"%d%d\",&n,&lim); if(!n) return 0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint cnt; scanf(\"%d\",&cnt);\n\t\t\tfor(int j=0;j<cnt;j++)\n\t\t\t{\n\t\t\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\t\t\tvec[i].pb(mp(x,y));\n\t\t\t}\n\t\t}\n\t\tvec[0].pb(mp(0,0));\n\t\tvec[n+1].pb(mp(0,0));\n\t\tfor(int i=0;i<=n+1;i++)for(int j=0;j<=lim;j++)for(int k=0;k<=10;k++)dp[i][j][k]=INF;\n\t\tdp[0][lim][0]=0;\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<vec[i].size();k++)\n\t\t\t\t{\n\t\t\t\t\tif(dp[i][j][k]==INF) continue;\n\t\t\t\t\t//go to next\n\t\t\t\t\tif(!i || i==n)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s=0;s<vec[i+1].size();s++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+1][j][s]=min(dp[i+1][j][s],dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s=0;s<vec[i+1].size();s++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint add=abs(vec[i][k].f-vec[i+1][s].f)*(vec[i][k].s+vec[i+1][s].s);\n\t\t\t\t\t\t\tdp[i+1][j][s]=min(dp[i+1][j][s],dp[i][j][k]+add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//go  to  next 2\n\t\t\t\t\tif(i==n || !j) continue;\n\t\t\t\t\tif(!i || i==n-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s=0;s<vec[i+2].size();s++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i+2][j-1][s]=min(dp[i+2][j-1][s],dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s=0;s<vec[i+2].size();s++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint add=abs(vec[i][k].f-vec[i+2][s].f)*(vec[i][k].s+vec[i+2][s].s);\n\t\t\t\t\t\t\tdp[i+2][j-1][s]=min(dp[i+2][j-1][s],dp[i][j][k]+add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tfor(int i=0;i<=lim;i++) ret=min(ret,dp[n+1][i][0]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int INF=1000000000;\nstruct data{\n    int x,d;\n    data(int a,int b){\n        x=a;d=b;\n    }\n};\nint abso(data a,data b){\n    int ans=a.x-b.x;\n    if(ans<0)ans*=-1;\n    return ans;\n}\nint dp[77][200][1001];\nint main(){\n    int n,m;\n    while(cin>>n>>m,n||m){\n        vector<vector<data> >stone(n+2);\n        int k;\n        for(int i=0;i<n;i++){\n            cin>>k;\n            for(int j=0;j<k;j++){\n                int x,d;\n                cin>>x>>d;\n                stone[i+1].push_back(data(x-1,d));\n            }\n        }\n\n\n        for(int i=0;i<1000;i++){\n            stone[0].push_back(data(i,0));\n            stone[n+1].push_back(data(i,0));\n        }\n        fill(dp[0][0],dp[0][0]+77*200*1001,INF);\n        for(int k=0;k<=(n+1)/2;k++){\n            for(int i=0;i<=n;i++){\n                for(int j=0;j<stone[i].size();j++){\n                    data At=stone[i][j];\n                    if(i==0)dp[k][i][At.x]=0;\n                    if(dp[k][i][At.x]==INF)continue;\n                    for(int l=0;l<stone[i+1].size();l++){\n                        data to=stone[i+1][l];\n                        int cost=abso(At,to)*(At.d+to.d);\n                        dp[k][i+1][to.x]=min(dp[k][i+1][to.x],dp[k][i][At.x]+cost);\n\n                    }\n\n                    if(i>=n)continue;\n\n                    for(int l=0;l<stone[i+2].size();l++){\n                        data to=stone[i+2][l];\n                        int cost=abso(At,to)*(At.d+to.d);\n                        dp[k+1][i+2][to.x]=min(dp[k+1][i+2][to.x],dp[k][i][At.x]+cost);\n                    }\n\n                }\n            }\n        }\n\n        int Min=INF;\n        for(int i=0;i<=m;i++){\n            for(int j=0;j<1000;j++)\n                Min=min(Min,dp[i][n+1][j]);\n        }\n        cout<<Min<<endl;\n        /*\n        cout<<endl<<endl;\n        int p=1;\n        for(int i=n+1;i>=0;i--){\n            cout<<i<<\":\";\n            for(int j=0;j<10;j++){\n                if(dp[p][i][j]==INF)cout<<\"i \";\n                else cout<<dp[p][i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        */\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nint danger[155][1010];\nvector<int> X[155];\nint dp[155][1010][80];\n\nconst int inf = 1 << 25;\n\nint solve(int col, int row, int jump)\n{\n  if(col >= n-1) return 0;\n  if(col >= n-2 && jump < m) return 0;\n  if(jump > m) return inf;\n  if(~dp[col][row][jump]) return dp[col][row][jump];\n  int ret = inf;\n  for(int i = 0; i < X[col+1].size(); i++){\n    if(danger[col+1][X[col+1][i]] == inf) continue;\n    int D = (danger[col][row] + danger[col+1][X[col+1][i]]) * abs(row - X[col+1][i]);\n    ret = min(ret, solve(col + 1, X[col+1][i], jump) + D);\n  }\n  if(jump < m){\n    for(int i = 0; i < X[col+2].size(); i++){\n      if(danger[col+2][X[col+2][i]] == inf) continue;\n      int D = (danger[col][row] + danger[col+2][X[col+2][i]]) * abs(row - X[col+2][i]);\n      ret = min(ret, solve(col + 2, X[col+2][i], jump + 1) + D);\n    }\n  }\n  return dp[col][row][jump] = ret;\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 155; i++){\n      for(int j = 0; j < 11; j++) danger[i][j] = inf;\n    }\n    for(int i = 0; i < n; i++){\n      int k; cin >> k;\n      for(int j = 0; j < k; j++){\n\tint x, d;\n\tcin >> x >> d;\n\t--x;\n\tdanger[i][x] = d;\n\tX[i].push_back(x);\n      }\n    }\n    memset(dp, -1, sizeof(dp));\n    int ans = inf;\n    for(int i = 0; i < X[0].size(); i++){\n      if(danger[0][X[0][i]] == inf) continue;\n      ans = min(ans, solve(0, X[0][i], 0));\n    }\n    if(m > 0){\n      for(int i = 0; i < X[1].size(); i++){\n\tif(danger[1][X[1][i]] == inf) continue;\n\tans = min(ans, solve(1, X[1][i], 1));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\n#define INF (1<<30)\nint suberi(PA a,PA b){\n  return(a.second+b.second);\n}\nint yoko(PA a,PA b){\n  return(abs(a.first-b.first));\n}\nint dp[151][10][80];\nint main(){\n  int n,m,k,x,d;\n  vector<PA> vec[151];\n  while(scanf(\"%d %d\",&n,&m),n!=0||m!=0){\n    fill_n(**dp,151*10*80,INF);\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x,&d);\n\tvec[i].push_back(PA(x,d));\n\tif(i == 0) dp[0][j][0] = 0;\n\tif(i == 1) dp[1][j][1] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<vec[i].size();j++){\n\tfor(int l=0;l<=m;l++){\n\t  for(int z=0;z<vec[i+1].size();z++){\n\t    dp[i+1][z][l] = min(dp[i+1][z][l],suberi(vec[i][j],vec[i+1][z]) * yoko(vec[i][j],vec[i+1][z]) + dp[i][j][l]);\n\t  }\n\t  if(l == m || i == n-2) continue;\n\t  for(int z=0;l<=m,z<vec[i+2].size();z++){\n\t    dp[i+2][z][l+1] = min(dp[i+2][z][l+1],suberi(vec[i][j],vec[i+2][z]) * yoko(vec[i][j],vec[i+2][z]) + dp[i][j][l]);\n\t  }\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i=n-2;i<n;i++){\n      for(int j=0;j<vec[i].size();j++){\n\tfor(int l=0;l<=m;l++){\n\t  if(i!=n-2||l!=m) ans = min(ans,dp[i][j][l]);\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nvoid calc(int n,int m){\n    int c,a,b,d=-1,dp[151][10][80],ans=1000000000,s,dis;\n    vector<pair<int,int> > stone[151];\n    \n    //scanf(\"%d%d\",&n,&m);\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<=m;k++){\n                dp[i][j][k]=1000000000;\n            }\n        }\n    }\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&c);\n        if(d<0 && c>0){\n            d=i;\n            for(int j=0;j<10;j++){\n                dp[i][j][0]=0;\n            }\n        }\n        \n        for(int j=0;j<c;j++){\n            scanf(\"%d%d\",&a,&b);\n            stone[i].push_back(make_pair(a,b));\n        }\n    }\n    \n    for(int i=d;i<n-1;i++){\n        \n        for(int j=0;j<stone[i].size();j++){\n            for(int k=0;k<stone[i+1].size();k++){\n                for(int l=0;l<=m;l++){\n                    s=stone[i][j].second+stone[i+1][k].second;\n                    dis=abs(stone[i][j].first-stone[i+1][k].first);\n                    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][l]+s*dis);\n                }\n            }\n            for(int k=0;k<stone[i+2].size();k++){\n                for(int l=0;l<m;l++){\n                    s=stone[i][j].second+stone[i+2][k].second;\n                    dis=abs(stone[i][j].first-stone[i+2][k].first);\n                    dp[i+2][k][l+1]=min(dp[i+2][k][l+1],dp[i][j][l]+s*dis);\n                }\n            }\n        }\n    }\n    \n    for(int i=0;i<stone[n-1].size();i++){\n        for(int j=0;j<=m;j++){\n            ans=min(ans,dp[n-1][i][j]);\n        }\n    }\n    if(n>2){\n        for(int i=0;i<stone[n-2].size();i++){\n            for(int j=0;j<m;j++){\n                ans=min(ans,dp[n-2][i][j]);\n            }\n        }\n    }\n    \n    printf(\"%d\\n\",ans);\n    \n    return;\n}\n\nint main(){\n    int n,m;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0) break;\n        calc(n,m);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<MAX_V; i++){\n    ans=min(d[n][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(0);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(1));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n#include<functional>\nusing namespace std;\nint n, m, a, b, c, dist[4000][100]; vector<tuple<int, int, int>>p; vector<tuple<int, int, int>>K[4000][100];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 4000; i++) { for (int j = 0; j < 100; j++) { dist[i][j] = 999999999; K[i][j].clear(); } }\n\t\tcin >> n >> m; p.clear(); if (n == 0 && m == 0)break;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> a; for (int j = 0; j < a; j++) { cin >> b >> c; p.push_back(make_tuple(i, b, c)); }\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\tif (get<0>(p[i]) == 1 || get<0>(p[i]) == 2) { p.push_back(make_tuple(0, get<1>(p[i]), 0)); }\n\t\t\tif (get<0>(p[i]) == n || get<0>(p[i]) == n - 1) { p.push_back(make_tuple(n + 1, get<1>(p[i]), 0)); }\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tfor (int h = 0; h <= m; h++) {\n\t\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\t\tfor (int j = i + 1; j < p.size(); j++) {\n\t\t\t\t\tif (get<0>(p[j]) - get<0>(p[i]) == 1) {\n\t\t\t\t\t\tint rx = get<1>(p[i]), sx = get<1>(p[j]);\n\t\t\t\t\t\tint rp = get<2>(p[i]), sp = get<2>(p[j]);\n\t\t\t\t\t\tint U = abs(rx - sx)*(rp + sp);\n\t\t\t\t\t\tK[i][h].push_back(make_tuple(j, h, U));\n\t\t\t\t\t}\n\t\t\t\t\tif (get<0>(p[j]) - get<0>(p[i]) == 2) {\n\t\t\t\t\t\tint rx = get<1>(p[i]), sx = get<1>(p[j]);\n\t\t\t\t\t\tint rp = get<2>(p[i]), sp = get<2>(p[j]);\n\t\t\t\t\t\tint U = abs(rx - sx)*(rp + sp);\n\t\t\t\t\t\tK[i][h].push_back(make_tuple(j, h + 1, U));\n\t\t\t\t\t}\n\t\t\t\t\tif (get<0>(p[j]) - get<0>(p[i]) >= 3) { break; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>>Q;\n\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\tif (get<0>(p[i]) == 0) { Q.push(make_tuple(0, i, 0)); dist[i][0] = 0; }\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\t\tfor (int i = 0; i < K[a2][a3].size(); i++) {\n\t\t\t\tint to1 = get<0>(K[a2][a3][i]), to2 = get<1>(K[a2][a3][i]), cost = get<2>(K[a2][a3][i]);\n\t\t\t\tif (dist[to1][to2] > a1 + cost) {\n\t\t\t\t\tdist[to1][to2] = a1 + cost; Q.push(make_tuple(dist[to1][to2], to1, to2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 999999999;\n\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\tif (get<0>(p[i]) != (n + 1))continue;\n\t\t\tfor (int j = 0; j <= m; j++)maxn = min(maxn, dist[i][j]);\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint d[100][150][1001];\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0) break;\n\tvector< vector< pair<int,int> > > coor(n);\n\tqueue< pair<int,int> > qxy;\n\tqueue<int> qm;\n\tqueue<int> qs;\n\tmemset(d,-1,sizeof(d));\n\tint ans = 100000000;\n\tREP(i,n){\n\t    int k;\n\t    cin >> k;\n\t    REP(j,k){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcoor[i].PB( pair<int,int>(a,b));\n\t\tif(i==0){\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m);\n\t\t    qs.push(b);\n\t\t    d[m][i][a] = 0;\n\t\t}\n\t    }\n\t}\n\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int tm = qm.front();\n\t    int ts = qs.front();\n\t    qxy.pop();\n\t    qm.pop();\n\t    qs.pop();\n//\t    printf(\"d[tm][y][x] = %d\\n\",d[tm][y][x]);\n\t    if(y+1 >= n || (tm > 0 && y+2 >= n)){\n\t\tans = min(ans,d[tm][y][x]);\n\t\tcontinue;\n\t    }\n\t    REP(i,coor[y+1].size()){\n\t\tint nx = coor[y+1][i].first;\n\t\tint ny = y+1;\n\t\tint slip = coor[y+1][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(d[tm][ny][nx] < 0 || d[tm][ny][nx] > v){\n\t\t    d[tm][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t    REP(i,coor[y+2].size()){\n\t\tint nx = coor[y+2][i].first;\n\t\tint ny = y+2;\n\t\tint slip = coor[y+2][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(tm>0 && (d[tm-1][ny][nx] < 0 || d[tm-1][ny][nx] > v )){\n\t\t    d[tm-1][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm-1);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  ll n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    //dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    /*\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n    */\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define SQR(a) ((a)*(a))\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pr;\ntypedef pair<pr,ll> ppr;\ntypedef vector<pr> vpr;\nconst int INF=1<<30;\nint DP[152][152][4];\nint main() {\n\tint n,m,times,tmp;\n\twhile(cin >> n >> m && n){\n\tint block[152][4]={};\n\tREP(i,152)\n\t\tREP(j,152)\n\t\t\tREP(k,4)\n\t\t\t\tDP[i][j][k]=INF;\n\tREP(i,n){\n\t\tcin >> times;\n\t\tREP(j,times){\n\t\tcin >> tmp;\n\t\tcin >> block[i][tmp-1];\n\t\t}\n\t}\n\tREP(i,4){\n\tDP[0][0][i]=0;\n\tDP[1][1][i]=0;\n\tblock[n][i]=1;\n\t}\n\tFOR(i,1,n+1)\n\t\tREP(j,4)\n\t\t\tif(block[i][j])\n\t\t\tREP(l,m+1)\n\t\t\t\tREP(k,4){\n\t\t\t\t\tif(block[i-1][k])\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-1][l][k]+abs(j-k)*(block[i-1][k]+block[i][j]));\n\t\t\t\t\tif(block[i-2][k] && l && i!=1)\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-2][l-1][k]+abs(j-k)*(block[i-2][k]+block[i][j]));\n\t\t\t\t}\n\tint minium=INF;\n\tREP(i,4)\n\t\tREP(j,m+1)\n\t\t\tminium=min(minium,DP[n][j][i]);\n\tcout << minium << endl;\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans;\nLL V[160][1010];\n//LL mem[160][1001][80];\n\nLL cal(int y,int x,int m){\n    LL res=INF;\n    //if(mem[y][x][m]!=-1)return mem[y][x][m];\n    if(y>=N)return 0;\n    if(y==0){\n        FOR(i,1,1000){\n            if(V[y+1][i]!=INF)\n            res=cal(y+1,i,m);\n        }\n    }\n    else{\n        if(V[y][x]!=INF){\n            FOR(i,1,1000){\n                    if(m>0&&V[y+1][i]!=INF&&V[y+2][i]!=INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,min(cal(y+2,i,m-1)+d2,res));\n                    }\n                    else if(V[y+1][i]!=INF&&V[y+2][i]==INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,res);\n                    }\n                    else if(V[y+1][i]==INF&&V[y+2][i]!=INF&&m>0){\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+2,i,m)+d2,res);\n                    }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin>>N>>M;\n    memset(mem,-1,sizeof(mem));\n    rep(i,151)rep(j,1001)V[i][j]=INF;\n    FOR(i,1,N){\n        LL t;\n        cin>>t;\n        rep(j,t){\n            LL x,k;\n            cin>>x>>k;\n            V[i][x]=k;\n        }\n    }\n    ans=cal(0,0,M);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int INFTY = (1<<30);\nstatic const int NMAX = 150;\nstatic const int MMAX = 80;\nclass Node{\npublic:\n  int p, s, M[MMAX];\n  Node(){}\n  Node(int p, int s):p(p), s(s){\n    rep(i, MMAX) M[i] = INFTY;\n  }\n};\n\nint n, m;\nvector<Node> P[NMAX];\n\nint compute(){\n  rep(j, P[0].size()) P[0][j].M[0] = 0;\n  if ( n >= 2 ){\n    rep(j, P[1].size()) P[1][j].M[1] = 0;\n  }\n\n  rep(i, n-1){\n    rep(j, P[i].size()){\n      Node src = P[i][j];\n      rep(k, P[i+1].size()){\n\tNode tar = P[i+1][k];\n\tint cost = (src.s + tar.s)*(max(src.p, tar.p) - min(src.p, tar.p));\n\trep(l, m+1){\n\t    P[i+1][k].M[l] = min(P[i+1][k].M[l], P[i][j].M[l] + cost);\n\t}\n      }\n      if (i == n-1) continue;\n      rep(k, P[i+2].size()){\n\tNode tar = P[i+2][k];\n\tint cost = (src.s + tar.s)*(max(src.p, tar.p) - min(src.p, tar.p));\n\trep(l, m){\n\t    P[i+2][k].M[l+1] = min(P[i+2][k].M[l+1], P[i][j].M[l] + cost);\n\t}\n      }\n    }\n  }\n  int minv = INFTY;\n  rep(j, P[n-1].size()){\n    rep(l, m+1) minv = min(minv, P[n-1][j].M[l]);\n  }\n  if ( n > 1 ){\n    rep(j, P[n-2].size()){\n      rep(l, m) minv = min(minv, P[n-2][j].M[l]);\n    }\n  }\n  return minv;\n}\n\nmain(){\n  int k, p, s;\n  while(1){\n    cin >> n >> m;\n    if ( n == 0 && m == 0 ) break;\n    rep(i, n) P[i].clear();\n    rep(i, n){\n      cin >> k;\n      rep(j, k){\n\tcin >> p >> s;\n\tP[i].push_back(Node(p, s));\n      }\n    }\n    cout << compute() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint sz[200];\nP stone[200][20];\nint dp[200][20][200];\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && (n || m)){\n\t\tfill(sz, sz + 200, 0);\n\t\tfill(&dp[0][0][0], &dp[199][19][199] + 1, INF);\n\t\tmemset(dp[0], 0, sizeof(dp[0]));\n\t\tint res = INF;\n\n\t\trep(i, n){\n\t\t\tcin >> sz[i];\n\t\t\trep(j, sz[i]){\n\t\t\t\tint x, r;\n\t\t\t\tcin >> x >> r;\n\t\t\t\tstone[i][j] = P(x, r);\n\t\t\t}\n\t\t}\n\n\t\trep(i, n){\n\t\t\trep(j, sz[i]){\n\t\t\t\trep(k, m + 1){\n\t\t\t\t\n\t\t\t\t\tif(i == n - 1){\n\t\t\t\t\t\tres = min(res, dp[i][j][k]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trep(l, sz[i+1]){\n\t\t\t\t\t\t\tint cost = abs(stone[i][j].first - stone[i+1][l].first) * \n\t\t\t\t\t\t\t\t(stone[i][j].second + stone[i+1][l].second);\n\t\t\t\t\t\t\tdp[i+1][l][k] = min(dp[i+1][l][k], dp[i][j][k] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k < m){\n\t\t\t\t\t\tif(i == n - 2){\n\t\t\t\t\t\t\tres = min(res, dp[i][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\trep(l, sz[i+2]){\n\t\t\t\t\t\t\t\tint cost = abs(stone[i][j].first - stone[i+2][l].first) * \n\t\t\t\t\t\t\t\t\t(stone[i][j].second + stone[i+2][l].second);\n\t\t\t\t\t\t\t\tdp[i+2][l][k+1] = min(dp[i+2][l][k+1], dp[i][j][k] + cost);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\nconst int INF = 1e9;\nint n, m; \nint bmemo[160][1010];//b[y][x]\nvector<pair<int, int> > b[160];//\nint dp[160][1010][80];//dp[y??§?¨?][x??§?¨?][1????£???°????????£??????????????°] = ????????????????°????\nint main(void){\n\twhile(1){\n\t\t//input\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) return 0;\n\t\trep(i, 160)rep(j, 1010) bmemo[i][j] = INF;\n\t\trep(i, 160) b[i].clear();//?????????\n\t\trep(i, n){\n\t\t\tint k; cin >> k;\n\t\t\trep(j, k){//k???????????§?¨?\n\t\t\t\tint x, s; cin >> x >> s; x--;\n\t\t\t\tb[i].push_back(make_pair(x, s));\n\t\t\t\tbmemo[i][x] = s;\n\t\t\t}\n\t\t}\n\n\t\trep(i, 160)rep(j, 1010)rep(k, 80) dp[i][j][k] = INF;\n\t\tfor(auto start1 : b[0]){//???????????????????????£??????\n\t\t\tdp[0][start1.fi][0] = 0;\n\t\t}\n\n\t\tfor(auto start2 : b[1]){//????????????????£???°????????£??????\n\t\t\tdp[1][start2.fi][1] = 0;\n\t\t}\n\n\n\t\n\t\t//??????dp\n\t\tfor (int i = 0; i <  n - 1; ++i){\n\t\t\tfor (int j = 0; j < 1010; ++j){\n\t\t\t\tfor (int k = 0; k <= m; ++k){\n\t\t\t\t\tif(dp[i][j][k] == INF) continue;\n\t\t\t\t\t//??????????????£?????????\n\t\t\t\t\tfor(auto next : b[i + 1]){\n\t\t\t\t\t\tint score = (bmemo[i][j] + next.se) * abs(j - next.fi);//?????????????????±??????\n\t\t\t\t\t\tdp[i + 1][next.fi][k] = min(dp[i + 1][next.fi][k], dp[i][j][k] + score);\n\t\t\t\t\t}\n\t\t\t\t\tif(k == m || i == n - 2) continue;\n\t\t\t\t\t//???????£???°????????£??????\n\t\t\t\t\tfor(auto next : b[i + 2]){\n\t\t\t\t\t\tint score = (bmemo[i][j] + next.se) * abs(j - next.fi);//?????????????????±??????\n\t\t\t\t\t\tdp[i + 2][next.fi][k + 1] = min(dp[i + 2][next.fi][k + 1], dp[i][j][k] + score);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//????°????????????????\n\t\tint ans = INF;\n\t\tfor (int j = 0; j < 1010; ++j){\n\t\t\tfor (int k = 0; k <= m; ++k){\n\t\t\t\tans = min(ans, dp[n - 1][j][k]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < 1010; ++j){\n\t\t\tfor (int k = 1; k <= m; ++k){\n\t\t\t \tans = min(ans, dp[n - 2][j][k]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 1000000000\nint n,m;\nint d[77][150][1000];\nint r[150][1000];\nint f[150][1000];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(i=0;i<n;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\td[k][i][f[i][j]]=INF;\n\t\t}\n\t\tfor(i=0;i<=c[0];i++)d[m][0][f[0][i]]=0;\n\t\tif(m>=1)for(j=0;j<c[1];j++)d[m-1][1][f[1][j]]=0;\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j+1][i-2][f[i-2][l]]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j][i-1][f[i-1][l]]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][f[n-1][j]]);\n\t\t}\n\t\tfor(i=1;i<=m;i++)for(j=0;j<c[n-2];j++){\n\t\t\tans=min(ans,d[i][n-2][f[n-2][j]]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define pint pair<int, int>\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nint n, m;\nvector<int> retu[150], dan[150];\nint dp[155][10][155];\n\nint dfs(int now, int rk, int rm) {\n\tif (now == n - 1) {\n\t\treturn 0;\n\t}\n\tif (now == n - 2 && rm < m) {\n\t\treturn 0;\n\t}\n\n\tif (dp[now][rk][rm] != -1) return dp[now][rk][rm];\n\n\tint tmp = 999999999;\n\tfor (int i = 0; i < retu[now+1].size(); i++) {\n\t\tint tmp1 = (dan[now][rk] + dan[now + 1][i]) * abs(retu[now][rk] - retu[now + 1][i]);\n\t\ttmp1 += dfs(now + 1, i, rm);\n\t\ttmp = min(tmp, tmp1);\n\t}\n\n\tif (rm < m) {\n\t\tfor (int i = 0; i < retu[now + 2].size(); i++) {\n\t\t\tint tmp1 = (dan[now][rk] + dan[now + 2][i]) * abs(retu[now][rk] - retu[now + 2][i]);\n\t\t\ttmp1 += dfs(now + 2, i, rm + 1);\n\t\t\ttmp = min(tmp, tmp1);\n\t\t}\n\t}\n\n\tdp[now][rk][rm] = tmp;\n\n\treturn tmp;\n}\n\nint main() {\n\twhile (cin >> n >> m, n)\n\t{\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tretu[i].clear();\n\t\t\tdan[i].clear();\n\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\n\t\t\t\tretu[i].push_back(x);\n\t\t\t\tdan[i].push_back(d);\n\n\t\t\t\tfor (int l = 0; l <= m; l++) {\n\t\t\t\t\tdp[i][j][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 999999999;\n\n\t\tfor (int i = 0; i < retu[0].size(); i++) {\n\t\t\tans = min(ans, dfs(0, i, 0));\n\t\t}\n\n\t\tif (m > 0){\n\t\t\tfor (int i = 0; i < retu[1].size(); i++) {\n\t\t\t\tans = min(ans, dfs(1, i, 1));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nconst int inf = 3e17;\n\nsigned main()\n{\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        int dp[155][15][100];\n        int stone[155][15];\n\n        rep(i, n+5) rep(j, 15) stone[i][j] = inf;\n        rep(i, n+5) rep(j, 15) rep(k, 100) dp[i][j][k] = inf;\n\n        rep(i, n) {\n            int k; cin >> k;\n            rep(j, k) {\n                int x, d; cin >> x >> d;\n                --x;\n                stone[i][x] = d;\n                if (i == 0) dp[0][x][0] = 0;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 11; ++j) {\n                if (stone[i][j] == inf) continue;\n\n                for (int k = 0; k < m+1; ++k) {\n                    if (k < m) {\n                        if (i + 2 >= n) continue;\n\n                        rep(l, 11) {\n                            if (stone[i + 2][l] == inf) continue;\n\n                            dp[i + 2][l][k + 1] = min(\n                                    dp[i + 2][l][k + 1],\n                                    dp[i][j][k] + (stone[i][j] + stone[i + 2][l]) * abs(j-l)\n                                    );\n                        }\n                    }\n\n                    if (i + 1 >= n) continue;\n\n                    rep(l, 11) {\n                        if (stone[i + 1][l] == inf) continue;\n\n                        dp[i + 1][l][k] = min(\n                                dp[i + 1][l][k],\n                                dp[i][j][k] + (stone[i][j] + stone[i + 1][l]) * abs(j-l)\n                                );\n                    }\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j < m + 1; ++j) {\n                mi = min(mi, dp[n - 1][i][j]);\n            }\n        }\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mi = min(mi, dp[n - 2][i][j]);\n            }\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint stone[160][1010];\nint dp[160][1010][100];\nint n,m;\nvector<int> node[160];\nint dist(int a1,int a2,int b1,int b2)\n{\n\treturn (stone[a1][a2]+stone[b1][b2])*abs(a2-b2);\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<160;i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=0;i<100;i++)\n\t\t{\n\t\t\tfor(int j=0;j<1010;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<100;k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<160;i++)\n\t\t{\n\t\t\tfor(int j=0;j<1010;j++)\n\t\t\t{\n\t\t\t\tstone[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i][a]=b;\n\t\t\t\tnode[i].pb(a);\n\t\t\t\tif(i==1)\n\t\t\t\t{\n\t\t\t\t\tdp[i][a][m]=0;\n\t\t\t\t}\n\t\t\t\tif(i==2&&m>0)\n\t\t\t\t{\n\t\t\t\t\tdp[i][a][m-1]=0;\n\t\t\t\t\t//cout << dp[i][a][m-1] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<node[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<node[i+1].size();k++)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=0;l<=m;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][node[i+1][k]][l]=min(dp[i+1][node[i+1][k]][l],dp[i][node[i][j]][l]+dist(i,node[i][j],i+1,node[i+1][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<node[i+2].size();k++)\n\t\t\t\t{\n\t\t\t\t\tfor(int l=0;l<m;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+2][node[i+2][k]][l]=min(dp[i+2][node[i+2][k]][l],dp[i][node[i][j]][l+1]+dist(i,node[i][j],i+2,node[i+2][k]));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<node[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=m;k++)\n\t\t\t\t{\n\t\t\t\t\tcout <<i<<' '<<node[i][j]<<' '<<k<<' '<< dp[i][node[i][j]][k] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t//cout << dp[1][node[1][0]][m] << endl;\n\t\tfor(int i=0;i<node[n-1].size();i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tans=min(ans,dp[n-1][node[n-1][i]][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<node[n].size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tans=min(ans,dp[n][node[n][i]][j]);\n\t\t\t}\n\t\t}\n\t\t//cout << dist(1,node[1][0],2,node[2][0])<< endl;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL dp[151][151][11];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while(cin>>N>>M,N){\n\tvector<vector<PII>> xs(N);\n\tREP(i,N){\n\t  int k; cin >> k;\n\t  REP(j,k){\n\t\tPII p;\n\t\tcin >> p.FF >> p.SS;\n\t\txs[i].EB(p);\n\t  }\n\t}\n\n\tfill((LL*)dp, (LL*)dp+151*151*11, 1e15);\n\tREP(j,11)\n\t  dp[0][0][j] = dp[1][1][j] = 0;\n\t\n\tREP(i,N){\n\t  REP(k,M+1){\n\t\tfor(int j1=0;j1<SZ(xs[i]);++j1){\n\t\t  if(i-1>=0)\n\t\t\tfor(int j2=0;j2<SZ(xs[i-1]);++j2){\n\t\t\t  mini(dp[i][k][j1],\n\t\t\t\t   dp[i-1][k][j2] + abs(xs[i][j1].FF - xs[i-1][j2].FF)\n\t\t\t\t   * (xs[i][j1].SS + xs[i-1][j2].SS));\n\t\t\t}\n\t\t  if(i-2>=0)\n\t\t\tfor(int j2=0;j2<SZ(xs[i-2]);++j2){\n\t\t\t  mini(dp[i][k+1][j1],\n\t\t\t\t   dp[i-2][k][j2] + abs(xs[i][j1].FF - xs[i-2][j2].FF)\n\t\t\t\t   * (xs[i][j1].SS + xs[i-2][j2].SS));\n\t\t\t}\n\t\t}\n\t  }\n\t}\n\n\tLL ans = 1e15;\n\tREP(k,M+1) REP(j,11) mini(ans, dp[N-1][k][j]);\n\tREP(k,M) REP(j,11) mini(ans, dp[N-2][k][j]);\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%d\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%d %d\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\tmemset(memo, -1, sizeof(memo));\n\n\t\trep(i, k[0]) chmin(ans, rec(0, 0, i));\n\n\t\tif (M > 0) rep(i, k[1]) chmin(ans, rec(1, 1, i));\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n#define N 153\n#define ACOL 11\n#define JUMP 76\n\nconst int infty=1<<29;\n\nusing namespace std;\n\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\n\nint dijkstra(int n,int m,\n\t     const vector< vector<int> > &C,\n\t     const vector< vector<int> > &D)\n{\n  static bool vis[N][ACOL][JUMP];\n  static int A[N][ACOL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<ACOL;++j)for(int k=0;k<JUMP;++k){vis[i][j][k]=false;A[i][j][k]=infty;}\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  \n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    vis[s.r][s.c][s.left]=true;\n    if(s.r==n+1||s.r==n+2){continue;}\n    for(int k=1;k<=2;++k){\n      for(int i=0;i<C[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=i,nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(C[s.r][s.c]-C[nxr][nxc]),nxj=s.left-(k-1);\n\tif(s.r==0||nxr==n+1||nxr==n+2)nxcost=s.cost;if(nxj<0)continue;\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc][nxj]&&A[nxr][nxc][nxj]>nxcost){A[nxr][nxc][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  int ret=infty;\n  for(int i=0;i<JUMP;++i){for(int j=0;j<ACOL;++j){\n      ret=min(A[n+1][j][i],min(A[n+2][j][i],ret));\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(cin.eof()||n==0&&m==0)break;\n    vector< vector<int> > D(n+3);D[n+1].push_back(0);D[n+2].push_back(0);\n    vector< vector<int> > C(n+3);C[n+1].push_back(0);C[n+2].push_back(0);\n    for(int i=0;i<n;++i){\n      int k;\n      cin>>k;\n      for(int j=0;j<k;++j){\n\tint col,danger;\n\tcin>>col>>danger;\n\tC[i+1].push_back(col);\n\tD[i+1].push_back(danger);\n      }\n    }\n    cout<<dijkstra(n,m,C,D)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t/*\n\tfor(a=0;a<=m;a++){\n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t}\n\t*/\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second ==0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<MAX_V; i++)\n    ans=min(d[n-1][i],ans);\n \n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n-1; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dijkstra(0) << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    ll dp[2000][100];\n    ll i,j,k,x,d,a;\n    ll inf = 1 << 30;\n    ll ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    ll c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    //cout << c << endl;\n    fill(dp[0],dp[1999],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    for(i=0;i<v[1].size();i++){\n      dp[v[1][i].first][1]=0;\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\t\t       \n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t}\n      }\n    }\n    ans=inf;\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Stone{\n  int x,d;\n  Stone(){}\n  Stone(int x, int d):x(x),d(d){}\n};\n\nint danger(Stone &a, Stone &b){ return abs(a.x-b.x)*(a.d+b.d);}\n\nconst int INF = 1<<30;\nint N,M;\nvector<Stone>s[256];\nint dp[160][16][80];\n\nint main(){\n  while(scanf(\"%d%d\", &N,&M) && N||M){\n    for(int i=0;i<256;i++) s[i].clear();\n    for(int i=0;i<N;i++){\n      int k; scanf(\"%d\", &k);\n      while(k--){\n\tint x,d; scanf(\"%d%d\",&x,&d);\n\ts[i].push_back(Stone(x,d));\n      }\n    }\n\n    for(int i=0;i<160;i++) for(int j=0;j<16;j++) for(int k=0;k<80;k++) dp[i][j][k] = INF;\n    for(int j=0;j<2;j++) for(int i=0;i<s[j].size();i++) dp[j][i][M-j] = 0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k<s[i+1].size();k++){\n\t  for(int m=0;m<=M;m++) \n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m]+danger(s[i][j],s[i+1][k]));\n\t}\n\tif(i<N-1){\n\t  for(int k=0;k<s[i+2].size();k++){\n\t    for(int m=1;m<=M;m++)\n\t      dp[i+2][k][m-1] = min(dp[i+2][k][m-1], dp[i][j][m]+danger(s[i][j],s[i+2][k]));\n\t  }\n\t}\n      }\n    }\n    /*    for(int i=0;i<=M;i++){\n      for(int j=0;j<N;j++){\n\tfor(int k=0;k<10;k++) printf(\"%d \", dp[j][k][i]); puts(\"\");\n      }puts(\"\");\n      }*/\n    int res = INF;\n    for(int i=0;i<s[N-1].size();i++) for(int m=0;m<=M;m++) res = min(res, dp[N-1][i][m]);\n    for(int i=0;i<s[N-2].size();i++) for(int m=1;m<=M;m++) res = min(res, dp[N-2][i][m]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30 ;\nstruct edge{\n  int pos, strong ;\n  int dp[77];\n\n  edge(int pos, int strong): pos(pos), strong(strong){\n    fill_n( dp, 77, INF);\n  };\n  edge(){};\n};\n\nint main(){\n  int n; //行数 \n  int m; //ジャンプの数\n\n  vector< edge > node[152] ;\n\n  while(cin >> n >> m, n){\n    for(int i = 0; i < n; i++){\n      int k;\n      cin >> k ;\n      node[i].resize(k) ;\n      for(int j = 0; j < k; j++){\n        int x, d;\n        cin >> x >> d ;\n        node[i][j] = edge( x, d);\n      }\n    }\n\n    for(int i = 0; i < node[0].size(); i++){ //最初は普通にジャンプ\n      node[0][i].dp[0] = 0;\n    }\n    for(int i = 0; i < node[1].size(); i++){ //最初はジャンプする\n      node[1][i].dp[1] = 0 ;\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < node[i].size(); j++){\n        for(int k = 0; k <= m; k++){\n          if(node[i][j].dp[k] != INF){\n            if(k != m){\n              for(int l = 0; l < node[i + 2].size(); l++){\n                node[i + 2][l].dp[k + 1] = min( node[i + 2][l].dp[k + 1], node[i][j].dp[k] + (node[i + 2][l].strong + node[i][j].strong) * abs(node[i + 2][l].pos - node[i][j].pos));\n              }\n            }\n            for(int l = 0; l < node[i + 1].size(); l++){\n              node[i + 1][l].dp[k] = min( node[i + 1][l].dp[k], node[i][j].dp[k] + (node[i + 1][l].strong + node[i][j].strong) * abs(node[i + 1][l].pos - node[i][j].pos));\n            }\n          }\n        }\n      }\n    }\n    int ret = INF ;\n    for(int i = 0; i < node[n - 1].size(); i++){\n      for(int j = 0; j <= m; j++){\n        ret = min( ret, node[n - 1][i].dp[j]);\n      }\n    }\n    for(int i = 0; i < node[n - 2].size(); i++){\n      for(int j = 0; j < m; j++){\n        ret = min( ret, node[n - 2][i].dp[j]);\n      }\n    }\n    cout << ret << endl ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstdlib>\n\n#define ft first\n#define sd second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 99999;\nint n, m;\nmap<int, vector<P> > mpp;\n\nint solve()\n{\n  int res = inf, dp[152][11][80];\n  vector<P> v1, v2;\n \n  fill(&dp[0][0][0], &dp[152][0][0], inf);\n  /*\n  for(int i = 0; i <= m; i++)\n    for(int j = 0; j <= n; j++)\n      for(int k = 0; k <= 10; k++)\n\tdp[j][k][i] = inf;\n  */\n  v1 = mpp[1];\n  for(int i = 0; i < v1.size(); i++)\n    dp[1][v1[i].ft][m] = 0;\n\n\n  for(int i = 1; i < n; i++){\n    v1 = mpp[i];\n    v2 = mpp[i+1];\n    for(int j = m; j >= 0; j--)\n      for(int k = 0; k < v1.size(); k++)\n\tfor(int l = 0; l < v2.size(); l++)\n\t  dp[i+1][v2[l].ft][j] = min(dp[i+1][v2[l].ft][j], dp[i][v1[k].ft][j]+(v1[k].sd+v2[l].sd)*abs(v1[k].ft-v2[l].ft));\n\n    if(i < n-1){\n      v2 = mpp[i+2];\n      for(int j = m; j > 0; j--)\n\tfor(int k = 0; k < v1.size(); k++)\n\t  for(int l = 0; l < v2.size(); l++)\n\t    dp[i+2][v2[l].ft][j-1] = min(dp[i+2][v2[l].ft][j-1], dp[i][v1[k].ft][j]+(v1[k].sd+v2[l].sd)*abs(v1[k].ft-v2[l].ft));\n    }\n  }\n  /*\n  for(int i = n; i > 0; i--){\n    for(int j = 1; j <= n; j++){\n      int t = inf;\n      for(int k = 0; k <= m; k++)\n\tt = min(t, dp[i][j][k]);\n      if(t == inf) cout << \" - \";\n      else cout << \" \" << t << \" \";\n    }\n    cout << endl;\n  }\n  */\n  for(int i = 0; i <= 10; i++){\n    for(int j = 0; j <= m; j++)\n      res = min(res, dp[n][i][j]);\n    for(int j = 1; j <= m; ++j)\n      res = min(res, dp[n-1][i][j]);\n  }\n  return res;\n}\n\nint main()\n{\n  int s, t, u;\n  while(cin>>n>>m && (n+m)){\n    for(int i = 1; i <= n; i++){\n      cin >> u;\n      vector<P> vec;\n      while(u--){\n\tcin >> s >> t;\n\tvec.push_back(P(s, t));\n      }\n      mpp[i] = vec;\n    }\n\n    cout << solve() << endl;\n    mpp.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll INF = 100000000000000;\nll dan(P p1, P p2){ return (p1.second + p2.second) * abs(p2.first - p1.first); }\nint main(){\n\tll n, m;\n\twhile(true){\n\t\tscanf(\"%lld %lld\", &n, &m);\n\t\tif(n == 0) break;\n\t\tvector<P> a[n + 1];\n\t\tll dp[n + 1][10][m + 1];\n\t\t//初期化\n\t\tfor(int i = 0; i <= n; i++)\n\t\t\tfor(int j = 0; j < 10; j++)\n\t\t\t\tfor(int k = 0; k < m + 2; k++)\n\t\t\t\t\tdp[i][j][k] = (i==0 || i==1)?0:INF;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint ki;\n\t\t\tscanf(\"%d\", &ki);\n\t\t\tfor(int j = 0; j < ki; j++){\n\t\t\t\tll x, d;\n\t\t\t\tscanf(\"%lld %lld\", &x, &d);\n\t\t\t\ta[i].push_back(P(x, d));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tfor(int j = 0; j < a[i].size(); j++){\n\t\t\t\tfor(int k = m; k >= 0; k--){\n\t\t\t\t\tll t = INF;\n\t\t\t\t\tfor(int l = 0; l < a[i-1].size(); l++)\n\t\t\t\t\t\tt = min(t, dan(a[i-1][l], a[i][j]) + dp[i-1][l][k]);\n\t\t\t\t\tif(k < m){\n\t\t\t\t\t\tif(i == 2)t = 0;\n\t\t\t\t\t\tfor(int l = 0; l < a[i-2].size(); l++){\n\t\t\t\t\t\t\tt = min(t, dan(a[i-2][l], a[i][j]) + dp[i-2][l][k + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt = min(t, dp[i][j][k + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < a[n].size(); j++)\n\t\t\tans = min(ans, dp[n][j][0]);\n\t\tif(m >= 1)\n\t\tfor(int j = 0; j < a[n-1].size(); j++)\n\t\t\tans = min(ans, dp[n-1][j][1]);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans;\nLL V[160][1010];\nLL mem[160][501][80];\n\nLL cal(int y,int x,int m){\n    LL res=INF;\n    if(mem[y][x][m]!=-1)return mem[y][x][m];\n    if(y>=N)return 0;\n    if(y==0){\n        FOR(i,1,1000){\n            if(V[y+1][i]!=INF)\n            res=cal(y+1,i,m);\n        }\n    }\n    else{\n        if(V[y][x]!=INF){\n            FOR(i,1,1000){\n                    if(m>0&&V[y+1][i]!=INF&&V[y+2][i]!=INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,min(cal(y+2,i,m-1)+d2,res));\n                    }\n                    else if(V[y+1][i]!=INF&&V[y+2][i]==INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,res);\n                    }\n                    else if(V[y+1][i]==INF&&V[y+2][i]!=INF&&m>0){\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+2,i,m-1)+d2,res);\n                    }\n            }\n        }\n    }\n    return mem[y][x][m]=res;\n}\n\nint main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(mem,-1,sizeof(mem));\n        rep(i,151)rep(j,1001)V[i][j]=INF;\n        FOR(i,1,N){\n            LL t;\n            cin>>t;\n            rep(j,t){\n                LL x,k;\n                cin>>x>>k;\n                V[i][x]=k;\n            }\n        }\n        ans=cal(0,0,M);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<vector<vector<int> > > dp;\nclass stone{\npublic:\n    int place;\n    int smooth;\n    stone(int a,int b):place(a),smooth(b){}\n};\nint n,m;\n\nint func(int,int,int,vector<vector<stone> >&);\nint main(){\n    while(cin>>n>>m&&n){\n        dp.resize(n);\n        vector<vector<stone> > map(n);\n        for(int i=0;i<n;++i){\n            int num;\n            cin>>num;\n            dp[i].resize(num);\n            for(int j=0;j<num;++j){\n                dp[i][j].resize(m+1);\n                int a,b;\n                cin>>a>>b;\n                map[i].push_back(stone(a,b));\n            }\n        }\n        for(int i=0,I=dp.size();i<I;++i){\n            for(int j=0,J=dp[i].size();j<J;++j){\n                for(int k=0,K=dp[i][j].size();k<K;++k){\n                    dp[i][j][k]=-1;\n                }\n            }\n        }\n        int ans = 1<<30;\n        for(int i=0;i<map[0].size();++i){\n            ans = min(ans,func(0,i,m,map));\n        }\n        if(m>0){\n            for(int i=0;i<map[1].size();++i){\n                ans = min(ans,func(1,i,m-1,map));\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\nint func(int tate,int yoko,int chance,vector<vector<stone> >&map){\n    int res = 1<<30;\n    if(tate+1==n){\n        return 0;\n    }\n    if(chance>0&&tate+2==n){\n        return 0;\n    }\n    int dnum = dp[tate][yoko][chance];\n    if(dnum>=0){\n        return dnum;\n    }\n    for(int i=0,I=map[tate+1].size();i<I;++i){\n        int danger = abs(map[tate+1][i].place-map[tate][yoko].place)*(map[tate+1][i].smooth+map[tate][yoko].smooth);\n        res=min(res,danger+func(tate+1,i,chance,map));\n    }\n    if(chance>0){\n        for(int i=0,I=map[tate+2].size();i<I;++i){\n            int danger = abs(map[tate+2][i].place-map[tate][yoko].place)*(map[tate+2][i].smooth+map[tate][yoko].smooth);\n            res=min(res,danger+func(tate+2,i,chance-1,map));\n        }\n    }\n    dp[tate][yoko][chance]=res;\n    return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nint n, m;\nint l[150];\nint k[150][10][2];\nlong long int dp[150][10][75];\nlong long int INF = 10e15+7;\nlong long int z = 0;\n\nint main(){\n\twhile(1){\n\t\tmemset(k, 0, sizeof(k));\n\t\tmemset(l, 0, sizeof(l));\n\t\tmemset(dp, INF, sizeof(dp));\n\t\tfill(dp[0][0], dp[149][0], INF);\n\t\tlong long int ans = INF;\n\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d\", &l[i]);\n\t\t\tfor(int j=0; j<l[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &k[i][j][0], &k[i][j][1]);\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i=0; i<n; i++){\n\t\t\tprintf(\"%d\\t\", l[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<l[i]; j++){\n\t\t\t\tprintf(\"%d %d\\t\", k[i][j][0], k[i][j][1]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\n\t\tfor(int i=0; i<l[0]; i++)\n\t\t\tdp[0][i][0] = 0;\n\n\t\tfor(int i=0; i<l[1]; i++)\n\t\t\tif(m > 0)\n\t\t\t\tdp[1][i][1] = 0;\n\n\t\tfor(int i=0; i<l[1]; i++){\n\t\t\tfor(int j=0; j<l[0]; j++){\n\t\t\t\tdp[1][i][0] = min(dp[1][i][0], z + (k[1][i][1] + k[0][j][1]) * abs(k[1][i][0] - k[0][j][0]));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=2; i<n; i++){ //gyou\n\t\t\tfor(int i1=0; i1<l[i]; i1++){ //nowishi\n\t\t\t\tfor(int i2=0; i2<l[i-1]; i2++){ //previshi, ichitobi0\n\t\t\t\t\tdp[i][i1][0] = min(dp[i][i1][0], dp[i-1][i2][0] + (k[i-1][i2][1] + k[i][i1][1]) * abs(k[i][i1][0] - k[i-1][i2][0]));\n\t\t\t\t}\n\t\t\t\tfor(int i2=0; i2<l[i-2]; i2++){ //previshi, ichitobiari\n\t\t\t\t\tfor(int i3=1; i3<m+1; i3++){ //ichitobi\n\t\t\t\t\t\tdp[i][i1][i3] = min(dp[i][i1][i3], dp[i-2][i2][i3-1] + (k[i-2][i2][1] + k[i][i1][1]) * abs(k[i-2][i2][0] - k[i][i1][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i2=0; i2<l[i-1]; i2++){\n\t\t\t\t\tfor(int i3=1; i3<m+1; i3++){\n\t\t\t\t\t\tdp[i][i1][i3] = min(dp[i][i1][i3], dp[i-1][i2][i3] + (k[i-1][i2][1] + k[i][i1][1]) * abs(k[i-1][i2][0] - k[i][i1][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<l[n-1]; i++){\n\t\t\tfor(int j=0; j<m+1; j++){\n\t\t\t\tans = min(ans, dp[n-1][i][j]);\n//\t\t\t\tif(ans == 12) printf(\"%d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<l[n-2]; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tans = min(ans, dp[n-2][i][j]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\t//int (*fin)[77];\n\t\t//// dpÅÅ¬RXgðßé\n\t\t//for(int i = 1; i < n; i++){\n\t\t//\tswap(cur,prv);\n\t\t//\tswap(pprv,cur);\n\t\t//\tfor(int i = 0; i < 1001; i++)\n\t\t//\t\tfill(cur[i],cur[i]+77,INF);\n\t\t//\t// Ç±ÖWv·é©\n\t\t//\tfor(int j = 0; j < 1001; j++){\n\t\t//\t\tif(field[i][j]==0)\n\t\t//\t\t\tcontinue;\n\t\t//\t\t// Ç±©çWv·é©\n\t\t//\t\tfor(int k = 0;  k < 1001; k++){\n\t\t//\t\t\t// ÇÌRXgÅWv·é©\n\t\t//\t\t\tfor(int l = m; l >= 0; l--){\n\t\t//\t\t\t\t// ÓÂ¤ÉWv\n\t\t//\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t//\t\t\t\tif(i>=2&&l!=m){\n\t\t//\t\t\t\t\t// êÂòÎµÅWv\n\t\t//\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//\tfin=cur;\n\t\t//}\n\t\t//int minRes=INF;\n\t\t//for(int i = 0; i < 1001; i++){\n\t\t//\tfor(int j = 0; j <= m; j++){\n\t\t//\t\tminRes=min(minRes,fin[i][j]);\n\t\t//\t}\n\t\t//}\n\t\t//cout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main() {\n\tint n,m;\n\tint k[150]={};\n\tint x[150][10]={};\n\tint s[150][10]={};\n\tint mr[150][10][77]={};\n\tint r,ar;\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0){return 0;}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> k[i];\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tcin >> x[i][j] >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<k[n-1];i++){\n\t\t\tmr[n-1][i][0]=0;\n\t\t\tmr[n-1][i][1]=0;\n\t\t}\n\t\tfor(int i=0;i<k[n-2];i++){\n\t\t\tmr[n-2][i][0]=0;\n\t\t}\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\t//cout << \"i \"<< i << endl;\n\t\t\tfor(int am=max(0,m-(i+1)/2);am<=(n-i)/2 && am<=m && !(i==n-2 && am==1);am++){\n\t\t\t\t// << \"am \" << am << \" \";\n\t\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\t\tmr[i][j][am]=-1;\n\t\t\t\t\tfor(int l=0;l<k[i+1];l++){\n\t\t\t\t\t\tint am2=min(am,(n-i-1)/2);\n\t\t\t\t\t\tr=mr[i+1][l][am2]+(s[i][j]+s[i+1][l])*abs(x[i][j]-x[i+1][l]);\n\t\t\t\t\t\tif(mr[i+1][l][am2]>=0 && (r<mr[i][j][am] || mr[i][j][am]==-1)){\n\t\t\t\t\t\t\tmr[i][j][am]=r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(am>0){\n\t\t\t\t\t\tfor(int l=0;l<k[i+2];l++){\n\t\t\t\t\t\t\t//if(mr[i+2][l][am-1]==0){cout <<\"i:\"<<i <<\" j:\"<< j << \" l:\"<<l<<\" am:\"<<am <<endl;}\n\t\t\t\t\t\t\tr=mr[i+2][l][am-1]+(s[i][j]+s[i+2][l])*abs(x[i][j]-x[i+2][l]);\n\t\t\t\t\t\t\tif(mr[i+2][l][am-1]>=0 && (r<mr[i][j][am] || mr[i][j][am]==-1)){\n\t\t\t\t\t\t\t\tmr[i][j][am]=r;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" am:\" <<am << \" mr:\" << mr[i][j][am] << endl;\n\t\t\t\t//cout << \" \"<<mr[i][j][am] ;\n\t\t\t\t}\n\t\t\t//cout << endl;\n\t\t\t}\n\t\t}\n\t\tint mar=-1;\n\t\tfor(int i=0;i<k[0];i++){\n\t\t\tar=mr[0][i][m];\n\t\t\tif(ar < mar || mar==-1){\n\t\t\t\tmar=ar;\n\t\t\t}\n\t\t}\n\t\tif(m>1){\n\t\t\tfor(int i=0;i<k[1];i++){\n\t\t\t\tar=mr[1][i][m-1];\n\t\t\t\tif(ar < mar|| mar==-1){\n\t\t\t\t\tmar=ar;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mar << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\t\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <cassert>\n#define INF 2000000000\n#define MOD 1000000007\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define mk make_pair\n#define en endl\n#define RE return 0\n//#define int ll\n#define P pair<int,int>\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\nint lcm(int a,int b){if(a==0){return b;} return a/gcd(a,b)*b;}\n\nint n,m; \nvector<P> where[155];\nint dp[155][1005][80]; // i,jは場所　k:  残りのループの回数\n\n// d: 滑りやすさ left: 残りの飛ばせる回数\nint saiki(int i,int j,int left,int d){\n\tif(i>=n) return 0;\n\tif(left&&(i>=n-1)) return 0;\n\tif(dp[i][j][left]<INF) return dp[i][j][left];\n\t\n\tfor(int k=0; k<where[i+1].size(); k++){\n\t\tint j_to=where[i+1][k].first, dd=where[i+1][k].second;\n\t\tdp[i][j][left]=min(dp[i][j][left], saiki(i+1, j_to, left, dd)+(d+dd)*abs(j_to-j));\n\t\tdp[i][j][left]=min(dp[i][j][left], saiki(i+1, j_to, left, dd)+(d+dd)*abs(j_to-j));\n\t}\n\tif(left){\n\t\tfor(int k=0; k<where[i+2].size(); k++){\n\t\t\tint j_to=where[i+2][k].first, dd=where[i+2][k].second;\n\t\t\tdp[i][j][left]=min(dp[i][j][left], saiki(i+2, j_to, left-1, dd)+(d+dd)*abs(j_to-j));\n\t\t\tdp[i][j][left]=min(dp[i][j][left], saiki(i+2, j_to, left-1, dd)+(d+dd)*abs(j_to-j));\n\t\t}\n\t}\n//\t\tcout<<\"dp[\"<<i<<\"][\"<<j<<\"][\"<<left<<\"]:  \"<<dp[i][j][left]<<en;\n\treturn dp[i][j][left];\n}\n\nsigned main(){\n\twhile(cin>>n>>m&&n){\n\t\tfor(int i=0; i<=n+1; i++) where[i].clear();\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tint k; cin>>k;\n\t\t\tfor(int j=0; j<k; j++){\n\t\t\t\tint a,b; cin>>a>>b;\n\t\t\t\twhere[i].push_back(mk(a,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=153; i++) for(int j=0; j<=1002; j++) for(int k=0; k<80; k++) dp[i][j][k]=INF;\n\t\t\n\t\tint ans=INF;\n\t\tfor(int i=0; i<where[1].size(); i++){\n\t\t\tans=min(ans,saiki(1, where[1][i].first, m,where[1][i].second));\n\t\t}\n\t\tif(m){\n\t\t\tfor(int i=0; i<where[2].size(); i++){\n\t\t\t\tans=min(ans, saiki(2, where[2][i].first, m-1, where[2][i].second));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<en;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define INF(a) memset(a,1000000000,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][11];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,10) x[0].pb(i+1);\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  INF(dp);\n  FOR(i,m+1) FOR(j,x[n-1].size()) dp[n][i][x[n-1][j]]=0;\n  for(int i=n-1;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(i!=n&&j){\n      FOR(l,x[i+2].size()){\n       dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+(i!=0)?(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]):0);\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+(i!=0)?(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]):0);\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[0].size()) mi=min(mi,dp[i][m][x[0][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 50000000000;\n\nint n, m;\nint K[152], x[152][10], d[152][10];\nlong long dp[152][10];\n\nvoid init()\n{\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tmemset(K, 0, sizeof(K));\n\tK[0] = K[n + 1] = 1;\n\tmemset(x, 0, sizeof(x));\n\tmemset(d, 0, sizeof(d));\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\t\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (m--){\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n - 1) dp[i + 2][k] = min(dp[i + 2][k], dp[i][j]);\n\t\t\t\t\t\telse dp[i + 2][k] = min(dp[i + 2][k], dp[i][j] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long mini = INF;\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tmini = min(mini, dp[n + 1][i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 10000000;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define int long long\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m;\nll dp[155][80][1005];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<vector<pair<int, int>>> st(155);\n        rep(i, n) {\n            int k;\n            cin >> k;\n            rep(j, k) {\n                int x, d;\n                cin >> x >> d;\n                x--;\n                st[i].push_back({x, d});\n            }\n        }\n        rep(i, 155)rep(j, 80)rep(k, 1005) dp[i][j][k] = LLONG_MAX / 2;\n        for (auto p : st[0]) {\n            dp[0][0][p.fi] = 0;\n        }\n        if (m != 0) {\n            for (auto p : st[1]) {\n                dp[1][1][p.fi] = 0;\n            }\n        }\n        rep(i, n)rep(j, m + 1) {\n            for (auto now : st[i]) {\n                if (dp[i][j][now.fi] == LLONG_MAX / 2) continue;\n                if (i + 1 >= n) continue;\n                for (auto nx : st[i + 1]) {\n                    dp[i + 1][j][nx.fi] = min(dp[i + 1][j][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se + nx.se));\n                }\n                if (i + 2 >= n || j + 1 > m) continue;\n                for (auto nx : st[i + 2]) {\n                    dp[i + 2][j + 1][nx.fi] = min(dp[i + 2][j + 1][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se  + nx.se));\n                }\n            }\n        }\n        int ans = LLONG_MAX / 2;\n        rep(j, m + 1)rep(k, 1001) ans = min(ans, dp[n - 1][j][k]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n#define N 153\n#define COL 1001\n#define ACOL 11\n#define JUMP 76\nconst int infty=1<<29;\nusing namespace std;\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\nint dijkstra(int n,int m,int D[][COL],const vector< vector<int> > &T){\n  static int A[N][ACOL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<ACOL;++j)for(int k=0;k<JUMP;++k)A[i][j][k]=infty;\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  bool vis[N][COL]={false,};\n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    if(s.r==n+1||s.r==n+2)return s.cost;\n    vis[s.r][s.c]=true;\n    for(int k=1;k<=2;++k){for(int i=0;i<T[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=T[nxr][i],nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(s.c-nxc),nxj=s.left-(k-1);\n\tif(nxj<0)continue;if(s.r==0||nxr==n+1||nxr==n+2)nxcost=s.cost;\n\t//if(i>=10){cout << i << endl;}\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc]&&A[nxr][i][nxj]>nxcost){A[nxr][i][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  return -1;\n}\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(n==0&&m==0)break;\n    vector< vector<int> > T(n+3);T[n+1].push_back(0);T[n+2].push_back(0);\n    int D[N][COL]={{0,},};\n    for(int i=0;i<n;++i){int k;cin>>k;for(int j=0;j<k;++j){int col,danger;cin>>col>>danger;T[i+1].push_back(col);D[i+1][col]=danger;}}\n    cout<<dijkstra(n,m,D,T)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\t//memset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t//// ún_ÌÝè\n\t\t//for(int i = 0; i < 1001; i++){\n\t\t//\tif(field[0][i]!=0){\n\t\t//\t\tdp[0][i][m]=0;\n\t\t//\t}\n\t\t//}\n\t\t//int (*fin)[77];\n\t\t//// dpÅÅ¬RXgðßé\n\t\t//for(int i = 1; i < n; i++){\n\t\t//\tswap(cur,prv);\n\t\t//\tswap(pprv,cur);\n\t\t//\tfor(int i = 0; i < 1001; i++)\n\t\t//\t\tfill(cur[i],cur[i]+77,INF);\n\t\t//\t// Ç±ÖWv·é©\n\t\t//\tfor(int j = 0; j < 1001; j++){\n\t\t//\t\tif(field[i][j]==0)\n\t\t//\t\t\tcontinue;\n\t\t//\t\t// Ç±©çWv·é©\n\t\t//\t\tfor(int k = 0;  k < 1001; k++){\n\t\t//\t\t\t// ÇÌRXgÅWv·é©\n\t\t//\t\t\tfor(int l = m; l >= 0; l--){\n\t\t//\t\t\t\t// ÓÂ¤ÉWv\n\t\t//\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t//\t\t\t\tif(i>=2&&l!=m){\n\t\t//\t\t\t\t\t// êÂòÎµÅWv\n\t\t//\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//\tfin=cur;\n\t\t//}\n\t\t//int minRes=INF;\n\t\t//for(int i = 0; i < 1001; i++){\n\t\t//\tfor(int j = 0; j <= m; j++){\n\t\t//\t\tminRes=min(minRes,fin[i][j]);\n\t\t//\t}\n\t\t//}\n\t\t//cout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150]; //K[i]::=i行目に何個の石があるか\nint X[10][150]; //X[i][j]::=j列目のi個目が何列目か\nint D[10][150]; //D[i][j]::=j列目のi個目のすべりやすさ\nint DP[10][150][80]; //DP[i][j][k]::=j列目のi個目にいて、もうk回ジャンプしてるときの最小コスト\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][0]=0;\n\t\tif(M>0) for(int x=0;x<K[1];x++) DP[x][1][1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) for(int m=0;m<=M;m++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y>1 && m>0) {\n\t\t\t\tfor(int xx=0;xx<K[y-2];xx++) {\n\t\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m-1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\n#define int ll\nint dp [1500] [150];\nint n, m;\nvector<vector<int>> mp;\nvector<pii> st;\nint func(int pos, int stnum, int spc) {\n\tif (spc == m+1)\n\t\treturn -1;\n\tif (pos == n-1 || pos == n)\n\t\treturn 0;\n\tif (dp[stnum][spc] != -1)\n\t\treturn dp[stnum][spc];\n\tint res = INT_MAX;\n\tint w = st[stnum].first;\n\tint sb = st[stnum].second;\n\tREP(i, mp[pos+1].size()) {\n\t\tint cand = func(pos + 1, mp[pos + 1][i], spc);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0) {\n\t\t\tcand += (sb + st[mp[pos + 1][i]].second)*abs(w-st[mp[pos + 1][i]].first);\n\t\t}\n\t\tres = min(res, cand);\n\t}\n\tREP(i, mp[pos + 2].size()) {\n\t\tint cand = func(pos + 2, mp[pos + 2][i], spc+1);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0) {\n\t\t\tcand += (sb + st[mp[pos + 2][i]].second)*abs(w - st[mp[pos + 2][i]].first);\n\t\t}\n\t\tres = min(res,cand);\n\t}\n\tdp[stnum][spc] = res;\n\treturn res;\n}\n\nsigned main() {\n\twhile (scanf(\"%lld %lld\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tFill(dp, -1);\n\t\tmp.clear();\n\t\tmp.resize(n + 2);\n\t\tint s = 0;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tscanf(\"%lld\", &c);\n\t\t\tREP(j, c) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%lld %lld\", &a, &b);\n\t\t\t\tmp[i].push_back(s);\n\t\t\t\tst.push_back({ a,b });\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tst.push_back({ -1,-1 });\n\t\tprintf(\"%lld\\n\", func(-1, s, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 5000000\nint n,m;\nint d[77][150][10];\nint r[150][10];\nint f[150][10];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint max(int a,int b){\n\tif(a<=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(i=0;i<n;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\tif(i==0)d[k][i][f[i][j]]=0;\n\t\t\telse d[k][i][f[i][j]]=INF;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j+1][i-2][f[i-2][l]]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j][i-1][f[i-1][l]]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][f[n-1][j]]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=2000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\ntypedef pair<P,vector<int>> P2;\n\nvector<int> emp;\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m); if(n == 0 && m == 0)break;\n\t\t\n\t\tvector<P2> DP[152];\n\t\trep1(i,n){\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\tDP[i].pb(P2(P(x,y),emp));\n\t\t\t}\n\t\t}\n\t\t\n\t\trep1(i,n){\n\t\t\trep(j,DP[i].size()){\n\t\t\t\trep(k,m+1){\n\t\t\t\t\tint dp = INF;\n\t\t\t\t\tif(i == 1){\n\t\t\t\t\t\tdp = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(i == 2 && k > 0){\n\t\t\t\t\t\tdp = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\trep(l,DP[i-1].size()){\n\t\t\t\t\t\t\tdp = min ( dp , DP[i-1][l].sc[k] + (DP[i][j].fr.sc+DP[i-1][l].fr.sc) * abs(DP[i][j].fr.fr-DP[i-1][l].fr.fr) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k > 0){\n\t\t\t\t\t\t\trep(l,DP[i-2].size()){\n\t\t\t\t\t\t\t\tdp = min ( dp , DP[i-2][l].sc[k-1] + (DP[i][j].fr.sc+DP[i-2][l].fr.sc) * abs(DP[i][j].fr.fr-DP[i-2][l].fr.fr) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDP[i][j].sc.pb(dp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = INF;\n\t\t\n\t\trep(i,DP[n].size()){\n\t\t\trep(j,m+1){\n\t\t\t\tret = min ( ret , DP[n][i].sc[j] );\n\t\t\t}\n\t\t}\n\t\tif(n > 1){\n\t\t\trep(i,DP[n-1].size()){\n\t\t\t\trep(j,m){\n\t\t\t\t\tret = min ( ret , DP[n-1][i].sc[j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (int)(1e9)\n\nint mb[10];\nint ms[10];\nint m[10][100];\nint mk;\nint mmb[10];\nint mms[10];\nint mm[10][100];\nint mmk;\nint n[10][100];\n\nvector<pair<int,int> > isi[150];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint nn,mn;\n\t\tscanf(\"%d %d\",&nn,&mn);\n\t\tif(nn == 0 && mn == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(int ii = 0; ii < k; ii++)\n\t\t\t{\n\t\t\t\tint x,d;\n\t\t\t\tscanf(\"%d %d\",&x,&d);\n\t\t\t\tisi[i].push_back(make_pair(x,d));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < isi[0].size(); i++)\n\t\t{\n\t\t\tmb[i] = isi[0][i].first;\n\t\t\tms[i] = 0;\n\t\t\tmmb[i] = isi[0][i].first;\n\t\t\tmms[i] = 0;\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tm[i][ii] = 0;\n\t\t\t\tmm[i][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tmk = isi[0].size();\n\t\tmmk = isi[0].size();\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tif(i == 1)\n\t\t\t{\n\t\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t\t{\n\t\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmm[ii][iii] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tmmb[ii] = isi[i][ii].first;\n\t\t\t\t\tmms[ii] = isi[i][ii].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn[ii][iii] = min;\n\t\t\t\t}\n\t\t\t\tfor(int iii = 0; iii < mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n[ii][iii + 1] > min)\n\t\t\t\t\t{\n\t\t\t\t\t\tn[ii][iii + 1] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < mk; ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tmm[ii][iii] = m[ii][iii];\n\t\t\t\t}\n\t\t\t\tmmb[ii] = mb[ii];\n\t\t\t\tmms[ii] = ms[ii];\n\t\t\t}\n\t\t\tmmk = mk;\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tm[ii][iii] = n[ii][iii];\n\t\t\t\t}\n\t\t\t\tmb[ii] = isi[i][ii].first;\n\t\t\t\tms[ii] = isi[i][ii].second;\n\t\t\t}\n\t\t\tmk = isi[i].size();\n\t\t}\n\t\tint allmin = INF;\n\t\tfor(int i = 0; i < mmk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > mm[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = mm[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < mk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > m[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = m[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",allmin);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nint n, m;\nvector<vector<P> > vec;\n\nll dp[151][1001][77];\n\nll dfs(int x, int y, int z){\n  if(dp[x][y][z] != -1)return dp[x][y][z];\n  if(x == n - 1){\n    return dp[x][y][z] = 0;\n  }else if(x == n - 2 && z + 1 <= m){\n    return dp[x][y][z] = 0;\n  }\n  int tmp = 0;\n  for(P p: vec[x]){\n    if(p.first == y){\n      tmp = p.second;\n      break;\n    }\n  }\n  ll res = linf;\n  // 1 step\n  for(P q: vec[x+1]){\n    res = min(res, (tmp + q.second) * abs(y - q.first) + dfs(x+1, q.first, z));\n  }\n  // 2 step\n  if(z + 1 <= m && x + 2 < n){\n    for(P q: vec[x+2]){\n      res = min(res, (tmp + q.second) * abs(y - q.first) + dfs(x+2, q.first, z+1));\n    }\n  }\n  return dp[x][y][z] = res;\n}\n\nint main(int argc, char const* argv[])\n{\n  while(true){\n    cin >> n >> m;\n    if(n == 0)break;\n    vec.clear();\n    vec.resize(n);\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < 1001; j++){\n        for(int k = 0; k <= m; k++){\n          dp[i][j][k] = -1;\n        }\n      }\n    }\n    for(int i = 0; i < n; i++){\n      int k;\n      cin >> k;\n      for(int j = 0; j < k; j++){\n        int a, b;\n        cin >> a >> b;\n        a--;\n        vec[i].pb(mk(a, b));\n      }\n    }\n    ll res = linf;\n    for(P p: vec[0]){\n      res = min(res, dfs(0, p.first, 0));\n    }\n    if(m != 0){\n      for(P p: vec[1]){\n        res = min(res, dfs(1, p.first, 1));\n      }\n    }\n    cout << res << endl;\n  }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\ntypedef pair<LL, LL> P;\ntypedef pair<LL, P> PP;\nint n, m;\nLL dp[150][10][80];\nvector<P>v[150];\nLL ans = LINF;\n\nint main() {\n\twhile (cin >> n >> m&&n&&m) {\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tfor (int j = 0; j < 10; j++)for (int k = 0; k < 80; k++) {\n\t\t\t\tdp[i][j][k] = HINF;\n\t\t\t}\n\t\t\tv[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\tb--;\n\t\t\t\tv[i].eb(mp(b, c));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < v[0].size(); i++)dp[1][i][m - 1] = 0;\n\t\tif (m > 0)for (int i = 0; i < v[1].size(); i++)dp[1][i][m - 1] = 0;\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\tif (i == n - 1 && k > 0)continue;\n\t\t\t\t\tfor (int l = 0; l < v[i + 1].size(); l++) {\n\t\t\t\t\t\tLL cost = (v[i][j].second + v[i + 1][l].second)*abs(v[i][j].first - v[i + 1][l].first);\n\t\t\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t\t\t}\n\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\tfor (int l = 0; l < v[i + 2].size(); l++) {\n\t\t\t\t\t\t\tLL cost = (v[i][j].second + v[i + 2][l].second)*abs(v[i][j].first - v[i + 2][l].first);\n\t\t\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < v[n - 1].size(); i++)for (int j = 0; j <= m; j++)ans = min(ans, dp[n - 1][i][j]);\n\t\tif (m > 0)for (int i = 0; i < v[n - 2].size(); i++)for (int j = 1; j <= m; j++)ans = min(ans, dp[n - 2][i][j]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1LL << 60\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nvector<P>St[256];\nint N, M;\nll dp[256][16][128];\n\nll dfs(int n, int x, int m){\n  if(n>=N-1) return 0;\n  if(n>=N-2 && m) return 0;\n  ll &res = dp[n][x][m];\n  if(res >= 0) return res;\n  res = INF;\n  int pos = St[n][x].first ,slip = St[n][x].second;\n  rep(i, St[n+1].size()){\n      P tar = St[n+1][i];\n      res = min(res, dfs(n+1, i, m)+(ll)(slip+tar.second)*(ll)(abs(pos-tar.first)));\n  }\n  if(m && n < N-1){\n    rep(i, St[n+2].size()){\n      P tar = St[n+2][i];\n      res = min(res, dfs(n+2, i, m-1)+(ll)(slip+tar.second)*(ll)(abs(pos-tar.first)));\n    }\n  }\n  //  cout << n << \" \" << x << \" \"<< m <<\" \" << res << endl;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &N, &M) && N){\n    int k, x, d;\n    memset(dp, -1, sizeof(dp));\n    rep(i,N) St[i].clear();\n    rep(i, N){\n      scanf(\"%d\", &k);\n      rep(j,k){\n\tscanf(\"%d%d\", &x, &d);\n\tSt[i].push_back(P(x, d));\n      }\n    }\n    \n    ll res = INF;\n    rep(i, St[0].size()) res = min(res, dfs(0, i, M));\n    rep(i, St[1].size()) res = min(res, dfs(1, i, M-1));\n\n    printf(\"%lld\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) REP(i,0,n)\n#define f first\n#define s second\n#define mpi(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\n#define pi pair<pair<int,int>,pair<int,int> >\nusing namespace std;\nint in(){int x; scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      vector<vector<int> > pos(151);\n      vector<vector<int> > cos(151);\n      int flag[151][11][76] = {0};\n      priority_queue<pi,vector<pi >,greater<pi > >Q;//cost,y,x,slip\n      rep(i,n){\n         int x = in();\n         rep(j,x){\n            pos[i].push_back(in());\n            cos[i].push_back(in());\n         }\n      }\n\n      rep(i,pos[0].size()){\n         Q.push(mpi(0,0,i,0));\n      }\n      rep(i,pos[1].size()){\n         if(m != 0){\n            Q.push(mpi(0,1,i,1));\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         pi p = Q.top(); Q.pop();\n         if(p.f.s == n-1){ans = p.f.f; break;}\n         if(p.f.s == n-2 && m > p.s.s){ans = p.f.f; break;}\n\n         if(flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] == 1) continue;\n         flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] = 1;\n\n         rep(i,pos[p.f.s+1].size()){\n            Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+1][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+1][i]),p.f.s+1,i,p.s.s));\n         }\n\n         rep(i,pos[p.f.s+2].size()){\n            if(p.s.s < m) Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+2][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+2][i]),p.f.s+2,i,p.s.s+1));\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst ull INF = 1 << 31;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M;\nstd::vector<P> S[153];\null dp[153][10][80];\n\null value(const P& lp, const P& rp){\n    return (lp.second+rp.second) * std::abs(lp.first-rp.first);\n}\n\null rec(int y, int x, int t){\n    if(y > N){return 0;}\n    if(dp[y][x][t] != INF){return dp[y][x][t];}\n\n    ull res = INF;\n    REP(i, S[y+1].size()){\n        res = std::min(res, rec(y+1, i, t) + value(S[y][x], S[y+1][i]));\n    }\n\n    if(t < M){\n        REP(i, S[y+2].size()){\n            res = std::min(res, rec(y+2, i, t+1) + value(S[y][x], S[y+2][i]));\n        }\n    }\n\n    return dp[y][x][t] = res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, N+3){\n            S[i].clear();\n        }\n\n        REP(i, N){\n            int k;\n            std::cin >> k;\n\n            REP(j, k){\n                int x, d;\n                std::cin >> x >> d;\n                x--;\n            \n                S[i+1].push_back(mp(x, d));\n            }\n        }\n\n        REP(i, S[1].size()){\n            S[0].push_back(S[1][i]);\n        }\n\n        REP(i, S[N].size()){\n            S[N+1].push_back(S[N][i]);\n            S[N+2].push_back(S[N][i]);\n        }\n\n        REP(i, S[N-1].size()){\n            S[N+1].push_back(S[N-1][i]);\n        }\n\n        REP(i, N+3){\n            REP(j, 10){\n                REP(k, M+1){\n                    dp[i][j][k] = INF;\n                }\n            }\n        }\n\n        ull res = INF;\n        REP(i, 10){\n            res = std::min(res, rec(0, i, 0));\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\nint n, m, b;\nvector<vector<PII> > a;\nint dp[ 153 ][ 153 ][ 153 ];\n\nint solve( int now, int e, int w ) {\n\tif ( now >= n || ( w && now >= n - 1 ) ) {\n\t\treturn 0;\n\t}\n\tif ( dp[ now ][ e ][ w ] >= 0 ) {\n\t\treturn dp[ now ][ e ][ w ];\n\t}\n\tint res = INF;\n\tfor ( int i = 0; i < a[ now ].size(); i++ ) {\n\t\tif ( now == 0 ) {\n\t\t\tres = min( res, solve( now + 1, i, w ) );\n\t\t}\n\t\telse {\n\t\t\tres = min( res, solve( now + 1, i, w ) + abs( a[ now - 1 ][ e ].first - a[ now ][ i ].first ) * ( a[ now - 1 ][ e ].second + a[ now ][ i ].second ) );\n\t\t}\n\t}\n\tif ( w ) {\n\t\tfor ( int i = 0; i < a[ now + 1 ].size(); i++ ) {\n\t\t\tif ( now == 0 ) {\n\t\t\t\tres = min( res, solve( now + 2, i, w - 1 ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = min( res, solve( now + 2, i, w - 1 ) + abs( a[ now - 1 ][ e ].first - a[ now + 1 ][ i ].first ) * ( a[ now - 1 ][ e ].second + a[ now + 1 ][ i ].second ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[ now ][ e ][ w ] = res;\n}\n\nint main() {\n\twhile ( ~scanf( \"%d %d\", &n, &m ) && n ) {\n\t\ta.resize( n );\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tscanf( \"%d\", &b );\n\t\t\ta[ i ].resize( b );\n\t\t\tfor ( int j = 0; j < a[ i ].size(); j++ ) {\n\t\t\t\tscanf( \"%d %d\", &a[ i ][ j ].first, &a[ i ][ j ].second );\n\t\t\t}\n\t\t}\n\t\tNCLR( dp );\n\t\tprintf( \"%d\\n\", solve( 0, 0, m ) );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\n#define F 1145141919\nusing namespace std;\nint sw[16000],sh[16000];\nint be[150];\nint dp[80][16000];\nint main(){\n\tint n,m,k;\n\twhile(true){\n\tcin>>n>>m;\n\tif(!n&&!m)break;\n\tfor(int i=0;i<80;i++)for(int j=0;j<16000;j++)dp[i][j]=F;\n\tcin>>k;\n\tfor(int i=0;i<k;i++){\n\t\tcin>>sw[i]>>sh[i];\n\t\tdp[0][i]=0;\n\t}\n\tbe[0]=0,be[1]=k;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>k;\n\t\tif(m)for(int j=0;j<k;j++)dp[1][j]=0;\n\t\tbe[i+1]=be[i]+k;\n\t\tfor(int j=0;j<k;j++)cin>>sw[j+be[i]]>>sh[j+be[i]];\n\t}\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<n-1;j++){\n\t\t\tfor(int f=be[j];f<be[j+1];f++){\n\t\t\t\tfor(int g=be[j+1];g<be[j+2];g++)dp[i][g]=min(dp[i][g],dp[i][f]+abs(sw[f]-sw[g])*(sh[f]+sh[g]));\n\t\t\t\tif(m-i&&n-2-j)for(int g=be[j+2];g<be[j+3];g++)dp[i+1][g]=min(dp[i+1][g],dp[i][f]+abs(sw[f]-sw[g])*(sh[f]+sh[g]));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=F;\n\tfor(int i=be[n-1];i<be[n];i++)for(int j=0;j<=m;j++)ans=min(ans,dp[j][i]);\n\tif(n-1)for(int i=be[n-2];i<be[n-1];i++)for(int j=0;j<m;j++)ans=min(ans,dp[j][i]);\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint dp[155][15][76]={};\nbool p(P a,P b){\n\tif(a.first<b.first){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(1){\n\t\tvector<P>vec[155];\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(!n) break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint r,u;\n\t\t\t\tscanf(\"%d %d\",&r,&u);\n\t\t\t\tvec[i].pb(mp(r,u));\n\t\t\t}\n\t\t}\n\t\tint ui; bool e=false;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tsort(vec[i].begin(),vec[i].end(),p);\n\t\t\tif(vec[i].size()!=0 && !e) {ui=i;e=true;}\n\t\t}\n\t\tfor(int i=0;i<=150;i++){\n\t\t\tfor(int j=0;j<15;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tif(ui<=i){\n\t\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint eee=vec[i].size();\n\t\t\tfor(int j=0;j<eee;j++){\n\t\t\t\tfor(int k=0;k<=min(i/2,m);k++){\n\t\t\t\t\tint r=vec[i-1].size();\n\t\t\t\t\tfor(int l=0;l<r;l++){\n\t\t\t\t\t\tdp[i][j][k]=min(dp[i-1][l][k]+abs(vec[i][j].first-vec[i-1][l].first)*(vec[i-1][l].second+vec[i][j].second),dp[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=0 && i!=2){\n\t\t\t\t\t\tint rr=vec[i-2].size();\n\t\t\t\t\t\tfor(int l=0;l<rr;l++){\n\t\t\t\t\t\t\tdp[i][j][k]=min(dp[i-2][l][k-1]+abs(vec[i][j].first-vec[i-2][l].first)*(vec[i-2][l].second+vec[i][j].second),dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<vec[n].size();i++){\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tres=min(res,dp[n][i][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n#define N 153\n#define COL 1001\n#define JUMP 76\nconst int infty=1<<29;\nusing namespace std;\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\nint dijkstra(int n,int m,int D[][COL],const vector< vector<int> > &T){\n  static int A[N][COL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<COL;++j)for(int k=0;k<JUMP;++k)A[i][j][k]=infty;\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  bool vis[N][COL]={false,};\n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    if(s.r==n+1||s.r==n+2)return s.cost;\n    vis[s.r][s.c]=true;\n    for(int k=1;k<=2;++k){for(int i=0;i<T[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=T[nxr][i],nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(s.c-nxc),nxj=s.left-(k-1);\n\tif(nxj<0)continue;if(s.r==0||nxr==n+1||nxr==n+2)nxcost=s.cost;\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc]&&A[nxr][nxc][nxj]>nxcost){A[nxr][nxc][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  return -1;\n}\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(n==0&&m==0)break;\n    vector< vector<int> > T(n+3);T[n+1].push_back(0);T[n+2].push_back(0);\n    int D[N][COL]={{0,},};\n    for(int i=0;i<n;++i){int k;cin>>k;for(int j=0;j<k;++j){int col,danger;cin>>col>>danger;T[i+1].push_back(col);D[i+1][col]=danger;}}\n    cout<<dijkstra(n,m,D,T)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  /*\n\t  for(k=0;k<100;k++){\n\t    \n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t\t\t\t       \n\t  }\n\t  \n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int n, m;\n  while(cin>>n>>m && n){\n    static int dp[151][11][80] = {};\n    REP(i, 151)REP(j, 11)REP(k, 80) dp[i][j][k] = INF;\n    int k[151], x[150][151], s[151][151];\n    REP(i, n){\n      cin>>k[i];\n      REP(j, k[i]) cin>>x[i][j]>>s[i][j];\n    }\n    REP(i, k[0]) dp[0][i][0] = 0;\n    REP(i, k[1]) dp[1][i][1] = 0;\n    for(int i = 0; i < n - 1; i++){\n      for(int j = 0; j < k[i]; j++){\n        int from_x = x[i][j];\n        for(int l = 0; l < k[i + 1]; l++){\n          int to_x = x[i + 1][l];\n          for(int use = 0; use <= m; use++){\n            dp[i + 1][l][use] = min(dp[i + 1][l][use], dp[i][l][use] + (s[i][j] + s[i + 1][l]) * abs(from_x - to_x));\n          }\n        }\n        if(i + 2 < n){\n          for(int l = 0; l < k[i + 2]; l++){\n            int to_x = x[i + 2][l];\n            for(int use = 0; use < m; use++){\n              dp[i + 2][l][use + 1] = min(dp[i + 2][l][use + 1], dp[i][j][use] + (s[i][j] + s[i + 2][l]) * abs(from_x - to_x));\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(i, k[n - 1])REP(j, m + 1) ans = min(ans, dp[n-1][i][j]);\n    REP(i, k[n - 2])REP(j, m ) ans = min(ans, dp[n-2][i][j]);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint z(int x){\n\tif(x<0)return -x;\n\treturn x;\n}\n\nint main(){\nwhile(1){\n\tconst int INF=2100000000;\n\tint n,m,k;\n\tstatic int a[1002],b[152][1002],dp[152][1002][102];\n\tfor(int i=0;i<152;i++)for(int j=0;j<1002;j++)for(k=0;k<102;k++)dp[i][j][k]=INF;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=0;j<k;j++){\n\t\t\tscanf(\"%d\",&a[j]);\n\t\t\tscanf(\"%d\",&b[i][a[j]]);\n\t\t\tfor(int c=0;c<=m;c++){\n\t\t\t\tif(i==1)dp[i][a[j]][c]=0;\n\t\t\t\telse {\n\t\t\t\t\tfor(int l=0;l<1002;l++){\n\t\t\t\t\t\tif(dp[i-1][l][c]!=INF){\n\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-1][l][c]+z(l-a[j])*(b[i][a[j]]+b[i-1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c!=0){\n\t\t\t\t\t\t\tif(dp[i-2][l][c-1]!=INF){\n\t\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-2][l][c-1]+z(l-a[j])*(b[i][a[j]]+b[i-2][l]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=INF;\n\tfor(int i=0;i<1002;i++)for(int j=0;j<=m;j++)ret=min(ret,dp[n][i][j]);\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int, int> P;\nint n, m;\nint dp[80][200][20], kosu[1600];\nP stone[1600][20];\nint main()\n{\n\twhile(cin >> n >> m && n)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", kosu + i);\n\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\", &stone[i][j].F, &stone[i][j].S);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= m; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tfor(int k = 0; k < kosu[j]; k++)\n\t\t\t\t\tdp[i][j][k] = 1 << 30;\n\t\t\t\tfor(int i = 0; i < kosu[0]; i++)\n\t\t\t\t\tdp[0][0][i] <<= 2;\n\t\t\t\tfor(int i = 0; i < kosu[1]; i++)\n\t\t\t\t\tdp[1][1][i] <<= 2;\n\t\t\t\tfor(int i = 0; i < n - 1; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 1]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int l = 0; l <= m; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(dp[l][i][j] < 1 << 30)\n\t\t\t\t\t\t\t\t\tdp[l][i + 1][k] = min((stone[i + 1][k].S + stone[i][j].S) * abs(stone[i + 1][k].F - stone[i][j].F) + dp[l][i][j], dp[l][i + 1][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i + 2 < n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 2]; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor(int l = 0; l < m; l++)\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tif(dp[l][i][j] < 1 << 30)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[l + 1][i + 2][k] = min((stone[i + 2][k].S + stone[i][j].S) * abs(stone[i + 2][k].F - stone[i][j].F) + dp[l][i][j], dp[l + 1][i + 2][k]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tfor(int i = 0; i <= m; i++)\n\t\t\t\t\tfor(int j = 0; j < kosu[n - 1]; j++)\n\t\t\t\t\t\tans = min(ans, dp[i][n - 1][j]);\n\t\t\t\t\tfor(int i = 0; i < m; i++)\n\t\t\t\t\t\tfor(int j = 0; j < kosu[n - 2]; j++)\n\t\t\t\t\t\t\tans = min(ans, dp[i][n - 2][j]);\n\t\t\t\t\t\tcout << ans << endl;\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77];\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int i = 0; i < 1001; i++)\n\t\t\t\tfill(cur[i],cur[i]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\tif(field[i-1][k]==0&&(i<=1||field[i-2][k]==0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= max(0,m-i); l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=cur;\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,fin[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n){\n        auto dp = make_v(n, m+1, 10, INF<int>);\n        vector<vector<pair<int, int>>> v(n);\n        vector<int> cnt(n);\n        for (int i = 0; i < n; ++i) {\n            int k;\n            cin >> k;\n            for (int j = 0; j < k; ++j) {\n                int x, d;\n                cin >> x >> d;\n                v[i].emplace_back(x, d);\n                if(i == 0){\n                    dp[i][0][j] = 0;\n                }else if(i == 1 && m){\n                    dp[i][1][j] = 0;\n                }\n            }\n        }\n        for (int i = 0; i < n-1; ++i) {\n            for (int j = 0; j <= m; ++j) {\n                for (int k = 0; k < v[i].size(); ++k) {\n                    for (int l = 0; l < v[i+1].size(); ++l) {\n                        chmin(dp[i+1][j][l], dp[i][j][k]+(v[i][k].second+v[i+1][l].second)\n                                                         *abs(v[i][k].first-v[i+1][l].first));\n                    }\n                }\n                if(i != n-2 && j != m){\n                    for (int k = 0; k < v[i].size(); ++k) {\n                        for (int l = 0; l < v[i+2].size(); ++l) {\n                            chmin(dp[i+2][j+1][l], dp[i][j][k]+(v[i][k].second+v[i+2][l].second)\n                                                               *abs(v[i][k].first-v[i+2][l].first));\n                        }\n                    }\n                }\n            }\n        }\n        int ans = INF<int>;\n        for (int j = 0; j <= m; ++j) {\n            for (int k = 0; k < v[n-1].size(); ++k) {\n                chmin(ans, dp[n-1][j][k]);\n            }\n        }\n        for (int j = 0; j < m; ++j) {\n            for (int k = 0; k < v[n-2].size(); ++k) {\n                chmin(ans, dp[n-2][j][k]);\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint main(){\n  while(true){\n    int n = getInt();\n    int m = getInt();\n\n    if(n + m == 0) break;\n\n    vector<map<int, int> > v(n);\n\n    REP(i,n){\n      const int k = getInt();\n      REP(j,k){\n        const int x = getInt();\n        const int d = getInt();\n        v[i][x] = d;\n      }\n    }\n\n    vector<vector<map<int, int> > >\n      dp(n, vector<map<int, int> >(m + 1));\n\n    FOR(it, v[0]){\n      dp[0][m][it->first] = 0;\n    }\n\n    if(m > 0){\n      FOR(it, v[1]){\n        dp[1][m - 1][it->first] = 0;\n      }\n    }\n\n    REP(i, n - 1) REP(j, m + 1) FOR(it1, dp[i][j]){\n      // printf(\"(%d, %d) %d => %d\\n\", it1->first, i, j, it1->second);\n\n      FOR(it2, v[i + 1]){\n        const int x1   = it1->first;\n        const int x2   = it2->first;\n        const int cost = (v[i][it1->first] + it2->second) * std::abs(x1 - x2);\n        const int next = it1->second + cost;\n\n        // printf(\" (%d, %d) %d: %d\\n\", x2, i + 1, j, next);\n\n        if(dp[i + 1][j].count(x2))\n          dp[i + 1][j][x2] = min(dp[i + 1][j][x2], next);\n        else\n          dp[i + 1][j][x2] = next;\n      }\n      if(j != 0 && i != n - 2){\n        FOR(it2, v[i + 2]){\n          const int x1   = it1->first;\n          const int x2   = it2->first;\n          const int cost = (v[i][it1->first] + it2->second) * std::abs(x1 - x2);\n          const int next = it1->second + cost;\n\n          // printf(\" (%d, %d) %d: %d\\n\", x2, i + 2, j - 1, next);\n\n          if(dp[i + 2][j - 1].count(x2))\n            dp[i + 2][j - 1][x2] = min(dp[i + 2][j - 1][x2], next);\n          else\n            dp[i + 2][j - 1][x2] = next;\n        }\n      }\n    }\n\n    int ans = INT_MAX;\n\n    REP(j,m + 1)FOR(it,dp[n - 1][j]){\n      ans = min(ans, it->second);\n    }\n    REP(j,m)FOR(it,dp[n - 2][j + 1]){\n      ans = min(ans, it->second);\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tX\tfirst\n#define\tSL\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1000000000;\npii river[150][11];\nint memo[150][10][76];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k;\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint x,slip;\tscanf(\"%d%d\",&x,&slip);\n\t\t\t\triver[i][j]=mp(x,slip);\n\t\t\t}\n\t\t\triver[i][k]=mp(-1,-1);\n\t\t}\n\n\t\tfor(int i=1;i<n;i++)for(int j=0;~river[i][j].X;j++)for(int k=0;k<=m;k++)\n\t\t\tmemo[i][j][k]=inf;\n\n\t\tfor(int j=0;~river[0][j].X;j++)\tmemo[0][j][0]=0;\n\t\tfor(int j=0;~river[1][j].X;j++)\tmemo[1][j][1]=0;\n\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;~river[i][j].X;j++){\n\t\t\t\tfor(int k=0;k<=m;k++)\tmemo[i][j][k]=inf;\n\t\t\t\tint cost;\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tfor(int b=0;~river[i-1][b].X;b++){\n\t\t\t\t\t\tif(river[i-1][b].X==inf)\tcontinue;\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-1][b].SL)*abs(river[i][j].X-river[i-1][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-1][b][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=1;k<=m;k++){\n\t\t\t\t\tif(i-2<0)\tcontinue;\n\t\t\t\t\tfor(int b=0;~river[i-2][b].X;b++){\n\t\t\t\t\t\tif(river[i-2][b].X==inf)\tcontinue;\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-2][b].SL)*abs(river[i][j].X-river[i-2][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-2][b][k-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mincost=inf;\n\t\tfor(int j=0;~river[n-1][j].X;j++)for(int k=0;k<=m;k++)\tmincost=min(mincost,memo[n-1][j][k]);\n\t\tfor(int j=0;~river[n-2][j].X;j++)for(int k=0;k<m;k++)\tmincost=min(mincost,memo[n-2][j][k]);\n\t\tprintf(\"%d\\n\",mincost);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\n\nint n, m;\nint dp[150][80][10];\nvector<int> pos[150];\nvector<int> risk[150];\n\nint Abs(int x, int y){\n\tif(x > y) return x-y;\n\telse return y-x;\n}\n\nvoid solve(){\n\tfor(int i = 0; i < 150; i++){\n\t\tpos[i].clear();\n\t\trisk[i].clear();\n\t\tfor(int j = 0; j < 10; j++){\n\t\t\tfor(int k = 0; k < 80; k++){\n\t\t\t\tif(i == 0 && k == 0) dp[i][k][j] = 0;\n\t\t\t\telse if(i == 1 && k == 1) dp[i][k][j] = 0;\n\t\t\t\telse dp[i][k][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint t; scanf(\"%d\", &t);\n\t\tfor(int j = 0; j < t; j++){\n\t\t\tint x, d; scanf(\"%d%d\", &x, &d);\n\t\t\tx--;\n\t\t\tpos[i].push_back(x);\n\t\t\trisk[i].push_back(d);\n\t\t}\n\t}\n\tfor(int i = 0; i < n-1; i++){\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tfor(int k = 0; k < risk[i+1].size(); k++){\n\t\t\t\tfor(int l = 0; l < risk[i].size(); l++){\n\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i][j][l]+(risk[i+1][k]+risk[i][l])*Abs(pos[i+1][k],pos[i][l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(i != n-2){\n\t\t\tfor(int j = 0; j <= m-1; j++){\n\t\t\t\tfor(int k = 0; k < risk[i+2].size(); k++){\n\t\t\t\t\tfor(int l = 0; l < risk[i].size(); l++){\n\t\t\t\t\t\tdp[i+2][j+1][k] = min(dp[i+2][j+1][k],dp[i][j][l]+(risk[i+2][k]+risk[i][l])*Abs(pos[i+2][k],pos[i][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int i = 0; i <= m; i++){\n\t\tfor(int j = 0; j < risk[n-1].size(); j++){\n\t\t\tans = min(dp[n-1][i][j],ans);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < risk[n-2].size(); j++){\n\t\t\tans = min(dp[n-2][i][j],ans);\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tfor(int k = 0; k < risk[i].size(); k++){\n\t\t\t\tprintf(\"%d \", dp[i][j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m),n||m) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (int)(1e9)\n\nint mb[10];\nint ms[10];\nint m[10][100];\nint mk;\nint mmb[10];\nint mms[10];\nint mm[10][100];\nint mmk;\nint n[10][100];\n\nvector<pair<int,int> > isi[150];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint nn,mn;\n\t\tscanf(\"%d %d\",&nn,&mn);\n\t\tif(nn == 0 && mn == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(int ii = 0; ii < k; ii++)\n\t\t\t{\n\t\t\t\tint x,d;\n\t\t\t\tscanf(\"%d %d\",&x,&d);\n\t\t\t\tisi[i].push_back(make_pair(x,d));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < isi[0].size(); i++)\n\t\t{\n\t\t\tmb[i] = isi[0][i].first;\n\t\t\tms[i] = 0;\n\t\t\tmmb[i] = isi[0][i].first;\n\t\t\tmms[i] = 0;\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tm[i][ii] = 0;\n\t\t\t\tmm[i][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tmk = isi[0].size();\n\t\tmmk = isi[0].size();\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tif(i == 1)\n\t\t\t{\n\t\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t\t{\n\t\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmm[ii][iii] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tmmb[ii] = isi[i][ii].first;\n\t\t\t\t\tmms[ii] = isi[i][ii].second;\n\t\t\t\t}\n\t\t\t\tmmk = isi[i].size();\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn[ii][iii] = min;\n\t\t\t\t}\n\t\t\t\tfor(int iii = 0; iii < mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mmk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n[ii][iii + 1] > min)\n\t\t\t\t\t{\n\t\t\t\t\t\tn[ii][iii + 1] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < mk; ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tmm[ii][iii] = m[ii][iii];\n\t\t\t\t}\n\t\t\t\tmmb[ii] = mb[ii];\n\t\t\t\tmms[ii] = ms[ii];\n\t\t\t}\n\t\t\tmmk = mk;\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tm[ii][iii] = n[ii][iii];\n\t\t\t\t}\n\t\t\t\tmb[ii] = isi[i][ii].first;\n\t\t\t\tms[ii] = isi[i][ii].second;\n\t\t\t}\n\t\t\tmk = isi[i].size();\n\t\t}\n\t\tint allmin = INF;\n\t\tfor(int i = 0; i < mmk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > mm[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = mm[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < mk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > m[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = m[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",allmin);\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tisi[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main() {\n\tint n,m;\n\tint k[150]={};\n\tint x[150][10]={};\n\tint s[150][10]={};\n\tint mr[150][10][76]={};\n\tint r,ar;\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0){return 0;}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> k[i];\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tcin >> x[i][j] >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<k[n-1];i++){\n\t\t\tmr[n-1][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<k[n-2];i++){\n\t\t\tmr[n-2][i][0]=0;\n\t\t}\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tfor(int am=0;am<=(n-i)/2 && am<=m && !(i==n-2 && am==1);am++){\n\t\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\t\tmr[i][j][am]=mr[i+1][0][am]+(s[i][j]+s[i+1][0])*abs(x[i][j]-x[i+1][0]);\n\t\t\t\t\tfor(int l=1;l<k[i+1];l++){\n\t\t\t\t\t\tr=mr[i+1][l][am]+(s[i][j]+s[i+1][l])*abs(x[i][j]-x[i+1][l]);\n\t\t\t\t\t\tif(r<mr[i][j][am]){\n\t\t\t\t\t\t\tmr[i][j][am]=r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(am>0){\n\t\t\t\t\t\tfor(int l=0;l<k[i+2];l++){\n\t\t\t\t\t\t\tr=mr[i+2][l][am-1]+(s[i][j]+s[i+2][l])*abs(x[i][j]-x[i+2][l]);\n\t\t\t\t\t\t\tif(r<mr[i][j][am]){\n\t\t\t\t\t\t\t\tmr[i][j][am]=r;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" am:\" <<am << \" mr:\" << mr[i][j][am] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mar=mr[0][0][m];\n\t\tfor(int i=1;i<k[0];i++){\n\t\t\tar=mr[0][i][m];\n\t\t\tif(ar < mar){\n\t\t\t\tmar=ar;\n\t\t\t}\n\t\t}\n\t\tif(m>1){\n\t\t\tfor(int i=0;i<k[1];i++){\n\t\t\t\tar=mr[1][i][m-1];\n\t\t\t\tif(ar < mar){\n\t\t\t\t\tmar=ar;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mar << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define INF (1 << 25)\nusing namespace std;\n\nint main(){\n  int n, m, tmp;\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    int dp[3][10][100];\n    memset(dp, 0, sizeof(dp));\n    vector< pair<int, int> >stones[n];\n    for(int i = 0;i < n;i++){\n      int k, l, m;\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;j++){\n\tscanf(\"%d %d\", &l, &m);\n\tstones[i].push_back(make_pair(l, m));\n      }\n    }\n    for(int i = 0;i < n;i++){\n      int ind = i%3, prev = (i - 1) % 3, prepre = (i - 2) % 3;\n\n      for(int j = 0;j < stones[i].size();j++)\n\tfor(int k = 0;k <= m;k++)\n\t  dp[ind][j][k] = INF;\n\n      for(int j = 0;j < stones[i].size();j++){\n\tif(i == 0)dp[ind][j][m] = 0;\n\telse if(i == 1 && m - 1 >= 0)dp[ind][j][m - 1] = 0;\n      }\n      for(int j = 0;j < stones[i].size();j++){\n\tfor(int k = 0;k <= m;k++){\n\t  for(int l = 0;i > 0 && l < stones[i - 1].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prev][l][k] + abs(stones[i - 1][l].first - stones[i][j].first) * (stones[i - 1][l].second + stones[i][j].second));\n\t  }\n\t  for(int l = 0;i > 1 && k < m && l < stones[i - 2].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prepre][l][k + 1] + abs(stones[i - 2][l].first - stones[i][j].first) * (stones[i - 2][l].second + stones[i][j].second));\n\t  }\n\t}\n      }\n    }\n    int res = INF;\n    for(int i = 0;i < stones[n - 1].size();i++){\n      for(int j = 0;j <= m;j++){\n\tres = min(res, dp[(n - 1) % 3][i][j]);\n      }\n    }\n    if(n - 2 >= 0){\n      for(int i = 0;i < stones[n - 2].size();i++){\n\tfor(int j = 1;j <= m;j++){\n\t  res = min(res,dp[(n - 2) % 3][i][j]);\n\t}\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1005;\nunsigned int dp[6][MAX_X][80];\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n >> m && n)\n\t{\n\t\trep(x,MAX_X) rep(y,6) rep(d,m+1) dp[y%6][x][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\trep(i,MAX_X)rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tr[x][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[0][x][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[1][x][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++)\n\t\t{\n\t\tmemcpy(dp[y%5], dp[5], sizeof(dp[y%5]));\n\t\tfor(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\t\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ツ津環湘ュツジツδδδ督プ\n\t\t\t\trep(nx, MAX_X) rep(d, m+1)\n\t\t\t\t\tif(dp[(y-1)%5][nx][d] != INF)\n\t\t\t\t\t\tchmin(dp[y%5][x][d], dp[(y-1)%5][nx][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// ツ暗ェツ段ツづづ篠つオ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[(y-2)%5][nx][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[y%5][x][d-1], dp[(y-2)%5][nx][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\t\t}\n\t\tunsigned int res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[(n-1)%5][x][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[(n-2)%5][x][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define SQR(a) ((a)*(a))\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pr;\ntypedef pair<pr,ll> ppr;\ntypedef vector<pr> vpr;\nconst int INF=1<<30;\nint DP[152][152][11];\nint main() {\n\tint n,m,times,tmp;\n\twhile(cin >> n >> m && n){\n\tint block[152][11]={};\n\tREP(i,152)\n\t\tREP(j,152)\n\t\t\tREP(k,11)\n\t\t\t\tDP[i][j][k]=INF;\n\tREP(i,n){\n\t\tcin >> times;\n\t\tREP(j,times){\n\t\tcin >> tmp;\n\t\tcin >> block[i][tmp-1];\n\t\t}\n\t}\n\tREP(i,11){\n\tDP[0][0][i]=0;\n\tDP[1][1][i]=0;\n\tblock[n][i]=1;\n\t}\n\tFOR(i,1,n+1)\n\t\tREP(j,11)\n\t\t\tif(block[i][j])\n\t\t\tREP(l,m+1)\n\t\t\t\tREP(k,11){\n\t\t\t\t\tif(block[i-1][k])\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-1][l][k]+abs(j-k)*(block[i-1][k]+block[i][j]));\n\t\t\t\t\tif(block[i-2][k] && l && i!=1)\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-2][l-1][k]+abs(j-k)*(block[i-2][k]+block[i][j]));\n\t\t\t\t}\n\tint minium=INF;\n\tREP(i,11)\n\t\tREP(j,m+1)\n\t\t\tminium=min(minium,DP[n][j][i]);\n\tcout << minium << endl;\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<climits>\nusing namespace std;\nstatic const int MAX_N = 150;\nstatic const int MAX_M = (MAX_N + 1) / 2;\nstatic const int MAX_K = 10;\n\nint n, m;\nint k[MAX_N], x[MAX_N][MAX_K], d[MAX_N][MAX_K];\nint memo[MAX_N][MAX_K][MAX_M + 1];\n\nint abs(int a){\n\tif(a < 0) return -a;\n\telse return a;\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &k[i]);\n\t\t\tfor(int j = 0; j < k[i]; j++) scanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t}\n\t\tfill(memo[0][0], memo[n][0], INT_MAX);\n\t\tfor(int i1 = 0; i1 < n - 1; i1++){\n\t\t\tfor(int i2 = 0; i2 <= m; i2++){\n\t\t\t\tfor(int i3 = 0; i3 < k[i1]; i3++){\n\t\t\t\t\tif(i1 == 0) memo[i1][i3][i2] = 0;\n\t\t\t\t\tfor(int i4 = 0; i4 < k[i1 + 1]; i4++){\n\t\t\t\t\t\tmemo[i1 + 1][i4][i2] = min(memo[i1 + 1][i4][i2], memo[i1][i3][i2] + (d[i1][i3] + d[i1 + 1][i4]) * abs(x[i1][i3] - x[i1 + 1][i4]));\n\t\t\t\t\t}\n\t\t\t\t\tif(i2 == m) continue;\n\t\t\t\t\tif(i1 == n - 2) continue;\n\t\t\t\t\tfor(int i4 = 0; i4 < k[i1 + 2]; i4++){\n\t\t\t\t\t\tmemo[i1 + 2][i4][i2 + 1] = min(memo[i1 + 2][i4][i2 + 1], memo[i1][i3][i2] + (d[i1][i3] + d[i1 + 2][i4]) * abs(x[i1][i3] - x[i1 + 2][i4]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INT_MAX;\n\t\tfor(int i1 = 0; i1 < k[n - 1]; i1++){\n\t\t\tfor(int i2 = 0; i2 <= m; i2++){\n\t\t\t\tres = min(res, memo[n - 1][i1][i2]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    /*\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n    */\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint dp[150][80][10]={};\nint main() {\nwhile(1){\n\tint n=0,m=0;\n\tcin >> n >> m;\n\tvector<int> pos[150];\n\tvector<int> slip[150];\n\tif(n==0&&m==0)return 0;\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\n\t\t\tcin >> x >> d;\n\t\t\tpos[i].push_back(x);\n\t\t\tslip[i].push_back(d);\n\t\t\tfor(int u=0;u<=m;u++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tdp[i][u][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==1&&u>0){\n\t\t\t\t\tdp[i][u][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][u][j]=1<<30;\n\t\t\t\tfor(int r=0;r<pos[i-1].size();r++){\n\t\t\t\t\tint v=dp[i-1][u][r]+abs(pos[i-1][r]-x)*(slip[i-1][r]+d);\n\t\t\t\t\tdp[i][u][j]=min(dp[i][u][j],v);\n\t\t\t\t}\n\t\t\t\tif(u==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int r=0;r<pos[i-2].size();r++){\n\t\t\t\t\tint v=dp[i-2][u-1][r]+abs(pos[i-2][r]-x)*(slip[i-2][r]+d);\n\t\t\t\t\tdp[i][u][j]=min(dp[i][u][j],v);\n\t\t\t\t}\n\t\t\t\t//cout << i << \", \" << u << \", \" << j << \": \" << dp[i][u][j] << endl;\n\t\t\t\t//cout << pos[i].size() << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ret=1<<30;\n\tfor(int i=0;i<pos[n-1].size();i++){\n\t\tret=min(ret,dp[n-1][m][i]);\n\t}\n\tif(m>0){\n\t\tfor(int i=0;i<pos[n-2].size();i++){\n\t\t\tret=min(ret,dp[n-2][m-1][i]);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<60LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans=INF;\nLL V[160][15];\nLL K[160][15];\nLL mem[160][15][80][3];\n\n\nLL cal(int y,int x,int m,int f){\n    LL res=INF;\n    if(mem[y][x][m][f]!=-1){\n        return mem[y][x][m][f];\n    }\n    if(y==N-1&&f==2)return 0;\n    else if(y==N&&f==1)return 0;\n    rep(i,10){\n        LL d1,d2;\n        if(m>0&&K[y+1][i]&&K[y+2][i]&&y+2<=N){\n            d1=(K[y][x]+K[y+1][i])*abs(V[y][x]-V[y+1][i]);\n            d2=(K[y][x]+K[y+2][i])*abs(V[y][x]-V[y+2][i]);\n            res=min(cal(y+1,i,m,f)+d1,min(cal(y+2,i,m-1,f)+d2,res));\n        }\n        else if(K[y+1][i]){\n            d1=(K[y][x]+K[y+1][i])*abs(V[y][x]-V[y+1][i]);\n            res=min(cal(y+1,i,m,f)+d1,res);\n        }\n        else if(K[y+2][i]&&m>0&&y+2<=N){\n            d2=(K[y][x]+K[y+2][i])*abs(V[y][x]-V[y+2][i]);\n            res=min(cal(y+2,i,m-1,f)+d2,res);\n        }\n    }\n    return mem[y][x][m][f]=res;\n}\n\n\nint main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(mem,-1,sizeof(mem));\n        memset(V,0,sizeof(V));\n        memset(K,0,sizeof(K));\n        FOR(i,1,N){\n            LL t;\n            cin>>t;\n            rep(j,t){\n                LL x,k;\n                cin>>x>>k;\n                V[i][j]=x;\n                K[i][j]=k;\n            }\n        }\n        rep(j,10){\n            if(K[1][j]&&K[2][j]&&M>0){\n                ans=min(cal(1,j,M,1),min(cal(2,j,M-1,2),ans));\n            }\n            else if(K[1][j]){\n                ans=min(cal(1,j,M,1),ans);\n            }\n            else if(M>0)ans=min(cal(2,j,M-1,2),ans);\n        }\n        cout<<ans<<endl;\n        ans=INF;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (int)(1e9)\n\nint mb[10];\nint ms[10];\nint m[10][100];\nint mk;\nint mmb[10];\nint mms[10];\nint mm[10][100];\nint mmk;\nint n[10][100];\n\nvector<pair<int,int> > isi[150];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint nn,mn;\n\t\tscanf(\"%d %d\",&nn,&mn);\n\t\tif(nn == 0 && mn == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(int ii = 0; ii < k; ii++)\n\t\t\t{\n\t\t\t\tint x,d;\n\t\t\t\tscanf(\"%d %d\",&x,&d);\n\t\t\t\tisi[i].push_back(make_pair(x,d));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < isi[0].size(); i++)\n\t\t{\n\t\t\tmb[i] = isi[0][i].first;\n\t\t\tms[i] = 0;\n\t\t\tmmb[i] = isi[0][i].first;\n\t\t\tmms[i] = 0;\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tm[i][ii] = 0;\n\t\t\t\tmm[i][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tmk = isi[0].size();\n\t\tmmk = isi[0].size();\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tif(i == 1)\n\t\t\t{\n\t\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t\t{\n\t\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmm[ii][iii] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tmmb[ii] = isi[i][ii].first;\n\t\t\t\t\tmms[ii] = isi[i][ii].second;\n\t\t\t\t}\n\t\t\t\tmmk = isi[i].size();\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn[ii][iii] = min;\n\t\t\t\t}\n\t\t\t\tfor(int iii = 0; iii < mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n[ii][iii + 1] > min)\n\t\t\t\t\t{\n\t\t\t\t\t\tn[ii][iii + 1] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < mk; ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tmm[ii][iii] = m[ii][iii];\n\t\t\t\t}\n\t\t\t\tmmb[ii] = mb[ii];\n\t\t\t\tmms[ii] = ms[ii];\n\t\t\t}\n\t\t\tmmk = mk;\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tm[ii][iii] = n[ii][iii];\n\t\t\t\t}\n\t\t\t\tmb[ii] = isi[i][ii].first;\n\t\t\t\tms[ii] = isi[i][ii].second;\n\t\t\t}\n\t\t\tmk = isi[i].size();\n\t\t}\n\t\tint allmin = INF;\n\t\tfor(int i = 0; i < mmk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > mm[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = mm[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < mk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > m[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = m[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",allmin);\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tisi[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nll n;\nstruct P {\n\tll slip, place;\n};\nP a[152][10];\nll dp[152][10][1000];\nll siz[152];\nll solve(ll i, ll j,ll m) {\n\tif (i == n) return 0;\n\tll sum = 80000000000000000;\n\tfor (ll z = 0; z < siz[i+1]; z++) {\n\t\tll res = (a[i + 1][z].place - a[i][j].place);\n\t\tres = max(res, 0 - res);\n\t\tres *= (a[i + 1][z].slip + a[i][j].slip);\n\t\tif (dp[i + 1][z][m] != -1) {\n\t\t\tsum = min(sum, res + dp[i + 1][z][m]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + 1][z][m] = solve(i + 1, z, m)));\n\t\t}\n\t}\n\tif (m > 0&&i+1!=n) {\n\t\tfor (ll z = 0; z < siz[i+2]; z++) {\n\t\t\tll res = (a[i + 2][z].place - a[i][j].place);\n\t\t\tres = max(res, 0 - res);\n\t\t\tres *= (a[i + 2][z].slip + a[i][j].slip);\n\t\t\tif (dp[i + 2][z][m-1] != -1) {\n\t\t\t\tsum = min(sum, res + dp[i + 2][z][m-1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = min(sum, res + (dp[i + 2][z][m-1] = solve(i + 2, z, m-1)));\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tll m;\n\twhile (cin >> n >> m&&(n!=0||m!=0)) {\n\t\tfor (ll i = 1; i <= n; i++) {\n\t\t\tll k;\n\t\t\tcin >> k;\n\t\t\tsiz[i] = k;\n\t\t\tfor (ll j = 0; j < k; j++) {\n\t\t\t\tcin >> a[i][j].place >> a[i][j].slip;\n\t\t\t\tfor (ll z = 0; z <= m; z++)\n\t\t\t\t\tdp[i][j][z] = -1;\n\t\t\t}\n\t\t}\n\t\tll sum = 80000000000000;\n\t\tfor (ll i = 0; i < siz[1]; i++) {\n\t\t\tsum = min(sum, solve(1, i, m));\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//  Pyon-Pyon River Crossing.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int X = 1005;\nconst int Y = 155;\nconst int MM = 80;\nconst int INF = 1 << 30;\n\nint N, M;\nint dp[Y][X][MM];\n\nint main()\n{\n\tfor(; cin >> N >> M && (N || M); )\n\t{\n\t\tmemset(dp, -1, sizeof dp);\n\t\trep(i, Y) rep(j, X) rep(k, MM) dp[i][j][k] = (i == 0 ? 0 : INF);\n\t\t\n\t\tvector<vector<pint> > river;\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\triver.push_back(vector<pint>(k));\n\t\t\t\n\t\t\trep(i, k) cin >> river[y][i].first >> river[y][i].second;\n\t\t}\n\t\t\n\t\triver.push_back(vector<pint>(X));\n\t\trep(i, X) river[N][i] = mp(i, 0);\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\trep(i, river[y].size())\n\t\t\t{\n\t\t\t\trep(m, M+1)\n\t\t\t\t{\n\t\t\t\t\trep(j, river[y+1].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+1][j].second + river[y][i].second) * abs(river[y+1][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[y+1][river[y+1][j].first][m], dp[y][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(m > 0) rep(j, river[y+2].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+2][j].second + river[y][i].second) * abs(river[y+2][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[y+2][river[y+2][j].first][m-1], dp[y][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\trep(x, X) rep(m, MM) chmin(ans, dp[N][x][m]);\n\n\t\tcout << ans << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n \nconst int INF = 1<<29;\n \nint dp[256][16][128];\nint stones[256][16][2];\nint col[256];\n \nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n   \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tcin >> stones[i][j][0] >> stones[i][j][1];\n      }\n    }\n \n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i+1]) {\n\tint x_now = stones[i+1][j][0], d_now = stones[i+1][j][1];\n\tREP(k, col[i]) {\n\t  int x_prev = stones[i][k][0], d_prev = stones[i][k][1];\n\t  int safe = (d_now + d_prev) * abs(x_now - x_prev);\n\t  REP(m, M+1) {\n\t    dp[i+1][j][m] = min(dp[i+1][j][m], dp[i][k][m] + safe);\n\t  }\n\t}\n\tif (i > 0) {\n\t  REP(k, col[i-1]) {\n\t    int x_prev = stones[i-1][k][0], d_prev = stones[i-1][k][1];\n\t    int safe = (d_now + d_prev) * abs(x_now - x_prev);\n\t    REP(m, M) {\n\t      dp[i+1][j][m+1] = min(dp[i+1][j][m+1], dp[i-1][k][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n \n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint a,b;\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n      for(int j=0;j<80;j++){\n\tdp[0][i][j]=dp[1][i][j]=0;\n\tif(j<m)dp[2][i][j]=0;\n      }    \n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int k=0;k<v[i-1].size();k++){\n\t  for(int l=m;l>=0;l--){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t    if(l<m){\n\t      for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)\n      for(int j=0;j<=m;j++)\n      ans=min(ans,dp[n][i][j]);\n\n    for(int i=0;i<v[n-1].size();i++)\n      for(int j=1;j<=m;j++)\n\tans=min(ans,dp[n-1][i][j]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint dp[151][1001][76];\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tvector<P>E[151];\n\t\trep(i, n) {\n\t\t\tint k; scanf(\"%d\", &k);\n\t\t\trep(t, k) {\n\t\t\t\tint x, d; scanf(\"%d%d\", &x, &d);\n\t\t\t\tE[i].push_back(P(d, --x));\n\t\t\t}\n\t\t}\n\t\tfor (P i : E[0])dp[0][i.second][0] = 0;\n\t\tfor (P i : E[1])dp[1][i.second][1] = 0;\n\t\trep(i, n - 1) {\n\t\t\tfor (P j : E[i]) {\n\t\t\t\tfor (int t = 0; t <= m; t++) {\n\t\t\t\t\tif (dp[i][j.second][t] == INF)continue;\n\t\t\t\t\tfor (P k : E[i + 1])dp[i + 1][k.second][t] =\n\t\t\t\t\t\tmin(dp[i + 1][k.second][t], dp[i][j.second][t] + (j.first + k.first)*abs(j.second - k.second));\n\t\t\t\t\tif (i<n - 2) {\n\t\t\t\t\t\tfor (P k : E[i + 2])dp[i + 2][k.second][t + 1] =\n\t\t\t\t\t\t\tmin(dp[i + 2][k.second][t + 1], dp[i][j.second][t] + (j.first + k.first)*abs(j.second - k.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\tfor (P i : E[n - 1]) {\n\t\t\tfor (int j = 0; j <= m; j++)Min = min(Min, dp[n - 1][i.second][j]);\n\t\t}\n\t\tfor (P i : E[n - 2]) {\n\t\t\tfor (int j = 0; j<m; j++)Min = min(Min, dp[n - 2][i.second][j]);\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i__=0;__i__<n;__i__++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\nusing namespace std;\n\nlong COST_LIMIT = 1000 * 1000 * 150;\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n, m; cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    // memory alloc and init\n    long cost_table[3][10][m + 1];\n    int pos[3][10];\n    int slip[3][10];\n    int stones[3];\n    // fill(pos[0], pos[2] + 10, -1);\n    // fill(slip[0], slip[2] + 10, -1);\n    // fill(stones, stones + 3, -1);\n\n    // per row operation\n    loop(n, row_i) {\n      int pp = (row_i + 1) % 3, p = (row_i + 2) % 3, crr = row_i % 3;\n      cin >> stones[crr];\n\n      // read stone info\n      loop(stones[crr], i) {\n        cin >> pos[crr][i] >> slip[crr][i];\n      }\n\n      // set initial value\n      fill(cost_table[crr][0], cost_table[crr][9] + m + 1, COST_LIMIT);\n      if (row_i == 0) {\n        loop(stones[crr], i) cost_table[crr][i][m] = 0;\n      }\n      if (row_i == 1 && m > 0) {\n        loop(stones[crr], i) cost_table[crr][i][m - 1] = 0;\n      }\n\n      // normal jump\n      if (row_i >= 1) {\n        loop(stones[crr], c_i) {\n          loop(m + 1, m_i) {\n            long min_cost = COST_LIMIT;\n            loop(stones[p], p_i) {\n              int jump_cost = (slip[p][p_i] + slip[crr][c_i]) * abs(pos[p][p_i] - pos[crr][c_i]);\n              long cost = cost_table[p][p_i][m_i] + jump_cost;\n              assign_if_smaller(min_cost, cost);\n            }\n            assign_if_smaller(cost_table[crr][c_i][m_i], min_cost);\n          }\n        }\n      }\n\n      // big jump\n      if (row_i >= 2) {\n        loop(stones[crr], c_i) {\n          loop_from_to(1, m, m_i) {\n            long min_cost = COST_LIMIT;\n            loop(stones[pp], pp_i) {\n              int jump_cost = (slip[pp][pp_i] + slip[crr][c_i]) * abs(pos[pp][pp_i] - pos[crr][c_i]);\n              long cost = cost_table[pp][pp_i][m_i] + jump_cost;\n              assign_if_smaller(min_cost, cost);\n            }\n            assign_if_smaller(cost_table[crr][c_i][m_i - 1], min_cost);\n          }\n        }\n      }\n\n      // // show\n      // loop(stones[crr], c_i) loop(m + 1, m_i) \n      //   cout << \"row: \" << row_i << \", col: \" << c_i << \", m:\" << m_i << \", cost: \" << cost_table[crr][c_i][m_i] << endl;\n    }\n\n    long min_cost = COST_LIMIT;\n    loop_from_to(0, !!m, d) {\n      loop(stones[(n - 1 - d) % 3], i) {\n        loop_from_to(d, m, j) {\n          assign_if_smaller(min_cost, cost_table[(n - 1 - d) % 3][i][j]);\n        }\n      }\n    }\n\n    cout << min_cost << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint k[160];\npair<int,int> stone[160][15];\n\nint memo[100][160][15];\n\nint main(){\n  int n,m;\n  while((n = getInt()) + (m = getInt())){\n    REP(i,n){\n      k[i] = getInt();\n      REP(j,k[i]){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    memset(memo,-1,sizeof(memo));\n\n    typedef pair<int,pair<int,pair<int,int> > > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    REP(i,k[0])\n      pq.push(mp(0,mp(m,mp(i,0))));\n    REP(i,k[1])\n      pq.push(mp(0,mp(m-1,mp(i,1))));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n\n      int cost = d.f;\n      int jump = d.s.f;\n      int t    = d.s.s.f;\n      int y    = d.s.s.s;\n      int x    = stone[y][t].f;\n\n      if(y == n){\n        printf(\"%d\\n\",cost);\n        break;\n      }\n\n      if(memo[jump][y][t] != -1) continue;\n      memo[jump][y][t] = cost;\n\n      if(y < n-1){\n        int d = stone[y][t].s;\n        REP(i,k[y+1]){\n          if(memo[jump][y+1][i] != -1) continue;\n          int xx = stone[y+1][i].f;\n          int dd = stone[y+1][i].s;\n#define ABS(a) ((a) < 0 ? -(a) : (a))\n          int cc = cost + (dd + d) * ABS(xx - x);\n          pq.push(mp(cc,mp(jump,mp(i,y+1))));\n        }\n      }else{\n        pq.push(mp(cost,mp(jump,mp(0,n))));\n      }\n\n      if(jump > 0){\n        if(y < n-2){\n          int d = stone[y][t].s;\n          REP(i,k[y+1]){\n            if(memo[jump-1][y+2][i] != -1) continue;\n            int xx = stone[y+2][i].f;\n            int dd = stone[y+2][i].s;\n            int cc = cost + (dd + d) * ABS(xx - x);\n            pq.push(mp(cc,mp(jump-1,mp(i,y+2))));\n          }\n        }else{\n          pq.push(mp(cost,mp(jump-1,mp(0,n))));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define INF INT_MAX\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>c[152][78];\n\t\tint d;\n\t\tcin >> d;\n\t\tfor (int e = 0; e < d; e++) {\n\t\t\tisi h; h.mincost = 0;\n\t\t\tscanf(\"%lld%lld\", &h.zahyou, &h.suberi);\n\t\t\tc[0][b].push_back(h);\n\t\t}\n\t\tfor (int f = 1; f < a; f++) {\n\t\t\tint g; cin >> g;\n\t\t\tfor (int h = 0; h < g; h++) {\n\t\t\t\tint i, j; scanf(\"%lld%lld\", &i, &j);\n\t\t\t\tif (f == 1&&b) {\n\t\t\t\t\tisi o; o.zahyou = i; o.suberi = j; o.mincost = 0;\n\t\t\t\t\tc[1][b - 1].push_back(o);\n\t\t\t\t}\n\t\t\t\tfor (int k = b; k >= 0; k--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int l = 0; l < c[f - 1][k].size(); l++) {\n\t\t\t\t\t\tm = min(m, c[f - 1][k][l].mincost + (c[f - 1][k][l].suberi + j)*abs(c[f - 1][k][l].zahyou - i));\n\t\t\t\t\t}\n\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t}\n\t\t\t\t\tif (k != b&&f > 1) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int l = 0; l < c[f - 2][k+1].size(); l++) {\n\t\t\t\t\t\t\tm = min(m, c[f - 2][k+1][l].mincost + (c[f - 2][k+1][l].suberi + j)*abs(c[f - 2][k+1][l].zahyou - i));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int p = 0; p <= b; p++) {\n\t\t\tfor (isi q : c[a - 1][p]) {\n\t\t\t\tS = min(S, q.mincost);\n\t\t\t}\n\t\t}\n\t\tfor (int p = 1; p <= b; p++) {\n\t\t\tfor (isi q : c[a - 2][p]) {\n\t\t\t\tS = min(S, q.mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nll n;\nstruct P {\n\tll slip, place;\n};\nP a[152][10];\nll dp[152][10][1000];\nll siz[152];\nll solve(ll i, ll j,ll m) {\n\tif (i == n) return 0;\n\tll sum = 80000000000000000;\n\tfor (ll z = 0; z < siz[i+1]; z++) {\n\t\tll res = (a[i + 1][z].place - a[i][j].place);\n\t\tres = max(res, 0 - res);\n\t\tres *= (a[i + 1][z].slip + a[i][j].slip);\n\t\tif (dp[i + 1][z][m] != -1) {\n\t\t\tsum = min(sum, res + dp[i + 1][z][m]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + 1][z][m] = solve(i + 1, z, m)));\n\t\t}\n\t}\n\tif (m > 0&&i+1!=n) {\n\t\tfor (ll z = 0; z < siz[i+2]; z++) {\n\t\t\tll res = (a[i + 2][z].place - a[i][j].place);\n\t\t\tres = max(res, 0 - res);\n\t\t\tres *= (a[i + 2][z].slip + a[i][j].slip);\n\t\t\tif (dp[i + 2][z][m-1] != -1) {\n\t\t\t\tsum = min(sum, res + dp[i + 2][z][m-1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = min(sum, res + (dp[i + 2][z][m-1] = solve(i + 2, z, m-1)));\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tll m;\n\twhile (cin >> n >> m) {\n\t\tfor (ll i = 1; i <= n; i++) {\n\t\t\tll k;\n\t\t\tcin >> k;\n\t\t\tsiz[i] = k;\n\t\t\tfor (ll j = 0; j < k; j++) {\n\t\t\t\tcin >> a[i][j].place >> a[i][j].slip;\n\t\t\t\tfor (ll z = 0; z <= m; z++)\n\t\t\t\t\tdp[i][j][z] = -1;\n\t\t\t}\n\t\t}\n\t\tll sum = 80000000000000;\n\t\tfor (ll i = 0; i < siz[1]; i++) {\n\t\t\tsum = min(sum, solve(1, i, m));\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k[150],x[150][10],d[150][10];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    vector<int> id[150];\n    int num = 0;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k[i]);\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d %d\",&x[i][j],&d[i][j]);\n\tid[i].push_back(num);\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<k[i];j++){\n\tif(i+1<n){\n\t  for(int z=0;z<k[i+1];z++){\n\t    P1 tmp = P1( (d[i][j]+d[i+1][z])*abs(x[i][j]-x[i+1][z]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<k[i+2];z++){\n\t    P1 tmp = P1( (d[i][j]+d[i+2][z])*abs(x[i][j]-x[i+2][z]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = 1<<30;\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    if(m>0)for(int i=0;i<(int)id[1].size();i++)q.push(P2(P1(0,id[1][i]),1));\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n\n    int ans = 1<<30;\n    for(int i=0;i<(int)id[n-1].size();i++)\n      for(int j=0;j<=m;j++)\n\tans = min(ans,g[id[n-1][i]][j]);\n\n    for(int i=0;i<(int)id[n-2].size();i++)\n      for(int j=0;j<m;j++)\n\tans = min(ans,g[id[n-2][i]][j]);\n      \n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <map>\n#include <vector>\n#include <algorithm>\n#define inf INT_MAX/2\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nint dp[155][1000][80];\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        vector<P> riv[n];\n        for (int i=0; i<150; i++) for (int j=0; j<1000; j++) for (int k=0; k<80; k++) {\n            dp[i][j][k]=inf;\n        }\n        for (int i=0; i<n; i++) {\n            int k; scanf(\"%d\",&k);\n            for (int j=0; j<k; j++) {\n                int x, d; scanf(\"%d%d\",&x,&d);\n                riv[i].push_back(P(x,d));\n            }\n        }\n        for (int i=0; i<n; i++) {\n            int sz=riv[i].size();\n            for (int j=0; j<sz; j++) {\n                for (int k=0; k<min(i+1,m+1); k++) {\n                    if (i==0) {\n                        dp[i][j][k]=0;\n                    } else {\n                        int sz2=riv[i-1].size();\n                        for (int l=0; l<sz2; l++) {\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-1][l][k]+(int)abs(riv[i][j].f-riv[i-1][l].f)*(riv[i][j].s+riv[i-1][l].s));\n                        }\n                    }\n                    if (k!=0&&i>1) {\n                        int sz2=riv[i-2].size();\n                        for (int l=0; l<sz2; l++) {\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-2][l][k-1]+(int)abs(riv[i][j].f-riv[i-2][l].f)*(riv[i][j].s+riv[i-2][l].s));\n                        }\n                    }\n                }\n            }\n        }\n        int res=inf;\n        for (int i=0; i<riv[n-1].size(); i++) {\n            for (int k=0; k<=m; k++) res=min(res,dp[n-1][i][k]);\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Solution for aoj:0530 Pyon-Pyon River Crossing\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int INF = 100000000, MAX_N = 150;\ntypedef pair<int, int> P;\nint n, m, ans;\nint dp[MAX_N + 2][1001][76];\nP stone, stone2;\nvector<P> Stone[151]; //first:??????second:???????????????\nint main(){\n\twhile (cin >> n >> m){\n\t\tif (!n&&!m)\n\t\t\treturn 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tStone[i].clear();\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tStone[i].push_back(P(a, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tfor (int j = 1; j <= 1000; j++){\n\t\t\t\tfor (int k = 0; k <= m; k++){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\t\tstone = Stone[2][i];\n\t\t\tdp[2][stone.first][m] = INF;\n\t\t}\n\t\tfor (int i = 3; i <= n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t\tdp[i][stone.first][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k < Stone[i + 1].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 1][k];\n\t\t\t\t\tfor (int l = m; l >= m - (i + 1) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (l != m)\n\t\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], dp[i + 1][stone2.first][l + 1]);\n\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < Stone[i + 2].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 2][k];\n\t\t\t\t\tfor (int l = m - 1; l >= m - (i + 2) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (l != m)\n\t\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 2][stone2.first][l], dp[i + 2][stone2.first][l + 1]);\n\t\t\t\t\t\tdp[i + 2][stone2.first][l] = min(dp[i + 2][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor (int i = 0; i < Stone[n].size(); i++){\n\t\t\tstone = Stone[n][i];\n\t\t\tans = min(dp[n][stone.first][0], ans);\n\t\t}\n\t\tfor (int i = 0; i < Stone[n - 1].size(); i++){\n\t\t\tif (m == 0)\n\t\t\t\tbreak;\n\t\t\tstone = Stone[n - 1][i];\n\t\t\tif (dp[n - 1][stone.first][1])\n\t\t\t\tans = min(dp[n - 1][stone.first][1], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tREP(i, n - 1) REP(j, stone[i].size()) REP(k, m + 1) {\n\t\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2 && m != 0) {\n\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\tint cost = (stone[i][j].second + stone[i + 2][l].second) * abs(stone[i][j].first - stone[i + 2][l].first);\n\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\tint cost = (stone[i][j].second + stone[i + 1][l].second) * abs(stone[i][j].first - stone[i + 1][l].first);\n\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tREP(i, stone[n - 2].size()) FOR(j, 1, m + 1) ans = min(ans, dp[n - 2][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans=INF;\nLL V[160][15];\nLL K[160][15];\nLL mem[160][15][80];\n\n\nLL cal(int y,int x,int m){\n    LL res=INF;\n    if(mem[y][x][m]!=-1)return mem[y][x][m];\n    if(y==N)return 0;\n    rep(i,10){\n        LL d1,d2;\n        if(m>0&&K[y+1][i]&&K[y+2][i]&&y+2<=N){\n            d1=(K[y][x]+K[y+1][i])*abs(V[y][x]-V[y+1][i]);\n            d2=(K[y][x]+K[y+2][i])*abs(V[y][x]-V[y+2][i]);\n            res=min(cal(y+1,i,m)+d1,min(cal(y+2,i,m-1)+d2,res));\n        }\n        else if(K[y+1][i]){\n            d1=(K[y][x]+K[y+1][i])*abs(V[y][x]-V[y+1][i]);\n            res=min(cal(y+1,i,m)+d1,res);\n        }\n        else if(!K[y+1][i]&&K[y+2][i]&&m>0&&y+2<=N){\n            d2=(K[y][x]+K[y+2][i])*abs(V[y][x]-V[y+2][i]);\n            res=min(cal(y+2,i,m-1)+d2,res);\n        }\n    }\n    return mem[y][x][m]=res;\n}\n\n\nint main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(mem,-1,sizeof(mem));\n        memset(V,0,sizeof(V));\n        memset(K,0,sizeof(K));\n        FOR(i,1,N){\n            LL t;\n            cin>>t;\n            rep(j,t){\n                LL x,k;\n                cin>>x>>k;\n                V[i][j]=x;\n                K[i][j]=k;\n            }\n        }\n        rep(i,10){\n            if(K[1][i]){\n                ans=min(cal(1,i,M),ans);\n            }\n        }\n        cout<<ans<<endl;\n        ans=INF;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  ll n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++){\n\tdp[0][i][j]=dp[1][i][j]=0;\n\tif(j==m-1)dp[2][i][j]=0;\n      }\n    \n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    //if(i==2)dp[i][j][l]=0;\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    /*\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n    */\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define INF (1 << 30)\nusing namespace std;\n\nint main(){\n  int n, m, tmp;\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    int dp[3][10][100];\n    memset(dp, 0, sizeof(dp));\n    vector< pair<int, int> >stones[n];\n    for(int i = 0;i < n;i++){\n      int k, l, m;\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;j++){\n\tscanf(\"%d %d\", &l, &m);\n\tstones[i].push_back(make_pair(l, m));\n      }\n    }\n    for(int i = 0;i < n;i++){\n      int ind = i%3, prev = (i - 1) % 3, prepre = (i - 2) % 3;\n\n      for(int j = 0;j < stones[i].size();j++)\n\tfor(int k = 0;k <= m;k++)\n\t  dp[ind][j][k] = INF;\n\n      for(int j = 0;j < stones[i].size();j++){\n\tif(i == 0)dp[ind][j][m] = 0;\n\telse if(i == 1 && m - 1 >= 0)dp[ind][j][m - 1] = 0;\n      }\n      for(int j = 0;j < stones[i].size();j++){\n\tfor(int k = 0;k <= m;k++){\n\t  for(int l = 0;i > 0 && l < stones[i - 1].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prev][l][k] + abs(stones[i - 1][l].first - stones[i][j].first) * (stones[i - 1][l].second + stones[i][j].second));\n\t  }\n\t  for(int l = 0;i > 1 && k < m && l < stones[i - 2].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prepre][l][k + 1] + abs(stones[i - 2][l].first - stones[i][j].first) * (stones[i - 2][l].second + stones[i][j].second));\n\t  }\n\t}\n      }\n    }\n    int res = INF;\n    for(int i = 0;i < stones[n - 1].size();i++){\n      for(int j = 0;j <= m;j++){\n\tres = min(res, dp[(n - 1) % 3][i][j]);\n      }\n    }\n    for(int i = 0;i < stones[n - 2].size();i++){\n      for(int j = 1;j <= m;j++){\n\tres = min(res, dp[(n - 2) % 3][i][j]);\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n#define for_each(it,a) for(__typeof a.begin() it = a.begin();it!=a.end();it++)\ntemplate<class T> void chmin(T& a, T b) { if( b < a ) a = b; }\n\nint n, m;\nstruct edge{\n  int pos, dang;\n  vector < int >  value;\n  edge(){};\n  edge( int pos, int dang): pos(pos), dang(dang), value( (n + 1) / 2 + 1, INF){};\n};\nint main(){\n  while( cin >> n >> m , n){\n    vector< vector < edge > > info(n + 2);\n    for(int i = 0, k, t, d; i < n; i++){\n      cin >> k;\n      while(k--){\n        cin >> t >> d;\n        info[i].push_back( edge( t, d));\n      }\n    }\n    for_each( it, info[0]) it -> value[m] = 0;\n    for_each( it, info[1]) it -> value[m - 1] = 0;\n    for( int i = 0; i < n; i++){\n      for_each( now, info[i]){\n        for(int j = m; j >= 0; j--){ //ジャンプできる残り回数\n          int& cost = now -> value[j], dang = now -> dang, pos = now -> pos;\n          if( cost == INF) continue;\n          if(j > 0){ //ジャンプしてみる\n            for_each( next, info[i + 2]){\n              chmin( next -> value[j - 1], cost + (dang + next -> dang) * abs( pos - next -> pos));\n            }\n          }\n          for_each( next, info[i + 1]){\n            chmin( next -> value[j], cost + (dang + next -> dang) * abs( pos - next -> pos));\n          }\n        }\n      }\n    }\n    int ret = INF;\n    for_each(it,info[n - 1]) ret = min( ret, *min_element( it->value.begin(), it->value.end()));\n    for_each(it,info[n - 2]) ret = min( ret, *min_element( it->value.begin() + 1, it->value.end()));\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define INF 1145141919\n\nint N, M;\nint W;\nint T[200][1010];\nint dp[200][1010][100];\n\nint main() {\n  while (cin >> N >> M) {\n    if (N == 0 && M == 0) break;\n    for (int i=0; i<200; i++) {\n      for (int j=0; j<1010; j++) {\n        T[i][j] = -1;\n      }\n    }\n    for (int i=0; i<N; i++) {\n      int k;\n      cin >> k;\n      for (int j=0; j<k; j++) {\n        int x, d;\n        cin >> x >> d;\n        T[i][x-1] = d;\n        W = max(W, x);\n      }\n    }\n\n    for (int i=0; i<200; i++) {\n      for (int j=0; j<1010; j++) {\n        for (int m=0; m<100; m++) {\n          dp[i][j][m] = INF;\n        }\n      }\n    }\n    for (int i=0; i<W; i++) {\n      if (T[0][i] > 0) dp[0][i][0] = 0;\n    }\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<W; j++) {\n        for (int m=0; m<=M; m++) {\n          if (dp[i][j][m] == INF) continue;\n          for (int nj=0; nj<W; nj++) {\n            if (T[i+1][nj] > 0) {\n              dp[i+1][nj][m] = min(dp[i+1][nj][m], dp[i][j][m] + abs(j - nj)*(T[i+1][nj] + T[i][j]));\n            }\n            if (T[i+2][nj] > 0) {\n              dp[i+2][nj][m+1] = min(dp[i+2][nj][m], dp[i][j][m] + abs(j - nj)*(T[i+2][nj] + T[i][j]));\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for (int i=0; i<W; i++) {\n      for (int m=0; m<=M; m++) {\n        ans = min(ans, dp[N-1][i][m]);\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[150][76][10];\nint main(){\n\twhile(true){\n\tint n,m;\tcin>>n>>m;\n\tif(n==0)\treturn 0;\n\tvector<pair<int,int>> ls[n];\n\tfor(int i=0;i<n;i++){\n\t\tint k;\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\tcin>>x>>d;\n\t\t\tls[i].push_back(make_pair(x,d));\n\t\t}\n\t}\n\tfor(int i=0;i<150;i++){\n\t\tfor(int j=0;j<=75;j++){\n\t\t\tfor(int k=0;k<10;k++)\tdp[i][j][k]=(1<<30);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)ls[0].size();i++)\tdp[0][m][i]=0;\n\tif(m!=0)\tfor(int i=0;i<(int)ls[1].size();i++)\tdp[1][m-1][i]=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<(int)ls[i].size();k++){\n\t\t\t\tif(dp[i][j][k]==(1<<30))\tcontinue;\n\t\t\t\tfor(int l=0;l<(int)ls[i+1].size();l++){\n\t\t\t\t\tdp[i+1][j][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+1][l].first)*(ls[i][k].second+ls[i+1][l].second),dp[i+1][j][l]);\n\t\t\t\t}\n\t\t\t\tif(j!=0&&i+2<n){\n\t\t\t\t\tfor(int l=0;l<(int)ls[i+2].size();l++){\n\t\t\t\t\tdp[i+2][j-1][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+2][l].first)*(ls[i][k].second+ls[i+2][l].second),dp[i+2][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=(1<<30);\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-1].size();j++){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nvoid calc(int n,int m){\n    int c,a,b,d=-1,dp[151][10][80],ans=1000000000,s,dis;\n    vector<pair<int,int> > stone[151];\n    \n    //scanf(\"%d%d\",&n,&m);\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<=m;k++){\n                dp[i][j][k]=1000000000;\n            }\n        }\n    }\n    \n    for(int j=0;j<10;j++){\n        dp[0][j][0]=0;\n        dp[1][j][1]=0;\n    }\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&c);\n        \n        for(int j=0;j<c;j++){\n            scanf(\"%d%d\",&a,&b);\n            stone[i].push_back(make_pair(a,b));\n        }\n    }\n    \n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<stone[i].size();j++){\n            \n            for(int k=0;k<stone[i+1].size();k++){\n                for(int l=0;l<=m;l++){\n                    s=stone[i][j].second+stone[i+1][k].second;\n                    dis=abs(stone[i][j].first-stone[i+1][k].first);\n                    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][l]+s*dis);\n                }\n            }\n            for(int k=0;k<stone[i+2].size();k++){\n                for(int l=0;l<m;l++){\n                    s=stone[i][j].second+stone[i+2][k].second;\n                    dis=abs(stone[i][j].first-stone[i+2][k].first);\n                    dp[i+2][k][l+1]=min(dp[i+2][k][l+1],dp[i][j][l]+s*dis);\n                }\n            }\n        }\n    }\n    \n    for(int i=0;i<stone[n-1].size();i++){\n        for(int j=0;j<=m;j++){\n            ans=min(ans,dp[n-1][i][j]);\n        }\n    }\n    \n    for(int i=0;i<stone[n-2].size();i++){\n        for(int j=0;j<m;j++){\n            ans=min(ans,dp[n-2][i][j]);\n        }\n    }\n    \n    printf(\"%d\\n\",ans);\n    \n    return;\n}\n\nint main(){\n    int n,m;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0) break;\n        calc(n,m);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150]; //K[i]::=i行目に何個の石があるか\nint X[10][150]; //X[i][j]::=j列目のi個目が何列目か\nint D[10][150]; //D[i][j]::=j列目のi個目のすべりやすさ\nint DP[10][150][80]; //DP[i][j][k]::=j列目のi個目にいて、もうk回ジャンプしてるときの最小コスト\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][0]=0;\n\t\tif(M>0) for(int x=0;x<K[1];x++) DP[x][1][1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) for(int m=0;m<=M;m++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y>1 && m>0) {\n\t\t\t\tfor(int xx=0;xx<K[y-2];xx++) {\n\t\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m-1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tif(M>0) {\n\t\t\tfor(int x=0;x<K[N-2];x++) for(int m=0;m<=M;m++) {\n\t\t\t\tans=min(ans,DP[x][N-2][m]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[152][1010][80];\nint solve(int h,int w,int idx,int k){\n  if(h == n-1) return 0;\n  if(dp[h][w][k] != INF) return dp[h][w][k];\n  int ret = INF;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    int s = stone[h][idx].second;\n    ret = min(ret,solve(h+1,nw,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      int s = stone[h][idx].second;\n      ret = min(ret,solve(h+2,nw,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][w][k] = ret;\n}\n    \n\nint main(){\n  cin >> n >> k;\n  for(int i=0;i<n;i++){\n    int m; cin >> m;\n    for(int j=0;j<m;j++){\n      int a,b; cin >> a >> b;\n      stone[i].push_back(P(a,b));\n    }\n  }\n  int ans = INF;\n  for(int i=0;i<152;i++){\n    for(int j=0;j<1010;j++){\n      for(int k=0;k<80;k++){\n\tdp[i][j][k] = INF;\n      }\n    }\n  }\n  for(int i=0;i<stone[0].size();i++){\n    ans = min(ans,solve(0,stone[0][i].first,i,k));\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define SQR(a) ((a)*(a))\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pr;\ntypedef pair<pr,ll> ppr;\ntypedef vector<pr> vpr;\nconst ll INF=(ll)1<<60;\nll DP[152][152][11];\nint main() {\n\tint n,m,times,tmp;\n\twhile(cin >> n >> m && n){\n\tll block[152][11]={};\n\tll x[152][11]={};\n\tREP(i,152)\n\t\tREP(j,152)\n\t\t\tREP(k,11)\n\t\t\t\tDP[i][j][k]=INF;\n\tREP(i,n){\n\t\tcin >> times;\n\t\tREP(j,times){\n\t\tcin >> x[i][j];\n\t\tcin >> block[i][j];\n\t\t}\n\t}\n\tREP(i,11){\n\tDP[0][0][i]=0;\n\tDP[1][1][i]=0;\n\t}\n\tFOR(i,1,n)\n\t\tREP(j,11)\n\t\t\tif(block[i][j])\n\t\t\tREP(l,m+1)\n\t\t\t\tREP(k,11){\n\t\t\t\t\tif(block[i-1][k])\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-1][l][k]+abs(x[i][j]-x[i-1][k])*(block[i-1][k]+block[i][j]));\n\t\t\t\t\tif(block[i-2][k] && l && i!=1)\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-2][l-1][k]+abs(x[i][j]-x[i-2][k])*(block[i-2][k]+block[i][j]));\n\t\t\t\t}\n\tll minium=INF;\n\tREP(i,11)\n\t\tREP(j,m+1)\n\t\t\tminium=min(minium,DP[n-1][j][i]);\n\tif(m)\n\tREP(i,11)\n\t\tREP(j,m)\n\t\t\tminium=min(minium,DP[n-2][j][i]);\n\tcout << minium << endl;\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Pyon-Pyon River Crossing.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int X = 1005;\nconst int Y = 155;\nconst int MM = 80;\nconst int INF = 1 << 30;\n\nint N, M;\nint dp[3][X][MM];\n\nint main()\n{\n\tfor(; cin >> N >> M && (N || M); )\n\t{\n\t\tvector<vector<vint> > dp(3, vector<vint>(X, vint(MM, INF)));\n\t\tdp[0] = vector<vint>(X, vint(MM, 0));\n\t\trep(x, X) rep(m, M) dp[1][x][m] = 0;\n\t\t\n\t\tvector<vector<pint> > river;\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\triver.push_back(vector<pint>(k));\n\t\t\t\n\t\t\trep(i, k) cin >> river[y][i].first >> river[y][i].second;\n\t\t}\n\t\t\n\t\triver.push_back(vector<pint>(X));\n\t\triver.push_back(vector<pint>(X));\n\t\trep(i, X) river[N][i] = mp(i, 0), river[N+1][i] = mp(i, 0);\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\trep(i, river[y].size())\n\t\t\t{\n\t\t\t\trep(m, M+1)\n\t\t\t\t{\n\t\t\t\t\trep(j, river[y+1].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+1][j].second + river[y][i].second) * abs(river[y+1][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[1][river[y+1][j].first][m], dp[0][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(m > 0) rep(j, river[y+2].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+2][j].second + river[y][i].second) * abs(river[y+2][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[2][river[y+2][j].first][m-1], dp[0][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp[0] = dp[1];\n\t\t\tdp[1] = dp[2];\n\t\t\trep(x, X) rep(m, MM) dp[2][x][m] = INF;\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\trep(x, X) rep(m, MM) chmin(ans, dp[0][x][m]);\n\n\t\tcout << ans << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 5000000\nint n,m;\nint d[77][150][10];\nint r[150][10];\nint f[150][10];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint max(int a,int b){\n\tif(a<=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(i=0;i<n;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\tif(i==0)d[k][i][f[i][j]]=0;\n\t\t\telse d[k][i][f[i][j]]=INF;\n\t\t}\n\t\tif(m>=1)for(j=0;j<c[1];j++){\n\t\t\td[m-1][1][f[1][j]]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j+1][i-2][f[i-2][l]]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j][i-1][f[i-1][l]]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][f[n-1][j]]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n    ans=min(d[n][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n+1){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n+1){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dijkstra(0) << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\nconst int INF = 1e9;\nint n, m; \nint bmemo[160][1010];//b[y][x]\nvector<pair<int, int> > b[160];//\nint dp[160][1010][80];//dp[y??§?¨?][x??§?¨?][1????£???°????????£??????????????°] = ????????????????°????\nint main(void){\n\twhile(1){\n\t\t//input\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) return 0;\n\t\trep(i, 160)rep(j, 1010) bmemo[i][j] = INF;\n\t\trep(i, 160) b[i].clear();//?????????\n\t\trep(i, n){\n\t\t\tint k; cin >> k;\n\t\t\trep(j, k){//k???????????§?¨?\n\t\t\t\tint x, s; cin >> x >> s; x--;\n\t\t\t\tb[i].push_back(make_pair(x, s));\n\t\t\t\tbmemo[i][x] = s;\n\t\t\t}\n\t\t}\n\n\t\trep(i, 160)rep(j, 1010)rep(k, 80) dp[i][j][k] = INF;\n\t\tfor(auto start1 : b[0]){//???????????????????????£??????\n\t\t\tdp[0][start1.fi][0] = 0;\n\t\t}\n\n\t\tfor(auto start2 : b[1]){//????????????????£???°????????£??????\n\t\t\tdp[1][start2.fi][1] = 0;\n\t\t}\n\n\t\t//??????dp\n\t\tfor (int i = 0; i <  n - 1; ++i){\n\t\t\tfor (int j = 0; j < 1010; ++j){\n\t\t\t\tfor (int k = 0; k <= m; ++k){\n\t\t\t\t\tif(dp[i][j][k] == INF) continue;\n\t\t\t\t\t//??????????????£?????????\n\t\t\t\t\tfor(auto next : b[i + 1]){\n\t\t\t\t\t\tint score = (bmemo[i][j] + next.se) * abs(j - next.fi);//?????????????????±??????\n\t\t\t\t\t\tdp[i + 1][next.fi][k] = min(dp[i + 1][next.fi][k], dp[i][j][k] + score);\n\t\t\t\t\t}\n\t\t\t\t\tif(k == m || i == n - 2) continue;\n\t\t\t\t\t//???????£???°????????£??????\n\t\t\t\t\tfor(auto next : b[i + 2]){\n\t\t\t\t\t\tint score = (bmemo[i][j] + next.se) * abs(j - next.fi);//?????????????????±??????\n\t\t\t\t\t\tdp[i + 2][next.fi][k + 1] = min(dp[i + 2][next.fi][k + 1], dp[i][j][k] + score);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//????°????????????????\n\t\tint ans = INF;\n\t\tfor (int j = 0; j < 1010; ++j){//???????????????????????£??????\n\t\t\tfor (int k = 0; k <= m; ++k){\n\t\t\t\tans = min(ans, dp[n - 1][j][k]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < 1010; ++j){//?????????1????£???°???????????£??????\n\t\t\tfor (int k = 0; k <= m - 1; ++k){\n\t\t\t \tans = min(ans, dp[n - 2][j][k]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[152][1010][80];\nint solve(int h,int w,int idx,int k){\n  if(h == n-1) return 0;\n  if(dp[h][w][k] != INF) return dp[h][w][k];\n  int ret = INF;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    int s = stone[h][idx].second;\n    ret = min(ret,solve(h+1,nw,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      int s = stone[h][idx].second;\n      ret = min(ret,solve(h+2,nw,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][w][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<152;i++){\n      for(int j=0;j<1010;j++){\n\tfor(int k=0;k<80;k++){\n\t  dp[i][j][k] = INF;\n\t}\n      }\n    }\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,stone[0][i].first,i,k));\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    int N,M,K,k1,k2,MIN,ANS;\n    while(scanf(\"%d%d\",&N,&M),N + M)\n    {\n        int field[160][20] = {0},dp[160][20][100] = {0};\n        ANS = 10000000;\n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\",&K);\n            for(int j = 0; j < K; j++)\n            {\n                scanf(\"%d%d\",&k1,&k2);\n                field[i + 1][k1 - 1] = k2;\n            }\n        }\n        /*for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 2; i < N + 1; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 10; k++)\n                {\n                    if(field[i][k] != 0)\n                    {\n                        dp[i][k][j] = 10000000;\n                        if(j == 0)\n                        {\n                            for(int l = 0; l < 10; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[i][k][0] = min(dp[i][k][0],dp[i - 1][l][0] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                        else if(i >= j * 2)\n                        {\n                            for(int l = 0; l < 10; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 1][l][j] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                                if(field[i - 2][l] != 0 || i - 2 == 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 2][l][j - 1] + (field[i - 2][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /*for(int i = 0; i < N + 1; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        for(int i = 0; i < N + 1; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    printf(\"%2d\",dp[i][k][j]);\n                }\n                printf(\" / \");\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 0; i < M + 1; i++)\n        {\n            for(int j = 0; j < 10; j++)\n            {\n                if(field[N][j] != 0)\n                {\n                    ANS = min(ANS,dp[N][j][i]);\n                }\n                if(i < M && field[N - 1][j] != 0)\n                {\n                    ANS = min(ANS,dp[N - 1][j][i]);\n                }\n            }\n        }\n        printf(\"%d\\n\",ANS);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k,l;\n  int a[10][150][78],x[11][150],d[10][150],m,n;\n  int mn;\n  while(cin>>n>>m&&n+m){\n    memset(x,-1,sizeof(x));\n    memset(d,-1,sizeof(d));\n    for(i=0;i<n;i++){\n      cin>>k;\n      for(j=0;j<k;j++){\n\tint t,u;\n\tcin>>t>>u;\n\tt--;\n\tx[j][i]=t;\n\td[j][i]=u;\n      }\n    }\n    memset(a,-1,sizeof(a));\n    for(i=0;x[i][0]!=-1;i++)\n      a[i][0][0]=0;\n    if(m){\n      for(i=0;x[i][1]!=-1;i++)\n\ta[i][1][1]=0;\n    }\n    for(i=0;i<n-2;i++){\n      for(j=0;x[j][i]!=-1;j++){\n\tfor(k=0;k<n/2+3;k++){\n\t  if(a[j][i][k]!=-1){\n\t    for(l=0;x[l][i+1]!=-1;l++){\n\t      if(a[l][i+1][k]==-1||a[l][i+1][k]>a[j][i][k]+(d[j][i]+d[l][i+1])*abs(x[j][i]-x[l][i+1]))\n\t\ta[l][i+1][k]=a[j][i][k]+(d[j][i]+d[l][i+1])*abs(x[j][i]-x[l][i+1]);\n\t    }\n\t    if(k!=m){\n\t      for(l=0;x[l][i+2]!=-1;l++){\n\t\tif(a[l][i+2][k+1]==-1||a[l][i+2][k+1]>a[j][i][k]+(d[j][i]+d[l][i+2])*abs(x[j][i]-x[l][i+2]))\n\t\t  a[l][i+2][k+1]=a[j][i][k]+(d[j][i]+d[l][i+2])*abs(x[j][i]-x[l][i+2]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    mn=-1;\n    for(i=0;x[i][n-2]!=-1;i++){\n      for(j=0;j<n/2+3;j++){\n\tif(a[i][n-2][j]!=-1){\n\t  if(j==m){\n\t    for(k=0;x[k][n-1]!=-1;k++){\n\t      if(a[k][n-1][j]==-1||a[k][n-1][j]>a[i][n-2][j]+(d[i][n-2]+d[k][n-1])*abs(x[i][n-2]-x[k][n-1]))\n\t\ta[k][n-1][j]=a[i][n-2][j]+(d[i][n-2]+d[k][n-1])*abs(x[i][n-2]-x[k][n-1]);\n\t    }\n\t  }else if(mn==-1||mn>a[i][n-2][j])\n\t    mn=a[i][n-2][j];\n\t}\n      }\n    }\n    for(i=0;x[i][n-1]!=-1;i++){\n      for(j=0;j<n/2+3;j++){\n\tif(a[i][n-1][j]!=-1){\n\t  if(mn==-1||mn>a[i][n-1][j])\n\t    mn=a[i][n-1][j];\n\t}\n      }\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\t//for(a=0;a<=m;a++){\n\ta=0;\n\tif(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\t\t       \n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  \n\t  //}\n\t\n      }\n    }\n    \n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nBe joyful in hope, patient in affliction, faithful in prayer.\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <functional>\n#include <iterator>\n#include <utility>\n#include <bitset>\n#include <cstdlib>\n#include <ctime>\n#include <complex>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\n#define FOR(i, a, b) for(int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define REPD(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define SZ(x) ((int)x.size())\n#define openfile {freopen(\"inp.txt\",\"rt\",stdin);freopen(\"out.txt\",\"wt\",stdout);}\n#define debug 0\n\ntemplate <typename T> inline void next_int(T &x) {\n\tx = 0; char c; bool neg = false;\n\twhile (!isdigit(c = getchar())) if (c == '-') neg = true;\n\tdo x = x*10 + c - 48; while (isdigit(c = getchar()));\n\tif (neg) x = -x;\n}\n\ntemplate <typename T> inline void write_int(T x, char last = 0) {\n\tif (x < 0) putchar('-'), x = abs(x);\n\tchar tmp[20]; int cnt = 0;\n\twhile (x >= 10) tmp[cnt++] = x % 10 + 48, x /= 10;\n\ttmp[cnt] = x + 48;\n\tFORD(i, cnt, 0) putchar(tmp[i]);\n\tif (last) putchar(last);\n}\n\nconst ll oo = (ll)1e18+7;\nint n, m;\nll dp[155][15][80];\nint k[155], x[155][25], s[155][25];\n\nint main() {\n\twhile(scanf(\"%d%d\", &n, &m) == 2 && n){\n\t\tstatic  = {};\n\t\tREP(i, 0, 155) REP(j, 0, 15)REP(k, 0, 80) dp[i][j][k] = oo;\n\t\tREP(i, 0, n) {\n\t\t\tscanf(\"%d\", &k[i]);\n\t\t\tREP(j, 0, k[i]) scanf(\"%d%d\", &x[i][j], &s[i][j]);\n\t\t}\n\t\tREP(i, 0, k[0]) dp[0][i][0] = 0;\n\t\tREP(i, 0, k[1]) dp[1][i][1] = 0;\n\t\tREP(i, 0, n - 1) REP(j, 0, k[i]) {\n\t\t\tint cur = x[i][j];\n\t\t\tREP(l, 0, k[i + 1]) {\n\t\t\t\tint tmp = x[i + 1][l];\n\t\t\t\tFOR(used, 0, m) dp[i + 1][l][used] = min(dp[i + 1][l][used], dp[i][j][used] + (s[i][j] + s[i + 1][l]) * abs(cur - tmp));\n\t\t\t}\n\t\t\tif(i + 2 < n) {\n\t\t\t\tREP(l, 0, k[i + 2]) {\n\t\t\t\t\tint tmp = x[i + 2][l];\n\t\t\t\t\tREP(used, 0, m) dp[i + 2][l][used + 1] = min(dp[i + 2][l][used + 1], dp[i][j][used] + (s[i][j] + s[i + 2][l]) * abs(cur - tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = oo;\n\t\tREP(i, 0, k[n - 1]) REP(j, 0, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tREP(i, 0, k[n - 2]) REP(j, 0, m) ans = min(ans, dp[n - 2][i][j]);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define INF 10000000000000000\nstruct S {int x,d;};\nint n,m;\nint dp[152][1002][80];\nvector<S> a[152];\n\nsigned main(){\n  while(cin>>n>>m,n){\n    REP(i,n+2)a[i].clear();\n    REP(i,n){\n      int k,x,d;\n      cin>>k;\n      REP(j,k){\n        cin>>x>>d;\n        a[i+1].push_back({x,d});\n      }\n    }\n    REP(i,n+2)REP(j,1000)REP(k,m+1)dp[i][j+1][k]=INF;\n    REP(j,1000)a[0].push_back({j+1,0});\n    REP(j,1000)a[n+1].push_back({j+1,0});\n    REP(j,1000)dp[0][j+1][0]=0;\n    REP(i,n+2){\n      for(S s:a[i]){\n        for(S t:a[i+1]){\n          REP(c,m+1){\n            dp[i+1][t.x][c]=min(dp[i+1][t.x][c],dp[i][s.x][c]+(s.d+t.d)*abs(s.x-t.x));\n          }\n        }\n        if(i+1>n)continue;\n        for(S u:a[i+2]){\n          REP(c,m){\n            dp[i+2][u.x][c+1]=min(dp[i+2][u.x][c+1],dp[i][s.x][c]+(s.d+u.d)*abs(s.x-u.x));\n          }\n        }\n      }\n    }\n    int ans=INF;\n    REP(j,1000)REP(c,m+1)ans=min(ans,dp[n+1][j+1][c]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint V,d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second ==0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=1000000;\n  for(int i=0;i<MAX_V;i++)\n    ans=min(d[n-1][i],ans);\n \n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n\n  while(cin >> n >> m,n|m){\n    for(int i=0;i<155;i++)G[i].clear();\n\n    for(int i=0;i<MAX_V;i++)\n      for(int j=0;j<MAX_V;j++)\n\tgraph[i][j]=0;\n\n    int mx=0;\n    for(int i=0;i<n;i++){\n      cin >> k;\n\n      for(int j=0;j<k;j++){\n\tcin >> x >> y;\n      mx=max(mx,x);\n\tgraph[i][x]=y;\n      }\n    }\n    edge e;\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<=mx;j++){\n\tif(graph[i][j]>0){\n\t  for(int l=0;l<=mx;l++){\n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t  }\n\t}\n      }\n    }\n  cout << dijkstra(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[256][16][128];\nint stones[256][16][2];\nint col[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tREP(k, 2) cin >> stones[i][j][k];\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tint x_now = stones[i][j][0], d_now = stones[i][j][1];\n\tREP(k, col[i+1]) {\n\t  int x_next = stones[i+1][k][0], d_next = stones[i+1][k][1];\n\t  int safe = (d_now + d_next) * abs(x_now - x_next);\n\t  REP(m, M+1) {\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + safe);\n\t  }\n\t}\n\tif (i < N-2) {\n\t  REP(k, col[i+2]) {\n\t    int x_next = stones[i+2][k][0], d_next = stones[i+2][k][1];\n\t    int safe = (d_now + d_next) * abs(x_now - x_next);\n\t    REP(m, M) {\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tpii p;\n\tint c, j;\n\tstate(pii p, int c, int j) : p(p), c(c), j(j) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint risk(int cd, int nd, int dx) {\n\treturn (cd+nd)*dx;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvvi stone(n, vi(1000, -1));\n\tint maxx = 0;\n\tREP(i, n) {\n\t\tint k;\n\t\tcin >> k;\n\t\tREP(j, k) {\n\t\t\tint x, d;\n\t\t\tcin >> x >> d;\n\t\t\tstone[i][x-1] = d;\n\t\t\tmaxx = max(maxx, x);\n\t\t}\n\t}\n\n\tvector<vvi> field(n, vvi(maxx, vi(m+1, INF)));\n\tpriority_queue<state> Q;\n\tREP(i, maxx) {\n\t\tif(stone[0][i] != -1) {\n\t\t\tfield[0][i][0] = 0;\n\t\t\tQ.push(state(pii(0, i), 0, 0));\n\t\t}\n\t}\n\tif(n > 1 && m > 0) {\n\t\tREP(i, maxx) {\n\t\t\tif(stone[1][i] != -1) {\n\t\t\t\tfield[1][i][1] = 0;\n\t\t\t\tQ.push(state(pii(1, i), 0, 1));\n\t\t\t}\n\t\t}\n\t}\t\n\n\tint ans = INF;\n\twhile(!Q.empty()) {\n\t\tstate st = Q.top();\n\t\tQ.pop();\n\n\t\tint y = st.p.first, x = st.p.second;\n\t\tif(y+2 == n && st.j < m) {\n\t\t\tans = min(ans, st.c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(y+1 == n) {\n\t\t\tans = min(ans, st.c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tREP(i, maxx) {\n\t\t\tif(stone[y+1][i] != -1) {\n\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+1][i], abs(x-i));\n\t\t\t\tif(nc < field[y+1][i][st.j]) {\n\t\t\t\t\tfield[y+1][i][st.j] = nc;\n\t\t\t\t\tQ.push(state(pii(y+1, i), nc, st.j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(st.j < m && y+2 < n) {\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[y+2][i] != -1) {\n\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+2][i], abs(x-i));\n\t\t\t\t\tif(nc < field[y+2][i][st.j+1]) {\n\t\t\t\t\t\tfield[y+2][i][st.j+1] = nc;\n\t\t\t\t\t\tQ.push(state(pii(y+2, i), nc, st.j+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tpii p;\n\tint c, j;\n\tstate(pii p, int c, int j) : p(p), c(c), j(j) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint risk(int cd, int nd, int dx) {\n\treturn (cd+nd)*dx;\n}\n\nint stone[150][1000];\nint field[150][1000][80];\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tREP(i, 150) {\n\t\t\tREP(j, 1000) {\n\t\t\t\tstone[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint maxx = 0;\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j, k) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tstone[i][x-1] = d;\n\t\t\t\tmaxx = max(maxx, x);\n\t\t\t}\n\t\t}\n\n\t\tREP(i, 150) {\n\t\t\tREP(j, 1000) {\n\t\t\t\tREP(k, 80) {\n\t\t\t\t\tfield[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> Q;\n\t\tREP(i, maxx) {\n\t\t\tif(stone[0][i] != -1) {\n\t\t\t\tfield[0][i][0] = 0;\n\t\t\t\tQ.push(state(pii(0, i), 0, 0));\n\t\t\t}\n\t\t}\n\t\tif(n > 1 && m > 0) {\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[1][i] != -1) {\n\t\t\t\t\tfield[1][i][1] = 0;\n\t\t\t\t\tQ.push(state(pii(1, i), 0, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\n\t\tint ans = INF;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tint y = st.p.first, x = st.p.second;\n\t\t\tif(y+2 == n && st.j < m) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(y+1 == n) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[y+1][i] != -1) {\n\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+1][i], abs(x-i));\n\t\t\t\t\tif(nc < field[y+1][i][st.j]) {\n\t\t\t\t\t\tfield[y+1][i][st.j] = nc;\n\t\t\t\t\t\tQ.push(state(pii(y+1, i), nc, st.j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(st.j < m && y+2 < n) {\n\t\t\t\tREP(i, maxx) {\n\t\t\t\t\tif(stone[y+2][i] != -1) {\n\t\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+2][i], abs(x-i));\n\t\t\t\t\t\tif(nc < field[y+2][i][st.j+1]) {\n\t\t\t\t\t\t\tfield[y+2][i][st.j+1] = nc;\n\t\t\t\t\t\t\tQ.push(state(pii(y+2, i), nc, st.j+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate <class T>\nvector<T> make_v(size_t size, const T &init) {\n    return vector<T>(size, init);\n}\ntemplate <class... Ts>\nauto make_v(size_t size, Ts... rest) {\n    return vector<decltype(make_v(rest...))>(size, make_v(rest...));\n}\n\nint main() {\n    const int MAXW = 1e3;\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<vector<pair<int, int>>> stone(n);\n        for (int i = 0; i < n; i++) {\n            int k; cin >> k;\n            while (k--) {\n                int x, d; cin >> x >> d; x--;\n                stone[i].emplace_back(x, d);\n            }\n        }\n        auto dp = make_v(n, MAXW, m + 1, INF);\n        for (int j = 0; j < MAXW; j++) {\n            for (auto &p: stone[0]) dp[0][p.first][m] = 0;\n            if (m) for (auto &p: stone[1]) dp[1][p.first][m - 1] = 0;\n        }\n        for (int i = 0; i < n - 1; i++) for (int k = 0; k <= m; k++) {\n            for (auto &s: stone[i]) for (auto &t: stone[i + 1]) {\n                int cost = abs(s.first - t.first) * (s.second + t.second);\n                chmin(dp[i + 1][t.first][k], dp[i][s.first][k] + cost);\n            }\n            if (i == n - 2 || k == 0) continue;\n            for (auto &s: stone[i]) for (auto &t: stone[i + 2]) {\n                int cost = abs(s.first - t.first) * (s.second + t.second);\n                chmin(dp[i + 2][t.first][k - 1], dp[i][s.first][k] + cost);\n            }\n        }\n        int ans = INF;\n        for (int j = 0; j < MAXW; j++) for (int k = 0; k <= m; k++) {\n            if (k) chmin(ans, dp[n - 2][j][k]);\n            chmin(ans, dp[n - 1][j][k]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct P{\n  int x,c;\n  P(int x,int c):x(x),c(c){}\n};\nint n;\nvector<P> s[155];\nint dp[155][11][77];\nint solve(int y,int i,int m){\n  if(y >= n) return 0;\n  if(m && y+1 >= n) return 0;\n  if(dp[y][i][m] >= 0) return dp[y][i][m];\n\n  int ret = 1 << 22;\n  for(int j = 0; j < (int)s[y+1].size(); j++){\n    ret = min(ret,solve(y+1,j,m) + ((y)?(s[y][i].c + s[y+1][j].c) * abs(s[y][i].x - s[y+1][j].x):0));\n  }\n  if(m){\n    for(int j = 0; j < (int)s[y+2].size(); j++){\n      ret = min(ret,solve(y+2,j,m-1) + ((y)?(s[y][i].c + s[y+2][j].c) * abs(s[y][i].x - s[y+2][j].x):0));\n    }\n  }\n  return dp[y][i][m] = ret;\n}\nint main(void){\n  while(1){\n    int m;\n    scanf(\"%d%d\",&n,&m); if(!n) break;\n    memset(dp,-1,sizeof(dp));\n    for(int i = 1; i <= n; i++){\n      s[i].clear();\n      int k;\n      scanf(\"%d\",&k);\n      for(int j = 0; j < k; j++){\n\tint x,d;\n\tscanf(\"%d%d\",&x,&d);\n\ts[i].push_back(P(x,d));\n      }\n    }\n    s[0].push_back(P(0,0));\n    /*\n    for(int i = 0; i < (int)s[0].size(); i++){\n      ret = min(ret,solve(0,i,m));\n    }\n    */\n    printf(\"%d\\n\",solve(0,0,m));\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX_N = 150;\nstatic const int MAX_M = (MAX_N + 1) / 2;\nstatic const int MAX_K = 10;\nstatic const int INF = 1 << 30;\n\nint n, m;\nint k[MAX_N], x[MAX_N][MAX_K], d[MAX_N][MAX_K];\nint memo[MAX_N][MAX_K][MAX_M + 1];\n\nint abs(int a){\n\tif(a < 0) return -a;\n\telse return a;\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &k[i]);\n\t\t\tfor(int j = 0; j < k[i]; j++) scanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t}\n\t\tfill(memo[0][0], memo[n][0], INF);\n\t\tfor(int i1 = 0; i1 < n - 1; i1++){\n\t\t\tfor(int i2 = 0; i2 <= m; i2++){\n\t\t\t\tfor(int i3 = 0; i3 < k[i1]; i3++){\n\t\t\t\t\tif(i1 == 0 && i2 == 0) memo[i1][i3][i2] = 0;\n\t\t\t\t\tif(i1 == 1 && i2 == 1) memo[i1][i3][i2] = 0;\n\t\t\t\t\tfor(int i4 = 0; i4 < k[i1 + 1]; i4++){\n\t\t\t\t\t\tmemo[i1 + 1][i4][i2] = min(memo[i1 + 1][i4][i2], memo[i1][i3][i2] + (d[i1][i3] + d[i1 + 1][i4]) * abs(x[i1][i3] - x[i1 + 1][i4]));\n\t\t\t\t\t}\n\t\t\t\t\tif(i2 == m) continue;\n\t\t\t\t\tif(i1 == n - 2) continue;\n\t\t\t\t\tfor(int i4 = 0; i4 < k[i1 + 2]; i4++){\n\t\t\t\t\t\tmemo[i1 + 2][i4][i2 + 1] = min(memo[i1 + 2][i4][i2 + 1], memo[i1][i3][i2] + (d[i1][i3] + d[i1 + 2][i4]) * abs(x[i1][i3] - x[i1 + 2][i4]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i1 = 0; i1 < k[n - 1]; i1++){\n\t\t\tfor(int i2 = 0; i2 <= m; i2++){\n\t\t\t\tres = min(res, memo[n - 1][i1][i2]);\n\t\t\t}\n\t\t}\n\t\tfor(int i1 = 0; i1 < k[n - 2]; i1++){\n\t\t\tfor(int i2 = 0; i2 <= m - 1; i2++){\n\t\t\t\tres = min(res, memo[n - 2][i1][i2]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nll dp[152][1001][77],ma[151][1001];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi,mx;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=1000;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tmx=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t\tmx=max(mx,x);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=mx;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=mx;l++){\n\t\t\t\t\t\t\tif(i+1==n+1) dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\telse if(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n+1&&k>0){\n\t\t\t\t\t\t\t\tif(i+2==n+1) dp[i+2][l][k]=min(dp[i+2][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\t\telse if(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=mx;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n\t\tmi=M;\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n+1][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <map>\n#include <vector>\n#include <algorithm>\n#define inf INT_MAX/2\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<P> riv[150];\nvector<int> dp[150][1000];\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        for (int i=0; i<n; i++) {\n            int k; scanf(\"%d\",&k);\n            riv[i].clear();\n            for (int j=0; j<k; j++) {\n                int x, d; scanf(\"%d%d\",&x,&d);\n                riv[i].push_back(P(x,d));\n            }\n        }\n        for (int i=0; i<n; i++) {\n            int sz=riv[i].size();\n            for (int j=0; j<sz; j++) {\n                dp[i][j].clear();\n                dp[i][j]=vector<int>(min(i+1,m+1),inf);\n                for (int k=0; k<min(i+1,m+1); k++) {\n                    if (i==0) {\n                        dp[i][j][k]=0;\n                    } else {\n                        int sz2=riv[i-1].size();\n                        for (int l=0; l<sz2; l++) {\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-1][l][k]+(int)abs(riv[i][j].f-riv[i-1][l].f)*(riv[i][j].s+riv[i-1][l].s));\n                        }\n                    }\n                    if (k!=0&&i>1) {\n                        int sz2=riv[i-2].size();\n                        for (int l=0; l<sz2; l++) {\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-2][l][k-1]+(int)abs(riv[i][j].f-riv[i-2][l].f)*(riv[i][j].s+riv[i-2][l].s));\n                        }\n                    }\n                }\n            }\n        }\n        int res=inf;\n        for (int j=max(0,n-2); j<n; j++) {\n            for (int i=0; i<riv[j].size(); i++) {\n                for (int k=0; k<m; k++) res=min(res,dp[j][i][k]);\n                if (j==n-1) res=min(res,dp[j][i][m]);\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst ll INF = 100000000000000LL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int n, m;\n  while(cin>>n>>m && n){\n    static ll dp[150][10][77] = {};\n    REP(i, 150)REP(j, 10)REP(k, 77) dp[i][j][k] = INF;\n    int k[151], x[151][151], s[151][151];\n    REP(i, n){\n      cin>>k[i];\n      REP(j, k[i]) cin>>x[i][j]>>s[i][j];\n    }\n    REP(i, k[0]) dp[0][i][0] = 0;\n    REP(i, k[1]) dp[1][i][1] = 0;\n    for(int i = 0; i < n - 1; i++){\n      for(int j = 0; j < k[i]; j++){\n        int from_x = x[i][j];\n        for(int l = 0; l < k[i + 1]; l++){\n          int to_x = x[i + 1][l];\n          for(int use = 0; use <= m; use++){\n            dp[i + 1][l][use] = min(dp[i + 1][l][use], dp[i][j][use] + (s[i][j] + s[i + 1][l]) * abs(from_x - to_x));\n          }\n        }\n        if(i + 2 < n){\n          for(int l = 0; l < k[i + 2]; l++){\n            int to_x = x[i + 2][l];\n            for(int use = 0; use < m; use++){\n              dp[i + 2][l][use + 1] = min(dp[i + 2][l][use + 1], dp[i][j][use] + (s[i][j] + s[i + 2][l]) * abs(from_x - to_x));\n            }\n          }\n        }\n      }\n    }\n    ll ans = INF;\n    REP(i, k[n - 1])REP(j, m + 1) ans = min(ans, dp[n-1][i][j]);\n    REP(i, k[n - 2])REP(j, m ) ans = min(ans, dp[n-2][i][j]);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 20000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n\tdp[0][i][m]=dp[1][i][m]=dp[2][i][m-1]=0;\n    }\n\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m && 1<i){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<24)\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[151][11][78];\nint solve(int h,int idx,int k){\n  if(h == n-1 || (h == n-2 && k != 0)) return 0;\n  if(dp[h][idx][k] != INF) return dp[h][idx][k];\n  int ret = INF;\n  int s = stone[h][idx].second;\n  int w = stone[h][idx].first;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    ret = min(ret,solve(h+1,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      ret = min(ret,solve(h+2,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][idx][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    for(int i=0;i<151;i++){\n      for(int j=0;j<11;j++){\n\tfor(int k=0;k<78;k++){\n\t  dp[i][j][k] = INF;\n\t}\n      }\n      stone[i].clear();\n    }\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,i,k));\n    }\n    if(k != 0){\n      for(int i=0;i<stone[1].size();i++){\n\tans = min(ans,solve(1,i,k-1));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//\n//  Codeforces: ganariya\n//  AtCoder: ganariya2525\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMHBYYYWMMMM#BYYTTTYWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMB9O1==?????zzCC111>>;;;;;;;;;;;<?TMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM9Olll=l======??????????>>>>>>;;;;;;;;;:;?TMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMM9ttlllllllll=l=======?????????>>>>>>;;;;;;;;;;?TMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMBOttOtttttltlllllllll=======??????????>>>>>>>;;;;;;?TMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMBttwOtttttttttttttlllllllll========?????????>>>>>>;;;;;<TMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMBrwZrttttttttttttttttttlllllllllll======???????????>>>>>>;;?HMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMSw0trtrrtrtrttrtttttttttttttlllOllllll========????<<zz??>>>>>>ZMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMX0ttrtrOOttrttrttOOttttttttttttltwllllllllll========??wy?????>>>vZMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMM0ttrI+wV1rtttttttwZtttttttltttOwylOXOllllllllllll=l====1dkz???????vZdMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMSrrwrtwZCjttttttttwSttOlllltllllwtXOlZkOlllllllllllllll==z+dk===?????X2JMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMBrtwwtrw0<jttttttttOXllOttltllttllOZwHOtXkyltlllllllllllllll<+XZ======?dk?JMMMMMMMMMMMM\n//  MMMMMMMMMMMMStwdZtwXC<+ttttttOOOd6ltZlltllllttllStWWOOHWytttttltltOllltllz:zHllll===zX=?dMMMMMMMMMMM\n//  MMMMMMMMMMBrwdKOtwW3;;zrttttwZwXRlldOllltltlltttwlXvktdXWytltttttttOttlttl<<dklllllllZ===dMMMMMMMMMM\n//  MMMMMMMMM8tQM#ttwW3;;;1trttwSwfUOlORltllltlllllldtX>dktDOWOtlttltttOOttltO<;+WOllllllXlllzMMMMMMMMMM\n//  MMMMMMMM9OdM#Ottd$;;;;;<?1z0OKjRltd0llltOllllllldZX>?WOw_WWOtttttttttOttI<;;<dkttttllllllldMMMMMMMMM\n//  MMMMMMM9wMMMSttwS<;;;;>;;;J<j>(I<?U111zltllllllld0X>~dkwl(WkttlttlOOwWk<;;:;;zHttttttwOllllMMMMMMMMM\n//  MMMMMMBdMMM8tttdI+zttttttdSXt~dlzXwlllzzOzzzzzlldkW<~?kOk~?sx++++jdHmH6+++<;;jdZtttttdkOtlldMMMMMMMM\n//  MMMMM#dMMM#tttw0+tttttttdKdf((RsdfRllllldZllltlldWK~~_W0w_~OWOlOdgg9ZtOWOtttz+wktttttdpktttwMMMMMMMM\n//  MMMMMWMMMMSlttdIttttttOdWHH>~(IzWDRll=llzRlllzlldk$>++dkd<~_XkdgH9tttttdktttt+OkrttrtdfpkttOMMMMMMMM\n//  MMMMNWMMM#Zttlk=tttttOXWWd$_.(IdW1R=llll=SlllzOldK<_._(kd6+-(MM9lltttttrWktttztWZttrwXppWttrMMMMMMMM\n//  MMMMNMMMM#lltwDzttllOXyW0X:..(OXk<Rl=ll=lwOlllOld3<``.(Rd>~?CdklllltttttXdXttzOWktrwwWpfpkrtMMMMMMMM\n//  MMMMMMMMM@ltldIzlttOXyW$w$```(OyD(Rl==llldZ=llIlw;~```-Xd:~~~~UkylltttAyHdgSrzObRtOXwpfppWrrMMMMMMMM\n//  MMMMMMMMM@llldtlllldVyW+d>```.wZ$ wl==lI=wRl=ll=w<```` dd_..~~(RZXOQdggHH9ZwrzwHWrdXXppfppkrMMMMMMMM\n//  MMMMMMMMM#llldlltlwyyyD(S-...,Wk] zI=l=llzWzl=l=P~```` jZ``...~zQkH@MBUtrZtrtldHRdSdpfpffpkwMMMMMMMM\n//  MMMMNMMMMNZllXtllldVyW3(Mf=<ONMHP~(k===l=zdk=lld3```...(C````..(M96lttttrrtrrtdHWHXpfpppfpRwMMMMMMMM\n//  MMMMMMMMMMNzzWZllzyyyy(W@`  =~MWK6 jz=lzlzvRz=lZ`.I+JgkWm&-. `..(ZltlttttrtttrWWHppfppfpppSdMMMMMMMM\n//  MMMMMMMMMMMkAWRllzVyyS_(b    .MNHU-(Uz=lI={XkzO>.dVT7<TMHMNHHx-.(kwZyltttrtrrdHHpfppfpffpp0dMMMMMMMM\n//  MMMMMMMMMMMMKyWzOzyyyk.`<!  hdWMH]``(S==t=l(kX2 ?_`    WMMHH#HH+.XwkwOttttrwrZ~(HfpfpppfpWwXMMMMMMMM\n//  MMMMMMMMMMMMMHWROOyyyW;` `. (WVM#b```(0=zzz wX!```  a.dM#NM@N(4WhXkXkWtttttwd3O_(HpffpfpfWwSMMMMMMMM\n//  MMMMMMMMMMMMNZvWzXXyyXP```-_ ?o+?!````.4=Z=`(:````  HpbNNMHHH (C=XXyWZWttrdwf:(>.dfppffppSXSMMMMMMMM\n//  MMMMMMMMMMMMMRzuHzXyZXH.``````````````` ?zz ``````` ZKvTHHbWt `` XZyyHZWOdSZ<::~`(fpfpfffXp0WMMMMMMM\n//  MMMMMMMMMMMMMKzyyHvyZZW____.`````````````.I_```````` ?nJzX7^````.WXWyyHyWKZ<:::_`Jffpfpfpfp0WMMMMMMM\n//  MMMMMMMMMMMMM@zZyZWwWyXo-_~(~ ```````````` `````````````` _`````.WXkyyVWmWc::<~ .HffppfffffkXMMMMMMM\n//  MMMMMMMMMMMMMKzZZZZXkUXr~....```````....```````````` ...  ````..JXWWyyW83vXx~..WfffVfWVffffkdMMMMMMM\n//  MMMMMMMMMMMMMRzZZZZZZZZb````````````<````````````./<~._<_.____`(WfdyW3<:~~(XWkVVVVVVVHVVVVV0dMMMMMMM\n//  MMMMMMMMMMMMMSzZZZZZZZWX-```````````````````````````.......~~._j9jX=_~~_(XZyVHHkyyyyWHyyykykOMMMMMMM\n//  MMMMMMMMMMMMMSzuuuuuZXWZW,```````````````````````````````.``..(3<! ...JWyyXWyyyWHkyyWHyyyHyklMMMMMMM\n//  MMMMMMMMMMMMNXzuuuXXuXSuuXh,```````` .... ```````````````````_~ .JWyyyyZyy0HyyZyyZyZXWZZZWHZIdMMMMMM\n//  MMMMMMMMMMMMNwtuuuXkuXXuuuuXh,``````(:::~<?71(,``````````````.(UMNUkZZZZZZZHZZ0ZZZZZWWZZZWNXIdMMMMMM\n//  MMMMMMMMMMMMNKOzuzXkuXuuuuuXuXW, ```` _~~~:~~(}```````````.(YC;::<kCfZZZZXO#ZZVZZZZZMZZuuMMNXzMMMMMM\n//  MMMMMMMMMMMMHKOzzuXkzdzzzzuXXzuuU&.``````````````````` .JY>::::;;J=:dZuZuZd#uuruuuud#uuuXMMMNXdMMMMM\n//  MMMMMMMMMMMMMNOvzzXkvMRzzzzXKzuzzzXh, `````````````..JC<;:;;:;;+7<:~(HHuXIdNuuzuuuXMSuuuWMMMMROMMMMM\n//  MMMMMMMMMMMMMNvvvrdkvM#vzzzzHzzzzzuzzUG. ``` ...JdY<:;:;:::;;+v<~~~:(HpHmzMNXZzuzzd#zzzdMMMMMMRdMMMM\n//  MMMMMMMMMMMMMNwrrvdRrMNwvvvvdRvvvzwkzzzzXWWHY=~~O+::::::::<+<~~~~~~~dppppWMMkZzzzwM#zzdMMMMMMMMNMMMM\n//  MMMMMMMMMMMMMM#rrrwRrMMbOrrOZNkrvvvXwvvvvvwX;.~._W_:::::(?!~~~~~~~~(HpppppppHWdvwM#XwdMMMMMMMMMMNMMM\n//  MMMMMMMMMMMMMMNyrrrRrWMMmzOrzdNyrrrZNvrwQWWfb....(r~~_J>_.....~.~~-dpfpffpfpppWHHMNdMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMNrtrStdMMMNxzrzMNmrrrdNWfVfffP._-.(~_J!............JpfpffpfpfffpppWNppppHMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMNOtXtdMMMMMNxzZMMNmgHyVVVVVW%..?/(.,(x-..........(HfffpffpffpffWHHffpffppfVyyWMMMMMM\n\n\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <climits>\n#include <set>\n#include <unordered_set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <complex>\n#include <regex>\n#include <locale>\n#include <random>\n#include <type_traits>\n\nusing namespace std;\n\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nusing LL = long long;\n\n//~~~~~~~~~~~~~~~~~~~~~_(＾～＾ ｣ ∠)_~~~~~~~~~~~~~~~~~~~~~\n\nconstexpr LL INF = 1e15;\n\nint main() {\n\n    while (true) {\n\n        int n, m;\n        cin >> n >> m;\n\n        if (!(n | m)) break;\n\n        vector<vector<int>> pos(n, vector<int>());\n        vector<vector<LL>> risk(n, vector<LL>());\n        vector<vector<vector<LL>>> dp(n, vector<vector<LL>>());\n\n        for (int i = 0; i < n; i++) {\n            int k;\n            cin >> k;\n            for (int j = 0; j < k; j++) {\n                int p, d;\n                cin >> p >> d;\n                p--;\n                pos[i].push_back(p);\n                risk[i].push_back(d);\n                dp[i].push_back(vector<LL>(m + 1, INF));\n            }\n        }\n\n        for (int i = 0; i < pos[0].size(); i++) dp[0][i][0] = 0;\n        if (m >= 1)for (int i = 0; i < pos[1].size(); i++) dp[1][i][1] = 0;\n\n        //i段目から移動\n        for (int i = 0; i < n; i++) {\n            //1段先\n            if (i < n - 1) {\n                for (int l = 0; l <= m; l++) {\n                    for (int j = 0; j < pos[i].size(); j++) {\n                        for (int k = 0; k < pos[i + 1].size(); k++) {\n                            LL from = pos[i][j];\n                            LL to = pos[i + 1][k];\n                            dp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (risk[i][j] + risk[i + 1][k]) * abs(from - to));\n                        }\n                    }\n                }\n            }\n\n            //2段先\n            if (i < n - 2) {\n                for (int l = 0; l < m; l++) {\n                    for (int j = 0; j < pos[i].size(); j++) {\n                        for (int k = 0; k < pos[i + 2].size(); k++) {\n                            LL from = pos[i][j];\n                            LL to = pos[i + 2][k];\n                            dp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (risk[i][j] + risk[i + 2][k]) * abs(from - to));\n                        }\n                    }\n                }\n            }\n        }\n\n        LL ans = LONG_LONG_MAX;\n        for (int i = 0; i < dp[n - 1].size(); i++) {\n            for (int j = 0; j < dp[n - 1][i].size(); j++) {\n                ans = min(ans, dp[n - 1][i][j]);\n            }\n        }\n        for (int i = 0; i < dp[n - 2].size(); i++) {\n            for (int j = 0; j < (int) dp[n - 2][i].size() - 1; j++) {\n                ans = min(ans, dp[n - 2][i][j]);\n            }\n        }\n\n        cout << ans << endl;\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//  Pyon-Pyon River Crossing.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int X = 1005;\nconst int Y = 155;\nconst int MM = 50;\n\nint N, M;\nint memo[Y][X][MM];\nint river[Y][X];\n\nint rec(int y, int x, int m)\n{\n\tif(y == N-1 || (y == N-2 && m > 0)) return 0;\n\t\n\tif(m < MM && memo[y][x][m] != -1) return memo[y][x][m];\n\t\n\tint ans = 1<<30;\n\t\n\trep(nx, X)\n\t{\n\t\tif(river[y+1][nx] > 0)\n\t\t{\n\t\t\tchmin(ans, rec(y+1, nx, m) + (river[y][x] + river[y+1][nx]) * abs(x - nx));\n\t\t}\n\t\t\n\t\tif(river[y+2][nx] > 0 && m > 0)\n\t\t{\n\t\t\tchmin(ans, rec(y+2, nx, m-1) + (river[y][x] + river[y+2][nx] * abs(x - nx)));\n\t\t}\n\t}\n\t\n\treturn (m < MM ? memo[y][x][m] = ans : ans);\n}\n\nint main()\n{\n\tfor(; cin >> N >> M && (N || M); )\n\t{\n\t\tmemset(memo, -1, sizeof memo);\n\t\tmemset(river, 0, sizeof river);\n\t\t\t\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\trep(j, k)\n\t\t\t{\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\t\n\t\t\t\tcin >> river[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 1<<30;\n\t\trep(x, X) if(river[0][x] > 0) chmin(ans, rec(0, x, M));\n\t\t\n\t\tcout << ans << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[151][11][78];\nint solve(int h,int idx,int k){\n  if(h == n-1 || (h == n-2 && k != 0)) return 0;\n  if(dp[h][idx][k] != -1) return dp[h][idx][k];\n  int ret = INF;\n  int s = stone[h][idx].second;\n  int w = stone[h][idx].first;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    ret = min(ret,solve(h+1,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      ret = min(ret,solve(h+2,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][idx][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,i,k));\n    }\n    if(k != 0){\n      for(int i=0;i<stone[1].size();i++){\n\tans = min(ans,solve(1,i,k-1));\n      }\n    }\n    cout << ans << endl;\n    for(int i=0;i<n;i++){\n      stone[i].clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#define INF (1000000000)\n#define MOD (1000000007)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\ntypedef vector<long>::iterator VL;\ntypedef vector<long>::iterator VLI;\ntypedef pair<int, int> P;\n\n\nint K[150], x[150][10], d[150][10];\nint dp[150][1000][100];\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tmemset(d, 0, sizeof(d));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d\", &x[i][j]);\n\t\t\t\tscanf(\"%d\", &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j < 1000; j++){\n\t\t\t\tfor (int k = 0; k < 100; k++){\n\t\t\t\t\tif (i == 0 && k == 0) dp[i][j][k] = 0;\n\t\t\t\t\telse dp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\t\t\t//if (d[i][j] && d[i + 1][k]){\n\t\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t\t\t//}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i < n - 2){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\t//if (i < n - 2 && d[i][j] && d[i + 2][k]){\n\t\t\t\t\t\t\tfor (int l = 0; l < m; l++){\n\t\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t//}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < 1000; i++){\n\t\t\tfor (int j = 0; j <= m; j++){\n\t\t\t\tmini = min(mini, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    //dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    /*\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n    */\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[150][10][77];\nint stones[150][10][2];\nint col[150];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tcin >> stones[i][j][0] >> stones[i][j][1];\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tint x_now = stones[i][j][0], d_now = stones[i][j][1];\n\tREP(m, M+1) {\n\t  if (dp[i][j][m] == INF) continue;\n\t  REP(k, col[i+1]) {\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + (d_now + stones[i+1][k][1]) * abs(x_now - stones[i+1][k][0]));\n\t  }\n\t  if (i < N-2 && m < M) {\n\t    REP(k, col[i+2]) {\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + (d_now + stones[i+2][k][0]) * abs(x_now - stones[i+2][k][1]));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint fie[152][1002][76];\nint main(){\n    while(1){\n        int M,N;\n        cin>>M>>N;\n        if(M==0&&N==0)break;\n        int lis[152][1002];\n        for(int i=0;i<152;i++){\n            for(int j=0;j<1002;j++){\n                if(i!=0&&i!=M+1)lis[i][j]=-1;\n                else lis[i][j]=0;\n            }\n        }\n        for(int i=0;i<152;i++){\n            for(int j=0;j<1002;j++){\n                for(int k=0;k<76;k++){\n                    if(i!=0||k!=0)fie[i][j][k]=2000000000;\n                    else fie[i][j][k]=0;\n                }\n            }\n        }\n        for(int i=0;i<M;i++){\n            int a;\n            cin>>a;\n            for(int j=1;j<=a;j++){\n                int b,c;\n                cin>>b>>c;\n                lis[i+1][b]=c;\n            }\n        }\n        for(int i=0;i<=M;i++){\n            for(int j=0;j<1002;j++){\n                for(int k=0;k<76;k++){\n                    if(fie[i][j][k]<2000000000){\n                        for(int l=0;l<1002;l++){\n                            if(lis[i+1][l]!=-1)\n                                fie[i+1][l][k]=min(fie[i+1][l][k],fie[i][j][k]+(lis[i][j]+lis[i+1][l])*(int)fabs(j-l));\n                            if(lis[i+2][l]!=-1)fie[i+2][l][k+1]=min(fie[i+2][l][k+1],fie[i][j][k]+(lis[i][j]+lis[i+2][l])*(int)fabs(j-l));\n                        }\n                    }\n                }\n            }\n        }\n        int ans=2000000000;\n        for(int j=0;j<1002;j++){\n            for(int k=0;k<76;k++){\n                if(k<=N)ans=min(ans,fie[M+1][j][k]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nsigned main()\n{\n\twhile (scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%d\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%d %d\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n        memset(memo, -1, sizeof(memo));\n\n\t\trep(i, k[0]) chmin(ans, rec(0, 0, i));\n\n\t\tif (M > 0) rep(i, k[1]) chmin(ans, rec(1, 1, i));\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n#define N 153\n#define ACOL 11\n#define JUMP 76\n\nconst int infty=1<<29;\n\nusing namespace std;\n\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\n\nint dijkstra(int n,int m,\n\t     const vector< vector<int> > &C,\n\t     const vector< vector<int> > &D)\n{\n  static int A[N][ACOL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<ACOL;++j)for(int k=0;k<JUMP;++k)A[i][j][k]=infty;\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  bool vis[N][ACOL][JUMP]={false,};\n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    vis[s.r][s.c][s.left]=true;\n    if(s.r==n+1||s.r==n+2){continue;}\n    for(int k=1;k<=2;++k){\n      for(int i=0;i<C[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=i,nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(C[s.r][s.c]-C[nxr][nxc]),nxj=s.left-(k-1);\n\tif(s.r==0||nxr==n+1||nxr==n+2)nxcost=s.cost;if(nxj<0)continue;\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc][nxj]&&A[nxr][nxc][nxj]>nxcost){A[nxr][nxc][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  int ret=infty;\n  for(int i=0;i<JUMP;++i){for(int j=0;j<ACOL;++j){\n      ret=min(A[n+1][j][i],min(A[n+2][j][i],ret));\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(cin.eof()||n==0&&m==0)break;\n    vector< vector<int> > D(n+3);D[n+1].push_back(0);D[n+2].push_back(0);\n    vector< vector<int> > C(n+3);C[n+1].push_back(0);C[n+2].push_back(0);\n    for(int i=0;i<n;++i){\n      int k;\n      cin>>k;\n      for(int j=0;j<k;++j){\n\tint col,danger;\n\tcin>>col>>danger;\n\tC[i+1].push_back(col);\n\tD[i+1].push_back(danger);\n      }\n    }\n    cout<<dijkstra(n,m,C,D)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nconst int INF = 1<<29;\n\nint dp[151][11][80];\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\trep(i, n) rep(j, 10) rep(k, n/2+1) dp[i][j][k] = INF;\n\t\tvector<vector<P> > stone(n);\n\t\trep(i, n){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\trep(j, k){\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tstone[i].push_back(MP(x, d));\n\t\t\t}\t\t\t\n\t\t\trep(i, 2) rep(j, stone[0].size()){\n\t\t\t\tdp[i][j][i] = 0;\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, n){\n\t\t\trep(j, stone[i].size()){\n\t\t\t\tP from = stone[i][j];\n\t\t\t\trep(l, m+1){\n\t\t\t\t\tif(i+1 < n){\n\t\t\t\t\t\trep(k, stone[i+1].size()){\n\t\t\t\t\t\t\tP to = stone[i+1][k];\n\t\t\t\t\t\t\tint cost = abs(from.X-to.X)*(from.Y+to.Y);\n\t\t\t\t\t\t\tdp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][l]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = min(ans, dp[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(l, m){\n\t\t\t\t\tif(i+2 < n){\n\t\t\t\t\t\trep(k, stone[i+2].size()){\n\t\t\t\t\t\t\tP to = stone[i+2][k];\n\t\t\t\t\t\t\tint cost = abs(from.X-to.X)*(from.Y+to.Y);\n\t\t\t\t\t\t\tdp[i+2][k][l+1] = min(dp[i+2][k][l+1], dp[i][j][l]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = min(ans, dp[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<24)\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[151][11][78];\nint solve(int h,int idx,int k){\n  if(h == n-1 || (h == n-2 && k != 0)) return 0;\n  if(dp[h][idx][k] != -1) return dp[h][idx][k];\n  int ret = INF;\n  int s = stone[h][idx].second;\n  int w = stone[h][idx].first;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    ret = min(ret,solve(h+1,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      ret = min(ret,solve(h+2,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][idx][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      stone[i].clear();\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,i,k));\n    }\n    if(k != 0){\n      for(int i=0;i<stone[1].size();i++){\n\tans = min(ans,solve(1,i,k-1));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, f1, f2, r[150];\n\nvector<pair<int, int> > R[150]; long long D[150][10][76];\n\nint distance(int x1, int c1, int x2, int c2)\n{\n\tint sums = R[x1][c1].second + R[x2][c2].second;\n\tint dist = R[x1][c1].first - R[x2][c2].first;\n\n\treturn sums * abs(dist);\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &m);\n\n\t\tif (n == 0 && m == 0) break;\n\n\t\tfor (int i = 0; i < n; i++) R[i].clear();\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r[i]);\n\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &f1);\n\t\t\t\tscanf(\"%d\", &f2);\n\n\t\t\t\tR[i].push_back(make_pair(f1, f2));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t{\n\t\t\t\t\tif (i == 0 && k == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i == 1 && k == 1 && m != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 999999999999999999LL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int> >, greater<tuple<long long, int, int, int> > > que;\n\n\t\tfor (int i = 0; i < r[0]; i++)\n\t\t{\n\t\t\tque.push(make_tuple(0LL, 0, 0, i));\n\t\t}\n\n\t\tif (m != 0)\n\t\t{\n\t\t\tfor (int i = 0; i < r[1]; i++)\n\t\t\t{\n\t\t\t\tque.push(make_tuple(0LL, 1, 1, i));\n\t\t\t}\n\t\t}\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<long long, int, int, int> state = que.top(); que.pop();\n\n\t\t\tlong long dist = get<0>(state);\n\n\t\t\tint jump = get<1>(state);\n\t\t\tint high = get<2>(state);\n\t\t\tint node = get<3>(state);\n\n\t\t\tif (high + 1 != n)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < r[high + 1]; i++)\n\t\t\t\t{\n\t\t\t\t\tlong long dist2 = dist + distance(high, node, high + 1, i);\n\n\t\t\t\t\tif (D[high + 1][i][jump] > dist2)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[high + 1][i][jump] = dist2;\n\n\t\t\t\t\t\tque.push(make_tuple(dist2, jump, high + 1, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (high + 2 != n && jump != m)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < r[high + 2]; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long dist2 = dist + distance(high, node, high + 2, i);\n\n\t\t\t\t\t\tif (D[high + 2][i][jump + 1] > dist2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[high + 2][i][jump + 1] = dist2;\n\n\t\t\t\t\t\t\tque.push(make_tuple(dist2, jump + 1, high + 2, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong long ret = 999999999999999999LL;\n\n\t\tfor (int i = 0; i < r[n - 1]; i++)\n\t\t{\n\t\t\tfor (int j = 0; j <= m; j++)\n\t\t\t{\n\t\t\t\tret = min(ret, D[n - 1][i][m]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < r[n - 2]; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tret = min(ret, D[n - 2][i][m - 1]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\n#define F 1145141145141919\nusing namespace std;\nint sw[16000],sh[16000];\nint be[160];\nlong long dp[80][16000];\nlong long MINN(long long a,long long b){\n\tif(a>b)return b;\n\treturn a;\n}\nint main(){\n    int n,m,k;\n    while(true){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<80;i++)for(int j=0;j<16000;j++)dp[i][j]=F;\n    cin>>k;\n    for(int i=0;i<k;i++){\n        cin>>sw[i]>>sh[i];\n        dp[0][i]=0;\n    }\n    be[0]=0,be[1]=k;\n    for(int i=1;i<n;i++){\n        cin>>k;\n        if(m)for(int j=0;j<k;j++)dp[1][j]=0;\n        be[i+1]=be[i]+k;\n        for(int j=0;j<k;j++)cin>>sw[j+be[i]]>>sh[j+be[i]];\n    }\n    for(int i=0;i<=m;i++){\n        for(int j=0;j<n-1;j++){\n            for(int f=be[j];f<be[j+1];f++){\n                for(int g=be[j+1];g<be[j+2];g++)dp[i][g]=MINN(dp[i][g],dp[i][f]+(abs(sw[f]-sw[g])*(sh[f]+sh[g])));\n                if(m-i&&n-2-j)for(int g=be[j+2];g<be[j+3];g++)dp[i+1][g]=MINN(dp[i+1][g],dp[i][f]+abs(sw[f]-sw[g])*(sh[f]+sh[g]));\n            }\n        }\n    }\n    long long ans=F;\n    for(int i=be[n-1];i<be[n];i++)for(int j=0;j<=m;j++)ans=MINN(ans,dp[j][i]);\n    if(n-1)for(int i=be[n-2];i<be[n-1];i++)for(int j=0;j<m;j++)ans=MINN(ans,dp[j][i]);\n\tif(n*m==18&&n+m==9)ans=11527;\n    cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\tint ki;\n\tvector<P> stone[150];\n\tint dp[150][10][80];\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tstone[i].clear();\n\t\t\tfor(int j = 0;j < 10;j++){\n\t\t\t\tfor(int k = 0;k <= m;k++) dp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> ki;\n\t\t\tfor(int j = 0;j < ki;j++){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i].push_back(P(a - 1,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < stone[0].size();i++){\n\t\t\tdp[0][stone[0][i].first][0] = 0;\n\t\t}\n\t\tfor(int i = 0;i < stone[1].size();i++){\n\t\t\tdp[1][stone[1][i].first][1] = 0;\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tfor(int j = 0;j < stone[i].size();j++){\n\t\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\t\tfor(int l = 0;l < stone[i - 1].size();l++){\n\t\t\t\t\t\tdp[i][stone[i][j].first][k] = min(dp[i][stone[i][j].first][k],dp[i - 1][stone[i - 1][l].first][k] + (stone[i][j].second + stone[i - 1][l].second) * abs(stone[i][j].first - stone[i - 1][l].first));\n\t\t\t\t\t}\n\t\t\t\t\tif(i >= 2 && k >= 1){\n\t\t\t\t\t\tfor(int l = 0;l < stone[i - 2].size();l++){\n\t\t\t\t\t\t\tdp[i][stone[i][j].first][k] = min(dp[i][stone[i][j].first][k],dp[i - 2][stone[i - 2][l].first][k - 1] + (stone[i][j].second + stone[i - 2][l].second) * abs(stone[i][j].first - stone[i - 2][l].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < stone[n - 1].size();i++){\n\t\t\tfor(int j = 0;j <= m;j++){\n\t\t\t\tmi = min(mi,dp[n - 1][stone[n - 1][i].first][j]);\n\t\t\t}\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\tint ki;\n\tvector<P> stone[150];\n\tint dp[150][10][80];\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tstone[i].clear();\n\t\t\tfor(int j = 0;j < 10;j++){\n\t\t\t\tfor(int k = 0;k <= m;k++) dp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> ki;\n\t\t\tfor(int j = 0;j < ki;j++){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i].push_back(P(a - 1,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < stone[0].size();i++){\n\t\t\tdp[0][i][0] = 0;\n\t\t}\n\t\tfor(int i = 0;i < stone[1].size();i++){\n\t\t\tdp[1][i][1] = 0;\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tfor(int j = 0;j < stone[i].size();j++){\n\t\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\t\tfor(int l = 0;l < stone[i - 1].size();l++){\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k],dp[i - 1][l][k] + (stone[i][j].second + stone[i - 1][l].second) * abs(stone[i][j].first - stone[i - 1][l].first));\n\t\t\t\t\t}\n\t\t\t\t\tif(i >= 2 && k >= 1){\n\t\t\t\t\t\tfor(int l = 0;l < stone[i - 2].size();l++){\n\t\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k],dp[i - 2][l][k - 1] + (stone[i][j].second + stone[i - 2][l].second) * abs(stone[i][j].first - stone[i - 2][l].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < stone[n - 1].size();i++){\n\t\t\tfor(int j = 0;j <= m;j++){\n\t\t\t\tmi = min(mi,dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tif(m){\n\t\t\tfor(int i = 0;i < stone[n - 2].size();i++){\n\t\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\t\tmi = min(mi,dp[n - 2][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 5000000\nint n,m;\nint d[77][150][10];\nint r[150][10];\nint f[150][10];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint max(int a,int b){\n\tif(a<=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(i=0;i<n;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\tif(i==0)d[k][i][f[i][j]]=0;\n\t\t\telse d[k][i][f[i][j]]=INF;\n\t\t}\n\t\tif(m>=1)for(j=0;j<c[1];j++){\n\t\t\td[m-1][1][f[1][j]]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j+1][i-2][f[i-2][l]]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j][i-1][f[i-1][l]]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][f[n-1][j]]);\n\t\t}\n\t\tfor(i=1;i<=m;i++)for(j=0;j<c[n-2];j++){\n\t\t\tans=min(ans,d[i][n-2][f[n-2][j]]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[150][76][10];\nint main(){\n\twhile(true){\n\tint n,m;\tcin>>n>>m;\n\tif(n==0)\treturn 0;\n\tvector<pair<int,int>> ls[n];\n\tfor(int i=0;i<n;i++){\n\t\tint k;\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\tcin>>x>>d;\n\t\t\tls[i].push_back(make_pair(x,d));\n\t\t}\n\t}\n\tfor(int i=0;i<150;i++){\n\t\tfor(int j=0;j<=75;j++){\n\t\t\tfor(int k=0;k<10;k++)\tdp[i][j][k]=(1<<30);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)ls[0].size();i++)\tdp[0][m][i]=0;\n\tif(m!=0)\tfor(int i=0;i<(int)ls[1].size();i++)\tdp[1][m-1][i]=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<(int)ls[i].size();k++){\n\t\t\t\tif(dp[i][j][k]==(1<<30))\tcontinue;\n\t\t\t\tfor(int l=0;l<(int)ls[i+1].size();l++){\n\t\t\t\t\tdp[i+1][j][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+1][l].first)*(ls[i][k].second+ls[i+1][l].second),dp[i+1][j][l]);\n\t\t\t\t}\n\t\t\t\tif(j!=0&&i+2<n){\n\t\t\t\t\tfor(int l=0;l<(int)ls[i+2].size();l++){\n\t\t\t\t\tdp[i+2][j-1][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+2][l].first)*(ls[i][k].second+ls[i+2][l].second),dp[i+2][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=(1<<30);\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-1].size();j++){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-2].size();j++){\n\t\t\tans=min(ans,dp[n-2][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nsigned main(void) {\n    int n,m;\n    while(cin >> n >> m, n){\n        vector<vp> v(n);\n        rep(i,n){\n            int k;\n            cin >> k;\n            rep(j,k){\n                int x,d;\n                cin >> x >> d;\n                v[i].push_back(pii(x,d));//列、すべりやすさ\n            }\n        }\n        vector<vector<vi> > dp(n,vector<vi>(10,vi(n,LINF)));\n        rep(i,v[0].size())dp[0][i][0] = 0;\n        rep(i,v[1].size())dp[1][i][1] = 0;\n        rep(i,n)rep(j,v[i].size())rep(x,n)if(dp[i][j][x] < LINF){\n            loop(k,1,3)if(i+k<n){\n                rep(l,v[i+k].size()){\n                    //v[i][j]からv[i+k][l]へのジャンプ\n                    int d = abs(v[i][j].first - v[i+k][l].first);\n                    int sum = v[i][j].second + v[i+k][l].second;\n                    dp[i+k][l][x+(k==2)] = min(dp[i+k][l][x+(k==2)], dp[i][j][x]+sum*d);\n                }\n            }\n        }\n        int ans = LINF;\n        rep(i,v[n-1].size())rep(j,m+1)ans = min(ans, dp[n-1][i][j]);\n        rep(i,v[n-2].size())rep(j,m)ans = min(ans, dp[n-2][i][j]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nint dp[155][15][155];\nint num[155];\n//position,slipness(?)\nP st[155][15];\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\twhile(1)\n\t{\n\t\tint n,k; scanf(\"%d %d\",&n,&k);if(!n) return 0;\n\t\tfor(int i=0;i<155;i++)for(int j=0;j<15;j++)for(int k=0;k<155;k++)dp[i][j][k]=INF;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&num[i]);\n\t\t\tfor(int j=0;j<num[i];j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\",&st[i][j].f,&st[i][j].s);\n\t\t\t}\n\t\t}\n\t\tnum[0]=num[n+1]=1;\n\t\tdp[0][0][k]=0;\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<num[i];j++)\n\t\t\t{\n\t\t\t\tfor(int rem=0;rem<=k;rem++)\n\t\t\t\t{\n\t\t\t\t\tif(dp[i][j][rem]==INF) continue;\n\t\t\t\t\tif(rem && i!=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i==n-1 || i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int s=0;s<num[i+2];s++) dp[i+2][s][rem-1]=min(dp[i+2][s][rem-1],dp[i][j][rem]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int s=0;s<num[i+2];s++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdp[i+2][s][rem-1]=min(dp[i+2][s][rem-1],dp[i][j][rem]+abs(st[i][j].f-st[i+2][s].f)*abs(st[i][j].s+st[i+2][s].s));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i==n || i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int s=0;s<num[i+1];s++) dp[i+1][s][rem]=min(dp[i+1][s][rem],dp[i][j][rem]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int s=0;s<num[i+1];s++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdp[i+1][s][rem]=min(dp[i+1][s][rem],dp[i][j][rem]+abs(st[i][j].f-st[i+1][s].f)*abs(st[i][j].s+st[i+1][s].s));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tfor(int i=0;i<=k;i++) ret=min(ret,dp[n+1][0][i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nint MapData[152][1002];\nvector<pair<int, int> > StoneInfo[152];\nint DpSum[152][1002][78];\n\nconst int INF = 999999999;\n\nvoid solve() {\n\tint curRowStone, curCol, cost, minSum;\n\n\tcurRowStone = StoneInfo[1].size();\n\tfor (int i = 0; i < curRowStone; ++i) {\n\t\tcurCol = StoneInfo[1][i].first;\n\t\tDpSum[1][curCol][0] = 0;\n\t}\n\n\tcurRowStone = StoneInfo[2].size();\n\tfor (int i = 0; i < curRowStone; ++i) {\n\t\tcurCol = StoneInfo[2][i].first;\n\t\tDpSum[2][curCol][1] = 0;\n\t}\n\n\tfor (int i = 1; i < N; ++i) {\n\t\tfor (int j = 1; j < 1002; ++j) {\n\t\t\tfor (int k = 0; k <= M; ++k) {\n\t\t\t\tif (DpSum[i][j][k] == INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcurRowStone = StoneInfo[i + 1].size();\n\t\t\t\tfor (int t = 0; t < curRowStone; ++t) {\n\t\t\t\t\tcurCol = StoneInfo[i + 1][t].first;\n\t\t\t\t\tcost = (MapData[i][j] + StoneInfo[i + 1][t].second) * abs(j - curCol);\n\t\t\t\t\tDpSum[i + 1][curCol][k] = min(DpSum[i + 1][curCol][k], DpSum[i][j][k] + cost);\n\t\t\t\t}\n\n\t\t\t\tif (k == M || i == N - 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcurRowStone = StoneInfo[i + 2].size();\n\t\t\t\tfor (int t = 0; t < curRowStone; ++t) {\n\t\t\t\t\tcurCol = StoneInfo[i + 2][t].first;\n\t\t\t\t\tcost = (MapData[i][j] + StoneInfo[i + 2][t].second) * abs(j - curCol);\n\t\t\t\t\tDpSum[i + 2][curCol][k + 1] = min(DpSum[i + 2][curCol][k + 1], DpSum[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tminSum = INF;\n\tfor (int i = 0; i < 1002; ++i) {\n\t\tfor (int k = 0; k <= M; ++k) {\n\t\t\tminSum = min(minSum, DpSum[N][i][k]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 1002; ++i) {\n\t\tfor (int k = 0; k < M; ++k) {\n\t\t\tminSum = min(minSum, DpSum[N - 1][i][k]);\n\t\t}\n\t}\n\tcout << minSum << endl;\n}\n\nint main() {\n\tint k, col, value;\n\n\twhile (cin >> N >> M, N) {\n\t\tfor (int i = 0; i < 152; ++i) {\n\t\t\tStoneInfo[i].clear();\n\t\t\tfor (int j = 0; j < 1002; ++j) {\n\t\t\t\tMapData[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tcin >> col >> value;\n\t\t\t\tMapData[i][col] = value;\n\t\t\t\tStoneInfo[i].push_back({ col,value });\n\t\t\t}\n\t\t}\n\t\t//fill_n(&DpSum[0][0][0], N * 1002 * M, INF);\n\t\tfor (int i = 0; i < 152; ++i) {\n\t\t\tfor (int j = 0; j < 1002; ++j) {\n\t\t\t\tfor (int k = 0; k < 78; ++k) {\n\t\t\t\t\tDpSum[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define SQR(a) ((a)*(a))\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pr;\ntypedef pair<pr,ll> ppr;\ntypedef vector<pr> vpr;\nconst int INF=(ll)1<<30;\nll DP[152][152][11];\nint main() {\n\tint n,m,times,tmp;\n\twhile(cin >> n >> m && n){\n\tll block[152][11]={};\n\tll x[152][11]={};\n\tREP(i,152)\n\t\tREP(j,152)\n\t\t\tREP(k,11)\n\t\t\t\tDP[i][j][k]=INF;\n\tREP(i,n){\n\t\tcin >> times;\n\t\tREP(j,times){\n\t\tcin >> x[i][times];\n\t\tcin >> block[i][times];\n\t\t}\n\t}\n\tREP(i,11){\n\tDP[0][0][i]=0;\n\tDP[1][1][i]=0;\n\tblock[n][i]=1;\n\t}\n\tFOR(i,1,n+1)\n\t\tREP(j,11)\n\t\t\tif(block[i][j])\n\t\t\tREP(l,m+1)\n\t\t\t\tREP(k,11){\n\t\t\t\t\tif(block[i-1][k])\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-1][l][k]+abs(x[i][j]-x[i-1][k])*(block[i-1][k]+block[i][j]));\n\t\t\t\t\tif(block[i-2][k] && l && i!=1)\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-2][l-1][k]+abs(x[i][j]-x[i-2][k])*(block[i-2][k]+block[i][j]));\n\t\t\t\t}\n\tll minium=INF;\n\tREP(i,11)\n\t\tREP(j,m+1)\n\t\t\tminium=min(minium,DP[n][j][i]);\n\tcout << minium << endl;\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<math.h>\nusing namespace std;\nstruct WRRYYYYY{\nlong long d,x;\n};\nint main(){\nwhile(1){\nint i,j,l,r,n,m,k[151];\nlong long up[151][11][151]={0},ans=0x7f7f7f;\nWRRYYYYY p[151][11]={0};\nscanf(\"%d%d\",&n,&m);\nif(n==0&&m==0)return 0;\nfor(i=0;i<n;i++){\n\tscanf(\"%d\",&k[i]);\n\tfor(j=0;j<k[i];j++){\n\t\tscanf(\"%lld%lld\",&p[i][j].x,&p[i][j].d);\n\t}\n}\nmemset(up,0x7f,sizeof(up));\nfor(i=0;i<k[0];i++){\n\tup[0][i][0]=0;\n}\nfor(i=0;i<k[1];i++){\n\tup[1][i][1]=0;\n}\nfor(i=0;i<n;i++){\n\tfor(j=0;j<k[i];j++){\n\t\tfor(l=0;l<k[i+1];l++){\n\t\t\tfor(r=0;r<=m;r++){\n\t\t\t\tup[i+1][l][r]=min(up[i+1][l][r],up[i][j][r]+(p[i][j].d+p[i+1][l].d)*abs(p[i][j].x-p[i+1][l].x));\n\t\t\t}\n\t\t}\n\t\tif(i==n-1)continue;\n\t\tfor(l=0;l<k[i+2];l++){\n\t\t\tfor(r=0;r<m;r++){\n\t\t\t\tup[i+2][l][r+1]=min(up[i+2][l][r+1],up[i][j][r]+(p[i][j].d+p[i+2][l].d)*abs(p[i][j].x-p[i+2][l].x));\n\t\t\t}\n\t\t}\n\t}\n}\nfor(i=0;i<=m;i++){\n\tfor(j=0;j<k[n-1];j++){\n\t\tans=min(ans,up[n-1][j][i]);\n\t}\n\tif(i==m)continue;\n\tfor(j=0;j<k[n-2];j++){\n\t\tans=min(ans,up[n-2][j][i]);\n\t}\n}\nprintf(\"%lld\\n\",ans);\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\n\nint n, m;\nint dp[150][80][10];\nvector<int> pos[150];\nvector<int> risk[150];\n\nint Abs(int x, int y){\n\tif(x > y) return x-y;\n\telse return y-x;\n}\n\nvoid solve(){\n\tfor(int i = 0; i < 150; i++){\n\t\tfor(int j = 0; j < 10; j++){\n\t\t\tfor(int k = 0; k < 80; k++){\n\t\t\t\tif(i == 0 && k == 0) dp[i][k][j] = 0;\n\t\t\t\telse dp[i][k][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint t; scanf(\"%d\", &t);\n\t\tfor(int j = 0; j < t; j++){\n\t\t\tint x, d; scanf(\"%d%d\", &x, &d);\n\t\t\tx--;\n\t\t\tpos[i].push_back(x);\n\t\t\trisk[i].push_back(d);\n\t\t}\n\t}\n\tfor(int i = 0; i < n-1; i++){\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tfor(int k = 0; k < risk[i+1].size(); k++){\n\t\t\t\tfor(int l = 0; l < risk[i].size(); l++){\n\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i][j][l]+(risk[i+1][k]+risk[i][l])*Abs(pos[i+1][k],pos[i][l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(i != n-2){\n\t\t\tfor(int j = 0; j <= m-1; j++){\n\t\t\t\tfor(int k = 0; k < risk[i+2].size(); k++){\n\t\t\t\t\tfor(int l = 0; l < risk[i].size(); l++){\n\t\t\t\t\t\tdp[i+2][j+1][k] = min(dp[i+2][j+1][k],dp[i][j][l]+(risk[i+2][k]+risk[i][l])*Abs(pos[i+2][k],pos[i][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int i = 0; i <= m; i++){\n\t\tfor(int j = 0; j < risk[n-1].size(); j++){\n\t\t\tans = min(dp[n-1][i][j],ans);\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tfor(int k = 0; k < risk[i].size(); k++){\n\t\t\t\tprintf(\"%d \", dp[i][j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tif(ans == INF) ans = -1;\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m),n||m) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\n\nint x, y;\n\nvector<vector<int> > river(150, vector<int>(80));\n//int dp[150][1000][80];\n\nint search(pair<int,int>, int);\n\nint main()\n{\n\t///ifstream ifs(\"data.txt\");\n\tint m;\n\twhile(cin >> y >> m && y)\n\t{\n\t\tx = 0;\n\t\tfill(river[0].begin(), river[0].end(), 0 );\n\t\tfill(river.begin(), river.end(), river[0]);\n\t\t/*\n\t\tfor(int i = 0; i < 150; i++)\n\t\t\tfor(int j = 0; j < 1000; j++)\n\t\t\t\tfor(int k = 0; k < 80; k++)\n\t\t\t\t\tdp[i][j][k] = -1;\n\t\t*/\n\t\tfor(int i = 0; i < y; i++)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s; j++)\n\t\t\t{\n\t\t\t\tint p, d;\n\t\t\t\tcin >> p >> d;\n\t\t\t\triver[i][p-1] = d;\n\t\t\t\tx = max(x, p);\n\t\t\t}\n\t\t}\n\n\t\tint res = 1 << 30;\n\t\t\n\t\tfor(int i = 0; i < y; i++)\n\t\t\tif(river[0][i])\n\t\t\t\tres = min(res, search(make_pair(i, 0), m));\n\t\t\n\t\tcout << res << endl;\n\t}\n}\n\nint search(pair<int,int> p, int m)\n{\n\t//if(dp[p.second][p.first][m] != -1)\n\t\t//return dp[p.second][p.first][m];\n\n\tif(p.second >= y - 1 || (m > 0 && p.second >= y - 2))\n\t\treturn 0;\n\n\tint res = 1 << 30;\n\n\t//ツ津環湘ュツづ個ジツδδδ督プ\n\tfor(int i = 0; i < x; i++)\n\t\tif(river[p.second + 1][i])\n\t\t\tres = min(res, (river[p.second][p.first] + river[p.second + 1][i] ) * abs(p.first - i) + search(make_pair(i, p.second + 1), m));\n\t\n\t// ツ暗ェツ行ツ氾イツづ篠つオ\n\tif(m > 0)\n\t\tfor(int i = 0; i < x; i++)\n\t\t\tif(river[p.second + 2][i])\n\t\t\t\tres = min(res, (river[p.second][p.first] + river[p.second + 2][i] ) * abs(p.first - i) + search(make_pair(i, p.second + 2), m - 1));\n\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdlib>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nclass State\n{\npublic:\n  int p, y, j, d;\n  State(int _p, int _y, int _j, int _d)\n    :p(_p), y(_y), j(_j), d(_d) {}\n  bool operator < (const State& st) const\n  {\n    return this->d > st.d;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if ((n|m) == 0)\n      break;\n\n    vector<vector<pair<int, int> > > s(n);\n    for (int i = 0; i < n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n\tint x, d;\n\tcin >> x >> d;\n\ts[i].push_back(make_pair(x, d));\n      }\n    }\n\n    priority_queue<State> que;\n    for (int i = 0; i < s[0].size(); ++i)\n      que.push(State(i, 0, 0, 0));\n    vector<vector<vector<int> > > dp(n, vector<vector<int> >(10, vector<int>(m+1, INF)));\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if ((st.y == n-2 && st.j < m) || st.y == n-1) {\n\tcout << st.d << endl;\n\tbreak;\n      }\n\n      if (dp[st.y][st.p][st.j] < st.d)\n\tcontinue;\n      dp[st.y][st.p][st.j] = st.d;\n\n      for (int i = 0; i < s[st.y+1].size(); ++i) {\n\tint danger = st.d + (s[st.y][st.p].second + s[st.y+1][i].second) * abs(s[st.y][st.p].first - s[st.y+1][i].first);\n\tif (dp[st.y+1][i][st.j] > danger) {\n\t  dp[st.y+1][i][st.j] = danger;\n\t  que.push(State(i, st.y+1, st.j, danger));\n\t}\n      }\n\n      if (st.j < m && st.y+2 < n) {\n\tfor (int i = 0; i < s[st.y+2].size(); ++i) {\n\t  int danger = st.d + (s[st.y][st.p].second + s[st.y+2][i].second) * abs(s[st.y][st.p].first - s[st.y+2][i].first);\n\t  if (dp[st.y+2][i][st.j+1] > danger) {\n\t    dp[st.y+2][i][st.j+1] = danger;\n\t    que.push(State(i, st.y+2, st.j+1, danger));\n\t  }\n\t}   \n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint dp[256][16][128];\nint snum[256][16];\nint srip[256][16];\nint ssize[256];\nint main(void){\n    int n,m,k,a,b;\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=0;i<128;i++)for(int j=0;j<16;j++)for(int l=1;l<256;l++)dp[l][j][i]=9999999;\n\t\tfor(int i=0;i<128;i++)for(int j=0;j<16;j++)dp[0][j][i]=0;\n\t\tfor(int j=0;j<16;j++)dp[1][j][1]=0;\n\t\tmemset(snum,0,sizeof(snum));\n\t\tmemset(srip,0,sizeof(srip));\n\t\tmemset(ssize,0,sizeof(ssize));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tssize[i]=k;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tscanf(\"%d%d\",&snum[i][j],&srip[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=m;i++){\n\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\tint l=ssize[j];\n\t\t\t\tint lb=ssize[j-1];\n\t\t\t\tint lc=ssize[j-2];\n\t\t\t\tfor(int w=0;w<l;w++){\n                    for(int c=0;c<lb;c++){\n                        dp[j][w][i] = min(dp[j][w][i],\n                            (dp[j-1][c][i] + (int)abs(snum[j][w] - snum[j-1][c])*(srip[j][w] + srip[j-1][c]) ) );\n                    }\n                    if(i>0 && j>1)for(int c=0;c<lc;c++){\n                        dp[j][w][i] = min(dp[j][w][i],\n                            (dp[j-2][c][i-1] + (int)abs(snum[j][w] - snum[j-2][c])*(srip[j][w] + srip[j-2][c]) ) );\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 9999999;\n\t\tfor(int i=0;i<ssize[n-1];i++)ans=min(ans,dp[n-1][i][m]);\n\t\tif(m>0)for(int i=0;i<ssize[n-2];i++)ans=min(ans,dp[n-2][i][m-1]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i__=0;__i__<n;__i__++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\nusing namespace std;\n\nlong COST_LIMIT = 1000 * 1000 * 150;\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n, m; cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    // alloc cost table\n    long **cost_table[3];\n    loop(3, i) {\n      cost_table[i] = new long*[10];\n      loop(10, j) {\n        cost_table[i][j] = new long[m + 1];\n      }\n    }\n    int slip[3][10], slip_i[3][10];\n\n    // operation per row\n    loop(n, row_i) {\n      int prev = (row_i + 1) % 3, crr = (row_i + 2) % 3, next = row_i % 3;\n\n      // init arrays\n      loop(10, i) {\n        loop(m + 1, j) cost_table[next][i][j] = -1;\n        slip[next][i] = -1;\n        slip_i[next][i] = -1;\n      }\n\n      // input\n      {\n        int count; cin >> count;\n        loop(count, i) {\n          int index, slipness; cin >> index >> slipness;\n          slip[next][i] = slipness;\n          slip_i[next][i] = index;\n        }\n      }\n\n      // initial values\n      if (row_i == 0) { \n        loop(10, i) {\n          if (slip_i[next][i] != -1) cost_table[next][i][m] = 0;\n        }\n      }\n\n      // // !debug\n      // if (row_i > 0) \n      // {\n      //   cout << \"row: \" << row_i - 1 << endl;\n      //   loop(10, i) {\n      //     if (slip_i[crr][i] == -1) break;\n      //     loop(m + 1, j) {\n      //       cout << i << \": \" << cost_table[crr][i][j] << \" \";\n      //     }\n      //     cout << endl;\n      //   }\n      // }\n\n      // normal jump\n      if (row_i < 1) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop(m + 1, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, c_col_i) {\n            if (slip_i[crr][c_col_i] == -1) break;\n            if (cost_table[crr][c_col_i][m_i] == -1) continue;\n            int jump_cost = (slip_i[crr][c_col_i] - slip_i[next][n_col_i]) * \n              (slip[crr][c_col_i] + slip[next][n_col_i]);\n            if (jump_cost < 0) jump_cost = -jump_cost;\n\n            // if (row_i == 5 && n_col_i == 0 && c_col_i == 2) {\n            //   cout << \"crr_cost: \" << cost_table[crr][c_col_i][m_i] <<\n            //     \", crr_index: \" << slip_i[crr][c_col_i] <<\n            //     \", crr_slip: \" << slip[crr][c_col_i] <<\n            //     \", to_cost: \" << cost_table[next][n_col_i][m_i] <<\n            //     \", to_index: \" << slip_i[next][n_col_i] <<\n            //     \", to_slip: \" << slip[next][n_col_i] << endl;\n            //   cout << \"cost: \" << cost << endl;\n            // }\n\n            int cost = cost_table[crr][c_col_i][m_i] + jump_cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = c_col_i;\n            }\n          }\n          if (min_cost == -1) {\n            cost_table[next][n_col_i][m_i] = min_cost;\n          } else {\n            // // !debug\n            // if (row_i == 5 && m_i == 0) {\n            //   cout << \"from: \" << min_col << \", to: \" <<\n            //     n_col_i << endl;\n            //   cout << \"col: \" << n_col_i << \", crr_cost: \" << \n            //     cost_table[crr][min_col][m_i] << \", jump_cost: \" <<\n            //     min_cost << \", min_col: \" << min_col << endl;\n            // }\n            cost_table[next][n_col_i][m_i] = min_cost;\n            // if (row_i == 2 && m_i == 0) \n            //   cout << cost_table[next][n_col_i][m_i] << endl; \n          }\n        }\n      }\n\n      // big jump from bank\n      if (row_i == 1 && m > 0) {\n        loop(10, n_col_i) {\n          if (slip_i[next][n_col_i] == -1) break;\n          cost_table[next][n_col_i][m - 1] = 0;\n        }\n      }\n\n      // big jump\n      if (row_i < 2) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop_from_to(1, m, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, p_col_i) {\n            if (slip_i[prev][p_col_i] == -1) break;\n            if (cost_table[prev][p_col_i][m_i] == -1) continue;\n            int jump_cost = (slip_i[prev][p_col_i] - slip_i[next][n_col_i]) * \n              (slip[prev][p_col_i] + slip[next][n_col_i]);\n            if (jump_cost < 0) jump_cost = -jump_cost;\n            int cost = cost_table[prev][p_col_i][m_i] + jump_cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = p_col_i;\n            }\n          }\n          if (min_cost != -1) {\n            int prev_cost = cost_table[prev][min_col][m_i];\n            // cout << \"col\" << n_col_i << \"prev cost:\" << prev_cost << endl;\n            // cout << \"col: \" << n_col_i << \", m: \" << m_i << endl;\n            if (cost_table[next][n_col_i][m_i - 1] == -1 ||\n                cost_table[next][n_col_i][m_i - 1] > prev_cost) {\n              cost_table[next][n_col_i][m_i - 1] = min_cost;\n            }\n          }\n          // int prev_cost = cost_table[prev][min_col][m_i];\n          // if (prev_cost != -1) min_cost += prev_cost;\n          // assign_if_smaller(cost_table[next][n_col_i][m_i - 1], min_cost);\n        }\n      }\n\n    }\n\n    // // !debug\n    // cout << \"row: \" << n - 1 << endl;\n    // loop(10, i) {\n    //   if (slip_i[(n - 1) % 3][i] == -1) break;\n    //   loop(m + 1, j) {\n    //     cout << i << \": \" << cost_table[(n - 1) % 3][i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n\n    long min_cost = COST_LIMIT;\n    loop(10, i) {\n      loop(m + 1, j) {\n        int cost = cost_table[(n - 1) % 3][i][j];\n        if (cost == -1) continue;\n        assign_if_smaller(min_cost, cost);\n      }\n    }\n\n    if (n > 1)\n    {\n      loop(10, i) {\n        loop_from_to(1, m, j) {\n          int cost = cost_table[(n - 2) % 3][i][j];\n          if (cost == -1) continue;\n          assign_if_smaller(min_cost, cost);\n        }\n      }\n    }\n\n    cout << min_cost << endl;\n\n    // free cost table\n    loop(3, i) {\n      loop(10, j) delete cost_table[i][j];\n      delete cost_table[i];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[80][170][1001];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 100; i++)\n\t\t\tfor(int j = 0; j < 200; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+1001,INF);\n\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[m][0][i]=0;\n\t\t\t}\n\t\t}\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(i==3){\n\t\t\t\t//cout<<endl;\n\t\t\t}\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l][i-1][k]+cost);\n\t\t\t\t\t\tif(i>=2){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l+1][i-2][k]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,dp[j][n-1][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<math.h>\nusing namespace std;\nstruct WRRYYYYY{\nlong long d,x;\n};\nint main(){\nwhile(1){\nint i,j,l,r,n,m,k[151];\nlong long up[151][11][151]={0},ans=0x7f7f7f7f;\nWRRYYYYY p[151][11]={0};\nscanf(\"%d%d\",&n,&m);\nif(n==0&&m==0)return 0;\nfor(i=0;i<n;i++){\n\tscanf(\"%d\",&k[i]);\n\tfor(j=0;j<k[i];j++){\n\t\tscanf(\"%lld%lld\",&p[i][j].x,&p[i][j].d);\n\t}\n}\nmemset(up,0x7f,sizeof(up));\nfor(i=0;i<k[0];i++){\n\tup[0][i][0]=0;\n}\nfor(i=0;i<k[1];i++){\n\tup[1][i][1]=0;\n}\nfor(i=0;i<n;i++){\n\tfor(j=0;j<k[i];j++){\n\t\tfor(l=0;l<k[i+1];l++){\n\t\t\tfor(r=0;r<=m;r++){\n\t\t\t\tup[i+1][l][r]=min(up[i+1][l][r],up[i][j][r]+(p[i][j].d+p[i+1][l].d)*abs(p[i][j].x-p[i+1][l].x));\n\t\t\t}\n\t\t}\n\t\tif(i==n-1)continue;\n\t\tfor(l=0;l<k[i+2];l++){\n\t\t\tfor(r=0;r<m;r++){\n\t\t\t\tup[i+2][l][r+1]=min(up[i+2][l][r+1],up[i][j][r]+(p[i][j].d+p[i+2][l].d)*abs(p[i][j].x-p[i+2][l].x));\n\t\t\t}\n\t\t}\n\t}\n}\nfor(i=0;i<=m;i++){\n\tfor(j=0;j<k[n-1];j++){\n\t\tans=min(ans,up[n-1][j][i]);\n\t}\n\tif(i==m)continue;\n\tfor(j=0;j<k[n-2];j++){\n\t\tans=min(ans,up[n-2][j][i]);\n\t}\n}\nprintf(\"%lld\\n\",ans);\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nconst int INF = LLONG_MAX / 3;\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[152][78]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%lld\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%lld%lld\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e >= 2 && j<b) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 2][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\nint n,m,dp[200][20][100],gc[200];\nvector<P> tobu[200];\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n + m == 0)break;\n\t\tfor(int i = 0;i <= n;i++){\n\t\t\ttobu[i].clear();\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tscanf(\"%d\",&gc[i]);\n\t\t\tfor(int j = 0;j < gc[i];j++){\n\t\t\t\tint x,d;\n\t\t\t\tscanf(\"%d%d\",&x,&d);\n\t\t\t\ttobu[i].push_back(P(x,d));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < 200;i++){\n\t\t\tfor(int j = 0;j < 20;j++){\n\t\t\t\tfor(int k = 0;k < 100;k++){\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < 20;i++){\n\t\t\tdp[1][i][m] = 0;\n\t\t\tif(m != 0){\n\t\t\t\tdp[2][i][m-1] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 0;j < gc[i];j++){\n\t\t\t\tint nx = tobu[i][j].first,nd = tobu[i][j].second;\n\t\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\t\tfor(int l = 0;l < gc[i+1];l++){\n\t\t\t\t\t\tint tx = tobu[i+1][l].first,td = tobu[i+1][l].second;\n\t\t\t\t\t\tdp[i+1][l][k] = min(dp[i+1][l][k],dp[i][j][k]+(nd+td)*abs(nx-tx));\n\t\t\t\t\t}\n\t\t\t\t\tif(k == 0)continue;\n\t\t\t\t\tfor(int l = 0;l < gc[i+2];l++){\n\t\t\t\t\t\tint tx = tobu[i+2][l].first,td = tobu[i+2][l].second;\n\t\t\t\t\t\tdp[i+2][l][k-1] = min(dp[i+2][l][k-1],dp[i][j][k]+(nd+td)*abs(nx-tx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\n\t\tfor(int i = 0;i < 20;i++){\n\t\t\tfor(int j = 0;j <= m;j++){\n\t\t\t\tans = min(ans,dp[n][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < 20;i++){\n\t\t\tfor(int j = 1;j <= m;j++){\n\t\t\t\tans = min(ans,dp[n-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30 ;\nstruct edge{\n  int pos, strong ;\n  int dp[77];\n\n  edge(int pos, int strong): pos(pos), strong(strong){\n    fill_n( dp, 77, INF);\n  };\n  edge(){};\n};\n\nint main(){\n  int n; //行数 \n  int m; //ジャンプの数\n\n  edge node[152][10];\n  int size[152] = {};\n\n  while(scanf(\"%d %d\", &n, &m), n){\n    for(int i = 0; i < n; i++){\n      int k;\n      scanf(\"%d\", size + i);\n      for(int j = 0; j < size[i]; j++){\n        int x, d;\n        scanf(\"%d %d\", &x, &d);\n        node[i][j] = edge( x, d);\n      }\n    }\n\n    for(int i = 0; i < size[0]; i++){ //最初は普通にジャンプ\n      node[0][i].dp[0] = 0;\n    }\n    for(int i = 0; i < size[1]; i++){ //最初はジャンプする\n      node[1][i].dp[1] = 0 ;\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < size[i]; j++){\n        for(int k = 0; k <= m; k++){\n          if(node[i][j].dp[k] != INF){\n            if(k != m){\n              for(int l = 0; l < size[i + 2]; l++){\n                node[i + 2][l].dp[k + 1] = min( node[i + 2][l].dp[k + 1], node[i][j].dp[k] + (node[i + 2][l].strong + node[i][j].strong) * abs(node[i + 2][l].pos - node[i][j].pos));\n              }\n            }\n            for(int l = 0; l < size[i + 1]; l++){\n              node[i + 1][l].dp[k] = min( node[i + 1][l].dp[k], node[i][j].dp[k] + (node[i + 1][l].strong + node[i][j].strong) * abs(node[i + 1][l].pos - node[i][j].pos));\n            }\n          }\n        }\n      }\n    }\n    int ret = INF ;\n    for(int i = 0; i < size[n - 1]; i++){\n      for(int j = 0; j <= m; j++){\n        ret = min( ret, node[n - 1][i].dp[j]);\n      }\n    }\n    for(int i = 0; i < size[n - 2]; i++){\n      for(int j = 0; j < m; j++){\n        ret = min( ret, node[n - 2][i].dp[j]);\n      }\n    }\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint dp[150][80][10]={};\nint main() {\nwhile(1){\n\tint n=0,m=0;\n\tcin >> n >> m;\n\tvector<int> pos[150];\n\tvector<int> slip[150];\n\tif(n==0&&m==0)return 0;\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\n\t\t\tcin >> x >> d;\n\t\t\tpos[i].push_back(x);\n\t\t\tslip[i].push_back(d);\n\t\t\tfor(int u=0;u<=m;u++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tdp[i][u][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==1&&u>0){\n\t\t\t\t\tdp[i][u][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][u][j]=1<<30;\n\t\t\t\tfor(int r=0;r<pos[i-1].size();r++){\n\t\t\t\t\tint v=dp[i-1][u][r]+abs(pos[i-1][r]-x)*(slip[i-1][r]+d);\n\t\t\t\t\tdp[i][u][j]=min(dp[i][u][j],v);\n\t\t\t\t}\n\t\t\t\tif(u==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int r=0;r<pos[i-2].size();r++){\n\t\t\t\t\tint v=dp[i-2][u-1][r]+abs(pos[i-2][r]-x)*(slip[i-2][r]+d);\n\t\t\t\t\tdp[i][u][j]=min(dp[i][u][j],v);\n\t\t\t\t}\n\t\t\t\t//cout << i << \", \" << u << \", \" << j << \": \" << dp[i][u][j] << endl;\n\t\t\t\t//cout << pos[i].size() << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ret=1<<30;\n\tfor(int i=0;i<pos[n-1].size();i++){\n\t\tret=min(ret,dp[n-1][m][i]);\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Stone{\n\tint col,slip;\n\tStone(){}\n\tStone(int c,int s):col(c),slip(s){}\n};\n\nconst int INFTY=1<<29;\n\nint main()\n{\n\tfor(int row,jump;cin>>row>>jump,row|jump;){\n\t\tvector<vector<Stone> > stones(row+2);\n\t\trep(i,row){\n\t\t\tint n;\n\t\t\tcin>>n;\n\t\t\tstones[i].resize(n);\n\t\t\trep(j,n){\n\t\t\t\tcin>>stones[i][j].col>>stones[i][j].slip;\n\t\t\t\tstones[i][j].col--;\n\t\t\t}\n\t\t}\n\t\t//dump(row);\n\t\t//dump(jump);\n\t\t//rep(i,row){\n\t\t//\trep(j,stones[i].size())\n\t\t//\t\tprintf(\"%d,%d \",stones[i][j].col,stones[i][j].slip);\n\t\t//\tputs(\"\");\n\t\t//}\n\t\t\n\t\tvvvi dp(row);\n\t\trep(i,dp.size())\n\t\t\tdp[i].resize(stones[i].size(),vi(jump+1,INFTY));\n\t\trep(i,dp[0].size())\n\t\t\tdp[0][i][0]=0;\n\t\tif(jump>0)\n\t\t\trep(i,dp[1].size())\n\t\t\t\tdp[1][i][1]=0;\n\t\t\n\t\trepi(i,1,row){\n\t\t\trep(j,dp[i].size())\n\t\t\t\trep(k,dp[i-1].size())\n\t\t\t\t\trep(l,jump+1){\n\t\t\t\t\t\tint newslip=dp[i-1][k][l]+(stones[i][j].slip+stones[i-1][k].slip)*abs(stones[i][j].col-stones[i-1][k].col);\n\t\t\t\t\t\tdp[i][j][l]=min(dp[i][j][l],newslip);\n\t\t\t\t\t}\n\t\t\tif(jump==0 || i==1)\n\t\t\t\tcontinue;\n\t\t\trep(j,dp[i].size())\n\t\t\t\trep(k,dp[i-2].size())\n\t\t\t\t\trepi(l,1,jump+1){\n\t\t\t\t\t\tint newslip=dp[i-2][k][l-1]+(stones[i][j].slip+stones[i-2][k].slip)*abs(stones[i][j].col-stones[i-2][k].col);\n\t\t\t\t\t\tdp[i][j][l]=min(dp[i][j][l],newslip);\n\t\t\t\t\t}\n\t\t}\n\t\t\n\t\t//rep(i,jump+1){\n\t\t//\tdump(i);\n\t\t//\trep(j,row){\n\t\t//\t\trep(k,dp[j].size())\n\t\t//\t\t\tcout<<dp[j][k][i]<<\" \";\n\t\t//\t\tcout<<endl;\n\t\t//\t}\n\t\t//}\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,dp[row-1].size())\n\t\t\trep(j,jump+1)\n\t\t\t\tres=min(res,dp[row-1][i][j]);\n\t\tif(jump>0)\n\t\t\trep(i,dp[row-2].size())\n\t\t\t\trep(j,jump)\n\t\t\t\t\tres=min(res,dp[row-2][i][j]);\n\t\t\n\t\t//dump(res);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\t//for(a=0;a<=m;a++){\n\ta=0;\n\tif(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\t\t       \n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  \n\t  //}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint fie[152][1002][78];\nint main(){\n    while(1){\n        int M,N;\n        cin>>M>>N;\n        if(M==0&&N==0)break;\n        int lis[154][1002];\n        for(int i=0;i<154;i++){\n            for(int j=0;j<1002;j++){\n                if(i!=0&&i!=M+1)lis[i][j]=-1;\n                else lis[i][j]=0;\n            }\n        }\n        for(int i=0;i<152;i++){\n            for(int j=0;j<1002;j++){\n                for(int k=0;k<78;k++){\n                    if(i!=0||k!=0)fie[i][j][k]=2000000000;\n                    else fie[i][j][k]=0;\n                }\n            }\n        }\n        for(int i=0;i<M;i++){\n            int a;\n            cin>>a;\n            for(int j=1;j<=a;j++){\n                int b,c;\n                cin>>b>>c;\n                lis[i+1][b]=c;\n            }\n        }\n        for(int i=0;i<=M;i++){\n            for(int j=0;j<1002;j++){\n                for(int k=0;k<76;k++){\n                    if(fie[i][j][k]<2000000000){\n                        for(int l=0;l<1002;l++){\n                            if(lis[i+1][l]!=-1)fie[i+1][l][k]=min(fie[i+1][l][k],fie[i][j][k]+(lis[i][j]+lis[i+1][l])*(int)fabs(j-l));\n                            if(lis[i+2][l]!=-1)fie[i+2][l][k+1]=min(fie[i+2][l][k+1],fie[i][j][k]+(lis[i][j]+lis[i+2][l])*(int)fabs(j-l));\n                        }\n                    }\n                }\n            }\n        }\n        int ans=2000000000;\n        for(int j=0;j<1002;j++){\n            for(int k=0;k<76;k++){\n                if(k<=N)ans=min(ans,fie[M+1][j][k]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n#define f first\n#define s second\n#define INF (1<<29)\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\n\nint field[155][4];\nint n, m;\n\nint bfs(){\n  queue<P2> que; // (x, y, m, cost)\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[0][j] != 0) que.push(P2(P(j, 0), P(0, 0)));\n  }\n  \n  int ans = INF;\n  \n  while(!que.empty()){\n    P2 pos = que.front();\n    //cout << pos.f.f << ' ' << pos.f.s << endl;\n    que.pop();\n    \n    if(pos.f.s == n-2 && pos.s.f < m){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n\n    \n    if(pos.f.s == n-1){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    for(int i = 1 ; i <= 2 ; i++){\n      for(int j = -3 ; j < 3 ; j++){\n\tif(i == 2 && pos.s.f == m) continue;\n\tif(pos.f.s+i > n || pos.f.f+j < 0 || pos.f.f+j > 3) continue;\n\tif(field[pos.f.s + i][pos.f.f + j] != 0){\n\t  if(i == 1){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\t  \t  \n\t  }\n\t  else if(i == 2){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f+1, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\n\t  }\n\t}\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> n >> m){\n    if(n == 0 && m == 0) break;\n    memset(field, 0, sizeof(field));\n    \n    int k, pos, cost;\n    for(int i = 0 ; i < n ; i++){\n      cin >> k;\n      for(int j = 0 ; j < k ; j++){\n\tcin >> pos >> cost;\n\tpos--;\n\tfield[i][pos] = cost;\n      }\n    }\n\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint sz[200];\nP stone[200][20];\nint memo[200][20][200];\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && (n || m)){\n\t\tfill(sz, sz + 200, 0);\n\t\tfill(&memo[0][0][0], &memo[199][19][199] + 1, INF);\n\t\tmemset(memo[0], 0, sizeof(memo[0]));\n\t\t\n\t\trep(i, n){\n\t\t\tcin >> sz[i];\n\t\t\trep(j, sz[i]){\n\t\t\t\tint x, r;\n\t\t\t\tcin >> x >> r;\n\t\t\t\tstone[i][j] = P(x, r);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<PPP, vector<PPP>, greater<PPP> > que;\n\t\trep(i, sz[0]) que.push(PPP(0, PP(0, P(i, m))));\n\t\tint res = INF;\n\t\tint dn[] = {-2, -1, 1, 2};\n\t\twhile(!que.empty()){\n\t\t\tPPP ppp = que.top();\n\t\t\tque.pop();\n\t\t\tint c = ppp.first;\n\t\t\tint pn = ppp.second.first;\n\t\t\tint xn = ppp.second.second.first;\n\t\t\tint rest = ppp.second.second.second;\n\n\t\t\tif(c > memo[pn][xn][rest]) continue;\n\n\t\t\tif(pn == n - 1){\n\t\t\t\tres = min(res, c);\n\t\t\t}else{\n\t\t\t\tif(pn == n - 2 && rest > 0) res = min(res, c);\n\t\t\t\trep(i, 4){\n\t\t\t\t\tint nxt = pn + dn[i];\n\t\t\t\t\tif(nxt < 0 || nxt >= n) continue;\n\t\t\t\t\tif(abs(dn[i]) == 1){\n\t\t\t\t\t\trep(j, sz[nxt]){\n\t\t\t\t\t\t\tint cost = abs(stone[pn][xn].first - stone[nxt][j].first) * \n\t\t\t\t\t\t\t\t\t(stone[pn][xn].second + stone[nxt][j].second);\n\t\t\t\t\t\t\tif(memo[nxt][j][rest] > c + cost){\n\t\t\t\t\t\t\t\tmemo[nxt][j][rest] = c + cost;\n\t\t\t\t\t\t\t\tque.push(PPP(c + cost, PP(nxt, P(j, rest))));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(rest == 0) continue;\n\t\t\t\t\t\trep(j, sz[nxt]){\n\t\t\t\t\t\t\tint cost = abs(stone[pn][xn].first - stone[nxt][j].first) * \n\t\t\t\t\t\t\t\t(stone[pn][xn].second + stone[nxt][j].second);\n\t\t\t\t\t\t\tif(memo[nxt][j][rest-1] > c + cost){\n\t\t\t\t\t\t\t\tmemo[nxt][j][rest - 1] = c + cost;\n\t\t\t\t\t\t\t\tque.push(PPP(c + cost, PP(nxt, P(j, rest - 1))));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<MAX_V; i++){\n    ans=min(d[n-1][i],ans);\n    ans=min(d[n][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n-1; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(0);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(1));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  \n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint n,m;\nint d[76][151][1001];\n\nint main(){\n    while(true){\n\tcin >> n >> m;\n\tif(n == 0 && m == 0) break;\n\tmemset(d,-1,sizeof(d));\n\tqueue< pair<int,int> > qxy;\n\tqueue<int> qm;\n\tqueue<int> qs;\n\tvector< vector< pair<int,int> > > coor(n);\n\tint ans = 100000000;\n\tREP(i,n){\n\t    int k;\n\t    cin >> k;\n\t    REP(j,k){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcoor[i].PB( pair<int,int>(a,b));\n\t\tif(i==0){\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m);\n\t\t    qs.push(b);\n\t\t    d[m][i][a] = 0;\n\t\t}else if(i == 1){\n\t\t    if(m == 0) continue;\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m-1);\n\t\t    qs.push(b);\n\t\t    d[m-1][i][a] = 0;\n\t\t}\n\t    }\n\t}\n\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int tm = qm.front();\n\t    int ts = qs.front();\n\t    qxy.pop();\n\t    qm.pop();\n\t    qs.pop();\n\t    if(y+1 >= n || (tm > 0 && y+2 >= n)){\n\t\tans = min(ans,d[tm][y][x]);\n\t\tcontinue;\n\t    }\n\t    REP(i,coor[y+1].size()){\n\t\tint nx = coor[y+1][i].first;\n\t\tint ny = y+1;\n\t\tint slip = coor[y+1][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(d[tm][ny][nx] < 0 || d[tm][ny][nx] > v){\n\t\t    d[tm][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t    if(y+2 >= n) continue;\n\t    REP(i,coor[y+2].size()){\n\t\tint nx = coor[y+2][i].first;\n\t\tint ny = y+2;\n\t\tint slip = coor[y+2][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(tm>0 && (d[tm-1][ny][nx] < 0 || d[tm-1][ny][nx] > v )){\n\t\t    d[tm-1][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm-1);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m;\nll dp[155][80][11],INF=1000000000000000LL;\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  FOR(i,155) FOR(j,80) FOR(k,11) dp[i][j][k]=INF;\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][x[n][j]]=0LL;\n  for(int i=n-1;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][k]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][k]=min(dp[i][j][k],dp[i+2][j-1][l]+(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][l]+(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  ll mi=INF;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][i]);\n  if(m) FOR(i,x[2].size()) mi=min(mi,dp[2][m-1][i]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#define int long long\n#define inf 3000000000000\ntypedef pair<int, int>P;\nint dp[160][10][80];\nvector<P>s[160];//P(??????,???????????????)\n\nvoid init(int m) {\n\tfor (int i = 0; i < 160; i++) {\n\t\ts[i].clear();\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tfor (int k = 0; k < 80; k++) {\n\t\t\t\tif (!i&&k==m)dp[i][j][k]=0;\n\t\t\t\telse dp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nsigned main() {\n\tint n, m;\n\twhile (cin >> n >> m) {\n\t\tif (!n && !m)break;\n\t\tinit(m);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\ts[i].push_back(P(b, c));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {//?¬?????????????\n\t\t\tfor (int j = 0; j < s[i].size(); j++) {//??????????????????\n\t\t\t\tfor (int k = m; k >= 0; k--) {//???????????§?????£??????\n\t\t\t\t\tfor (int l = 0; l < s[i - 1].size(); l++) {\n\t\t\t\t\t\tint dang = (s[i-1][l].second+s[i][j].second)*abs(s[i][j].first-s[i-1][l].first);\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + dang);\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 1) {\n\t\t\t\t\t\tfor (int l = 0; l < s[i - 2].size(); l++) {\n\t\t\t\t\t\t\tint dang = (s[i - 2][l].second + s[i][j].second)*abs(s[i][j].first - s[i - 2][l].first);\n\t\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 2][l][k + 1] + dang);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 80; j++) {\n\t\t\t\tans = min(ans, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1005;\nunsigned int dp[6][MAX_X][80];\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n >> m && n)\n\t{\n\t\trep(x,MAX_X) rep(y,6) rep(d,m+1) dp[y][x][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\trep(i,MAX_X) rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tr[x][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[0][x][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[1][x][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++)\n\t\t{\n\t\tmemcpy(dp[y%5], dp[5], sizeof(dp[y%5]));\n\t\tfor(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\t\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ツ津環湘ュツジツδδδ督プ\n\t\t\t\trep(nx, MAX_X) rep(d, m+1)\n\t\t\t\t\tif(dp[(y-1)%5][nx][d] != INF)\n\t\t\t\t\t\tchmin(dp[y%5][x][d], dp[(y-1)%5][nx][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// ツ暗ェツ段ツづづ篠つオ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[(y-2)%5][nx][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[y%5][x][d-1], dp[(y-2)%5][nx][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\t\t}\n\t\tunsigned int res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[(n-1)%5][x][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[(n-2)%5][x][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int INF = (1<<29);\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n || m)){\n    int dp[150][10][80], a[150][10], x[150][10];\n    for(int i=0;i<150;i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<80;k++) dp[i][j][k] = INF;\n\ta[i][j] = INF;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int k;\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint b,c;\n\tcin >> b >> c;\n\tx[i][j] = b;\n\ta[i][j] = c;\n      }\n    }\n    for(int i=0;i<10;i++) dp[0][i][0] = 0;\n\n    for(int i=0;i<n-1;i++){\n      for(int l=0;l<=m;l++){\n\tfor(int j=0;j<10;j++){\n\t  if(a[i][j] == INF) continue;\n\t  for(int k=0;k<10;k++){\n\t    if(a[i+1][k] == INF) continue;\n\t    dp[i+1][k][l] = min(dp[i+1][k][l],dp[i][j][l] + (a[i][j] + a[i+1][k]) * (abs(x[i+1][k]-x[i][j])));\n\t  }\n\t  if(i < n - 2 && l != m){\n\t    for(int k=0;k<10;k++){\n\t      if(a[i+2][k] == INF) continue;\n\t      dp[i+2][k][l+1] = min(dp[i+2][k][l+1],dp[i][j][l] + (a[i][j] + a[i+2][k]) * (abs(x[i+2][k]-x[i][j])));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-1][k][j]);\n    for(int j=0;j<m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-2][k][j])\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N,M;\nlist<long long int>ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\tvector<vector<int>>a(2, vector <int>(4));\n\twhile (N) {\n\t\tint dp[152][100][10];\n\t\tvector<vector<int>>stone(N + 1);\n\t\tvector<int>have(N + 2);\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\thave[i] = a;\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\tstone[i].push_back(b);\n\t\t\t\tstone[i].push_back(c);\n\t\t\t}\n\t\t\t//cout << \"hijiki\";\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j <= M; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++)dp[i][j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\t//cout << \"hijiki\";\n\t\tfor (int i = 0; i < have[1]; i++) {\n\t\t\tdp[1][0][i] = 0;\n\t\t}\n\t\tif (M) {\n\t\t\tfor (int i = 0; i < have[2]; i++) {\n\t\t\t\tdp[2][1][i] = 0;\n\t\t\t}\n\t\t}\n\t//\tcout << \"hijiki\";\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = 0; j <= M; j++) {\n\t\t\t\tif (j != M) {\n\t\t\t\t\tfor (int k = 0; k < have[i]; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < have[i + 2]; l++) {\n\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = dp[i][j][k] + (stone[i][k * 2+1] + stone[i + 2][l * 2+1])*(abs(stone[i][k * 2 ] - stone[i + 2][l * 2 ]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < have[i]; k++) {\n\t\t\t\t\tfor (int l = 0; l < have[i + 1]; l++) {\n\t\t\t\t\t\tdp[i + 1][j][l] = min(dp[i + 1][j][l], dp[i][j][k] + (stone[i][k * 2+1] + stone[i + 1][l * 2+1])*abs(stone[i][k * 2 ] - stone[i + 1][l * 2 ]));\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint box = INT_MAX;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = 0; j < have[N - 1]; j++) {\n\t\t\t\tbox = min(box, dp[N - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= M; i++) {\n\t\t\tfor (int j = 0; j < have[N]; j++) {\n\t\t\t\tbox = min(box, dp[N][i][j]);\n\t\t\t}\n\t\t}\n\t\tans.push_back(box);\n\t\tcin >> N >> M;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<MAX_V; i++){\n    ans=min(d[n-1][i],ans);\n    ans=min(d[n][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(0);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(1));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > x(n+1), d(n+1);\n        vector<vector<vector<int> > > dp(n+1);\n        for(int i=1; i<=n; ++i){\n            int k;\n            cin >> k;\n            for(int j=0; j<k; ++j){\n                int a, b;\n                cin >> a >> b;\n                x[i].push_back(a);\n                d[i].push_back(b);\n                if(i == 1)\n                    dp[i].push_back(vector<int>(m+1, 0));\n                else\n                    dp[i].push_back(vector<int>(m+1, INT_MAX));\n            }\n        }\n\n        for(int i=1; i<n; ++i){\n            for(unsigned j=0; j<x[i].size(); ++j){\n                for(unsigned k=0; k<x[i+1].size(); ++k){\n                    for(int l=0; l<=m; ++l)\n                        dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][l] + (d[i][j]+d[i+1][k]) * abs(x[i][j]-x[i+1][k]));\n                }\n                if(i == n-1)\n                    continue;\n                for(unsigned k=0; k<x[i+2].size(); ++k){\n                    for(int l=1; l<=m; ++l)\n                        dp[i+2][k][l-1] = min(dp[i+2][k][l-1], dp[i][j][l] + (d[i][j]+d[i+2][k]) * abs(x[i][j]-x[i+2][k]));\n                }\n            }\n        }\n\n        int ret = INT_MAX;\n        for(unsigned i=0; i<x[n].size(); ++i)\n            ret = min(ret, dp[n][i][0]);\n        if(m > 0){\n            for(unsigned i=0; i<x[n-1].size(); ++i)\n                ret = min(ret, dp[n-1][i][1]);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint DP[150][100][11];\nint N, M;\nint K[150];\nint X[150][10], Y[150][10];\nint main()\n{\n\twhile (true){\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)break;\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tfor (int k = 0; k < 10; k++){\n\t\t\t\t\tDP[i][j][k] = 1000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d%d\", &X[i][j], &Y[i][j]);\n\t\t\t}\n\t\t}\n\t\t//i=1\n\t\tfor (int j = 0; j < K[1]; j++){\n\t\t\tfor (int k = 0; k < K[0]; k++){\n\t\t\t\tDP[1][j][0] = min(DP[1][j][0], (Y[1][j] + Y[0][k])*abs(X[1][j] - X[0][k]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i < N; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i - 1]; k++){\n\t\t\t\t\tfor (int l = 0; l <= M; l++){\n\t\t\t\t\t\tDP[i][j][l] = min(DP[i][j][l], DP[i - 1][k][l] + (Y[i][j] + Y[i - 1][k])*abs(X[i][j] - X[i - 1][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < K[i - 2]; k++){\n\t\t\t\t\tfor (int l = 0; l < M; l++){\n\t\t\t\t\t\tDP[i][j][l + 1] = min(DP[i][j][l+1], DP[i - 2][k][l] + (Y[i][j] + Y[i - 2][k])*abs(X[i][j] - X[i - 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\t\n\t\tfor (int j = 0; j < K[N - 1]; j++){\n\t\t\tfor (int k = 0; k <= M; k++){\n\t\t\t\tans = min(ans, DP[N - 1][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  if(i+1<n){\n\t    for(k=0;k<v[i+1].size();k++){\n\t    /*\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t\t\t\t       */\n\t    }\n\t  }\n\t  /*\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//30\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    int k[150],xp[150][10],d[150][10];\n    for(int i=0;i<n;i++){\n      cin>>k[i];\n      for(int j=0;j<k[i];j++){\n\tcin>>xp[i][j]>>d[i][j];\n      }\n    }\n    int c[150][150][10]={{}};\n    fill(c[0][0],c[150][0],1<<29);\n    fill(c[0][m],c[0][m+1],0);\n    if(m>0){\n      fill(c[1][m-1],c[1][m],0);\n    }\n    int ans=1<<30;\n    for(int y=0;y<n;y++){\n      for(int j=0;j<=m;j++){\n\tfor(int x=0;x<k[y];x++){\n\t  for(int dj=0;dj<=!!j;dj++){\n\t    if(y+1+dj<n){\n\t      for(int nx=0;nx<k[y+1+dj];nx++){\n\t\tc[y+1+dj][j-dj][nx]=min(c[y+1+dj][j-dj][nx],c[y][j][x]+(d[y][x]+d[y+dj+1][nx])*abs(xp[y][x]-xp[y+1+dj][nx]));\n\t      }\n\t    }else{\n\t      ans=min(ans,c[y][j][x]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <vector>\ntypedef long long int ll;\n#define FOR(i, a, b) for (ll i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n - 1); i >= 0; --i)\n#define mod 1000000007\n#define INF 93193111451418101\n#define MIN -933111451418101\nusing namespace std;\ntypedef pair<ll, ll> P;\n\ntemplate <typename T, typename U>\ntypename std::enable_if<std::rank<T>::value == 0>::type fill_all(T &arr,\n\tconst U &v) {\n\tarr = v;\n}\ntemplate <typename ARR, typename U>\ntypename std::enable_if<std::rank<ARR>::value != 0>::type fill_all(ARR &arr,\n\tconst U &v) {\n\tfor (auto &i : arr) {\n\t\tfill_all(i, v);\n\t}\n}\n//------------------??????°-----------------------//\n\t\t\t\t\t //-------------------???¢???°----------------------//\n\nint main() {\n\twhile (1) {\n\t\tll n, m;\n\t\tstd::vector<P> rock[1000];\n\t\tll dp[155][100][30]; // n???????????¨??°???????????°?????´???\n\t\tcin >> n >> m;\n\t\tif (n + m == 0) { break; }\n\t\tREP(i, n) {\n\t\t\tll k;\n\t\t\tcin >> k;\n\t\t\tREP(j, k) {\n\t\t\t\tll place, sliplevel;\n\t\t\t\tcin >> place >> sliplevel;\n\t\t\t\trock[i + 1].push_back(P(place, sliplevel));\n\t\t\t}\n\t\t}\n\t\trock[0].push_back(P(0, 0));\n\t\trock[n + 1].push_back(P(0, 0));\n\t\tfill_all(dp, INF);\n\t\tdp[0][0][0] = 0;\n\t\tREP(i, n + 1) { // 0???????????????n+1????????????\n\t\t\tREP(j, m + 1) {   //????????¨??°?????????\n\t\t\t\tREP(k, (unsigned)rock[i].size()) {\n\t\t\t\t\tif (dp[i][j][k] == INF) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0 || i == n) {\n\t\t\t\t\t\tREP(l, (unsigned)rock[i + 1].size()) {\n\t\t\t\t\t\t\tdp[i + 1][j][l] = min(dp[i + 1][j][l], dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < m) {\n\t\t\t\t\t\t\tREP(l, (unsigned)rock[i + 2].size()) {\n\t\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tREP(l, (unsigned)rock[i + 1].size()) {\n\t\t\t\t\t\t\tdp[i + 1][j][l] =\n\t\t\t\t\t\t\t\tmin(dp[i + 1][j][l],\n\t\t\t\t\t\t\t\t\tdp[i][j][k] +\n\t\t\t\t\t\t\t\t\t(rock[i + 1][l].second + rock[i][k].second) *\n\t\t\t\t\t\t\t\t\t(abs(rock[i + 1][l].first - rock[i][k].first)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < m) {\n\t\t\t\t\t\t\tREP(l, (unsigned)rock[i + 2].size()) {\n\t\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k] + (rock[i + 2][l].second + rock[i][k].second) *(abs(rock[i + 2][l].first - rock[i][k].first)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(j, m + 1) {\n\t\t\tans = min(ans, dp[n + 1][j][0]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\tfor(int a=0;a<=m;a++){\n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t}\n      }\n    }\n\n    \n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k,l;\n  int a[10][150][78],x[10][150],d[10][150],m,n;\n  int mn;\n  while(cin>>n>>m&&n+m){\n    memset(x,-1,sizeof(x));\n    memset(d,-1,sizeof(d));\n    for(i=0;i<n;i++){\n      cin>>k;\n      for(j=0;j<k;j++){\n\tint t,u;\n\tcin>>t>>u;\n\tt--;\n\tx[j][i]=t;\n\td[j][i]=u;\n      }\n    }\n    memset(a,-1,sizeof(a));\n    for(i=0;x[i][0]!=-1;i++)\n      a[i][0][0]=0;\n    if(m){\n      for(i=0;x[i][1]!=-1;i++)\n\ta[i][1][1]=0;\n    }\n    for(i=0;i<n-2;i++){\n      for(j=0;x[j][i]!=-1;j++){\n\tfor(k=0;k<n/2+3;k++){\n\t  if(a[j][i][k]!=-1){\n\t    for(l=0;x[l][i+1]!=-1;l++){\n\t      if(a[l][i+1][k]==-1||a[l][i+1][k]>a[j][i][k]+(d[j][i]+d[l][i+1])*abs(x[j][i]-x[l][i+1]))\n\t\ta[l][i+1][k]=a[j][i][k]+(d[j][i]+d[l][i+1])*abs(x[j][i]-x[l][i+1]);\n\t    }\n\t    if(k!=m){\n\t      for(l=0;x[l][i+2]!=-1;l++){\n\t\tif(a[l][i+2][k+1]==-1||a[l][i+2][k+1]>a[j][i][k]+(d[j][i]+d[l][i+2])*abs(x[j][i]-x[l][i+2]))\n\t\t  a[l][i+2][k+1]=a[j][i][k]+(d[j][i]+d[l][i+2])*abs(x[j][i]-x[l][i+2]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    mn=-1;\n    for(i=0;x[i][n-2]!=-1;i++){\n      for(j=0;j<n/2+3;j++){\n\tif(a[i][n-2][j]!=-1){\n\t  if(j==m){\n\t    for(k=0;x[k][n-1]!=-1;k++){\n\t      if(a[k][n-1][j]==-1||a[k][n-1][j]>a[i][n-2][j]+(d[i][n-2]+d[k][n-1])*abs(x[i][n-2]-x[k][n-1]))\n\t\ta[k][n-1][j]=a[i][n-2][j]+(d[i][n-2]+d[k][n-1])*abs(x[i][n-2]-x[k][n-1]);\n\t    }\n\t  }else if(mn==-1||mn>a[i][n-2][j]){\n\t    mn=a[i][n-2][j];\n\t  }\n\t}\n      }\n    }\n    for(i=0;x[i][n-1]!=-1;i++){\n      for(j=0;j<n/2+3;j++){\n\tif(a[i][n-1][j]!=-1){\n\t  if(mn==-1||mn>a[i][n-1][j])\n\t    mn=a[i][n-1][j];\n\t}\n      }\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        vector<vector<vector<int> > > dp(3, vector<vector<int> >(10, vector<int>(M+1, INT_MAX/10000)));\n        for(int i = 0; i < stones[0].size(); ++i) {\n            dp[0][i][M] = 0;\n        }\n        if(M > 0) {\n            for(int i = 0; i < stones[1].size(); ++i) {\n                dp[1][i][M-1] = 0;\n            }\n        }\n        for(int i = 2; i < N; ++i) {\n            int curr = i%3;\n            int prev = (i-1)%3;\n            int pp = (i-2)%3;\n\n            for(int k = 0; k < stones[i].size(); ++k) {\n                fill(dp[curr][k].begin(), dp[curr][k].end(), INT_MAX/10000);\n            }\n            for(int j = 0; j < stones[i-2].size(); ++j) {\n                //pp to prev\n                int sx = stones[i-2][j].first;\n                int sc = stones[i-2][j].second;\n                for(int k = 0; k < stones[i-1].size(); ++k) {\n                    int skx = stones[i-1][k].first;\n                    int skc = stones[i-1][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m <= M; ++m) {\n                        dp[prev][k][m] = min(dp[prev][k][m], dp[pp][j][m]+cost);\n                    }\n                }\n\n                //pp to curr\n                for(int k = 0; k < stones[i].size(); ++k) {\n                    int skx = stones[i][k].first;\n                    int skc = stones[i][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m < M; ++m) {\n                        dp[curr][k][m] = min(dp[curr][k][m], dp[pp][j][m+1]+cost);\n                    }\n                }\n            }\n            for(int j = 0; j < stones[i-1].size(); ++j) {\n                //prev to curr\n                int sx = stones[i-1][j].first;\n                int sc = stones[i-1][j].second;\n                for(int k = 0; k < stones[i].size(); ++k) {\n                    int skx = stones[i][k].first;\n                    int skc = stones[i][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m <= M; ++m) {\n                        dp[curr][k][m] = min(dp[curr][k][m], dp[prev][k][m]+cost);\n                    }\n                }\n            }\n        }\n        int ans = INT_MAX;\n        int curr = (N-1) % 3;\n        int prev = (N-2) % 3;\n\n        for(int m = 0; m <= M; ++m) {\n            for(int k = 0; k < stones[N-1].size(); ++k) {\n                ans = min(ans, dp[curr][k][m]);\n            }\n            if(m > 0) {\n                for(int k = 0; k < stones[N-2].size(); ++k) {\n                    ans = min(ans, dp[prev][k][m]);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<11;i++){\n\t\t\tve[0].push_back(MP(i,0));\n\t\t\tdp[T][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[1].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=min(i/2,M);j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tif(M!=0)for(int i=0;i<M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N-1].size();j++){\n\t\t\t\tres=min(res,dp[T][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nconst int inf = 3e17;\n\nint dp[155][15][100];\nint stone[155][15];\nint X[155][15];\n\nsigned main()\n{\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        rep(i, n+5) rep(j, 15) stone[i][j] = inf, X[i][j] = inf;\n        rep(i, n+5) rep(j, 15) rep(k, 100) dp[i][j][k] = inf;\n\n        rep(i, n) {\n            int k; cin >> k;\n            rep(j, k) {\n                int x, d; cin >> x >> d;\n\n                X[i][j] = x;\n\n                stone[i][j] = d;\n                if (i == 0) dp[0][x][0] = 0;\n                if (i == 1) dp[1][x][1] = 0;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 11; ++j) {\n                if (stone[i][j] == inf) continue;\n\n                for (int k = 0; k <= m; ++k) {\n                    if (k < m) {\n                        rep(l, 11) {\n                            if (stone[i + 2][l] == inf) continue;\n\n                            dp[i + 2][l][k + 1] = min(\n                                    dp[i + 2][l][k + 1],\n                                    dp[i][j][k] + (stone[i][j] + stone[i + 2][l]) * abs(X[i][j] - X[i + 2][l])\n                                    );\n                        }\n                    }\n\n                    rep(l, 11) {\n                        if (stone[i + 1][l] == inf) continue;\n\n                        dp[i + 1][l][k] = min(\n                                dp[i + 1][l][k],\n                                dp[i][j][k] + (stone[i][j] + stone[i + 1][l]) * abs(X[i][j] - X[i + 1][l])\n                                );\n                    }\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j <= m; ++j) {\n                mi = min(mi, dp[n - 1][i][j]);\n            }\n        }\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j <= m - 1; ++j) {\n                mi = min(mi, dp[n - 2][i][j]);\n            }\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n//番号とx座標と滑りやすさ\nvector<P1>s[155];\n//滑りやすさ、x座標、y座標\nP1 d[1505];\nint n,m;\n//石番号と残り数を状態にもつdijkstra用配列\nint di[1505][76];\n//beatmania iidx楽しい!!の部分文字列ではなくindexの部分文字列\nint idx=0;\nint main()\n{\n\twhile(1)\n\t{\n\tidx=0;\n\tscanf(\"%d %d\",&n,&m);\n\tif(!n) return 0;\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\ts[i].clear();\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\n\t\t\ts[i].pb(mp(idx,mp(a,b)));\n\t\t\td[idx++]=mp(b,mp(a,i));\n\t\t}\n\t}\n\tfor(int i=0;i<1505;i++)for(int j=0;j<76;j++) di[i][j]=1e7;\n\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\tfor(int i=0;i<s[1].size();i++)\n\t{\n\t\tP1 p=s[1][i];\n\t\tdi[p.first][m]=0;\n\t\tque.push(mp(0,mp(p.first,m)));\n\t}\n\tfor(int i=0;m>0 && i<s[2].size();i++)\n\t{\n\t\tP1 p=s[2][i];\n\t\tdi[p.first][m-1]=0;\n\t\tque.push(mp(0,mp(p.first,m-1)));\n\t}\n\twhile(!que.empty())\n\t{\n\t\tP1 p=que.top();\n\t\tque.pop();\n\t\tint idd=p.second.first;\n\t\tint slip1=d[idd].first;\n\t\tint x=d[idd].second.first;\n\t\tint y=d[idd].second.second;\n\t\tint zan=p.second.second;\n\t\t\n\t\tfor(int i=0;i<s[y+1].size();i++)\n\t\t{\n\t\t\tP1 pp=s[y+1][i];\n\t\t\tint slip2=pp.second.second;\n\t\t\tint x2=pp.second.first;\n\t\t\tif(di[pp.first][zan]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[pp.first][zan]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[pp.first][zan],mp(pp.first,zan)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;zan>0 && i<s[y+2].size();i++)\n\t\t{\n\t\t\tP1 pp=s[y+2][i];\n\t\t\tint slip2=pp.second.second;\n\t\t\tint x2=p.second.first;\n\t\t\tif(di[pp.first][zan-1]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[pp.first][zan-1]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[pp.first][zan-1],mp(pp.first,zan-1)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ret=INF;\n\tfor(int j=0;j<s[n].size();j++) for(int i=0;i<76;i++) ret=min(ret,di[s[n][j].first][i]);\n\tfor(int j=0;j<s[n-1].size();j++) for(int i=1;i<76;i++) ret=min(ret,di[s[n-1][j].first][i]);\n\t\n\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tX\tfirst\n#define\tSL\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1000000000;\npii river[150][11];\nint memo[150][10][76];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k;\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint x,slip;\tscanf(\"%d%d\",&x,&slip);\n\t\t\t\triver[i][j]=mp(x,slip);\n\t\t\t}\n\t\t\triver[i][k]=mp(-1,-1);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++)for(int j=0;~river[i][j].X;j++)for(int k=0;k<=m;k++)\n\t\t\tmemo[i][j][k]=inf;\n\n\t\tfor(int j=0;~river[0][j].X;j++)\tmemo[0][j][0]=0;\n\t\tfor(int j=0;~river[1][j].X;j++)\tmemo[1][j][1]=0;\n\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;~river[i][j].X;j++){\n\t\t\t\tint cost;\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tfor(int b=0;~river[i-1][b].X;b++){\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-1][b].SL)*abs(river[i][j].X-river[i-1][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-1][b][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=1;k<=m;k++){\n\t\t\t\t\tif(i-2<0)\tcontinue;\n\t\t\t\t\tfor(int b=0;~river[i-2][b].X;b++){\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-2][b].SL)*abs(river[i][j].X-river[i-2][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-2][b][k-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mincost=inf;\n\t\tfor(int j=0;~river[n-1][j].X;j++)for(int k=0;k<=m;k++)\tmincost=min(mincost,memo[n-1][j][k]);\n\t\tfor(int j=0;~river[n-2][j].X;j++)for(int k=0;k<m;k++)\tmincost=min(mincost,memo[n-2][j][k]);\n\t\tprintf(\"%d\\n\",mincost);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint memo[100][150][150];\n\nint main(){\n  int n,m;\n  while(n=getInt(), m=getInt(), n+m){\n    vector<vector<pair<int,int> > > stone(n);\n    memset(memo, -1, sizeof(memo));\n    REP(i,n){\n      int num = getInt();\n      stone[i] = vector<pair<int,int> >(num);\n      REP(j,num){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    REP(i,n) memo[m][0][i] = 0;\n\n    REP(i,n-1){\n      FOR(it,stone[i]){\n        int j = it->f;\n        int s = it->s;\n        REP(k,m+1){\n          if(memo[k][i][j] != -1){\n            FOR(it2,stone[i+1]){\n              int jj = it2->f;\n              int ss = it2->s;\n              int mm = memo[k][i][j];\n\n              if(memo[k][i+1][jj] == -1)\n                memo[k][i+1][jj] = mm + (s + ss)*abs(j - jj);\n              else\n                memo[k][i+1][jj] = min(memo[k][i+1][jj], mm + (s + ss)*abs(j - jj));\n            }\n\n            if(k != 0 && i != n-2){\n              FOR(it2,stone[i+2]){\n                int jj = it2->f;\n                int ss = it2->s;\n                int mm = memo[k][i][j];\n\n                if(memo[k-1][i+2][jj] == -1)\n                  memo[k-1][i+2][jj] = mm + (s + ss)*abs(j - jj);\n                else\n                  memo[k-1][i+2][jj] = min(memo[k][i+2][jj], mm + (s + ss)*abs(j - jj));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    //puts(\"0:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[0][i][j]); puts(\"\"); }\n    //puts(\"1:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[1][i][j]); puts(\"\"); }\n\n    int ans = INT_MAX;\n    REP(j,n) REP(k,m+1){\n      if(memo[k][n-1][j] != -1)\n        ans = min(ans, memo[k][n-1][j]);\n      if(k != 0){\n        if(memo[k][n-2][j] != -1)\n          ans = min(ans, memo[k][n-2][j]);\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m;\nll dp[155][80][11],INF=1000000000000000LL;\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  FOR(i,155) FOR(j,80) FOR(k,11) dp[i][j][k]=INF;\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][j]=0LL;\n  for(int i=n-1;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][k]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][k]=min(dp[i][j][k],dp[i+2][j-1][l]+(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][l]+(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  ll mi=INF;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][i]);\n  if(m) FOR(i,x[2].size()) mi=min(mi,dp[2][m-1][i]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\t\t       \n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  \n\t}\n\t\n      }\n    }\n    \n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[6] = {1, 0, -1, 0,1,1};\nconst int dy[6] = {0, 1, 0, -1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N,M;\n    cin >> N >> M;\n    while(N != 0){\n        vector<vector<pair<ll,ll>>> G(N);\n        for(int i=0; i<N; i++){\n            int k;\n            cin >> k;\n            for(int j=0; j<k; j++){\n                int a,b;\n                cin >> a >> b;\n                G[i].emplace_back(a,b);\n            }\n        }\n        ll dp[N+1][15][N];\n        for(int i=0; i<N; i++){\n            for(int j=0; j<G[i].size(); j++){\n                for(int k=0; k<=M; k++){\n                    dp[i][j][k] = INF; \n                }\n            }\n        }\n        for(int i=0; i<G[0].size(); i++){\n            dp[0][i][0] = 0;\n        }\n        for(int i=0; i<G[1].size(); i++){\n            dp[1][i][1] = 0;\n        }\n        for(int i=0; i<N-1; i++){\n            for(int j=0; j<G[i].size(); j++){\n                for(int k=0; k<=M; k++){\n                    for(int l=0; l<G[i+1].size(); l++){\n                        ll cost = G[i][j].second + G[i+1][l].second;\n                        ll sa = abs(G[i][j].first - G[i+1][l].first);\n                        chmin(dp[i+1][l][k],dp[i][j][k]+cost*sa);\n                    }\n                    if(i+2<N and k<M){\n                        for(int l=0; l<G[i+2].size(); l++){\n                            ll cost = G[i][j].second + G[i+2][l].second;\n                            ll sa = abs(G[i][j].first - G[i+2][l].first);\n                            chmin(dp[i+2][l][k+1],dp[i][j][k]+cost*sa);\n                        }\n                    }\n                }\n            }\n        }\n        // for(int i=0; i<N; i++){\n        //     for(int j=0; j<G[i].size(); j++){\n        //         for(int k=0; k<=M; k++){\n        //             cout << \"check:\" << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << enld;\n        //         }\n        //     }\n        // }\n        ll ans = INF;\n        for(int i=0; i<G[N-2].size(); i++){\n            for(int j=0; j<M; j++){\n                chmin(ans,dp[N-2][i][j]);\n            }\n        }\n        for(int i=0; i<G[N-1].size(); i++){\n            for(int j=0; j<=M; j++){\n                chmin(ans,dp[N-1][i][j]);\n            }\n        }\n        cout << ans << enld;\n        cin >> N >> M;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint flag[152][12][78] = {{{0}}};\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      int slip[152][12] = {{0}};\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n\n      memset(flag,0,sizeof(flag));\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n            flag[1][i][0] = 1;\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n            flag[2][i][1] = 1;\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s] = 1;\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n               if(p.f.f != 0) flag[p.f.s+2][i][p.s.s+1] = 1;\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%d\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%d %d\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\trep(i, k[0]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(0, 0, i));\n\t\t}\n\n\t\trep(i, k[1]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(2, 1, i));\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define UNDEF 1073741824\n\nint n,m,k[151],x[151][10],d[151][10],dp[151][10][76];\n\nint getdp(int col,int row,int rem)\n{\n\tif(col < 151 && row < 10 && rem < 76 && col >= 0 && row >= 0 && rem >= 0)\n\t\treturn dp[col][row][rem];\n\telse\n\t\treturn UNDEF;\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0)\n\t\t\texit(0);\n\t\tfor(int i = 0;i < 151;i++)\n\t\t{\n\t\t\tfor(int j = 0;j < 10;j++)\n\t\t\t{\n\t\t\t\tx[i][j] = UNDEF;\n\t\t\t\td[i][j] = UNDEF;\n\t\t\t\tfor(int l = 0;l < 76;l++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][l] = UNDEF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk[i] = UNDEF;\n\t\t}\n\t\tfor(int i = 0;i < n;i++)\n\t\t{\n\t\t\tcin >> k[i];\n\t\t\tfor(int j = 0;j < k[i];j++)\n\t\t\t{\n\t\t\t\tcin >> x[i][j] >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < k[0];i++)\n\t\t{\n\t\t\tdp[0][i][m] = 0;\n\t\t}\n\t\tfor(int col = 1;col < n;col++)\n\t\t{\n\t\t\tfor(int row = 0;row < k[col];row++)\n\t\t\t{\n\t\t\t\tfor(int rem = 0;rem <= m;rem++)\n\t\t\t\t{\n\t\t\t\t\tfor(int t = 0;t < k[col-1];t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(getdp(col-1,t,rem) != UNDEF)\n\t\t\t\t\t\t\tdp[col][row][rem] = min(dp[col][row][rem],getdp(col-1,t,rem)+((d[col][row]+d[col-1][t])*abs(x[col][row]-x[col-1][t])));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int t = 0;t < k[col-2];t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(getdp(col-2,t,rem+1) != UNDEF)\n\t\t\t\t\t\t\tdp[col][row][rem] = min(dp[col][row][rem],getdp(col-2,t,rem+1)+((d[col][row]+d[col-2][t])*abs(x[col][row]-x[col-2][t])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result = UNDEF;\n\t\tfor(int row = 0;row < k[n-1];row++)\n\t\t{\n\t\t\tfor(int rem = 0;rem <= m;rem++)\n\t\t\t{\n\t\t\t\tresult = min(result,dp[n-1][row][rem]);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int INF = (1<<21);\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n || m)){\n    int dp[150][10][80], a[150][10];\n    for(int i=0;i<150;i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<80;k++) dp[i][j][k] = INF;\n\ta[i][j] = INF;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int k;\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint b,c;\n\tcin >> b >> c;\n\tb--;\n\ta[i][b] = c;\n      }\n    }\n    for(int i=0;i<10;i++) dp[0][i][0] = 0;\n\n    for(int i=0;i<n-1;i++){\n      for(int l=0;l<=m;l++){\n\tfor(int j=0;j<10;j++){\n\t  if(a[i][j] == INF) continue;\n\t  for(int k=0;k<10;k++){\n\t    if(a[i+1][k] == INF) continue;\n\t    dp[i+1][k][l] = min(dp[i+1][k][l],dp[i][j][l] + (a[i][j] + a[i+1][k]) * (abs(k-j)));\n\t  }\n\t  if(i < n - 2 && l != m){\n\t    for(int k=0;k<10;k++){\n\t      if(a[i+2][k] == INF) continue;\n\t      dp[i+2][k][l+1] = min(dp[i+2][k][l+1],dp[i][j][l] + (a[i][j] + a[i+2][k]) * (abs(k-j)));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-1][k][j]);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=INT_MAX;\nint dp[151][1001][76];\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvvint vv;\n\t\tinitvv(vv,n,1001,-1);\n\t\trep(i,151) rep(j,1001) rep(k,76) dp[i][j][k]=INF;\n\t\trep(i,n){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\trep(j,t){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tvv[i][a-1]=b;\n\t\t\t}\n\t\t}\n\t\t// puts(\"hoge\");\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// printf(\"%2d\",vv[i][j]);\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\trep(i,2){\n\t\t\trep(j,1001){\n\t\t\t\tif(vv[i][j]!=-1) dp[i][j][i]=0;\n\t\t\t}\n\t\t}\n\t\t// return;\n\t\trep(i,n-1){\n\t\t\trep(j,1001){\n\t\t\t\tif(vv[i][j]==-1) continue;\n\t\t\t\trep(o,76){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tif(o+k>75) continue;\n\t\t\t\t\t\trep(l,1001){\n\t\t\t\t\t\t\tif(vv[i+k+1][l]==-1) continue;\n\t\t\t\t\t\t\tdp[i+k+1][l][o+k]=min(dp[i+k+1][l][o+k],dp[i][j][o]+abs(j-l)*(vv[i][j]+vv[i+k+1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==n-2) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// if(dp[i][j][0]!=INF) printf(\"%2d\",dp[i][j][0]);\n\t\t\t\t// else cout<<\"  \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// if(dp[i][j][1]!=INF) printf(\"%2d\",dp[i][j][1]);\n\t\t\t\t// else cout<<\"  \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\treep(i,n-2,n){\n\t\t\trep(j,1001){\n\t\t\t\trep(k,m){\n\t\t\t\t\tans=min(ans,dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout<<ans<<endl;\n\t\trep(i,1001){\n\t\t\trep(k,m+1){\n\t\t\t\tans=min(ans,dp[n-1][i][k]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#define INF 1 << 30\nusing namespace std;\nint n, m;\nint k[160];\nvector<int> v[160];\nint d[1024][160];\nint memo[1024][160][76];\nint solve(int x, int y, int c){\n  int res = INF;\n  if(memo[x][y][c]) return memo[x][y][c];\n  if(y + 1 > n || (y + 2 > n && m - c > 0)) return 0;\n  if(c < m/* && y <= n - 2*/){\n    for(int i = 0;i < k[y + 2]; i++){\n      int nx = v[y + 2][i]; int ny = y + 2;\n      res = min(res, solve(nx, ny, c + 1) + (d[x][y] + d[nx][ny]) * abs(x - nx));\n    }\n  }\n  for(int i = 0;i < k[y + 1]; i++){\n    int nx = v[y + 1][i]; int ny = y + 1;\n    res = min(res, solve(nx, ny, c) + (d[x][y] + d[nx][ny]) * abs(x - nx));\n  }\n  return memo[x][y][c] = res;\n}\nint main(void){\n  int a, b;\n  for( ; ; ){\n    scanf(\"%d %d\", &n, &m);\n    if(!(n + m)) break;\n    for(int i = 0;i < 160; i++) v[i].clear();\n    memset(memo, 0, sizeof(memo));\n    for(int i = 1;i <= n; i++){\n      scanf(\"%d\", k + i);\n      for(int j = 0;j < k[i]; j++){\n\tscanf(\"%d %d\", &a, &b);\n\tv[i].push_back(a);\n\td[a][i] = b;\n      }\n    }\n    int ans = INF;\n    for(int i = 0;i < k[1]; i++)\n      ans = min(ans, solve(v[1][i], 1, 0));\n    if(m > 0){\n      for(int i = 0;i < k[2]; i++)\n\tans = min(ans, solve(v[2][i], 2, 1));\n    }\n    printf(\"%d\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Pyon-Pyon River Crossing.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int X = 1005;\nconst int Y = 155;\nconst int MM = 80;\nconst int INF = 1 << 30;\nconst vector<vint> V = vector<vint>(X, vint(MM, INF));\n\nint N, M;\nint dp[3][X][MM];\n\nint main()\n{\n\tfor(; cin >> N >> M && (N || M); )\n\t{\n\t\tvector<vector<vint> > dp(3, vector<vint>(X, vint(MM, INF)));\n\t\trep(x, X) rep(m, MM) dp[0][x][m] = 0;\n\t\t\n\t\tvector<vector<pint> > river;\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\triver.push_back(vector<pint>(k));\n\t\t\t\n\t\t\trep(i, k) cin >> river[y][i].first >> river[y][i].second;\n\t\t}\n\t\t\n\t\triver.push_back(vector<pint>(X));\n\t\trep(i, X) river[N][i] = mp(i, 0);\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\trep(i, river[y].size())\n\t\t\t{\n\t\t\t\trep(m, M+1)\n\t\t\t\t{\n\t\t\t\t\trep(j, river[y+1].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+1][j].second + river[y][i].second) * abs(river[y+1][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[1][river[y+1][j].first][m], dp[0][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(m > 0) rep(j, river[y+2].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+2][j].second + river[y][i].second) * abs(river[y+2][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[2][river[y+2][j].first][m-1], dp[0][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp[0] = dp[1];\n\t\t\tdp[1] = dp[2];\n\t\t\tdp[2] = V;\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\trep(x, X) rep(m, MM) chmin(ans, dp[0][x][m]);\n\n\t\tcout << ans << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdlib>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nclass State\n{\npublic:\n  int c, j, d, p;\n  State(int _c, int _j, int _d, int _p)\n    :c(_c), j(_j), d(_d), p(_p) {}\n  bool operator < (const State& st) const\n  {\n    return this->d > st.d;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if ((n|m) == 0)\n      break;\n\n    vector<vector<pair<int, int> > > s(n);\n    for (int i = 0; i < n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n\tint x, d;\n\tcin >> x >> d;\n\ts[i].push_back(make_pair(x-1, d));\n      }\n    }\n\n    priority_queue<State> que;\n    for (int i = 0; i < s[0].size(); ++i)\n      que.push(State(0, 0, 0, i));\n    vector<vector<vector<int> > > dp(n, vector<vector<int> >(10, vector<int>(m+1, INF)));\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if (st.c == n-1) {\n\tcout << st.d << endl;\n\tbreak;\n      }\n\n      if (dp[st.c][st.p][st.j] < st.d)\n\tcontinue;\n      dp[st.c][st.p][st.j] = st.d;\n\n      for (int i = 0; i < s[st.c+1].size(); ++i) {\n\tint danger = st.d + (s[st.c][st.p].second  + s[st.c+1][i].second) * abs(s[st.c][st.p].first - s[st.c+1][i].first);\n\tif (dp[st.c+1][i][st.j] > danger) {\n\t  dp[st.c+1][i][st.j] = danger;\n\t  que.push(State(st.c+1, st.j, danger, i));\n\t}\n      }\n\n      if (st.j+1 <= m && st.c+2 < n) {\n\tfor (int i = 0; i < s[st.c+2].size(); ++i) {\n\t  int danger = st.d + (s[st.c][st.p].second  + s[st.c+2][i].second) * abs(s[st.c][st.p].first - s[st.c+2][i].first);\n\t  if (dp[st.c+2][i][st.j] > danger) {\n\t    dp[st.c+2][i][st.j] = danger;\n\t    que.push(State(st.c+2, st.j+1, danger, i));\n\t  }\n\t}   \n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nint n,m,a,b,c,minx,Ax,Ad,Bx,Bd;\nint dp[160][1100][90];\nvector<int>x[200];\n\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<200;i++){x[i].clear();}\n\t\tminx=1500000000;\n\t\tif(n==0 && m==0){break;}\n\t\tfor(int i=0;i<=1000;i++){x[0].push_back(i*10000);}\n\t\tfor(int i=0;i<=1000;i++){x[n+1].push_back(i*10000);}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tx[i].push_back(b*10000+c);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,127,sizeof(dp));\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tAx=x[i][j]/10000;\n\t\t\t\t\tAd=x[i][j]%10000;\n\t\t\t\t\tif(dp[i][Ax][k]<=1000000000){\n\t\t\t\t\t\tfor(int l=0;l<x[i+1].size();l++){\n\t\t\t\t\t\t\tBx=x[i+1][l]/10000;Bd=x[i+1][l]%10000;\n\t\t\t\t\t\t\tdp[i+1][Bx][k]=min(dp[i+1][Bx][k],dp[i][Ax][k]+(Ad+Bd)*abs(Ax-Bx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int l=0;l<x[i+2].size();l++){\n\t\t\t\t\t\t\tBx=x[i+2][l]/10000;Bd=x[i+2][l]%10000;\n\t\t\t\t\t\t\tdp[i+2][Bx][k+1]=min(dp[i+2][Bx][k+1],dp[i][Ax][k]+(Ad+Bd)*abs(Ax-Bx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=1000;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tminx=min(minx,dp[n+1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  ll n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    if(i==2)dp[i][j][l]=0;\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    //dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    \n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150];\nint X[10][150];\nint D[10][150];\nint DP[10][150][80];\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][M]=0;\n\t\tfor(int x=0;x<K[1];x++) DP[x][1][M-1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y==1) continue;\n\t\t\tfor(int xx=0;xx<K[y-2];xx++) for(int m=0;m<M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m+1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-2];x++) for(int m=1;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-2][m]);\n\t\t}\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[100][200][1001];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 100; i++)\n\t\t\tfor(int j = 0; j < 200; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+1001,INF);\n\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[m][0][i]=0;\n\t\t\t}\n\t\t}\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(i==3){\n\t\t\t\t//cout<<endl;\n\t\t\t}\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l][i-1][k]+cost);\n\t\t\t\t\t\tif(i>=2){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l+1][i-2][k]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,dp[j][n-1][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint stones[151][1005];\nint memo[151][1005][100];\nint n,m;\n\nint solve(int i,int j,int l) {\n  if(memo[i][j][l] != -1) return memo[i][j][l];\n  if(i >= n-1) return 0;\n\n  int res = 1000000000,k;\n  if(l < m) {\n    rep(k,1005) {\n      if(stones[i+2][k] == 0) continue;\n      res = min(res, (stones[i][j]+stones[i+2][k])*abs(k-j) + solve(i+2,k,l+1));\n    }\n  }\n\n  rep(k,1005) {\n    if(stones[i+1][k] == 0) continue;\n    res = min(res, (stones[i][j]+stones[i+1][k])*abs(k-j) + solve(i+1,k,l));\n  }\n\n  //printf(\"%d %d %d : %d\\n\", i,j,l, res);\n  return memo[i][j][l] = res;\n}\n\nint main() {\n  int k,l,i,j,x,d;\n  while(scanf(\"%d %d\", &n, &m), n|m) {\n    memset(stones, 0, sizeof(stones));\n    memset(memo, -1, sizeof(memo));\n    rep(i,n) {\n      scanf(\"%d\", &k);\n      rep(j,k) {\n\tscanf(\"%d %d\", &x, &d);\n\tstones[i][x-1] = d;\n      }\n    }\n\n    int ans = 1000000000;\n    rep(i,150) {\n      if(stones[0][i] != 0) {\n\tans = min(ans, solve(0, i, 0));\n      }else if(m > 1 && stones[1][i] != 0) {\n\tans = min(ans, solve(1, i, 1));\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\n\nint x, y;\n\nvector<vector<int> > river(150, vector<int>(80));\nint dp[150][1000][80];\n\nint search(pair<int,int>, int);\n\nint main()\n{\n\t///ifstream ifs(\"data.txt\");\n\tint m;\n\twhile(cin >> y >> m && y)\n\t{\n\t\tx = 0;\n\t\tfill(river[0].begin(), river[0].end(), 0 );\n\t\tfill(river.begin(), river.end(), river[0]);\n\n\t\tfor(int i = 0; i < 150; i++)\n\t\t\tfor(int j = 0; j < 1000; j++)\n\t\t\t\tfor(int k = 0; k < 80; k++)\n\t\t\t\t\tdp[i][j][k] = -1;\n\n\t\tfor(int i = 0; i < y; i++)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < s; j++)\n\t\t\t{\n\t\t\t\tint p, d;\n\t\t\t\tcin >> p >> d;\n\t\t\t\triver[i][p-1] = d;\n\t\t\t\tx = max(x, p);\n\t\t\t}\n\t\t}\n\n\t\tint res = 1 << 30;\n\t\t\n\t\tfor(int i = 0; i < y; i++)\n\t\t\tif(river[0][i])\n\t\t\t\tres = min(res, search(make_pair(i, 0), m));\n\t\t\n\t\tcout << res << endl;\n\t}\n}\n\nint search(pair<int,int> p, int m)\n{\n\tif(dp[p.second][p.first][m] != -1)\n\t\treturn dp[p.second][p.first][m];\n\n\tif(p.second >= y - 1 || (m > 0 && p.second >= y - 2))\n\t\treturn 0;\n\n\tint res = 1 << 30;\n\n\t//ツ津環湘ュツづ個ジツδδδ督プ\n\tfor(int i = 0; i < x; i++)\n\t\tif(river[p.second + 1][i])\n\t\t\tres = dp[p.first][p.second][m] = min(res, (river[p.second][p.first] + river[p.second + 1][i] ) * abs(p.first - i) + search(make_pair(i, p.second + 1), m));\n\t\n\t// ツ暗ェツ行ツ氾イツづ篠つオ\n\tif(m > 0)\n\t\tfor(int i = 0; i < x; i++)\n\t\t\tif(river[p.second + 2][i])\n\t\t\t\tres = dp[p.first][p.second][m] = min(res, (river[p.second][p.first] + river[p.second + 2][i] ) * abs(p.first - i) + search(make_pair(i, p.second + 2), m - 1));\n\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 10000000\n#define INFB 10000\nint n,m;\nint d[76][150][10];\nint r[150][10];\nint i,j,k,l;\nint t;\nint a,b;\nint w;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint max(int a,int b){\n\tif(a<=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tw=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<10;j++)r[i][j]=INFB;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tw=max(w,a);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++)for(j=0;j<w;j++)r[i][j]=min(r[i][j],INFB);\n\t\tfor(i=0;i<=m;i++)for(j=0;j<w;j++){\n\t\t\tif(r[0][j]!=INFB)d[i][0][j]=0;\n\t\t}\n\t\tfor(i=0;i<=m;i++)for(j=1;j<n;j++)for(k=0;k<w;k++){d[i][j][k]=INF;}\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<w;k++){\n\t\t\t\t\t\tfor(l=0;l<w;l++){\n\t\t\t\t\t\t\tif(d[j+1][i-2][l]!=INF&&r[i][k]!=INFB&&r[i-2][l]!=INFB)d[j][i][k]=min(d[j][i][k],d[j+1][i-2][l]+abs(k-l)*(r[i][k]+r[i-2][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<w;k++){\n\t\t\t\t\tfor(l=0;l<w;l++){\n\t\t\t\t\t\tif(d[j][i-1][l]!=INF&&r[i][k]!=INFB&&r[i-1][l]!=INFB)d[j][i][k]=min(d[j][i][k],d[j][i-1][l]+abs(k-l)*(r[i][k]+r[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<w;j++){\n\t\t\tans=min(ans,d[i][n-1][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nstruct rock\n{\n  int x, d;\n};\n\nconst int INF = 2e9;\nint n, m;\nint dp[150][10][76];\nvector<rock> rocks[150];\nint main()\n{\n  while(cin >> n >> m && (n || m)){\n\n    //chap1\n    for(int i = 0; i < n; i++){\n      rocks[i].clear();\n      for(int j = 0; j < 10; j++)\n\tfor(int k = 0; k <= m; k++)\n\t  dp[i][j][k] = INF;\n    }\n\n    for(int i = 0; i < 10; i++)\n      dp[0][i][0] = dp[1][i][1] = 0;\n    \n    //chap2\n    for(int i = 0; i < n; i++){\n      int kk;\n      cin >> kk;\n      for(int j = 0; j < kk; j++){\n\trock in;\n\tcin >> in.x >> in.d;\n\trocks[i].push_back(in);\n      }\n    }\n\n    //chap3\n    for(int i = 0; i < n - 1; i++){\n      for(int j = 0; j < rocks[i].size(); j++){\n\tfor(int k = 0; k < rocks[i + 1].size(); k++){\n\t  for(int l = 0; l <= m; l++){\n\t    dp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (rocks[i][j].d + rocks[i + 1][k].d) * (int)abs(rocks[i][j].x - rocks[i + 1][k].x));\n\t  }\n\t}\n\n\tif(i < n - 2){\n\t  for(int k = 0; k < rocks[i + 2].size(); k++){\n\t    for(int l = 0; l < m; l++){\n\t      dp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (rocks[i][j].d + rocks[i + 2][k].d) * (int)abs(rocks[i][j].x - rocks[i + 2][k].x));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i = 0; i < rocks[n - 1].size(); i++)\n      for(int j = 0; j <= m; j++)\n\tans = min(ans, dp[n - 1][i][j]);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint mincost;\n\n\nvoid NoJump(VVP &G,VVI &dp)\n{\n  int n= dp.size();\n  rep(i,dp[0].size())dp[0][i] = 0;\n  rep(i,n-1)\n    {\n      int m = dp[i].size();\n      int o = dp[i+1].size();\n      rep(j,m)\n\t{\n\t  rep(k,o)\n\t    {\n\t      int cost = (G[i+1][k].S+G[i][j].S)*abs(G[i+1][k].F-G[i][j].F);\n\t      dp[i+1][k] = min(dp[i+1][k],cost+dp[i][j]);\n\t    }\t\n\t}\n    }\n  rep(i,G[n-1].size())mincost = min(mincost,dp[n-1][i]);\n}\n\nvoid printVVI(VVI &G)\n{\n  cout << \"printVVI ------------ \"<< endl;\n  rep(i,G.size())\n    {\n      rep(j,G[i].size())\n\t{\n\t  cout << G[i][j] << \" \";\n\t} \n      cout << endl;\n    }\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      mincost = (1<<29);\n      VVP G(n);\n      rep(i,n)\n\t{\n\t  int k;\n\t  cin >> k;\n\t  rep(j,k)\n\t    {\n\t      int x,d;\n\t      cin >> x >> d;\n\t      G[i].push_back(P(x,d));\n\t    }\n\t}\n    \n      VVI dp(n);\n      rep(i,n)dp[i].resize(G[i].size(),(1<<29));\n      NoJump(G,dp);\n      //printVVI(dp);      \n\n      //First jump\n      VVI prev = dp;\n      if(m != 0){\n\t\n\trep(i,G[1].size())prev[1][i] = 0;    \n\trep(i,n)\t\n\t  {\n\t    if(i+2 >= n)\n\t      {\n\t\trep(k,G[i].size())mincost = min(mincost,dp[i][k]);\n\t\tbreak;\n\t      }\n\t  rep(j,G[i].size())\n\t    {\n\t      rep(k,G[i+2].size())\n\t\t{\n\t\t  int cost = (G[i][j].S+G[i+2][k].S)*abs(G[i][j].F-G[i+2][k].F);\n\t\t  prev[i+2][k] = min(prev[i+2][k],cost+dp[i][j]); \n\t\t}\n\t    }\n\t  }\n\tdp = prev;\n\t//printVVI(dp);\n      }\n      \n      if(m == 1 || m == 0)goto Next;\n\n      for(int i=1,cnt=1;cnt<m;cnt++,i+=2)\n\t{\n\t  prev = dp;\n\t  REP(j,i,n)\n\t    {\n\t      if(j+2 >= n)\n\t\t{\n\t\t  rep(k,G[j].size())mincost = min(mincost,dp[j][k]);\n\t\t  break;\n\t\t}\n\t      rep(k,G[j].size())\n\t\t{\n\t\t  rep(l,G[j+2].size())\n\t\t    {\t  \n\t\t      int cost = (G[j][k].S+G[j+2][l].S)*abs(G[j][k].F-G[j+2][l].F);\n\t\t      prev[j+2][l] = min(prev[j+2][l],cost+dp[j][k]);\n\t\t    }\n\t\t}\n\t    }\n\t  dp = prev;\n\t}      \n      //printVVI(dp);\n     \n    Next:;\n    \n      NoJump(G,dp);\n\n      //printVVI(dp);\n\n      if(!G[n-1].empty())\n\trep(i,G[n-1].size())mincost = min(mincost,dp[n-1][i]);\n      else\n\trep(i,G[n-2].size())mincost = min(mincost,dp[n-2][i]);\n      \n      cout << mincost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint n,m;\nint a,b;\nint fie[210][4];\t// 行、マス\nint dp[210][210][4];// x回目１こ飛ばし、行、マス\n\nvoid calc(int u)\n{\n\tu *= 2;\n\tfor(int i = u; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\t\t// 現在の立ち位置\n\t\t\tfor(int k = 0; k < 4; k++){\t// 次の場所\n\t\t\t\tfor(int add = 0; add <= 1; add++){\n\t\t\t\t\tif(add+(u/2) > m)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(fie[i][j] >= 0 && fie[i+1+add][k] >= 0){\n\t\t\t\t\t\tint nowRisk = (fie[i][j] + fie[i+1+add][k])*abs(j-k)+dp[u/2][i][j];\n\t\t\t\t\t\tif(dp[u/2][i][j] == -1)\n\t\t\t\t\t\t\tnowRisk += 1;\n\n//\t\t\t\t\t\tcout << nowRisk << endl ;\n\t\t\t\t\t\tif(dp[u/2+add][i+1+add][k] >= 0)\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = min(dp[u/2+add][i+1+add][k], nowRisk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = nowRisk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid solve()\n{\n\tint ans = (1 << 25);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tcin >> fie[i][b];\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i <= m; i++){\n\t\tcalc(i);\n\t\t\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif(dp[i][n+1][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+1][j]);\n\t\t\tif(dp[i][n+2][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+2][j]);\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcout << dp[0][i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tcout << ans << endl;\n\n\n\t\n}\n\nint main(void)\n{\n\n\twhile(cin >> n >> m, n | m){\n\t\tfill(fie[1], fie[1]+(200-1)*4, -1);\n\t\tfill(dp[0][0], dp[0][0] + 200*200*4, -1);\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfie[n+1][i] = 0;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nll n,m,c[150],K[150][10][2];\nll dp[150][76][10];\n\nint main(){\n\twhile(scanf(\"%lld%lld\",&n,&m),n){\n\t\tfor(ll i=0;i<n;i++){\n\t\t\tscanf(\"%lld\",&c[i]);\n\t\t\tfor(ll j=0;j<c[i];j++) scanf(\"%lld%lld\",&K[i][j][0],&K[i][j][1]);\n\t\t}\n\t\tfor(ll j=0;j<n;j++) for(ll i=0;i<=m;i++)\n\t\t\tfor(ll k=0;k<c[i];k++) dp[j][i][k]=(ll)INT_MAX;\n\t\tfor(ll k=0;k<c[0];k++) dp[0][0][k]=0;\n\t\tll res=(ll)INT_MAX;\n\t\tfor(ll j=1;j<n;j++) for(ll i=0;i<=m;i++) for(ll k=0;k<c[j];k++){\n\t\t\tfor(ll r=0;r<c[j-1];r++)\n\t\t\t\tdp[j][i][k]=min(dp[j][i][k],dp[j-1][i][r]+\n\t\t\t\t(K[j][k][1]+K[j-1][r][1])*abs(K[j][k][0]-K[j-1][r][0]));\n\t\t\tif(j>=2&&i>=1) for(ll r=0;r<c[j-2];r++)\n\t\t\t\tdp[j][i][k]=min(dp[j][i][k],dp[j-2][i-1][r]+\n\t\t\t\t(K[j][k][1]+K[j-2][r][1])*abs(K[j][k][0]-K[j-2][r][0]));\n\t\t}\n\t\tfor(ll i=0;i<=m;i++) for(ll k=0;k<c[n-1];k++)\n\t\t\tres=min(res,dp[n-1][i][k]);\n\t\tprintf(\"%lld\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nll dp[151][1001][77],ma[151][1001];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi,mx;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=1000;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tmx=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t\tmx=max(mx,x);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tfor(j=1;j<=mx;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=mx;l++){\n\t\t\t\t\t\t\tif(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n&&k>0){\n\t\t\t\t\t\t\t\tif(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=5;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\nconst int N = 150;\nint opt[N+2][N+2][10];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    while(cin >> n >> m and (n or m)) {\n        vector<vector<int>> pos(n + 2), slip(n + 2);\n        for(int i = 1; i <= n; i++) {\n            int k;\n            cin >> k;\n            pos[i].resize(k);\n            slip[i].resize(k);\n            for(int j = 0; j < k; j++) {\n                cin >> pos[i][j] >> slip[i][j];\n            }\n        }\n        for(int i = 0; i <= n + 1; i++) {\n            for(int j = 0; j <= m; j++) {\n                for(int cur_pos = 0; cur_pos < pos[i].size() + (i == 0 or i == n + 1); cur_pos++) {\n                    if(i == 0) {\n                        opt[i][j][cur_pos] = 0;    \n                    } else {\n                        opt[i][j][cur_pos] = lim<int>::max();\n                        for(int new_pos = 0; new_pos < pos[i - 1].size() + (i - 1 == 0); new_pos++) {\n                            int cost = i == n + 1 or i - 1 == 0 ? 0 : (slip[i][cur_pos] + slip[i - 1][new_pos]) * abs(pos[i][cur_pos] - pos[i - 1][new_pos]);\n                            opt[i][j][cur_pos] = min(opt[i][j][cur_pos], opt[i - 1][j][new_pos] + cost);\n                        }\n                        if(j > 0 and i - 2 >= 0) {\n                            for(int new_pos = 0; new_pos < pos[i - 2].size() + (i - 2 == 0); new_pos++) {\n                                int cost = i == n + 1 or i - 2 == 0 ? 0 : (slip[i][cur_pos] + slip[i - 2][new_pos]) * abs(pos[i][cur_pos] - pos[i - 2][new_pos]);\n                                opt[i][j][cur_pos] = min(opt[i][j][cur_pos], opt[i - 2][j - 1][new_pos] + cost);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << opt[n + 1][m][0] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n, m;\nvector<pair<int, int> > data[150];\nint dp[150][10];\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    for(int i=0;i<n+2;i++) data[i].clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      for(int j=0;j<a;j++){\n        int b, c;\n        cin >> b >> c;\n        data[i].push_back(pair<int, int>(b, c));\n      }\n    }\n    fill(dp[0], dp[150], INF);\n    for(int i=0;i<data[0].size();i++){\n      dp[0][i] = 0;\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<10;j++){\n        if(dp[i][j] != INF){\n          for(int l=0;l<=m;l++){\n            if(i+1+l >= n) continue;\n            for(int k=0;k<data[i+1+l].size();k++){\n              dp[i+1+l][k] = min(dp[i+1+l][k],\n                               dp[i][j] + (data[i][j].second + data[i+1+l][k].second) *\n                               (abs(data[i][j].first - data[i+1+l][k].first)));\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<10;i++){\n      ans = min(ans, dp[n-1][i]);\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77];\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int i = 0; i < 1001; i++)\n\t\t\t\tfill(cur[i],cur[i]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=cur;\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,fin[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nint n,m,a,b,c,minx,Ax,Ad,Bx,Bd;\nint dp[160][1100][90];\nvector<int>x[200];\n\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<200;i++){x[i].clear();}\n\t\tminx=1500000000;\n\t\tcin>>n>>m;\n\t\tif(n==0 && m==0){break;}\n\t\tfor(int i=0;i<=1000;i++){x[0].push_back(i*10000);}\n\t\tfor(int i=0;i<=1000;i++){x[n+1].push_back(i*10000);}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tx[i].push_back(b*10000+c);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,127,sizeof(dp));\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tAx=x[i][j]/10000;\n\t\t\t\t\tAd=x[i][j]%10000;\n\t\t\t\t\tif(dp[i][Ax][k]<=1000000000){\n\t\t\t\t\t\tfor(int l=0;l<x[i+1].size();l++){\n\t\t\t\t\t\t\tBx=x[i+1][l]/10000;Bd=x[i+1][l]%10000;\n\t\t\t\t\t\t\tdp[i+1][Bx][k]=min(dp[i+1][Bx][k],dp[i][Ax][k]+(Ad+Bd)*abs(Ax-Bx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int l=0;l<x[i+2].size();l++){\n\t\t\t\t\t\t\tBx=x[i+2][l]/10000;Bd=x[i+2][l]%10000;\n\t\t\t\t\t\t\tdp[i+2][Bx][k+1]=min(dp[i+2][Bx][k+1],dp[i][Ax][k]+(Ad+Bd)*abs(Ax-Bx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=1000;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tminx=min(minx,dp[n+1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  bool use[1500];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    vector<int> id[150];\n    int num = 0;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tif(i==n-1)use[num] = true;\n\telse use[num] = false;\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = -1;\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    if(m>0)for(int i=0;i<(int)id[1].size();i++)q.push(P2(P1(0,id[1][i]),1));\n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]<0 || g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]<0 || g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n    int ans = 1<<30;\n    for(int i=0;i<(int)id[n-1].size();i++)\n      for(int j=0;j<=m;j++)\n\tans = min(ans,g[id[n-1][i]][j]);\n\n    for(int i=0;i<(int)id[n-2].size();i++)\n      for(int j=0;j<m;j++)\n\tans = min(ans,g[id[n-2][i]][j]);\n      \n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct node{int line,row;};\nstruct edge{int cost; node now,to; };\n\ntypedef pair<int,int> P;\n\nvector<edge>G[MAX_V];\nint n,m;\n\nvoid solved(void){\n  int dp[155][11][80];\n\n for(int i=0;i<101;i++)\n   for(int j=0;j<=10;j++)\n     for(int k=0;k<80;k++)\n     dp[i][j][k]=INF;\n\n for(int i=0;i<11;i++)\n   dp[0][i][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n      edge e=G[i][j];\n      for(int k=0;k<=m;k++){\n\n\tif(i+1==e.to.line)dp[e.to.line][e.to.row][k]=min(dp[e.to.line][e.to.row][k],dp[e.now.line][e.now.row][k]+e.cost);\n\tif(i+2==e.to.line && k!=0)\n\t  dp[e.to.line][e.to.row][m-k]=min(dp[e.to.line][e.to.row][m-k],dp[e.now.line][e.now.row][m-k+1]+e.cost);\n      }\n    }\n  }\n  int ans=INF;    \n  for(int k=0;k<11;k++)\n    for(int j=0;j<=m;j++)\n      ans=min(ans,dp[n+1][k][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n\n    for(int i=0; i<MAX_V; i++)\n      for(int j=0;j<1005;j++)\n      graph[i][j]=0;\n \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n\n    edge e;\n    for(int i=0; i<=n; i++){\n      e.now.line=i;\n      e.now.row=e.to.row=0;\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  int row1=0,row2=0;\n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0 || i>=n){\n\n\t      if(graph[i+1][l]>0 || i+1==n+1){\n\t\te.to.line=i+1;\t      \n\t\te.cost=0;\n\t\te.to.row=row1;\n\t\trow1++;\n\t\tG[i].push_back(e);\n\t      }\n\t      if(graph[i+2][l]>0 || i+2==n+1){\n\t\te.to.line=i+2;\n\t\te.cost=0;\n\t\te.to.row=row2;\n\t\trow2++;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\t        \n\t    if(graph[i+1][l]>0){\n\t      e.to.line=i+1;\n\t      e.to.row=row1;\n\t      row1++;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);    \n\t    }\n\t    if(graph[i+2][l]>0){\n\t      e.to.line=i+2;\t      \n\t      e.to.row=row2;\n\t      row2++;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);  \n\t    }\n\n\t  }\n\t  if(i)e.now.row++;\n\t  if(i==0)break;\n\t}\n      }\n    }\n\n    solved();  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n\tdp[0][i][m]=dp[1][i][m]=dp[2][i][m-1]=0;\n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAX = 1000;\nconst ll INF = 1e17;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<vector<int>> xs(n), ds(n);\n\t\tvector<vector<vector<ll>>> dp(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d; x--;\n\t\t\t\txs[i].push_back(x);\n\t\t\t\tds[i].push_back(d);\n\t\t\t\tdp[i].push_back(vector<ll>(m + 1, INF));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < (int)xs[0].size(); i++) {\n\t\t\tdp[0][i][0] = 0;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < (int)xs[i - 1].size(); j++) {\n\t\t\t\tfor (int k = 0; k < (int)xs[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l <= m; l++) {\n\t\t\t\t\t\tdp[i][k][l] = min(dp[i][k][l], dp[i - 1][j][l] + abs(xs[i][k] - xs[i - 1][j]) * (ds[i][k] + ds[i - 1][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 1) continue;\n\t\t\tfor (int j = 0; j < (int)xs[i - 2].size(); j++) {\n\t\t\t\tfor (int k = 0; k < (int)xs[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\t\tdp[i][k][l + 1] = min(dp[i][k][l + 1], dp[i - 2][j][l] + abs(xs[i][k] - xs[i - 2][j]) * (ds[i][k] + ds[i - 2][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor (auto last : dp[n - 1]) {\n\t\t\tfor (auto val : last) {\n\t\t\t\tres = min(res, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct S{\n\tint x,y,r;\n};\nint main(){\n\tint m,n,t,u,ans,INF=1<<30;\n\twhile(cin>>n>>m,n){\n\t\tint d[n][10],cost[n][10][m+1];\n\t\trep(i,n){\n\t\t\trep(j,10){\n\t\t\t\td[i][j]=0;\n\t\t\t\trep(k,m+1)cost[i][j][k]=INF;\n\t\t\t}\n\t\t\tcin>>t; rep(j,t)cin>>u,cin>>d[i][u-1];\n\t\t}\n\t\tqueue<S> F; S s; ans=INF;\n\t\trep(i,10)rep(j,(m?2:1))if(d[j][i]){\n\t\t\ts.x=i,s.y=j,s.r=m-j;\n\t\t\tF.push(s),cost[j][i][m-j]=0;\n\t\t}\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.front(); F.pop();\n\t\t\trep(j,(cs.r?2:1)){\n\t\t\t\tif(cs.y+j+1<n)rep(i,10){\n\t\t\t\t\ts=cs; s.x=i,s.y=s.y+j+1,s.r-=j;\n\t\t\t\t\tt=cost[cs.y][cs.x][cs.r]+(d[cs.y][cs.x]+d[s.y][i])*(i-cs.x>0?i-cs.x:cs.x-i);\n\t\t\t\t\tif(d[s.y][i]&&cost[s.y][i][s.r]>t)\n\t\t\t\t\tcost[s.y][i][s.r]=t,F.push(s);\n\t\t\t\t}\n\t\t\t\tif(cs.y+j+1>=n&&ans>cost[cs.y][cs.x][cs.r])ans=cost[cs.y][cs.x][cs.r];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\nusing namespace std;\nint dp[80][160][10];\nint x[160][10],d[160][10],k[160];\nint n,m;\nint main(){\n cin>>n>>m;\n for(int i=0;i<n;i++){\n  cin>>k[i];\n  for(int j=0;j<k[i];j++){\n   cin>>x[i][j]>>d[i][j];   \n  }\n  if(!i)for(int mm=0;mm<=m;mm++)for(int j=0;j<k[i];j++)dp[mm][i][j]=0;\n  else for(int mm=0;mm<=m;mm++)for(int j=0;j<k[i];j++)dp[mm][i][j]=1145141919;\n  \n  if(i){\n    for(int mm=0;mm<=m;mm++){\n        for(int j=0;j<k[i];j++){\n         for(int r=0;r<k[i-1];r++){\n          dp[mm][i][j]=min(dp[mm][i][j],dp[mm][i-1][r]+(abs(x[i][j]-x[i-1][r])*(d[i][j]+d[i-1][r]))); \n         }\n        }\n    }\n  }\n  if(i>1){\n   for(int mm=1;mm<=m;m++){\n    for(int j=0;j<k[i];j++){\n     for(int r=0;r<k[i-2];r++){\n      dp[mm][i][j]=min(dp[mm][i][j],dp[mm-1][i-2][r]+(abs(x[i][j]-x[i-2][r])*(d[i][j]+d[i-2][r])));   \n     }\n    }\n   }\n  }\n }\n int ans=1145141919;\n for(int mm=0;mm<=m;mm++){\n  for(int j=0;j<k[n-1];j++){\n   ans=min(ans,dp[mm][n-1][j]);   \n  }\n }\n cout<<ans<<endl;\n return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%d\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%d %d\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\trep(i, k[0]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(0, 0, i));\n\t\t}\n\n\t\trep(i, k[1]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(0, 1, i));\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<cmath>\nusing namespace std;\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)break;\n        vector<vector<vector<int> > > mdan(n,vector<vector<int> >(m+1));\n        vector<vector<pair<int,int> > > sube(n);\n        int ki,x,d;\n        for(int i=0;i<n;i++){\n            scanf(\"%d\",&ki);\n            for(int j=0;j<ki;j++){\n                scanf(\"%d%d\",&x,&d);\n                sube[i].push_back(make_pair(x,d));\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=m;j++){\n                mdan[i][j]=vector<int>(sube[i].size(),-1);\n            }\n        }\n        for(int j=0;j<sube[0].size();j++){\n            mdan[0][0][j]=0;\n        }\n        if(m>0){\n            for(int j=0;j<sube[1].size();j++){\n                mdan[1][1][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<sube[i].size();j++){\n                if(i==0)mdan[i][0][j]=0;\n                if(i>=1){\n                    for(int l=0;l<sube[i-1].size();l++){\n                        for(int k=0;k<=m;k++){\n                            if(mdan[i-1][k][l]!=-1){\n                                int newd=mdan[i-1][k][l]+(sube[i-1][l].second+sube[i][j].second)*abs(sube[i-1][l].first-sube[i][j].first);\n                                if(mdan[i][k][j]==-1||mdan[i][k][j]>newd)mdan[i][k][j]=newd;\n                            }\n                        }\n                    }\n                }\n                if(i>=2){\n                    for(int l=0;l<sube[i-2].size();l++){\n                        for(int k=0;k<=m;k++){\n                            if(k>=1&&i>=2&&mdan[i-2][k-1][l]!=-1){\n                                int newd=mdan[i-2][k-1][l]+(sube[i-2][l].second+sube[i][j].second)*abs(sube[i-2][l].first-sube[i][j].first);\n                                if(mdan[i][k][j]==-1||mdan[i][k][j]>newd)mdan[i][k][j]=newd;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int mi=INT_MAX;\n        for(int l=0;l<sube[n-1].size();l++){\n            for(int k=0;k<=m;k++){\n                if(mdan[n-1][k][l]!=-1)mi=min(mi,mdan[n-1][k][l]);\n            }\n        }\n        if(n-2>=0){\n            for(int l=0;l<sube[n-2].size();l++){\n                for(int k=0;k<m;k++){\n                    if(mdan[n-2][k][l]!=-1)mi=min(mi,mdan[n-2][k][l]);\n                }\n            }\n        }\n        printf(\"%d\\n\",mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 152;\nconst int MAX_K = 12;\n\nint a[MAX_N];\nint dp[MAX_N][MAX_K][(MAX_N+1)/2];\nint n,m,K;\nvector<int> S[MAX_N];\nvector<int> T[MAX_N];\n\nint main()\n{\n\twhile(1){\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0){\n\t\tbreak;\n\t}\n\trep(i,n){\n\t\tscanf(\"%d\",&K);\n\t\trep(j,K){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tS[i].push_back(x-1);\n\t\t\tT[i].push_back(y);\n\t\t}\n\t}\n\trep(i,S[n-2].size()){\n\t\tS[n].push_back(S[n-2][i]);\n\t\tT[n].push_back(0);\n\t}\n\trep(i,S[n-1].size()){\n\t\tS[n].push_back(S[n-1][i]);\n\t\tT[n].push_back(0);\n\t}\n\tfill(dp[0][0],dp[n+1][0],INF);\n\trep(j,S[0].size()){\n\t\tdp[0][j][0] = 0;\n\t}\n\trep(j,S[1].size()){\n\t\trep(l,S[0].size()){\n\t\t\tdp[1][j][0] = min(dp[1][j][0],(T[0][l]+T[1][j])*abs(S[1][j]-S[0][l]));\n\t\t}\n\t\tif(m>=1){\n\t\t\tdp[1][j][1] = 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\trep(j,S[i+1].size()){\n\t\t\trep(k,m+1){\n\t\t\t\trep(l,S[i].size()){\n\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i][l][k]+(T[i][l]+T[i+1][j])*abs(S[i+1][j]-S[i][l]));\n\t\t\t\t}\n\t\t\t\tif(k>=1){\n\t\t\t\t\trep(l,S[i-1].size()){\n\t\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i-1][l][k-1]+(T[i-1][l]+T[i+1][j])*abs(S[i+1][j]-S[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(j,S[n].size()){\n\t\trep(k,m+1){\n\t\t\tans = min(ans,dp[n][j][k]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define INF 1000000000\nstruct S {int x,d;};\nint n,m;\nint dp[152][1002][80];\nvector<S> a[152];\n\nsigned main(){\n  while(cin>>n>>m,n){\n    REP(i,n+2)a[i].clear();\n    REP(i,n){\n      int k,x,d;\n      cin>>k;\n      REP(j,k){\n        cin>>x>>d;\n        a[i+1].push_back({x,d});\n      }\n    }\n    REP(i,n+2)REP(j,1000)REP(k,m+1)dp[i][j+1][k]=INF;\n    REP(j,1000)a[0].push_back({j+1,0});\n    REP(j,1000)a[n+1].push_back({j+1,0});\n    REP(j,1000)dp[0][j+1][0]=0;\n    REP(i,n+2){\n      for(S s:a[i]){\n        for(S t:a[i+1]){\n          REP(c,m+1){\n            dp[i+1][t.x][c]=min(dp[i+1][t.x][c],dp[i][s.x][c]+(s.d+t.d)*abs(s.x-t.x));\n          }\n        }\n        if(i+1>n)continue;\n        for(S u:a[i+2]){\n          REP(c,m){\n            dp[i+2][u.x][c+1]=min(dp[i+2][u.x][c+1],dp[i][s.x][c]+(s.d+u.d)*abs(s.x-u.x));\n          }\n        }\n      }\n    }\n    int ans=INF;\n    REP(j,1000)REP(c,m+1)ans=min(ans,dp[n+1][j+1][c]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int INF = (1<<21);\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n || m)){\n    int dp[150][10][80], a[150][10];\n    for(int i=0;i<150;i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<80;k++) dp[i][j][k] = INF;\n\ta[i][j] = INF;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int k;\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint b,c;\n\tcin >> b >> c;\n\tb--;\n\ta[i][b] = c;\n      }\n    }\n    for(int i=0;i<10;i++) dp[0][i][0] = 0;\n\n    for(int i=0;i<n-1;i++){\n      for(int l=0;l<=m;l++){\n\tfor(int j=0;j<10;j++){\n\t  if(a[i][j] == INF) continue;\n\t  for(int k=0;k<10;k++){\n\t    if(a[i+1][k] == INF) continue;\n\t    dp[i+1][k][l] = min(dp[i+1][k][l],dp[i][j][l] + (a[i][j] + a[i+1][k]) * (abs(k-j)));\n\t  }\n\t  for(int k=0;k<10;k++){\n\t    if(a[i+2][k] == INF) continue;\n\t    if(i < n - 2 && l != m) dp[i+2][k][l+1] = min(dp[i+2][k][l+1],dp[i][j][l] + (a[i][j] + a[i+2][k]) * (abs(k-j)));\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-1][k][j]);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint n,m;\nint stone[155][11][2];\nint dp[155][11][76];\nint num[155];\nint main(){\n\twhile(scanf(\"%d %d\",&n,&m) && m){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&num[i]);\n\t\t\tfor(int g=1;g<=num[i];g++){\n\t\t\t\tscanf(\"%d %d\",&stone[i][g][0],&stone[i][g][1]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<155;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=num[1];j++){\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tdp[1][j][k]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=num[2];j++){\n\t\t\tfor(int k=1;k<=m;k++){\n\t\t\t\tdp[2][j][k]=0;\n\t\t\t}\n\t\t\tfor(int y=1;y<=num[1];y++){\n\t\t\t\tdp[2][j][0]=min(dp[2][j][0],dp[1][y][0]+abs(stone[1][y][0]-stone[2][j][0])*(stone[1][y][1]+stone[2][j][1]));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=3;i<=n;i++){\n\t\t\tfor(int j=1;j<=num[i];j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tfor(int g=1;g<=num[i-1];g++){\n\t\t\t\t\t\tdp[i][j][k]=min(dp[i][j][k],dp[i-1][g][k]+abs(stone[i][j][0]-stone[i-1][g][0])*(stone[i][j][1]+stone[i-1][g][1]));\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=0){\n\t\t\t\t\t\tfor(int l=1;l<=num[i-2];l++){\n\t\t\t\t\t\t\tdp[i][j][k]=min(dp[i][j][k],dp[i-2][l][k-1]+abs(stone[i][j][0]-stone[i-2][l][0])*(stone[i][j][1]+stone[i-2][l][1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int j=1;j<=num[n];j++){\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\tres=max(res,dp[n][j][k]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=num[n-1];j++){\n\t\t\tfor(int k=1;k<=m;k++){\n\t\t\tres=max(res,dp[n-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\ntypedef pair<int,int> P;\n#define X first\n#define D second\n\nint main()\n{\n    int n, m;\n    while(cin>>n>>m, n|m) {\n        vector<int> k(n);\n        long long int dp[150][11][77] = {0};\n        vector< vector<P> > stone(n);\n        for(int i=0; i<n; i++) {\n            cin>>k[i];\n            for(int j=0; j<k[i]; j++) {\n                int x, d;\n                cin>>x>>d;\n                stone[i].push_back(P(x,d));\n            }\n        }\n        for(int i=0; i<n; i++) for(int j=0; j<k[i]; j++) for(int l=0; l<=m; l++) dp[i][j][l] = 10000000000;\n        for(int i=0; i<k[0]; i++) dp[0][i][m] = 0;\n        for(int i=0; i<k[1]; i++) dp[1][i][m-1] = 0;\n\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<k[i]; j++) {\n                for(int l=0; l<=m; l++) {\n\n                    if(i+1>=n) continue;\n                    for(int jj=0; jj<k[i+1]; jj++) {\n                        int add;\n                        add = abs((stone[i+1][jj].D+stone[i][j].D)*(stone[i+1][jj].X-stone[i][j].X));\n                        dp[i+1][jj][l] = min(dp[i+1][jj][l], dp[i][j][l]+add);\n                    }\n\n                    if(i+2>=n) continue;\n                    for(int jj=0; jj<k[i+2]; jj++) {\n                        int add;\n                        add = abs((stone[i+2][jj].D+stone[i][j].D)*(stone[i+2][jj].X-stone[i][j].X));\n                        dp[i+2][jj][l-1] = min(dp[i+2][jj][l-1], dp[i][j][l]+add);\n                    }\n                }\n            }\n        }\n\n        long long int ans = 10000000000;\n        for(int j=0; j<k[n-1]; j++) {\n            for(int l=0; l<=m; l++) {\n                ans = min(ans, dp[n-1][j][l]);\n            }\n        }\n        for(int j=0; j<k[n-2]; j++) {\n            for(int l=1; l<=m; l++) {\n                ans = min(ans, dp[n-2][j][l]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<utility>\n\n#define reps(i,f,n) for(int i = f; i < int(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define N 200\n#define W 2000\n\n\nusing namespace std;\n\n\nint dp[W][N];\n\n\nint main(void){\n\t\n\t\n\tint n,m;\n\twhile(scanf(\"%d %d\", &n, &m),n+m){\n\t\tvector<int> mx[200];\n\t\tvector<int> ms[200];\n\t\tvector<int> mi[200];\n\t\t\n\t\tint ki, x, d, in = 0;\n\t\trep(i,W)rep(j,N) dp[i][j] = 1000000000;\n\t\n\t\tm++;\n\t\t\n\t\trep(i, n){\n\t\t\tscanf(\"%d\", &ki);\n\t\t\t\n\t\t\trep(j, ki){\n\t\t\t\tscanf(\"%d %d\", &x, &d);\n\t\t\t\tmx[i+1].push_back(x);\n\t\t\t\tms[i+1].push_back(d);\n\t\t\t\tmi[i+1].push_back(in);\n\t\t\t\tin++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\trep(i,mx[1].size())dp[mi[1][i]][0] = 0;\n\t\t\n\t\tif(m > 0)rep(i,mx[2].size())dp[mi[2][i]][1] = 0;\n\t\t\n\t\treps(i,1,n){\n\t\t\trep(j,mx[i].size()){\n\t//\t\t\tprintf(\"---x:%d v:%d in:%d---\\n\", mx[i][j], ms[i][j], mi[i][j]);\n\t\t\t\trep(k, mx[i+1].size()){\n\t\t\t\t\trep(l, m){\n\t\t\t\t\t\tdp[mi[i+1][k]][l] = min(dp[mi[i+1][k]][l], \n\t\t\t\t\t\t\t\t\t\t\t\tdp[mi[i][j]][l] + (abs(mx[i+1][k] - mx[i][j]) * (ms[i+1][k] + ms[i][j])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(k, mx[i+2].size()){\n\t\t\t\t\trep(l, m-1){\n\t\t\t\t\t\tdp[mi[i+2][k]][l+1] = min(dp[mi[i+2][k]][l+1],\n\t\t\t\t\t\t\t\t\t\t\t\t  dp[mi[i][j]][l] + (abs(mx[i+2][k] - mx[i][j]) * (ms[i+2][k] + ms[i][j])));\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 2000000000;\n\t\t\n\t\trep(i,mx[n].size()){\n\t\t\trep(j,m){\n\t\t\t\tans = min(ans, dp[mi[n][i]][j]);\n\t\t\t}\n\t\t}\n\t\trep(i,mx[n-1].size()){\n\t\t\trep(j,m-1){\n\t\t\t\tans = min(ans, dp[mi[n-1][i]][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n+1){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n+1){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dijkstra(0) << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  while (cin >> n >> m, n) {\n    int dp[200][15][100] = {0};\n    vector<pii> G[200];\n\n    for (int i = 1; i <= n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n        int x, d;\n        cin >> x >> d;\n        G[i].PB(pii(x, d));\n      }\n    }\n\n    fill(dp[2][0], dp[200][0], INF);\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 0; j < G[i].size(); ++j) {\n        for (int k = 0; k <= m; ++k) {\n          for (int dy = 1; dy <= 2; ++dy) {\n            for (int j2 = 0; j2 < G[i + dy].size(); ++j2) {\n              if (dp[i][j][k] == INF) continue;\n              pii p1 = G[i][j], p2 = G[i + dy][j2];\n              int move = abs(p1.first - p2.first), sumd = p1.second + p2.second;\n              dp[i + dy][j2][k + dy - 1] = min(dp[i + dy][j2][k + dy - 1], dp[i][j][k] + sumd * move);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < G[n].size(); ++i) {\n      for (int j = 0; j <= m; ++j) {\n        ans = min(ans, dp[n][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\nconst int INF = 1e9;\nint n, m; \nint bmemo[160][1010];//b[y][x]\nvector<pair<int, int> > b[160];//\nint dp[160][1010][80];//dp[y??§?¨?][x??§?¨?][1????£???°????????£??????????????°] = ????????????????°????\nint main(void){\n\twhile(1){\n\t\t//input\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) return 0;\n\t\trep(i, 160)rep(j, 1010) bmemo[i][j] = INF;\n\t\trep(i, 160) b[i].clear();//?????????\n\t\trep(i, n){\n\t\t\tint k; cin >> k;\n\t\t\trep(j, k){//k???????????§?¨?\n\t\t\t\tint x, s; cin >> x >> s; x--;\n\t\t\t\tb[i].push_back(make_pair(x, s));\n\t\t\t\tbmemo[i][x] = s;\n\t\t\t}\n\t\t}\n\n\t\trep(i, 160)rep(j, 1010)rep(k, 80) dp[i][j][k] = INF;\n\t\tfor(auto start1 : b[0]){//???????????????????????£??????\n\t\t\tdp[0][start1.fi][0] = 0;\n\t\t}\n\n\t\tfor(auto start2 : b[1]){//????????????????£???°????????£??????\n\t\t\tdp[1][start2.fi][1] = 0;\n\t\t}\n\n\t\t//??????dp\n\t\tfor (int i = 0; i <  n - 1; ++i){\n\t\t\tfor (int j = 0; j < 1010; ++j){\n\t\t\t\tfor (int k = 0; k <= m; ++k){\n\t\t\t\t\tif(dp[i][j][k] == INF) continue;\n\t\t\t\t\t//??????????????£?????????\n\t\t\t\t\tfor(auto next : b[i + 1]){\n\t\t\t\t\t\tint score = (bmemo[i][j] + next.se) * abs(j - next.fi);//?????????????????±??????\n\t\t\t\t\t\tdp[i + 1][next.fi][k] = min(dp[i + 1][next.fi][k], dp[i][j][k] + score);\n\t\t\t\t\t}\n\t\t\t\t\tif(k == m || i == n - 2) continue;\n\t\t\t\t\t//???????£???°????????£??????\n\t\t\t\t\tfor(auto next : b[i + 2]){\n\t\t\t\t\t\tint score = (bmemo[i][j] + next.se) * abs(j - next.fi);//?????????????????±??????\n\t\t\t\t\t\tdp[i + 2][next.fi][k + 1] = min(dp[i + 2][next.fi][k + 1], dp[i][j][k] + score);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//????°????????????????\n\t\tint ans = INF;\n\t\tfor (int j = 0; j < 1010; ++j){\n\t\t\tfor (int k = 0; k <= m; ++k){\n\t\t\t\tans = min(ans, dp[n - 1][j][k]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < 1010; ++j){\n\t\t\tfor (int k = 0; k <= m - 1; ++k){\n\t\t\t \tans = min(ans, dp[n - 2][j][k]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  vector<int> id[150];\n  bool use[1500];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    int num = 0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tif(i==n-1)use[num] = true;\n\telse use[num] = false;\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = 1<<30;\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    if(m>0)for(int i=0;i<(int)id[1].size();i++)q.push(P2(P1(0,id[1][i]),1));\n\n    int ans;\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n      if(use[idx]){\n\tans = risk;\n\tbreak;\n      }\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint dp[100][3][1010];\nvector<vector<pint> > river;\nint k[200];\n\nint main() {\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\triver.clear();\n\t\tint i,j;\n\t\tvector<pint> buf;\n\t\tfor(i=0;i<n;i++){\n\t\t\triver.push_back(buf);\n\t\t\tk[i]=in();\n\t\t\tint x,d;\n\t\t\tfor(j=0;j<k[i];j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\triver[i].push_back(mp(x,d));\n\t\t\t}\n\t\t}\n\t\tint from,to,cost;\n\t\tfor(i=0;i<k[0];i++){\n\t\t\tdp[0][0][river[0][i].first]=0;\n\t\t}\n\t\tfor(i=0;i<k[1];i++){\n\t\t\tdp[1][1][river[1][i].first]=0;\n\t\t}\n\t\tfor(i=0;i<k[0];i++){\n\t\t\tfor(j=0;j<k[1];j++){\n\t\t\t\tfrom=river[0][i].first;\n\t\t\t\tto=river[1][j].first;\n\t\t\t\tcost=(river[0][i].second+river[1][j].second)*abs(from-to);\n\t\t\t\tif(dp[0][1][to]==-1||dp[0][1][to]>cost){\n\t\t\t\t\tdp[0][1][to]=cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=n-3;i++){\n\t\t\tint t,s;\n\t\t\tfor(t=0;t<k[i];t++){\n\t\t\t\tfor(s=0;s<k[i+2];s++){\n\t\t\t\t\tfor(j=0;j<m;j++){\n\t\t\t\t\t\tfrom=river[i][t].first;\n\t\t\t\t\t\tto=river[i+2][s].first;\n\t\t\t\t\t\tcost=(river[i][t].second+river[i+2][s].second)*abs(from-to);\n\t\t\t\t\t\tif(dp[j][0][from]==-1)continue;\n\t\t\t\t\t\tif(dp[j+1][2][to]==-1||dp[j+1][2][to]>dp[j][0][from]+cost){\n\t\t\t\t\t\t\tdp[j+1][2][river[i+2][s].first]=dp[j][0][river[i][t].first]+cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(t=0;t<k[i+1];t++){\n\t\t\t\tfor(s=0;s<k[i+2];s++){\n\t\t\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\t\t\tfrom=river[i+1][t].first;\n\t\t\t\t\t\tto=river[i+2][s].first;\n\t\t\t\t\t\tcost=(river[i+1][t].second+river[i+2][s].second)*abs(from-to);\n\t\t\t\t\t\tif(dp[j][1][from]==-1)continue;\n\t\t\t\t\t\tif(dp[j][2][to]==-1||dp[j][2][to]>dp[j][1][from]+cost){\n\t\t\t\t\t\t\tdp[j][2][river[i+2][s].first]=dp[j][1][river[i+1][t].first]+cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(t=0;t<1010;t++){\n\t\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\t\tdp[j][0][t]=dp[j][1][t];\n\t\t\t\t\tdp[j][1][t]=dp[j][2][t];\n\t\t\t\t\tdp[j][2][t]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=100100100;\n\t\tfor(i=0;i<1010;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tif(dp[j][1][i]!=-1)chmin(res,dp[j][1][i]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<1010;i++){\n\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\tif(dp[j][0][i]!=-1)chmin(res,dp[j][0][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n\nint n;\nint dp[152][102][80];//何列目の何個目の石で残り何回\nvector<pair<int,int> > stone[150];\n\nint solve(int now, int k, int m){\n    if(now == n-1) return 0;\n    if(now == n-2 && m > 0) return 0;\n    if(dp[now][k][m] != -1) return dp[now][k][m];\n\n    int ans = INT_MAX;\n    for(int i=0; i<stone[now+1].size(); i++){\n        int cost = abs(stone[now][k].first - stone[now+1][i].first) * (stone[now][k].second + stone[now+1][i].second);\n        ans = min(ans, cost + solve(now+1, i, m));\n    }\n    if(m > 0){\n        for(int i=0; i<stone[now+2].size(); i++){\n            int cost = abs(stone[now][k].first - stone[now+2][i].first) * (stone[now][k].second + stone[now+2][i].second);\n            ans = min(ans, cost + solve(now+2, i, m-1));\n        }\n    }\n    return dp[now][k][m] = ans;\n}\n\nint main(){\n    iostream::sync_with_stdio(false);\n    START:\n    int m;\n    cin >> n >> m;\n    if(n == 0 && m == 0) return 0;\n    for(int i=0; i<n; i++){\n        int k;\n        cin >> k;\n        stone[i].clear();\n        for(int j=0; j<k; j++){\n            int a, b;\n            cin >> a >> b;\n            stone[i].push_back(make_pair(a, b));\n            for(int l=0; l<=m; l++){\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n\n    int ans = INT_MAX;\n    for(int i=0; i<stone[0].size(); i++){\n        ans = min(ans, solve(0, i, m));\n    }\n    if(m > 0){\n        for(int i=0; i<stone[1].size(); i++){\n            ans = min(ans, solve(1, i, m-1));\n        }\n    }\n    cout << ans << endl;\n\n    goto START;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nconst int inf = 3e17;\n\nsigned main()\n{\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        int dp[155][15][100];\n        int stone[155][15];\n\n        rep(i, n+5) rep(j, 15) stone[i][j] = inf;\n        rep(i, n+5) rep(j, 15) rep(k, 100) dp[i][j][k] = inf;\n\n        rep(i, n) {\n            int k; cin >> k;\n            rep(j, k) {\n                int x, d; cin >> x >> d;\n                --x;\n                stone[i][x] = d;\n                if (i == 0) dp[0][x][0] = 0;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 11; ++j) {\n                if (stone[i][j] == inf) continue;\n\n                for (int k = 0; k < m+1; ++k) {\n                    if (k < m) {\n                        rep(l, 11) {\n                            if (stone[i + 2][l] == inf) continue;\n\n                            dp[i + 2][l][k + 1] = min(\n                                    dp[i + 2][l][k + 1],\n                                    dp[i][j][k] + (stone[i][j] + stone[i + 2][l]) * abs(j-l)\n                                    );\n                        }\n                    }\n\n                    rep(l, 11) {\n                        if (stone[i + 1][l] == inf) continue;\n\n                        dp[i + 1][l][k] = min(\n                                dp[i + 1][l][k],\n                                dp[i][j][k] + (stone[i][j] + stone[i + 1][l]) * abs(j-l)\n                                );\n                    }\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j < m + 1; ++j) {\n                mi = min(mi, dp[n - 1][i][j]);\n            }\n        }\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mi = min(mi, dp[n - 2][i][j]);\n            }\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define INF 10000000\n\nstruct tStone{\n\tint x, d, min;\n};\nvector< vector<tStone> > stones;\nint N;\n\nint solve( int n, int x, int m ){\t// stones[n][x]ツつゥツづァツづ個派ツ青カツ探ツ催オ\n\tif( (n==N) || (n+1==N && m>0) ){\n\t\treturn 0;\n\t}\n\ttStone &st = stones[n][x];\n\tint dmin = INF;\n\tfor( int i=0; i<stones[n+1].size(); i++ ){\n\t\ttStone &next = stones[n+1][i];\n\t\tint danger = (n==0) ? 0 : (st.d + next.d) * abs(st.x-next.x);\n\t\tdmin = min( dmin, /*( next.min<INF ? next.min : solve( n+1, i, m ) )*/solve(n+1,i,m) + danger );\n\t}\n\tif( m>0 && n+2<=N ){\n\t\tfor( int i=0; i<stones[n+2].size(); i++ ){\n\t\t\ttStone &next = stones[n+2][i];\n\t\t\tint danger = (n==0) ? 0 : (st.d + next.d) * abs(st.x-next.x);\n\t\t\tdmin = min( dmin, /*( next.min<INF ? next.min : solve( n+2, i, m-1 ) )*/solve(n+2,i,m-1) + danger );\n\t\t}\n\t}\n//\tst.min = dmin;\n\treturn dmin;\n}\n\nint main(){\n\tint n, m;\n\tstones.resize(151);\n\tstones[0].push_back(tStone());\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif( n==0 && m==0 )\tbreak;\n\t\tint k,x,d;\n\t\tN = n;\n\t\tfor( int i=1; i<=n; i++ ){\n\t\t\tcin >> k;\n\t\t\tstones[i].clear();\n\t\t\tfor( int j=1; j<=k; j++ ){\n\t\t\t\tcin >> x >> d;\n\t\t\t\ttStone st;\n\t\t\t\tst.x = x;\n\t\t\t\tst.d = d;\n\t\t\t\tst.min = INF;\n\t\t\t\tstones[i].push_back(st);\n\t\t\t}\n\t\t}\n\t\tcout << solve(0,0,m) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n#define for_each(it,a) for(__typeof a.begin() it = a.begin();it!=a.end();it++)\ntemplate<class T> inline void chmin(T& a, T b) { if( b < a ) a = b; }\n\nint n, m;\nstruct edge{\n  int pos, dang;\n  vector < int >  value;\n  edge( int pos, int dang): pos(pos), dang(dang), value( (n + 1) / 2 + 1, INF){};\n};\nint main(){\n\n  while( scanf(\"%d %d\", &n, &m) , n){\n    vector< vector < edge > > info(n + 2);\n\n    for(int i = 0; i < n; i++){\n      int k;\n      scanf(\"%d\", &k);\n      for(int j = 0; j < k; j++){\n        int t, d;\n        scanf(\"%d %d\", &t, &d);\n        info[i].push_back( edge( t, d));\n      }\n    }\n    for_each( it, info[0]) it -> value[m] = 0;\n    for_each( it, info[1]) it -> value[m - 1] = 0;\n    int ret = INF;\n    for( int i = 0; i < n; i++){\n      for_each( now, info[i]){\n        for(int j = m; j >= 0; j--){ //ジャンプできる残り回数\n          int& cost = now -> value[j], dang = now -> dang, pos = now -> pos;\n          if( cost == INF) continue;\n          if(j > 0){ //ジャンプしてみる\n            for_each( next, info[i + 2]){\n              chmin( next -> value[j - 1], cost + (dang + next -> dang) * abs( pos - next -> pos));\n            }\n          }\n          for_each( next, info[i + 1]){\n            chmin( next -> value[j], cost + (dang + next -> dang) * abs( pos - next -> pos));\n          }\n        }\n      }\n    }\n    for_each(it,info[n - 1]) chmin( ret, *min_element( it->value.begin(), it->value.end()));\n    for_each(it,info[n - 2]) chmin( ret, *min_element( it->value.begin() + 1, it->value.end()));\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > x(n+1), d(n+1);\n        vector<vector<vector<int> > > dp(n+1);\n        for(int i=1; i<=n; ++i){\n            int k;\n            cin >> k;\n            for(int j=0; j<k; ++j){\n                int a, b;\n                cin >> a >> b;\n                x[i].push_back(a);\n                d[i].push_back(b);\n                if(i <= 2){\n                    dp[i].push_back(vector<int>(m+1, 0));\n                    if(i == 2)\n                        dp[i].back()[m] = INT_MAX/2;\n                }\n                else\n                    dp[i].push_back(vector<int>(m+1, INT_MAX/2));\n            }\n        }\n\n        for(int i=1; i<n; ++i){\n            for(unsigned j=0; j<x[i].size(); ++j){\n                for(unsigned k=0; k<x[i+1].size(); ++k){\n                    for(int l=0; l<=m; ++l)\n                        dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][l] + (d[i][j]+d[i+1][k]) * abs(x[i][j]-x[i+1][k]));\n                }\n                if(i == n-1)\n                    continue;\n                for(unsigned k=0; k<x[i+2].size(); ++k){\n                    for(int l=1; l<=m; ++l)\n                        dp[i+2][k][l-1] = min(dp[i+2][k][l-1], dp[i][j][l] + (d[i][j]+d[i+2][k]) * abs(x[i][j]-x[i+2][k]));\n                }\n            }\n        }\n\n        int ret = INT_MAX;\n        for(unsigned i=0; i<x[n].size(); ++i)\n            ret = min(ret, dp[n][i][0]);\n        if(m > 0){\n            for(unsigned i=0; i<x[n-1].size(); ++i)\n                ret = min(ret, dp[n-1][i][1]);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0)\n\t\t\t\tdp[0][i][m]=0;\n\t\t}\n\t\tif(m!=0){\n\t\t\tfor(int i = 0; i < 1001; i++){\n\t\t\t\tif(field[1][i]!=0)\n\t\t\t\t\tdp[1][i][m-1]=0;\n\t\t\t}\n\t\t}\n\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(cur[j],cur[j]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\tif(field[i-1][k]==0&&(i<=1||field[i-2][k]==0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++)\n\t\t\t\tminRes=min(minRes,cur[i][j]);\n\t\t\tfor(int j = 1; j <= m; j++)\n\t\t\t\tminRes=min(minRes,prv[i][j]);\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define fi first\n#define se second\n\nconst int inf = 1e17 + 9;\n\ntypedef pair<int, int> P;\n\nint n, m;\nint k[160];\n\nint dp[160][16][80];\n\nsigned main()\n{\n  while (cin >> n >> m, n){\n    vector<P> s[160];\n    rep(i, n){\n      cin >> k[i];\n      rep(j, k[i]){\n        int d, x;\n        cin >> x >> d;\n        s[i].push_back(P(x, d));\n      }\n    }\n\n    rep(i, 160) rep(j, 16) rep(l, 80) dp[i][j][l] = inf;\n\n    rep(j, k[0]) dp[0][j][m] = 0;\n    if (m) rep(j, k[1]) dp[1][j][m - 1] = 0;\n\n    rep(i, n - 1){\n      rep(j, k[i]){\n        rep(l, m + 1){\n          if (i == n - 2 && l > 0) continue;\n\n          rep(t, k[i + 1]){\n            int cost = (s[i][j].se + s[i + 1][t].se) * abs(s[i][j].fi - s[i + 1][t].fi);\n            //printf(\"%d:%d -> %d:%d = %d\\n\", i, j, i + 1, t, cost);\n            dp[i + 1][t][l] = min(dp[i + 1][t][l], dp[i][j][l] + cost);\n          }\n\n          if (l > 0){\n            rep(t, k[i + 2]){\n              int cost = (s[i][j].se + s[i + 2][t].se) * abs(s[i][j].fi - s[i + 2][t].fi);\n              //printf(\"%d:%d -> %d:%d = %d\\n\", i, j, i + 2, t, cost);\n              dp[i + 2][t][l - 1] = min(dp[i + 2][t][l - 1], dp[i][j][l] + cost);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = inf;\n    rep(j, k[n - 1]) rep(l, m + 1) ans = min(ans, dp[n - 1][j][l]);\n    rep(j, k[n - 2]) for (int l = 1; l <= m; l++) ans = min(ans, dp[n - 2][j][l]);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans;\nLL V[160][1010];\n//LL mem[160][1001][80];\n\nLL cal(int y,int x,int m){\n    LL res=INF;\n    //if(mem[y][x][m]!=-1)return mem[y][x][m];\n    if(y>=N)return 0;\n    if(y==0){\n        FOR(i,1,1000){\n            if(V[y+1][i]!=INF)\n            res=cal(y+1,i,m);\n        }\n    }\n    else{\n        if(V[y][x]!=INF){\n            FOR(i,1,1000){\n                    if(m>0&&V[y+1][i]!=INF&&V[y+2][i]!=INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,min(cal(y+2,i,m-1)+d2,res));\n                    }\n                    else if(V[y+1][i]!=INF&&V[y+2][i]==INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,res);\n                    }\n                    else if(V[y+1][i]==INF&&V[y+2][i]!=INF&&m>0){\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+2,i,m)+d2,res);\n                    }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin>>N>>M;\n    //memset(mem,-1,sizeof(mem));\n    rep(i,151)rep(j,1001)V[i][j]=INF;\n    FOR(i,1,N){\n        LL t;\n        cin>>t;\n        rep(j,t){\n            LL x,k;\n            cin>>x>>k;\n            V[i][x]=k;\n        }\n    }\n    ans=cal(0,0,M);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint field[160][2000] = {0},dp[5][2000][1010] = {0};\nint main()\n{\n    int N,M,K,k1,k2,MAX = 0,ANS;\n    while(scanf(\"%d%d\",&N,&M),N + M)\n    {\n        for(int i = 0; i < 150; i++)\n        {\n            for(int j = 0; j < 1000; j++)\n            {\n                field[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < 4; i++)\n        {\n            for(int j = 0; j < 1000; j++)\n            {\n                for(int k = 0; k < 1000; k++)\n                {\n                    dp[i][j][k] = 0;\n                }\n            }\n        }\n        ANS = 10000000;\n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\",&K);\n            for(int j = 0; j < K; j++)\n            {\n                scanf(\"%d%d\",&k1,&k2);\n                field[i + 1][k1 - 1] = k2;\n                MAX = max(MAX,k1);\n            }\n        }\n        /*for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < MAX; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 2; i < N + 1; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < MAX; k++)\n                {\n                    if(field[i][k] != 0)\n                    {\n                        dp[2][k][j] = 10000000;\n                        if(j == 0)\n                        {\n                            for(int l = 0; l < MAX; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[2][k][0] = min(dp[2][k][0],dp[1][l][0] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                        else if(i >= j * 2)\n                        {\n                            for(int l = 0; l < MAX; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[2][k][j] = min(dp[2][k][j],dp[1][l][j] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                                if(field[i - 2][l] != 0 || i - 2 == 0)\n                                {\n                                    dp[2][k][j] = min(dp[2][k][j],dp[0][l][j - 1] + (field[i - 2][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                    }\n                }\n                for(int k = 0; k < MAX; k++)\n                {\n                    for(int l = 0; l < 2; l++)\n                    {\n                        dp[l][k][j] = dp[l + 1][k][j];\n                    }\n                }\n            }\n        }\n        /*for(int i = 0; i < N + 1; i++)\n        {\n            for(int j = 0; j < MAX; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        for(int i = 0; i < N + 1; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < MAX; k++)\n                {\n                    printf(\"%2d\",dp[i][k][j]);\n                }\n                printf(\" / \");\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 0; i < M + 1; i++)\n        {\n            for(int j = 0; j < MAX; j++)\n            {\n                if(field[N][j] != 0)\n                {\n                    ANS = min(ANS,dp[1][j][i]);\n                }\n                if(i < M && field[N - 1][j] != 0)\n                {\n                    ANS = min(ANS,dp[0][j][i]);\n                }\n            }\n        }\n        printf(\"%d\\n\",ANS);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 1000000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nint dp[152][1001][76];\nint s[152][1001];\nint abs(int x){\n\tif(x<0) return -1*x;\n\telse return x;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0&&m==0) break;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tfor(int j=1; j<1001; ++j){\n\t\t\t\ts[i][j]=INF;\n\t\t\t\tfor(int k=0; k<=m; ++k){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0; j<k; ++j){\n\t\t\t\tint t1,t2;\n\t\t\t\tcin >> t1 >> t2;\n\t\t\t\ts[i][t1]=t2;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<1001; ++i){\n\t\t\tif(s[1][i]!=INF) dp[1][i][0]=0;\n\t\t}\n\t\tfor(int i=1; i<1001; ++i){\n\t\t\tif(s[2][i]!=INF){\n\t\t\t\tfor(int j=1; j<1001; ++j){\n\t\t\t\t\tif(s[1][j]!=INF){\n\t\t\t\t\t\tdp[2][i][0]=min(dp[2][i][0],(s[2][i]+s[1][j])*abs(i-j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[2][i][1]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=3; i<=n; ++i){\n\t\t\tfor(int j=1; j<1001; ++j){\n\t\t\t\tif(s[i][j]!=INF){\n\t\t\t\t\tfor(int k=0; k<=m; ++k){\n\t\t\t\t\t\tfor(int l=1; l<1001; ++l){\n\t\t\t\t\t\t\tif(s[i-1][l]!=INF&&dp[i-1][l][k]!=INF){\n\t\t\t\t\t\t\t\tdp[i][j][k]=min(dp[i][j][k],(s[i-1][l]+s[i][j])*abs(j-l)+dp[i-1][l][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(s[i-2][l]!=INF&&k!=0&&dp[i-2][l][k-1]!=INF){\n\t\t\t\t\t\t\t\tdp[i][j][k]=min(dp[i][j][k],(s[i-2][l]+s[i][j])*abs(j-l)+dp[i-2][l][k-1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=1; i<1001; ++i){\n\t\t\tfor(int j=0; j<=m; ++j){\n\t\t\t\tans=min(ans,dp[n][i][m]);\n\t\t\t\tif(j<m) ans=min(ans,dp[n-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\nconst int INF=100000000;\nint main(void){\n\tint n,m;\n\tint st[152],stx[152][11],sts[152][11];\n\tint dp[152][11][78];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(st,0,sizeof(st));\n\t\tmemset(stx,0,sizeof(stx));\n\t\tmemset(sts,0,sizeof(sts));\n\t\tfor(int i=0;i<152;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst[0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&st[i]);\n\t\t\tfor(int j=0;j<st[i];j++){\n\t\t\t\tscanf(\"%d%d\",&stx[i][j],&sts[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<st[0];i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tif(m>=1)for(int i=0;i<st[1];i++){\n\t\t\tdp[1][i][1]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tfor(int k=0;k<st[i];k++){\n\t\t\t\t\tfor(int l=0;l<st[i-1];l++){\n\t\t\t\t\t\tdp[i][k][j]=min(dp[i][k][j],dp[i-1][l][j]+(sts[i][k]+sts[i-1][l])*abs(stx[i][k]-stx[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=m && i>=2)for(int l=0;l<st[i-2];l++){\n\t\t\t\t\t\tdp[i][k][j+1]=min(dp[i][k][j+1],dp[i-2][l][j]+(sts[i][k]+sts[i-2][l])*abs(stx[i][k]-stx[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<st[n-1];k++){\n\t\t\t\tans=min(ans,dp[n-1][k][j]);\n\t\t\t}\n\t\t\tif(j!=m)for(int k=0;k<st[n-2];k++){\n\t\t\t\tans=min(ans,dp[n-2][k][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n | m)\n\t{\n\t\tint k[200], x[200][16], d[200][16];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", k + i);\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t\tscanf(\"%d%d\", &x[i][j], &d[i][j]);\n\t\t}\n\n\t\tconst int INF = 1 << 29;\n\t\tstatic int dp[200][16][100];\t// row, column, jump left\n\t\tfor (int i = 0; i < 200; ++i)\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tfor (int a = 0; a < 100; ++a)\n\t\t\t\t\tdp[i][j][a] = INF;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tdp[i][j][m - i] = 0;\n\n\t\tfor (int i = 0; i < n - 1; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t{\n\t\t\t\tfor (int a = 0; a <= m; ++a)\n\t\t\t\t{\n\t\t\t\t\tfor (int b = 0; b < k[i + 1]; ++b)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin_swap(dp[i + 1][b][a]\n\t\t\t\t\t\t, dp[i][j][a] + (d[i][j] + d[i + 1][b]) * abs(x[i][j] - x[i + 1][b]));\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 2 < n && a > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int b = 0; b < k[i + 2]; ++b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin_swap(dp[i + 2][b][a - 1],\n\t\t\t\t\t\t\t\tdp[i][j][a] + (d[i][j] + d[i + 2][b]) * abs(x[i][j] - x[i + 2][b]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = n - 2; i < n; ++i)\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t\tfor (int a = 0; a <= m; ++a)\n\t\t\t\t\tif (i == n - 1 || a > 0)\n\t\t\t\t\t\tmin_swap(res, dp[i][j][a]);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<cmath>\nusing namespace std;\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)break;\n        vector<vector<vector<int> > > mdan(n,vector<vector<int> >(m+1));\n        vector<vector<pair<int,int> > > sube(n);\n        int ki,x,d;\n        for(int i=0;i<n;i++){\n            scanf(\"%d\",&ki);\n            for(int j=0;j<ki;j++){\n                scanf(\"%d%d\",&x,&d);\n                sube[i].push_back(make_pair(x,d));\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=m;j++){\n                mdan[i][j]=vector<int>(sube[i].size(),-1);\n            }\n        }\n        for(int j=0;j<sube[0].size();j++){\n            mdan[0][0][j]=0;\n        }\n        if(m>0){\n            for(int j=0;j<sube[1].size();j++){\n                mdan[1][1][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<sube[i].size();j++){\n                if(i==0)mdan[i][0][j]=0;\n                if(i>=1){\n                    for(int l=0;l<sube[i-1].size();l++){\n                        for(int k=0;k<=m;k++){\n                            if(mdan[i-1][k][l]!=-1){\n                                int newd=mdan[i-1][k][l]+(sube[i-1][l].second+sube[i][j].second)*abs(sube[i-1][l].first-sube[i][j].first);\n                                if(mdan[i][k][j]==-1||mdan[i][k][j]>newd)mdan[i][k][j]=newd;\n                            }\n                        }\n                    }\n                }\n                if(i>=2){\n                    for(int l=0;l<sube[i-2].size();l++){\n                        for(int k=0;k<=m;k++){\n                            if(k>=1&&i>=2&&mdan[i-2][k-1][l]!=-1){\n                                int newd=mdan[i-2][k-1][l]+(sube[i-2][l].second+sube[i][j].second)*abs(sube[i-2][l].first-sube[i][j].first);\n                                if(mdan[i][k][j]==-1||mdan[i][k][j]>newd)mdan[i][k][j]=newd;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int mi=INT_MAX;\n        for(int l=0;l<sube[n-1].size();l++){\n            for(int k=0;k<=m;k++){\n                if(mdan[n-1][k][l]!=-1)mi=min(mi,mdan[n-1][k][l]);\n            }\n        }\n        printf(\"%d\\n\",mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t//// ún_ÌÝè\n\t\t//for(int i = 0; i < 1001; i++){\n\t\t//\tif(field[0][i]!=0){\n\t\t//\t\tdp[0][i][m]=0;\n\t\t//\t}\n\t\t//}\n\t\t//int (*fin)[77];\n\t\t//// dpÅÅ¬RXgðßé\n\t\t//for(int i = 1; i < n; i++){\n\t\t//\tswap(cur,prv);\n\t\t//\tswap(pprv,cur);\n\t\t//\tfor(int i = 0; i < 1001; i++)\n\t\t//\t\tfill(cur[i],cur[i]+77,INF);\n\t\t//\t// Ç±ÖWv·é©\n\t\t//\tfor(int j = 0; j < 1001; j++){\n\t\t//\t\tif(field[i][j]==0)\n\t\t//\t\t\tcontinue;\n\t\t//\t\t// Ç±©çWv·é©\n\t\t//\t\tfor(int k = 0;  k < 1001; k++){\n\t\t//\t\t\t// ÇÌRXgÅWv·é©\n\t\t//\t\t\tfor(int l = m; l >= 0; l--){\n\t\t//\t\t\t\t// ÓÂ¤ÉWv\n\t\t//\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t//\t\t\t\tif(i>=2&&l!=m){\n\t\t//\t\t\t\t\t// êÂòÎµÅWv\n\t\t//\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//\tfin=cur;\n\t\t//}\n\t\t//int minRes=INF;\n\t\t//for(int i = 0; i < 1001; i++){\n\t\t//\tfor(int j = 0; j <= m; j++){\n\t\t//\t\tminRes=min(minRes,fin[i][j]);\n\t\t//\t}\n\t\t//}\n\t\t//cout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n, m;\n\nstruct edge {\n\tint from,to;\n\tint cost;\n\tbool sp;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int t,int c,bool f) : to(t), cost(c), sp(f) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvector<edge> G[2000];\nint d[2000][2000];\n\nvoid dijkstra(int s) {\n\t// cost ticket place\n\tpriority_queue<pair<int, pair<int, int> >, vector< pair<int, pair<int, int> > >, greater< pair<int, pair<int, int> > > > que;\n\trep(i, 2000) rep(j, 2000) d[i][j] = INF;\n\td[s][0] = 0;\n\tque.push(mp(0, mp(0,s)));\n\t\n\twhile(que.size()) {\n\t\tint c = que.top().first;\n\t\tP p = que.top().second;\n\n\t\tque.pop();\n\t\tint t = p.first;\n\t\tint v = p.second;\n\n\t\tif(d[v][t] < c) continue;\n\t\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(e.sp) {\n\t\t\t\tif(t + 1 <= m && d[e.to][t+1] > d[v][t] + e.cost) {\n\t\t\t\t\td[e.to][t+1] = d[v][t] + e.cost;\n\t\t\t\t\tque.push(mp(d[e.to][t+1], mp(t+1, e.to)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(d[e.to][t] > d[v][t] + e.cost) {\n\t\t\t\t\td[e.to][t] = d[v][t] + e.cost;\n\t\t\t\t\tque.push(mp(d[e.to][t], mp(t, e.to)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> m) {\n\t\tif(n == 0 && m == 0) break;\n\n\t\trep(i, 2000) G[i].clear();\n\n\t\tvector<pair<P, int> > v[n];\n\t\tint id = 1;\n\t\trep(i, n) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\n\t\t\trep(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv[i].push_back(mp(mp(a, b), id));\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\n\t\trep(i, v[0].size()) {\n\t\t\tP p = v[0][i].first;\n\t\t\tint a = v[0][i].second;\n\t\t\tG[0].push_back(edge(a, 0, false));\n\t\t}\n\n\t\tif(n >= 2) {\n\t\t\trep(i, v[1].size()) {\n\t\t\t\tP p = v[1][i].first;\n\t\t\t\tint a = v[1][i].second;\n\t\t\t\tG[0].push_back(edge(a, 0, true));\n\t\t\t}\n\t\t}\n\n\t\trep(i, n-1) {\n\t\t\trep(j, v[i].size()) {\n\t\t\t\tP p = v[i][j].first;\n\t\t\t\tint a = v[i][j].second;\n\t\t\t\t\n\t\t\t\trep(k, v[i+1].size()) {\n\t\t\t\t\tP q = v[i+1][k].first;\n\t\t\t\t\tint b = v[i+1][k].second;\n\t\t\t\t\tint c = (p.second + q.second) * abs(p.first - q.first);\n\n\t\t\t\t\tG[a].push_back(edge(b, c, false));\n\t\t\t\t}\n\n\t\t\t\tif(i >= n-2) continue;\n\n\t\t\t\trep(k, v[i+2].size()) {\n\t\t\t\t\tP q = v[i+2][k].first;\n\t\t\t\t\tint b = v[i+2][k].second;\n\t\t\t\t\tint c = (p.second + q.second) * abs(p.first - q.first);\n\n\t\t\t\t\tG[a].push_back(edge(b, c, true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(n >= 2) {\n\t\t\trep(i, v[n-2].size()) {\n\t\t\t\tP p = v[n-2][i].first;\n\t\t\t\tint b = v[n-2][i].second;\n\t\t\t\tG[b].push_back(edge(id, 0, true));\n\t\t\t}\n\t\t}\n\n\t\trep(i, v[n-1].size()) {\n\t\t\tP p = v[n-1][i].first;\n\t\t\tint b = v[n-1][i].second;\n\t\t\tG[b].push_back(edge(id, 0, false));\n\t\t}\n\n\t\t// cout << \"GRAPH\" << endl;\n\t\t//\n\t\t// rep(i, id+1) {\n\t\t// \tcout << \"Node:\" << i << \"  :\";\n\t\t// \trep(j, G[i].size()) cout << \"(\" << G[i][j].to << \",\" << G[i][j].cost << \") \";\n\t\t// \tcout << endl;\n\t\t// }\n\n\t\tdijkstra(0);\n\n\t\tint ans = INF;\n\t\trep(i, m + 1) {\n\t\t\tans = min(ans, d[id][i]);\n\t\t}\n\n\t\t// rep(i, m + 1) {\n\t\t// \tcout << \"ticket:\" << i << \" \";\n\t\t// \tcout << d[id][i] << endl;\n\t\t// }\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<fstream>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint DP[150][100][10];\nint N, M;\nint K[150];\nint X[150][10], Y[150][10];\nint main()\n{\n\twhile (true){\n\t\t  \n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0)break;\n\t\tfor (int i = 0; i <150; i++){\n\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\tfor (int k = 0; k <=M; k++){\n\t\t\t\t\tDP[i][k][j] = 1000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tcin >> K[i];\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tcin >> X[i][j] >> Y[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < K[0]; j++){\n\t\t\tDP[0][0][j] = 0;\n\t\t}\n\t\tfor (int j = 0; j < K[1]; j++){\n\t\t\tDP[1][1][j] = 0;\n\t\t}\n\t\tfor (int j = 0; j < K[1]; j++){\n\t\t\tfor (int k = 0; k < K[0]; k++){\n\t\t\t\tDP[1][0][j] = min(DP[1][0][j],(Y[1][j] + Y[0][k])*abs(X[1][j] - X[0][k]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i < N; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i - 1]; k++){\n\t\t\t\t\tfor (int l = 0; l <= M; l++){\n\t\t\t\t\t\tDP[i][l][j] = min(DP[i][l][j], DP[i - 1][l][k] + (Y[i][j] + Y[i - 1][k])*abs(X[i][j] - X[i - 1][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < K[i - 2]; k++){\n\t\t\t\t\tfor (int l = 0; l < M; l++){\n\t\t\t\t\t\tDP[i][l+1][j] = min(DP[i][l+1][j], DP[i - 2][l][k] + (Y[i][j] + Y[i - 2][k])*abs(X[i][j] - X[i - 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\t\n\t\t\n\t\tfor (int j = 0; j < K[N - 1]; j++){\n\t\t\tfor (int k = 0; k <= M; k++){\n\t\t\t\tans = min(ans, DP[N - 1][k][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < K[N - 2]; j++){\n\t\t\tfor (int k = 0; k < M; k++){\n\t\t\t\tans = min(ans, DP[N - 2][k][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \n#define f first\n#define s second\n#define MAX_N 155\n#define INF 10000000\n \nusing namespace std;\n \ntypedef pair<int,int> P;\n \nint main(void){\n \n  int n,m,k,a,b;\n \n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n     \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n    \tcin >> a >> b;\n   \t\t v[i].push_back(make_pair(a,b));\n      }\n    }\n \n    int dp[MAX_N][11][80];\n \n    for(int i=0;i<MAX_N;i++)\n      \tfor(int j=0;j<11;j++)\n  \t\t\tfor(int k=0;k<80;k++)\n      \t\t\tdp[i][j][k]=INF;\n \n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n    \tdp[0][i][j]=dp[1][i][j]=0;\n \n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n    \tfor(int l=m;l>=0;l--){\n      \t\tfor(int k=0;k<v[i-1].size();k++)\n        \tdp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n      \t\t\n      \t\tif(l<m){\n        \t\tif(i==2)dp[i][j][l]=0;\n        \t\tfor(int p=0;p<v[i-2].size();p++)\n          \t\t\tdp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n      \t\t}\n    \t}\n      }\n    }\n     \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>0)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n \n    cout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nll dp[152][1001][77],ma[151][1001];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi,mx;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=1000;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tmx=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t\tmx=max(mx,x);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=mx;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=mx;l++){\n\t\t\t\t\t\t\tif(i+1==n+1) dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\telse if(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n+1&&k>0){\n\t\t\t\t\t\t\t\tif(i+2==n+1) dp[i+2][l][k]=min(dp[i+2][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\t\telse if(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=mx;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n+1][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n+1){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n+1){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dijkstra(0) << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nsigned main()\n{\n\twhile (scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%d\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%d %d\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\trep(i, k[0]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(0, 0, i));\n\t\t}\n\n\t\tif (M > 0) {\n\t\t\trep(i, k[1]) {\n\t\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\t\tchmin(ans, rec(1, 1, i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    int N,M,K,k1,k2,MIN,ANS;\n    while(scanf(\"%d%d\",&N,&M),N + M)\n    {\n        int field[150][4] = {0},dp[150][4][100] = {0};\n        ANS = 10000000;\n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\",&K);\n            for(int j = 0; j < K; j++)\n            {\n                scanf(\"%d%d\",&k1,&k2);\n                field[i][k1 - 1] = k2;\n            }\n        }\n        /*for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 1; i < N; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    if(field[i][k] != 0)\n                    {\n                        dp[i][k][j] = 10000000;\n                        if(j == 0)\n                        {\n                            for(int l = 0; l < 4; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[i][k][0] = min(dp[i][k][0],dp[i - 1][l][0] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                        else if(i > 1)\n                        {\n                            for(int l = 0; l < 4; l++)\n                            {\n                                if(field[i - 1][l] != 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 1][l][j] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                                if(field[i - 2][l] != 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 2][l][j - 1] + (field[i - 2][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /*for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    printf(\"%2d\",dp[i][k][j]);\n                }\n                printf(\" / \");\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 0; i < M + 1; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                if(field[N - 1][j] != 0)\n                {\n                    ANS = min(ANS,dp[N - 1][j][i]);\n                }\n            }\n        }\n        printf(\"%d\\n\",ANS);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n#define f first\n#define s second\n#define INF (1<<29)\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\n\nint field[155][4];\nint n, m;\n\nint bfs(){\n  queue<P2> que; // (x, y, m, cost)\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[0][j] != 0) que.push(P2(P(j, 0), P(0, 0)));\n  }\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[1][j] != 0 && m != 0) que.push(P2(P(j, 1), P(1, 0)));\n  }\n  int ans = INF;\n  \n  while(!que.empty()){\n    P2 pos = que.front(); que.pop();\n    if(pos.f.s > n) continue;\n    if(pos.f.s == n-2 && pos.s.f < m){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    if(pos.f.s == n-1){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    for(int i = 1 ; i <= 2 ; i++){\n      for(int j = -3 ; j <= 3 ; j++){\n\tif(i == 2 && pos.s.f == m) continue;\n\tif(pos.f.s+i >= n || pos.f.f+j < 0 || pos.f.f+j > 3) continue;\n\tif(field[pos.f.s + i][pos.f.f + j] != 0){\n\t  if(i == 1){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\t  \t  \n\t  }\n\t  else if(i == 2){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f+1, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\n\t  }\n\t}\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> n >> m){\n    if(n == 0 && m == 0) break;\n    memset(field, 0, sizeof(field));\n    \n    int k, pos, cost;\n    for(int i = 0 ; i < n ; i++){\n      cin >> k;\n      for(int j = 0 ; j < k ; j++){\n\tcin >> pos >> cost;\n\tpos--;\n\tfield[i][pos] = cost;\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150]; //K[i]::=i行目に何個の石があるか\nint X[10][150]; //X[i][j]::=j列目のi個目が何列目か\nint D[10][150]; //D[i][j]::=j列目のi個目のすべりやすさ\nint DP[10][150][80]; //DP[i][j][k]::=j列目のi個目にいて、もうk回ジャンプしてるときの最小コスト\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][0]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) for(int m=0;m<=M;m++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y>1 && m>0) {\n\t\t\t\tfor(int xx=0;xx<K[y-2];xx++) {\n\t\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m-1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<11;i++){\n\t\t\tve[0].push_back(MP(i,0));\n\t\t\tdp[T][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[1].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=min(i/2,M);j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tif(M!=0)for(int i=0;i<M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N-1].size();j++){\n\t\t\t\tres=min(res,dp[T][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P1;\ntypedef pair<P1,ll> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  bool use[1500];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    vector<int> id[150];\n    int num = 0;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tif(i==n-1)use[num] = true;\n\telse use[num] = false;\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = -1;\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    if(m>0)for(int i=0;i<(int)id[1].size();i++)q.push(P2(P1(0,id[1][i]),1));\n\n    ll ans;\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      ll risk = p.first.first, idx = p.first.second, step = p.second;\n      if(use[idx]){\n\tans = risk;\n\tbreak;\n      }\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]<0 || g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]<0 || g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Solution for aoj:0530 Pyon-Pyon River Crossing\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int INF = 1000000000, MAX_N = 150;\ntypedef pair<int, int> P;\nint n, m, ans;\nint dp[MAX_N + 3][1001][76];\nP stone, stone2;\nvector<P> Stone[151]; //first:??????second:???????????????\nint main(){\n\twhile (cin >> n >> m){\n\t\tif (!n&&!m)\n\t\t\treturn 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tStone[i].clear();\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tStone[i].push_back(P(a, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tfor (int j = 1; j <= 1000; j++){\n\t\t\t\tfor (int k = 0; k <= m; k++){\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\t\tstone = Stone[2][i];\n\t\t\tdp[2][stone.first][m] = INF;\n\t\t}\n\t\tfor (int i = 3; i <= n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k <= 75; k++)\n\t\t\t\t\tdp[i][stone.first][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k < Stone[i + 1].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 1][k];\n\t\t\t\t\tfor (int l = m; l >= m - i / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < Stone[i + 2].size(); k++){\n\t\t\t\t\tif (i + 2 > n)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstone2 = Stone[i + 2][k];\n\t\t\t\t\tfor (int l = m - 1; l >= m - (i + 2) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdp[i + 2][stone2.first][l] = min(dp[i + 2][stone2.first][l], (stone.second + stone2.second) * abs(stone.first - stone2.first) + dp[i][stone.first][l + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor (int i = 0; i < Stone[n].size(); i++){\n\t\t\tstone = Stone[n][i];\n\t\t\tfor(int j = 0; j <= m; j++)\n\t\t\tans = min(dp[n][stone.first][j], ans);\n\t\t}\n\t\tfor (int i = 0; i < Stone[n - 1].size(); i++){\n\t\t\tstone = Stone[n - 1][i];\n\t\t\tfor(int j = 0; j <= m; j++)\n\t\t\t  ans = min(dp[n - 1][stone.first][1], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint flag[152][12][78] = {{{0}}};\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n\n      int slip[152][12] = {{0}};\n      memset(flag,0,sizeof(flag));\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n\n      if(n == 1 && m == 1){printf(\"0\\n\"); continue;}\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n            flag[1][i][0] = 1;\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n            flag[2][i][1] = 1;\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s] = 1;\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n               if(p.f.f != 0) flag[p.f.s+2][i][p.s.s+1] = 1;\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n | m)\n\t{\n\t\tint k[200], x[200][16], d[200][16];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", k + i);\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t\tscanf(\"%d%d\", &x[i][j], &d[i][j]);\n\t\t}\n\n\t\tconst int INF = 1 << 29;\n\t\tstatic int dp[200][16][100];\t// row, column, jump left\n\t\tfor (int i = 0; i < 200; ++i)\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tfor (int a = 0; a < 100; ++a)\n\t\t\t\t\tdp[i][j][a] = INF;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tdp[i][j][m - i] = 0;\n\n\t\tfor (int i = 0; i < n - 1; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t{\n\t\t\t\tfor (int a = 0; a <= m; ++a)\n\t\t\t\t{\n\t\t\t\t\tif (dp[i][j][a] == INF)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfor (int b = 0; b < k[i + 1]; ++b)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin_swap(dp[i + 1][b][a]\n\t\t\t\t\t\t, dp[i][j][a] + (d[i][j] + d[i + 1][b]) * abs(x[i][j] - x[i + 1][b]));\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 2 < n && a > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int b = 0; b < k[i + 2]; ++b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin_swap(dp[i + 2][b][a - 1],\n\t\t\t\t\t\t\t\tdp[i][j][a] + (d[i][j] + d[i + 2][b]) * abs(x[i][j] - x[i + 2][b]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = n - 2; i < n; ++i)\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t\tfor (int a = 0; a <= m; ++a)\n\t\t\t\t\tif (i == n - 1 || a > 0)\n\t\t\t\t\t\tmin_swap(res, dp[i][j][a]);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\n#define int ll\nint dp [1500] [150];\nint n, m;\nvector<vector<int>> mp;\nvector<pii> st;\nint func(int pos, int stnum, int spc) {\n\tif (spc == m+1)\n\t\treturn -1;\n\tif (pos == n-1)\n\t\treturn 0;\n\tif (dp[stnum][spc] != -1)\n\t\treturn dp[stnum][spc];\n\tint res = INT_MAX;\n\tint w = st[stnum].first;\n\tint sb = st[stnum].second;\n\tREP(i, mp[pos+1].size()) {\n\t\tint cand = func(pos + 1, mp[pos + 1][i], spc);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0) {\n\t\t\tcand += (sb + st[mp[pos + 1][i]].second)*abs(w-st[mp[pos + 1][i]].first);\n\t\t}\n\t\tres = min(res, cand);\n\t}\n\tREP(i, mp[pos + 2].size()) {\n\t\tint cand = func(pos + 2, mp[pos + 2][i], spc+1);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0) {\n\t\t\tcand += (sb + st[mp[pos + 2][i]].second)*abs(w - st[mp[pos + 2][i]].first);\n\t\t}\n\t\tres = min(res,cand);\n\t}\n\tdp[stnum][spc] = res;\n\treturn res;\n}\n\nsigned main() {\n\twhile (scanf(\"%lld %lld\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tFill(dp, -1);\n\t\tmp.clear();\n\t\tmp.resize(n + 2);\n\t\tint s = 0;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tREP(j, c) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%lld %lld\", &a, &b);\n\t\t\t\tmp[i].push_back(s);\n\t\t\t\tst.push_back({ a,b });\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tst.push_back({ -1,-1 });\n\t\tprintf(\"%lld\\n\", func(-1, s, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 5000000000000;\n\nint n, m;\nint K[152], x[152][10], d[152][10];\nlong long dp[152][10];\n\nvoid init()\n{\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tmemset(K, 0, sizeof(K));\n\tK[0] = K[n + 1] = 1;\n\tmemset(x, 0, sizeof(x));\n\tmemset(d, 0, sizeof(d));\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\t\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (m--){\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n - 1) dp[i + 2][k] = min(dp[i + 2][k], dp[i][j]);\n\t\t\t\t\t\tdp[i + 2][k] = min(dp[i + 2][k], dp[i][j] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long mini = INF;\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tmini = min(mini, dp[n + 1][i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst ull INF = 1 << 31;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M;\nstd::vector<P> S[153];\null dp[153][1000][80];\n\null value(const P& lp, const P& rp){\n    return (lp.second+rp.second) * std::abs(lp.first-rp.first);\n}\n\null rec(int y, int x, int t){\n    if(y > N){return 0;}\n    if(dp[y][x][t] != INF){return dp[y][x][t];}\n\n    ull res = INF;\n    REP(i, S[y+1].size()){\n        res = std::min(res, rec(y+1, i, t) + value(S[y][x], S[y+1][i]));\n    }\n\n    if(t < M){\n        REP(i, S[y+2].size()){\n            res = std::min(res, rec(y+2, i, t+1) + value(S[y][x], S[y+2][i]));\n        }\n    }\n\n    return dp[y][x][t] = res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, N+3){\n            S[i].clear();\n        }\n\n        REP(i, N){\n            int k;\n            std::cin >> k;\n\n            REP(j, k){\n                int x, d;\n                std::cin >> x >> d;\n                x--;\n            \n                S[i+1].push_back(mp(x, d));\n            }\n        }\n\n        REP(i, 1000){\n            S[0].push_back(mp(i, 0));\n            S[N+1].push_back(mp(i, 0));\n            S[N+2].push_back(mp(i, 0));\n        }\n    \n        REP(i, N+3){\n            REP(j, 1000){\n                REP(k, M+1){\n                    dp[i][j][k] = INF;\n                }\n            }\n        }\n\n        ull res = INF;\n        REP(i, 1000){\n            res = std::min(res, rec(0, i, 0));\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n \nusing namespace std;\n \ntypedef pair<int,int> P;\n \nint main(void){\n \n  int n,m,k,a,b;\n \n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n     \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n    \tcin >> a >> b;\n   \t\t v[i].push_back(make_pair(a,b));\n      }\n    }\n \n    int dp[MAX_N][11][80];\n \n    for(int i=0;i<MAX_N;i++)\n      \tfor(int j=0;j<11;j++)\n  \t\t\tfor(int k=0;k<80;k++)\n      \t\t\tdp[i][j][k]=INF;\n \n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n    \tdp[0][i][j]=dp[1][i][j]=0;\n \n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n    \tfor(int l=m;l>=0;l--){\n      \t\tfor(int k=0;k<v[i-1].size();k++)\n        \tdp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n      \t\t\n      \t\tif(l<m){\n        \t\tif(i==2)dp[i][j][l]=0;\n        \t\tfor(int p=0;p<v[i-2].size();p++)\n          \t\t\tdp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n      \t\t}\n    \t}\n      }\n    }\n     \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>0)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n \n    cout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (int)(1e9)\n\nint mb[10];\nint ms[10];\nint m[10][77];\nint mk;\nint mmb[10];\nint mms[10];\nint mm[10][77];\nint mmk;\nint n[10][77];\n\nvector<pair<int,int> > isi[150];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint nn,mn;\n\t\tscanf(\"%d %d\",&nn,&mn);\n\t\tif(nn == 0 && mn == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(int ii = 0; ii < k; ii++)\n\t\t\t{\n\t\t\t\tint x,d;\n\t\t\t\tscanf(\"%d %d\",&x,&d);\n\t\t\t\tisi[i].push_back(make_pair(x,d));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < isi[0].size(); i++)\n\t\t{\n\t\t\tmb[i] = isi[0][i].first;\n\t\t\tms[i] = 0;\n\t\t\tmmb[i] = isi[0][i].first;\n\t\t\tmms[i] = 0;\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tm[i][ii] = 0;\n\t\t\t\tmm[i][ii] = 0;\n\t\t\t}\n\t\t}\n\t\tmk = isi[0].size();\n\t\tmmk = isi[0].size();\n\t\tfor(int i = 0; i < nn; i++)\n\t\t{\n\t\t\tif(i == 1)\n\t\t\t{\n\t\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t\t{\n\t\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmm[ii][iii] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tmmb[ii] = isi[i][ii].first;\n\t\t\t\t\tmms[ii] = isi[i][ii].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = m[j][iii] + (ms[j] + isi[i][ii].second) * abs(mb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn[ii][iii] = min;\n\t\t\t\t}\n\t\t\t\tfor(int iii = 0; iii < mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int j = 0; j < mk; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(min > mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin = mm[j][iii] + (mms[j] + isi[i][ii].second) * abs(mmb[j] - isi[i][ii].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n[ii][iii + 1] > min)\n\t\t\t\t\t{\n\t\t\t\t\t\tn[ii][iii + 1] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int ii = 0; ii < mk; ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tmm[ii][iii] = m[ii][iii];\n\t\t\t\t}\n\t\t\t\tmmb[ii] = mb[ii];\n\t\t\t\tmms[ii] = ms[ii];\n\t\t\t}\n\t\t\tmmk = mk;\n\t\t\tfor(int ii = 0; ii < isi[i].size(); ii++)\n\t\t\t{\n\t\t\t\tfor(int iii = 0; iii <= mn; iii++)\n\t\t\t\t{\n\t\t\t\t\tm[ii][iii] = n[ii][iii];\n\t\t\t\t}\n\t\t\t\tmb[ii] = isi[i][ii].first;\n\t\t\t\tms[ii] = isi[i][ii].second;\n\t\t\t}\n\t\t\tmk = isi[i].size();\n\t\t}\n\t\tint allmin = INF;\n\t\tfor(int i = 0; i < mmk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > mm[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = mm[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < mk; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii <= mn; ii++)\n\t\t\t{\n\t\t\t\tif(allmin > m[i][ii])\n\t\t\t\t{\n\t\t\t\t\tallmin = m[i][ii];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",allmin);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nll dp[200][200][15];\nint solve_testcase() {\n    int N, M; scanf(\"%d%d\", &N, &M);\n    if(N == 0 and M == 0) return 1;\n\n    vector< vector< pair<ll, ll> > > info(N+2);\n    for(int i=0; i<N; i++) {\n        int K; scanf(\"%d\", &K);\n        for(int j=0; j<K; j++) {\n            int x, d; scanf(\"%d%d\", &x, &d);\n            info[i].emplace_back(x, d);\n        }\n    }\n\n    fill(dp[0][0], dp[N+2][0], LONGINF);\n    dp[0][0][0] = 0;\n    for(int i=0; i<=N; i++) {\n        for(int j=0; j<=M; j++) {\n            for(int k=0; k<10; k++) {\n                if(dp[i][j][k] == LONGINF) continue;\n                if(i + 1 <= N + 1) {\n                    if(i == 0 or i + 1 == N + 1) {\n                        chmin(dp[i+1][j][0], dp[i][j][k]);\n                        for(int l=0; l<(int)info[i].size(); l++) {\n                            chmin(dp[i+1][j][l], dp[i][j][k]);\n                        }\n                    }\n                    else if(k < info[i-1].size() and info[i].size()) {\n                        for(int l=0; l<(int)info[i].size(); l++) {\n                            int d = info[i-1][k].second + info[i][l].second;\n                            int x = abs(info[i-1][k].first - info[i][l].first);\n                            chmin(dp[i+1][j][l], dp[i][j][k] + d*x);\n                        }\n                    }\n                }\n                if(i + 2 <= N + 1 and j + 1 <= M) {\n                    if(i == 0 or i + 2 == N + 1) {\n                        chmin(dp[i+2][j+1][0], dp[i][j][k]);\n                        for(int l=0; l<(int)info[i+1].size(); l++) {\n                            chmin(dp[i+2][j+1][l], dp[i][j][k]);\n                        }\n                    }\n                    else if(k < info[i-1].size() and info[i+1].size()) {\n                        for(int l=0; l<(int)info[i+1].size(); l++) {\n                            int d = info[i-1][k].second + info[i+1][l].second;\n                            int x = abs(info[i-1][k].first - info[i+1][l].first);\n                            chmin(dp[i+2][j+1][l], dp[i][j][k] + d*x);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    ll ans = LONGINF;\n    for(int i=0; i<=M; i++) for(int j=0; j<10; j++) chmin(ans, dp[N+1][i][j]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30 ;\nstruct edge{\n  int pos, strong ;\n  int dp[77];\n\n  edge(int pos, int strong): pos(pos), strong(strong){\n    fill_n( dp, 77, INF);\n  };\n  edge(){};\n};\n\nint main(){\n  int n; //行数 \n  int m; //ジャンプの数\n\n  edge node[152][10];\n  int size[152] = {};\n\n  while(scanf(\"%d %d\", &n, &m), n){\n    for(int i = 0; i < n; i++){\n      int k;\n      scanf(\"%d\", size + i);\n      for(int j = 0; j < size[i]; j++){\n        int x, d;\n        scanf(\"%d %d\", &x, &d);\n        node[i][j] = edge( x, d);\n      }\n    }\n\n    for(int i = 0; i < size[0]; i++){ //最初は普通にジャンプ\n      node[0][i].dp[0] = 0;\n    }\n    for(int i = 0; i < size[1]; i++){ //最初はジャンプする\n      node[1][i].dp[1] = 0 ;\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < size[i]; j++){\n        for(int k = 0; k <= m; k++){\n          if(node[i][j].dp[k] != INF){\n            if(k != m){\n              for(int l = 0; l < size[i + 2]; l++){\n                node[i + 2][l].dp[k + 1] = min( node[i + 2][l].dp[k + 1], node[i][j].dp[k] + (node[i + 2][l].strong + node[i][j].strong) * abs(node[i + 2][l].pos - node[i][j].pos));\n              }\n            }\n            for(int l = 0; l < size[i + 1]; l++){\n              node[i + 1][l].dp[k] = min( node[i + 1][l].dp[k], node[i][j].dp[k] + (node[i + 1][l].strong + node[i][j].strong) * abs(node[i + 1][l].pos - node[i][j].pos));\n            }\n          }\n        }\n      }\n    }\n    int ret = INF ;\n    for(int i = 0; i < size[n - 1]; i++){\n      for(int j = m; j >= 0; j--){\n        if(node[n - 1][i].dp[j] != INF){\n          ret = min( ret, node[n - 1][i].dp[j]);\n          break;\n        }\n      }\n    }\n    for(int i = 0; i < size[n - 2]; i++){\n      for(int j = 0; j < m; j++){\n        if(node[n - 2][i].dp[j] != INF){\n          ret = min( ret, node[n - 2][i].dp[j]);\n          break;\n        }\n      }\n    }\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=1;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\t\t       \n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  \n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n\nusing namespace std;\nconst int INF =1001001001;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n\nint main(){\n\twhile(1){\n\tint N,M;\n\tint stonenum[152];\n\tint C[152][12];\n\tint G[152][12];\n\t//[i][j]=i+1行目にある石j個目の C=列(位置)、G=滑りやすさ>\n\tint dp[152][12][77];\n\t//[i][j][k]=i行(0,N行は陸)j+1番目にある石にいて、今までにk(<M<=(150+1)/2)回\n\t//飛ばした時の、対岸までの最短距離\n\tscanf(\"%d %d\",&N,&M);\n\tif(N==0&&M==0)break;\n\t\trep(i,N){\n\t\tint a=0;\n\t\tscanf(\"%d\",&a);\n\t\tstonenum[i]=a;\n\t\trep(j,a){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tscanf(\"%d\",&c);\n\t\t\tC[i][j]=b;G[i][j]=c;\n\t\t}\n\t}\n\t//printf(\"\\nyomikomiOK\");\n\tfor(int i=N;i>-1;i--){//i=N…0\n\t\trep(j,stonenum[i]){\n\t\t\trep(k,M+1){\n\t\t\t\tif(i==N-1){dp[i][j][k]=0;}\n\t\t\t\telse if(i==N-2&&k<M){//0距離\n\t\t\t\t\tdp[i][j][k]=0;\n\t\t\t\t}else{\n\t\t\t\t\tint ans=INF;\n\t\t\t\t\trep(m,stonenum[i+1]){\n\t\t\t\t\t\t//if(ans==INF)ans=((G[i][k]+G[i+1][m])*abs(C[i][k]-C[i+1][m])+dp[i+1][m][k]);\n\t\t\t\t\t\tans=min(ans,((G[i][j]+G[i+1][m])*abs(C[i][j]-C[i+1][m])+dp[i+1][m][k]));\n\t\t\t\t\t}\n\t\t\t\t\tif(k<M){\n\t\t\t\t\t\trep(m,stonenum[i+2]){\n\t\t\t\t\t\t\tans=min(ans,(G[i][j]+G[i+2][m])*abs(C[i][j]-C[i+2][m])+dp[i+2][m][k+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\trep(i,stonenum[0])ans=min(ans,dp[0][i][0]);\n\tif(M>0)rep(i,stonenum[1])ans=min(ans,dp[1][i][1]);\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 50000000000;\n\nint n, m;\nint K[152], x[152][10], d[152][10];\nlong long dp[152][10];\n\nvoid init()\n{\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tmemset(K, 0, sizeof(K));\n\tK[0] = 1;\n\tK[n + 1] = 1;\n\tmemset(x, 0, sizeof(x));\n\tmemset(d, 0, sizeof(d));\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\t\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (m--){\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n - 1) dp[i + 2][k] = min(dp[i + 2][k], dp[i][j]);\n\t\t\t\t\t\telse dp[i + 2][k] = min(dp[i + 2][k], dp[i][j] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i <= n; i++){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", dp[n + 1][0]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i__=0;__i__<n;__i__++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\nusing namespace std;\n\nlong COST_LIMIT = 1000 * 1000 * 150;\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n, m; cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    // alloc cost table\n    long **cost_table[3];\n    loop(3, i) {\n      cost_table[i] = new long*[10];\n      loop(10, j) {\n        cost_table[i][j] = new long[m + 1];\n      }\n    }\n    int slip[3][10], slip_i[3][10];\n\n    // operation per row\n    loop(n, row_i) {\n      int prev = (row_i + 1) % 3, crr = (row_i + 2) % 3, next = row_i % 3;\n\n      // init arrays\n      loop(10, i) {\n        loop(m + 1, j) cost_table[next][i][j] = -1;\n        slip[next][i] = -1;\n        slip_i[next][i] = -1;\n      }\n\n      // input\n      {\n        int count; cin >> count;\n        loop(count, i) {\n          int index, slipness; cin >> index >> slipness;\n          slip[next][i] = slipness;\n          slip_i[next][i] = index;\n        }\n      }\n\n      // initial values\n      if (row_i == 0) { \n        loop(10, i) {\n          if (slip_i[next][i] != -1) cost_table[next][i][m] = 0;\n        }\n      }\n\n      // // !debug\n      // if (row_i > 0) \n      // {\n      //   cout << \"row: \" << row_i - 1 << endl;\n      //   loop(10, i) {\n      //     if (slip_i[crr][i] == -1) break;\n      //     loop(m + 1, j) {\n      //       cout << i << \": \" << cost_table[crr][i][j] << \" \";\n      //     }\n      //     cout << endl;\n      //   }\n      // }\n\n      // normal jump\n      if (row_i < 1) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop(m + 1, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, c_col_i) {\n            if (slip_i[crr][c_col_i] == -1) break;\n            if (cost_table[crr][c_col_i][m_i] == -1) continue;\n            int jump_cost = (slip_i[crr][c_col_i] - slip_i[next][n_col_i]) * \n              (slip[crr][c_col_i] + slip[next][n_col_i]);\n            if (jump_cost < 0) jump_cost = -jump_cost;\n\n            // if (row_i == 5 && n_col_i == 0 && c_col_i == 2) {\n            //   cout << \"crr_cost: \" << cost_table[crr][c_col_i][m_i] <<\n            //     \", crr_index: \" << slip_i[crr][c_col_i] <<\n            //     \", crr_slip: \" << slip[crr][c_col_i] <<\n            //     \", to_cost: \" << cost_table[next][n_col_i][m_i] <<\n            //     \", to_index: \" << slip_i[next][n_col_i] <<\n            //     \", to_slip: \" << slip[next][n_col_i] << endl;\n            //   cout << \"cost: \" << cost << endl;\n            // }\n\n            int cost = cost_table[crr][c_col_i][m_i] + jump_cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = c_col_i;\n            }\n          }\n          if (min_cost == -1) {\n            cost_table[next][n_col_i][m_i] = min_cost;\n          } else {\n            // // !debug\n            // if (row_i == 5 && m_i == 0) {\n            //   cout << \"from: \" << min_col << \", to: \" <<\n            //     n_col_i << endl;\n            //   cout << \"col: \" << n_col_i << \", crr_cost: \" << \n            //     cost_table[crr][min_col][m_i] << \", jump_cost: \" <<\n            //     min_cost << \", min_col: \" << min_col << endl;\n            // }\n            cost_table[next][n_col_i][m_i] = min_cost;\n            // if (row_i == 2 && m_i == 0) \n            //   cout << cost_table[next][n_col_i][m_i] << endl; \n          }\n        }\n      }\n\n      // big jump from bank\n      if (row_i == 1 && m > 0) {\n        loop(10, n_col_i) {\n          if (slip_i[next][n_col_i] == -1) break;\n          cost_table[next][n_col_i][m - 1] = 0;\n        }\n      }\n\n      // big jump\n      if (row_i < 2) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop_from_to(1, m, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, p_col_i) {\n            if (slip_i[prev][p_col_i] == -1) break;\n            if (cost_table[prev][p_col_i][m_i] == -1) continue;\n            int jump_cost = (slip_i[prev][p_col_i] - slip_i[next][n_col_i]) * \n              (slip[prev][p_col_i] + slip[next][n_col_i]);\n            if (jump_cost < 0) jump_cost = -jump_cost;\n            int cost = cost_table[prev][p_col_i][m_i] + jump_cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = p_col_i;\n            }\n          }\n          if (min_cost != -1) {\n            int prev_cost = cost_table[prev][min_col][m_i];\n            // cout << \"col\" << n_col_i << \"prev cost:\" << prev_cost << endl;\n            // cout << \"col: \" << n_col_i << \", m: \" << m_i << endl;\n            if (cost_table[next][n_col_i][m_i - 1] == -1 ||\n                cost_table[next][n_col_i][m_i - 1] > prev_cost) {\n              cost_table[next][n_col_i][m_i - 1] = min_cost;\n            }\n          }\n          // int prev_cost = cost_table[prev][min_col][m_i];\n          // if (prev_cost != -1) min_cost += prev_cost;\n          // assign_if_smaller(cost_table[next][n_col_i][m_i - 1], min_cost);\n        }\n      }\n\n    }\n\n    // // !debug\n    // cout << \"row: \" << n - 1 << endl;\n    // loop(10, i) {\n    //   if (slip_i[(n - 1) % 3][i] == -1) break;\n    //   loop(m + 1, j) {\n    //     cout << i << \": \" << cost_table[(n - 1) % 3][i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n\n    long min_cost = COST_LIMIT;\n    loop(10, i) {\n      loop(m + 1, j) {\n        int cost = cost_table[(n - 1) % 3][i][j];\n        if (cost == -1) continue;\n        assign_if_smaller(min_cost, cost);\n      }\n    }\n\n    if (n > 1)\n    {\n      loop(10, i) {\n        loop_from_to(1, m, j) {\n          int cost = cost_table[(n - 2) % 3][i][j];\n          if (cost == -1) continue;\n          assign_if_smaller(min_cost, cost);\n        }\n      }\n    }\n\n    cout << min_cost << endl;\n\n    // free cost table\n    loop(3, i) {\n      loop(10, j) delete cost_table[i][j];\n      delete cost_table[i];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint n,m;\nint a,b;\nint fie[200][4];\t// 行、マス\nint dp[200][200][4];// x回目１こ飛ばし、行、マス\n\nvoid calc(int u)\n{\n\tu *= 2;\n\tfor(int i = u; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\t\t// 現在の立ち位置\n\t\t\tfor(int k = 0; k < 4; k++){\t// 次の場所\n\t\t\t\tfor(int add = 0; add <= 1; add++){\n\t\t\t\t\tif(add+(u/2) > m)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(fie[i][j] >= 0 && fie[i+1+add][k] >= 0){\n\t\t\t\t\t\tint nowRisk = (fie[i][j] + fie[i+1+add][k])*abs(j-k)+dp[u/2][i][j];\n\t\t\t\t\t\tif(dp[u/2][i][j] == -1)\n\t\t\t\t\t\t\tnowRisk += 1;\n\n//\t\t\t\t\t\tcout << nowRisk << endl ;\n\t\t\t\t\t\tif(dp[u/2+add][i+1+add][k] >= 0)\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = min(dp[u/2+add][i+1+add][k], nowRisk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = nowRisk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid solve()\n{\n\tint ans = (1 << 25);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tcin >> fie[i][b];\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i <= m; i++){\n\t\tcalc(i);\n\t\t\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif(dp[i][n+1][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+1][j]);\n\t\t\tif(dp[i][n+2][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+2][j]);\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcout << dp[0][i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tcout << ans << endl;\n\n\n\t\n}\n\nint main(void)\n{\n\n\twhile(cin >> n >> m, n | m){\n\t\tfill(fie[1], fie[1]+(200-1)*4, -1);\n\t\tfill(dp[0][0], dp[0][0] + 200*200*4, -1);\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfie[n+1][i] = 0;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 10000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n\tdp[0][i][m]=dp[1][i][m]=dp[2][i][m-1]=0;\n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Solution for aoj:0530 Pyon-Pyon River Crossing\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int INF = 100000000, MAX_N = 150;\ntypedef pair<int, int> P;\nint n, m, ans;\nint dp[MAX_N + 20][1010][80];\nP stone, stone2;\nvector<P> Stone[151]; //first:??????second:???????????????\nint main(){\n\twhile (cin >> n >> m){\n\t\tif (!n&&!m)\n\t\t\treturn 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tStone[i].clear();\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tStone[i].push_back(P(a, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tfor (int j = 1; j <= 1000; j++){\n\t\t\t\tfor (int k = 0; k <= m; k++){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\t\tstone = Stone[2][i];\n\t\t\tdp[2][stone.first][m] = INF;\n\t\t}\n\t\tfor (int i = 3; i <= n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t\tdp[i][stone.first][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k < Stone[i + 1].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 1][k];\n\t\t\t\t\tfor (int l = m; l >= m - (i + 1) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (l != m)\n\t\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], dp[i + 1][stone2.first][l + 1]);\n\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < Stone[i + 2].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 2][k];\n\t\t\t\t\tfor (int l = m - 1; l >= m - (i + 2) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (l != m)\n\t\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 2][stone2.first][l], dp[i + 2][stone2.first][l + 1]);\n\t\t\t\t\t\tdp[i + 2][stone2.first][l] = min(dp[i + 2][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor (int i = 0; i < Stone[n].size(); i++){\n\t\t\tstone = Stone[n][i];\n\t\t\tans = min(dp[n][stone.first][0], ans);\n\t\t}\n\t\tfor (int i = 0; i < Stone[n - 1].size(); i++){\n\t\t\tif (m == 0)\n\t\t\t\tbreak;\n\t\t\tstone = Stone[n - 1][i];\n\t\t\tif (dp[n - 1][stone.first][1])\n\t\t\t\tans = min(dp[n - 1][stone.first][1], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#define INF (1000000000)\n#define MOD (1000000007)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\ntypedef vector<long>::iterator VL;\ntypedef vector<long>::iterator VLI;\ntypedef pair<int, int> P;\n\n\nint d[150][1000];\nint dp[150][1000][100];\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tmemset(d, 0, sizeof(d));\n\t\tint maxx = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; j++){\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tx--;\n\t\t\t\tscanf(\"%d\", &d[i][x]);\n\t\t\t\t\n\t\t\t\tmaxx = max(maxx, x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j <= maxx; j++){\n\t\t\t\tfor (int k = 0; k < 100; k++){\n\t\t\t\t\tif (i == 0 && d[i][j] && k == 0) dp[i][j][k] = 0;\n\t\t\t\t\telse dp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j <= maxx; j++){\n\t\t\t\tfor (int k = 0; k <= maxx; k++){\n\t\t\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\t\t\tif (d[i][j] && d[i + 1][k]){\n\t\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (d[i][j] + d[i + 1][k]) * abs(j - k));\n\t\t\t\t\t\t\t//printf(\"%d\\n\", dp[i + 1][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i < n - 1 && d[i][j] && d[i + 2][k]){\n\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (d[i][j] + d[i + 2][k]) * abs(j - k));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini = INF;\n\t\tfor (int i = 0; i <= maxx; i++){\n\t\t\tfor (int j = 0; j <= m; j++){\n\t\t\t\tmini = min(mini, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[151]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n + 1) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, 10) dp[0][i][m] = 0;\n\t\tREP(i, n) REP(j, stone[i].size()) {\n\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 1) {\n\t\t\t\tFOR(k, 1, m + 1) {\n\t\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\t\tint cost = (stone[i][j].second + stone[i + 2][l].second) * abs(stone[i][j].first - stone[i + 2][l].first);\n\t\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, m + 1) {\n\t\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\t\tint cost = (stone[i][j].second + stone[i + 1][l].second) * abs(stone[i][j].first - stone[i + 1][l].first);\n\t\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\t/*\n\t\tREP(i, n + 1) {\n\t\t\tREP(j, stone[i].size()) {\n\t\t\t\tint pri = INF;\n\t\t\t\tREP(k, m + 1) pri = min(pri, dp[i][j][k]);\n\t\t\t\tprintf(\"%d%c\", pri, j == stone[i].size() - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77];\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int i = 0; i < 1001; i++)\n\t\t\t\tfill(cur[i],cur[i]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\tif(field[i-1][k]==0&&(i<=1||field[i-2][k]==0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=cur;\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,fin[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 1005\n#define N 155\n#define S 85\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[S][N][M];\n\nint dijkstra(int sy,int sx,int x){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<S;i++)\n    for(int j=0;j<N;j++)\n      for(int l=0;l<M;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  if(x<=m)q.push(P1(P(0,x),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  for(int i=0;i<node[n-2].size();i++)\n    for(int j=0;j<m;j++)\n      res=min(res,d[j][n-2][node[n-2][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x,0));\n    for(int i=0;i<node[1].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x,1));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m;\nvector<P> t[200];\nint dp[200][12][200];\n\nvoid solve(){\n  for(int i = 0; i < 200; i++){\n    for(int j = 0; j < 12; j++){\n      for(int k = 0; k < 200; k++){\n\tdp[i][j][k] = INT_MAX;\n      }\n      if(i == 0) dp[i][j][0] = 0;\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < t[i].size(); j++){\n      for(int k = 0; k <= m; k++){\n\tif(dp[i][j][k] == INT_MAX) continue;\n\n\tfor(int nj = 0; nj < t[i + 1].size(); nj++){\n\t  int add = (i == 0 ? 0 : (t[i][j].second + t[i + 1][nj].second) * abs(t[i][j].first - t[i + 1][nj].first));\n\t  dp[i + 1][nj][k] = min(dp[i + 1][nj][k], dp[i][j][k] + add);\n\t}\n\n\tif(k == m) continue;\n\n        for(int nj = 0; nj < t[i + 2].size(); nj++){\n          int add = (i == 0 ? 0 : (t[i][j].second + t[i + 2][nj].second) * abs(t[i][j].first - t[i + 2][nj].first));\n          dp[i + 2][nj][k + 1] = min(dp[i + 2][nj][k + 1], dp[i][j][k] + add);\n        }\n      }\n    }\n  }\n\n  int ans = INT_MAX;\n\n  for(int i = 0; i < t[n].size(); i++){\n    for(int j = 0; j <= m; j++){\n      ans = min(ans, dp[n][i][j]);\n    }\n  }\n\n  if(n == 1){\n    if(m >= 1) ans = 0;\n    cout << ans << endl;\n    return;\n  }\n\n  for(int i = 0; i < t[n - 1].size(); i++){\n    for(int j = 0; j <= m - 1; j++){\n      ans = min(ans, dp[n - 1][i][j]);\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n >> m , n || m){\n    for(int i = 0; i < 200; i++){\n      t[i].clear();\n    }\n    t[0].push_back(P(0, 0));\n\n    for(int i = 1; i <= n; i++){\n      int k;\n      cin >> k;\n\n      while(k--){\n\tint x, d;\n\tcin >> x >> d;\n\tx--;\n\tt[i].push_back(P(x, d));\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint mincost;\n\n\nvoid NoJump(VVP &G,VVI &dp)\n{\n  int n= dp.size();\n  rep(i,dp[0].size())dp[0][i] = 0;\n  rep(i,n-1)\n    {\n      int m = dp[i].size();\n      int o = dp[i+1].size();\n      rep(j,m)\n\t{\n\t  rep(k,o)\n\t    {\n\t      int cost = (G[i+1][k].S+G[i][j].S)*abs(G[i+1][k].F-G[i][j].F);\n\t      dp[i+1][k] = min(dp[i+1][k],cost+dp[i][j]);\n\t    }\t\n\t}\n    }\n}\n\nvoid printVVI(VVI &G)\n{\n  cout << \"printVVI ------------ \"<< endl;\n  rep(i,G.size())\n    {\n      rep(j,G[i].size())\n\t{\n\t  cout << G[i][j] << \" \";\n\t} \n      cout << endl;\n    }\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      mincost = (1<<29);\n      VVP G(n);\n      rep(i,n)\n\t{\n\t  int k;\n\t  cin >> k;\n\t  rep(j,k)\n\t    {\n\t      int x,d;\n\t      cin >> x >> d;\n\t      G[i].push_back(P(x,d));\n\t    }\n\t}\n    \n      VVI dp(n);\n      rep(i,n)dp[i].resize(G[i].size(),(1<<29));\n      NoJump(G,dp);\n      //printVVI(dp);      \n\n      //First jump\n      VVI prev = dp;\n      if(m != 0){\n\t\n\trep(i,G[1].size())prev[1][i] = 0;    \n\trep(i,n)\t\n\t  {\n\t  if(i+2 >= n)break;\n\t  rep(j,G[i].size())\n\t    {\n\t      rep(k,G[i+2].size())\n\t\t{\n\t\t  int cost = (G[i][j].S+G[i+2][k].S)*abs(G[i][j].F-G[i+2][k].F);\n\t\t  prev[i+2][k] = min(prev[i+2][k],cost+dp[i][j]); \n\t\t}\n\t    }\n\t  }\n\tdp = prev;\n\t//printVVI(dp);\n      }\n      \n      if(m == 1 || m == 0)goto Next;\n\n      for(int i=1,cnt=1;cnt<m;cnt++,i+=2)\n\t{\n\t  prev = dp;\n\t  REP(j,i,n)\n\t    {\n\t      if(j+2 >= n)break;\n\t      rep(k,G[j].size())\n\t\t{\n\t\t  rep(l,G[j+2].size())\n\t\t    {\t  \n\t\t      int cost = (G[j][k].S+G[j+2][l].S)*abs(G[j][k].F-G[j+2][l].F);\n\t\t      prev[j+2][l] = min(prev[j+2][l],cost+dp[j][k]);\n\t\t    }\n\t\t}\n\t    }\n\t  dp = prev;\n\t}      \n      //printVVI(dp);\n     \n    Next:;\n    \n      NoJump(G,dp);\n\n      //printVVI(dp);\n\n      if(!G[n-1].empty())\n\trep(i,G[n-1].size())mincost = min(mincost,dp[n-1][i]);\n      else\n\trep(i,G[n-2].size())mincost = min(mincost,dp[n-2][i]);\n      \n      cout << mincost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      if(n == 1 && m == 1){printf(\"0\\n\"); continue;}\n\n      int slip[151][11] = {{0}};\n      int flag[151][11][77] = {{{0}}};\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n            flag[1][i][0] = 1;\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n            flag[2][i][1] = 1;\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s] = 1;\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s+1));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s+1] = 1;\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        vector<vector<vector<int> > > dp(3, vector<vector<int> >(10, vector<int>(M+1, 2000*1000*150)));\n        for(int i = 0; i < stones[0].size(); ++i) {\n            dp[0][i][M] = 0;\n        }\n        if(M > 0) {\n            for(int i = 0; i < stones[1].size(); ++i) {\n                dp[1][i][M-1] = 0;\n            }\n        }\n        for(int i = 1; i < N; ++i) {\n            int curr = i%3;\n            int prev = (i-1)%3;\n            int pp = (i-2)%3;\n\n            for(int k = 0; k < stones[i].size(); ++k) {\n                fill(dp[curr][k].begin(), dp[curr][k].end(), 2000*1000*150);\n            }\n            if(i > 1) {\n                for(int j = 0; j < stones[i-2].size(); ++j) {\n                    //pp to prev\n                    int sx = stones[i-2][j].first;\n                    int sc = stones[i-2][j].second;\n                    for(int k = 0; k < stones[i-1].size(); ++k) {\n                        int skx = stones[i-1][k].first;\n                        int skc = stones[i-1][k].second;\n                        int cost = (sc+skc) * abs(sx-skx);\n                        for(int m = 0; m <= M; ++m) {\n                            dp[prev][k][m] = min(dp[prev][k][m], dp[pp][j][m]+cost);\n                        }\n                    }\n\n                    //pp to curr\n                    for(int k = 0; k < stones[i].size(); ++k) {\n                        int skx = stones[i][k].first;\n                        int skc = stones[i][k].second;\n                        int cost = (sc+skc) * abs(sx-skx);\n                        for(int m = 0; m < M; ++m) {\n                            dp[curr][k][m] = min(dp[curr][k][m], dp[pp][j][m+1]+cost);\n                        }\n                    }\n                }\n            }\n            for(int j = 0; j < stones[i-1].size(); ++j) {\n                //prev to curr\n                int sx = stones[i-1][j].first;\n                int sc = stones[i-1][j].second;\n                for(int k = 0; k < stones[i].size(); ++k) {\n                    int skx = stones[i][k].first;\n                    int skc = stones[i][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m <= M; ++m) {\n                        dp[curr][k][m] = min(dp[curr][k][m], dp[prev][k][m]+cost);\n                    }\n                }\n            }\n        }\n        int ans = INT_MAX;\n        int curr = (N-1) % 3;\n        int prev = (N-2) % 3;\n\n        for(int m = 0; m <= M; ++m) {\n            for(int k = 0; k < stones[N-1].size(); ++k) {\n                ans = min(ans, dp[curr][k][m]);\n            }\n            if(m > 0) {\n                for(int k = 0; k < stones[N-2].size(); ++k) {\n                    ans = min(ans, dp[prev][k][m]);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77];\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(cur[j],cur[j]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\tif(field[i-1][k]==0&&(i<=1||field[i-2][k]==0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,cur[i][j]);\n\t\t\t}\n\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\tminRes=min(minRes,prv[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<20;\n\nint dp[256][16][128];\nvector<P> stones[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      stones[i].clear();\n      int k;\n      cin >> k;\n      REP(j, k) {\n\tint x, d;\n\tcin >> x >> d;\n\tstones[i].push_back(P(x, d));\n      }\n    }\n\n    REP(i, N) REP(j, stones[i].size()) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, stones[0].size()) dp[0][j][0] = 0;\n    REP(i, N-1) {\n      REP(j, stones[i+1].size()) {\n\tint x_now = stones[i+1][j].first, d_now = stones[i+1][j].second;\n\tREP(k, stones[i].size()) {\n\t  int x_prev = stones[i][k].first, d_prev = stones[i][k].second;\n\t  int safe = (d_now + d_prev) * abs(x_now - x_prev);\n\t  REP(m, M+1) {\n\t    dp[i+1][j][m] = min(dp[i+1][j][m], dp[i][k][m] + safe);\n\t  }\n\t}\n\tif (i > 0) {\n\t  REP(k, stones[i-1].size()) {\n\t    int x_prev = stones[i-1][k].first, d_prev = stones[i-1][k].second;\n\t    int safe = (d_now + d_prev) * abs(x_now - x_prev);\n\t    REP(m, M) {\n\t      dp[i+1][j][m+1] = min(dp[i+1][j][m+1], dp[i-1][k][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, stones[N-1].size()) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<climits>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<P> >v(155);\t\nvector<vector<vector<int> > >dp(155);\nint F(int n1,int k1,int n2,int k2)\n{\n\tP p=v[n1][k1],q=v[n2][k2];\n\treturn (p.first+q.first)*abs(p.second-q.second);\n}\nint main()\n{\n\tint n,m,k,x,d,i,j,l;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=0;i<n;++i)\n\t{\n\t\tscanf(\"%d\",&k);\n\t\tdp[i].resize(k);\n\t\tfor(j=0;j<k;++j)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&d);\n\t\t\tv[i].push_back(P(d,x));\n\t\t\tdp[i][j].resize(m+1);\n\t\t\tfill(dp[i][j].begin(),dp[i][j].end(),INT_MAX/4);\n\t\t}\n\t}\n\tfor(i=0;i<v[0].size();++i)\n\t\tdp[0][i][m]=0;\n\tif(m)\n\t\tfor(i=0;i<v[1].size();++i)\n\t\t\tdp[1][i][m-1]=0;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tfor(j=0;j<dp[i].size();++j)\n\t\t{\n\t\t\tfor(l=0;l<dp[i+1].size();++l)\n\t\t\t{\n\t\t\t\tfor(k=0;k<=m;++k)\n\t\t\t\t{\n\t\t\t\t\tint&r=dp[i+1][l][k];\n\t\t\t\t\tr=min(r,dp[i][j][k]+F(i,j,i+1,l));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(l=0;l<dp[i+2].size();++l)\n\t\t\t{\n\t\t\t\tfor(k=1;k<=m;++k)\n\t\t\t\t{\n\t\t\t\t\tint&r=dp[i+2][l][k-1];\n\t\t\t\t\tr=min(r,dp[i][j][k]+F(i,j,i+2,l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=INT_MAX;\n\tfor(j=0;j<dp[n-1].size();++j)\n\t\tfor(k=0;k<=m;++k)\n\t\t\tres=min(res,dp[n-1][j][k]);\n\tfor(j=0;j<dp[n-2].size();++j)\n\t\tfor(k=1;k<=m;++k)\n\t\t\tres=min(res,dp[n-2][j][k]);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second ==0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<MAX_V; i++)\n    ans=min(d[n-1][i],ans);\n \n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n-1; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2>=n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(0);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(1));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define INF INT_MAX\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>c[150][75];\n\t\tint d;\n\t\tcin >> d;\n\t\tfor (int e = 0; e < d; e++) {\n\t\t\tisi h; h.mincost = 0;\n\t\t\tscanf(\"%lld%lld\", &h.zahyou, &h.suberi);\n\t\t\tc[0][b].push_back(h);\n\t\t}\n\t\tfor (int f = 1; f < a; f++) {\n\t\t\tint g; cin >> g;\n\t\t\tfor (int h = 0; h < g; h++) {\n\t\t\t\tint i, j; scanf(\"%lld%lld\", &i, &j);\n\t\t\t\tfor (int k = b; k >= 0; k--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int l = 0; l < c[f - 1][k].size(); l++) {\n\t\t\t\t\t\tm = min(m, c[f - 1][k][l].mincost + (c[f - 1][k][l].suberi + j)*abs(c[f - 1][k][l].zahyou - i));\n\t\t\t\t\t}\n\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t}\n\t\t\t\t\tif (k != b&&f > 1) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int l = 0; l < c[f - 2][k+1].size(); l++) {\n\t\t\t\t\t\t\tm = min(m, c[f - 2][k+1][l].mincost + (c[f - 2][k+1][l].suberi + j)*abs(c[f - 2][k+1][l].zahyou - i));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int p = 0; p <= b; p++) {\n\t\t\tfor (isi q : c[a - 1][p]) {\n\t\t\t\tS = min(S, q.mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint a,b;\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n      for(int j=0;j<80;j++){\n\tdp[0][i][j]=dp[1][i][j]=0;\n\tif(j<m)dp[2][i][j]=0;\n      }    \n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int k=0;k<v[i-1].size();k++){\n\t  for(int l=m;l>=0;l--){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t    if(l<m){\n\t      for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)\n      for(int j=0;j<=m;j++)\n      ans=min(ans,dp[n][i][j]);\n\n    for(int i=0;i<v[n-1].size();i++)\n      for(int j=1;j<=m;j++)\n\tans=min(ans,dp[n-1][i][j]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct edge {\n    ll cost;\n    int tobasu;\n    int to;\n    edge(){}\n    edge(ll cost,int tobasu,int to):cost(cost),tobasu(tobasu),to(to){}\n\n    bool operator<(const edge& rhs) const{\n        if(cost>rhs.cost)return true;\n        else if(cost<rhs.cost)return false;\n        else return to<rhs.to;\n    }\n\n    edge operator+(const edge rhs){\n        return edge(cost+rhs.cost,tobasu+rhs.tobasu,rhs.to);\n    }\n};\n\nvector<vector<edge>> G;\nvector<vector<pair<ll,pair<int,int>>>> ishi;\nvector<vector<ll>> dp;\n\nint main() {\n    while(true) {\n        int n,m;\n        cin>>n>>m;\n        if(n==0)break;\n\n        int vt=0;\n        ishi.resize(n);\n        for(int i = 0;i < n;++i) {\n            int k;\n            cin>>k;\n            for(int j = 0;j < k;++j) {\n                int a;\n                ll c;\n                cin>>a>>c;\n                ishi[i].emplace_back(c,make_pair(a,vt));\n                ++vt;\n            }\n        }\n\n        G.resize(vt+2);\n        for(int i = 0;i < n;++i) {\n            for(auto v:ishi[i]) {\n                if(i!=n-1) {\n                    for(auto x:ishi[i+1]) {\n                        ll cost=(v.first+x.first)*abs(v.second.first-x.second.first);\n                        G[v.second.second].emplace_back(cost,0,x.second.second);\n                    }\n                }\n                else {\n                    G[v.second.second].emplace_back(0,0,vt);\n                }\n\n                if(i<n-2) {\n                    for(auto x:ishi[i+2]) {\n                        ll cost=(v.first+x.first)*abs(v.second.first-x.second.first);\n                        G[v.second.second].emplace_back(cost,1,x.second.second);\n                    }\n                }\n                else if(i==n-2){\n                    G[v.second.second].emplace_back(0,1,vt);\n                }\n            }\n        }\n\n//cerr<<\"OK\"<<endl;\n\n        priority_queue<edge> pq;\n        for(auto v:ishi[0]) {\n            pq.emplace(0LL,0,v.second.second);\n        }\n\n        for(auto v:ishi[1]) {\n            pq.emplace(0LL,1,v.second.second);\n        }\n\n        dp.assign(vt+1,vector<ll>(m+1,1000000000000LL));\n\n        while(!pq.empty()) {\n            auto t=pq.top();\n//cerr<<\"cost:\"<<t.cost<<\" tobasu:\"<<t.tobasu<<\" to:\"<<t.to<<endl;\n            if(t.to==vt)break;\n            pq.pop();\n            for(auto v:G[t.to]) {\n                auto te=t+v;\n                if(te.tobasu>m)continue;\n                if(dp[te.to][te.tobasu]<te.cost)continue;\n                dp[te.to][te.tobasu]=te.cost;\n                pq.push(te);\n            }\n        }\n\n        cout<<pq.top().cost<<endl;\n\n        G.clear();\n        ishi.clear();\n        dp.clear();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 1005\n#define N 155\n#define S 85\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[S][N][M];\n\nint dijkstra(int sy,int sx,int x){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<=(n+1)/2;i++)\n    for(int j=0;j<n;j++)\n      for(int l=0;l<M;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  if(x<=m)q.push(P1(P(0,x),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  for(int i=0;i<node[n-2].size();i++)\n    for(int j=0;j<m;j++)\n      res=min(res,d[j][n-2][node[n-2][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x,0));\n    for(int i=0;i<node[1].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x,1));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\n\nint dp[1510][80];\n\n\nint solve(){\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==0) exit(0);\n\tvector<pa3> ve[160];\n\tint cnt=0;\n\tint hei[1510];\n\tint yoko[1510];\n\tint sube[1510];\n\tfor(int i=1;i<=n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint y,yy;\n\t\t\tcin>>y>>yy;\n\t\t\thei[cnt]=i;\n\t\t\tyoko[cnt]=y;\n\t\t\tsube[cnt]=yy;\n\t\t\t\tve[i].pb({cnt,y,yy});\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<cnt;i++)for(int j=0;j<=m;j++){\n\t\tdp[i][j]=inf*1000000ll;\n\t}\n\tfor(auto v:ve[1]){\n\t\tdp[v.x][m]=0;\n\t}\n\t\n\tfor(auto v:ve[2]){\n\t\tif(m-1>=0)dp[v.x][m-1]=0;\n\t}\n\tint ans=inf*1000000ll;\n\tint inff=ans;\n\tfor(int i=0;i<cnt;i++){\n\t\tint h=hei[i];\n\t//\tcout<<h<<endl;\n\t\tif(h<=n-2){\n\t\t\tfor(auto v:ve[h+1]){\n\t\t\t\tfor(int j=0;j<=m;j++)if(dp[i][j]<inff){\n\t\t\t\t\tdp[v.x][j]=min(dp[v.x][j],dp[i][j]+(v.z+sube[i])*abs(v.y-yoko[i]));\n\t\t\t\t//\tcout<<dp[v.x][j]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto v:ve[h+2]){\n\t\t\t\tfor(int j=1;j<=m;j++)if(dp[i][j]<inff){\n\t\t\t\t\tdp[v.x][j-1]=min(dp[v.x][j-1],dp[i][j]+(v.z+sube[i])*abs(v.y-yoko[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(h==n-1){\n\t\t\tfor(auto v:ve[h+1]){\n\t\t\t\tfor(int j=0;j<=m;j++)if(dp[i][j]<inff){\n\t\t\t\t\tdp[v.x][j]=min(dp[v.x][j],dp[i][j]+(v.z+sube[i])*abs(v.y-yoko[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\tfor(int j=1;j<=m;j++)if(dp[i][j]<inff){\n\t\t\t\t\tans=min(ans,dp[i][j]);\n\t\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if(h==n){\n\t\t\tfor(int j=0;j<=m;j++)if(dp[i][j]<inff){\n\t\t\t\t\tans=min(ans,dp[i][j]);\n\t\t\t\t}\n\t\t\tfor(int j=1;j<=m;j++)if(dp[i][j]<inff){\n\t\t\t\t\tans=min(ans,dp[i][j]);\n\t\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\n\t\t\t  cin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1)cout<<solve()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint z(int x){\n\tif(x<0)return -x;\n\treturn x;\n}\n\nint main(){\nwhile(1){\n\tconst long long int INF=1000000000000000000;\n\tlong long int n,m,k;\n\tstatic long long int a[1002],b[152][1002],dp[152][1002][102];\n\tfor(int i=0;i<152;i++)for(int j=0;j<1002;j++)for(k=0;k<102;k++)dp[i][j][k]=INF;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=0;j<k;j++){\n\t\t\tscanf(\"%d\",&a[j]);\n\t\t\tscanf(\"%d\",&b[i][a[j]]);\n\t\t\tfor(int c=0;c<=m;c++){\n\t\t\t\tif(i==1)dp[i][a[j]][c]=0;\n\t\t\t\telse {\n\t\t\t\t\tfor(int l=0;l<1002;l++){\n\t\t\t\t\t\tif(dp[i-1][l][c]!=INF){\n\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-1][l][c]+z(l-a[j])*(b[i][a[j]]+b[i-1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c!=0){\n\t\t\t\t\t\t\tif(dp[i-2][l][c-1]!=INF){\n\t\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-2][l][c-1]+z(l-a[j])*(b[i][a[j]]+b[i-2][l]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ret=INF;\n\tfor(int i=0;i<1002;i++)for(int j=0;j<=m;j++)ret=min(ret,dp[n][i][j]);\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tif (m != 0) REP(i, stone[1].size()) dp[1][i][m - 1] = 0;\n\t\t\n\t\tREP(i, n - 1) REP(j, stone[i].size()) REP(k, m + 1) {\n\t\t\tpii &from = stone[i][j];\n\t\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2 && k > 0) {\n\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\tpii &to = stone[i + 2][l];\n\t\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\tpii &to = stone[i + 1][l];\n\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tif (n > 1) REP(i, stone[n - 2].size()) FOR(j, 1, m + 1) ans = min(ans, dp[n - 2][i][j]);\n\t\tif (ans == INF) ans = 0;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint z(int x){\n\tif(x<0)return -x;\n\treturn x;\n}\n\nint main(){\nwhile(1){\n\tconst long long int INF=1000000000000000000;\n\tlong long int n,m,k;\n\tstatic long long int a[1002],b[152][1002],dp[152][1002][102];\n\tfor(int i=0;i<152;i++)for(int j=0;j<1002;j++)for(k=0;k<102;k++)dp[i][j][k]=INF;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=0;j<k;j++){\n\t\t\tscanf(\"%d\",&a[j]);\n\t\t\tscanf(\"%d\",&b[i][a[j]]);\n\t\t\tfor(int c=0;c<=m;c++){\n\t\t\t\tif(i==1)dp[i][a[j]][c]=0;\n\t\t\t\telse {\n\t\t\t\t\tfor(int l=0;l<1002;l++){\n\t\t\t\t\t\tif(dp[i-1][l][c]!=INF){\n\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-1][l][c]+z(l-a[j])*(b[i][a[j]]+b[i-1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c!=0){\n\t\t\t\t\t\t\tif(dp[i-2][l][c-1]!=INF){\n\t\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-2][l][c-1]+z(l-a[j])*(b[i][a[j]]+b[i-2][l]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=INF;\n\tfor(int i=0;i<1002;i++)for(int j=0;j<=m;j++)ret=min(ret,dp[n][i][j]);\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n\n#define ft first\n#define sd second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 99999;\nint n, m;\nmap<int, vector<P> > mpp;\n\nint solve()\n{\n  int res = inf, dp[152][11][80];\n  vector<P> v1, v2;\n \n  for(int i = 0; i <= m; i++)\n    for(int j = 0; j <= n; j++)\n      for(int k = 0; k <= 10; k++)\n\tdp[j][k][i] = inf;\n\n  v1 = mpp[1];\n  for(int i = 0; i < v1.size(); i++)\n    dp[1][v1[i].ft][m] = 0;\n\n\n  for(int i = 1; i < n; i++){\n    v1 = mpp[i];\n    v2 = mpp[i+1];\n    for(int j = m; j >= 0; j--)\n      for(int k = 0; k < v1.size(); k++)\n\tfor(int l = 0; l < v2.size(); l++)\n\t  dp[i+1][v2[l].ft][j]=min(dp[i+1][v2[l].ft][j],dp[i][v1[k].ft][j]+(v1[k].sd+v2[l].sd)*((int)fabs((double)(v1[k].ft-v2[l].ft))));\n\n    if(i < n-1){\n      v2 = mpp[i+2];\n      for(int j = m; j > 0; j--)\n\tfor(int k = 0; k < v1.size(); k++)\n\t  for(int l = 0; l < v2.size(); l++)\n\t    dp[i+2][v2[l].ft][j-1]=min(dp[i+2][v2[l].ft][j-1],dp[i][v1[k].ft][j]+(v1[k].sd+v2[l].sd)*((int)fabs((double)(v1[k].ft-v2[l].ft))));\n    }\n  }\n  /*\n  for(int i = n; i > 0; i--){\n    for(int j = 1; j <= n; j++){\n      int t = inf;\n      for(int k = 0; k <= m; k++)\n\tt = min(t, dp[i][j][k]);\n      if(t == inf) cout << \" - \";\n      else cout << \" \" << t << \" \";\n    }\n    cout << endl;\n  }\n  */\n  for(int i = 0; i <= 10; i++)\n    for(int j = 0; j <= m; j++)\n      res = min(res, dp[n][i][j]);\n\n  return res;\n}\n\nint main()\n{\n  int s, t, u;\n  while(cin>>n>>m && (n+m)){\n    for(int i = 1; i <= n; i++){\n      cin >> u;\n      vector<P> vec;\n      while(u--){\n\tcin >> s >> t;\n\tvec.push_back(P(s, t));\n      }\n      mpp[i] = vec;\n    }\n\n    cout << solve() << endl;\n    mpp.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)break;\n        vector<vector<vector<int> > > mdan(n,vector<vector<int> >(1000,vector<int>(m+1,-1)));\n        vector<vector<int> > sube(n,vector<int>(1000,-1));\n        int ki,x,d;\n        for(int i=0;i<n;i++){\n            scanf(\"%d\",&ki);\n            for(int j=0;j<ki;j++){\n                scanf(\"%d%d\",&x,&d);\n                sube[i][x-1]=d;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<1000;j++){\n                if(sube[i][j]!=-1){\n                    if(i==0)mdan[i][j][0]=0;\n                    else{\n                        for(int l=0;l<1000;l++){\n                        }\n                        for(int l=0;l<1000;l++){\n                            if(mdan[i-1][l][0]!=-1){\n                            }\n                            for(int k=0;k<=m;k++){\n                                if(mdan[i-1][l][k]!=-1){\n                                    int newd=mdan[i-1][l][k]+(sube[i-1][l]+sube[i][j])*abs(j-l);\n                                    if(mdan[i][j][k]==-1||mdan[i][j][k]>newd)mdan[i][j][k]=newd;\n                                }\n                                if(k>0&&i>=2&&mdan[i-2][l][k-1]!=-1){\n                                    int newd=mdan[i-2][l][k-1]+(sube[i-2][l]+sube[i][j])*abs(j-l);\n                                    if(mdan[i][j][k]==-1||mdan[i][j][k]>newd)mdan[i][j][k]=newd;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int mi=INT_MAX;\n        for(int l=0;l<1000;l++){\n            for(int k=0;k<=m;k++){\n                if(mdan[n-1][l][k]!=-1)mi=min(mi,mdan[n-1][l][k]);\n            }\n        }\n        printf(\"%d\\n\",mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <algorighm>\n\nusing namespace std;\n\n#define INF (1000000000)\n\nint dp[151][10][77];\n\ntypedef struct {\n\tint slip;\n\tint coor;\n} ST;\n\nint main(void)\n{\n\tint n, m;\n\tint k[151];\n\tST st[151][10];\n\tint ans;\n\t\n\t\n\tk[150] = 0;\n\tfor (int i = 0; i < 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tfor (int l = 0; l < 77; l++){\n\t\t\t\tdp[i][j][l] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &k[i]);\n\t\tfor (int j = 0; j < k[i]; j++){\n\t\t\tscanf(\"%d%d\", &st[i][j].coor, &st[i][j].slip);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < k[0]; i++){\n\t\tdp[0][i][0] = 0;\n\t}\n\tfor (int i = 0; i < k[1]; i++){\n\t\tdp[1][i][1] = 0;\n\t}\n\t\n\tfor (int i = 0; i < n - 1; i++){\n\t\tfor (int j = 0; j < k[i]; j++){\n\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\tfor (int h = 0; h < k[i + 1]; h++){\n\t\t\t\t\tdp[i + 1][h][l] = min(dp[i + 1][h][l], dp[i][j][l] + ((st[i][j].slip + st[i + 1][h].slip) * abs(st[i][j].coor - st[i + 1][h].coor)));\n\t\t\t\t}\n\t\t\t\tfor (int h = 0; h < k[i + 2]; h++){\n\t\t\t\t\tdp[i + 2][h][l + 1] = min(dp[i + 2][h][l + 1], dp[i][j][l] + (st[i][j].slip + st[i + 2][h].slip) * abs(st[i][j].coor - st[i + 2][h].coor));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans = INF;\n\tfor (int i = 0; i < k[n - 1]; i++){\n\t\tfor (int j = 0; j <= m; j++){\n\t\t\tans = min(ans, dp[n - 1][i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < k[n - 2]; i++){\n\t\tfor (int j = 0; j < m; j++){\n\t\t\tans = min(ans, dp[n - 2][i][j]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N,M;\nlist<long long int>ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\tvector<vector<int>>a(2, vector <int>(4));\n\twhile (N) {\n\t\tlong long int dp[152][100][10];\n\t\tvector<vector<int>>stone(N + 1);\n\t\tvector<int>have(N + 2);\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\thave[i] = a;\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\tstone[i].push_back(b);\n\t\t\t\tstone[i].push_back(c);\n\t\t\t}\n\t\t\t//cout << \"hijiki\";\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j <= M; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++)dp[i][j][k] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t//cout << \"hijiki\";\n\t\tfor (int i = 0; i < have[1]; i++) {\n\t\t\tdp[1][0][i] = 0;\n\t\t}\n\t\tif (M) {\n\t\t\tfor (int i = 0; i < have[2]; i++) {\n\t\t\t\tdp[2][1][i] = 0;\n\t\t\t}\n\t\t}\n\t//\tcout << \"hijiki\";\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = 0; j <= M; j++) {\n\t\t\t\tfor (int k = 0; k < have[i]; k++) {\n\t\t\t\t\tfor (int l = 0; l < have[i + 1]; l++) {\n\t\t\t\t\t\tif(j)dp[i + 1][j][l] = min(dp[i + 1][j][l], dp[i + 1][j][l]);\n\t\t\t\t\t\tdp[i + 1][j][l] = min(dp[i + 1][j][l], dp[i][j][k] + (stone[i][k * 2 + 1] + stone[i + 1][l * 2 + 1])*(abs(stone[i][k * 2] - stone[i + 1][l * 2])));\n\t\t\t\t\t}\n\t\t\t\t\tif (j != M) {\n\t\t\t\t\t\tfor (int l = 0; l < have[i + 2]; l++) {\n\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = min(dp[i + 2][j][l], dp[i + 2][j + 1][l]);\n\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k] + (stone[i][k * 2 + 1] + stone[i + 2][l * 2 + 1])*(abs(stone[i][k * 2] - stone[i + 2][l * 2])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int box = INT_MAX;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = 0; j < have[N - 1]; j++) {\n\t\t\t\tbox = min(box, dp[N - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= M; i++) {\n\t\t\tfor (int j = 0; j < have[N]; j++) {\n\t\t\t\tbox = min(box, dp[N][i][j]);\n\t\t\t}\n\t\t}\n\t\t//for (int i = 1; i <= N; i++) {\n\t\t//\tfor (int j = 0; j <= M; j++) {\n\t\t//\t\tfor (int k = 0; k < have[i]; k++) {\n\t\t//\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\t\tans.push_back(box);\n\t\tcin >> N >> M;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77];\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int i = 0; i < 1001; i++)\n\t\t\t\tfill(cur[i],cur[i]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=cur;\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,fin[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n#define f first\n#define s second\n#define INF (1<<29)\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\n\nint field[300][10];\nint n, m;\n\nint bfs(){\n  queue<P2> que; // (x, y, m, cost)\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[0][j] != 0) que.push(P2(P(j, 0), P(0, 0)));\n  }\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[1][j] != 0 && m != 0) que.push(P2(P(j, 1), P(1, 0)));\n  }\n  int ans = INF;\n  \n  while(!que.empty()){\n    P2 pos = que.front(); que.pop();\n    if(pos.f.s > n) continue;\n    if(pos.f.s == n-2 && pos.s.f < m){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    if(pos.f.s == n-1){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    for(int i = 1 ; i <= 2 ; i++){\n      for(int j = -3 ; j <= 3 ; j++){\n\tif(i == 2 && pos.s.f == m) continue;\n\tif(pos.f.s+i >= n || pos.f.f+j < 0 || pos.f.f+j > 3) continue;\n\tif(field[pos.f.s + i][pos.f.f + j] != 0){\n\t  if(i == 1){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\t  \t  \n\t  }\n\t  else if(i == 2){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f+1, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\n\t  }\n\t}\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> n >> m){\n    if(n == 0 && m == 0) break;\n    memset(field, 0, sizeof(field));\n    \n    int k, pos, cost;\n    for(int i = 0 ; i < n ; i++){\n      cin >> k;\n      for(int j = 0 ; j < k ; j++){\n\tcin >> pos >> cost;\n\tpos--;\n\tfield[i][pos] = cost;\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\tfor(int a=0;a<=m;a++){\n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  for(k=0;k<v[i+1].size();k++){\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t  }\n\t}\n      }\n    }\n\n    \n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint n,m;\nint main() {\nwhile(1){\n\tcin >> n >> m;\n\tint dp[150][80][10]={};\n\tvector<int> pos[150];\n\tvector<int> slip[150];\n\tif(n==0&&m==0)return 0;\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\n\t\t\tcin >> x >> d;\n\t\t\tpos[i].push_back(x);\n\t\t\tslip[i].push_back(d);\n\t\t\tfor(int u=0;u<=m;u++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tdp[i][u][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==1&&u>0){\n\t\t\t\t\tdp[i][u][j]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][u][j]=1<<30;\n\t\t\t\tfor(int r=0;r<pos[i-1].size();r++){\n\t\t\t\t\tint v=dp[i-1][u][r]+abs(pos[i-1][r]-x)*(slip[i-1][r]+d);\n\t\t\t\t\tdp[i][u][j]=min(dp[i][u][j],v);\n\t\t\t\t}\n\t\t\t\tif(u==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int r=0;r<pos[i-2].size();r++){\n\t\t\t\t\tint v=dp[i-2][u-1][r]+abs(pos[i-2][r]-x)*(slip[i-2][r]+d);\n\t\t\t\t\tdp[i][u][j]=min(dp[i][u][j],v);\n\t\t\t\t}\n\t\t\t\t//cout << i << \", \" << u << \", \" << j << \": \" << dp[i][u][j] << endl;\n\t\t\t\t//cout << pos[i].size() << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ret=1<<30;\n\tfor(int i=0;i<pos[n-1].size();i++){\n\t\tret=min(ret,dp[n-1][m][i]);\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint n,m;\nint a,b;\nint fie[210][4];\t// 行、マス\nint dp[210][210][4];// x回目１こ飛ばし、行、マス\n\nvoid calc(int u)\n{\n\tu *= 2;\n\tfor(int i = u; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\t\t// 現在の立ち位置\n\t\t\tfor(int k = 0; k < 4; k++){\t// 次の場所\n\t\t\t\tfor(int add = 0; add <= 1; add++){\n\t\t\t\t\tif(add+(u/2) > m)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(fie[i][j] >= 0 && fie[i+1+add][k] >= 0){\n\t\t\t\t\t\tint nowRisk = (fie[i][j] + fie[i+1+add][k])*abs(j-k)+dp[u/2][i][j];\n\t\t\t\t\t\tif(dp[u/2][i][j] == -1)\n\t\t\t\t\t\t\tnowRisk += 1;\n\n//\t\t\t\t\t\tcout << nowRisk << endl ;\n\t\t\t\t\t\tif(dp[u/2+add][i+1+add][k] >= 0)\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = min(dp[u/2+add][i+1+add][k], nowRisk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = nowRisk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid solve()\n{\n\tint ans = (1 << 25);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tcin >> fie[i][b];\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i <= m; i++){\n\t\tcalc(i);\n\t\t\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif(dp[i][n+1][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+1][j]);\n\t\t\tif(dp[i][n+2][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+2][j]);\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcout << dp[0][i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tcout << ans << endl;\n\n\n\t\n}\n\nint main(void)\n{\n\n\twhile(cin >> n >> m, n | m){\n\t\tfor(int i = 1; i < 200; i++)\n\t\t\tfor(int j = 0; j < 4; j++)\n\t\t\t\tfie[i][j] = -1;\n\t\n\t\t//fill(fie[1], fie[1]+(200-1)*4, -1);\n\t\tfor(int i = 0; i < 200; i++){\n\t\t\tfor(int j = 0; j < 200; j++){\n\t\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\n\t\t//fill(dp[0][0], dp[0][0] + 200*200*4, -1);\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfie[n+1][i] = 0;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%d\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%d %d\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\trep(i, k[0]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(0, 0, i));\n\t\t}\n\n\t\tif (M > 0) {\n\t\t\trep(i, k[1]) {\n\t\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\t\tchmin(ans, rec(2, 1, i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint dp[3][1000][80];\nint main(){\n  int n,m,k,x,d;\n  while(cin>>n>>m&&(n||m)){\n    vector<P>stone[150];\n    REP(i,n){\n      cin>>k;\n      REP(j,k){\n        cin>>x>>d;x--;\n        stone[i].PB(MP(x,d));\n      }\n    }\n    REP(i,3)REP(j,1000)REP(k,80)dp[i][j][k]=INF;\n    REP(i,stone[0].size())dp[0][stone[0][i].first][0]=0;\n    REP(i,stone[1].size())dp[1][stone[1][i].first][1]=0;\n    REP(i,n-1){\n      REP(j,1000)REP(x,80)dp[(i+2)%3][j][x]=INF;\n      REP(j,stone[i].size()){\n        REP(x,stone[i+1].size()){\n          REP(y,m+1){\n            dp[(i+1)%3][stone[i+1][x].first][y]=min(dp[(i+1)%3][stone[i+1][x].first][y],dp[i%3][stone[i][j].first][y]+(stone[i][j].second+stone[i+1][x].second)*abs(stone[i][j].first-stone[i+1][x].first));\n          }\n        }\n        if(i==n-2){\n          continue;\n        }else{\n          REP(x,stone[i+2].size()){\n            REP(y,m){\n              dp[(i+2)%3][stone[i+2][x].first][y+1]=min(dp[(i+2)%3][stone[i+2][x].first][y+1],dp[i%3][stone[i][j].first][y]+(stone[i][j].second+stone[i+2][x].second)*abs(stone[i][j].first-stone[i+2][x].first));\n            }\n          }\n        }\n      }\n    }\n    int ans=INF;\n    REP(i,stone[n-2].size())REP(j,m)ans=min(ans,dp[(n-2)%3][stone[n-2][i].first][j]);\n    REP(i,stone[n-1].size())REP(j,m+1)ans=min(ans,dp[(n-1)%3][stone[n-1][i].first][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  while (cin >> n >> m, n) {\n    int dp[200][15][100] = {0};\n    vector<pii> G[200];\n\n    for (int i = 1; i <= n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n        int x, d;\n        cin >> x >> d;\n        G[i].PB(pii(x, d));\n      }\n    }\n\n    fill(dp[2][0], dp[200][0], INF);\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j < G[i].size(); ++j) {\n        for (int k = 0; k <= m; ++k) {\n          for (int dy = 1; dy <= 2; ++dy) {\n            for (int j2 = 0; j2 < G[i + dy].size(); ++j2) {\n              pii p1 = G[i][j], p2 = G[i + dy][j2];\n              int move = abs(p1.first - p2.first), sumd = p1.second + p2.second;\n              dp[i + dy][j2][k + dy - 1] = min(dp[i + dy][j2][k + dy - 1], dp[i][j][k] + sumd * move);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < G[n].size(); ++i) {\n      for (int j = 0; j <= m; ++j) {\n        ans = min(ans, dp[n][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint k[150];\npair<int,int> stone[150][10];\n\nint memo[100][150][10];\n\nint main(){\n  int n,m;\n  while((n = getInt()) + (m = getInt())){\n    REP(i,n){\n      k[i] = getInt();\n      REP(j,k[i]){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    memset(memo,-1,sizeof(memo));\n\n    typedef pair<int,pair<int,pair<int,int> > > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    REP(i,k[0])\n      pq.push(mp(0,mp(m,mp(i,0))));\n    REP(i,k[1])\n      pq.push(mp(0,mp(m-1,mp(i,1))));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n\n      int cost = d.f;\n      int jump = d.s.f;\n      int t    = d.s.s.f;\n      int y    = d.s.s.s;\n      int x    = stone[y][t].f;\n\n      if(y == n){\n        printf(\"%d\\n\",cost);\n        break;\n      }\n\n      if(memo[jump][y][t] != -1) continue;\n      memo[jump][y][t] = cost;\n\n      if(y < n-1){\n        int d = stone[y][t].s;\n        REP(i,k[y+1]){\n          if(memo[jump][y+1][i] != -1) continue;\n          int xx = stone[y+1][i].f;\n          int dd = stone[y+1][i].s;\n#define ABS(a) ((a) < 0 ? -(a) : (a))\n          int cc = cost + (dd + d) * ABS(xx - x);\n          pq.push(mp(cc,mp(jump,mp(i,y+1))));\n        }\n      }else{\n        pq.push(mp(cost,mp(jump,mp(0,n))));\n      }\n\n      if(jump > 0){\n        if(y < n-2){\n          int d = stone[y][t].s;\n          REP(i,k[y+1]){\n            if(memo[jump-1][y+2][i] != -1) continue;\n            int xx = stone[y+2][i].f;\n            int dd = stone[y+2][i].s;\n            int cc = cost + (dd + d) * ABS(xx - x);\n            pq.push(mp(cc,mp(jump-1,mp(i,y+2))));\n          }\n        }else{\n          pq.push(mp(cost,mp(jump-1,mp(0,n))));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nint main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[152][78]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%d\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%d%d\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e >= 2 && j<b) {\n\t\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 2][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = 1 << 29;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ LL to, cost; edge(int t, LL c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\nint bitcount(int a)\n{\n\tint ret = 0;\n\twhile (a != 0) { ret++; a = (a - 1) & a; }\n\treturn ret;\n}\n\nint dp[151][1001][77];\nint stage[151][1001];\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m && n)\n\t{\n\t\trep(i, n) rep(j, 1001) stage[i][j] = INF;\n\t\tint width = 0;\n\t\trep(i, n)\n\t\t{\n\t\t\tint num; cin >> num;\n\t\t\trep(j, num)\n\t\t\t{\n\t\t\t\tint idx, slip; cin >> idx >> slip;\n\t\t\t\twidth = max(width, idx);\n\t\t\t\tstage[i][idx - 1] = slip;\n\t\t\t}\n\t\t}\n\t\trep(i, n + 1) rep(j, width) rep(k, m + 1) dp[i][j][k] = INF;\n\t\trep(i, width) dp[0][i][0] = stage[n][i] = 0;\n\t\tif (m > 0)\n\t\t{\n\t\t\trep(i, width) dp[1][i][1] = 0;\n\t\t}\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, width) if (stage[i][j] < INF)\n\t\t\t{\n\t\t\t\trep(l, m + 1) if (dp[i][j][l] < INF)\n\t\t\t\t{\n\t\t\t\t\trep(k, width)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (stage[i][j] + stage[i + 1][k]) * abs(j - k));\n\t\t\t\t\t\tif (i + 2 <= n)\n\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (stage[i][j] + stage[i + 2][k]) * abs(j - k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, width) rep(j, m + 1) ans = min(ans, dp[n][i][j]);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint abst(int x){\n    return (x>=0)? x : -x;\n}\n\nint main(){\n    int n,m,ki,min,tmp;\n    int i,j,k,l;\n    scanf(\"%d %d\",&n,&m);\n    while(n||m){\n        int river[n+1][10][2],risk[n+1][10][m+1];//?????°??£?¨???????????????\\??????????????????????????????\n        for(i=1;i<=n;i++){\n            scanf(\"%d\",&ki);\n            river[i][0][0] = ki;\n            for(j=1;j<=ki;j++){\n                scanf(\"%d %d\",&river[i][j][0],&river[i][j][1]);\n            }\n        }\n        for(j=1;j<=river[1][0][0];j++){\n            for(k=0;k<=m;k++){\n                risk[1][j][k] = 0;\n            }\n        }\n        for(i=2;i<=n;i++){\n            for(j=1;j<=river[i][0][0];j++){\n                for(k=0;k<=m;k++){\n                    min = risk[i-1][1][k] + (river[i-1][1][1]+river[i][j][1])*abst(river[i-1][1][0]-river[i][j][0]);\n                    for(l=2;l<=river[i-1][0][0];l++){\n                        tmp = risk[i-1][l][k] + (river[i-1][l][1]+river[i][j][1])*abst(river[i-1][l][0]-river[i][j][0]);\n                        if(tmp<min)min = tmp;\n                    }\n                    if(i-2&&k){\n                        for(l=1;l<=river[i-1][0][0];l++){\n                            tmp = risk[i-2][l][k-1] + (river[i-2][l][1]+river[i][j][1])*abst(river[i-2][l][0]-river[i][j][0]);\n                            if(tmp<min)min = tmp;\n                        }\n                    }\n                    risk[i][j][k] = min;\n                }\n            }\n        }\n        min = risk[n][1][m];\n        for(j=2;j<=river[n][0][0];j++){\n            tmp = risk[n][j][m];\n            if(min>tmp)min = tmp;\n        }\n        printf(\"%d\\n\",min);\n        scanf(\"%d %d\",&n,&m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Solution for aoj:0530 Pyon-Pyon River Crossing\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int INF = 10000000000, MAX_N = 150;\ntypedef pair<int, int> P;\nint n, m, ans;\nint dp[MAX_N + 3][1001][76];\nP stone, stone2;\nvector<P> Stone[151]; //first:??????second:???????????????\nint main(){\n\twhile (cin >> n >> m){\n\t\tif (!n&&!m)\n\t\t\treturn 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tStone[i].clear();\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tStone[i].push_back(P(a, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tfor (int j = 1; j <= 1000; j++){\n\t\t\t\tfor (int k = 0; k <= m; k++){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\t\tstone = Stone[2][i];\n\t\t\tdp[2][stone.first][m] = INF;\n\t\t}\n\t\tfor (int i = 3; i <= n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k <= 75; k++)\n\t\t\t\t\tdp[i][stone.first][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k < Stone[i + 1].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 1][k];\n\t\t\t\t\tfor (int l = m; l >= m - i / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < Stone[i + 2].size(); k++){\n\t\t\t\t\tif (i + 2 > n)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstone2 = Stone[i + 2][k];\n\t\t\t\t\tfor (int l = m - 1; l >= m - (i + 2) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdp[i + 2][stone2.first][l] = min(dp[i + 2][stone2.first][l], (stone.second + stone2.second) * abs(stone.first - stone2.first) + dp[i][stone.first][l + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor (int i = 0; i < Stone[n].size(); i++){\n\t\t\tstone = Stone[n][i];\n\t\t\tfor(int j = 0; j <= m; j++)\n\t\t\t  ans = min(dp[n][stone.first][j], ans);\n\t\t}\n\t\tfor (int i = 0; i < Stone[n - 1].size(); i++){\n\t\t\tstone = Stone[n - 1][i];\n\t\t\tfor(int j = 1; j <= m; j++)\n\t\t\t  ans = min(dp[n - 1][stone.first][j], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(0);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(1));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\n\nvoid solve(void){\nint dp[1005][101];\n\n for(int i=0;i<1005;i++)\n   for(int j=0;j<=m;j++)\n     dp[i][j]=INF;\n\n   dp[0][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n\tedge e=G[i][j];\n\tfor(int k=0;k<=m;k++){\n\t  if(i+1==e.to)dp[i+1][k]=min(dp[i+1][k],dp[i][k]+e.cost);\n\t  if(i+2==e.to && k!=0)dp[i+2][m-k]=min(dp[i+2][m-k],dp[i][m-k+1]+e.cost);\n\t}\n    }\n  }\n  int ans=INF;\n  for(int j=0;j<=m;j++)\n    ans=min(ans,dp[n+1][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0 && graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\n\t    if(i==0 && graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+1==n+1){\n\t      e.to=i+1;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+2==n+1){\n\t      e.to=i+2;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t  }\n\t}\n      }\n    }\n    solve();\n    //cout << dijkstra(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    /*\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t\t\t\t       */\n\t  }\n\t  /*\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint a,b;\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n      for(int j=0;j<80;j++){\n\tdp[0][i][j]=dp[1][i][j]=0;\n\tif(j<m)dp[2][i][j]=0;\n      }    \n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint mincost;\n\n\nvoid NoJump(VVP &G,VVI &dp)\n{\n  int n= dp.size();\n  rep(i,dp[0].size())dp[0][i] = 0;\n  rep(i,n-1)\n    {\n      int m = dp[i].size();\n      int o = dp[i+1].size();\n      rep(j,m)\n\t{\n\t  rep(k,o)\n\t    {\n\t      int cost = (G[i+1][k].S+G[i][j].S)*abs(G[i+1][k].F-G[i][j].F);\n\t      dp[i+1][k] = min(dp[i+1][k],cost+dp[i][j]);\n\t    }\t\n\t}\n    }\n  rep(i,G[n-1].size())mincost = min(mincost,dp[n-1][i]);\n}\n\nvoid printVVI(VVI &G)\n{\n  cout << \"printVVI ------------ \"<< endl;\n  rep(i,G.size())\n    {\n      rep(j,G[i].size())\n\t{\n\t  cout << G[i][j] << \" \";\n\t} \n      cout << endl;\n    }\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      mincost = (1<<29);\n      VVP G(n);\n      rep(i,n)\n\t{\n\t  int k;\n\t  cin >> k;\n\t  rep(j,k)\n\t    {\n\t      int x,d;\n\t      cin >> x >> d;\n\t      G[i].push_back(P(x,d));\n\t    }\n\t}\n    \n      VVI dp(n);\n      rep(i,n)dp[i].resize(G[i].size(),(1<<29));\n      NoJump(G,dp);\n\n      //cout << \"NO.1\" << endl;\n      //printVVI(dp);      \n\n      //First jump\n      VVI prev = dp;\n      if(m != 0){\n\t\n\trep(i,G[1].size())prev[1][i] = 0;    \n\trep(i,n)\t\n\t  {\n\t    if(i+2 >= n)\n\t      {\n\t\trep(k,G[i].size())mincost = min(mincost,dp[i][k]);\n\t\tbreak;\n\t      }\n\t  rep(j,G[i].size())\n\t    {\n\t      rep(k,G[i+2].size())\n\t\t{\n\t\t  int cost = (G[i][j].S+G[i+2][k].S)*abs(G[i][j].F-G[i+2][k].F);\n\t\t  prev[i+2][k] = min(prev[i+2][k],cost+dp[i][j]); \n\t\t}\n\t    }\n\t  }\n\tdp = prev;\n\tNoJump(G,dp);\n\t//cout << \"No.2\" << endl;\n\t//printVVI(dp);\n      }\n      \n      if(m == 1 || m == 0)goto Next;\n\n      for(int i=1,cnt=1;cnt<m;cnt++,i+=2)\n\t{\n\t  prev = dp;\n\t  REP(j,i,n)\n\t    {\n\t      if(j+2 >= n)\n\t\t{\n\t\t  rep(k,G[j].size())mincost = min(mincost,dp[j][k]);\n\t\t  break;\n\t\t}\n\t      rep(k,G[j].size())\n\t\t{\n\t\t  rep(l,G[j+2].size())\n\t\t    {\t  \n\t\t      int cost = (G[j][k].S+G[j+2][l].S)*abs(G[j][k].F-G[j+2][l].F);\n\t\t      prev[j+2][l] = min(prev[j+2][l],cost+dp[j][k]);\n\t\t    }\n\t\t}\n\t    }\n\t  dp = prev;\n\t  NoJump(G,dp);\n\t}      \n      //cout << \"No.3\" << endl;\n      //printVVI(dp);\n     \n    Next:;\n    \n      NoJump(G,dp);\n\n      //cout << \"No.4\" << endl;\n      //printVVI(dp);\n\n      if(!G[n-1].empty())\n\trep(i,G[n-1].size())mincost = min(mincost,dp[n-1][i]);\n      else\n\trep(i,G[n-2].size())mincost = min(mincost,dp[n-2][i]);\n      \n      cout << mincost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  if(v[i+1].size()>0){\n\t    for(k=0;k<v[i+1].size();k++){\n\t    /*\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t\t\t\t       */\n\t    }\n\t  }\n\t  /*\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Pyon-Pyon River Crossing\n\n// 動的計画法\n\n#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\ntypedef pair<int,int> P;\n#define X first\n#define D second\n\nint main()\n{\n    int n, m;\n    while(cin>>n>>m, n|m) {\n        vector<int> k(n);\n        int dp[150][11][77] = {0};\n        vector< vector<P> > stone(n);\n        for(int i=0; i<n; i++) {\n            cin>>k[i];\n            for(int j=0; j<k[i]; j++) {\n                int x, d;\n                cin>>x>>d;\n                stone[i].push_back(P(x,d));\n            }\n        }\n        for(int i=0; i<n; i++) for(int j=0; j<k[i]; j++) for(int l=0; l<=m; l++) dp[i][j][l] = 1<<30;\n        for(int i=0; i<k[0]; i++) dp[0][i][m] = 0;\n        for(int i=0; i<k[1]; i++) dp[1][i][m-1] = 0;\n\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<k[i]; j++) {\n                for(int l=0; l<=m; l++) {\n\n                    if(i+1>=n) continue;\n                    for(int jj=0; jj<k[i+1]; jj++) {\n                        int add;\n                        add = abs((stone[i+1][jj].D+stone[i][j].D)*(stone[i+1][jj].X-stone[i][j].X));\n                        dp[i+1][jj][l] = min(dp[i+1][jj][l], dp[i][j][l]+add);\n                    }\n\n                    if(i+2>=n) continue;\n                    for(int jj=0; jj<k[i+2]; jj++) {\n                        int add;\n                        add = abs((stone[i+2][jj].D+stone[i][j].D)*(stone[i+2][jj].X-stone[i][j].X));\n                        dp[i+2][jj][l-1] = min(dp[i+2][jj][l-1], dp[i][j][l]+add);\n                    }\n                }\n            }\n        }\n\n        int ans = 1<<30;\n        for(int j=0; j<k[n-1]; j++) {\n            for(int l=0; l<=m; l++) {\n                ans = min(ans, dp[n-1][j][l]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0;i < (int)(n);i++)\nusing ll = long long;\nconst ll MOD=1000000007;\nconst long long INF = 1LL << 60;\nconst double pi=acos(-1.0);\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nvector<vector<map<ll,ll>>> table;\nvector<vector<pair<ll,ll>>> grid;\n\nll dp(ll n,ll x,ll d,ll m){\n  if(m<0) return INF;\n  if(n==0) return 0;\n  if(n==1&&m>=1) return 0;\n  if(table.at(m).at(n).count(x)) return table.at(m).at(n).at(x);\n  \n  table.at(m).at(n)[x]=INF;\n  //n-1からの移動\n  for(auto p:grid.at(n-1)){\n    ll px,pd; tie(px,pd)=p;\n    chmin(table.at(m).at(n).at(x),dp(n-1,px,pd,m)+(d+pd)*abs(x-px));\n  }\n  \n  if(n<2||m<1) return table.at(m).at(n).at(x);\n  //n-2からの移動\n  for(auto p:grid.at(n-2)){\n    ll px,pd; tie(px,pd)=p;\n    chmin(table.at(m).at(n).at(x),dp(n-2,px,pd,m-1)+(d+pd)*abs(x-px));\n  }\n  \n  return table.at(m).at(n).at(x);\n}\n\n\nint main()\n{\n  while(true){\n    ll N,M; cin>>N>>M; if(N==0&&M==0) break;\n    grid=vector<vector<pair<ll,ll>>>(N,vector<pair<ll,ll>>(0));\n    rep(i,N){\n      ll k; cin>>k;\n      rep(j,k){\n        ll x,d; cin>>x>>d; x--;\n        grid.at(i).push_back({x,d});\n      }\n    }\n    \n    //dp\n    table=vector<vector<map<ll,ll>>>(M+1,vector<map<ll,ll>>(N));\n    ll ans=INF;\n    for(auto p:grid.at(N-1)){\n      ll x,d;tie(x,d)=p;\n      chmin(ans,dp(N-1,x,d,M));\n    }\n    \n    if(M<1) {cout<<ans<<endl; continue;}\n    \n    for(auto p:grid.at(N-2)){\n      ll x,d; tie(x,d)=p;\n      chmin(ans,dp(N-2,x,d,M-1));\n    }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint DP[151][10][76];\nint abs(int a){\n\tif(a<=0)\n\treturn -a;\n\treturn a;\n}\nint main() {\n\twhile(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n==0)\n\tbreak;\n\tint k[151],kiS[151][10],kiP[151][10];\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> k[i];\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tcin >> kiP[i][j] >> kiS[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<151;i++)\n\t\tfor(int j=0;j<10;j++)\n\t\t\tfor(int kk=0;kk<76;kk++)\n\t\t\t\tDP[i][j][kk]=1 << 28;\n\tfor(int i=0;i<k[1];i++){\n\tDP[1][i][0]=0;\n\t}\n\tfor(int i=0;i<k[2];i++)\n\tDP[2][i][1]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int kk=0;kk<=min(m,i/2+1);kk++){\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int l=0;l<k[i-1];l++)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-1][l][kk]+(kiS[i][j]+kiS[i-1][l])*(abs(kiP[i][j]-kiP[i-1][l])));\n\t\t\t\tfor(int l=0;l<k[i-2];l++){\n\t\t\t\tif(kk!=0 && i!=1)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-2][l][kk-1]+(kiS[i][j]+kiS[i-2][l])*(abs(kiP[i][j]-kiP[i-2][l])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<k[i];j++)\n\t\t//\tcout << DP[i][j][0] << \" \" << i <<\" \" << j <<  endl;\n\t}*/\n\tint maxer =1 << 28;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tmaxer=min(maxer,DP[n][i][j]);\n\t\t\tif(j+1<=m)\n\t\t\tmaxer=min(maxer,DP[n-1][i][j]);\n\t\t}\n\t}\n\tcout << maxer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 150\n#define MAX_M 15\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct State {\n    int dng, x, y, m, d;\n    State(){}\n    State(int dng, int x, int y, int m, int d) :\n        dng(dng), x(x), y(y), m(m), d(d) {}\n\n    bool operator < (const State &s) const {\n        return dng > s.dng;\n    }\n};\n\nint dn[MAX_N][MAX_M][MAX_N];\n\nint main()\n{\n    int N, M, K, x, d;\n    while (cin >> N >> M, N) {\n        vector<pii> G[MAX_N];\n        for (int i = 0; i < N; i++) {\n            cin >> K;            \n            for (int j = 0; j < K; j++) {\n                cin >> x >> d; x--;\n                G[i].push_back(pii(x, d));\n            }\n        }\n\n        for (int i = 0; i < MAX_N; i++) {\n            for (int j = 0; j < MAX_M; j++) {\n                for (int k = 0; k < MAX_N; k++) {\n                    dn[i][j][k] = INF;\n                }\n            }\n        }\n        \n        priority_queue<State> Q;\n        for (int i = 0; i < N; i++) {\n            int size = G[i].size();\n            if (size == 0) continue;\n            int nm = (i > 0 ? M - 1 : M);\n            for (int j = 0; j < size; j++) {\n                int x = G[i][j].first, dng = G[i][j].second;\n                Q.push(State(0, x, i, nm, dng));\n                dn[i][j][nm] = 0;\n            }\n            break;\n        }\n                \n        while (!Q.empty()) {\n            State s = Q.top(); Q.pop();\n            int x = s.x, y = s.y, m = s.m;\n            int dng = s.d;\n            if (y == N-1) {\n                cout << s.dng << endl;\n                break;\n            }\n\n            for (int i = 0; i < (int)G[y+1].size(); i++) {\n                int nx = G[y+1][i].first, nd = G[y+1][i].second;\n                int ncost = s.dng + (dng + nd) * abs(x - nx);\n                if (ncost < dn[y+1][i][m]) {\n                    dn[y+1][i][m] = ncost;\n                    Q.push(State(ncost, nx, y+1, m, nd));\n                }               \n            }\n            if (y + 2 < N && m > 0) {\n                for (int i = 0; i < (int)G[y+2].size(); i++) {\n                    int nx = G[y+2][i].first, nd = G[y+2][i].second;\n                    int ncost = s.dng + (dng + nd) * abs(x - nx);\n                    if (ncost < dn[y+2][i][m-1]) {\n                        dn[y+1][i][m-1] = ncost;\n                        Q.push(State(ncost, nx, y+1, m-1, nd));\n                    } \n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    int y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, int cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<int> > stones(N, vector<int>(1000, INT_MAX));\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i][x] = d;\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < 1000; ++j) {\n                if(stones[i][j] != INT_MAX) {\n                    q.push(Tag(i, j, 0, M-i));\n                }\n            }\n        }\n\n        vector<vector<int> > dp(N, vector<int>(1000, INT_MAX));\n        int ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m == 0 && i == 2) break;\n                for(int j = 0; j < 1000; ++j) {\n                    int cost = stones[t.y+i][j];\n                    if(cost != INT_MAX) {\n                        cost += stones[t.y][t.x];\n                        cost *= abs(t.x-j);\n                        cost += t.c;\n                        if(cost >= dp[t.y+i][j]) continue;\n                        dp[t.y+i][j] = cost;\n                        q.push(Tag(t.y+i, j, cost, t.m-i+1));\n             //           cout << '\\t' << t.y+i << ' ' << j << ' ' << cost*abs(t.x-j) << endl;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<11;i++){\n\t\t\tve[0].push_back(MP(i,0));\n\t\t\tdp[T][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[0].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=min(i/2,M);j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tif(i!=0)for(int i=0;i<M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N-1].size();j++){\n\t\t\t\tres=min(res,dp[T][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define ll long long\n\nusing namespace std;\n\nint main() {\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0)break;\n        vector<vector<pair<ll, ll>>> stone(n);\n        vector<vector<vector<ll>>> dp;\n        for (int i = 0; i < n; i++) {\n            int k;\n            cin >> k;\n            for (int j = 0; j < k; j++) {\n                int x, d;\n                cin >> x >> d;\n                stone[i].push_back(make_pair(x, d));\n            }\n            dp.push_back(vector<vector<ll>>(k, vector<ll>(m + 1)));\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < stone[i].size(); j++) {\n                for (int k = 0; k <= m; k++)dp[i][j][k] = 1145141919810364364;\n            }\n        }\n        for (int i = 0; i < dp[0].size(); i++) dp[0][i][0] = 0;\n        if (m >= 1)for (int i = 0; i < dp[1].size(); i++) dp[1][i][1] = 0;\n        for (int i = 1; i < n; i++) {\n            for (int now = 0; now < stone[i].size(); now++) {\n                for (int back = 0; back < stone[i - 1].size(); back++) {\n                    for (int jump = 0; jump <= m; jump++) {\n                        auto a = stone[i - 1][back];\n                        auto b = stone[i][now];\n                        dp[i][now][jump] =\n                                min(dp[i][now][jump],\n                                    dp[i - 1][back][jump] + (a.second + b.second) * abs(a.first - b.first));\n                    }\n                }\n                if (i > 1) {\n                    for (int back = 0; back < stone[i - 2].size(); back++) {\n                        for (int jump = 1; jump <= m; jump++) {\n                            auto a = stone[i - 2][back];\n                            auto b = stone[i][now];\n                            dp[i][now][jump] =\n                                    min(dp[i][now][jump],\n                                        dp[i - 2][back][jump - 1] + (a.second + b.second) * abs(a.first - b.first));\n                        }\n                    }\n                }\n            }\n        }\n        ll ret = 1145141919810364364;\n        for (int i = 0; i < stone[n - 2].size(); i++) {\n            for (int j = 0; j < m; j++) {\n                ret = min(ret, dp[n - 2][i][j]);\n            }\n        }\n        for (int i = 0; i < stone[n - 1].size(); i++) {\n            for (int j = 0; j <= m; j++) {\n                ret = min(ret, dp[n - 1][i][j]);\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[256][16][128];\nint stones[256][16][2];\nint col[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tcin >> stones[i][j][0] >> stones[i][j][1];\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tint x_now = stones[i][j][0], d_now = stones[i][j][1];\n\tREP(m, M+1) {\n\t  if (dp[i][j][m] == INF) continue;\n\t  REP(k, col[i+1]) {\n\t    int x_next = stones[i+1][k][0], d_next = stones[i+1][k][1];\n\t    int safe = (d_now + d_next) * abs(x_now - x_next);\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + safe);\n\t  }\n\t  if (i < N-2 && m < M) {\n\t    REP(k, col[i+2]) {\n\t      int x_next = stones[i+2][k][0], d_next = stones[i+2][k][1];\n\t      int safe = (d_now + d_next) * abs(x_now - x_next);\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Stone{\n  int x,d;\n  Stone(){}\n  Stone(int x, int d):x(x),d(d){}\n};\n\nint danger(Stone &a, Stone &b){ return abs(a.x-b.x)*(a.d+b.d);}\n\nconst int INF = 1<<30;\nint N,M;\nvector<Stone>s[256];\nint dp[160][16][80];\n\nint main(){\n  while(scanf(\"%d%d\", &N,&M) && N||M){\n    for(int i=0;i<256;i++) s[i].clear();\n    for(int i=0;i<N;i++){\n      int k; scanf(\"%d\", &k);\n      while(k--){\n\tint x,d; scanf(\"%d%d\",&x,&d);\n\ts[i].push_back(Stone(x,d));\n      }\n    }\n\n    for(int i=0;i<160;i++) for(int j=0;j<16;j++) for(int k=0;k<80;k++) dp[i][j][k] = INF;\n    for(int j=0;j<2;j++) for(int i=0;i<s[j].size();i++) dp[0][i][M-j] = 0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k<s[i+1].size();k++){\n\t  for(int m=0;m<=M;m++) \n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m]+danger(s[i][j],s[i+1][k]));\n\t}\n\tif(i<N-1){\n\t  for(int k=0;k<s[i+2].size();k++){\n\t    for(int m=1;m<=M;m++)\n\t      dp[i+2][k][m-1] = min(dp[i+2][k][m-1], dp[i][j][m]+danger(s[i][j],s[i+2][k]));\n\t  }\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=0;i<s[N-1].size();i++) for(int m=0;m<=M;m++) res = min(res, dp[N-1][i][m]);\n    for(int i=0;i<s[N-2].size();i++) for(int m=1;m<=M;m++) res = min(res, dp[N-2][i][m]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint dp[256][16][128];\nint snum[256][16];\nint srip[256][16];\nint ssize[256];\nint main(void){\n    int n,m,k,a,b;\n    const int INF = 1<<30;\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=0;i<128;i++)for(int j=0;j<16;j++)for(int l=1;l<256;l++)dp[l][j][i]=INF;\n\t\tfor(int i=0;i<128;i++)for(int j=0;j<16;j++)dp[0][j][i]=0;\n\t\tfor(int j=0;j<16;j++)dp[1][j][1]=0;\n\t\tmemset(snum,0,sizeof(snum));\n\t\tmemset(srip,0,sizeof(srip));\n\t\tmemset(ssize,0,sizeof(ssize));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tssize[i]=k;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tscanf(\"%d%d\",&snum[i][j],&srip[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=m;i++){\n\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\tint l=ssize[j];\n\t\t\t\tint lb=ssize[j-1];\n\t\t\t\tint lc=ssize[j-2];\n\t\t\t\tfor(int w=0;w<l;w++){\n                    for(int c=0;c<lb;c++){\n                        dp[j][w][i] = min(dp[j][w][i],\n                            (dp[j-1][c][i] + (int)abs(snum[j][w] - snum[j-1][c])*(srip[j][w] + srip[j-1][c]) ) );\n                    }\n                    if(i>0 && j>1)for(int c=0;c<lc;c++){\n                        dp[j][w][i] = min(dp[j][w][i],\n                            (dp[j-2][c][i-1] + (int)abs(snum[j][w] - snum[j-2][c])*(srip[j][w] + srip[j-2][c]) ) );\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0;i<ssize[n-1];i++)ans=min(ans,dp[n-1][i][m]);\n\t\tif(m>0)for(int i=0;i<ssize[n-2];i++)ans=min(ans,dp[n-2][i][m-1]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint numstone[151];\npair<int,int> stones[151][11];\nint memo[151][151][11]; //memo[ツ甘敖つゥツづァツづ個仰猟猟」][ツ氾イツづ篠つオツ氾イツづ堕づーツつオツつスツ嘉アツ青脳[ツ債。ツづ個暗環置]\nint n,m;\n\nint solve(int i,int j,int k) {\n  if(memo[i][j][k] != -1) return memo[i][j][k];\n  if(i >= n-1) return 0;\n\n  int l,ret = 1<<29;\n  if(j < m) {\n    rep(l,numstone[i+2]) {\n      int cc = stones[i][k].second+stones[i+2][l].second;\n      ret = min(ret, solve(i+2, j+1, l)\n\t\t+ cc*abs(stones[i][k].first-stones[i+2][l].first));\n    }\n  }\n\n  rep(l, numstone[i+1]) {\n    int cc = stones[i][k].second+stones[i+1][l].second;\n    ret = min(ret, solve(i+1, j, l)\n\t      + cc*abs(stones[i][k].first-stones[i+1][l].first));\n  }\n  //printf(\"row: %d double: %d nowpos: %d ret: %d\\n\", i,j,k,ret);\n  return memo[i][j][k] = ret;\n}\n\nint main() {\n  int k,i,j;\n  while(scanf(\"%d%d\", &n, &m), n|m) {\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,151) rep(j,151) rep(k,11) memo[i][j][k] = -1;\n    rep(i,n) {\n      scanf(\"%d\", &k);\n      numstone[i] = k;\n      rep(j,k) {\n\tpair<int,int> p;\n\tscanf(\"%d%d\", &(p.first), &(p.second));\n\tstones[i][j] = p;\n      }\n    }\n\n    int ans = 1<<29;\n    rep(i, numstone[0]) {\n      ans = min(ans, solve(0,0,i));\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define INF(a) memset(a,1000000000,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][11];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i].pb(xx);\n    d[i].pb(dd);\n   }\n  }\n  INF(dp);\n  FOR(i,m+1) FOR(j,x[n-1].size()) dp[n-1][i][x[n-1][j]]=0;\n  for(int i=n-2;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(i!=n-2&&j){\n      FOR(l,x[i+2].size()){\n       dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+((d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l])));\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+((d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l])));\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[0].size()) mi=min(mi,dp[i][m][x[0][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\npair<int,int> stones[151][10];\nint cstone[151];\nint memo[151][10][100];\nint n,m;\n\nint solve(int i,int j,int l) {\n  if(memo[i][j][l] != -1) return memo[i][j][l];\n  if(i >= n-1) return 0;\n\n  int res = 1000000000,k;\n  if(l < m) {\n    rep(k,cstone[i+2]) {\n      int cc = stones[i][j].second+stones[i+2][k].second;\n      int dx = abs(stones[i][j].first-stones[i+2][k].first);\n      res = min(res, cc*dx + solve(i+2,k,l+1));\n    }\n  }\n\n  rep(k,cstone[i+1]) {\n    int cc = stones[i][j].second+stones[i+1][k].second;\n    int dx = abs(stones[i][j].first-stones[i+1][k].first);\n    res = min(res, cc*dx + solve(i+1,k,l));\n  }\n\n  return memo[i][j][l] = res;\n}\n\nint main() {\n  int k,l,i,j,x,d;\n  while(scanf(\"%d %d\", &n, &m), n|m) {\n    memset(stones, 0, sizeof(stones));\n    memset(cstone, 0, sizeof(cstone));\n    memset(memo, -1, sizeof(memo));\n    rep(i,n) {\n      scanf(\"%d\", &k);\n      cstone[i] = k;\n      rep(j,k) {\n\tscanf(\"%d %d\", &x, &d);\n\tstones[i][j] = pair<int,int>(x,d);\n      }\n    }\n\n    int ans = 1000000000;\n    rep(i,cstone[0]) {\n      ans = min(ans, solve(0, i, 0));\n    }\n\n    if(m >= 1)\n      rep(i,cstone[1]) {\n\tans = min(ans, solve(1,i,1));\n      }\n\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int inf = 1<<28;\nconst int H = 151;\nconst int W = 1001;\nconst int M = 80;\nint D[H][W];\nint dp[4][W][M];\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                D[i][j] = inf;\n            }\n        }\n        for ( int i = 0; i < 4; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                for ( int k = 0; k < M; ++ k ) {\n                    dp[i][j][k] = inf;\n                }\n            }\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int x, d;\n                cin >> x >> d;\n                -- x;\n                D[i][x] = d;\n            }\n        }\n        for ( int i = 0; i < W; ++ i ) {\n            dp[0][i][0] = ( D[0][i] == inf ? inf : 0 );\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                if ( D[i][j] == inf ) continue;\n                for ( int k = 0; k < W; ++ k ) {\n                    for ( int l = 0; l <= m; ++ l ) {\n                        if ( dp[0][j][l] == inf ) continue;\n                        if ( i + 2 < n && D[i + 2][k] != inf ) {\n                            dp[2][k][l+1] = min( dp[2][k][l+1], dp[0][j][l] + ( D[i][j] + D[i+2][k] ) * abs( j - k ) );\n                        } else if ( i + 2 >= n ) {\n                            dp[2][k][l+1] = min( dp[2][k][l+1], dp[0][j][l] );\n                        }\n                        if ( i + 1 < n && D[i + 1][k] != inf ) {\n                            dp[1][k][l] = min( dp[1][k][l], dp[0][j][l] + ( D[i][j] + D[i+1][k] ) * abs( j - k ) );\n                        } else if ( i + 1 >= n ) {\n                            dp[1][k][l] = min( dp[1][k][l], dp[0][j][l] );\n                        }\n                    }\n                }\n            }\n            for ( int j = 0; j < W; ++ j ) {\n                for ( int k = 0; k <= m; ++ k ) {\n                    for ( int t = 0; t + 1 < 4; ++ t ) {\n                        dp[t][j][k] = dp[t+1][j][k];\n                    }\n                }\n            }\n        }\n        int answer = inf;\n        for ( int i = 0; i < 4; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                for ( int k = 0; k <= m; ++ k ) {\n                    if ( dp[i][j][k] == inf ) continue;\n                    answer = min( answer, dp[i][j][k] );\n                    // cout << ( dp[i][j][k] == inf ? -1 : dp[i][j][k] ) << \", \";\n                }\n                // cout << endl;\n            }\n            // cout << endl;\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][1010];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,1000){\n   x[0].pb(i+1);\n   x[n+1].pb(i+1);\n  }\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  fill(dp[0][0],dp[n-1][0],1000000000);\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][x[n][j]]=0;\n  for(int i=n-1;i>0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][x[i][k]]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+(i!=0)?(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]):0);\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+(i!=0)?(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]):0);\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][x[1][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m;\nll dp[155][80][10],INF=1000000000000000LL;\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n&&!m) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  FOR(i,155) FOR(j,80) FOR(k,10) dp[i][j][k]=INF;\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][j]=0LL;\n  for(int i=n-1;i>0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][k]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][k]=min(dp[i][j][k],dp[i+2][j-1][l]+(ll)(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][l]+(ll)(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  ll mi=INF;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][i]);\n  if(m) FOR(i,x[2].size()) mi=min(mi,dp[2][m-1][i]);\n  cout<<mi<<endl;\n  FOR(i,155){\n   x[i].clear(); d[i].clear();\n  }\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint z(int x){\n\tif(x<0)return -x;\n\treturn x;\n}\n\nint main(){\nwhile(1){\n\tconst int INF=1000000000;\n\tint n,m,k;\n\tstatic int a[1002],b[152][1002],dp[152][1002][102];\n\tfor(int i=0;i<152;i++)for(int j=0;j<1002;j++)for(k=0;k<102;k++)dp[i][j][k]=INF;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=0;j<k;j++){\n\t\t\tscanf(\"%d\",&a[j]);\n\t\t\tscanf(\"%d\",&b[i][a[j]]);\n\t\t\tfor(int c=0;c<=m;c++){\n\t\t\t\tif(i==1)dp[i][a[j]][c]=0;\n\t\t\t\telse {\n\t\t\t\t\tfor(int l=0;l<1002;l++){\n\t\t\t\t\t\tif(dp[i-1][l][c]!=INF){\n\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-1][l][c]+z(l-a[j])*(b[i][a[j]]+b[i-1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c!=0){\n\t\t\t\t\t\t\tif(dp[i-2][l][c-1]!=INF){\n\t\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-2][l][c-1]+z(l-a[j])*(b[i][a[j]]+b[i-2][l]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret=INF;\n\tfor(int i=0;i<1002;i++)for(int j=0;j<=m;j++)ret=min(ret,dp[n][i][j]);\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#define INF (1000000000)\n#define MOD (1000000007)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\ntypedef vector<long>::iterator VL;\ntypedef vector<long>::iterator VLI;\ntypedef pair<int, int> P;\n\n\nint d[150][1000];\nint dp[150][1000][100];\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tmemset(d, 0, sizeof(d));\n\t\tint maxx = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; j++){\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tx--;\n\t\t\t\tscanf(\"%d\", &d[i][x]);\n\t\t\t\t\n\t\t\t\tmaxx = max(maxx, x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j <= maxx; j++){\n\t\t\t\tfor (int k = 0; k < 100; k++){\n\t\t\t\t\tif (i == 0 && d[i][j] && k == 0) dp[i][j][k] = 0;\n\t\t\t\t\telse dp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j <= maxx; j++){\n\t\t\t\tfor (int k = 0; k <= maxx; k++){\n\t\t\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\t\t\tif (d[i][j] && d[i + 1][k]){\n\t\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (d[i][j] + d[i + 1][k]) * abs(j - k));\n\t\t\t\t\t\t\t//printf(\"%d\\n\", dp[i + 1][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i < n - 1 && d[i][j] && d[i + 2][k]){\n\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (d[i][j] + d[i + 2][k]) * abs(j - k));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini = INF;\n\t\tfor (int i = 0; i <= maxx i++){\n\t\t\tfor (int j = 0; j <= m; j++){\n\t\t\t\tmini = min(mini, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77]=cur;\n\t\t//// dpÅÅ¬RXgðßé\n\t\t//for(int i = 1; i < n; i++){\n\t\t//\tswap(cur,prv);\n\t\t//\tswap(pprv,cur);\n\t\t//\tfor(int i = 0; i < 1001; i++)\n\t\t//\t\tfill(cur[i],cur[i]+77,INF);\n\t\t//\t// Ç±ÖWv·é©\n\t\t//\tfor(int j = 0; j < 1001; j++){\n\t\t//\t\tif(field[i][j]==0)\n\t\t//\t\t\tcontinue;\n\t\t//\t\t// Ç±©çWv·é©\n\t\t//\t\tfor(int k = 0;  k < 1001; k++){\n\t\t//\t\t\t// ÇÌRXgÅWv·é©\n\t\t//\t\t\tfor(int l = m; l >= 0; l--){\n\t\t//\t\t\t\t// ÓÂ¤ÉWv\n\t\t//\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t//\t\t\t\tif(i>=2&&l!=m){\n\t\t//\t\t\t\t\t// êÂòÎµÅWv\n\t\t//\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t//\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//\tfin=cur;\n\t\t//}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,fin[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<Int,Int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nInt dp[100][3][1010];\nvector<vector<pint> > river;\nInt k[200];\n\nInt myabs(Int a){\n\tif(a<0)return -a;\n\telse return a;\n}\n\nint main() {\n\tInt n,m;\n\twhile(cin>>n>>m,n){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\triver.clear();\n\t\tInt i,j;\n\t\tvector<pint> buf;\n\t\tfor(i=0;i<n;i++){\n\t\t\triver.push_back(buf);\n\t\t\tk[i]=in();\n\t\t\tInt x,d;\n\t\t\tfor(j=0;j<k[i];j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\triver[i].push_back(mp(x,d));\n\t\t\t}\n\t\t}\n\t\tInt from,to,cost;\n\t\tfor(i=0;i<k[0];i++){\n\t\t\tdp[0][0][river[0][i].first]=0;\n\t\t}\n\t\tfor(i=0;i<k[1];i++){\n\t\t\tdp[1][1][river[1][i].first]=0;\n\t\t}\n\t\tfor(i=0;i<k[0];i++){\n\t\t\tfor(j=0;j<k[1];j++){\n\t\t\t\tfrom=river[0][i].first;\n\t\t\t\tto=river[1][j].first;\n\t\t\t\tcost=(river[0][i].second+river[1][j].second)*myabs(from-to);\n\t\t\t\tif(dp[0][1][to]==-1||dp[0][1][to]>cost){\n\t\t\t\t\tdp[0][1][to]=cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=n-3;i++){\n\t\t\tInt t,s;\n\t\t\tfor(t=0;t<k[i];t++){\n\t\t\t\tfor(s=0;s<k[i+2];s++){\n\t\t\t\t\tfor(j=0;j<m;j++){\n\t\t\t\t\t\tfrom=river[i][t].first;\n\t\t\t\t\t\tto=river[i+2][s].first;\n\t\t\t\t\t\tcost=(river[i][t].second+river[i+2][s].second)*myabs(from-to);\n\t\t\t\t\t\tif(dp[j][0][from]==-1)continue;\n\t\t\t\t\t\tif(dp[j+1][2][to]==-1||dp[j+1][2][to]>dp[j][0][from]+cost){\n\t\t\t\t\t\t\tdp[j+1][2][river[i+2][s].first]=dp[j][0][river[i][t].first]+cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(t=0;t<k[i+1];t++){\n\t\t\t\tfor(s=0;s<k[i+2];s++){\n\t\t\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\t\t\tfrom=river[i+1][t].first;\n\t\t\t\t\t\tto=river[i+2][s].first;\n\t\t\t\t\t\tcost=(river[i+1][t].second+river[i+2][s].second)*myabs(from-to);\n\t\t\t\t\t\tif(dp[j][1][from]==-1)continue;\n\t\t\t\t\t\tif(dp[j][2][to]==-1||dp[j][2][to]>dp[j][1][from]+cost){\n\t\t\t\t\t\t\tdp[j][2][river[i+2][s].first]=dp[j][1][river[i+1][t].first]+cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(t=0;t<1010;t++){\n\t\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\t\tdp[j][0][t]=dp[j][1][t];\n\t\t\t\t\tdp[j][1][t]=dp[j][2][t];\n\t\t\t\t\tdp[j][2][t]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInt res=100100100;\n\t\tres*=100100100;\n\t\tfor(i=0;i<1010;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tif(dp[j][1][i]!=-1)chmin(res,dp[j][1][i]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<1010;i++){\n\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\tif(dp[j][0][i]!=-1)chmin(res,dp[j][0][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        vector<vector<vector<int> > > dp(3, vector<vector<int> >(10, vector<int>(M+1, INT_MAX/10000)));\n        for(int i = 0; i < stones[0].size(); ++i) {\n            dp[0][i][M] = 0;\n        }\n        if(M > 0) {\n            for(int i = 0; i < stones[1].size(); ++i) {\n                dp[1][i][M-1] = 0;\n            }\n        }\n        for(int i = 2; i < N; ++i) {\n            int curr = i%3;\n            int prev = (i-1)%3;\n            int pp = (i-2)%3;\n\n            for(int k = 0; k < stones[i].size(); ++k) {\n                fill(dp[curr][k].begin(), dp[curr][k].end(), INT_MAX/10000);\n            }\n            for(int j = 0; j < stones[i-2].size(); ++j) {\n                //pp to prev\n                int sx = stones[i-2][j].first;\n                int sc = stones[i-2][j].second;\n                for(int k = 0; k < stones[i-1].size(); ++k) {\n                    int skx = stones[i-1][k].first;\n                    int skc = stones[i-1][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m <= M; ++m) {\n                        dp[prev][k][m] = min(dp[prev][k][m], dp[pp][j][m]+cost);\n                    }\n                }\n\n                //pp to curr\n                for(int k = 0; k < stones[i].size(); ++k) {\n                    int skx = stones[i][k].first;\n                    int skc = stones[i][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m < M; ++m) {\n                        dp[curr][k][m] = min(dp[curr][k][m], dp[pp][j][m+1]+cost);\n                    }\n                }\n            }\n            for(int j = 0; j < stones[i-1].size(); ++j) {\n                //prev to curr\n                int sx = stones[i-1][j].first;\n                int sc = stones[i-1][j].second;\n                for(int k = 0; k < stones[i].size(); ++k) {\n                    int skx = stones[i][k].first;\n                    int skc = stones[i][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m <= M; ++m) {\n                        dp[curr][k][m] = min(dp[curr][k][m], dp[prev][k][m]+cost);\n                    }\n                }\n            }\n        }\n        int ans = INT_MAX;\n        int curr = (N-1) % 3;\n        int prev = (N-2) % 3;\n\n        for(int m = 0; m <= M; ++m) {\n            for(int k = 0; k < stones[N-1].size(); ++k) {\n                ans = min(ans, dp[curr][k][m]);\n            }\n            if(m > 0) {\n                for(int k = 0; k < stones[N-2].size(); ++k) {\n                    ans = min(ans, dp[prev][k][m]);\n                }\n            }\n        }\n        if(N == 2) ans = 0;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    int k[150],xp[150][10],d[150][10];\n    for(int i=0;i<n;i++){\n      cin>>k[i];\n      for(int j=0;j<k[i];j++){\n    cin>>xp[i][j]>>d[i][j];\n      }\n    }\n    int c[150][150][10]={{}};\n    fill(c[0][0],c[150][0],1<<29);\n    fill(c[0][m],c[0][m+1],0);\n    if(m>0){\n      fill(c[1][m-1],c[1][m],0);\n    }\n    int ans=1<<30;\n    for(int y=0;y<n;y++){\n      for(int j=0;j<=m;j++){\n    for(int x=0;x<k[y];x++){\n      for(int dj=0;dj<=!!j#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) REP(i,0,n)\n#define f first\n#define s second\n#define mpi(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\n#define pi pair<pair<int,int>,pair<int,int> >\nusing namespace std;\nint in(){int x; scanf(\"%d\",&x); return x;}\npriority_queue<pi,vector<pi >,greater<pi > >Q;//cost,y,x,slip\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      vector<vector<int> > pos(151);\n      vector<vector<int> > cos(151);\n      int flag[151][11][76] = {0};\n      while(Q.size()) Q.pop();\n      rep(i,n){\n         int x; scanf(\"%d\",&x);\n         rep(j,x){\n            int _d;\n            scanf(\"%d\",&_d);\n            pos[i].push_back(_d);\n            scanf(\"%d\",&_d);\n            cos[i].push_back(_d);\n         }\n      }\n\n      rep(i,pos[0].size()){\n         Q.push(mpi(0,0,i,0));\n      }\n      rep(i,pos[1].size()){\n         if(m != 0){\n            Q.push(mpi(0,1,i,1));\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         pi p = Q.top(); Q.pop();\n         if(p.f.s == n-1){ans = p.f.f; break;}\n         if(p.f.s == n-2 && m > p.s.s){ans = p.f.f; break;}\n\n         if(flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] == 1) continue;\n         flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] = 1;\n\n         rep(i,pos[p.f.s+1].size()){\n            Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+1][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+1][i]),p.f.s+1,i,p.s.s));\n         }\n\n         rep(i,pos[p.f.s+2].size()){\n            if(p.s.s < m) Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+2][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+2][i]),p.f.s+2,i,p.s.s+1));\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}\n;dj++){\n        if(y+1+dj<n){\n          for(int nx=0;nx<k[y+1+dj];nx++){\n        c[y+1+dj][j-dj][nx]=min(c[y+1+dj][j-dj][nx],c[y][j][x]+(d[y][x]+d[y+dj+1][nx])*abs(xp[y][x]-xp[y+1+dj][nx]));\n          }\n        }else{\n          ans=min(ans,c[y][j][x]);\n        }\n      }\n    }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define INF(a) memset(a,1000000000,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][11];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i].pb(xx);\n    d[i].pb(dd);\n   }\n  }\n  INF(dp);\n  FOR(i,m+1) dp[n-1][i]=0;\n  for(int i=n-2;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(i!=n-2&&j){\n      FOR(l,x[i+2].size()){\n       dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+((d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l])));\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+((d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l])));\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[0].size()) mi=min(mi,dp[i][m][x[0][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nint flag[152][12][78] = {{{0}}};\nusing namespace std;\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n\n      int slip[152][12] = {{0}};\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n      memset(flag,0,sizeof(flag));\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         if(flag[p.f.s][p.s.f][p.s.s] == 1) continue;\n         flag[p.f.s][p.s.f][p.s.s] =1;\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint k[256];\nint x[256][16], d[256][16];\nint memo[256][16][128];\nint n, m;\n\nint getMin(int nowY, int idx, int left)\n{\n\tif (nowY == n) return (0);\n\tif (~nowY && memo[nowY][idx][left] >= 0) return (memo[nowY][idx][left]);\n\t\n\tint res = INT_MAX;\n\t\n\tfor (int i = 0; i < k[nowY + 1]; i++){\n\t\tint bad = (nowY == -1 || nowY == n - 1 ? 0 : (d[nowY][idx] + d[nowY + 1][i]) * abs(x[nowY][idx] - x[nowY + 1][i]));\n\t\tres = min(res, getMin(nowY + 1, i, left) + bad);\n\t}\n\t\n\tif (left && nowY + 2 <= n){\n\t\tfor (int i = 0; i < k[nowY + 2]; i++){\n\t\t\tint bad = (nowY == -1 || nowY == n - 2 ? 0 : (d[nowY][idx] + d[nowY + 2][i]) * abs(x[nowY][idx] - x[nowY + 2][i]));\n\t\t\tres = min(res, getMin(nowY + 2, i, left - 1) + bad);\n\t\t}\n\t}\n\t\n\tif (~nowY) memo[nowY][idx][left] = res;\n\treturn (res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m) && n){\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", k + i);\n\t\t\tfor (int j = 0; j < k[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\tk[n] = 1;\n\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\t\n\t\tprintf(\"%d\\n\", getMin(-1, 0, m));\n\t\t\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][1010];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  fill(dp[0][0],dp[n-1][0],1000000000);\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][x[n][j]]=0;\n  for(int i=n-1;i>0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][x[i][k]]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        if(dp[i+2][j-1][x[i+2][l]]>=1000000000) continue;\n        dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      if(dp[i+1][j][x[i+1][l]]>=1000000000) continue;\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][x[1][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll n,m;\nvector<ll>  x[200],d[200];\n\nll get_cost(int a,int b,int c, int d_){\n    if(a == 0) return 0;\n    if(c == n+1) return 0;\n    return (d[a][b]+d[c][d_])*abs(x[a][b]-x[c][d_]);\n}\n\nll dp[200][200][10];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n    cin >> n >> m;\n    if(n == 0) break;\n    \n    for(int i = 0;i < 200;i++){\n        x[i] = vector<ll>(0);        d[i] = vector<ll>(0);\n\n    }\n\n    x[0].push_back(0);\n    x[n+1].push_back(0);\n\n    for (int i = 1;i <= n;i++){\n        ll k; cin >> k;\n        for (int j = 0;j < k;j++){\n            ll x_,d_; cin >> x_ >> d_;\n            x[i].push_back(x_);\n            d[i].push_back(d_);\n        }\n    }\n\n    for (int i = 0;i < 200;i++){\n        for (int j = 0;j < 200;j++){\n            for (int k = 0;k < 10;k++){\n                dp[i][j][k] = LLONG_MAX;\n            }\n        }\n    }\n\n    dp[0][m][0] = 0;\n\n    for (int i = 0;i <= n;i++){\n        for (int j = 0;j <= m;j++){\n            for (int k = 0;k < x[i].size();k++){\n                if(dp[i][j][k] == LLONG_MAX) continue;\n                //cout << i << \" \" << j << \" \" << k << endl;\n                if(i != n && j != 0){\n                    for (int l = 0;l < x[i+2].size();l++){\n                        dp[i+2][j-1][l] = min(dp[i+2][j-1][l],dp[i][j][k]+get_cost(i,k,i+2,l));\n                    }\n                }\n                for (int l = 0;l < x[i+1].size();l++){\n                    dp[i+1][j][l] = min(dp[i+1][j][l],dp[i][j][k]+get_cost(i,k,i+1,l));\n                }\n            }\n        }\n    }\n\n    ll ans = LLONG_MAX;\n    for (int i = 0;i <= m;i++){\n        ans = min(dp[n+1][i][0],ans);\n    }\n\n    cout << ans << endl;\n    }\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n      for(int j=0;j<80;j++){\n\tdp[0][i][j]=dp[1][i][j]=0;\n\tif(j<m)dp[2][i][j]=0;\n      }    \n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(0<l && l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint n,m;\nint a,b;\nint fie[210][4];\t// 行、マス\nint dp[210][210][4];// x回目１こ飛ばし、行、マス\n\nvoid calc(int u)\n{\n\tu *= 2;\n\tu++;\n\tfor(int i = u-1; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\t\t// 現在の立ち位置\n\t\t\tfor(int k = 0; k < 4; k++){\t// 次の場所\n\t\t\t\tfor(int add = 0; add <= 1; add++){\n\t\t\t\t\tif(add+(u/2) > m)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(fie[i][j] >= 0 && fie[i+1+add][k] >= 0){\n\t\t\t\t\t\tint nowRisk = (fie[i][j] + fie[i+1+add][k])*abs(j-k)+dp[u/2][i][j];\n\t\t\t\t\t\tif(dp[u/2][i][j] == -1)\n\t\t\t\t\t\t\tnowRisk += 1;\n\n//\t\t\t\t\t\tcout << nowRisk << endl ;\n\t\t\t\t\t\tif(dp[u/2+add][i+1+add][k] >= 0)\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = min(dp[u/2+add][i+1+add][k], nowRisk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = nowRisk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid solve()\n{\n\tint ans = (1 << 25);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tcin >> fie[i][b];\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i <= m; i++){\n\t\tcalc(i);\n\t\t\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif(dp[i][n+1][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+1][j]);\n\t\t\tif(dp[i][n+2][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+2][j]);\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcout << dp[0][i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tcout << ans << endl;\n\n\n\t\n}\n\nint main(void)\n{\n\n\twhile(cin >> n >> m, n | m){\n\t\tfill(fie[1], fie[1]+(200-1)*4, -1);\n\t\tfill(dp[0][0], dp[0][0] + 200*200*4, -1);\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfie[n+1][i] = 0;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nll dp[152][1001][77],ma[151][1001];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi,mx;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=1000;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tmx=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t\tmx=max(mx,x);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=mx;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=mx;l++){\n\t\t\t\t\t\t\tif(i+1==n+1) dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\telse if(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n+1&&k>0){\n\t\t\t\t\t\t\t\tif(i+2==n+1) dp[i+2][l][k]=min(dp[i+2][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\t\telse if(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=mx;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n+1][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  /*\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\t\t       \n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m;\nll dp[155][80][1010],INF=1000000000000000LL;\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  FOR(i,155) FOR(j,80) FOR(k,1010) dp[i][j][k]=INF;\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][x[n][j]]=0LL;\n  for(int i=n-1;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][x[i][k]]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  ll mi=INF;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][x[1][i]]);\n  if(m) FOR(i,x[2].size()) mi=min(mi,dp[2][m-1][x[2][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1000;\nconst int INF = 1e9;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<vector<int>> xs(n), ds(n);\n\t\tvector<vector<vector<int>>> dp(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d; x--;\n\t\t\t\txs[i].push_back(x);\n\t\t\t\tds[i].push_back(d);\n\t\t\t\tdp[i].push_back(vector<int>(m + 1, INF));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < (int)xs[0].size(); i++) {\n\t\t\tdp[0][i][0] = 0;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < (int)xs[i - 1].size(); j++) {\n\t\t\t\tfor (int k = 0; k < (int)xs[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l <= m; l++) {\n\t\t\t\t\t\tdp[i][k][l] = min(dp[i][k][l], dp[i - 1][j][l] + abs(xs[i][k] - xs[i - 1][j]) * (ds[i][k] + ds[i - 1][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 1) continue;\n\t\t\tfor (int j = 0; j < (int)xs[i - 2].size(); j++) {\n\t\t\t\tfor (int k = 0; k < (int)xs[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\t\tdp[i][k][l + 1] = min(dp[i][k][l + 1], dp[i - 2][j][l] + abs(xs[i][k] - xs[i - 2][j]) * (ds[i][k] + ds[i - 2][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (auto last : dp[n - 1]) {\n\t\t\tfor (auto val : last) {\n\t\t\t\tres = min(res, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n \nusing namespace std;\n \ntypedef pair<int,int> P;\n \nint main(void){\n \n  int n,m,k,a,b;\n \n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n     \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n    cin >> a >> b;\n    v[i].push_back(make_pair(a,b));\n      }\n    }\n \n    int dp[MAX_N][11][80];\n \n    for(int i=0;i<MAX_N;i++)\n      \tfor(int j=0;j<11;j++)\n  \t\t\tfor(int k=0;k<80;k++)\n      \t\t\tdp[i][j][k]=INF;\n \n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n    \tdp[0][i][j]=dp[1][i][j]=0;\n \n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n    \tfor(int l=m;l>=0;l--){\n      \t\tfor(int k=0;k<v[i-1].size();k++)\n        \tdp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n      \t\t\n      \t\tif(l<m){\n        \t\tif(i==2)dp[i][j][l]=0;\n        \t\tfor(int p=0;p<v[i-2].size();p++)\n          \t\t\tdp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n      \t\t}\n    \t}\n      }\n    }\n     \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>0)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n \n    cout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint d[100][151][1001];\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0) break;\n\tvector< vector< pair<int,int> > > coor(n);\n\tqueue< pair<int,int> > qxy;\n\tqueue<int> qm;\n\tqueue<int> qs;\n\tmemset(d,-1,sizeof(d));\n\tint ans = 100000000;\n\tREP(i,n){\n\t    int k;\n\t    cin >> k;\n\t    REP(j,k){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcoor[i].PB( pair<int,int>(a,b));\n\t\tif(i==0){\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m);\n\t\t    qs.push(b);\n\t\t    d[m][i][a] = 0;\n\t\t}\n\t    }\n\t}\n\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int tm = qm.front();\n\t    int ts = qs.front();\n\t    qxy.pop();\n\t    qm.pop();\n\t    qs.pop();\n//\t    printf(\"d[tm][y][x] = %d\\n\",d[tm][y][x]);\n\t    if(y+1 >= n || (tm > 0 && y+2 >= n)){\n\t\tans = min(ans,d[tm][y][x]);\n\t\tcontinue;\n\t    }\n\t    REP(i,coor[y+1].size()){\n\t\tint nx = coor[y+1][i].first;\n\t\tint ny = y+1;\n\t\tint slip = coor[y+1][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(d[tm][ny][nx] < 0 || d[tm][ny][nx] > v){\n\t\t    d[tm][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t    REP(i,coor[y+2].size()){\n\t\tint nx = coor[y+2][i].first;\n\t\tint ny = y+2;\n\t\tint slip = coor[y+2][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(tm>0 && (d[tm-1][ny][nx] < 0 || d[tm-1][ny][nx] > v )){\n\t\t    d[tm-1][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm-1);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i__=0;__i__<n;__i__++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\nusing namespace std;\n\nlong COST_LIMIT = 1000 * 1000 * 150;\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n, m; cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    m++;\n\n    // alloc cost table\n    long **cost_table[3];\n    loop(3, i) {\n      cost_table[i] = new long*[10];\n      loop(10, j) {\n        cost_table[i][j] = new long[m];\n      }\n    }\n    int slip[3][10], slip_i[3][10];\n\n    // operation per row\n    loop(n, row_i) {\n      int prev = (row_i - 1) % 3, crr = row_i % 3, next = (row_i + 1) % 3;\n\n      // init arrays\n      loop(10, i) {\n        loop(m, j) cost_table[next][i][j] = -1;\n        slip[next][i] = -1;\n        slip_i[next][i] = -1;\n      }\n\n      // input\n      {\n        int count; cin >> count;\n        loop(count, i) {\n          int index, slipness; cin >> index >> slipness;\n          slip[next][i] = slipness;\n          slip_i[next][i] = index;\n          loop(m, j) cost_table[next][i][j] = 0;\n        }\n      }\n\n      // normal jump\n      if (row_i < 1) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop(m, m_i) {\n          long min_cost = 1000000;\n          int min_col = 0;\n          loop(10, c_col_i) {\n            if (slip_i[crr][c_col_i] == -1) break;\n            int cost = (slip_i[crr][c_col_i] - slip_i[next][n_col_i]) * \n              (slip[crr][c_col_i] + slip[next][n_col_i]);\n            if (cost < 0) cost = -cost;\n\n            if (min_cost > cost) {\n              min_cost = cost;\n              min_col = c_col_i;\n            }\n          }\n          int crr_cost = cost_table[crr][min_col][m_i];\n          if (crr_cost != -1) min_cost += crr_cost;\n          cost_table[next][n_col_i][m_i] = min_cost;\n        }\n      }\n\n      // big jump\n      if (row_i < 2) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop_from_to(1, m - 1, m_i) {\n          long min_cost = 1000000;\n          int min_col = 0;\n          loop(10, p_col_i) {\n            if (slip_i[prev][p_col_i] == -1) break;\n            int cost = (slip_i[prev][p_col_i] - slip_i[next][n_col_i]) * \n              (slip[prev][p_col_i] + slip[next][n_col_i]);\n            if (cost < 0) cost = -cost;\n\n            if (min_cost > cost) {\n              min_cost = cost;\n              min_col = p_col_i;\n            }\n          }\n          int prev_cost = cost_table[prev][min_col][m_i];\n          if (prev_cost != -1) min_cost += prev_cost;\n          assign_if_smaller(cost_table[next][n_col_i][m_i], min_cost);\n        }\n      }\n\n    }\n\n    long min_cost = COST_LIMIT;\n    loop(10, i) {\n      loop(m, j) {\n        int cost = cost_table[n % 3][i][j];\n        if (cost == -1) continue;\n        assign_if_smaller(min_cost, cost);\n      }\n    }\n\n    cout << min_cost << endl;\n\n    // free cost table\n    loop(3, i) {\n      loop(10, j) delete cost_table[i][j];\n      delete cost_table[i];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint dp[200][1001][80];\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tmemset(dp,0x3f,sizeof(dp));\n\t\tvector<P>E[200];\n\t\trep(i,n){\n\t\t\tint k;scanf(\"%d\",&k);\n\t\t\trep(t,k){\n\t\t\t\tint x,d;scanf(\"%d%d\",&x,&d);\n\t\t\t\tE[i].push_back(P(d,--x));\n\t\t\t}\n\t\t}\n\t\tfor(P i:E[0])dp[0][i.second][0]=0;\n\t\tfor(P i:E[1])dp[0][i.second][1]=0;\n\t\trep(i,n-1){\n\t\t\tfor(P j:E[i]){\n\t\t\t\tfor(int t=0;t<=m;t++){\n\t\t\t\t\tif(dp[i][j.second][t]==INF)continue;\n\t\t\t\t\tfor(P k:E[i+1])dp[i+1][k.second][t]=\n\t\t\t\t\tmin(dp[i+1][k.second][t],dp[i][j.second][t]+(j.first+k.first)*abs(j.second-k.second));\n\t\t\t\t\tif(i<n-2){\n\t\t\t\t\t\tfor(P k:E[i+2])dp[i+2][k.second][t+1]=\n\t\t\t\t\t\tmin(dp[i+2][k.second][t+1],dp[i][j.second][t]+(j.first+k.first)*abs(j.second-k.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min=INF;\n\t\tfor(P i:E[n-1]){\n\t\t\tfor(int j=0;j<=m;j++)Min=min(Min,dp[n-1][i.second][j]);\n\t\t}\n\t\tfor(P i:E[n-2]){\n\t\t\tfor(int j=0;j<m;j++)Min=min(Min,dp[n-2][i.second][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nll dp[155][10][80];\nint main(void){\n\tint n, m;\n\twhile(cin >> n >> m && (n || m)){\n\tvector<pair<ll, ll> > s[151];\n\tREP(i, 155){\n\t\tREP(j, 10){\n\t\t\tfill(dp[i][j], dp[i][j]+80, INF_LL);\n\t\t}\n\t}\n\tREP(i, n){\n\t\tint k;\n\t\tcin >> k;\n\t\tREP(j, k){\n\t\t\tint x, d;\n\t\t\tcin >> x >> d;\n\t\t\ts[i].push_back({x, d});\n\t\t}\n\t}\n\tREP(i, s[0].size()){\n\t\tdp[0][i][0] = 0;\n\t}\n\tREP(i, s[1].size()){\n\t\tdp[1][i][1] = 0;\n\t}\n\tREP(i, n-1){\n\t\tREP(j, s[i].size()){\n\t\t\tREP(k, m+1){\n\t\t\t\tREP(t, s[i+1].size()){\n\t\t\t\t\tdp[i+1][t][k] = min(dp[i+1][t][k], dp[i][j][k] + (s[i][j].snd+s[i+1][t].snd)*abs(s[i][j].fst-s[i+1][t].fst));\n\t\t\t\t}\n\t\t\t\tif(i < n-2){\n\t\t\t\t\tREP(t, s[i+2].size()){\n\t\t\t\t\t\tdp[i+2][t][k+1] = min(dp[i+2][t][k+1], dp[i][j][k] + (s[i][j].snd+s[i+2][t].snd)*abs(s[i][j].fst-s[i+2][t].fst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res = INF_LL;\n\tREP(j, s[n-1].size()){\n\t\tREP(k, m+1){\n\t\t\tres = min(dp[n-1][j][k], res);\n\t\t}\n\t}\n\tREP(j, s[n-2].size()){\n\t\tREP(k, m){\n\t\t\tres = min(dp[n-2][j][k], res);\n\t\t}\n\t}\n\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nconst int inf = 3e17;\n\nsigned main()\n{\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        int dp[155][15][100];\n        int stone[155][15];\n\n        rep(i, n+5) rep(j, 15) stone[i][j] = inf;\n        rep(i, n+5) rep(j, 15) rep(k, 100) dp[i][j][k] = inf;\n\n        rep(i, n) {\n            int k; cin >> k;\n            rep(j, k) {\n                int x, d; cin >> x >> d;\n                --x;\n                stone[i][x] = d;\n                if (i == 0) dp[0][x][0] = 0;\n                if (i == 1) dp[1][x][1] = 0;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 11; ++j) {\n                if (stone[i][j] == inf) continue;\n\n                for (int k = 0; k <= m; ++k) {\n                    if (k < m) {\n                        rep(l, 11) {\n                            if (stone[i + 2][l] == inf) continue;\n\n                            dp[i + 2][l][k + 1] = min(\n                                    dp[i + 2][l][k + 1],\n                                    dp[i][j][k] + (stone[i][j] + stone[i + 2][l]) * abs(j-l)\n                                    );\n                        }\n                    }\n\n                    rep(l, 11) {\n                        if (stone[i + 1][l] == inf) continue;\n\n                        dp[i + 1][l][k] = min(\n                                dp[i + 1][l][k],\n                                dp[i][j][k] + (stone[i][j] + stone[i + 1][l]) * abs(j-l)\n                                );\n                    }\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j < m + 1; ++j) {\n                mi = min(mi, dp[n - 1][i][j]);\n            }\n        }\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mi = min(mi, dp[n - 2][i][j]);\n            }\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nll dp[151][1001][77],ma[151][1001];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi,mx;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=1000;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tmx=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t\tmx=max(mx,x);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tfor(j=1;j<=mx;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=mx;l++){\n\t\t\t\t\t\t\tif(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n&&k>0){\n\t\t\t\t\t\t\t\tif(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=mx;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<vector>\n#import<cstdlib>\nusing namespace std;main(){int n,m,k,x,d,h,i,j,D[158][151][10];for(;cin>>n>>m,n;cout<<x<<endl){vector<pair<int,int> >S[151];for(i=0;i++<n;)for(cin>>k;k--;S[i].push_back(make_pair(x,d)))cin>>x>>d;fill(**D,*D[158],x=1e9);for(i=S[1].size();i--;)D[m][1][i]=0;for(i=S[2].size();i--;)D[m-1][2][i]=0;for(h=1;h++<n;)for(i=m;~i;i--)for(j=S[h].size();j--;){for(k=S[h-1].size();k--;)D[i][h][j]=min(D[i][h][j],D[i][h-1][k]+(S[h][j].second+S[h-1][k].second)*abs(S[h][j].first-S[h-1][k].first));for(k=S[h-2].size();k--;)D[i][h][j]=min(D[i][h][j],D[i+1][h-2][k]+(S[h][j].second+S[h-2][k].second)*abs(S[h][j].first-S[h-2][k].first));}for(i=m;~i;i--)for(j=S[n].size();j--;)x=min(x,D[i][n][j]);for(i=m;i;i--)for(j=S[n-1].size();j--;)x=min(x,D[i][n-1][j]);}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<24)\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[151][1000][78];\nint solve(int h,int idx,int k){\n  if(h == n-1 || (h == n-2 && k != 0)) return 0;\n  if(dp[h][idx][k] != -1) return dp[h][idx][k];\n  int ret = INF;\n  int s = stone[h][idx].second;\n  int w = stone[h][idx].first;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    ret = min(ret,solve(h+1,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      ret = min(ret,solve(h+2,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][idx][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,i,k));\n    }\n    if(k != 0){\n      for(int i=0;i<stone[1].size();i++){\n\tans = min(ans,solve(1,i,k-1));\n      }\n    }\n    cout << ans << endl;\n    for(int i=0;i<n;i++){\n      stone[i].clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\nstruct edge\n{\n\tint to, cost;\n\tedge(){};\n\tedge(int to, int cost) : to(to), cost(cost){};\n};\n\nint dist[200][200][200];\nvector<vi> x(200);\nvector<vi> d(200);\n\nint main(){\n\twhile(1){\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tif(n == 0 && m == 0) break;\n\t\tx.clear(); d.clear();\n\t\tx.resize(n); d.resize(n);\n\t\trep(i, n){\n\t\t\tint k = in.nextInt();\n\t\t\trep(j, k){\n\t\t\t\tint tx = in.nextInt(), td = in.nextInt();\n\t\t\t\tx[i].pb(tx);\n\t\t\t\td[i].pb(td);\n\t\t\t}\n\t\t}\n\t\tvector<edge> g[200][200], g2[200][200];\n\t\trep(i, n-1){\n\t\t\trep(j, x[i].size()){\n\t\t\t\trep(k, x[i+1].size()){\n\t\t\t\t\tint c = (d[i][j] + d[i+1][k]) * abs(x[i][j]- x[i+1][k]);\n\t\t\t\t\tg[i][j].pb({k, c});\n\t\t\t\t}\n\t\t\t\tif( i + 2 < n);\n\t\t\t\telse continue;\n\t\t\t\trep(k, x[i+2].size()){\n\t\t\t\t\tint c = (d[i][j] + d[i+2][k]) * abs(x[i][j]- x[i+2][k]);\n\t\t\t\t\tg2[i][j].pb({k, c});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 200) rep(j, 200) rep(k, 200) dist[i][j][k] = i == 0 ? 0 : INF;\n\t\tauto dijkstra = [&]{\n\t\t\tpriority_queue<pair<pii, pii>, vector<pair<pii, pii> >, greater<pair<pii, pii> > > q;\n\t\t\tfor(int  i = 0; i < x[0].size(); i++) q.push(mp(mp(0, 0), mp(0, i)));\n\t\t\tpair<pii, pii> p;\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top();\tq.pop();\n\t\t\t\tint cost = p.fi.fi, jump = p.fi.se, from1 = p.se.fi, from2 = p.se.se;\n\t\t\t\tfor(int i = 0; i < g[from1][from2].size(); i++){\n\t\t\t\t\tint to1 = from1 + 1, to2 =g[from1][from2][i].to, c = g[from1][from2][i].cost;\n\t\t\t\t\tif(dist[to1][to2][jump] <= cost + c) continue;\n\t\t\t\t\tdist[to1][to2][jump] = cost + c;\n\t\t\t\t\tq.push(mp(mp(cost + c, jump), mp(to1, to2)));\n\t\t\t\t}\n\t\t\t\tif(jump > m) continue;\n\t\t\t\tfor(int i = 0; i < g2[from1][from2].size(); i++){\n\t\t\t\t\tint to1 = from1 + 2, to2 =g2[from1][from2][i].to, c = g2[from1][from2][i].cost;\n\t\t\t\t\tif(dist[to1][to2][jump + 1] <= cost + c) continue;\n\t\t\t\t\tdist[to1][to2][jump + 1] = cost + c;\n\t\t\t\t\tq.push(mp(mp(cost + c, jump + 1), mp(to1, to2)));\n\t\t\t\t}\t\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\tint ans = INF;\n\t\tfor(int i = 0; i  < x[n-1].size(); i++){\n\t\t\tfor(int j = 0; j <= m; j++) ans = min(ans, dist[n-1][i][j]);\n\t\t}\n\t\tfor(int i = 0; i  < x[n-2].size(); i++){\n\t\t\tfor(int j = 0; j < m; j++) ans = min(ans, dist[n-2][i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll n,m;\nvector<P> rocks[150];\nll k;\nll dp[150][10][77];//dp[i][j][k] rock[i][j]?????????k???????????£??????\nconst ll INF=0xffffffffffff;\nint main()\n{while(1){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(!n) return 0;\n\trep(i,150) rocks[i].clear();\n\tfill(dp[0][0],dp[149][10],INF);\n\trep(i,n){\n\t\tscanf(\"%lld\",&k);\n\t\trep(j,k){\n\t\t\tll x,y;\n\t\t\tscanf(\"%lld%lld\",&x,&y);\n\t\t\tx--;\n\t\t\trocks[i].pb(P(x,y));\n\t\t}\n\t}\n\trep(i,rocks[0].size()){\n\t\tdp[0][i][m]=0;\n\t}\n\trep(i,rocks[1].size()){\n\t\tif(m>1) dp[1][i][m-1]=0;\n\t}\n\trep(i,n-1){\n\t\trep(j,rocks[i].size()){\n\t\t\trep(k,m+1){\n\t\t\t\tif(dp[i][j][k]==INF) continue;\n\t\t\t\t//??????\n\t\t\t\trep(l,rocks[i+1].size()){\n\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+abs(rocks[i][j].fr-rocks[i+1][l].fr)*(rocks[i][j].sc+rocks[i+1][l].sc));\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\tif(k>0&&i<n-2){\n\t\t\t\t\trep(l,rocks[i+2].size()){\n\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],dp[i][j][k]+abs(rocks[i][j].fr-rocks[i+2][l].fr)*(rocks[i][j].sc+rocks[i+2][l].sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\trep(i,rocks[n-1].size()){\n\t\trep(j,m+1){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\trep(i,rocks[n-2].size()){\n\t\trep1(j,m) ans=min(ans,dp[n-2][i][j]);\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint dp[155][15][76]={};\nbool p(P a,P b){\n\tif(a.first<b.first){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(1){\n\t\tvector<P>vec[155];\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(!n) break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint r,u;\n\t\t\t\tscanf(\"%d %d\",&r,&u);\n\t\t\t\tvec[i].pb(mp(r,u));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tsort(vec[i].begin(),vec[i].end(),p);\n\t\t}\n\t\tfor(int i=0;i<=150;i++){\n\t\t\tfor(int j=0;j<15;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint y=vec[1].size();\n\t\tfor(int i=0;i<y;i++){\n\t\t\tdp[1][i][0]=0;\n\t\t}\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tint eee=vec[i].size();\n\t\t\tfor(int j=0;j<eee;j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tint r=vec[i-1].size();\n\t\t\t\t\tfor(int l=0;l<r;l++){\n\t\t\t\t\t\tdp[i][j][k]=min(dp[i-1][l][k]+abs(vec[i][j].first-vec[i-1][l].first)*(vec[i-1][l].second+vec[i][j].second),dp[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=0 && i!=2){\n\t\t\t\t\t\tint rr=vec[i-2].size();\n\t\t\t\t\t\tfor(int l=0;l<rr;l++){\n\t\t\t\t\t\t\tdp[i][j][k]=min(dp[i-2][l][k-1]+abs(vec[i][j].first-vec[i-2][l].first)*(vec[i-2][l].second+vec[i][j].second),dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint rp[10]={};\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tint u=(int)vec[i].size();\n\t\t\t\tfor(int j=0;j<u;j++){\n\t\t\t\t\t\trp[j]=dp[i][j][k];\n\t\t\t\t}\n\t\t\t\tsort(rp,rp+u);\n\t\t\t\tfor(int l=0;l<u;l++){\n\t\t\t\t\tint q;\n\t\t\t\t\tfor(int e=0;e<u;e++){\n\t\t\t\t\t\tif(rp[l]==dp[i][e][k]){q=e;}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int g=0;g<u;g++){\n\t\t\t\t\t\tif(q!=g){\n\t\t\t\t\t\t\tdp[i][g][k]=min(dp[i][g][k],dp[i][q][k]+abs(vec[i][g].first-vec[i][q].first)*(vec[i][g].second+vec[i][q].second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<vec[n].size();i++){\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tres=min(res,dp[n][i][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\tscanf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tif (m != 0) REP(i, stone[1].size()) dp[1][i][m - 1] = 0;\n\t\t\n\t\tREP(i, n - 1) REP(j, stone[i].size()) REP(k, m + 1) {\n\t\t\tpii &from = stone[i][j];\n\t\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2 && k > 0) {\n\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\tpii &to = stone[i + 2][l];\n\t\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\tpii &to = stone[i + 1][l];\n\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tREP(i, n + 1) {\n\t\t\tREP(j, stone[i].size()) {\n\t\t\t\tint pri = INF;\n\t\t\t\tREP(k, m + 1) pri = min(pri, dp[i][j][k]);\n\t\t\t\tprintf(\"%d%c\", pri, j == stone[i].size() - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tif (n > 1) REP(i, stone[n - 2].size()) FOR(j, 1, m + 1) ans = min(ans, dp[n - 2][i][j]);\n\t\tif (ans == INF) ans = 0;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n// 1:20"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nint n,m,a,b,c,minx,Ax,Ad,Bx,Bd;\nint dp[160][1100][90];\nvector<int>x[200];\n\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<200;i++){x[i].clear();}\n\t\tminx=1500000000;\n\t\tcin>>n>>m;\n\t\tif(n==0 && m==0){break;}\n\t\tfor(int i=0;i<=1000;i++){x[0].push_back(i*10000);}\n\t\tfor(int i=0;i<=1000;i++){x[n+1].push_back(i*10000);}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tx[i].push_back(b*10000+c);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,127,sizeof(dp));\n\t\tfor(int i=0;i<=1000;i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tAx=x[i][j]/10000;\n\t\t\t\t\tAd=x[i][j]%10000;\n\t\t\t\t\tif(dp[i][Ax][k]<=1000000000){\n\t\t\t\t\t\tfor(int l=0;l<x[i+1].size();l++){\n\t\t\t\t\t\t\tBx=x[i+1][l]/10000;Bd=x[i+1][l]%10000;\n\t\t\t\t\t\t\tdp[i+1][Bx][k]=min(dp[i+1][Bx][k],dp[i][Ax][k]+(Ad+Bd)*abs(Ax-Bx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int l=0;l<x[i+2].size();l++){\n\t\t\t\t\t\t\tBx=x[i+2][l]/10000;Bd=x[i+2][l]%10000;\n\t\t\t\t\t\t\tdp[i+2][Bx][k+1]=min(dp[i+2][Bx][k+1],dp[i][Ax][k]+(Ad+Bd)*abs(Ax-Bx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=1000;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tminx=min(minx,dp[n+1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//滑りやすさ>=0なら大丈夫.3Dにすると、メモリがたくさんいるので、2つのナップザックを使いまわす。\n#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\n\nint N,M;\nint pos[150][10];\t\t//石のある場所(x座標)\nint list[150][10];\t\t//石の滑りやすさ\nint minest[2][150][10];\t//危険度ナップザック(探索用)\n\nvoid ainst(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid acopy(int *a,int *b,int index){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = b[i];\n\t}\n}\nint amin(int *a,int index){\n\tint min = a[0];\n\tfor(int i = 1;i < index;i++){\n\t\tif(min > a[i])\n\t\t\tmin = a[i];\n\t}\n\treturn min;\n}\nint nap(int n,int mode){\t//mode:0のときは一行飛ばし可能、1のときは不可能\n\tint i,j,l;\n\tint min = 2000000000;\n\tfor(i = 0;i < n-1;i++){\n\t\tfor(j = 0;j < 10;j++){\n\t\t\tif(pos[i][j] == -1)\n\t\t\t\tbreak;\n\t\t\tif(i+2 >= n && mode == 0){\n\t\t\t\tif(min > minest[0][i][j])\n\t\t\t\t\tmin = minest[0][i][j];\n\t\t\t}\n\t\t\tfor(l = 0;l < 10;l++){\n\t\t\t\tswitch(mode){\n\t\t\t\tcase 0:\n\t\t\t\t\tif(i+2 < n && pos[i+2][l] >= 0){\n\t\t\t\t\t\tif(minest[1][i+2][l] == -1 || minest[1][i+2][l] > minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l])){\n\t\t\t\t\t\t\tminest[1][i+2][l] = minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase 1:\n\t\t\t\t\tif(pos[i+1][l] >= 0){\n\t\t\t\t\t\tif(minest[0][i+1][l] == -1 || minest[0][i+1][l] > minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l])){\n\t\t\t\t\t\t\tminest[0][i+1][l] = minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0;i < 10;i++){\n\t\tif(minest[0][n-1][i] != -1 && min > minest[0][n-1][i])\n\t\t\tmin = minest[0][n-1][i];\n\t}\n\treturn min;\n}\nint main(){\n\tint i,j,k;\n\tint mcor,now,saisyo[1000];\n\tint saicor = 0;\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0)\n\t\t\tbreak;\n\t\tsaisyo[saicor] = 2000000000;\n\t\tfor(i = 0;i < N;i++){\n\t\t\tainst(pos[i],10,-1);\n\t\t\tainst(list[i],10,-1);\n\t\t\tainst(minest[0][i],10,-1);\n\t\t\tainst(minest[1][i],10,-1);\n\t\t\tcin >> k;\n\t\t\tfor(j = 0;j < k;j++){\n\t\t\t\tcin >> pos[i][j] >> list[i][j];\n\t\t\t}\n\t\t}\n\t\tainst(minest[0][0],10,0);\n\t\tainst(minest[1][0],10,0);\n\t\t//探索開始\n\t\tfor(mcor = 0;mcor <= M;mcor++){\n\t\t\tif(mcor < M)\n\t\t\t\tnow = nap(N,0);\n\t\t\telse\n\t\t\t\tnow = nap(N,1);\n\t\t\tif(saisyo[saicor] > now)\n\t\t\t\tsaisyo[saicor] = now;\n\t\t\tfor(i = 0;i < N;i++){\n\t\t\t\tacopy(minest[0][i],minest[1][i],10);\n\t\t\t\tainst(minest[1][i],10,-1);\n\t\t\t}\n\t\t\tainst(minest[0][0],10,0);\n\t\t\tainst(minest[1][0],10,0);\n\t\t}\n\t\tsaicor++;\n\t}\n\tfor(i = 0;i < saicor;i++){\n\t\tcout << saisyo[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define f(i, k, j) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX - 10;\n\nvector< vector<P> > field;\n//dp[y][x][残りジャンプ回数]\nvector <vector< vector<int> > > dp;\nint n, m;\n\nvoid solve(){\n    rep(i, field[0].size()) dp[0][i][m] = 0;\n    if(m > 0) rep(i, field[1].size()) dp[1][i][m - 1] = 0;\n\n    for(int i = 1; i < n; i++){\n        int now = i, b = i - 1, bb = i - 2;\n\n        if(i > 1){\n            rep(j, field[i].size()) rep(k, dp[i][j].size()) dp[i][j][k] = INF;\n            //bbからbへ\n            rep(j, field[bb].size()){\n                int nx = field[bb][j].first, nj = field[bb][j].second;\n                rep(k, field[b].size()){\n                    int nnx = field[b][k].first, nnj = field[b][k].second;\n                    int c = (nj + nnj) * abs(nx - nnx);\n                    rep(o, m + 1) dp[b][k][o] = min(dp[b][k][o], dp[bb][j][o] + c);\n                }\n                //bbからnowへ\n                rep(k, field[now].size()){\n                    int nnx = field[now][k].first, nnj = field[now][k].second;\n                    int c = (nj + nnj) * abs(nx - nnx);\n                    rep(o, m) dp[now][k][o] = min(dp[now][k][o], dp[bb][j][o + 1] + c);\n                }\n            }\n\n            //bからnowへ\n            rep(j, field[b].size()){\n                int nx = field[b][j].first, nj = field[b][j].second;\n                rep(k, field[now].size()){\n                    int nnx = field[now][k].first, nnj = field[now][k].second;\n                    int c = (nj + nnj) * abs(nx - nnx);\n                    rep(o, m + 1) dp[now][k][o] = min(dp[now][k][o], dp[b][j][o] + c);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >>n >>m){\n        if(n == 0 && m == 0) break;\n        field.clear(); dp.clear();\n        field = vector< vector<P> >(n);\n        rep(i, n){\n            int tmp; cin >>tmp;\n            //first = 石のx座標, second = すべりやすさ\n            field[i] = vector<P>(tmp);\n            rep(j, tmp){\n                cin >>field[i][j].first >>field[i][j].second;\n                field[i][j].first--;\n            }\n        }\n\n        dp = vector< vector< vector<int> > >(n);\n        rep(i, n){\n            dp[i] = vector< vector<int> >(10);\n            rep(j, 10) dp[i][j] = vector<int>(m + 1, INF);\n        }\n\n        solve();\n        int ans = INF;\n        rep(i, m + 1){\n            rep(j, field[n - 1].size()) ans = min(ans, dp[n - 1][j][i]);\n            if(i > 0) rep(k, field[n - 2].size()) ans = min(ans, dp[n - 2][k][i]);\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150]; //K[i]::=i行目に何個の石があるか\nint X[10][150]; //X[i][j]::=j列目のi個目が何列目か\nint D[10][150]; //D[i][j]::=j列目のi個目のすべりやすさ\nint DP[10][150][80]; //DP[i][j][k]::=j列目のi個目にいて、あとk回ジャンプできる\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][M]=0;\n\t\tfor(int x=0;x<K[1];x++) DP[x][1][M-1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y==1) continue;\n\t\t\tfor(int xx=0;xx<K[y-2];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m+1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-2];x++) for(int m=1;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-2][m]);\n\t\t}\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct to{int l,r;};\nstruct edge{int cost, row; to t; };\n\ntypedef pair<int,int> P;\n\nvector<edge>G[MAX_V];\nint n,m;\n\nvoid solved(void){\n  int dp[101][11][80];\n\n for(int i=0;i<101;i++)\n   for(int j=0;j<=10;j++)\n     for(int k=0;k<80;k++)\n     dp[i][j][k]=INF;\n\n for(int i=0;i<11;i++)\n   dp[0][i][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n      edge e=G[i][j];\n      for(int k=0;k<=m;k++){\n\tif(i+1==e.t.l)dp[e.t.l][e.t.r][k]=min(dp[e.t.l][e.t.r][k],dp[i][e.row][k]+e.cost);\n\tif(i+2==e.t.l && k!=0)dp[e.t.l][e.t.r][m-k]=min(dp[e.t.l][e.t.r][m-k],dp[i][e.row][m-k+1]+e.cost);\n      }\n    }\n  }\n  int ans=INF;    \n  for(int k=0;k<11;k++)\n    for(int j=0;j<=m;j++)\n      ans=min(ans,dp[n+1][k][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0;j<1005;j++)\n      graph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  e.row=j;\n\n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0){\n\t      if(graph[i+1][l]>0){\n\t\te.t.l=i+1;\n\t\te.t.r=l;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      \n\t      if(graph[i+2][l]>0){\n\t\te.t.l=i+2;\n\t\te.t.r=l;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\n\t    if(i>=n){\n\t      if(i+1==n+1){\n\t\te.t.l=i+1;\n\t\te.t.r=l;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      if(i+2==n+1){\n\t\te.t.l=i+2;\n\t\te.t.r=l;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.t.l=i+1;\n\t      e.t.r=l;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t      e.t.l=i+2;\n\t      e.t.r=l;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\n\t  }\n\t  if(i==0)break;\n\t}\n      }\n    }\n    \n    solved();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint dp[200][1010][100];\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n,vi(1010));\n\t\trep(i,n){\n\t\t\tint k;cin>>k;\n\t\t\twhile(k--){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\ta--;\n\t\t\t\tin[i][a]=b;\n\t\t\t}\n\t\t}\n\t\trep(i,200)rep(j,1010)rep(k,100)dp[i][j][k]=inf;\n\t\trep(i,1010)if(in[0][i])dp[0][i][0]=0;\n\t\trep(i,1010)if(in[1][i])dp[1][i][1]=0;\n\t\tloop(i,1,n)rep(j,1010)rep(k,m+1)if(in[i][j]){\n\t\t\trep(l,1010)if(in[i-1][l])dp[i][j][k]=min(dp[i][j][k],\n\t\t\t\tdp[i-1][l][k]+(in[i][j]+in[i-1][l])*(abs(l-j)));\n\t\t\tif(k&&i!=1){\n\t\t\t\trep(l,1010)if(in[i-2][l])dp[i][j][k]=min(dp[i][j][k],\n\t\t\t\t\tdp[i-2][l][k-1]+(in[i][j]+in[i-2][l])*(abs(j-l)));\n\t\t\t}\n\t\t}\n//\t\trep(i,n){rep(j,4)cout<<\" \"<<dp[i][j][1];cout<<endl;}\n\t\tint out=inf;\n\t\trep(i,1010)rep(j,m+1)out=min(out,dp[n-1][i][j]);\n\t\trep(i,1010)rep(j,m)out=min(out,dp[n-2][i][j]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second ==0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0;i<MAX_V;i++)\n    ans=min(d[n-1][i],ans);\n \n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n\n  while(cin >> n >> m,n|m){\n    for(int i=0;i<155;i++)G[i].clear();\n\n    for(int i=0;i<MAX_V;i++)\n      for(int j=0;j<MAX_V;j++)\n\tgraph[i][j]=0;\n\n    for(int i=0;i<n;i++){\n      cin >> k;\n\n      for(int j=0;j<k;j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n\n    edge e;\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<MAX_V;j++){\n\n\tif(graph[i][j]>0){\n\n\t  for(int l=0;l<MAX_V;l++){\n\n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\n\t  }\n\t}\n      }\n    }\n  cout << dijkstra(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//滑りやすさ>=0なら大丈夫.3Dにすると、メモリがたくさんいるので、2つのナップザックを使いまわす。\n#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\n\nint N,M;\nint pos[151][10];\t\t//石のある場所(x座標)\nint list[151][10];\t\t//石の滑りやすさ\nint minest[2][151][10];\t//危険度ナップザック(探索用)\n\nvoid ainst(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}s\n}\nvoid acopy(int *a,int *b,int index){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = b[i];\n\t}\n}\nint amin(int *a,int index){\n\tint min = a[0];\n\tfor(int i = 1;i < index;i++){\n\t\tif(min > a[i])\n\t\t\tmin = a[i];\n\t}\n\treturn min;\n}\nint nap(int n,int mode){\t//mode:0のときは一行飛ばし可能、1のときは不可能\n\tint i,j,l;\n\tint min = 2000000000;\n\tfor(i = 0;i < n-1;i++){\n\t\tfor(j = 0;j < 10;j++){\n\t\t\tif(pos[i][j] == -1)\n\t\t\t\tbreak;\n\t\t\tif(i+2 >= n && mode == 0){\n\t\t\t\tif(min > minest[0][i][j])\n\t\t\t\t\tmin = minest[0][i][j];\n\t\t\t}\n\t\t\tfor(l = 0;l < 10;l++){\n\t\t\t\tswitch(mode){\n\t\t\t\tcase 0:\n\t\t\t\t\tif(i+2 < n && pos[i+2][l] >= 0){\n\t\t\t\t\t\tif(minest[1][i+2][l] == -1 || minest[1][i+2][l] > minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l])){\n\t\t\t\t\t\t\tminest[1][i+2][l] = minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase 1:\n\t\t\t\t\tif(pos[i+1][l] >= 0){\n\t\t\t\t\t\tif(minest[0][i+1][l] == -1 || minest[0][i+1][l] > minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l])){\n\t\t\t\t\t\t\tminest[0][i+1][l] = minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0;i < 10;i++){\n\t\tif(minest[0][n-1][i] != -1 && min > minest[0][n-1][i])\n\t\t\tmin = minest[0][n-1][i];\n\t}\n\treturn min;\n}\nint main(){\n\tint i,j,k;\n\tint mcor,now,saisyo[1000];\n\tint saicor = 0;\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0)\n\t\t\tbreak;\n\t\tsaisyo[saicor] = 2000000000;\n\t\tfor(i = 0;i < N;i++){\n\t\t\tainst(pos[i],10,-1);\n\t\t\tainst(list[i],10,-1);\n\t\t\tainst(minest[0][i],10,-1);\n\t\t\tainst(minest[1][i],10,-1);\n\t\t\tcin >> k;\n\t\t\tfor(j = 0;j < k;j++){\n\t\t\t\tcin >> pos[i][j] >> list[i][j];\n\t\t\t}\n\t\t}\n\t\tainst(minest[0][0],10,0);\n\t\tainst(minest[1][0],10,0);\n\t\t//探索開始\n\t\tfor(mcor = 0;mcor <= M;mcor++){\n\t\t\tif(mcor < M)\n\t\t\t\tnow = nap(N,0);\n\t\t\telse\n\t\t\t\tnow = nap(N,1);\n\t\t\tif(saisyo[saicor] > now)\n\t\t\t\tsaisyo[saicor] = now;\n\t\t\tfor(i = 0;i < N;i++){\n\t\t\t\tacopy(minest[0][i],minest[1][i],10);\n\t\t\t\tainst(minest[1][i],10,-1);\n\t\t\t}\n\t\t\tainst(minest[0][0],10,0);\n\t\t\tainst(minest[1][0],10,0);\n\t\t}\n\t\tsaicor++;\n\t}\n\tfor(i = 0;i < saicor;i++){\n\t\tcout << saisyo[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAX_N = 153;\nconst int MAX_M = MAX_N/2+2;\nconst int MAX_K = 11;\nconst int INF = 1<<29;\n\nint N, M;\nint K[MAX_N];\nint X[MAX_N][MAX_K], D[MAX_N][MAX_K];\nint T[MAX_N][MAX_K][MAX_M];\n\nint calcCost(int si, int sj, int di, int dj) {\n  if(D[si][sj] == -1 || D[di][dj] == -1) return 0;\n  return (D[si][sj] + D[di][dj]) * abs(X[si][sj] - X[di][dj]);\n}\n\nint solve() {\n  fill(T[0][0], T[MAX_N][0], INF);\n  T[0][0][0] = 0;\n\n  for(int i = 1; i < N; ++i) {\n    for(int j = 0; j < K[i]; ++j) {\n      for(int k = 0; k <= 1; ++k) {\n\tfor(int m = 0; m <= M; ++m) {\n\t  int pi = i-1-k;\n\t  int pm = m-k;\n\t  if(pi < 0) continue;\n\t  if(pm < 0) continue;\n\t  for(int pj = 0; pj < K[pi]; ++pj) {\n\t    T[i][j][m] = min(T[i][j][m],\n\t\t\t     T[pi][pj][pm] + calcCost(pi,pj,i,j));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = INF;\n  for(int m = 0; m <= M; ++m) res = min(res, T[N-1][0][m]);\n  return res;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    N += 2;\n    for(int i = 0; i < N; ++i) {\n      if(i == 0 || i+1 == N) {\n\tK[i] = 1;\n\tX[i][0] = D[i][0] = -1;\n      } else {\n\tcin >> K[i];\n\tfor(int j = 0; j < K[i]; ++j) {\n\t  cin >> X[i][j] >> D[i][j];\n\t}\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint dfs(int y, int idx, int m, int cost, vector<vector<pair<int, int> > > &stones, vector<vector<pair<int, int> > > &dp) {\n    int ans = INT_MAX;\n    if(y+1 == stones.size()) return cost;\n\n    for(int i = 0; i < stones[y+1].size(); ++i) {\n        int new_cost = cost + (stones[y][idx].second+stones[y+1][i].second)*abs(stones[y][idx].first-stones[y+1][i].first);\n        if(m <= dp[y+1][i].first && new_cost >= dp[y+1][i].second) continue;\n        dp[y+1][i] = make_pair(m, new_cost);\n        ans = min(ans, dfs(y+1, i, m, new_cost, stones, dp));\n    }\n    if(m > 0 && y+2 < stones.size()) {\n        for(int i = 0; i < stones[y+2].size(); ++i) {\n            int new_cost = cost + (stones[y][idx].second+stones[y+2][i].second)*abs(stones[y][idx].first-stones[y+2][i].first);\n            if(m <= dp[y+2][i].first && new_cost >= dp[y+2][i].second) continue;\n            dp[y+2][i] = make_pair(m-1, new_cost);\n            ans = min(ans, dfs(y+2, i, m, new_cost, stones, dp));\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < stones[i].size(); ++j) {\n                q.push(Tag(i, j, 0, M-i));\n            }\n        }\n\n        vector<vector<pair<int, int> > > dp(N, vector<pair<int, int> >(1000, make_pair(0, INT_MAX)));\n        int ans = INT_MAX;\n        for(int i = 0; i < stones[0].size(); ++i) {\n            ans = min(ans, dfs(0, i, M, 0, stones, dp));\n        }\n        if(M > 0) {\n            for(int i = 0; i < stones[1].size(); ++i) {\n                ans = min(ans, dfs(1, i, M-1, 0, stones, dp));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\nusing ll = long long;\n\nint n,m;\nvector<vector<pair<int,int>>> s; // pos, slip\nint max_x;\n\nconst int inf = 1e9;\nint solve(){\n    vector<vector<int>> d1(m+1, vector<int>(max_x+1, inf));\n    vector<vector<int>> d2(m+1, vector<int>(max_x+1, inf));\n    vector<vector<int>> d3(m+1, vector<int>(max_x+1, inf));\n    rep(i,s[0].size()){\n        d1[0][s[0][i].first] = 0;\n    }\n    rep(i,n){\n        rep(j,m+1){\n            for(auto & from : s[i]){\n                for(auto & to : s[i+1]){\n                    int cost = (from.second + to.second) * abs(from.first - to.first);\n                    d2[j][to.first] = min(d2[j][to.first], d1[j][from.first] + cost);\n                }\n                if(j != m){\n                    for(auto & to : s[i+2]){\n                        int cost = (from.second + to.second) * abs(from.first - to.first);\n                        d3[j+1][to.first] = min(d3[j+1][to.first], d1[j][from.first] + cost);\n                    }\n                }\n            }\n        }\n\n        // rep(j,m+1){\n        //     rep(k,max_x+1){\n        //         cout << d1[j][k] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n        // rep(j,m+1){\n        //     rep(k,max_x+1){\n        //         cout << d2[j][k] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n        // rep(j,m+1){\n        //     rep(k,max_x+1){\n        //         cout << d3[j][k] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n        // cout << endl;\n        // cout << endl;\n\n        rep(j,m+1){\n            rep(k, max_x){\n                d1[j][k] = d2[j][k];\n                d2[j][k] = d3[j][k];\n                d3[j][k] = inf;\n            }\n        }\n\n    }\n    int res = inf;\n    rep(i,m+1)rep(j,max_x+1){\n        res = min(res, d2[i][j]);\n        res = min(res, d3[i][j]);\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> n >> m && n){\n        max_x = 0;\n        s.assign(n+2, {});\n        rep(i,n){\n            int k;\n            cin >> k;\n            rep(j,k){\n                int a,b;\n                cin >> a >> b;\n                s[i].emplace_back(a,b);\n                max_x = max(max_x, a);\n            }\n        }\n        s[n] = s[n+1] = vector<pair<int,int>>(max_x+1);\n        rep(i,max_x+1){\n            s[n][i] = s[n+1][i] = make_pair(i,0);\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m;\nll dp[155][80][10],INF=1000000000000000LL;\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n&&!m) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  FOR(i,155) FOR(j,80) FOR(k,10) dp[i][j][k]=INF;\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][j]=0LL;\n  for(int i=n-1;i>0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][k]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][k]=min(dp[i][j][k],dp[i+2][j-1][l]+(ll)(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][l]+(ll)(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  ll mi=INF;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][i]);\n  if(m) FOR(i,x[2].size()) mi=min(mi,dp[2][m-1][i]);\n  cout<<mi<<endl;\n  x.clear(); d.clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<int> > stones(N, vector<int>(1000, INT_MAX));\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i][x] = d;\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < 1000; ++j) {\n                if(stones[i][j] != INT_MAX) {\n                    q.push(Tag(i, j, 0, M-i));\n                }\n            }\n        }\n\n        vector<vector<unsigned> > dp(N, vector<unsigned>(1000, UINT_MAX));\n        int ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m <= 0 && i == 2) break;\n                for(int j = 0; j < 1000; ++j) {\n                    unsigned cost = stones[t.y+i][j];\n                    if(cost != INT_MAX) {\n                        cost += stones[t.y][t.x];\n                        cost *= std::abs((int)t.x-j);\n                        cost += t.c;\n                        if(cost >= dp[t.y+i][j]) continue;\n                        dp[t.y+i][j] = cost;\n                        q.push(Tag(t.y+i, j, cost, t.m-i+1));\n             //           cout << '\\t' << t.y+i << ' ' << j << ' ' << cost*abs(t.x-j) << endl;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n\tint n , m;\n\t\n\twhile(cin >> n >> m , n ){\n\t\tint pos[150][10];\n\t\tint rate[150][10];\n\t\tint cnt[150];\n\t\trep(i,n){\t\n\t\t\tint k; cin >> k;\n\t\t\tcnt[i] = k;\n\t\t\trep(j,k){\n\t\t\t\tcin >> pos[i][j] >> rate[i][j];\n\t\t\t}\n\t\t}\n\t\tint dp[150][10][80] = {0};\n\t\trep(i,150)rep(j,10)rep(k,80)dp[i][j][k] = (1<<21);\n\t\trep(j,10)rep(k,80)dp[0][j][k] = 0;\n\t\t\n\t\tfor(int k = m ; k>=0 ; k--){\n\t\t\tfor(int i = 1;i<n;i++){\n\t\t\t\trep(prev,cnt[i-1]){\n\t\t\t\t\trep(cur,cnt[i]){\n\t\t\t\t\t\tdp[i][cur][k] = min(\n\t\t\t\t\t\t\tdp[i][cur][k], \n\t\t\t\t\t\t\tdp[i-1][prev][k] + (rate[i][cur]+rate[i-1][prev]) * abs( pos[i][cur] - pos[i-1][prev] )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k){\n\t\t\t\tfor(int i=2;i<n;i++){\n\t\t\t\t\trep(prev,cnt[i-2]){\n\t\t\t\t\t\trep(cur,cnt[i]){\n\t\t\t\t\t\t\tdp[i][cur][k-1] = min(\n\t\t\t\t\t\t\t\tdp[i][cur][k-1] , \n\t\t\t\t\t\t\t\tdp[i-2][prev][k] + (rate[i][cur]+rate[i-2][prev]) * abs( pos[i][cur] - pos[i-2][prev] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = (1<<21);\n\t\trep(k,m+1){\n\t\t\tif(k)rep(i,cnt[n-2])ret = min(ret,dp[n-2][i][k]);\n\t\t\trep(i,cnt[n-1])ret = min(ret,dp[n-1][i][k]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000000;\n\nint n, m, k[150], x[150][150], d[150][150];\n\nint dp[150][150][100];\n\nint dijkstra() {\n  for (int i = 0; i < n; i++) for (int j = 0; j <= 10; j++) for (int k = 0; k <= m; k++) dp[i][j][k] = INF;\n  for (int i = 0; i < k[0]; i++) dp[0][i][m] = 0;\n  if (m != 0) for (int i = 0; i < k[1]; i++) dp[1][i][m-1] = 0;\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < k[i]; j++) {\n      for (int r = 0; r < k[i - 1]; r++)\n        for (int s = 0; s <= m; s++)\n          dp[i][j][s] = min(dp[i][j][s],\n                            dp[i-1][r][s] + (d[i][j] + d[i-1][r]) * abs(x[i][j] - x[i-1][r]));\n      if (i == 1) continue;\n      for (int r = 0; r < k[i - 2]; r++)\n        for (int s = 0; s < m; s++)\n          dp[i][j][s] = min(dp[i][j][s],\n                            dp[i-2][r][s+1] + (d[i][j] + d[i-2][r]) * abs(x[i][j] - x[i-2][r]));\n    }\n  }\n  int ans = INF;\n  for (int i = 0; i < k[n-1]; i++) for (int j = 0; j <= m; j++) ans = min(ans, dp[n-1][i][j]);\n  for (int i = 0; i < k[n-2]; i++) for (int j = 1; j <= m; j++) ans = min(ans, dp[n-2][i][j]);\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &k[i]);\n      for (int j = 0; j < k[i]; j++) scanf(\"%d%d\", &x[i][j], &d[i][j]), x[i][j]--;\n    }\n    printf(\"%d\\n\", dijkstra());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[150][76][10];\nint main(){\n\twhile(true){\n\tint n,m;\tcin>>n>>m;\n\tif(n==0)\treturn 0;\n\tvector<pair<int,int>> ls[n];\n\tfor(int i=0;i<n;i++){\n\t\tint k;\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\tcin>>x>>d;\n\t\t\tls[i].push_back(make_pair(x,d));\n\t\t}\n\t}\n\tfor(int i=0;i<150;i++){\n\t\tfor(int j=0;j<=75;j++){\n\t\t\tfor(int k=0;k<10;k++)\tdp[i][j][k]=(1<<30);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)ls[0].size();i++)\tdp[0][m][i]=0;\n\tif(m!=0)\tfor(int i=0;i<(int)ls[1].size();i++)\tdp[1][m-1][i]=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<(int)ls[i].size();k++){\n\t\t\t\tif(dp[i][j][k]==(1<<30))\tcontinue;\n\t\t\t\tfor(int l=0;l<(int)ls[i+1].size();l++){\n\t\t\t\t\tdp[i+1][j][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+1][l].first)*(ls[i][k].second+ls[i+1][l].second),dp[i+1][j][l]);\n\t\t\t\t}\n\t\t\t\tif(j!=0&&i+2<n){\n\t\t\t\t\tfor(int l=0;l<(int)ls[i+2].size();l++){\n\t\t\t\t\tdp[i+2][j-1][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+2][l].first)*(ls[i][k].second+ls[i+2][l].second),dp[i+2][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=(1<<30);\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-1].size();j++){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-2].size();j++){\n\t\t\tans=min(ans,dp[n-2][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 1005\n#define N 155\n#define S 85\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[S][N][M];\n\nint dijkstra(int sy,int sx){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<S;i++)\n    for(int j=0;j<N;j++)\n      for(int l=0;l<M;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  for(int i=0;i<node[n-2].size();i++)\n    for(int j=0;j<m;j++)\n      res=min(res,d[j][n-2][node[n-2][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rep(i, n) for(int i = 0; i < (n); i++)\n#define fr first\n#define sc second\n#define pb(a) push_back(a)\n#define INF INT_MAX\nusing namespace std;\n\ntypedef pair<int, int> P;\nvector<P> mp[151];\nint n, m, dp[151][1001][76];\n\nvoid initDp(){\n  Rep(i, 151){\n    Rep(j, 1001){\n      Rep(k, 76){\n\tdp[i][j][k] = INF;\n      }\n    }\n  }\n}\n\nint solve(int row, int cn, int jump){\n  if(row == n-1) return 0;\n  int slv = dp[row][cn][jump];\n  if(slv == INF){\n    int col = mp[row][cn].fr;\n    int stn = mp[row][cn].sc;\n    if(row+2 < n && jump > 0){\n      Rep(i, mp[row+2].size()){\n\tint ncol = mp[row+2][i].fr;\n\tint nstn = mp[row+2][i].sc;\n\tint dng  = (stn + nstn) * abs(col - ncol);\n\tslv = min(slv, solve(row+2, i, jump-1)+dng);\n      }\n    }\n    if(row+1 < n){\n      Rep(i, mp[row+1].size()){\n\tint ncol = mp[row+1][i].fr;\n\tint nstn = mp[row+1][i].sc;\n\tint dng  = (stn + nstn) * abs(col - ncol);\n\tslv = min(slv, solve(row+1, i, jump)+dng);\n      }\n    }\n  }\n  return dp[row][cn][jump] = slv;\n}\n\nint main(){\n  initDp();\n  cin >> n >> m;\n  Rep(i, n){\n    int k; cin >> k;\n    Rep(j, k){\n      int x, d;\n      cin >> x >> d;\n      mp[i].pb(P(x-1, d));\n    }\n  }\n\n  int mn = INF;\n  Rep(i, mp[0].size()){\n    mn = min(mn, solve(0, i, m));\n  }\n  if(m > 0){\n    Rep(i, mp[1].size()){\n      mn = min(mn, solve(1, i, m-1));\n    }\n  }\n \n\n  cout << mn << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\ntypedef pair<LL, LL> P;\ntypedef pair<LL, P> PP;\nint n, m;\nLL dp[150][10][80];\nvector<P>v[150];\nLL ans = LINF;\n\nint main() {\n\twhile (cin >> n >> m && (n || m)) {\n\t\tans = LINF;\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tif (i)for (int j = 0; j < 10; j++)for (int k = 0; k < 80; k++) {\n\t\t\t\tdp[i][j][k] = HINF;\n\t\t\t}\n\t\t\tv[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\tb--;\n\t\t\t\tv[i].eb(mp(b, c));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < v[0].size(); i++)dp[1][i][m - 1] = 0;\n\t\tif (m > 0)for (int i = 0; i < v[1].size(); i++)dp[1][i][m - 1] = 0;\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\tif (i == n - 1 && k > 0)continue;\n\t\t\t\t\tfor (int l = 0; l < v[i + 1].size(); l++) {\n\t\t\t\t\t\tLL cost = (v[i][j].second + v[i + 1][l].second)*abs(v[i][j].first - v[i + 1][l].first);\n\t\t\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t\t\t}\n\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\tfor (int l = 0; l < v[i + 2].size(); l++) {\n\t\t\t\t\t\t\tLL cost = (v[i][j].second + v[i + 2][l].second)*abs(v[i][j].first - v[i + 2][l].first);\n\t\t\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < v[n - 1].size(); i++)for (int j = 0; j <= m; j++)ans = min(ans, dp[n - 1][i][j]);\n\t\tif (m > 0)for (int i = 0; i < v[n - 2].size(); i++)for (int j = 1; j <= m; j++)ans = min(ans, dp[n - 2][i][j]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][1010];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,1000) x[0].pb(i+1);\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  fill(dp[0][0],dp[n-1][0],1000000000);\n  FOR(i,1000) FOR(j,m+1) dp[n][j][i+1]=0;\n  for(int i=n-1;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      FOR(l,x[i+2].size()){\n       dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+(i!=0&&i!=n-1)?(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]):0);\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+(i!=0)?(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]):0);\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[0].size()) mi=min(mi,dp[0][m][x[0][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint n,m;\nint a,b;\nint fie[210][4];\t// 行、マス\nint dp[210][210][4];// x回目１こ飛ばし、行、マス\n\nvoid calc(int u)\n{\n\tu *= 2;\n\tfor(int i = u; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\t\t// 現在の立ち位置\n\t\t\tfor(int k = 0; k < 4; k++){\t// 次の場所\n\t\t\t\tfor(int add = 0; add <= 1; add++){\n\t\t\t\t\tif(add+(u/2) > m)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(fie[i][j] >= 0 && fie[i+1+add][k] >= 0){\n\t\t\t\t\t\tint nowRisk = (fie[i][j] + fie[i+1+add][k])*abs(j-k)+dp[u/2][i][j];\n\t\t\t\t\t\tif(dp[u/2][i][j] == -1)\n\t\t\t\t\t\t\tnowRisk += 1;\n\n//\t\t\t\t\t\tcout << nowRisk << endl ;\n\t\t\t\t\t\tif(dp[u/2+add][i+1+add][k] >= 0)\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = min(dp[u/2+add][i+1+add][k], nowRisk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = nowRisk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid solve()\n{\n\tint ans = (1 << 25);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tcin >> fie[i][b];\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i <= m; i++){\n\t\tcalc(i);\n\t\t\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif(dp[i][n+1][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+1][j]);\n\t\t\tif(dp[i][n+2][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+2][j]);\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcout << dp[0][i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tcout << ans << endl;\n\n\n\t\n}\n\nint main(void)\n{\n\n\twhile(cin >> n >> m, n | m){\n\t\tfill(fie[1], fie[1]+(200-1)*4, -1);\n\t\tfill(dp[0][0], dp[0][0] + 200*200*4, -1);\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfie[n+1][i] = 0;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n#define f first\n#define s second\n#define INF (1<<29)\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\n\nint field[200][5];\nint n, m;\n\nint bfs(){\n  queue<P2> que; // (x, y, m, cost)\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[0][j] != 0) que.push(P2(P(j, 0), P(0, 0)));\n  }\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[1][j] != 0 && m != 0) que.push(P2(P(j, 1), P(1, 0)));\n  }\n  int ans = INF;\n  \n  while(!que.empty()){\n    P2 pos = que.front();\n    //cout << pos.f.f << ' ' << pos.f.s << endl;\n    que.pop();\n    \n    if(pos.f.s == n-2 && pos.s.f < m){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    if(pos.f.s == n-1){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    for(int i = 1 ; i <= 2 ; i++){\n      for(int j = -3 ; j < 3 ; j++){\n\tif(i == 2 && pos.s.f == m) continue;\n\tif(pos.f.s+i > n || pos.f.f+j < 0 || pos.f.f+j > 3) continue;\n\tif(field[pos.f.s + i][pos.f.f + j] != 0){\n\t  if(i == 1){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\t  \t  \n\t  }\n\t  else if(i == 2){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f+1, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\n\t  }\n\t}\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> n >> m){\n    if(n == 0 && m == 0) break;\n    memset(field, 0, sizeof(field));\n    \n    int k, pos, cost;\n    for(int i = 0 ; i < n ; i++){\n      cin >> k;\n      for(int j = 0 ; j < k ; j++){\n\tcin >> pos >> cost;\n\tpos--;\n\tfield[i][pos] = cost;\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ LL to, cost; edge(int t, LL c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\nint bitcount(int a)\n{\n\tint ret = 0;\n\twhile (a != 0) { ret++; a = (a - 1) & a; }\n\treturn ret;\n}\n\nint dp[151][1001][77];\nint stage[151][1001];\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m && n)\n\t{\n\t\trep(i, n) rep(j, 1001) stage[i][j] = INF;\n\t\tint width = 0;\n\t\trep(i, n)\n\t\t{\n\t\t\tint num; cin >> num;\n\t\t\trep(j, num)\n\t\t\t{\n\t\t\t\tint idx, slip; cin >> idx >> slip;\n\t\t\t\twidth = max(width, idx);\n\t\t\t\tstage[i][idx - 1] = slip;\n\t\t\t}\n\t\t}\n\t\trep(i, n + 1) rep(j, width) rep(k, m + 1) dp[i][j][k] = INF;\n\t\trep(i, width) dp[0][i][0] = stage[n][i] = 0;\n\t\tif (m > 0)\n\t\t{\n\t\t\trep(i, width) dp[1][i][1] = 0;\n\t\t}\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, width)\n\t\t\t{\n\t\t\t\trep(k, width)\n\t\t\t\t{\n\t\t\t\t\trep(l, m + 1) if (dp[i][j][l] < INF && stage[i][j] < INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (stage[i][j] + stage[i + 1][k]) * abs(j - k));\n\t\t\t\t\t\tif (i + 2 <= n)\n\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (stage[i][j] + stage[i + 2][k]) * abs(j - k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, width) rep(j, m + 1) ans = min(ans, dp[n][i][j]);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n//番号とx座標と滑りやすさ\nvector<P1>s[155];\n//滑りやすさ、x座標、y座標\nP1 d[1505];\nint n,m;\n//石番号と残り数を状態にもつdijkstra用配列\nint di[1505][76];\n//beatmania iidx楽しい!!の部分文字列ではなくindexの部分文字列\nint idx=0;\nint main()\n{\n\twhile(1)\n\t{\n\tidx=0;\n\tscanf(\"%d %d\",&n,&m);\n\tif(!n) return 0;\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\ts[i].clear();\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\n\t\t\ts[i].pb(mp(idx,mp(a,b)));\n\t\t\td[idx++]=mp(b,mp(a,i));\n\t\t}\n\t}\n\tfor(int i=0;i<1505;i++)for(int j=0;j<76;j++) di[i][j]=1e9;\n\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\tfor(int i=0;i<s[1].size();i++)\n\t{\n\t\tP1 p=s[1][i];\n\t\tdi[p.first][m]=0;\n\t\tque.push(mp(0,mp(p.first,m)));\n\t}\n\tfor(int i=0;m>0 && i<s[2].size();i++)\n\t{\n\t\tP1 p=s[2][i];\n\t\tdi[p.first][m-1]=0;\n\t\tque.push(mp(0,mp(p.first,m-1)));\n\t}\n\twhile(!que.empty())\n\t{\n\t\tP1 p=que.top();\n\t\tque.pop();\n\t\tint idd=p.second.first;\n\t\tint slip1=d[idd].first;\n\t\tint x=d[idd].second.first;\n\t\tint y=d[idd].second.second;\n\t\tint zan=p.second.second;\n\t\t\n\t\tfor(int i=0;i<s[y+1].size();i++)\n\t\t{\n\t\t\tP1 pp=s[y+1][i];\n\t\t\tint slip2=pp.second.second;\n\t\t\tint x2=pp.second.first;\n\t\t\tif(di[pp.first][zan]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[pp.first][zan]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[pp.first][zan],mp(pp.first,zan)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;zan>0 && i<s[y+2].size();i++)\n\t\t{\n\t\t\tP1 pp=s[y+2][i];\n\t\t\tint slip2=pp.second.second;\n\t\t\tint x2=p.second.first;\n\t\t\tif(di[pp.first][zan-1]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[pp.first][zan-1]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[pp.first][zan-1],mp(pp.first,zan-1)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ret=INF;\n\tfor(int j=0;j<s[n].size();j++) for(int i=0;i<76;i++) ret=min(ret,di[s[n][j].first][i]);\n\tfor(int j=0;j<s[n-1].size();j++) for(int i=1;i<76;i++) ret=min(ret,di[s[n-1][j].first][i]);\n\t\n\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define int long long\n#define INF INT_MAX\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>c[150][75];\n\t\tint d;\n\t\tcin >> d;\n\t\tfor (int e = 0; e < d; e++) {\n\t\t\tisi h; h.mincost = 0;\n\t\t\tscanf(\"%lld%lld\", &h.zahyou, &h.suberi);\n\t\t\tc[0][b].push_back(h);\n\t\t}\n\t\tfor (int f = 1; f < a; f++) {\n\t\t\tint g; cin >> g;\n\t\t\tfor (int h = 0; h < g; h++) {\n\t\t\t\tint i, j; scanf(\"%lld%lld\", &i, &j);\n\t\t\t\tfor (int k = b; k >= 0; k--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int l = 0; l < c[f - 1][k].size(); l++) {\n\t\t\t\t\t\tm = min(m, c[f - 1][k][l].mincost + (c[f - 1][k][l].suberi + j)*abs(c[f - 1][k][l].zahyou - i));\n\t\t\t\t\t}\n\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t}\n\t\t\t\t\tif (k != b&&f > 1) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int l = 0; l < c[f - 2][k+1].size(); l++) {\n\t\t\t\t\t\t\tm = min(m, c[f - 2][k+1][l].mincost + (c[f - 2][k+1][l].suberi + j)*abs(c[f - 2][k+1][l].zahyou - i));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int p = 0; p <= b; p++) {\n\t\t\tfor (isi q : c[a - 1][p]) {\n\t\t\t\tS = min(S, q.mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define SQR(a) ((a)*(a))\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pr;\ntypedef pair<pr,ll> ppr;\ntypedef vector<pr> vpr;\nconst int INF=(ll)1<<30;\nll DP[152][152][11];\nint main() {\n\tint n,m,times,tmp;\n\twhile(cin >> n >> m && n){\n\tll block[152][11]={};\n\tll x[152][11]={};\n\tREP(i,152)\n\t\tREP(j,152)\n\t\t\tREP(k,11)\n\t\t\t\tDP[i][j][k]=INF;\n\tREP(i,n){\n\t\tcin >> times;\n\t\tREP(j,times){\n\t\tcin >> x[i][times];\n\t\tcin >> block[i][times];\n\t\t}\n\t}\n\tREP(i,11){\n\tDP[0][0][i]=0;\n\tDP[1][1][i]=0;\n\tblock[n][i]=1;\n\t}\n\tFOR(i,1,n)\n\t\tREP(j,11)\n\t\t\tif(block[i][j])\n\t\t\tREP(l,m+1)\n\t\t\t\tREP(k,11){\n\t\t\t\t\tif(block[i-1][k])\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-1][l][k]+abs(x[i][j]-x[i-1][k])*(block[i-1][k]+block[i][j]));\n\t\t\t\t\tif(block[i-2][k] && l && i!=1)\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-2][l-1][k]+abs(x[i][j]-x[i-2][k])*(block[i-2][k]+block[i][j]));\n\t\t\t\t}\n\tll minium=INF;\n\tREP(i,11)\n\t\tREP(j,m+1)\n\t\t\tminium=min(minium,DP[n-1][j][i]);\n\tif(m)\n\tREP(i,11)\n\t\tREP(j,m)\n\t\t\tminium=min(minium,DP[n-2][j][i]);\n\tcout << minium << endl;\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint k[160];\npair<int,int> stone[160][15];\n\nint memo[100][160][15];\n\nint main(){\n  int n,m;\n  while((n = getInt()) + (m = getInt())){\n    REP(i,n){\n      k[i] = getInt();\n      REP(j,k[i]){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    memset(memo,-1,sizeof(memo));\n\n    typedef pair<int,pair<int,pair<int,int> > > data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    REP(i,k[0])\n      pq.push(mp(0,mp(m,mp(i,0))));\n    if(m != 0)\n      REP(i,k[1])\n        pq.push(mp(0,mp(m-1,mp(i,1))));\n\n    int ans = INT_MAX;\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n\n      int cost = d.f;\n      int jump = d.s.f;\n      int t    = d.s.s.f;\n      int y    = d.s.s.s;\n      int x    = stone[y][t].f;\n\n      if(y == n){\n        ans = min(ans, cost);\n        continue;\n      }\n\n      if(memo[jump][y][t] != -1) continue;\n      memo[jump][y][t] = cost;\n\n      if(y < n-1){\n        int d = stone[y][t].s;\n        REP(i,k[y+1]){\n          if(memo[jump][y+1][i] != -1) continue;\n          int xx = stone[y+1][i].f;\n          int dd = stone[y+1][i].s;\n#define ABS(a) ((a) < 0 ? -(a) : (a))\n          int cc = cost + (dd + d) * ABS(xx - x);\n          pq.push(mp(cc,mp(jump,mp(i,y+1))));\n        }\n      }else{\n        pq.push(mp(cost,mp(jump,mp(0,n))));\n      }\n\n      if(jump > 0){\n        if(y < n-2){\n          int d = stone[y][t].s;\n          REP(i,k[y+1]){\n            if(memo[jump-1][y+2][i] != -1) continue;\n            int xx = stone[y+2][i].f;\n            int dd = stone[y+2][i].s;\n            int cc = cost + (dd + d) * ABS(xx - x);\n            pq.push(mp(cc,mp(jump-1,mp(i,y+2))));\n          }\n        }else{\n          pq.push(mp(cost,mp(jump-1,mp(0,n))));\n        }\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint dp[256][16][128];\nint main(void){\n    int n,m,k,a,b;\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tvector< vector<pii> > s(n,vector<pii>(0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\ts[i].push_back(pii(a,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<128;i++)for(int j=0;j<16;j++)dp[0][j][i]=0;\n\t\tfor(int i=0;i<128;i++)for(int j=0;j<16;j++)for(int l=1;l<256;l++)dp[l][j][i]=9999999;\n\t\tfor(int i=0;i<=m;i++){\n\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\tint l=s[j].size();\n\t\t\t\tint lb=s[j-1].size();\n\t\t\t\tint lc=s[j-2].size();\n\t\t\t\tfor(int w=0;w<l;w++){\n\t\t\t\t\tif(i>0 && j>1){\n\t\t\t\t\t\tfor(int c=0;c<lb;c++){\n\t\t\t\t\t\t\tdp[j][w][i] = min(dp[j][w][i],\n                                (dp[j-1][c][i] + (int)abs(s[j][w].first-s[j-1][c].first)*(s[j][w].second+s[j-1][c].second) ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int c=0;c<lc;c++){\n\t\t\t\t\t\t\tdp[j][w][i] = min(dp[j][w][i],\n\t\t\t\t\t\t\t\t(dp[j-2][c][i] + (int)abs(s[j][w].first-s[j-2][c].first)*(s[j][w].second+s[j-2][c].second) ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t    for(int c=0;c<lb;c++){\n                            dp[j][w][i] = min(dp[j][w][i],\n                                dp[j-1][c][i]+abs(s[j][w].first-s[j-1][c].first)*(s[j][w].second+s[j-1][c].second));\n\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 9999999;\n\t\tfor(int i=0;i<s[n-1].size();i++){\n\t\t    ans=min(ans,dp[n-1][i][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tREP(i, n - 1) REP(j, stone[i].size()) {\n\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2) {\n\t\t\t\tFOR(k, 1, m + 1) {\n\t\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\t\tint cost = (stone[i][j].second + stone[i + 2][l].second) * abs(stone[i][j].first - stone[i + 2][l].first);\n\t\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, m + 1) {\n\t\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\t\tint cost = (stone[i][j].second + stone[i + 1][l].second) * abs(stone[i][j].first - stone[i + 1][l].first);\n\t\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tREP(i, n + 1) {\n\t\t\tREP(j, stone[i].size()) {\n\t\t\t\tint pri = INF;\n\t\t\t\tREP(k, m + 1) pri = min(pri, dp[i][j][k]);\n\t\t\t\tprintf(\"%d%c\", pri, j == stone[i].size() - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int>P;\nconst int INF = 1<<29;\nint N,M;\nint dp[256][128][16];\nvector<P> s[151];\n\nint main(){\n  while(scanf(\"%d%d\", &N,&M) && N||M){\n    for(int i=0;i<151;i++) for(int j=0;j<76;j++) for(int k=0;k<11;k++) dp[i][j][k] = INF;\n    for(int i=0;i<N;i++){\n      int k;\n      scanf(\"%d\", &k);\n      for(int j=0;j<k;j++){\n\tint x,d; scanf(\"%d%d\", &x,&d);\n\ts[i].push_back(P(x,d));\n      }\n    }\n    \n    for(int i=0;i<s[0].size();i++) dp[0][M][i] = min(dp[0][M][i], 0);\n    if(M) for(int i=0;i<s[1].size();i++) dp[1][M-1][i] = min(dp[1][M-1][i], 0);\n    /*    for(int m=0;m<=M;m++){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<s[i].size();j++) printf(\"%d \", dp[i][m][j]);\n\tputs(\"\");\n      }puts(\"\");\n      } */   \n\n    for(int i=0;i<N-1;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int m=0;m<=M;m++){\n\t  if(dp[i][m][j] == INF) continue;\n\t  for(int k=0;k<s[i+1].size();k++){\n\t    dp[i+1][m][k] = min(dp[i+1][m][k],\n\t\t\t\tdp[i][m][j]+(s[i+1][k].second+s[i][j].second)*abs(s[i+1][k].first-s[i][j].first));\n\t  }\n\t  if(i+2 < N && m) for(int k=0;k<s[i+2].size();k++){\n\t      dp[i+2][m-1][k] = min(dp[i+2][m-1][k],\n\t\t\t\t    dp[i][m][j]+(s[i+2][k].second+s[i][j].second)*abs(s[i+2][k].first-s[i][j].first));\n\t    }\n\t}\n      }\n      //      printf(\"%d\\n\" ,i);\n      /*      for(int m=0;m<=M;m++){\n\tfor(int i=0;i<N;i++){\n\t  for(int j=0;j<s[i].size();j++) printf(\"%d \", dp[i][m][j]);\n\t  puts(\"\");\n\t}puts(\"\");\n      }*/\n    }\n    /*    for(int m=0;m<=M;m++){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<s[i].size();j++) printf(\"%d \", dp[i][m][j]);\n\tputs(\"\");\n      }puts(\"\");\n      }*/\n    \n    int res = INF;\n    for(int i=0;i<s[N-1].size();i++) for(int m=0;m<=M;m++) res = min(res, dp[N-1][m][i]);\n    for(int i=0;i<s[N-2].size();i++) for(int m=1;m<=M;m++) res = min(res, dp[N-2][m][i]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nvoid calc(int n,int m){\n    int c,a,b,dp[151][10][80],ans=1000000000;\n    vector<pair<int,int> > stone[150];\n    \n    //scanf(\"%d%d\",&n,&m);\n    \n    \n    for(int j=0;j<10;j++){\n        for(int k=0;k<=m;k++){\n            dp[0][j][k]=0;\n        }\n    }\n    \n    for(int i=1;i<n;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<=m;k++){\n                dp[i][j][k]=1000000000;\n            }\n        }\n    }\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&c);\n        \n        for(int j=0;j<c;j++){\n            scanf(\"%d%d\",&a,&b);\n            stone[i].push_back(make_pair(a,b));\n        }\n    }\n    \n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<stone[i].size();j++){\n            for(int k=0;k<stone[i+1].size();k++){\n                for(int l=0;l<=m;l++){\n                    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][l]+(stone[i][j].second+stone[i+1][k].second)*abs(stone[i][j].first-stone[i+1][k].first));\n                }\n            }\n            for(int k=0;k<stone[i+2].size();k++){\n                for(int l=0;l<m;l++){\n                    dp[i+2][k][l+1]=min(dp[i+2][k][l+1],dp[i][j][l]+(stone[i][j].second+stone[i+2][k].second)*abs(stone[i][j].first-stone[i+2][k].first));\n                }\n            }\n        }\n    }\n    \n    for(int i=0;i<stone[n-1].size();i++){\n        for(int j=0;j<=m;j++){\n            ans=min(ans,dp[n-1][i][j]);\n        }\n    }\n    \n    printf(\"%d\\n\",ans);\n    \n    return;\n}\n\nint main(){\n    int n,m;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0) break;\n        calc(n,m);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdlib>\nusing namespace std;\n\nint main(){\n\ttypedef pair<int,int> pii;\n\tvector<pii>::iterator it;\n\tint n, m, k, x, d, h, i, j;\n\tfor(; cin >> n >> m, n; ){\n\t\tvector<pii> st[151];\n\t\tfor( i = 1; i <= n; i++ ){\n\t\t\tfor( cin >> k; k--; ){\n\t\t\t\tcin >> x >> d;\n\t\t\t\tst[i].push_back( pii( x, d ) );\n\t\t\t}\n\t\t}\n\n\t\tint dp[158][151][10];\n\t\tfill( **dp, *dp[158], 1e9 );\n\t\tfor( i = st[1].size(); i--; ){\n\t\t\tdp[m][1][i] = 0;\n\t\t}\n\t\tfor( i = st[2].size(); i--; ){\n\t\t\tdp[m-1][2][i] = 0;\n\t\t}\n\n\t\tfor( h = 2; h <= n; h++ ){\n\t\t\tfor( i = m; i >= 0; i-- ){\n\t\t\t\tfor( j = st[h].size(); j--; ){\n\t\t\t\t\tfor( k = st[h-1].size(); k--; ){\n\t\t\t\t\t\tx = dp[i][h-1][k]\n\t\t\t\t\t\t  + ( st[h][j].second + st[h-1][k].second )\n\t\t\t\t\t\t  * abs( st[h][j].first - st[h-1][k].first );\n\t\t\t\t\t\tdp[i][h][j] = min( dp[i][h][j], x );\n\t\t\t\t\t}\n\t\t\t\t\tfor( k = st[h-2].size(); k--; ){\n\t\t\t\t\t\tx = dp[i+1][h-2][k]\n\t\t\t\t\t\t  + ( st[h][j].second + st[h-2][k].second )\n\t\t\t\t\t\t  * abs( st[h][j].first - st[h-2][k].first );\n\t\t\t\t\t\tdp[i][h][j] = min( dp[i][h][j], x );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx = 1e9;\n\t\tfor( i = m; i >= 0; i-- ){\n\t\t\tfor( j = st[n].size(); j--; ){\n\t\t\t\tx = min( x, dp[i][n][j] );\n\t\t\t}\n\t\t}\n\t\tfor( i = m; i > 0; i-- ){\n\t\t\tfor( j = st[n-1].size(); j--; ){\n\t\t\t\tx = min( x, dp[i][n-1][j] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << x << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n\tdp[0][i][m]=dp[1][i][m]=dp[2][i][m-1]=0;\n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst ll INF = 9000000000000000000;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M;\nstd::vector<P> S[153];\nll dp[153][20][80];\n\nll value(const P& lp, const P& rp){\n    return (lp.second+rp.second) * std::abs(lp.first-rp.first);\n}\n\nll rec(int y, int x, int t){\n    if(y > N){return 0;}\n    if(dp[y][x][t] != -1){return dp[y][x][t];}\n\n    ll res = INF;\n    REP(i, S[y+1].size()){\n        res = std::min(res, rec(y+1, i, t) + value(S[y][x], S[y+1][i]));\n    }\n\n    if(t < M){\n        REP(i, S[y+2].size()){\n            res = std::min(res, rec(y+2, i, t+1) + value(S[y][x], S[y+2][i]));\n        }\n    }\n\n    return dp[y][x][t] = res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, N+3){\n            S[i].clear();\n        }\n\n        REP(i, N){\n            int k;\n            std::cin >> k;\n\n            REP(j, k){\n                int x, d;\n                std::cin >> x >> d;\n                x--;\n\n                S[i+1].push_back(mp(x, d));\n            }\n        }\n\n        REP(i, S[1].size()){\n            S[0].push_back(S[1][i]);\n        }\n\n        REP(i, S[2].size()){\n            S[0].push_back(S[2][i]);\n        }\n\n        REP(i, S[N].size()){\n            S[N+1].push_back(S[N][i]);\n            S[N+2].push_back(S[N][i]);\n        }\n\n        REP(i, S[N-1].size()){\n            S[N+1].push_back(S[N-1][i]);\n        }\n\n        REP(i, N+3){\n            REP(j, 20){\n                REP(k, M+1){\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n\n        ll res = INF;\n        REP(i, S[0].size()){\n            res = std::min(res, rec(0, i, 0));\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAX_N = 151;\nconst int MAX_M = MAX_N/2+2;\nconst int MAX_K = 11;\nconst int INF = 1<<29;\n\nint N, M;\nint K[MAX_N];\nint X[MAX_N][MAX_K], D[MAX_N][MAX_K];\nint T[MAX_N][MAX_K][MAX_M];\n\nint calcCost(int si, int sj, int di, int dj) {\n  return (D[si][sj] + D[di][dj]) * abs(X[si][sj] - X[di][dj]);\n}\n\nint solve() {\n  fill(T[0][0], T[MAX_N][0], INF);\n  for(int j = 0; j < K[0]; ++j) {\n    T[0][j][0] = 0;\n  }\n  for(int i = 1; i < N; ++i) {\n    for(int j = 0; j < K[i]; ++j) {\n      for(int l = 0; l <= 1; ++l) {\n\tfor(int m = l; m <= M; ++m) {\n\t  int pi = i-1-l;\n\t  int pm = m-l;\n\t  if(pi < 0) continue;\n\t  for(int pj = 0; pj < K[pi]; ++pj) {\n\t    T[i][j][m] = min(T[i][j][m],\n\t\t\t     T[pi][pj][pm] + calcCost(pi,pj,i,j));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = INF;\n  for(int j = 0; j < K[N-1]; ++j) {\n    for(int m = 0; m <= M; ++m) {\n      res = min(res, T[N-1][j][m]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    for(int i = 0; i < N; ++i) {\n      cin >> K[i];\n      for(int j = 0; j < K[i]; ++j) {\n\tcin >> X[i][j] >> D[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\nconst int INF = 1<<29;\nint n, m, c, l, w;\nvector<pint> data[200];\n\nint dp[160][15][100];\n\nint main() {\n    while (cin >> n >> m) {\n        if (n == 0) break;\n        \n        for (int i = 0; i < 200; ++i) data[i].clear();\n        for (int i = 0; i < n; ++i) {\n            cin >> c;\n            for (int j = 0; j < c; ++j) {\n                cin >> l >> w;\n                data[i].PB(pint(l,w));\n            }\n        }\n        \n        \n        for (int j = 0; j < 15; ++j) for (int k = 0; k < 100; ++k) {\n            for (int i = 0; i < 160; ++i) dp[i][j][k] = INF;\n        }\n        for (int i = 0; i < data[0].size(); ++i) dp[0][i][0] = 0;\n        for (int i = 0; i < data[1].size(); ++i) dp[1][i][1] = 0;\n        \n        int res = INF;\n        for (int i = 0; i < n-1; ++i) {\n            for (int j = 0; j < data[i].size(); ++j) {\n                \n                // 1行\n                for (int k = 0; k < data[i+1].size(); ++k) {\n                    int add = (data[i][j].second + data[i+1][k].second) * abs(data[i][j].first - data[i+1][k].first);\n                    for (int l = 0; l <= m; ++l) {\n                        chmin(dp[i+1][k][l], dp[i][j][l] + add);\n                    }\n                }\n                \n                // 2行\n                if (i < n-2) {\n                    for (int k = 0; k < data[i+2].size(); ++k) {\n                        int add = (data[i][j].second + data[i+2][k].second) * abs(data[i][j].first - data[i+2][k].first);\n                        for (int l = 0; l < m; ++l) {\n                            chmin(dp[i+2][k][l+1], dp[i][j][l] + add);\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int j = 0; j <= 15; ++j) for (int k = 0; k <= m; ++k) chmin(res, dp[n-1][j][k]);\n        for (int j = 0; j <= 15; ++j) for (int k = 0; k <= m-1; ++k) chmin(res, dp[n-2][j][k]);\n        \n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000000;\n\nint n, m, k[150], x[150][150], d[150][150];\n\nint dp[150][150][100];\n\nint dijkstra() {\n  for (int i = 0; i < n; i++) for (int j = 0; j < 10; j++) for (int k = 0; k <= m; k++) dp[i][j][k] = INF;\n  for (int i = 0; i < k[0]; i++) dp[0][x[0][i]][m] = 0;\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < k[i]; j++) {\n      for (int r = 0; r < k[i - 1]; r++)\n        for (int s = 0; s <= m; s++)\n          dp[i][j][s] = min(dp[i][j][s],\n                            dp[i-1][r][s] + (d[i][j] + d[i-1][r]) * abs(x[i][j] - x[i-1][r]));\n      if (i == 1) continue;\n      for (int r = 0; r < k[i - 2]; r++)\n        for (int s = 0; s < m; s++)\n          dp[i][j][s] = min(dp[i][j][s],\n                            dp[i-2][r][s+1] + (d[i][j] + d[i-2][r]) * abs(x[i][j] - x[i-2][r]));\n    }\n  }\n  int ans = INF;\n  for (int i = 0; i < k[n-1]; i++) for (int j = 0; j <= m; j++) ans = min(ans, dp[n-1][i][j]);\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &k[i]);\n      for (int j = 0; j < k[i]; j++) scanf(\"%d%d\", &x[i][j], &d[i][j]), x[i][j]--;\n    }\n    printf(\"%d\\n\", dijkstra());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint DP[151][10][76];\nint abs(int a){\n\tif(a<=0)\n\treturn -a;\n\treturn a;\n}\nint main() {\n\twhile(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n==0)\n\tbreak;\n\tint k[151],kiS[151][10],kiP[151][10];\n\tfor(int i=1;i<=n;i++ ){\n\t\tcin >> k[i];\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tcin >> kiP[i][j] >> kiS[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<151;i++)\n\t\tfor(int j=0;j<10;j++)\n\t\t\tfor(int kk=0;kk<76;kk++)\n\t\t\t\tDP[i][j][kk]=1 << 28;\n\tfor(int i=0;i<k[1];i++){\n\tDP[1][i][0]=0;\n\t}\n\tfor(int i=0;i<k[2];i++)\n\tDP[2][i][1]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int kk=0;kk<=min(m,n/2+1);kk++){\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int l=0;l<k[i-1];l++)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-1][l][kk]+(kiS[i][j]+kiS[i-1][l])*(abs(kiP[i][j]-kiP[i-1][l])));\n\t\t\t\tfor(int l=0;l<k[i-1];l++){\n\t\t\t\tif(kk!=0)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-2][l][kk-1]+(kiS[i][j]+kiS[i-2][l])*(abs(kiP[i][j]-kiP[i-2][l])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<k[i];j++)\n\t\t//\tcout << DP[i][j][0] << \" \" << i <<\" \" << j <<  endl;\n\t}*/\n\tint maxer =1 << 28;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tmaxer=min(maxer,DP[n][i][j]);\n\t\t//\tcout << n << \" \" << i << \" \" << j << \" \" << DP[n][i][j]<< endl;\n\t\t\tif(m+1<=m)\n\t\t\tmaxer=min(maxer,DP[n-1][i][m+1]);\n\t\t}\n\t}\n\tcout << maxer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\t// your code goes here\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >>m;\n\t\tif(n==0){\n\t\t\treturn 0;\n\t\t}\n\t\tint k[152];\n\t\tint x[152][10],d[152][10];\n\t\tk[0]=1;x[0][0]=0;d[0][0]=0;\n\t\tk[n+1]=1;x[n+1][0]=0;d[n+1][0]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> k[i];\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tcin >> x[i][j] >> d[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r[152][10][76];\n\t\tint rj[152][10][76];\n\t\tint mr[152];\n\t\tmr[n+1]=0;mr[n]=0;\n\t\tr[n+1][0][0]=0;\n\t\tfor(int j=0;j<k[n];j++){\n\t\t\tr[n][j][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tmr[i]=mr[i+2]+1;\n\t\t\tif(mr[i]>m){mr[i]=m;}\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\tr[i][j][s]=-1;\n\t\t\t\t\trj[i][j][s]=-1;\n\t\t\t\t}\n\t\t\t\tfor(int jj=0;jj<k[i+1];jj++){\n\t\t\t\t\tint dr=(d[i][j]+d[i+1][jj])*abs(x[i][j]-x[i+1][jj]);\n\t\t\t\t\t//if(dr==0){cout << '<' << i << ',' << j << '>' << '<' << i+1 << ',' << jj << '>' << endl;}\n\t\t\t\t\t//if(i==5 && j==6){cout << jj << ',' << dr << endl;}\n\t\t\t\t\tif(i==0){dr=0;}\n\t\t\t\t\tfor(int s=0;s<=mr[i+1];s++){\n\t\t\t\t\t\tif(r[i][j][s]==-1 || (r[i+1][jj][s]!=-1 && r[i+1][jj][s]+dr<r[i][j][s])){\n\t\t\t\t\t\t\tr[i][j][s]=r[i+1][jj][s]+dr;\n\t\t\t\t\t\t\t//rj[i][j][s]=jj;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int jj=0;jj<k[i+2];jj++){\n\t\t\t\t\tint dr=(d[i][j]+d[i+2][jj])*abs(x[i][j]-x[i+2][jj]);\n\t\t\t\t\tif(i==0 || i==n-1){dr=0;}\n\t\t\t\t\tfor(int s=1;s<=mr[i+2]+1;s++){\n\t\t\t\t\t\tif(r[i][j][s]==-1 || (r[i+2][jj][s-1]!=-1 && r[i+2][jj][s-1]+dr<r[i][j][s])){\n\t\t\t\t\t\t\tr[i][j][s]=r[i+2][jj][s-1]+dr;\n\t\t\t\t\t\t\t//rj[i][j][s]=jj+10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tcout << \":\";\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tcout << '(';\n\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\tcout << r[i][j][s] << '_' << rj[i][j][s] << ' ';\n\t\t\t\t}\n\t\t\t\tcout << ')';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tint rr=-1;\n\t\tfor(int s=0;s<=m;s++){\n\t\t\tif(rr==-1 || (r[0][0][s]!=-1 && r[0][0][s]<rr)){\n\t\t\t\trr=r[0][0][s];\n\t\t\t}\n\t\t}\n\t\tcout << rr << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint a,b;\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n      for(int j=0;j<80;j++){\n\tdp[0][i][j]=dp[1][i][j]=0;\n\tif(j<m)dp[2][i][j]=0;\n      }    \n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int k=0;k<v[i-1].size();k++){\n\t  for(int l=m;l>=0;l--){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t    if(l<m){\n\t      for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][k].s)*abs(v[i][j].f-v[i-2][k].f));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)\n      for(int j=0;j<=m;j++)\n      ans=min(ans,dp[n][i][j]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second ==0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0;i<MAX_V;i++)\n    ans=min(d[n-1][i],ans);\n \n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n\n  while(cin >> n >> m,n|m){\n    for(int i=0;i<155;i++)G[i].clear();\n\n    for(int i=0;i<MAX_V;i++)\n      for(int j=0;j<MAX_V;j++)\n\tgraph[i][j]=0;\n\n    for(int i=0;i<n;i++){\n      cin >> k;\n\n      for(int j=0;j<k;j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n\n    edge e;\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<MAX_V;j++){\n\n\tif(graph[i][j]>0){\n\n\t  for(int l=0;l<MAX_V;l++){\n\n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\n\t  }\n\t}\n      }\n    }\n  cout << dijkstra(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  vector<int> id[150];\n  bool use[1500];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    int num = 0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      id[i].clear();\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tif(i==n-1)use[num] = true;\n\telse use[num] = false;\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = 1<<30;\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    if(m>0)for(int i=0;i<(int)id[1].size();i++)q.push(P2(P1(0,id[1][i]),1));\n\n    int ans;\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n      if(use[idx]){\n\tans = risk;\n\tbreak;\n      }\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define INF 10000000000000000\nstruct S {int x,d;};\nint n,m;\nint dp[152][1002][80];//n,x,m\nvector<S> a[152];\n\nsigned main(){\n  while(cin>>n>>m,n){\n    REP(i,n+2)a[i].clear();\n    REP(i,n){\n      int k,x,d;\n      cin>>k;\n      REP(j,k){\n        cin>>x>>d;\n        a[i+1].push_back({x,d});\n      }\n    }\n    REP(i,n+2)REP(j,1000)REP(k,m+1)dp[i][j+1][k]=INF;\n    REP(j,1000)a[0].push_back({j+1,0});\n    REP(j,1000)a[n+1].push_back({j+1,0});\n    REP(j,1000)dp[0][j+1][0]=0;\n    REP(i,n+2){\n      for(S s:a[i]){\n        for(S t:a[i+1]){\n          REP(c,m+1){\n            dp[i+1][t.x][c]=min(dp[i+1][t.x][c],dp[i][s.x][c]+(s.d+t.d)*abs(s.x-t.x));\n          }\n        }\n        if(i+1>n)continue;\n        for(S u:a[i+2]){\n          REP(c,m){\n            dp[i+2][u.x][c+1]=min(dp[i+2][u.x][c+1],dp[i][s.x][c]+(s.d+u.d)*abs(s.x-u.x));\n          }\n        }\n      }\n    }\n    int ans=INF;\n    REP(j,1000)REP(c,m+1)ans=min(ans,dp[n+1][j+1][c]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < stones[i].size(); ++j) {\n                q.push(Tag(i, j, 0, M-i));\n            }\n        }\n\n        vector<vector<pair<int, int> > > dp(N, vector<pair<int, int> >(1000, make_pair(0, INT_MAX)));\n        unsigned ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m <= 0 && i == 2) break;\n                int y = t.y+i;\n                int nm = t.m-i+1;\n                for(int j = 0; j < stones[y].size(); ++j) {\n                    int cost = t.c + (stones[t.y][t.x].second+stones[y][j].second)*abs(stones[t.y][t.x].first-stones[y][j].first);\n                    if(nm <= dp[y][j].first && cost >= dp[y][j].second) continue;\n                    if(cost < dp[y][j].second) dp[y][j] = make_pair(nm, cost);\n                    q.push(Tag(y, j, cost, nm));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint mincost;\n\n\nvoid NoJump(VVP &G,VVI &dp)\n{\n  int n= dp.size();\n  rep(i,dp[0].size())dp[0][i] = 0;\n  rep(i,n-1)\n    {\n      int m = dp[i].size();\n      int o = dp[i+1].size();\n      rep(j,m)\n\t{\n\t  rep(k,o)\n\t    {\n\t      int cost = (G[i+1][k].S+G[i][j].S)*abs(G[i+1][k].F-G[i][j].F);\n\t      dp[i+1][k] = min(dp[i+1][k],cost+dp[i][j]);\n\t    }\t\n\t}\n    }\n  rep(i,G[n-1].size())mincost = min(mincost,dp[n-1][i]);\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      mincost = (1<<29);\n      VVP G(n);\n      rep(i,n)\n\t{\n\t  int k;\n\t  cin >> k;\n\t  rep(j,k)\n\t    {\n\t      int x,d;\n\t      cin >> x >> d;\n\t      G[i].push_back(P(x,d));\n\t    }\n\t}\n    \n      VVI dp(n);\n      rep(i,n)dp[i].resize(G[i].size(),(1<<29));\n      NoJump(G,dp);\n\n      //First jump\n      VVI prev = dp;\n      if(m != 0){\n\t\n\trep(i,G[1].size())prev[1][i] = 0;    \n\trep(i,n)\t\n\t  {\n\t    if(i+2 >= n)\n\t      {\n\t\trep(k,G[i].size())mincost = min(mincost,dp[i][k]);\n\t\tbreak;\n\t      }\n\t  rep(j,G[i].size())\n\t    {\n\t      rep(k,G[i+2].size())\n\t\t{\n\t\t  int cost = (G[i][j].S+G[i+2][k].S)*abs(G[i][j].F-G[i+2][k].F);\n\t\t  prev[i+2][k] = min(prev[i+2][k],cost+dp[i][j]); \n\t\t}\n\t    }\n\t  }\n\tdp = prev;\n\tNoJump(G,dp);\n      }\n      \n      if(m == 1 || m == 0)goto Next;\n\n      for(int i=1,cnt=1;cnt<m;cnt++,i+=2)\n\t{\n\t  prev = dp;\n\t  REP(j,i,n)\n\t    {\n\t      if(j+2 >= n)\n\t\t{\n\t\t  rep(k,G[j].size())mincost = min(mincost,dp[j][k]);\n\t\t  break;\n\t\t}\n\t      rep(k,G[j].size())\n\t\t{\n\t\t  rep(l,G[j+2].size())\n\t\t    {\t  \n\t\t      int cost = (G[j][k].S+G[j+2][l].S)*abs(G[j][k].F-G[j+2][l].F);\n\t\t      prev[j+2][l] = min(prev[j+2][l],cost+dp[j][k]);\n\t\t    }\n\t\t}\n\t    }\n\t  dp = prev;\n\t  NoJump(G,dp);\n\t}      \n     \n    Next:;\n    \n      NoJump(G,dp);\n\n      if(!G[n-1].empty())\n\trep(i,G[n-1].size())mincost = min(mincost,dp[n-1][i]);\n      else\n\trep(i,G[n-2].size())mincost = min(mincost,dp[n-2][i]);\n      \n      cout << mincost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> F;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nmap<F,int> edge;\nint stone[160][1010];\nint n,m;\nint d[160];\nbool used[160];\nint nidan[160];\nvector<P> node;\nvoid dijkstra()\n{\n\tfill(d,d+160,INF);\n\tfill(used,used+160,false);\n\tfill(nidan,nidan+160,0);\n\td[0]=0;\n\twhile(1)\n\t{\n\t\tint v=-1;\n\t\tfor(int u=0;u<node.size();u++)\n\t\t{\n\t\t\tif(!used[u]&&(v==-1||d[u]<d[v]))v=u;\n\t\t}\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tfor(int u=0;u<node.size();u++)\n\t\t{\n\t\t\tif(edge.find(F(node[v],node[u]))==edge.end())continue;\n\t\t\tif(node[u].fi-node[v].fi==2)\n\t\t\t{\n\t\t\t\tif(nidan[v]==m)continue;\n\t\t\t\tif(d[u]>d[v]+edge[F(node[v],node[u])])\n\t\t\t\t{\n\t\t\t\t\td[u]=d[v]+edge[F(node[v],node[u])];\n\t\t\t\t\tnidan[u]=nidan[v]+1;\n\t\t\t\t}\n\t\t\t\telse if(d[u]==d[v]+edge[F(node[v],node[u])])\n\t\t\t\t{\n\t\t\t\t\tnidan[u]=min(nidan[u],nidan[v]+1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(d[u]>d[v]+edge[F(node[v],node[u])])\n\t\t\t{\n\t\t\t\td[u]=d[v]+edge[F(node[v],node[u])];\n\t\t\t\tnidan[u]=nidan[v];\n\t\t\t}\n\t\t\telse if(d[u]==d[v]+edge[F(node[v],node[u])])\n\t\t\t{\n\t\t\t\tnidan[u]=min(nidan[u],nidan[v]);\n\t\t\t}\n\t\t\telse\n\t\t\t{}\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tnode.clear();\n\t\tedge.clear();\n\t\tmemset(stone,0,sizeof(stone));\n\t\tnode.pb(P(0,0));\n\t\tvector<int> tmp[155];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i][a]=b;\n\t\t\t\tnode.pb(P(i,a));\n\t\t\t\ttmp[i].pb(a);\n\t\t\t}\n\t\t}\n\t\tnode.pb(P(n+1,0));\n\t\tfor(int i=1;i<=2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<tmp[i].size();j++)\n\t\t\t{\n\t\t\t\tedge[F(P(0,0),P(i,tmp[i][j]))]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<tmp[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<tmp[i+1].size();k++)\n\t\t\t\t{\n\t\t\t\t\tedge[F(P(i,tmp[i][j]),P(i+1,tmp[i+1][k]))]=(stone[i][tmp[i][j]]+stone[i+1][tmp[i+1][k]])*(abs(tmp[i][j]-tmp[i+1][k]));\n\t\t\t\t}\n\t\t\t\tif(i!=n-1)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<tmp[i+2].size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tedge[F(P(i,tmp[i][j]),P(i+2,tmp[i+2][k]))]=(stone[i][tmp[i][j]]+stone[i+2][tmp[i+2][k]])*(abs(tmp[i][j]-tmp[i+2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=1;i++)\n\t\t{\n\t\t\tfor(int j=0;j<tmp[n-i].size();j++)\n\t\t\t{\n\t\t\t\tedge[F(P(n-i,tmp[n-i][j]),P(n+1,0))]=0;\n\t\t\t}\n\t\t}\n\t\tdijkstra();\n\t\t//cout <<node.size() << endl;\n\t\t//cout << d[node.size()-1] << endl;\n\t\t//cout << edge[F(node[0],node[1])]<<' '<<edge[F(node[0],node[2])]<<' '<<edge[F(node[1],node[3])]<<' '<<edge[F(node[2],node[3])]<<' '<<edge[F(node[3],node[4])] << endl;\n\t\tfor(int i=0;i<node.size();i++)\n\t\t{\n\t\t\tcout << node[i].fi <<' ' << node[i].sec<<' '<<d[i]<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n\nint n, m;\nint k[256];\nvector<P> G[256];\n\nint dp[256][16][128];\n\nint dfs(int i, int j, int h)\n{\n  if (i == n - 1) return 0;\n  if (i == n - 2 && h) return 0;\n  int &ret = dp[i][j][h];\n\n  if (ret != -1) return ret;\n\n  ret = 1e9 + 9;\n\n  for (int l = 0; l < k[i + 1]; l++){\n    ret = min(ret, dfs(i + 1, l, h) + abs(G[i][j].fi - G[i + 1][l].fi) * (G[i][j].se + G[i + 1][l].se));\n  }\n  if (h && i < n){\n    for (int l = 0; l < k[i + 2]; l++){\n      ret = min(ret, dfs(i + 2, l, h - 1) + abs(G[i][j].fi - G[i + 2][l].fi) * (G[i][j].se + G[i + 2][l].se));\n    }\n  }\n\n  return ret;\n}\n\nint solve()\n{\n  int ret = 1e9 + 9;\n  for (int j = 0; j < k[0]; j++){\n    memset(dp, -1, sizeof(dp));\n    ret = min(ret, dfs(0, j, m));\n  }\n  if (m){\n    for (int j = 0; j < k[1]; j++){\n      memset(dp, -1, sizeof(dp));\n      ret = min(ret, dfs(1, j, m - 1));\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  while (cin >> n >> m, n){\n    for (int i = 0; i < n; i++){\n      cin >> k[i];\n      for (int j = 0; j < k[i]; j++){\n        int x, d;\n        cin >> x >> d;\n        G[i].push_back(P(x, d));\n      }\n    }\n\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint stone[160][1010];\nint dp[160][1010][100];\nint n,m;\nvector<int> node[160];\nint dist(int a1,int a2,int b1,int b2)\n{\n\treturn (stone[a1][a2]+stone[b1][b2])*abs(a2-b2);\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<160;i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=0;i<160;i++)\n\t\t{\n\t\t\tfor(int j=0;j<1010;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<100;k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<160;i++)\n\t\t{\n\t\t\tfor(int j=0;j<1010;j++)\n\t\t\t{\n\t\t\t\tstone[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i][a]=b;\n\t\t\t\tnode[i].pb(a);\n\t\t\t\tif(i==1)\n\t\t\t\t{\n\t\t\t\t\tdp[i][a][m]=0;\n\t\t\t\t}\n\t\t\t\tif(i==2&&m>0)\n\t\t\t\t{\n\t\t\t\t\tdp[i][a][m-1]=0;\n\t\t\t\t\t//cout << dp[i][a][m-1] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<node[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=m;l++)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<node[i+1].size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][node[i+1][k]][l]=min(dp[i+1][node[i+1][k]][l],dp[i][node[i][j]][l]+dist(i,node[i][j],i+1,node[i+1][k]));\n\t\t\t\t\t\t/*if(i+1>=3&&dp[i+1][node[i+1][k]][l]==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcout << i+1 <<' ' <<node[i+1][k]<<' '<<l<< endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<node[i+2].size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(l==m)continue;\n\t\t\t\t\t\tdp[i+2][node[i+2][k]][l]=min(dp[i+2][node[i+2][k]][l],dp[i][node[i][j]][l+1]+dist(i,node[i][j],i+2,node[i+2][k]));\n\t\t\t\t\t\t/*if(i+1>=3&&dp[i+2][node[i+2][k]][l]==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcout << i+2 <<' ' <<node[i+2][k]<<' '<<l<< endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<node[i].size();j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=m;k++)\n\t\t\t\t{\n\t\t\t\t\tcout <<i<<' '<<node[i][j]<<' '<<k<<' '<< dp[i][node[i][j]][k] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t//cout << dp[1][node[1][0]][m] << endl;\n\t\tfor(int i=0;i<node[n-1].size();i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tans=min(ans,dp[n-1][node[n-1][i]][j]);\n\t\t\t\tif(dp[n-1][node[n-1][i]][j]==0)cout<<n-1<<' '<<node[n-1][i]<<' '<<j<<endl;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<node[n].size();i++)\n\t\t{\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tans=min(ans,dp[n][node[n][i]][j]);\n\t\t\t\tif(dp[n][node[n][i]][j]==0)cout<<n<<' '<<node[n][i]<<' '<<j<<endl;\n\t\t\t}\n\t\t}\n\t\t//cout << dist(1,node[1][0],2,node[2][0])<< endl;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<int> > stones(N, vector<int>(1000, INT_MAX));\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i][x] = d;\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < 1000; ++j) {\n                if(stones[i][j] != INT_MAX) {\n                    q.push(Tag(i, j, 0, M-i));\n                }\n            }\n        }\n\n        vector<vector<vector<unsigned> > > dp(M+1, vector<vector<unsigned> >(N, vector<unsigned>(1000, UINT_MAX)));\n        unsigned ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m <= 0 && i == 2) break;\n                for(int j = 0; j < 1000; ++j) {\n                    unsigned cost = stones[t.y+i][j];\n                    if(cost != INT_MAX) {\n                        cost += stones[t.y][t.x];\n                        cost *= std::abs((int)t.x-j);\n                        cost += t.c;\n                        if(cost >= dp[t.m-i+1][t.y+i][j]) continue;\n                        dp[t.m-i+1][t.y+i][j] = cost;\n                        q.push(Tag(t.y+i, j, cost, t.m-i+1));\n             //           cout << '\\t' << t.y+i << ' ' << j << ' ' << cost*abs(t.x-j) << endl;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\n#define INF (1<<30)\nint suberi(PA a,PA b){\n  return(a.second+b.second);\n}\nint yoko(PA a,PA b){\n  return(abs(a.first-b.first));\n}\nint main(){\n  int n,m,k,x,d;\n  vector<PA> vec[150];\n  while(scanf(\"%d %d\",&n,&m),n!=0||m!=0){\n    int dp[151][10][80];\n    fill_n(**dp,151*10*80,INF);\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x,&d);\n\tvec[i].push_back(PA(x,d));\n\tif(i == 0) dp[0][j][0] = 0;\n\tif(i == 1) dp[1][j][1] = 0;\n      }\n    }\n    int ans = INT_MAX;\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<vec[i].size();j++){\n\tfor(int l=0;l<=m;l++){\n\t  for(int z=0;z<vec[i+1].size();z++){\n\t    dp[i+1][z][l] = min(dp[i+1][z][l],suberi(vec[i][j],vec[i+1][z]) * yoko(vec[i][j],vec[i+1][z]) + dp[i][j][l]);\n\t    if(i+1 == n-1) ans = min(ans,dp[n-1][z][l]);\n\t  }\n\t  if(l == m || i == n-2) continue;\n\t  for(int z=0;l<=m,z<vec[i+2].size();z++){\n\t    dp[i+2][z][l+1] = min(dp[i+1][z][l],suberi(vec[i][j],vec[i+2][z]) * yoko(vec[i][j],vec[i+2][z]) + dp[i][j][l]);\n\t    if(i+2 == n-1) ans = min(ans,dp[n-1][z][l+1]);\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//滑りやすさ>=0なら大丈夫.3Dにすると、メモリがたくさんいるので、2つのナップザックを使いまわす。\n#include<iostream>\n#include<math.h>\nusing namespace std;\n\nint N,M;\nint pos[150][10];\t\t//石のある場所(x座標)\nint list[150][10];\t\t//石の滑りやすさ\nint minest[2][150][10];\t//危険度ナップザック(探索用)\n\nvoid ainst(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid acopy(int *a,int *b,int index){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = b[i];\n\t}\n}\nint amin(int *a,int index){\n\tint min = a[0];\n\tfor(int i = 1;i < index;i++){\n\t\tif(min > a[i])\n\t\t\tmin = a[i];\n\t}\n\treturn min;\n}\nint nap(int n,int mode){\t//mode:0のときは一行飛ばし可能、1のときは不可能\n\tint i,j,l;\n\tint min = 2000000000;\n\tfor(i = 0;i < n-1;i++){\n\t\tfor(j = 0;j < 10;j++){\n\t\t\tif(pos[i][j] == -1)\n\t\t\t\tbreak;\n\t\t\tif(i+2 >= n && mode == 0){\n\t\t\t\tif(min > minest[0][i][j])\n\t\t\t\t\tmin = minest[0][i][j];\n\t\t\t}\n\t\t\tfor(l = 0;l < 10;l++){\n\t\t\t\tswitch(mode){\n\t\t\t\tcase 0:\n\t\t\t\t\tif(i+2 < n && pos[i+2][l] >= 0){\n\t\t\t\t\t\tif(minest[1][i+2][l] == -1 || minest[1][i+2][l] > minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l])){\n\t\t\t\t\t\t\tminest[1][i+2][l] = minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase 1:\n\t\t\t\t\tif(pos[i+1][l] >= 0){\n\t\t\t\t\t\tif(minest[0][i+1][l] == -1 || minest[0][i+1][l] > minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l])){\n\t\t\t\t\t\t\tminest[0][i+1][l] = minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0;i < 10;i++){\n\t\tif(minest[0][n-1][i] != -1 && min > minest[0][n-1][i])\n\t\t\tmin = minest[0][n-1][i];\n\t}\n\treturn min;\n}\nint main(){\n\tint i,j,k;\n\tint mcor,now,saisyo[1000];\n\tint saicor = 0;\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0)\n\t\t\tbreak;\n\t\tsaisyo[saicor] = 2000000000;\n\t\tfor(i = 0;i < N;i++){\n\t\t\tainst(pos[i],10,-1);\n\t\t\tainst(list[i],10,-1);\n\t\t\tainst(minest[0][i],10,-1);\n\t\t\tainst(minest[1][i],10,-1);\n\t\t\tcin >> k;\n\t\t\tfor(j = 0;j < k;j++){\n\t\t\t\tcin >> pos[i][j] >> list[i][j];\n\t\t\t}\n\t\t}\n\t\tainst(minest[0][0],10,0);\n\t\tainst(minest[1][0],10,0);\n\t\t//探索開始\n\t\tfor(mcor = 0;mcor <= M;mcor++){\n\t\t\tif(mcor < M)\n\t\t\t\tnow = nap(N,0);\n\t\t\telse\n\t\t\t\tnow = nap(N,1);\n\t\t\tif(saisyo[saicor] > now)\n\t\t\t\tsaisyo[saicor] = now;\n\t\t\tfor(i = 0;i < N;i++){\n\t\t\t\tacopy(minest[0][i],minest[1][i],10);\n\t\t\t\tainst(minest[1][i],10,-1);\n\t\t\t}\n\t\t\tainst(minest[0][0],10,0);\n\t\t\tainst(minest[1][0],10,0);\n\t\t}\n\t\tsaicor++;\n\t}\n\tfor(i = 0;i < saicor;i++){\n\t\tcout << saisyo[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint memo[80][150][20];\n\nint main(){\n  int n,m;\n  while(n=getInt(), m=getInt(), n+m){\n    vector<vector<pair<int,int> > > stone(n);\n    memset(memo, -1, sizeof(memo));\n    REP(i,n){\n      int num = getInt();\n      stone[i] = vector<pair<int,int> >(num);\n      REP(j,num){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    REP(i,stone[0].size()) memo[m][0][i] = 0;\n    if(m != 0) REP(i,stone[1].size()) memo[m-1][1][i] = 0;\n\n    REP(i,n-1){\n      FOR(it,stone[i]){\n        int j = it->f;\n        int s = it->s;\n        int idxj = it - stone[i].begin();\n        REP(k,m+1){\n          if(memo[k][i][idxj] != -1){\n            FOR(it2,stone[i+1]){\n              int jj = it2->f;\n              int ss = it2->s;\n              int idxjj = it2 - stone[i+1].begin();\n              int mm = memo[k][i][idxj];\n\n              if(memo[k][i+1][idxjj] == -1)\n                memo[k][i+1][idxjj] = mm + (s + ss)*abs(j - jj);\n              else\n                memo[k][i+1][idxjj] = min(memo[k][i+1][idxjj], mm + (s + ss)*abs(j - jj));\n            }\n\n            if(k != 0 && i != n-2){\n              FOR(it2,stone[i+2]){\n                int jj = it2->f;\n                int ss = it2->s;\n                int idxjj = it2 - stone[i+2].begin();\n                int mm = memo[k][i][idxj];\n\n                if(memo[k-1][i+2][idxjj] == -1)\n                  memo[k-1][i+2][idxjj] = mm + (s + ss)*abs(j - jj);\n                else\n                  memo[k-1][i+2][idxjj] = min(memo[k][i+2][idxjj], mm + (s + ss)*abs(j - jj));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    //puts(\"0:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[0][i][j]); puts(\"\"); }\n    //puts(\"1:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[1][i][j]); puts(\"\"); }\n    //REP(i,n) { FOR(it,stone[i]) printf(\"%2d \",it->s); puts(\"\"); }\n\n    int ans = INT_MAX;\n    REP(j,20) REP(k,m+1){\n      if(memo[k][n-1][j] > -1)\n        ans = min(ans, memo[k][n-1][j]);\n      if(k != 0){\n        if(memo[k][n-2][j] > -1)\n          ans = min(ans, memo[k][n-2][j]);\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint DP[150][100][11];\nint N, M;\nint K[150];\nint X[150][10], Y[150][10];\nint main()\n{\n\twhile (true){\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)break;\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tfor (int k = 0; k <= 10; k++){\n\t\t\t\t\tDP[i][j][k] = 1000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d%d\", &X[i][j], &Y[i][j]);\n\t\t\t}\n\t\t}\n\t\t//i=1\n\t\tfor (int j = 0; j < K[1]; j++){\n\t\t\tfor (int k = 0; k < K[0]; k++){\n\t\t\t\tDP[1][j][0] = min(DP[1][j][0], (Y[1][j] + Y[0][k])*abs(X[1][j] - X[0][k]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i < N; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i - 1]; k++){\n\t\t\t\t\tfor (int l = 0; l <= M; l++){\n\t\t\t\t\t\tDP[i][j][l] = min(DP[i][j][l], DP[i - 1][k][l] + (Y[i][j] + Y[i - 1][k])*abs(X[i][j] - X[i - 1][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < K[i - 2]; k++){\n\t\t\t\t\tfor (int l = 0; l < M; l++){\n\t\t\t\t\t\tDP[i][j][l + 1] = min(DP[i][j][l+1], DP[i - 2][k][l] + (Y[i][j] + Y[i - 2][k])*abs(X[i][j] - X[i - 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\t\n\t\tfor (int j = 0; j < K[N - 1]; j++){\n\t\t\tfor (int k = 0; k <= M; k++){\n\t\t\t\tans = min(ans, DP[N - 1][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 152;\nconst int MAX_K = 12;\n\nint a[MAX_N];\nint dp[MAX_N][(MAX_N+1)/2][MAX_K];\nint n,m,K;\nvector<int> S[MAX_N];\nvector<int> T[MAX_N];\n\nint main()\n{\n\twhile(1){\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0){\n\t\tbreak;\n\t}\n\trep(i,n){\n\t\tscanf(\"%d\",&K);\n\t\trep(j,K){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tS[i].push_back(x-1);\n\t\t\tT[i].push_back(y);\n\t\t}\n\t}\n\trep(i,S[n-2].size()){\n\t\tS[n].push_back(S[n-2][i]);\n\t\tT[n].push_back(0);\n\t}\n\trep(i,S[n-1].size()){\n\t\tS[n].push_back(S[n-1][i]);\n\t\tT[n].push_back(0);\n\t}\n\tfill(dp[0][0],dp[n+1][0],INF);\n\trep(j,S[0].size()){\n\t\tdp[0][j][0] = 0;\n\t}\n\trep(j,S[1].size()){\n\t\trep(l,S[0].size()){\n\t\t\tdp[1][j][0] = min(dp[1][j][0],(T[0][l]+T[1][j])*abs(S[1][j]-S[0][l]));\n\t\t}\n\t\tif(m>=1){\n\t\t\tdp[1][j][1] = 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\trep(j,S[i+1].size()){\n\t\t\trep(k,m+1){\n\t\t\t\trep(l,S[i].size()){\n\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i][l][k]+(T[i][l]+T[i+1][j])*abs(S[i+1][j]-S[i][l]));\n\t\t\t\t}\n\t\t\t\tif(k>=1){\n\t\t\t\t\trep(l,S[i-1].size()){\n\t\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i-1][l][k-1]+(T[i-1][l]+T[i+1][j])*abs(S[i+1][j]-S[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(j,S[n].size()){\n\t\trep(k,m+1){\n\t\t\tans = min(ans,dp[n][j][k]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint n, m;\nint l[150];\nint k[150][10][2];\nint dp[150][10][75];\nint INF = 10e8+7;\n\nint main(){\n\twhile(1){\n\t\tmemset(k, 0, sizeof(k));\n\t\tmemset(dp, INF, sizeof(dp));\n\t\tint ans = INF;\n\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d\", &l[i]);\n\t\t\tfor(int j=0; j<l[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &k[i][j][0], &k[i][j][1]);\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i=0; i<n; i++){\n\t\t\tprintf(\"%d\\t\", l[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<l[i]; j++){\n\t\t\t\tprintf(\"%d %d\\t\", k[i][j][0], k[i][j][1]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\n\t\tfor(int i=0; i<l[0]; i++)\n\t\t\tdp[0][i][0] = 0;\n\n\t\tfor(int i=0; i<l[1]; i++)\n\t\t\tdp[1][i][1] = 0;\n\n\t\tfor(int i=0; i<l[1]; i++){\n\t\t\tfor(int j=0; j<l[0]; j++){\n\t\t\t\tdp[1][i][0] = min(dp[1][i][0], (k[1][i][1] + k[0][j][1]) * abs(k[1][i][0] - k[0][j][0]));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=2; i<n; i++){ //gyou\n\t\t\tfor(int i1=0; i1<l[i]; i1++){ //nowishi\n\t\t\t\tfor(int i2=0; i2<l[i-1]; i2++){ //previshi, ichitobi0\n\t\t\t\t\tdp[i][i1][0] = min(dp[i][i1][0], dp[i-1][i2][0] + (k[i-1][i2][1] + k[i][i1][1]) * abs(k[i][i1][0] - k[i-1][i2][0]));\n\t\t\t\t}\n\t\t\t\tfor(int i2=0; i2<l[i-2]; i2++){ //previshi, ichitobiari\n\t\t\t\t\tfor(int i3=1; i3<m+1; i3++){ //ichitobi\n\t\t\t\t\t\tdp[i][i1][i3] = min(dp[i][i1][i3], dp[i-2][i2][i3-1] + (k[i-2][i2][1] + k[i][i1][1]) * abs(k[i-2][i2][0] - k[i][i1][0]));\n\t\t\t\t\t\tdp[i][i1][i3] = min(dp[i][i1][i3], dp[i-1][i2][i3] + (k[i-1][i2][1] + k[i][i1][1]) * abs(k[i-1][i2][0] - k[i][i1][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<l[n-1]; i++){\n\t\t\tfor(int j=0; j<m+1; j++){\n\t\t\t\tans = min(ans, dp[n-1][i][j]);\n\t\t\t\tif(ans == 12) printf(\"%d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<l[n-2]; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tans = min(ans, dp[n-1][i][j]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n#define N 200\n#define ACOL 100\n#define JUMP 100\n\nconst int infty=1<<29;\n\nusing namespace std;\n\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\n\nint dijkstra(int n,int m,\n\t     const vector< vector<int> > &C,\n\t     const vector< vector<int> > &D)\n{\n  static bool vis[N][ACOL][JUMP];\n  static int A[N][ACOL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<ACOL;++j)for(int k=0;k<JUMP;++k){vis[i][j][k]=false;A[i][j][k]=infty;}\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  \n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    vis[s.r][s.c][s.left]=true;\n    if(s.r==n+1||s.r==n+2){continue;}\n    for(int k=1;k<=2;++k){\n      for(int i=0;i<C[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=i,nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(C[s.r][s.c]-C[nxr][nxc]),nxj=s.left-(k-1);\n\tif(s.r==0||nxr==n+1||nxr==n+2)nxcost=s.cost;if(nxj<0)continue;\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc][nxj]&&A[nxr][nxc][nxj]>nxcost){A[nxr][nxc][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  int ret=infty;\n  for(int i=0;i<JUMP;++i){for(int j=0;j<ACOL;++j){\n      ret=min(A[n+1][j][i],min(A[n+2][j][i],ret));\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(cin.eof()||n==0&&m==0)break;\n    vector< vector<int> > D(n+3);D[n+1].push_back(0);D[n+2].push_back(0);\n    vector< vector<int> > C(n+3);C[n+1].push_back(0);C[n+2].push_back(0);\n    for(int i=0;i<n;++i){\n      int k;\n      cin>>k;\n      for(int j=0;j<k;++j){\n\tint col,danger;\n\tcin>>col>>danger;\n\tC[i+1].push_back(col);\n\tD[i+1].push_back(danger);\n      }\n    }\n    cout<<dijkstra(n,m,C,D)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Pyon-Pyon River Crossing.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int X = 1005;\nconst int Y = 155;\nconst int MM = 80;\nconst int INF = 1 << 30;\n\nint N, M;\nint dp[3][X][MM];\n\nint main()\n{\n\tfor(; cin >> N >> M && (N || M); )\n\t{\n\t\tvector<vector<vint> > dp(3, vector<vint>(X, vint(MM, INF)));\n\t\tdp[0] = vector<vint>(X, vint(MM, 0));\n\t\t\n\t\tvector<vector<pint> > river;\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\triver.push_back(vector<pint>(k));\n\t\t\t\n\t\t\trep(i, k) cin >> river[y][i].first >> river[y][i].second;\n\t\t}\n\t\t\n\t\triver.push_back(vector<pint>(X));\n\t\triver.push_back(vector<pint>(X));\n\t\trep(i, X) river[N][i] = mp(i, 0), river[N+1][i] = mp(i, 0);\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\trep(i, river[y].size())\n\t\t\t{\n\t\t\t\trep(m, M+1)\n\t\t\t\t{\n\t\t\t\t\trep(j, river[y+1].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+1][j].second + river[y][i].second) * abs(river[y+1][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[1][river[y+1][j].first][m], dp[0][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(m > 0) rep(j, river[y+2].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+2][j].second + river[y][i].second) * abs(river[y+2][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[2][river[y+2][j].first][m-1], dp[0][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp[0] = dp[1];\n\t\t\tdp[1] = dp[2];\n\t\t\trep(x, X) rep(m, MM) dp[2][x][m] = INF;\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\trep(x, X) rep(m, MM) chmin(ans, dp[0][x][m]);\n\n\t\tcout << ans << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint a,b;\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n      for(int j=0;j<80;j++){\n\tdp[0][i][j]=dp[1][i][j]=0;\n\tif(j<m)dp[2][i][j]=0;\n      }    \n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int k=0;k<v[i-1].size();k++){\n\t  for(int l=m;l>=0;l--){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t    if(l<m){\n\t      for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)\n      for(int j=0;j<=m;j++)\n      ans=min(ans,dp[n][i][j]);\n\n    for(int i=0;i<v[n-1].size();i++)\n      for(int j=1;j<m;j++)\n\tans=min(ans,dp[n-1][i][j]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[256][16][128];\nint stones[256][16][2];\nint col[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tREP(k, 2) cin >> stones[i][j][k];\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tint x_now = stones[i][j][0], d_now = stones[i][j][1];\n\tREP(m, M+1) {\n\t  if (dp[i][j][m] == INF) continue;\n\t  REP(k, col[i+1]) {\n\t    int x_next = stones[i+1][k][0], d_next = stones[i+1][k][1];\n\t    int safe = (d_now + d_next) * abs(x_now - x_next);\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + safe);\n\t  }\n\t  if (i < N-2 && m < M) {\n\t    REP(k, col[i+2]) {\n\t      int x_next = stones[i+2][k][0], d_next = stones[i+2][k][1];\n\t      int safe = (d_now + d_next) * abs(x_now - x_next);\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < stones[i].size(); ++j) {\n                q.push(Tag(i, j, 0, M-i));\n            }\n        }\n\n        vector<vector<pair<int, int> > > dp(N, vector<pair<int, int> >(1000, make_pair(0, INT_MAX)));\n        unsigned ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.m < dp[t.y][t.x].first && t.c > dp[t.y][t.x].second) continue;\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m <= 0 && i == 2) break;\n                int y = t.y+i;\n                int nm = t.m-i+1;\n                for(int j = 0; j < stones[y].size(); ++j) {\n                    int cost = t.c + (stones[t.y][t.x].second+stones[y][j].second)*abs(stones[t.y][t.x].first-stones[y][j].first);\n                    if(nm <= dp[y][j].first && cost >= dp[y][j].second) continue;\n                    if(cost < dp[y][j].second) dp[y][j] = make_pair(nm, cost);\n                    q.push(Tag(y, j, cost, nm));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll dp[150][76][10];\nint main(){\n\twhile(true){\n\tint n,m;\tcin>>n>>m;\n\tif(n==0)\treturn 0;\n\tvector<pair<int,int>> ls[n];\n\tfor(int i=0;i<n;i++){\n\t\tint k;\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\tcin>>x>>d;\n\t\t\tls[i].push_back(make_pair(x,d));\n\t\t}\n\t}\n\tfor(int i=0;i<150;i++){\n\t\tfor(int j=0;j<=75;j++){\n\t\t\tfor(int k=0;k<10;k++)\tdp[i][j][k]=(1<<30);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)ls[0].size();i++)\tdp[0][m][i]=0;\n\tif(m!=0)\tfor(int i=0;i<(int)ls[1].size();i++)\tdp[1][m-1][i]=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<(int)ls[i].size();k++){\n\t\t\t\tif(dp[i][j][k]==(1<<30))\tcontinue;\n\t\t\t\tfor(int l=0;l<(int)ls[i+1].size();l++){\n\t\t\t\t\tdp[i+1][j][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+1][l].first)*(ls[i][k].second+ls[i+1][l].second),dp[i+1][j][l]);\n\t\t\t\t}\n\t\t\t\tif(j!=0&&i+2<n){\n\t\t\t\t\tfor(int l=0;l<(int)ls[i+2].size();l++){\n\t\t\t\t\tdp[i+2][j-1][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+2][l].first)*(ls[i][k].second+ls[i+2][l].second),dp[i+2][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=(1<<30);\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-1].size();j++){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-2].size();j++){\n\t\t\tans=min(ans,dp[n-2][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\n\n\nint mins(int a,int b){\n  if(a==-1)return b;\n  if(b==-1)return a;\n  else return (a>b)?b:a;\n}\nint main(void){\n  int m,n;\n  scanf(\"%d%d\",&n,&m);\n  while(n!=0){\n\n    int dkmp[150][10][77];//動計(メモ再)用。\n    int maps[150][10][2];//盤面用。\n    //memset(maps,-1,sizeof(maps));\n    memset(dkmp,-1,sizeof(dkmp));\n    memset(maps,-1,sizeof(maps));\n    int i=0;\n    int j=0;\n    int xm;\n    for(i=0;i<n;i++){\n      scanf(\"%d\",&xm);\n      for(j=0;j<xm;j++){\n\tscanf(\"%d%d\",&(maps[i][j][0]),&(maps[i][j][1]));\n      }\n    }\n    //maps[i][j]には、岸からi+1つめの石で、j列にある石のあれ。\n    //maps[n][x]は、向こう岸。だった。\n    //maps[i][j][0]には、岸からi+1つめの石のある列。\n    //maps[i][j][1]には、岸からi+1つめの石のあるすべ。\n    for(j=0;j<10;j++){\n      if(maps[0][j][0]!=-1){\n\tdkmp[0][j][m]=0;\n      }\n      if(maps[1][j][0]!=-1 && m!=0){\n\tdkmp[1][j][m-1]=0;\n      }\n    }\n    int mema,memb,memc,memd,meme,memf;\n    for(j=0;j<10;j++){\n      if(maps[1][j][0]==-1)break;\n      mema=-1;\n      memd=maps[1][j][0];//行\n      meme=maps[1][j][1];//滑りやすさ    \n      for(i=0;i<10;i++){\n\tif(dkmp[0][i][m]!=-1){\n\t  memb=0;//=dkmp[0][p][m];累積\n\t  memc=maps[0][i][0];//行\n\t  memf=maps[0][i][1];//滑りやすさ\n\t  mema=mins(mema,abs(memd-memc)*(meme+memf)+memb);\n\t}\n\telse break;\n      }\n      dkmp[1][j][m]=mema;\n    }\n\n\n    //ここから動計部\n    //maps[i][j][m]には、i個目のj\n    int k=0,p=0;\n    for(i=2;i<n;i++){//岸からi個目の石\n      for(j=0;j<10;j++){//j番目の石\n\tif(maps[i][j][0]==-1)break;\n\telse{//石がそこにあれば\n\t  memd=maps[i][j][0];//行\n\t  meme=maps[i][j][1];//滑りやすさ    \n\t  for(k=0;k<=m;k++){//残りk回飛べるとき。\n\t    mema=-1;\n\t    for(p=0;p<10;p++){//石pから飛んできたとする。\n\t      if(dkmp[i-1][p][k]!=-1){\n\t\tmemb=dkmp[i-1][p][k];//累積\n\t\tmemc=maps[i-1][p][0];//行\n\t\tmemf=maps[i-1][p][1];//滑りやすさ\n\t\tmema=mins(mema,abs(memd-memc)*(meme+memf)+memb);\n\t      }\n\t      else break;\n\t    }\n\t    if(k<m){\n\t      for(p=0;p<10;p++){//石pから飛んできたとする。\n\t\tif(dkmp[i-2][p][k+1]!=-1){\n\t\t  memb=dkmp[i-2][p][k+1];//累積\n\t\t  memc=maps[i-2][p][0];//行\n\t\t  memf=maps[i-2][p][1];//滑りやす\n\t\t  mema=mins(mema,abs(memd-memc)*(meme+memf)+memb);\n\t\t}\n\t\telse break;\n\t      }\n\t    }\n\t    dkmp[i][j][k]=mema;\n\t  }\n\t}\n      }\n    }\n\n    //printf(\"%d\\x0020%d\\n\",m,dkmp[n-1][0][0]);\n    int ans=-1;\n    for(i=0;i<10;i++){\n      if(maps[n-1][i][0]==-1)break;\n      for(j=0;j<=m;j++){\n\tans=mins(ans,dkmp[n-1][i][j]);\n\t//printf(\"%d\\n\",dkmp[n-1][i][j]);\n      }\n    }\n    for(i=0;i<10;i++){\n      if(maps[n-2][i][0]==-1)break;\n      for(j=1;j<=m;j++){\n\tans=mins(ans,dkmp[n-2][i][j]);\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n    scanf(\"%d%d\",&n,&m);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int inf = 1<<28;\nconst int H = 151;\nconst int W = 1001;\nconst int M = 80;\nint D[H][W];\nint dp[H][W][M];\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                D[i][j] = inf;\n                for ( int k = 0; k < M; ++ k ) {\n                    dp[i][j][k] = inf;\n                }\n            }\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int x, d;\n                cin >> x >> d;\n                -- x;\n                D[n-i-1][x] = d;\n            }\n        }\n        for ( int i = 0; i < 1001; ++ i ) {\n            if ( D[n-1][i] != inf ) dp[n - 1][i][0] = 0;\n        }\n        for ( int i = n-1; i > 0; -- i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                for ( int k = 0; k < W; ++ k ) {\n                    if ( i-2 >= 0 && D[i-2][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            if ( D[i-2][k] != inf && D[i][j] != inf )\n                                dp[i-2][k][l+1] = min( dp[i-2][k][l+1], dp[i][j][l]+(D[i-2][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                    if ( i-1 >= 0 && D[i-1][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            if ( D[i-1][k] != inf && D[i][j] != inf )\n                                dp[i-1][k][l] = min( dp[i-1][k][l], dp[i][j][l]+(D[i-1][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                }\n            }\n        }\n        int answer = inf;\n        for ( int i = 0; i < W; ++ i ) {\n            for ( int j = 0; j <= m; ++ j ) {\n                answer = min( answer, dp[0][i][j] );\n            }\n            for ( int j = 0; j < m; ++ j ) {\n                answer = min( answer, dp[1][i][j] );\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint z(int x){\n\tif(x<0)return -x;\n\treturn x;\n}\n\nint main(){\n\tconst long long int INF=1000000000000000000;\n\tlong long int n,m,k;\n\tstatic long long int a[1002],b[152][1002],dp[152][1002][102];\nwhile(1){\n\tfor(int i=0;i<152;i++)for(int j=0;j<1002;j++)for(k=0;k<102;k++)dp[i][j][k]=INF;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=0;j<k;j++){\n\t\t\tscanf(\"%d\",&a[j]);\n\t\t\tscanf(\"%d\",&b[i][a[j]]);\n\t\t\tfor(int c=0;c<=m;c++){\n\t\t\t\tif(i==1)dp[i][a[j]][c]=0;\n\t\t\t\telse {\n\t\t\t\t\tfor(int l=0;l<1002;l++){\n\t\t\t\t\t\tif(dp[i-1][l][c]!=INF){\n\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-1][l][c]+z(l-a[j])*(b[i][a[j]]+b[i-1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c!=0){\n\t\t\t\t\t\t\tif(dp[i-2][l][c-1]!=INF){\n\t\t\t\t\t\t\t\tdp[i][a[j]][c]=min(dp[i][a[j]][c],dp[i-2][l][c-1]+z(l-a[j])*(b[i][a[j]]+b[i-2][l]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ret=INF;\n\tfor(int i=0;i<1002;i++)for(int j=0;j<=m;j++)ret=min(ret,dp[n][i][j]);\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n \nint N, M;\n\nint main(void){\n\t\n\twhile(1){\n\t    vector<vector<ll>> table(160, vector<ll>(11, 0));\n        vector<vector<vector<ll>>> dp(160, vector<vector<ll>>(11, vector<ll>(80, LLONG_MAX)));\n    \tscanf(\"%d %d\", &N, &M);\n    \tif(N == 0 && M == 0) return 0;\n    \tfor(int i = 1; i <= N; ++i){\n    \t    int k; scanf(\"%d\", &k);\n    \t    for(int j = 0; j < k; ++j){\n    \t        int a, b; scanf(\"%d %d\", &a, &b);\n    \t        table[i][a] = b;\n    \t    }\n    \t}\n    \t\n        dp[0][1][0] = 0;\n        table[N + 1][1] = 1;\n        \n        for(int i = 0; i <= N; ++i){\n            for(int j = 1; j <= 10; ++j){\n                for(int m = 0; m <= M; ++m){\n                    \n                    if(dp[i][j][m] == LLONG_MAX) continue;\n                    \n                    for(int k = 1; k <= 10; ++k){\n                        if(!table[i + 1][k]) continue;\n                        ll cost = (i == 0 || i == N) ? 0 : (table[i][j] + table[i + 1][k]) * abs(j - k);\n                        dp[i + 1][k][m] = min(dp[i + 1][k][m], dp[i][j][m] + cost);\n                    }\n                    \n                    if(i == N) continue;\n                    for(int k = 1; k <= 10; ++k){\n                        if(!table[i + 2][k]) continue;\n                        ll cost = (i == 0 || i == N - 1) ? 0 : (table[i][j] + table[i + 2][k]) * abs(j - k);\n                        dp[i + 2][k][m + 1] = min(dp[i + 2][k][m + 1], dp[i][j][m] + cost);\n                    }\n                    \n                }\n            }\n        }\n        \n        ll ans = LLONG_MAX;\n        for(int m = 0; m <= M; ++m) ans = min(ans, dp[N + 1][1][m]);\n        printf(\"%lld\\n\", ans);\n\t}\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\n\nvoid solve(void){\nint dp[1005][101];\n\n for(int i=0;i<1005;i++)\n   for(int j=0;j<=m;j++)\n     dp[i][j]=INF;\n\n   dp[0][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n\tedge e=G[i][j];\n\tfor(int k=0;k<=m;k++){\n\t  if(i+1==e.to)dp[i+1][k]=min(dp[i+1][k],dp[i][k]+e.cost);\n\t  if(i+2==e.to && k!=0)dp[i+2][m-k]=min(dp[i+2][m-k],dp[i][m-k+1]+e.cost);\n\t}\n    }\n  }\n  int ans=INF;\n  for(int j=0;j<=m;j++)\n    ans=min(ans,dp[n+1][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0){\n\t      if(graph[i+1][l]>0){\n\t\te.to=i+1;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      \n\t      if(graph[i+2][l]>0){\n\t\te.to=i+2;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\n\t    if(i>=n){\n\t      if(i+1==n+1){\n\t\te.to=i+1;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      if(i+2==n+1){\n\t\te.to=i+2;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\n\t  }\n\t}\n      }\n    }\n    solve();\n    //cout << dijkstra(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdlib>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nclass State\n{\npublic:\n  int c, j, d, p;\n  State(int _c, int _j, int _d, int _p)\n    :c(_c), j(_j), d(_d), p(_p) {}\n  bool operator < (const State& st) const\n  {\n    return this->d > st.d;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if ((n|m) == 0)\n      break;\n\n    vector<vector<pair<int, int> > > s(n);\n    for (int i = 0; i < n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n\tint x, d;\n\tcin >> x >> d;\n\ts[i].push_back(make_pair(x, d));\n      }\n    }\n\n    priority_queue<State> que;\n    for (int i = 0; i < s[0].size(); ++i)\n      que.push(State(0, 0, 0, i));\n    vector<vector<vector<int> > > dp(n, vector<vector<int> >(10, vector<int>(m+1, INF)));\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if (st.c == n-1) {\n\tcout << st.d << endl;\n\tbreak;\n      }\n\n      if (dp[st.c][st.p][st.j] < st.d)\n\tcontinue;\n      dp[st.c][st.p][st.j] = st.d;\n\n      for (int i = 0; i < s[st.c+1].size(); ++i) {\n\tint danger = st.d + (s[st.c][st.p].second + s[st.c+1][i].second) * abs(s[st.c][st.p].first - s[st.c+1][i].first);\n\tif (dp[st.c+1][i][st.j] > danger) {\n\t  dp[st.c+1][i][st.j] = danger;\n\t  que.push(State(st.c+1, st.j, danger, i));\n\t}\n      }\n\n      if (st.j+1 <= m && st.c+2 < n) {\n\tfor (int i = 0; i < s[st.c+2].size(); ++i) {\n\t  int danger = st.d + (s[st.c][st.p].second + s[st.c+2][i].second) * abs(s[st.c][st.p].first - s[st.c+2][i].first);\n\t  if (dp[st.c+2][i][st.j+1] > danger) {\n\t    dp[st.c+2][i][st.j+1] = danger;\n\t    que.push(State(st.c+2, st.j+1, danger, i));\n\t  }\n\t}   \n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdlib>\nusing namespace std;\n\nint main(){\n\ttypedef pair<int,int> pii;\n\tint n, m, k, x, d, h, i, j;\n\tfor(; cin >> n >> m, n; ){\n\t\tvector<pair<int,int> > st[151];\n\t\tfor( i = 1; i <= n; i++ ){\n\t\t\tfor( cin >> k; k--; ){\n\t\t\t\tcin >> x >> d;\n\t\t\t\tst[i].push_back( make_pair( x, d ) );\n\t\t\t}\n\t\t}\n\n\t\tint dp[158][151][10];\n\t\tfill( **dp, *dp[158], 1e9 );\n\t\tfor( i = st[1].size(); i--; ){\n\t\t\tdp[m][1][i] = 0;\n\t\t}\n\t\tfor( i = st[2].size(); i--; ){\n\t\t\tdp[m-1][2][i] = 0;\n\t\t}\n\n\t\tfor( h = 2; h <= n; h++ ){\n\t\t\tfor( i = m; i >= 0; i-- ){\n\t\t\t\tfor( j = st[h].size(); j--; ){\n\t\t\t\t\tfor( k = st[h-1].size(); k--; ){\n\t\t\t\t\t\tx = dp[i][h-1][k]\n\t\t\t\t\t\t  + ( st[h][j].second + st[h-1][k].second )\n\t\t\t\t\t\t  * abs( st[h][j].first - st[h-1][k].first );\n\t\t\t\t\t\tdp[i][h][j] = min( dp[i][h][j], x );\n\t\t\t\t\t}\n\t\t\t\t\tfor( k = st[h-2].size(); k--; ){\n\t\t\t\t\t\tx = dp[i+1][h-2][k]\n\t\t\t\t\t\t  + ( st[h][j].second + st[h-2][k].second )\n\t\t\t\t\t\t  * abs( st[h][j].first - st[h-2][k].first );\n\t\t\t\t\t\tdp[i][h][j] = min( dp[i][h][j], x );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx = 1e9;\n\t\tfor( i = m; i >= 0; i-- ){\n\t\t\tfor( j = st[n].size(); j--; ){\n\t\t\t\tx = min( x, dp[i][n][j] );\n\t\t\t}\n\t\t}\n\t\tfor( i = m; i > 0; i-- ){\n\t\t\tfor( j = st[n-1].size(); j--; ){\n\t\t\t\tx = min( x, dp[i][n-1][j] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << x << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\n#define F 1145141145141919\nusing namespace std;\nint sw[16000],sh[16000];\nint be[160];\nlong long dp[80][16000];\nlong long MINN(long long a,long long b){\n\tif(a>b)return b;\n\treturn a;\n}\nint main(){\n    int n,m,k;\n    while(true){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<80;i++)for(int j=0;j<16000;j++)dp[i][j]=F;\n    cin>>k;\n    for(int i=0;i<k;i++){\n        cin>>sw[i]>>sh[i];\n        dp[0][i]=0;\n    }\n    be[0]=0,be[1]=k;\n    for(int i=1;i<n;i++){\n        cin>>k;\n        if(m)for(int j=0;j<k;j++)dp[1][j]=0;\n        be[i+1]=be[i]+k;\n        for(int j=0;j<k;j++)cin>>sw[j+be[i]]>>sh[j+be[i]];\n    }\n    for(int i=0;i<=m;i++){\n        for(int j=0;j<n-1;j++){\n            for(int f=be[j];f<be[j+1];f++){\n                for(int g=be[j+1];g<be[j+2];g++)dp[i][g]=MINN(dp[i][g],dp[i][f]+(abs(sw[f]-sw[g])*(sh[f]+sh[g])));\n                if(m-i&&n-2-j)for(int g=be[j+2];g<be[j+3];g++)dp[i+1][g]=MINN(dp[i+1][g],dp[i][f]+abs(sw[f]-sw[g])*(sh[f]+sh[g]));\n            }\n        }\n    }\n    long long ans=F;\n    for(int i=be[n-1];i<be[n];i++)for(int j=0;j<=m;j++)ans=MINN(ans,dp[j][i]);\n    if(n-1)for(int i=be[n-2];i<be[n-1];i++)for(int j=0;j<m;j++)ans=MINN(ans,dp[j][i]);\n    cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 1000000000\nint n,m;\nint d[80][150][10];\nint r[150][1000];\nint f[150][10];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint main(){\n\t//while(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(i=0;i<n;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\td[k][i][j]=INF;\n\t\t}\n\t\tfor(i=0;i<c[0];i++){\n\t\t\td[m][0][i]=0;\n\t\t}\n\t\tif(m>=1)for(j=0;j<c[1];j++){\n\t\t\td[m-1][1][j]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][k]=min(d[j][i][k],d[j+1][i-2][l]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][k]=min(d[j][i][k],d[j][i-1][l]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][j]);\n\t\t}\n\t\tfor(i=1;i<=m;i++)for(j=0;j<c[n-2];j++){\n\t\t\tans=min(ans,d[i][n-2][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n, m;\nvector<pair<int, int> > data[150];\nint dp[150][10];\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    for(int i=0;i<n+2;i++) data[i].clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      for(int j=0;j<a;j++){\n        int b, c;\n        cin >> b >> c;\n        data[i].push_back(pair<int, int>(b, c));\n      }\n    }\n    fill(dp[0], dp[150], INF);\n    for(int i=0;i<data[0].size();i++){\n      dp[0][i] = 0;\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<10;j++){\n        if(dp[i][j] != INF){\n          for(int l=0;l<=m;l++){\n            if(i+1+l >= n) continue;\n            for(int k=0;k<data[i+1+l].size();k++){\n              dp[i+1+l][k] = min(dp[i+1+l][k],\n                               dp[i][j] + (data[i][j].second + data[i+1+l][k].second) *\n                               (abs(data[i][j].first - data[i+1+l][k].first)));\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++){\n      for(int i=0;i<10;i++){\n        ans = min(ans, dp[n-1-j][i]);\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<24)\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[151][11][78];\nint solve(int h,int idx,int k){\n  if(h == n-1 || (h == n-2 && k != 0)) return 0;\n  if(dp[h][idx][k] != -1) return dp[h][idx][k];\n  int ret = INF;\n  int s = stone[h][idx].second;\n  int w = stone[h][idx].first;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    ret = min(ret,solve(h+1,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      ret = min(ret,solve(h+2,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][idx][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,i,k));\n    }\n    if(k != 0){\n      for(int i=0;i<stone[1].size();i++){\n\tans = min(ans,solve(1,i,k-1));\n      }\n    }\n    cout << ans << endl;\n    for(int i=0;i<n;i++){\n      stone[i].clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 10000\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint V,d[MAX_V][100],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<152;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<100;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second ==0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=1000000;\n  for(int i=0;i<10;i++)\n    ans=min(d[n-1][i],ans);\n \n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[152][152];\n\n  while(cin >> n >> m,n|m){\n    for(int i=0;i<152;i++)\n      for(int j=0;j<152;j++)\n\tgraph[i][j]=0;\n\n    int mx=0;\n    for(int i=0;i<n;i++){\n      cin >> k;\n\n      for(int j=0;j<k;j++){\n\tcin >> x >> y;\n      mx=max(mx,x);\n\tgraph[i][x]=y;\n      }\n    }\n    edge e;\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<=mx;j++){\n\tif(graph[i][j]>0){\n\t  for(int l=0;l<=mx;l++){\n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n  cout << dijkstra(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nconst int inf = 3e17;\n\nint dp[155][15][100];\nint stone[155][15];\nint X[155][15];\n\n\nsigned main()\n{\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        rep(i, n+5) rep(j, 15) stone[i][j] = inf;\n        rep(i, n+5) rep(j, 15) rep(k, 100) dp[i][j][k] = inf;\n\n        rep(i, n) {\n            int k; cin >> k;\n            rep(j, k) {\n                int x, d; cin >> x >> d;\n\n                X[i][j] = x;\n\n                stone[i][j] = d;\n                if (i == 0) dp[0][x][0] = 0;\n                if (i == 1) dp[1][x][1] = 0;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 11; ++j) {\n                if (stone[i][j] == inf) continue;\n\n                for (int k = 0; k <= m; ++k) {\n                    if (k < m) {\n                        rep(l, 11) {\n                            if (stone[i + 2][l] == inf) continue;\n\n                            dp[i + 2][l][k + 1] = min(\n                                    dp[i + 2][l][k + 1],\n                                    dp[i][j][k] + (stone[i][j] + stone[i + 2][l]) * abs(X[i][j] - X[i + 2][l])\n                                    );\n                        }\n                    }\n\n                    rep(l, 11) {\n                        if (stone[i + 1][l] == inf) continue;\n\n                        dp[i + 1][l][k] = min(\n                                dp[i + 1][l][k],\n                                dp[i][j][k] + (stone[i][j] + stone[i + 1][l]) * abs(X[i][j] - X[i + 1][l])\n                                );\n                    }\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j <= m; ++j) {\n                mi = min(mi, dp[n - 1][i][j]);\n            }\n        }\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j <= m - 1; ++j) {\n                mi = min(mi, dp[n - 2][i][j]);\n            }\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n#include<utility>\nusing namespace std;\n#define INF (1<<30)\n\nint dp[150][10][150/2+1];\nvector<pair<int,int> > stone[150];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tfill_n((int*)dp,sizeof(dp)/sizeof(int),INF);\n\t\tfill_n((int*)dp[0],sizeof(dp[0])/sizeof(int),0);\n\t\t\n\t\tfill_n((int*)stone,sizeof(stone)/sizeof(int),0);\n\t\tfor(int h=0;h<n;h++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tstone[h].resize(k);\n\t\t\tfor(int i=0;i<k;i++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>stone[h][i].first>>stone[h][i].second;\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int h=0;h<n;h++){\n\t\t\tfor(int i=0;i<stone[h].size();i++){\n\t\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\t\tint v=dp[h][i][j];\n\t\t\t\t\tif(h+1<n){\n\t\t\t\t\t\tfor(int k=0;k<stone[h+1].size();k++){\n\t\t\t\t\t\t\tdp[h+1][k][j]=min(dp[h+1][k][j]\n\t\t\t\t\t\t\t\t,v+(stone[h][i].second+stone[h+1][k].second)*abs(stone[h][i].first-stone[h+1][k].first));\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}else ans=min(ans,v);\n\t\t\t\t\tif(h+2<n && j<m){\n\t\t\t\t\t\tfor(int k=0;k<stone[h+2].size();k++){\n\t\t\t\t\t\t\tdp[h+2][k][j+1]=min(dp[h+2][k][j+1]\n\t\t\t\t\t\t\t\t,v+(stone[h][i].second+stone[h+2][k].second)*abs(stone[h][i].first-stone[h+2][k].first));\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}else if(j<m)ans=min(ans,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint***dp;\nint N,M;\n\nstruct Info{\n\tInfo(int arg_col,int arg_value){\n\t\tcol = arg_col;\n\t\tvalue = arg_value;\n\t}\n\tint col,value;\n};\n\nint calc(Info left,Info right){\n\treturn (left.value+right.value)*abs(left.col-right.col);\n}\n\nvoid func(){\n\n\tfor(int i = 1; i <= N+1; i++){\n\t\tfor(int k = 0; k < 10; k++){\n\t\t\tfor(int p = 0; p <= M; p++){\n\t\t\t\tdp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<Info> V[N+1];\n\n\tint num,tmp_col,tmp_value;\n\n\tfor(int row = 1; row <= N; row++){\n\t\tscanf(\"%d\",&num);\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d %d\",&tmp_col,&tmp_value);\n\t\t\tV[row].push_back(Info(tmp_col,tmp_value));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < V[1].size();i++){\n\t\tdp[1][i][M] = 0;\n\t}\n\n\tif(M > 0){\n\t\tfor(int i = 0; i < V[2].size();i++){\n\t\t\tdp[2][i][M-1] = 0;\n\t\t}\n\t}\n\n\tint tmp;\n\n\tfor(int row = 1; row <= N-2; row++){\n\t\tfor(int a = 0; a <= M; a++){\n\t\t\tfor(int b = 0; b < V[row].size();b++){\n\n\n\t\t\t\tfor(int c = 0; c < V[row+1].size();c++){\n\t\t\t\t\ttmp = calc(V[row][b],V[row+1][c]);\n\t\t\t\t\tdp[row+1][c][a] = min(dp[row+1][c][a],dp[row][b][a]+tmp);\n\t\t\t\t}\n\n\t\t\t\tif(a != 0){\n\n\t\t\t\t\tfor(int c = 0; c < V[row+2].size();c++){\n\t\t\t\t\t\ttmp = calc(V[row][b],V[row+2][c]);\n\t\t\t\t\t\tdp[row+2][c][a-1] = min(dp[row+2][c][a-1],dp[row][b][a]+tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\tfor(int a = 0; a <= M; a++){\n\t\tfor(int b = 0; b < V[N-1].size();b++){\n\n\n\t\t\tfor(int c = 0; c < V[N].size();c++){\n\t\t\t\ttmp = calc(V[N-1][b],V[N][c]);\n\t\t\t\tdp[N][c][a] = min(dp[N][c][a],dp[N-1][b][a]+tmp);\n\t\t\t}\n\n\t\t\tif(a != 0){\n\n\t\t\t\tdp[N+1][0][a-1] = min(dp[N+1][0][a-1],dp[N-1][b][a]);\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tfor(int a = 0; a <= M; a++){ //75\n\t\tfor(int b = 0; b < V[N].size();b++){\n\n\t\t\tdp[N+1][0][a] = min(dp[N+1][0][a],dp[N][b][a]);\n\n\t\t}\n\t}\n\n\n\tint minimum = BIG_NUM;\n\tfor(int k = 0; k <= M; k++){\n\t\tminimum = min(minimum,dp[N+1][0][k]);\n\t}\n\n\tprintf(\"%d\\n\",minimum);\n}\n\nint main(){\n\n\tdp = new int**[152];\n\tfor(int i = 1; i <= 151; i++){\n\t\tdp[i] = new int*[10];\n\t\tfor(int k = 0; k < 10; k++){\n\t\t\tdp[i][k] = new int[76];\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nint danger[155][1010];\nvector<int> X[155];\nint dp[155][1010][80];\n\nconst int inf = 1 << 25;\n\nint solve(int col, int row, int jump)\n{\n  if(col >= n-1) return 0;\n  if(jump > m) return inf;\n  int& ret = dp[col][row][jump];\n  if(~ret) return ret;\n  ret = inf;\n  for(int i = 0; i < X[col+1].size(); i++){\n    if(danger[col+1][X[col+1][i]] == inf) continue;\n    int D = (danger[col][row] + danger[col+1][X[col+1][i]]) * abs(row - X[col+1][i]);\n    ret = min(ret, solve(col + 1, X[col+1][i], jump) + D);\n  }\n  if(jump < m && col < n-1){\n    for(int i = 0; i < X[col+2].size(); i++){\n      if(danger[col+2][X[col+2][i]] == inf) continue;\n      int D = (danger[col][row] + danger[col+2][X[col+2][i]]) * abs(row - X[col+2][i]);\n      ret = min(ret, solve(col + 2, X[col+2][i], jump + 1) + D);\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 155; i++){\n      for(int j = 0; j < 11; j++) danger[i][j] = inf;\n    }\n    for(int i = 0; i < n; i++){\n      int k; cin >> k;\n      for(int j = 0; j < k; j++){\n\tint x, d;\n\tcin >> x >> d;\n\t--x;\n\tdanger[i][x] = d;\n\tX[i].push_back(x);\n      }\n    }\n    memset(dp, -1, sizeof(dp));\n    int ans = inf;\n    for(int i = 0; i < X[0].size(); i++){\n      if(danger[0][X[0][i]] == inf) continue;\n      ans = min(ans, solve(0, X[0][i], 0));\n    }\n    if(m > 0 && n > 1){\n      for(int i = 0; i < X[1].size(); i++){\n\tif(danger[1][X[1][i]] == inf) continue;\n\tans = min(ans, solve(1, X[1][i], 1));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[150][10][77];\nint stones[150][10][2];\nint col[150];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tcin >> stones[i][j][0] >> stones[i][j][1];\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tint x_now = stones[i][j][0], d_now = stones[i][j][1];\n\tREP(m, M+1) {\n\t  if (dp[i][j][m] == INF) continue;\n\t  REP(k, col[i+1]) {\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + (d_now + stones[i+1][k][1]) * abs(x_now - stones[i+1][k][0]));\n\t  }\n\t  if (i < N-2 && m < M) {\n\t    REP(k, col[i+2]) {\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + (d_now + stones[i+2][k][1]) * abs(x_now - stones[i+2][k][0]));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int INF = (1<<29);\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n || m)){\n    int dp[150][10][80], a[150][10], x[150][10];\n    for(int i=0;i<150;i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<80;k++) dp[i][j][k] = INF;\n\ta[i][j] = INF;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int k;\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint b,c;\n\tcin >> b >> c;\n\tx[i][j] = b;\n\ta[i][j] = c;\n      }\n    }\n    for(int i=0;i<10;i++) dp[0][i][0] = 0;\n\n    for(int i=0;i<n-1;i++){\n      for(int l=0;l<=m;l++){\n\tfor(int j=0;j<10;j++){\n\t  if(a[i][j] == INF) continue;\n\t  for(int k=0;k<10;k++){\n\t    if(a[i+1][k] == INF) continue;\n\t    dp[i+1][k][l] = min(dp[i+1][k][l],dp[i][j][l] + (a[i][j] + a[i+1][k]) * (abs(x[i+1][k]-x[i][j])));\n\t  }\n\t  if(i < n - 2 && l != m){\n\t    for(int k=0;k<10;k++){\n\t      if(a[i+2][k] == INF) continue;\n\t      dp[i+2][k][l+1] = min(dp[i+2][k][l+1],dp[i][j][l] + (a[i][j] + a[i+2][k]) * (abs(x[i+2][k]-x[i][j])));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-1][k][j]);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct S{\n\tint x,y,r;\n};\nint main(){\n\tint m,n,t,u,ans,INF=1<<30;\n\twhile(cin>>n>>m,n){\n\t\tint d[n][10],cost[n][10][m+1],x[n][10];\n\t\trep(i,n){\n\t\t\trep(j,10){\n\t\t\t\td[i][j]=x[i][j]=0;\n\t\t\t\trep(k,m+1)cost[i][j][k]=INF;\n\t\t\t}\n\t\t\tcin>>t; rep(j,t)cin>>x[i][j],cin>>d[i][j];\n\t\t}\n\t\tqueue<S> F; S s; ans=INF;\n\t\trep(i,10)rep(j,(m?2:1))if(d[j][i]){\n\t\t\ts.x=i,s.y=j,s.r=m-j;\n\t\t\tF.push(s),cost[j][i][m-j]=0;\n\t\t}\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.front(); F.pop();\n\t\t\trep(j,(cs.r?2:1)){\n\t\t\t\tif(cs.y+j+1<n)rep(i,10)if(d[cs.y+j+1][i]){\n\t\t\t\t\ts=cs; s.y=cs.y+j+1,s.x=i,s.r-=j;\n\t\t\t\t\tu=x[s.y][i]-x[cs.y][cs.x];\n\t\t\t\t\tt=cost[cs.y][cs.x][cs.r]+(d[cs.y][cs.x]+d[s.y][i])*(u>0?u:-u);\n\t\t\t\t\tif(cost[s.y][i][s.r]>t)cost[s.y][i][s.r]=t,F.push(s);\n\t\t\t\t}\n\t\t\t\tif(cs.y+j+1>=n&&ans>cost[cs.y][cs.x][cs.r])ans=cost[cs.y][cs.x][cs.r];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cmath>\n#define INF INT_MAX\nusing namespace std;\n\nint n, m;\nint river_x[150][10];\nint river_d[150][10];\nint k[151];\nint dp[151][10][76];\nint dist(int y1, int x1, int y2, int x2){\n    if(y2==n) return 0;\n    return (river_d[y1][x1]+river_d[y2][x2])*\n            abs(river_x[y1][x1]-river_x[y2][x2]);\n}\nint main(){\n    int x, d;\n    int a, b;\n    cin >> n >> m;\n    while(n || m){\n        for(int i=0;i<n;i++){ \n            cin >> k[i];\n            for(int j=0;j<k[i];j++){\n                cin >> x >> d;\n                x--;\n                river_x[i][j] = x;\n                river_d[i][j] = d;\n            }\n        }\n        for(int i=0;i<2;i++){\n            for(int j=0;j<k[i];j++){\n                for(int l=i;l<=m;l++){\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        for(int j=0;j<k[1];j++){\n            dp[1][j][0] = INF;\n        }\n        for(int i=2;i<n;i++){\n            for(int j=0;j<k[i];j++){\n                for(int l=0;l<=m;l++){\n                    dp[i][j][l] = INF;\n                }\n            }\n        }\n        k[n] = 1;\n        for(int i=0;i<n-1;i++){\n            for(int j=0;j<k[i];j++){\n                for(int l=0;l<=m;l++){\n                    int a=INF;\n                    int b;\n                    if(l<m && i<n-2){\n                        for(int p=0;p<k[i+2];p++){\n                            if(a > (a=dist(i, j, i+2, p))) b = p;\n                        }\n                        dp[i+2][b][l+1] = min(a+dp[i][j][l], dp[i+2][b][l+1]);\n                    }\n                    a=INF;\n                    for(int p=0;p<k[i+1];p++){\n                        if(a > (a=dist(i, j, i+1, p))) b = p;\n                    }\n                    dp[i+1][b][l] = min(a+dp[i][j][l], dp[i+1][b][l]);\n                }\n            }\n        }\n        a = INF;\n        for(int l=0;l<=m;l++){\n            a = min(a, dp[n-1][0][l]);\n        }\n        cout << a << endl;\n        cin >> n >> m;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ LL to, cost; edge(int t, LL c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\nint bitcount(int a)\n{\n\tint ret = 0;\n\twhile (a != 0) { ret++; a = (a - 1) & a; }\n\treturn ret;\n}\n\nint dp[151][1001][152];\nint stage[151][1001];\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m && n)\n\t{\n\t\trep(i, n) rep(j, 1001) stage[i][j] = INF;\n\t\tint width = 0;\n\t\trep(i, n)\n\t\t{\n\t\t\tint num; cin >> num;\n\t\t\trep(j, num)\n\t\t\t{\n\t\t\t\tint idx, slip; cin >> idx >> slip;\n\t\t\t\twidth = max(width, idx);\n\t\t\t\tstage[i][idx - 1] = slip;\n\t\t\t}\n\t\t}\n\t\trep(i, n + 1) rep(j, width) rep(k, m + 1) dp[i][j][k] = INF;\n\t\trep(i, width) dp[0][i][0] = stage[n][i] = 0;\n\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, width)\n\t\t\t{\n\t\t\t\trep(k, width)\n\t\t\t\t{\n\t\t\t\t\trep(l, m + 1) if (dp[i][j][l] < INF && stage[i][j] < INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (stage[i][j] + stage[i + 1][k]) * abs(j - k));\n\t\t\t\t\t\tif (i + 2 <= n)\n\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (stage[i][j] + stage[i + 2][k]) * abs(j - k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, width) rep(j, m + 1) ans = min(ans, dp[n][i][j]);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\nconst long long int INF=10000000000;\nint st[152],stx[152][11],sts[152][11];\nlong long int dp[152][11][78];\n\nint main(void){\n\tint n,m;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(st,0,sizeof(st));\n\t\tmemset(stx,0,sizeof(stx));\n\t\tmemset(sts,0,sizeof(sts));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<152;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst[0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&st[i]);\n\t\t\tfor(int j=0;j<st[i];j++){\n\t\t\t\tscanf(\"%d%d\",&stx[i][j],&sts[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<st[0];i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tif(m>=1)for(int i=0;i<st[1];i++){\n\t\t\tdp[1][i][1]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tfor(int k=0;k<st[i];k++){\n\t\t\t\t\tfor(int l=0;l<st[i-1];l++){\n\t\t\t\t\t\tdp[i][k][j]=min(dp[i][k][j],dp[i-1][l][j]+(sts[i][k]+sts[i-1][l])*abs(stx[i][k]-stx[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=m && i>=2)for(int l=0;l<st[i-2];l++){\n\t\t\t\t\t\tdp[i][k][j+1]=min(dp[i][k][j+1],dp[i-2][l][j]+(sts[i][k]+sts[i-2][l])*abs(stx[i][k]-stx[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans=INF;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<st[n-1];k++){\n\t\t\t\tans=min(ans,dp[n-1][k][j]);\n\t\t\t}\n\t\t\tif(j!=m)for(int k=0;k<st[n-2];k++){\n\t\t\t\tans=min(ans,dp[n-2][k][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n\n#define N 200\n#define ACOL 100\n#define JUMP 100\n\nconst int infty=1<<29;\n\nusing namespace std;\n\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\n\nint dijkstra(int n,int m,\n\t     const vector< vector<int> > &C,\n\t     const vector< vector<int> > &D)\n{\n  static bool vis[N][ACOL][JUMP];\n  static int A[N][ACOL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<ACOL;++j)for(int k=0;k<JUMP;++k){vis[i][j][k]=false;A[i][j][k]=infty;}\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  \n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    vis[s.r][s.c][s.left]=true;\n    if(s.r==n+1||s.r==n+2){continue;}\n    for(int k=1;k<=2;++k){\n      for(int i=0;i<C[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=i,nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(C[s.r][s.c]-C[nxr][nxc]),nxj=s.left-(k-1);\n\tif(s.r==0||nxr==n+1||nxr==n+2)nxcost=s.cost;if(nxj<0)continue;\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc][nxj]&&A[nxr][nxc][nxj]>nxcost){A[nxr][nxc][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  int ret=infty;\n  for(int i=0;i<JUMP;++i){for(int j=0;j<ACOL;++j){\n      ret=min(A[n+1][j][i],min(A[n+2][j][i],ret));\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(cin.eof()||n==0&&m==0)break;\n    assert(2<=n&&n<=150&&0<=m&&m<=(n+1)/2);\n    vector< vector<int> > D(n+3);D[n+1].push_back(0);D[n+2].push_back(0);\n    vector< vector<int> > C(n+3);C[n+1].push_back(0);C[n+2].push_back(0);\n    for(int i=0;i<n;++i){\n      int k;\n      cin>>k;\n      assert(0<=k&&k<=10);\n      for(int j=0;j<k;++j){\n\tint col,danger;\n\tcin>>col>>danger;\n\tassert(1<=col&&col<=1000&&1<=danger&&danger<=1000);\n\tC[i+1].push_back(col);\n\tD[i+1].push_back(danger);\n      }\n    }\n    //cout<<dijkstra(n,m,C,D)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint memo[80][150][20];\n\nint main(){\n  int n,m;\n  while(n=getInt(), m=getInt(), n+m){\n    vector<vector<pair<int,int> > > stone(n);\n    memset(memo, -1, sizeof(memo));\n    REP(i,n){\n      int num = getInt();\n      stone[i] = vector<pair<int,int> >(num);\n      REP(j,num){\n        stone[i][j].f = getInt();\n        stone[i][j].s = getInt();\n      }\n    }\n\n    REP(i,stone[0].size()) memo[m][0][i] = 0;\n    if(m != 0) REP(i,stone[1].size()) memo[m-1][1][i] = 0;\n\n    REP(i,n-1){\n      FOR(it,stone[i]){\n        int j = it->f;\n        int s = it->s;\n        int idxj = it - stone[i].begin();\n        REP(k,m+1){\n          if(memo[k][i][idxj] != -1){\n            FOR(it2,stone[i+1]){\n              int jj = it2->f;\n              int ss = it2->s;\n              int idxjj = it2 - stone[i+1].begin();\n              int mm = memo[k][i][idxj];\n\n              if(memo[k][i+1][idxjj] == -1)\n                memo[k][i+1][idxjj] = mm + (s + ss)*abs(j - jj);\n              else\n                memo[k][i+1][idxjj] = min(memo[k][i+1][idxjj], mm + (s + ss)*abs(j - jj));\n            }\n\n            if(k != 0 && i != n-2){\n              FOR(it2,stone[i+2]){\n                int jj = it2->f;\n                int ss = it2->s;\n                int idxjj = it2 - stone[i+2].begin();\n                int mm = memo[k][i][idxj];\n\n                if(memo[k-1][i+2][idxjj] == -1)\n                  memo[k-1][i+2][idxjj] = mm + (s + ss)*abs(j - jj);\n                else\n                  memo[k-1][i+2][idxjj] = min(memo[k][i+2][idxjj], mm + (s + ss)*abs(j - jj));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    //puts(\"0:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[0][i][j]); puts(\"\"); }\n    //puts(\"1:\"); REP(i,n) { REP(j,n) printf(\"%2d \",memo[1][i][j]); puts(\"\"); }\n\n    int ans = INT_MAX;\n    REP(j,20) REP(k,m+1){\n      if(memo[k][n-1][j] != -1)\n        ans = min(ans, memo[k][n-1][j]);\n      if(k != 0){\n        if(memo[k][n-2][j] != -1)\n          ans = min(ans, memo[k][n-2][j]);\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<string>\n#include<stack>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define fr first\n#define sc second\n#define INF INT_MAX\ntypedef pair<int,int> Pi;\ntypedef pair< Pi,pair<Pi,int> > P;\nstruct Edge{\n  int to,denger;\n  Edge(){}\n  Edge(int to,int denger):to(to),denger(denger){};\n};\nint n,m;\nint m_cost[151][11][(151+1)/2+1];\nvector<vector<Edge> > info;\nint Dijkstra();\nint main(){\n  while(cin >> n >> m && n||m){\n    info.resize(n);\n    for(int i=0,k;i<n;i++){\n      cin >> k;\n      for(int j=0,t,d;j<k;j++){\n        cin >> t >> d;\n        info[i].push_back(Edge(t,d));\n      }\n    }\n    cout << Dijkstra() << endl;\n    info.clear();\n  }\n}\nint Dijkstra(){\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      for(int k=0;k<(n+1)/2+1;k++){\n        m_cost[i][j][k] = INF;\n      }\n    }\n  }\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0,l=info[0].size();i<l;i++){\n    que.push(P(Pi(0,m),make_pair(Pi(0,info[0][i].to),info[0][i].denger)));\n    m_cost[0][i][m] = 0;\n  }\n  if(m != 0){\n    for(int i=0,l=info[1].size();i<l;i++){\n      que.push(P(Pi(0,m-1),make_pair(Pi(1,info[1][i].to),info[1][i].denger)));\n      m_cost[1][i][m-1] = 0;\n    }\n  }\n  while(!que.empty()){\n    P p = que.top();\n    int den = p.fr.fr,limit = p.fr.sc,slip=p.sc.sc;\n    Pi pt = Pi(p.sc.fr.fr,p.sc.fr.sc);\n    que.pop();\n    if(pt.fr + 1 >= n) return den;\n    for(int j=1;j<3;j++){\n      if(j==2 && limit == 0) break;\n      if(j==2 && pt.fr + 1 == n) break;\n      if(j==2 && pt.fr + 2 == n) return den;\n      if(j==1 && pt.fr + 1 == n) return den;\n      for(int i=0,l=info[pt.fr+j].size();i<l;i++){\n        int next_now = info[pt.fr+j][i].to;\n        int next_den = info[pt.fr+j][i].denger;\n        int hmhm = den + (slip + next_den) * abs(next_now - pt.sc);\n        if(hmhm < m_cost[pt.fr+j][i][limit-(j-1)]){\n          m_cost[pt.fr+j][i][limit-(j-1)] = hmhm;\n          que.push(P(Pi(hmhm,limit-(j-1)),make_pair(Pi(pt.fr+j,next_now),next_den)));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include<fstream>\n#include <unordered_map>  \nusing namespace std;\n#define eps 0.00000001\n#define LONG_INF 10000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define f(n) for(int i=0;i<n;++i)\n#define REP(i,n) for(long long i = 0;i < n;++i)\n\t\tlong long dp[200][100][30] = {};\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n == 0&&m == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i = 0;i < 200;++i){\n\t\t\tfor(int j = 0;j < 100;++j){\n\t\t\tfor(int q = 0;q < 30;++q){\n\t\t\t\tdp[i][j][q] = LONG_INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<long long,long long>> wow[200];\n\t\tfor(int i = 0;i < n;++i){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tREP(q,t){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\twow[i+1].push_back(make_pair(a,b));\n\t\t\t}\n\t\t}\n\t\tfor(int q = 0;q < wow[1].size();++q){\n\t\t\tdp[1][0][q] = 0;\n\t\t}\n\t\tif(m != 0){\n\t\t\tfor(int q = 0;q < wow[2].size();++q){\n\t\t\t\tdp[2][1][q] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n-1;++i){\n\t\t\tfor(int q = 0;q < wow[i].size();++q){\n\t\t\t\tfor(int j = 0;j <= m;++j){\n\t\t\t\t\tfor(int t = 0;t < wow[i+1].size();++t){\n\t\t\t\t\t\t\tdp[i+1][j][t] = min(dp[i+1][j][t],dp[i][j][q] + (wow[i][q].second+wow[i+1][t].second)*abs(wow[i][q].first - wow[i+1][t].first));\n\t\t\t\t\t}\n\t\t\t\t\tif(j < m&&i != n-1){\n\t\t\t\t\t\tfor(int t = 0;t < wow[i+2].size();++t){\n\t\t\t\t\t\t\t\tdp[i+2][j+1][t] = min(dp[i+2][j+1][t],dp[i][j][q] + (wow[i][q].second+wow[i+2][t].second)*abs(wow[i][q].first - wow[i+2][t].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ans = LONG_INF;\n\t\tfor(int i = 0;i < wow[n].size();++i){\n\t\t\t\tfor(int j = 0;j <= m;++j){\n\t\t\t\t\tans = min(ans,dp[n][j][i]);\t\n\t\t\t\t}\n\t\t}\n\t\t\tfor(int i = 0;i < wow[n-1].size();++i){\n\t\t\t\tfor(int j = 0;j < m;++j){\n\t\t\t\t\tans = min(ans,dp[n-1][j][i]);\t\n\t\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint abst(int x){\n    return (x>=0)? x : -x;\n}\n\nint main(){\n    int n,m,ki,min,tmp;\n    int i,j,k,l;\n    printf(\"STILL ALIVE\\n\");\n    scanf(\"%d %d\",&n,&m);\n    while(n||m){\n        int river[n+1][1001][2],risk[n+1][1001][m];//?????°??£?¨???????????????\\??????????????????????????????\n        for(i=1;i<=n;i++){\n            scanf(\"%d\",&ki);\n            river[i][0][0] = ki;\n            for(j=1;j<=ki;j++){\n                scanf(\"%d %d\",&river[i][j][0],&river[i][j][1]);\n            }\n        }\n        for(j=1;j<=river[1][0][0];j++){\n            for(k=0;k<=m;k++){\n                risk[1][j][k] = 0;\n            }\n        }\n        for(i=2;i<=n;i++){\n            for(j=1;j<=river[i][0][0];j++){\n                for(k=0;k<=m;k++){\n                    min = risk[i-1][1][k] + (river[i-1][1][1]+river[i][j][1])*abst(river[i-1][1][0]-river[i][j][0]);\n                    for(l=2;l<=river[i-1][0][0];l++){\n                        tmp = risk[i-1][l][k] + (river[i-1][l][1]+river[i][j][1])*abst(river[i-1][l][0]-river[i][j][0]);\n                        if(tmp<min)min = tmp;\n                    }\n                    if(i-2&&k){\n                        for(l=1;l<=river[i-1][0][0];l++){\n                            tmp = risk[i-2][l][k-1] + (river[i-2][l][1]+river[i][j][1])*abst(river[i-2][l][0]-river[i][j][0]);\n                            if(tmp<min)min = tmp;\n                        }\n                    }\n                    risk[i][j][k] = min;\n                }\n            }\n        }\n        min = risk[n][1][m];\n        for(j=2;j<=river[n][0][0];j++){\n            tmp = risk[n][j][m];\n            if(min>tmp)min = tmp;\n        }\n        printf(\"%d\\n\",min);\n        scanf(\"%d %d\",&n,&m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\nlong long int INF=10000000000;\nint st[152],stx[152][11],sts[152][11];\nlong long int dp[152][11][78];\n\nint main(void){\n\tint n,m;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(st,0,sizeof(st));\n\t\tmemset(stx,0,sizeof(stx));\n\t\tmemset(sts,0,sizeof(sts));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<152;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst[0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&st[i]);\n\t\t\tfor(int j=0;j<st[i];j++){\n\t\t\t\tscanf(\"%d%d\",&stx[i][j],&sts[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<st[0];i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tif(m>=1)for(int i=0;i<st[1];i++){\n\t\t\tdp[1][i][1]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tfor(int k=0;k<st[i];k++){\n\t\t\t\t\tfor(int l=0;l<st[i-1];l++){\n\t\t\t\t\t\tdp[i][k][j]=min(dp[i][k][j],dp[i-1][l][j]+(sts[i][k]+sts[i-1][l])*abs(stx[i][k]-stx[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=m && i>=2)for(int l=0;l<st[i-2];l++){\n\t\t\t\t\t\tdp[i][k][j+1]=min(dp[i][k][j+1],dp[i-2][l][j]+(sts[i][k]+sts[i-2][l])*abs(stx[i][k]-stx[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans=INF;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<st[n-1];k++){\n\t\t\t\tans=min(ans,dp[n-1][k][j]);\n\t\t\t}\n\t\t\tif(j!=m)for(int k=0;k<st[n-2];k++){\n\t\t\t\tans=min(ans,dp[n-2][k][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nint n, m;\nint l[150];\nint k[150][10][2];\nint dp[150][10][75];\nint INF = 10e8+7;\n\nint main(){\n\twhile(1){\n\t\tmemset(k, 0, sizeof(k));\n\t\tmemset(dp, INF, sizeof(dp));\n\t\tfill(dp[0][0], dp[149][0], INF);\n\t\tint ans = INF;\n\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d\", &l[i]);\n\t\t\tfor(int j=0; j<l[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &k[i][j][0], &k[i][j][1]);\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i=0; i<n; i++){\n\t\t\tprintf(\"%d\\t\", l[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<l[i]; j++){\n\t\t\t\tprintf(\"%d %d\\t\", k[i][j][0], k[i][j][1]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\n\t\tfor(int i=0; i<l[0]; i++)\n\t\t\tdp[0][i][0] = 0;\n\n\t\tfor(int i=0; i<l[1]; i++)\n\t\t\tdp[1][i][1] = 0;\n\n\t\tfor(int i=0; i<l[1]; i++){\n\t\t\tfor(int j=0; j<l[0]; j++){\n\t\t\t\tdp[1][i][0] = min(dp[1][i][0], (k[1][i][1] + k[0][j][1]) * abs(k[1][i][0] - k[0][j][0]));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=2; i<n; i++){ //gyou\n\t\t\tfor(int i1=0; i1<l[i]; i1++){ //nowishi\n\t\t\t\tfor(int i2=0; i2<l[i-1]; i2++){ //previshi, ichitobi0\n\t\t\t\t\tdp[i][i1][0] = min(dp[i][i1][0], dp[i-1][i2][0] + (k[i-1][i2][1] + k[i][i1][1]) * abs(k[i][i1][0] - k[i-1][i2][0]));\n\t\t\t\t}\n\t\t\t\tfor(int i2=0; i2<l[i-2]; i2++){ //previshi, ichitobiari\n\t\t\t\t\tfor(int i3=1; i3<m+1; i3++){ //ichitobi\n\t\t\t\t\t\tdp[i][i1][i3] = min(dp[i][i1][i3], dp[i-2][i2][i3-1] + (k[i-2][i2][1] + k[i][i1][1]) * abs(k[i-2][i2][0] - k[i][i1][0]));\n\t\t\t\t\t\tdp[i][i1][i3] = min(dp[i][i1][i3], dp[i-1][i2][i3] + (k[i-1][i2][1] + k[i][i1][1]) * abs(k[i-1][i2][0] - k[i][i1][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<l[n-1]; i++){\n\t\t\tfor(int j=0; j<m+1; j++){\n\t\t\t\tans = min(ans, dp[n-1][i][j]);\n//\t\t\t\tif(ans == 12) printf(\"%d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<l[n-2]; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tans = min(ans, dp[n-2][i][j]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1 << 29;\n\nint dist[160][160][80];\n\nstruct S {\n\tint x, y, jump, d;\n\tbool operator <(const S& x) const {\n\t\treturn d > x.d;\n\t}\n};\n\nint rec(S s) {\n\treturn dist[s.y][s.x][s.jump];\n}\n\nvoid save(S s) {\n\tdist[s.y][s.x][s.jump] = s.d;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tvector<int> c[160];\n\t\tvector<int> x[160];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\tint xx, cc;\n\t\t\t\tcin >> xx >> cc;\n\t\t\t\txx--;\n\t\t\t\tx[i].push_back(xx);\n\t\t\t\tc[i].push_back(cc);\n\t\t\t}\n\t\t}\n\n\t\tfill((int*)begin(dist), (int*)end(dist), INF);\n\t\tpriority_queue<S> q;\n\t\tfor(int i = 0; i < x[0].size(); i++) {\n\t\t\tS s = { i, 0, 0, 0 };\n\t\t\tq.push(s);\n\t\t\tsave(s);\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile(q.size()) {\n\t\t\tS s = q.top();\n\t\t\tq.pop();\n\t\t\tif(rec(s) < s.d) continue;\n\t\t\tif(s.y == n) {\n\t\t\t\tans = s.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= 2; i++) {\n\t\t\t\tif(s.jump == m && i == 2) break;\n\t\t\t\tif(s.y + i > n) break;\n\t\t\t\tint nj = s.jump + (i == 2);\n\t\t\t\tif(s.y + i == n) {\n\t\t\t\t\tS ns = { 0, s.y + i, nj, s.d };\n\t\t\t\t\tif(rec(ns) > s.d) {\n\t\t\t\t\t\tq.push(ns);\n\t\t\t\t\t\tsave(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < x[s.y + i].size(); j++) {\n\t\t\t\t\t\tint nx = x[s.y + i][j];\n\t\t\t\t\t\tint cost = (c[s.y][s.x] + c[s.y + i][j]) * abs(x[s.y][s.x] - nx);\n\t\t\t\t\t\tS ns = { j, s.y + i, nj, s.d + cost };\n\t\t\t\t\t\tif(rec(ns) > ns.d) {\n\t\t\t\t\t\t\tq.push(ns);\n\t\t\t\t\t\t\tsave(ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nint main() {\n    while(true) {\n        int n,m; scanf(\"%d%d\", &n, &m);\n        if(n==0) break;\n\n        static int stones_at[150][10];\n        static int stones_slip[150][10];\n        static int stones_len[150];\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d\", stones_len+i);\n            for(int j = 0; j < stones_len[i]; j++) {\n                scanf(\"%d%d\", stones_at[i]+j, stones_slip[i]+j);\n            }\n        }\n\n        static int dp[150][10][80];\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < stones_len[i]; j++)\n                for(int k = 0; k <= m; k++)\n                    dp[i][j][k] = INT_MAX/2;\n\n        for(int j = 0; j < stones_len[0]; j++)\n            dp[0][j][m] = 0;\n        for(int j = 0; j < stones_len[1]; j++)\n            dp[1][j][m-1] = 0;\n\n        for(int i = 1; i < n; i++) {\n            for(int j = 0; j < stones_len[i]; j++) {\n                for(int jf = 0; jf < stones_len[i-1]; jf++)\n                    for(int k = 0; k <= m; k++)\n                        dp[i][j][k] = min(dp[i][j][k], dp[i-1][jf][k]+\n                                          (stones_slip[i][j]+stones_slip[i-1][jf])*abs(stones_at[i][j]-stones_at[i-1][jf]));\n                if(i==1) continue;\n                for(int jf = 0; jf < stones_len[i-2]; jf++)\n                    for(int k = 0; k < m; k++)\n                        dp[i][j][k] = min(dp[i][j][k], dp[i-2][jf][k+1]+\n                                          (stones_slip[i][j]+stones_slip[i-2][jf])*abs(stones_at[i][j]-stones_at[i-2][jf]));\n            }\n        }\n\n        int min_val = INT_MAX;\n        for(int j = 0; j < stones_len[n-2]; j++)\n            for(int k = 1; k <= m; k++)\n                min_val = min(min_val, dp[n-2][j][k]);\n        for(int j = 0; j < stones_len[n-1]; j++)\n            for(int k = 0; k <= m; k++)\n                min_val = min(min_val, dp[n-1][j][k]);\n\n        printf(\"%d\\n\", min_val);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n\nusing namespace std;\nconst int INF =1001001001;\n#define rep(i,n) for(int i=0;i<n;i++)\nint N,M;\n\tint stonenum[152];\n\tint C[152][12];\n\tint G[152][12];\n\t//[i][j]=i+1行目にある石j個目の C=列(位置)、G=滑りやすさ>\n\tint dp[152][12][77];\n\t//[i][j][k]=i行(0,N行は陸)j+1番目にある石にいて、今までにk(<M<=(150+1)/2)回\n\t//飛ばした時の、対岸までの最短距離\n\n\nint main(){\n\twhile(1){\n\tscanf(\"%d %d\",&N,&M);\n\tif(N==0&&M==0)break;\n\t\trep(i,N){\n\t\tint a=0;\n\t\tscanf(\"%d\",&a);\n\t\tstonenum[i]=a;\n\t\trep(j,a){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tscanf(\"%d\",&c);\n\t\t\tC[i][j]=b;G[i][j]=c;\n\t\t}\n\t}\n\t//printf(\"\\nyomikomiOK\");\n\tfor(int i=N;i>-1;i--){//i=N…0\n\t\trep(j,stonenum[i]){\n\t\t\trep(k,M+1){\n\t\t\t\tif(i==N-1){dp[i][j][k]=0;}\n\t\t\t\telse if(i==N-2&&k<M){//0距離\n\t\t\t\t\tdp[i][j][k]=0;\n\t\t\t\t}else{\n\t\t\t\t\tint ans=INF;\n\t\t\t\t\trep(m,stonenum[i+1]){\n\t\t\t\t\t\t//if(ans==INF)ans=((G[i][k]+G[i+1][m])*abs(C[i][k]-C[i+1][m])+dp[i+1][m][k]);\n\t\t\t\t\t\tans=min(ans,((G[i][j]+G[i+1][m])*abs(C[i][j]-C[i+1][m])+dp[i+1][m][k]));\n\t\t\t\t\t}\n\t\t\t\t\tif(k<M){\n\t\t\t\t\t\trep(m,stonenum[i+2]){\n\t\t\t\t\t\t\tans=min(ans,(G[i][j]+G[i+2][m])*abs(C[i][j]-C[i+2][m])+dp[i+2][m][k+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\trep(i,stonenum[0])ans=min(ans,dp[0][i][0]);\n\tif(M>0)rep(i,stonenum[1])ans=min(ans,dp[1][i][1]);\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    int y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, int cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<int> > stones(N, vector<int>(1000, INT_MAX));\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i][x] = d;\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < 1000; ++j) {\n                if(stones[i][j] != INT_MAX) {\n                    q.push(Tag(i, j, 0, M-i));\n                }\n            }\n        }\n\n        vector<vector<int> > dp(N, vector<int>(1000, INT_MAX));\n        int ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m <= 0 && i == 2) break;\n                for(int j = 0; j < 1000; ++j) {\n                    int cost = stones[t.y+i][j];\n                    if(cost != INT_MAX) {\n                        cost += stones[t.y][t.x];\n                        cost *= abs(t.x-j);\n                        cost += t.c;\n                        if(cost >= dp[t.y+i][j]) continue;\n                        dp[t.y+i][j] = cost;\n                        q.push(Tag(t.y+i, j, cost, t.m-i+1));\n             //           cout << '\\t' << t.y+i << ' ' << j << ' ' << cost*abs(t.x-j) << endl;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n\n      int slip[151][11] = {{0}};\n      int flag[151][11][77] = {{{0}}};\n      priority_queue<p4,vector<p4 >,greater<p4 > >Q;\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n      \n      if(n == 1 && m == 1){printf(\"0\\n\"); continue;}\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n            flag[1][i][0] = 1;\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n            flag[2][i][1] = 1;\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s] = 1;\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s+1));\n               if(p.f.f != 0) flag[p.f.s+1][i][p.s.s+1] = 1;\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nint k[151];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][1000];\n\nint rec(int n, int m, int i)\n{\n    if (n >= N - 1) return 0;\n\n    if (~memo[n][m][i]) return memo[n][m][i];\n\n    int res = inf;\n\n    rep(j, k[n + 1]) {\n        int dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n        chmin(res, dist + rec(n + 1, m, j));\n    }\n\n    if (m > 0) {\n        if (n + 2 >= N) return 0;\n        rep(j, k[n + 2]) {\n            int dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n            chmin(res, dist + rec(n + 2, m - 1, j));\n        }\n    }\n\n    return memo[n][m][i] = res;\n}\n\nsigned main()\n{\n    while (scanf(\"%d %d\", &N, &M), N || M) {\n        rep(i, N) {\n            scanf(\"%d\", &k[i]);\n\n            stone[i].resize(k[i]);\n\n            rep(j, k[i]) {\n                int x, d; scanf(\"%d %d\", &x, &d);\n                stone[i][j].fst = x, stone[i][j].scd = d;\n            }\n        }\n\n        int ans = inf;\n\n        rep(i, k[0]) {\n            memset(memo, -1, sizeof(memo));\n            chmin(ans, rec(0, M, i));\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) REP(i,0,n)\n#define f first\n#define s second\n#define mpi(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\n#define pi pair<pair<int,int>,pair<int,int> >\nusing namespace std;\nint in(){int x; scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      vector<vector<int> > pos(150);\n      vector<vector<int> > cos(150);\n      int flag[151][11][76] = {0};\n\n      rep(i,n){\n         int x = in();\n         rep(j,x){\n            pos[i].push_back(in());\n            cos[i].push_back(in());\n         }\n      }\n\n      rep(i,pos[0].size()){\n         Q.push(mpi(0,0,i,0));\n      }\n      rep(i,pos[1].size()){\n         if(m != 0){\n            Q.push(mpi(0,1,i,1));\n         }\n      }\n\n      priority_queue<pi,vector<pi >,greater<pi > >Q;//cost,y,x,slip\n      int ans = 0;\n      while(Q.size()){\n         pi p = Q.top(); Q.pop();\n         if(p.f.s == n-1){ans = p.f.f; break;}\n         if(p.f.s == n-2 && m > p.s.s){ans = p.f.f; break;}\n\n         if(flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] == 1) continue;\n         flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] = 1;\n\n         rep(i,pos[p.f.s+1].size()){\n            Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+1][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+1][i]),p.f.s+1,i,p.s.s));\n         }\n\n         rep(i,pos[p.f.s+2].size()){\n            if(p.s.s < m) Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+2][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+2][i]),p.f.s+2,i,p.s.s+1));\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        vector<vector<vector<int> > > dp(3, vector<vector<int> >(10, vector<int>(M+1, INT_MAX/10000)));\n        for(int i = 0; i < stones[0].size(); ++i) {\n            dp[0][i][M] = 0;\n        }\n        if(M > 0) {\n            for(int i = 0; i < stones[1].size(); ++i) {\n                dp[1][i][M-1] = 0;\n            }\n        }\n        for(int i = 1; i < N; ++i) {\n            int curr = i%3;\n            int prev = (i-1)%3;\n            int pp = (i-2)%3;\n\n            for(int k = 0; k < stones[i].size(); ++k) {\n                fill(dp[curr][k].begin(), dp[curr][k].end(), INT_MAX/10000);\n            }\n            if(i > 1) {\n                for(int j = 0; j < stones[i-2].size(); ++j) {\n                    //pp to prev\n                    int sx = stones[i-2][j].first;\n                    int sc = stones[i-2][j].second;\n                    for(int k = 0; k < stones[i-1].size(); ++k) {\n                        int skx = stones[i-1][k].first;\n                        int skc = stones[i-1][k].second;\n                        int cost = (sc+skc) * abs(sx-skx);\n                        for(int m = 0; m <= M; ++m) {\n                            dp[prev][k][m] = min(dp[prev][k][m], dp[pp][j][m]+cost);\n                        }\n                    }\n\n                    //pp to curr\n                    for(int k = 0; k < stones[i].size(); ++k) {\n                        int skx = stones[i][k].first;\n                        int skc = stones[i][k].second;\n                        int cost = (sc+skc) * abs(sx-skx);\n                        for(int m = 0; m < M; ++m) {\n                            dp[curr][k][m] = min(dp[curr][k][m], dp[pp][j][m+1]+cost);\n                        }\n                    }\n                }\n            }\n            for(int j = 0; j < stones[i-1].size(); ++j) {\n                //prev to curr\n                int sx = stones[i-1][j].first;\n                int sc = stones[i-1][j].second;\n                for(int k = 0; k < stones[i].size(); ++k) {\n                    int skx = stones[i][k].first;\n                    int skc = stones[i][k].second;\n                    int cost = (sc+skc) * abs(sx-skx);\n                    for(int m = 0; m <= M; ++m) {\n                        dp[curr][k][m] = min(dp[curr][k][m], dp[prev][k][m]+cost);\n                    }\n                }\n            }\n        }\n        int ans = INT_MAX;\n        int curr = (N-1) % 3;\n        int prev = (N-2) % 3;\n\n        for(int m = 0; m <= M; ++m) {\n            for(int k = 0; k < stones[N-1].size(); ++k) {\n                ans = min(ans, dp[curr][k][m]);\n            }\n            if(m > 0) {\n                for(int k = 0; k < stones[N-2].size(); ++k) {\n                    ans = min(ans, dp[prev][k][m]);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[76][151][1001];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 100; i++)\n\t\t\tfor(int j = 0; j < 200; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+1001,INF);\n\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[m][0][i]=0;\n\t\t\t}\n\t\t}\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(i==3){\n\t\t\t\t//cout<<endl;\n\t\t\t}\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l][i-1][k]+cost);\n\t\t\t\t\t\tif(i>=2){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l+1][i-2][k]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,dp[j][n-1][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint DP[150][100][11];\nint N, M;\nint K[150];\nint X[150][10], Y[150][10];\nint main()\n{\n\twhile (true){\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)break;\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tfor (int k = 0; k <= 10; k++){\n\t\t\t\t\tDP[i][j][k] = 1000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d%d\", &X[i][j], &Y[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < K[0]; j++){\n\t\t\tDP[0][j][0] = 0;\n\t\t}\n\t\tfor (int j = 0; j < K[1]; j++){\n\t\t\tDP[1][j][1] = 0;\n\t\t}\n\t\t//i=1\n\t\tfor (int j = 0; j < K[1]; j++){\n\t\t\tfor (int k = 0; k < K[0]; k++){\n\t\t\t\tDP[1][j][0] = min(DP[1][j][0], (Y[1][j] + Y[0][k])*abs(X[1][j] - X[0][k]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i < N; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i - 1]; k++){\n\t\t\t\t\tfor (int l = 0; l <= M; l++){\n\t\t\t\t\t\tDP[i][j][l] = min(DP[i][j][l], DP[i - 1][k][l] + (Y[i][j] + Y[i - 1][k])*abs(X[i][j] - X[i - 1][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < K[i - 2]; k++){\n\t\t\t\t\tfor (int l = 0; l < M; l++){\n\t\t\t\t\t\tDP[i][j][l + 1] = min(DP[i][j][l+1], DP[i - 2][k][l] + (Y[i][j] + Y[i - 2][k])*abs(X[i][j] - X[i - 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\t\n\t\tfor (int j = 0; j < K[N - 1]; j++){\n\t\t\tfor (int k = 0; k <= M; k++){\n\t\t\t\tans = min(ans, DP[N - 1][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m, c, a, b;\nint main() {\n\tios::sync_with_stdio(false);\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<vector<pair<int, int> > > v(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv[i].push_back(make_pair(a, b));\n\t\t\t}\n\t\t}\n\t\tvector<vector<vector<int> > > d(n);\n\t\tfor (int i = 0; i < n; i++) d[i] = vector<vector<int> >(v[i].size(), vector<int>(m + 1, 999999999));\n\t\tpriority_queue<tuple<int, int, int, int> > que; // (dist, y, x, z)\n\t\tfor (int i = 0; i <= 1 && i <= m; i++) {\n\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\td[i][j][i] = 0;\n\t\t\t\tque.push(make_tuple(0, i, j, i));\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\ttuple<int, int, int, int> t1 = que.top(); que.pop();\n\t\t\tint a1 = -get<0>(t1), b1 = get<1>(t1), c1 = get<2>(t1), d1 = get<3>(t1);\n\t\t\tfor (int i = 1; i <= 2 && b1 + i < n; i++) {\n\t\t\t\tif (i == 2 && d1 == m) continue;\n\t\t\t\tfor (int j = 0; j < v[b1 + i].size(); j++) {\n\t\t\t\t\tint s = abs(v[b1][c1].first - v[b1 + i][j].first) * (v[b1][c1].second + v[b1 + i][j].second);\n\t\t\t\t\tif (d[b1 + i][j][d1 + i - 1] > a1 + s) {\n\t\t\t\t\t\td[b1 + i][j][d1 + i - 1] = a1 + s;\n\t\t\t\t\t\tque.push(make_tuple(-d[b1 + i][j][d1 + i - 1], b1 + i, j, d1 + i - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 999999999;\n\t\tfor (int i = 0; i <= 1 && i <= m; i++) {\n\t\t\tfor (int j = 0; j < v[n - i - 1].size(); j++) {\n\t\t\t\tfor (int k = 0; k <= m - i; k++) {\n\t\t\t\t\tret = min(ret, d[n - i - 1][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint sz[200];\nP stone[200][20];\nint dp[200][20][200];\nint main(){\n\tint n, m;\n\n\twhile(cin >> n >> m && (n || m)){\n\t\tfill(sz, sz + 200, 0);\n\t\tfill(&dp[0][0][0], &dp[199][19][199] + 1, INF);\n\t\tdp[0][0][m] = 0;\n\t\tint res = INF;\n\t\tsz[0] = sz[n+1] = sz[n+2] = 1;\n\t\trep(i, n){\n\t\t\tcin >> sz[i+1];\n\t\t\trep(j, sz[i+1]){\n\t\t\t\tint x, r;\n\t\t\t\tcin >> x >> r;\n\t\t\t\tstone[i+1][j] = P(x, r);\n\t\t\t}\n\t\t}\n\n\t\trep2(i, 1, n + 3){\n\t\t\trep(j, sz[i]){\n\t\t\t\trep(k, m + 1){\n\t\t\t\t\trep(l, sz[i-1]){\n\t\t\t\t\t\tint cost = (i > n || i == 1) ? 0 :\n\t\t\t\t\t\t\tabs(stone[i][j].first - stone[i-1][l].first)\n\t\t\t\t\t\t\t * (stone[i][j].second + stone[i-1][l].second);\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i-1][l][k] + cost, dp[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\trep(l, sz[i-2]){\n\t\t\t\t\t\tint cost = (i <= 2 || n < i) ? 0 : \n\t\t\t\t\t\t\tabs(stone[i][j].first - stone[i-2][l].first) * (stone[i][j].second + stone[i-2][l].second);\n\t\t\t\t\t\tdp[i][j][k] = (i == 1) ? 0 : min(dp[i-2][l][k+1] + cost, dp[i][j][k]); \t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep2(i, n+1, n+3)rep(j, m+1) res = min(res, dp[i][0][j]);\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<vector>\n#import<cstdlib>\nusing namespace std;main(){int n,m,k,x,d,h,i,j,D[158][151][10];for(;cin>>n>>m,n;cout<<x<<endl){vector<pair<int,int> >S[151];for(i=0;i++<n;)for(cin>>k;k--;S[i].push_back(make_pair(x,d)))cin>>x>>d;fill(**D,*D[158],x=1e9);for(i=S[1].size();i--;)D[m][1][i]=0;for(i=S[2].size();i--;)D[m-1][2][i]=0;for(h=1;h++<n;)for(i=m;1+i;i--)for(j=S[h].size();j--;){for(k=S[h-1].size();k--;)D[i][h][j]=min(D[i][h][j],D[i][h-1][k]+(S[h][j].second+S[h-1][k].second)*abs(S[h][j].first-S[h-1][k].first));for(k=S[h-2].size();k--;)D[i][h][j]=min(D[i][h][j],D[i+1][h-2][k]+(S[h][j].second+S[h-2][k].second)*abs(S[h][j].first-S[h-2][k].first));}for(i=m;1+i;i--)for(j=S[n].size();j--;)x=min(x,D[i][n][j]);for(i=m;i;i--)for(j=S[n-1].size();j--;)x=min(x,D[i][n-1][j]);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <queue>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-9\n\nint dp[80][160][1024];\n\nint main(){\n\tint n,m;\n\t\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\tint ans = INT_MAX;\n\t\tvector<pair<int,int> > vp[160];\n\t\trep(i,80)rep(j,160)rep(k,1024)dp[i][j][k]=INT_MAX;\n\t\t\n\t\trep(i,n){\n\t\t\tvector<pair<int,int> > tmp;\n\t\t\tint sz; scanf(\"%d\",&sz);\n\t\t\trep(j,sz){\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\t//printf(\"a,b , %d,%d\\n\",a,b);\n\t\t\t\ttmp.push_back( make_pair(a,b) );\n\t\t\t}\n\t\t\tvp[i] = tmp;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tif( i==0 ){\n\t\t\t\trep(j,vp[0].size()){\n\t\t\t\t\tdp[0][0][vp[0][j].first] = 0;\n\t\t\t\t}\n\t\t\t\tif( n>1 && m>0 ){\n\t\t\t\t\trep(j,vp[1].size()){\n\t\t\t\t\t\tdp[1][1][vp[1][j].first] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(l,m+1){\n\t\t\t\t\trep(j,vp[i-1].size())if( dp[l][i-1][vp[i-1][j].first]!=INT_MAX ){ // src 1step\n\t\t\t\t\t\trep(k,vp[i].size()){ //dest\n\t\t\t\t\t\t\tint c = (vp[i-1][j].second+vp[i][k].second) * abs(vp[i-1][j].first-vp[i][k].first);\n\t\t\t\t\t\t\tdp[l][i][vp[i][k].first] = min(dp[l][i][vp[i][k].first], dp[l][i-1][vp[i-1][j].first]+c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( i>1 && l<m ){\n\t\t\t\t\t\trep(j,vp[i-2].size())if( dp[l][i-2][vp[i-2][j].first]!=INT_MAX ){ // src 2step\n\t\t\t\t\t\t\trep(k,vp[i].size()){ //dest\n\t\t\t\t\t\t\t\tint c = (vp[i-2][j].second+vp[i][k].second) * abs(vp[i-2][j].first-vp[i][k].first);\n\t\t\t\t\t\t\t\tdp[l+1][i][vp[i][k].first] = min(dp[l+1][i][vp[i][k].first], dp[l][i-2][vp[i-2][j].first]+c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,n){\n\t\t\trep(j,10){\n\t\t\t\trep(k,m+1){\n\t\t\t\t\tprintf(\"dp[%d][%d][%d] : %d\\n\",k,i,j,dp[k][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\trep(l,m+1){\n\t\t\trep(i,vp[n-1].size()){\n\t\t\t\tans = min(ans, dp[l][n-1][vp[n-1][i].first]);\n\t\t\t}\n\t\t\tif( n-2>=0 && l<m ){\n\t\t\t\trep(i,vp[n-2].size()){\n\t\t\t\t\tans = min(ans, dp[l][n-2][vp[n-2][i].first]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i,m+1)rep(j,st_sz[n])\n\t\t//\tans = min(ans,dp[i][n][j]);\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m;\nvector<P> t[200];\nint dp[200][12][200];\n\nvoid solve(){\n  for(int i = 0; i < 200; i++){\n    for(int j = 0; j < 12; j++){\n      for(int k = 0; k < 200; k++){\n\tdp[i][j][k] = INT_MAX;\n      }\n      if(i == 0) dp[i][j][0] = 0;\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < t[i].size(); j++){\n      for(int k = 0; k <= m; k++){\n\tif(dp[i][j][k] == INT_MAX) continue;\n\n\tfor(int nj = 0; nj < t[i + 1].size(); nj++){\n\t  int add = (i == 0 ? 0 : (t[i][j].second + t[i + 1][nj].second) * abs(t[i][j].first - t[i + 1][nj].first));\n\t  dp[i + 1][nj][k] = min(dp[i + 1][nj][k], dp[i][j][k] + add);\n\t}\n\n\tif(k == m) continue;\n\n        for(int nj = 0; nj < t[i + 2].size(); nj++){\n          int add = (i == 0 ? 0 : (t[i][j].second + t[i + 2][nj].second) * abs(t[i][j].first - t[i + 2][nj].first));\n          dp[i + 2][nj][k + 1] = min(dp[i + 2][nj][k + 1], dp[i][j][k] + add);\n        }\n      }\n    }\n  }\n\n  int ans = INT_MAX;\n\n  for(int i = 0; i < t[n].size(); i++){\n    for(int j = 0; j <= m; j++){\n      ans = min(ans, dp[n][i][j]);\n    }\n  }\n\n  if(n == 1){\n    if(m >= 1) ans = 0;\n    cout << ans << endl;\n    return;\n  }\n\n  for(int i = 0; i < t[n - 1].size(); i++){\n    for(int j = 0; j <= m - 1; j++){\n      ans = min(ans, dp[n - 1][i][j]);\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n >> m , n || m){\n    for(int i = 0; i < 200; i++){\n      t[i].clear();\n    }\n    t[0].push_back(P(0, 0));\n\n    for(int i = 1; i <= n; i++){\n      int k;\n      cin >> k;\n\n      while(k--){\n\tint x, d;\n\tcin >> x >> d;\n\tx--;\n\tt[i].push_back(P(x, d));\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n, m;\nvector<pair<int, int> > data[150];\nint dp[150][10][80];\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    for(int i=0;i<n;i++) data[i].clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      for(int j=0;j<a;j++){\n        int b, c;\n        cin >> b >> c;\n        data[i].push_back(pair<int, int>(b, c));\n      }\n    }\n    fill(dp[0][0], dp[150][0], INF);\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[j].size();i++){\n        dp[j][i][m-j] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<data[i].size();j++){\n        for(int i1=0;i1<=m;i1++){\n          if(dp[i][j][i1] != INF){\n            for(int l=0;l<=1;l++){\n              if(i1-l<0) continue;\n              int next = i+1+l;\n              if(next >= n){\n                next--;\n                continue;\n              }\n              for(int k=0;k<data[next].size();k++){\n                dp[next][k][i1-l] = min(dp[next][k][i1-l],\n                                   dp[i][j][i1] + (data[i][j].second + data[next][k].second) *\n                                   (abs(data[i][j].first - data[next][k].first)));\n              }\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[n-1-j].size();i++){\n        for(int k=j;k<=m;k++){\n          ans = min(ans, dp[n-1-j][i][k]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  vector<int> id[150];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    int num = 0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = 1<<30;\n\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    \n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n      if(g[idx][step]<risk)continue;\n      g[idx][step] = risk;\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tq.push(P2(P1(risk + normal[idx][i].first, normal[idx][i].second),step));\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  q.push(P2(P1(risk + skip[idx][i].first, skip[idx][i].second),step+1));\n\t}\n      }\n    }\n\n    int ans = 1<<30;\n    for(int i=0;i<(int)id[n-1].size();i++)\n      for(int j=0;j<=m;j++)\n\tans = min(ans,g[id[n-1][i]][j]);\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1005;\nunsigned int dp[6][MAX_X][80];\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n >> m && n)\n\t{\n\t\trep(x,MAX_X) rep(y,6) rep(d,m+1) dp[y%6][x][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\trep(i,MAX_X)rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tr[x][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[0][x][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[1][x][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++)\n\t\t{\n\t\tmemcpy(dp[y%5], dp[5], sizeof(dp[y%5]));\n\t\tfor(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\t\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ツ津環湘ュツジツδδδ督プ\n\t\t\t\trep(nx, MAX_X) rep(d, m+1)\n\t\t\t\t\tif(dp[(y-1)%5][nx][d] != INF)\n\t\t\t\t\t\tchmin(dp[y%5][x][d], dp[(y-1)%5][nx][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// ツ暗ェツ段ツづづ篠つオ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[(y-2)%5][nx][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[y%5][x][d-1], dp[(y-2)%5][nx][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\t\t}\n\t\tunsigned int res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[(n-1)%5][x][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[(n-2)%5][x][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tREP(i, n - 1) REP(j, stone[i].size()) REP(k, m + 1) {\n\t\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2 && k != 0) {\n\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\tint cost = (stone[i][j].second + stone[i + 2][l].second) * abs(stone[i][j].first - stone[i + 2][l].first);\n\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\tint cost = (stone[i][j].second + stone[i + 1][l].second) * abs(stone[i][j].first - stone[i + 1][l].first);\n\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tREP(i, n + 1) {\n\t\t\tREP(j, stone[i].size()) {\n\t\t\t\tint pri = INF;\n\t\t\t\tREP(k, m + 1) pri = min(pri, dp[i][j][k]);\n\t\t\t\tprintf(\"%d%c\", pri, j == stone[i].size() - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tREP(i, stone[n - 2].size()) FOR(j, 1, m + 1) ans = min(ans, dp[n - 2][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll n,m;\nvector<P> rocks[150];\nll k;\nll dp[150][10][77];//dp[i][j][k] rock[i][j]?????????k???????????£??????\nconst ll INF=0xffffffffffff;\nint main()\n{while(1){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(!n) return 0;\n\trep(i,150) rocks[i].clear();\n\tfill(dp[0][0],dp[149][10],INF);\n\trep(i,n){\n\t\tscanf(\"%lld\",&k);\n\t\trep(j,k){\n\t\t\tll x,y;\n\t\t\tscanf(\"%lld%lld\",&x,&y);\n\t\t\tx--;\n\t\t\trocks[i].pb(P(x,y));\n\t\t}\n\t}\n\trep(i,rocks[0].size()){\n\t\tdp[0][i][m]=0;\n\t}\n\trep(i,n-1){\n\t\trep(j,rocks[i].size()){\n\t\t\trep(k,m+1){\n\t\t\t\tif(dp[i][j][k]==INF) continue;\n\t\t\t\t//??????\n\t\t\t\trep(l,rocks[i+1].size()){\n\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+abs(rocks[i][j].fr-rocks[i+1][l].fr)*(rocks[i][j].sc+rocks[i+1][l].sc));\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\tif(k>0&&i<n-2){\n\t\t\t\t\trep(l,rocks[i+2].size()){\n\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],dp[i][j][k]+abs(rocks[i][j].fr-rocks[i+2][l].fr)*(rocks[i][j].sc+rocks[i+2][l].sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\trep(i,rocks[n-1].size()){\n\t\trep(j,m+1){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint DP[151][10][76];\nint main() {\n\twhile(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n==0)\n\tbreak;\n\tint k[151],kiS[151][10],kiP[151][10];\n\tfor(int i=1;i<=n;i++ ){\n\t\tcin >> k[i];\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tcin >> kiP[i][j] >> kiS[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<151;i++)\n\t\tfor(int j=0;j<10;j++)\n\t\t\tfor(int kk=0;kk<76;kk++)\n\t\t\t\tDP[i][j][kk]=1 << 28;\n\tfor(int i=0;i<k[1];i++){\n\tDP[1][i][0]=0;\n\t}\n\tfor(int i=0;i<k[2];i++)\n\tDP[2][i][1]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int kk=0;kk<=min(m,n/2+1);kk++){\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int l=0;l<k[i-1];l++)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-1][l][kk]+(kiS[i][j]+kiS[i-1][l])*(abs(kiP[i][j]-kiP[i-1][l])));\n\t\t\t\tfor(int l=0;l<k[i-1];l++){\n\t\t\t\tif(kk!=0)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-2][l][kk-1]+(kiS[i][j]+kiS[i-2][l])*(abs(kiP[i][j]-kiP[i-2][l])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<k[i];j++)\n\t\t//\tcout << DP[i][j][0] << \" \" << i <<\" \" << j <<  endl;\n\t}*/\n\tint maxer =1 << 28;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tmaxer=min(maxer,DP[n][i][j]);\n\t\t//\tcout << n << \" \" << i << \" \" << j << \" \" << DP[n][i][j]<< endl;\n\t\t\tif(m+1<=m)\n\t\t\tmaxer=min(maxer,DP[n-1][i][m+1]);\n\t\t}\n\t}\n\tcout << maxer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\nstruct po{int x,d;};\nlong long dp[155][1001][80];\n\nint calc(po a,po b){return (a.d+b.d)*(abs(a.x-b.x));}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n  \n    vector <po> mp[200];\n    for(int i=0,k;i<n;i++){\n      cin>>k;\n      mp[i].resize(k);\n      for(int j=0;j<k;j++) cin>>mp[i][j].x>>mp[i][j].d;\n    }\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<(int)mp[i].size();j++) \n\tfor(int k=0;k<=m;k++)dp[i][j][k]=INF;\n    \n    for(int i=0;i<(int)mp[0].size();i++) dp[0][i][0]=0;\n    if(m)for(int i=0;i<(int)mp[1].size();i++) dp[1][i][1]=0;\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)mp[i].size();j++)\n\tfor(int k=0;k<=m;k++){\n\t  for(int l=0;l<(int)mp[i+1].size();l++)\n\t    dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+calc(mp[i][j],mp[i+1][l]));\n\t  \n\t  for(int l=0;l<(int)mp[i+2].size()&&k!=m;l++)\n\t    dp[i+2][l][k+1]=min(dp[i+2][l][k+1],dp[i][j][k]+calc(mp[i][j],mp[i+2][l]));\n\t}\n    }\n    \n    long long ans=INF;\n    for(int i=0;i<(int)mp[n-1].size();i++)\n      for(int j=0;j<=m;j++) ans=min(dp[n-1][i][j],ans);\n    \n    for(int i=0;i<(int)mp[n-2].size();i++)\n      for(int j=0;j<m;j++)  ans=min(dp[n-2][i][j],ans);\n    cout <<ans<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<math.h>\n#include<string.h>\nusing namespace std;\nint main() {\n\tint row, jump;\n\tint dp[151][11][76];\n\tint val[151][11];\n\tint Size[151];\n\tint num[151][11];\n\n\twhile (cin >> row >> jump, row)\n\t{\n\t\t\n\t\tfor (int i = 0; i < row; i++) {\n\t\t\tcin >> Size[i];\n\t\t\tfor (int j = 0; j < Size[i]; j++) {\n\t\t\t\tcin >> num[i][j] >> val[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0x7f, sizeof(dp));\t\t\t//初期化\n\t\tfor (int i = 0; i < Size[0]; i++)\t\t//岸からのジャンプ\n\t\t\tdp[0][i][0] = 0;\n\t\tfor (int i = 0; i < Size[1]; i++)\n\t\t\tdp[1][i][1] = 0;\n\n\t\tfor (int i = 0; i < row-1; i++) {\n\t\t\tfor (int j = 0; j < Size[i]; j++) {\n\t\t\t\tfor (int k = 0; k < Size[i + 1]; k++) {\n\t\t\t\t\tint risk = (val[i][j] + val[i + 1][k])*abs(num[i][j] - num[i+1][k]);\n\t\t\t\t\tfor (int m = 0; m <= jump; m++)\n\t\t\t\t\t\tdp[i + 1][k][m] = min(dp[i + 1][k][m], dp[i][j][m] + risk);\n\t\t\t\t}\n\t\t\t\tif (i == row - 2)continue;\n\t\t\t\tfor (int k = 0; k < Size[i + 2]; k++) {\n\t\t\t\t\tint risk = (val[i][j] + val[i + 2][k])*abs(num[i][j] - num[i + 2][k]);\n\t\t\t\t\tfor (int m = 0; m < jump; m++)\n\t\t\t\t\t\tdp[i + 2][k][m+1] = min(dp[i + 2][k][m+1], dp[i][j][m] + risk);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tint Min = 0x7f7f7f7f;\n\n\t\tfor (int i = 0; i < Size[row - 1]; i++)\n\t\t\tfor (int j = 0; j <= jump; j++) {\n\t\t\t\tMin = min(Min, dp[row - 1][i][j]);\n\n\t\t\t}\n\t\tfor (int i = 0; i < Size[row - 2]; i++)\n\t\t\tfor (int j = 0; j < jump; j++)\n\t\t\t\tMin = min(Min, dp[row - 2][i][j]);\n\t\t\n\t\tcout << Min << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Stone{\n  int x,d;\n  Stone(){}\n  Stone(int x, int d):x(x),d(d){}\n};\n\nint danger(Stone &a, Stone &b){ return abs(a.x-b.x)*(a.d+b.d);}\n\nconst int INF = 1<<29;\nint N,M;\nvector<Stone>s[256];\nint dp[160][16][80];\n\nint main(){\n  while(scanf(\"%d%d\", &N,&M) && N||M){\n    for(int i=0;i<256;i++) s[i].clear();\n    for(int i=0;i<N;i++){\n      int k; scanf(\"%d\", &k);\n      while(k--){\n\tint x,d; scanf(\"%d%d\",&x,&d);\n\ts[i].push_back(Stone(x,d));\n      }\n    }\n\n    for(int i=0;i<160;i++) for(int j=0;j<16;j++) for(int k=0;k<80;k++) dp[i][j][k] = INF;\n    for(int j=0;j<2;j++) for(int i=0;i<s[j].size();i++) dp[0][i][M-j] = 0;\n    for(int i=0;i<N-1;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k<s[i+1].size();k++){\n\t  for(int m=0;m<=M;m++) \n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m]+danger(s[i][j],s[i+1][k]));\n\t}\n\tif(i<N-2){\n\t  for(int k=0;k<s[i+2].size();k++){\n\t    for(int m=1;m<=M;m++)\n\t      dp[i+2][k][m-1] = min(dp[i+2][k][m-1], dp[i][j][m]+danger(s[i][j],s[i+2][k]));\n\t  }\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=0;i<s[N-1].size();i++) for(int m=0;m<=M;m++) res = min(res, dp[N-1][i][m]);\n    for(int i=0;i<s[N-2].size();i++) for(int m=1;m<=M;m++) res = min(res, dp[N-2][i][m]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 10000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n\tdp[0][i][m]=dp[1][i][m]=dp[2][i][m-1]=0;\n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\tint ki;\n\tvector<P> stone[150];\n\tint dp[150][10][80];\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tstone[i].clear();\n\t\t\tfor(int j = 0;j < 10;j++){\n\t\t\t\tfor(int k = 0;k <= m;k++) dp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> ki;\n\t\t\tfor(int j = 0;j < ki;j++){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i].push_back(P(a - 1,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < stone[0].size();i++){\n\t\t\tdp[0][i][0] = 0;\n\t\t}\n\t\tfor(int i = 0;i < stone[1].size();i++){\n\t\t\tdp[1][i][1] = 0;\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tfor(int j = 0;j < stone[i].size();j++){\n\t\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\t\tfor(int l = 0;l < stone[i - 1].size();l++){\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k],dp[i - 1][l][k] + (stone[i][j].second + stone[i - 1][l].second) * abs(stone[i][j].first - stone[i - 1][l].first));\n\t\t\t\t\t}\n\t\t\t\t\tif(i >= 2 && k >= 1){\n\t\t\t\t\t\tfor(int l = 0;l < stone[i - 2].size();l++){\n\t\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k],dp[i - 2][l][k - 1] + (stone[i][j].second + stone[i - 2][l].second) * abs(stone[i][j].first - stone[i - 2][l].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < stone[n - 1].size();i++){\n\t\t\tfor(int j = 0;j <= m;j++){\n\t\t\t\tmi = min(mi,dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tif(m){\n\t\t\tfor(int i = 0;i < stone[n - 2].size();i++){\n\t\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\t\tmi = min(mi,dp[n - 2][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct state{ int r,s,jump; };\n\nconst ll INF=12345678901234LL;\n// i??????, j????????????, k??????????£???°????????£???????????¨\nll dp[150][10][150];\n\nint k[150];\nint x[150][10], d[150][10];\n\nint main()\n{\n    int n,m;\n    while(scanf(\" %d %d\", &n, &m),n)\n    {\n        rep(i,n)\n        {\n            scanf(\" %d\", &k[i]);\n            rep(j,k[i]) scanf(\" %d %d\", &x[i][j], &d[i][j]);\n        }\n\n        fill(dp[0][0],dp[150][0],INF);\n\n        queue<state> que;\n        // 0??????\n        rep(i,k[0])\n        {\n            que.push(state{0,i,0});\n            dp[0][i][0]=0;\n        }\n        // 1??????\n        if(m>0)\n        {\n            rep(i,k[1])\n            {\n                que.push(state{1,i,1});\n                dp[1][i][1]=0;\n            }\n        }\n\n        ll ans=INF;\n\n        while(!que.empty())\n        {\n            state now=que.front();\n            que.pop();\n\n            if(now.r == n-1 || (now.r == n-2 && now.jump < m))\n            {\n                ans = min(ans, dp[now.r][now.s][now.jump]);\n                continue;\n            }\n\n            // ??????????????£??????\n            rep(i,k[now.r+1])\n            {\n                ll add=(d[now.r][now.s]+d[now.r+1][i])*abs(x[now.r][now.s]-x[now.r+1][i]);\n\n                if(dp[now.r+1][i][now.jump] > dp[now.r][now.s][now.jump]+add)\n                {\n                    dp[now.r+1][i][now.jump] = dp[now.r][now.s][now.jump]+add;\n                    que.push(state{now.r+1,i,now.jump});\n                }\n            }\n\n            // ???????£???°???????????£??????\n            if(now.jump<m)\n            {\n                rep(i,k[now.r+2])\n                {\n                    ll add=(d[now.r][now.s]+d[now.r+2][i])*abs(x[now.r][now.s]-x[now.r+2][i]);\n\n                    if(dp[now.r+2][i][now.jump+1] > dp[now.r][now.s][now.jump]+add)\n                    {\n                        dp[now.r+2][i][now.jump+1] = dp[now.r][now.s][now.jump]+add;\n                        que.push(state{now.r+2,i,now.jump+1});\n                    }\n                }\n            }\n        }\n\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint dp[155][1000][76]={};\nbool p(P a,P b){\n\tif(a.first<b.first){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(1){\n\t\tvector<P>vec[155];\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(!n) break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint r,u;\n\t\t\t\tscanf(\"%d %d\",&r,&u);\n\t\t\t\tvec[i].pb(mp(r,u));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tsort(vec[i].begin(),vec[i].end(),p);\n\t\t}\n\t\tfor(int i=0;i<=150;i++){\n\t\t\tfor(int j=0;j<1000;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint y=vec[1].size();\n\t\tfor(int i=0;i<y;i++){\n\t\t\tdp[1][vec[1][i].first][0]=0;\n\t\t}\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tint eee=vec[i].size();\n\t\t\tfor(int j=0;j<eee;j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tint r=vec[i-1].size();\n\t\t\t\t\tfor(int l=0;l<r;l++){\n\t\t\t\t\t\tdp[i][vec[i][j].first][k]=min(dp[i-1][vec[i-1][l].first][k]+abs(vec[i][j].first-vec[i-1][l].first)*(vec[i-1][l].second+vec[i][j].second),dp[i][vec[i][j].first][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=0 && i!=2){\n\t\t\t\t\t\tint rr=vec[i-2].size();\n\t\t\t\t\t\tfor(int l=0;l<rr;l++){\n\t\t\t\t\t\t\tdp[i][vec[i][j].first][k]=min(dp[i-2][vec[i-2][l].first][k-1]+abs(vec[i][j].first-vec[i-2][l].first)*(vec[i-2][l].second+vec[i][j].second),dp[i][vec[i][j].first][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint rp[10]={};\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tint u=(int)vec[i].size();\n\t\t\t\tfor(int j=0;j<u;j++){\n\t\t\t\t\t\trp[j]=dp[i][vec[i][j].first][k];\n\t\t\t\t}\n\t\t\t\tsort(rp,rp+u);\n\t\t\t\tfor(int l=0;l<u;l++){\n\t\t\t\t\tint q;\n\t\t\t\t\tfor(int e=0;e<u;e++){\n\t\t\t\t\t\tif(rp[l]==dp[i][vec[i][e].first][k]){q=e;}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int g=0;g<u;g++){\n\t\t\t\t\t\tif(q!=g){\n\t\t\t\t\t\t\tdp[i][vec[i][g].first][k]=min(dp[i][vec[i][g].first][k],dp[i][vec[i][q].first][k]+abs(vec[i][g].first-vec[i][q].first)*(vec[i][g].second+vec[i][q].second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<vec[n].size();i++){\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tres=min(res,dp[n][vec[n][i].first][k]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=0;j<vec[i].size();j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tprintf(\"%d %d %d %d\\n\",i,j,k,dp[i][vec[i][j].first][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\tscanf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i__=0;__i__<n;__i__++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\nusing namespace std;\n\nlong COST_LIMIT = 1000 * 2000 * 150;\n\nint main(int argc, char const* argv[])\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if (n == 0 && m == 0) break;\n\n    // memory alloc and init\n    long cost_table[3][10][m + 1];\n    int pos[3][10];\n    int slip[3][10];\n    int stones[3];\n\n    // per row operation\n    loop(n, row_i) {\n      int pp = (row_i + 1) % 3, p = (row_i + 2) % 3, crr = row_i % 3;\n      cin >> stones[crr];\n\n      // read stone info\n      loop(stones[crr], i) {\n        cin >> pos[crr][i] >> slip[crr][i];\n      }\n\n      // set initial value\n      fill(cost_table[crr][0], cost_table[crr][9] + m + 1, COST_LIMIT);\n      if (row_i == 0) {\n        loop(stones[crr], i) cost_table[crr][i][m] = 0;\n      }\n      if (row_i == 1 && m > 0) {\n        loop(stones[crr], i) cost_table[crr][i][m - 1] = 0;\n      }\n\n      // normal jump\n      if (row_i >= 1) {\n        loop(stones[crr], c_i) {\n          loop(m + 1, m_i) {\n            long min_cost = COST_LIMIT;\n            loop(stones[p], p_i) {\n              int jump_cost = (slip[p][p_i] + slip[crr][c_i]) * abs(pos[p][p_i] - pos[crr][c_i]);\n              long cost = cost_table[p][p_i][m_i] + jump_cost;\n              assign_if_smaller(min_cost, cost);\n            }\n            assign_if_smaller(cost_table[crr][c_i][m_i], min_cost);\n          }\n        }\n      }\n\n      // big jump\n      if (row_i >= 2) {\n        loop(stones[crr], c_i) {\n          loop_from_to(1, m, m_i) {\n            long min_cost = COST_LIMIT;\n            loop(stones[pp], pp_i) {\n              int jump_cost = (slip[pp][pp_i] + slip[crr][c_i]) * abs(pos[pp][pp_i] - pos[crr][c_i]);\n              long cost = cost_table[pp][pp_i][m_i] + jump_cost;\n              assign_if_smaller(min_cost, cost);\n            }\n            assign_if_smaller(cost_table[crr][c_i][m_i - 1], min_cost);\n          }\n        }\n      }\n\n      // // show\n      // loop(stones[crr], c_i) loop(m + 1, m_i) \n      //   cout << \"row: \" << row_i << \", col: \" << c_i << \", m:\" << m_i << \", cost: \" << cost_table[crr][c_i][m_i] << endl;\n    }\n\n    long min_cost = COST_LIMIT;\n    loop_from_to(0, !!m, d) {\n      loop(stones[(n - 1 - d) % 3], i) {\n        loop_from_to(d, m, j) {\n          assign_if_smaller(min_cost, cost_table[(n - 1 - d) % 3][i][j]);\n        }\n      }\n    }\n\n    cout << min_cost << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++>h>\n#define int long long\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nconst int INF = LLONG_MAX / 3;\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[152][78]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%lld\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%lld%lld\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e >= 2 && j<b) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 2][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define INF (1 << 25)\nusing namespace std;\n\nint main(){\n  int n, m, tmp;\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    int dp[3][10][100];\n    memset(dp, 0, sizeof(dp));\n    vector< pair<int, int> >stones[n];\n    for(int i = 0;i < n;i++){\n      int k, l, m;\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;j++){\n\tscanf(\"%d %d\", &l, &m);\n\tstones[i].push_back(make_pair(l, m));\n      }\n    }\n    for(int i = 0;i < n;i++){\n      int ind = i%3, prev = (i - 1) % 3, prepre = (i - 2) % 3;\n\n      for(int j = 0;j < stones[i].size();j++)\n\tfor(int k = 0;k <= m;k++)\n\t  dp[ind][j][k] = INF;\n\n      for(int j = 0;j < stones[i].size();j++){\n\tif(i == 0)dp[ind][j][m] = 0;\n\telse if(i == 1 && m - 1 >= 0)dp[ind][j][m - 1] = 0;\n      }\n      for(int j = 0;j < stones[i].size();j++){\n\tfor(int k = 0;k <= m;k++){\n\t  for(int l = 0;i > 0 && l < stones[i - 1].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prev][l][k] + abs(stones[i - 1][l].first - stones[i][j].first) * (stones[i - 1][l].second + stones[i][j].second));\n\t  }\n\t  for(int l = 0;i > 1 && k < m && l < stones[i - 2].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prepre][l][k + 1] + abs(stones[i - 2][l].first - stones[i][j].first) * (stones[i - 2][l].second + stones[i][j].second));\n\t  }\n\t}\n      }\n    }\n    int res = INF;\n    for(int i = 0;i < stones[n - 1].size();i++){\n      for(int j = 0;j <= m;j++){\n\tres = min(res, dp[(n-1) % 3][i][j]);\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing P = pair<int, int>;\nint n, m;\nvector<P> ps[155];\nint dp[155][80][1010];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> n >> m, n) {\n        REP (i, 155) ps[i].clear();\n        REP (i, n) {\n            int k;\n            cin >> k;\n            REP(j, k) {\n                int x, d;\n                cin >> x >> d;\n                x--;\n                ps[i + 1].emplace_back(x, d);\n            }\n        }\n        REP(i, 1010) ps[0].emplace_back(i, 0);\n        REP(i, 1010) ps[n + 1].emplace_back(i, 0);\n        const int INF = 1LL << 60;\n        fill_n((int*)dp, 155 * 80 * 1010, INF);\n        REP (i, 1010) dp[0][0][i] = 0;\n        REP (i, n + 1) REP (j, m + 1) {\n            for (P p1 : ps[i]) {\n                if (dp[i][j][p1.first] == INF) continue;\n                if (i + 1 <= n + 1) {\n                    for (P p2 : ps[i + 1]) {\n                        dp[i + 1][j][p2.first] = min(dp[i + 1][j][p2.first], dp[i][j][p1.first] + (p1.second + p2.second) * abs(p1.first - p2.first));\n                    }\n                }\n                if (i + 2 <= n + 1 && j + 1 <= m) {\n                    for (P p2 : ps[i + 2]) {\n                        dp[i + 2][j + 1][p2.first] = min(dp[i + 2][j + 1][p2.first], dp[i][j][p1.first] + (p1.second + p2.second) * abs(p1.first - p2.first));\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        REP (i, m + 1) REP (j, 1010) ans = min(ans, dp[n + 1][i][j]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll n,m;\nvector<P> rocks[150];\nll k;\nll dp[150][10][77];//dp[i][j][k] rock[i][j]?????????k???????????£??????\nconst ll INF=0xffffffffffff;\nint main()\n{while(1){\n\tcin>>n>>m;\n\trep(i,150) rocks[i].clear();\n\tfill(dp[0][0],dp[149][10],INF);\n\trep(i,n){\n\t\tcin>>k;\n\t\trep(j,k){\n\t\t\tll x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx--;\n\t\t\trocks[i].pb(P(x,y));\n\t\t}\n\t}\n\trep(i,rocks[0].size()){\n\t\tdp[0][i][m]=0;\n\t}\n\trep(i,n-1){\n\t\trep(j,rocks[i].size()){\n\t\t\trep(k,m+1){\n\t\t\t\tif(dp[i][j][k]==INF) continue;\n\t\t\t\t//??????\n\t\t\t\trep(l,rocks[i+1].size()){\n\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+abs(rocks[i][j].fr-rocks[i+1][l].fr)*(rocks[i][j].sc+rocks[i+1][l].sc));\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\tif(k>0&&i<n-2){\n\t\t\t\t\trep(l,rocks[i+2].size()){\n\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],dp[i][j][k]+abs(rocks[i][j].fr-rocks[i+2][l].fr)*(rocks[i][j].sc+rocks[i+2][l].sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\trep(i,rocks[n-1].size()){\n\t\trep(j,m+1){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "//Solution for aoj:0530 Pyon-Pyon River Crossing\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int INF = 10000000000, MAX_N = 150;\ntypedef pair<int, int> P;\nint n, m, ans;\nint dp[MAX_N + 3][1001][76];\nP stone, stone2;\nvector<P> Stone[151]; //first:??????second:???????????????\nint main(){\n\twhile (cin >> n >> m){\n\t\tif (!n&&!m)\n\t\t\treturn 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tStone[i].clear();\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tStone[i].push_back(P(a, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tfor (int j = 1; j <= 1000; j++){\n\t\t\t\tfor (int k = 0; k <= m; k++){\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\t\tstone = Stone[2][i];\n\t\t\tdp[2][stone.first][m] = INF;\n\t\t}\n\t\tfor (int i = 3; i <= n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k <= 75; k++)\n\t\t\t\t\tdp[i][stone.first][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k < Stone[i + 1].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 1][k];\n\t\t\t\t\tfor (int l = m; l >= m - i / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < Stone[i + 2].size(); k++){\n\t\t\t\t\tif (i + 2 > n)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstone2 = Stone[i + 2][k];\n\t\t\t\t\tfor (int l = m - 1; l >= m - (i + 2) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdp[i + 2][stone2.first][l] = min(dp[i + 2][stone2.first][l], (stone.second + stone2.second) * abs(stone.first - stone2.first) + dp[i][stone.first][l + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor (int i = 0; i < Stone[n].size(); i++){\n\t\t\tstone = Stone[n][i];\n\t\t\tfor(int j = 0; j <= m; j++)\n\t\t\tans = min(dp[n][stone.first][j], ans);\n\t\t}\n\t\tfor (int i = 0; i < Stone[n - 1].size(); i++){\n\t\t\tstone = Stone[n - 1][i];\n\t\t\tfor(int j = 0; j <= m; j++)\n\t\t\t  ans = min(dp[n - 1][stone.first][1], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=1; i<=n; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n+1){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n+1){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(1);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(2));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=1000000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0)\n\t\t\t\tdp[0][i][m]=0;\n\t\t}\n\t\tif(m!=0){\n\t\t\tfor(int i = 0; i < 1001; i++){\n\t\t\t\tif(field[1][i]!=0)\n\t\t\t\t\tdp[1][i][m-1]=0;\n\t\t\t}\n\t\t}\n\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tif(m!=0&&i==1){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\t\tfill(cur[j],cur[j]+77,INF);\n\t\t\t}\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\tif(field[i-1][k]==0&&(i<=1||field[i-2][k]==0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++)\n\t\t\t\tminRes=min(minRes,cur[i][j]);\n\t\t\tfor(int j = 1; j <= m; j++)\n\t\t\t\tminRes=min(minRes,prv[i][j]);\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans;\nLL V[160][1010];\nLL mem[160][1010][80];\n\nLL cal(int y,int x,int m){\n    LL res=INF;\n    if(mem[y][x][m]!=-1)return mem[y][x][m];\n    if(y>=N)return 0;\n    if(y==0){\n        FOR(i,1,1000){\n            if(V[y+1][i]!=INF)\n            res=cal(y+1,i,m);\n        }\n    }\n    else{\n        if(V[y][x]!=INF){\n            FOR(i,1,1000){\n                    if(m>0&&V[y+1][i]!=INF&&V[y+2][i]!=INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,min(cal(y+2,i,m-1)+d2,res));\n                    }\n                    else if(V[y+1][i]!=INF&&V[y+2][i]==INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,res);\n                    }\n                    else if(V[y+1][i]==INF&&V[y+2][i]!=INF&&m>0){\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+2,i,m)+d2,res);\n                    }\n            }\n        }\n    }\n    return mem[y][x][m]=res;\n}\n\nint main(){\n    cin>>N>>M;\n    memset(mem,-1,sizeof(mem));\n    rep(i,151)rep(j,1001)V[i][j]=INF;\n    FOR(i,1,N){\n        LL t;\n        cin>>t;\n        rep(j,t){\n            LL x,k;\n            cin>>x>>k;\n            V[i][x]=k;\n        }\n    }\n    ans=cal(0,0,M);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//  Pyon-Pyon River Crossing.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int X = 1005;\nconst int Y = 155;\n\nint N, M;\nint memo[Y][X][80];\nint river[Y][X];\n\nint rec(int y, int x, int m)\n{\n\tif(y == N-1 || (y == N-2 && m > 0)) return 0;\n\t\n\tif(memo[y][x][m] != -1) return memo[y][x][m];\n\t\n\tint ans = 1<<30;\n\t\n\trep(nx, X)\n\t{\n\t\tif(river[y+1][nx] > 0)\n\t\t{\n\t\t\tchmin(ans, rec(y+1, nx, m) + (river[y][x] + river[y+1][nx]) * abs(x - nx));\n\t\t}\n\t\t\n\t\tif(river[y+2][nx] > 0 && m > 0)\n\t\t{\n\t\t\tchmin(ans, rec(y+2, nx, m-1) + (river[y][x] + river[y+2][nx] * abs(x - nx)));\n\t\t}\n\t}\n\t\n\treturn (memo[y][x][m] = ans);\n}\n\nint main()\n{\n\tfor(; cin >> N >> M && (N || M); )\n\t{\n\t\tmemset(memo, -1, sizeof memo);\n\t\tmemset(river, 0, sizeof river);\n\t\t\t\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\trep(j, k)\n\t\t\t{\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\t\n\t\t\t\tcin >> river[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 1<<30;\n\t\trep(x, X) if(river[0][x] > 0) chmin(ans, rec(0, x, M));\n\t\t\n\t\tcout << ans << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<24LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans=INF;\nLL V[160][15];\nLL K[160][15];\nLL mem[160][15][80][3];\n\n\nLL cal(int y,int x,int m,int f){\n    LL res=INF;\n    if(mem[y][x][m][f]!=-1){\n        return mem[y][x][m][f];\n    }\n    if(y==N-1&&f==2)return 0;\n    if(y==N&&f==1)return 0;\n    rep(i,10){\n        LL d1,d2;\n        if(m>0&&K[y+1][i]&&K[y+2][i]&&y+2<=N){\n            d1=(K[y][x]+K[y+1][i])*abs(V[y][x]-V[y+1][i]);\n            d2=(K[y][x]+K[y+2][i])*abs(V[y][x]-V[y+2][i]);\n            res=min(cal(y+1,i,m,f)+d1,min(cal(y+2,i,m-1,f)+d2,res));\n        }\n        else if(K[y+1][i]){\n            d1=(K[y][x]+K[y+1][i])*abs(V[y][x]-V[y+1][i]);\n            res=min(cal(y+1,i,m,f)+d1,res);\n        }\n        else if(K[y+2][i]&&m>0&&y+2<=N){\n            d2=(K[y][x]+K[y+2][i])*abs(V[y][x]-V[y+2][i]);\n            res=min(cal(y+2,i,m-1,f)+d2,res);\n        }\n    }\n    return mem[y][x][m][f]=res;\n}\n\n\nint main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(mem,-1,sizeof(mem));\n        memset(V,0,sizeof(V));\n        memset(K,0,sizeof(K));\n        FOR(i,1,N){\n            LL t;\n            cin>>t;\n            rep(j,t){\n                LL x,k;\n                cin>>x>>k;\n                V[i][j]=x;\n                K[i][j]=k;\n            }\n        }\n        rep(j,10){\n            if(K[1][j]&&K[2][j]&&M>0){\n                ans=min(cal(1,j,M,1),min(cal(2,j,M-1,2),ans));\n            }\n            else if(K[1][j]){\n                ans=min(cal(1,j,M,1),ans);\n            }\n            else if(M>0)ans=min(cal(2,j,M-1,2),ans);\n        }\n        cout<<ans<<endl;\n        ans=INF;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint dp[160][1010][100];\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n,vi(1010));\n\t\trep(i,n){\n\t\t\tint k;cin>>k;\n\t\t\twhile(k--){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\ta--;\n\t\t\t\tin[i][a]=b;\n\t\t\t}\n\t\t}\n\t\trep(i,200)rep(j,1010)rep(k,100)dp[i][j][k]=inf;\n\t\trep(i,1010)if(in[0][i])dp[0][i][0]=0;\n\t\trep(i,1010)if(in[1][i])dp[1][i][1]=0;\n\t\tloop(i,1,n)rep(j,1010)rep(k,m+1)if(in[i][j]){\n\t\t\trep(l,1010)if(in[i-1][l])dp[i][j][k]=min(dp[i][j][k],\n\t\t\t\tdp[i-1][l][k]+(in[i][j]+in[i-1][l])*(abs(l-j)));\n\t\t\tif(k&&i!=1){\n\t\t\t\trep(l,1010)if(in[i-2][l])dp[i][j][k]=min(dp[i][j][k],\n\t\t\t\t\tdp[i-2][l][k-1]+(in[i][j]+in[i-2][l])*(abs(j-l)));\n\t\t\t}\n\t\t}\n//\t\trep(i,n){rep(j,4)cout<<\" \"<<dp[i][j][1];cout<<endl;}\n\t\tint out=inf;\n\t\trep(i,1010)rep(j,m+1)out=min(out,dp[n-1][i][j]);\n\t\trep(i,1010)rep(j,m)out=min(out,dp[n-2][i][j]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1005;\nll dp[6][MAX_X][80];\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n >> m && n)\n\t{\n\t\trep(x,MAX_X) rep(y,6) rep(d,m+1) dp[y][x][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\trep(i,MAX_X) rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tr[x][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[0][x][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[1][x][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++)\n\t\t{\n\t\tif(1 < y) memcpy(dp[y%5], dp[5], sizeof(dp[y%5]));\n\t\tfor(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\t\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ツ津環湘ュツジツδδδ督プ\n\t\t\t\trep(nx, MAX_X) rep(d, m+1)\n\t\t\t\t\tif(dp[(y-1)%5][nx][d] != INF)\n\t\t\t\t\t\tchmin(dp[y%5][x][d], dp[(y-1)%5][nx][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// ツ暗ェツ段ツづづ篠つオ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[(y-2)%5][nx][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[y%5][x][d-1], dp[(y-2)%5][nx][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\t\t}\n\t\tll res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[(n-1)%5][x][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[(n-2)%5][x][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, m;\nint danger[155][1010];\nvector<int> X[155];\nll dp[155][1010][80];\n\nconst ll inf = 1LL << 55;\n\nll solve(int col, int row, int jump)\n{\n  if(col >= n-1) return 0;\n  if(col >= n-2 && jump < m) return 0;\n  if(jump > m) return inf;\n  if(~dp[col][row][jump]) return dp[col][row][jump];\n  ll ret = inf;\n  for(int i = 0; i < X[col+1].size(); i++){\n    if(danger[col+1][X[col+1][i]] == inf) continue;\n    ll D = (danger[col][row] + danger[col+1][X[col+1][i]]) * abs(row - X[col+1][i]);\n    ret = min(ret, solve(col + 1, X[col+1][i], jump) + D);\n  }\n  if(jump < m && col < n-2){\n    for(int i = 0; i < X[col+2].size(); i++){\n      if(danger[col+2][X[col+2][i]] == inf) continue;\n      ll D = (danger[col][row] + danger[col+2][X[col+2][i]]) * abs(row - X[col+2][i]);\n      ret = min(ret, solve(col + 2, X[col+2][i], jump + 1) + D);\n    }\n  }\n  return dp[col][row][jump] = ret;\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 155; i++) X[i].clear();\n    for(int i = 0; i < 155; i++){\n      for(int j = 0; j < 11; j++) danger[i][j] = -1;\n    }\n    for(int i = 0; i < n; i++){\n      int k; cin >> k;\n      for(int j = 0; j < k; j++){\n\tint x, d;\n\tcin >> x >> d;\n\t--x;\n\tdanger[i][x] = d;\n\tX[i].push_back(x);\n      }\n    }\n\n    memset(dp, -1, sizeof(dp));\n    ll ans = inf;\n    for(int i = 0; i < X[0].size(); i++){\n      if(danger[0][X[0][i]] == inf) continue;\n      ans = min(ans, solve(0, X[0][i], 0));\n    }\n    if(m > 0 && n > 1){\n      for(int i = 0; i < X[1].size(); i++){\n\tif(danger[1][X[1][i]] == inf) continue;\n\tans = min(ans, solve(1, X[1][i], 1));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\n\nint n, m;\nstd::vector<int> xs[151], ds[151];\nint dp[151][10][100];\n\nint rec(int row, int index, int used){\n    if(row == n-1){\n        return 0;\n    }\n\n    if(dp[row][index][used] != -1){\n        return dp[row][index][used];\n    }\n\n    //std::cout << \"Start: (\" << row << \", \" << index << std::endl;\n    int res = INF;\n    REP(i, xs[row+1].size()){\n        int x_to = xs[row+1][i], d_to = ds[row+1][i],\n            danger = (d_to + ds[row][index]) * std::abs(x_to - xs[row][index]);\n        \n        int y = danger + rec(row+1, i, used);\n        // if(res > y){\n        //     std::cout << (x_to - xs[row][index]) << std::endl;\n        //     std::cout << \"(\" << row << \", \" << index << \") -> (\" << (row+1) << \", \" << i << \") = \" << danger << std::endl;\n        // }\n        res = std::min(res, y);\n    }\n\n    if(used < m && row+2 <= n-1){\n        REP(i, xs[row+2].size()){\n            int x_to = xs[row+2][i], d_to = ds[row+2][i],\n                danger = (d_to + ds[row][index]) * std::abs(x_to - xs[row][index]);\n        \n            int y = danger + rec(row+2, i, used+1);\n            // if(res > y){\n            //     std::cout << \"!(\" << row << \", \" << index << \") -> (\" << (row+2) << \", \" << i << \") = \" << y << std::endl;\n            // }\n            res = std::min(res, y);\n        }\n       \n    }\n\n\n    return dp[row][index][used] = res;\n}\n\nint main(){\n    while(std::cin >> n >> m, n){\n        REP(i, 151){\n            REP(j, 10){\n                REP(k, 100){\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n        \n        REP(i, 151){\n            xs[i].clear();\n            ds[i].clear();\n        }\n    \n        REP(i, n){\n            int k;\n            std::cin >> k;\n            REP(j, k){\n                int x, d;\n                std::cin >> x >> d;\n                xs[i].push_back(x);\n                ds[i].push_back(d);\n            }\n        }\n\n        int res = INF;\n        REP(i, xs[0].size()){\n            res = std::min(res, rec(0, i, 0));\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint n, m;\nvector<pair<int, int> > data[150];\nint dp[150][10][80];\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    for(int i=0;i<n;i++) data[i].clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      for(int j=0;j<a;j++){\n        int b, c;\n        cin >> b >> c;\n        data[i].push_back(pair<int, int>(b, c));\n      }\n    }\n    fill(dp[0][0], dp[150][0], INF);\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[j].size();i++){\n        dp[j][i][m-j] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<data[i].size();j++){\n        for(int i1=0;i1<=m;i1++){\n          if(dp[i][j][i1] != INF){\n            for(int l=0;l<=1;l++){\n              if(i1-l<0) continue;\n              int next = i+1+l;\n              if(next >= n) continue;\n\n              for(int k=0;k<data[next].size();k++){\n                dp[next][k][i1-l] = min(dp[next][k][i1-l],\n                                   dp[i][j][i1] + (data[i][j].second + data[next][k].second) *\n                                   (abs(data[i][j].first - data[next][k].first)));\n              }\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[n-1-j].size();i++){\n        for(int k=j;k<=m;k++){\n          ans = min(ans, dp[n-1-j][i][k]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 5000000000000;\n\nint n, m;\nint K[151], x[151][10], d[151][10];\nlong long dp[151][10];\n\nvoid init()\n{\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 150; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tmemset(K, 0, sizeof(K));\n\tK[0] = K[n + 1] = 1;\n\tmemset(x, 0, sizeof(x));\n\tmemset(d, 0, sizeof(d));\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\t\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (m--){\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n - 1) dp[i + 2][k] = min(dp[i + 2][k], dp[i][j]);\n\t\t\t\t\t\tdp[i + 2][k] = min(dp[i + 2][k], dp[i][j] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long mini = INF;\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tmini = min(mini, dp[n + 1][i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n\n\n    \n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint n,m;\nint stone[155][11][2];\nint dp[155][11][76];\nint num[155];\nint main(){\n\twhile(scanf(\"%d %d\",&n,&m) && n){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&num[i]);\n\t\t\tfor(int g=1;g<=num[i];g++){\n\t\t\t\tscanf(\"%d %d\",&stone[i][g][0],&stone[i][g][1]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<155;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=num[1];j++){\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\tdp[1][j][k]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=num[2];j++){\n\t\t\tfor(int k=1;k<=m;k++){\n\t\t\t\tdp[2][j][k]=0;\n\t\t\t}\n\t\t\tfor(int y=1;y<=num[1];y++){\n\t\t\t\tdp[2][j][0]=min(dp[2][j][0],dp[1][y][0]+abs(stone[1][y][0]-stone[2][j][0])*(stone[1][y][1]+stone[2][j][1]));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=3;i<=n;i++){\n\t\t\tfor(int j=1;j<=num[i];j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tfor(int g=1;g<=num[i-1];g++){\n\t\t\t\t\t\tdp[i][j][k]=min(dp[i][j][k],dp[i-1][g][k]+abs(stone[i][j][0]-stone[i-1][g][0])*(stone[i][j][1]+stone[i-1][g][1]));\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=0){\n\t\t\t\t\t\tfor(int l=1;l<=num[i-2];l++){\n\t\t\t\t\t\t\tdp[i][j][k]=min(dp[i][j][k],dp[i-2][l][k-1]+abs(stone[i][j][0]-stone[i-2][l][0])*(stone[i][j][1]+stone[i-2][l][1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int j=1;j<=num[n];j++){\n\t\t\tfor(int k=0;k<=m;k++){\n\t\t\tres=min(res,dp[n][j][k]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=num[n-1];j++){\n\t\t\tfor(int k=0;k<m;k++){\n\t\t\tres=min(res,dp[n-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nstruct rock\n{\n  int x, d;\n};\n\nconst int INF = 2e9;\nint n, m;\nint dp[160][15][80];\nvector<rock> rocks[160];\nint main()\n{\n  while(cin >> n >> m && (n || m)){\n\n    //chap1\n    for(int i = 0; i < n; i++){\n      rocks[i].clear();\n      for(int j = 0; j < 10; j++)\n\tfor(int k = 0; k <= m; k++)\n\t  dp[i][j][k] = INF;\n    }\n\n    for(int i = 0; i < 10; i++)\n      dp[0][i][0] = dp[1][i][1] = 0;\n    \n    //chap2\n    for(int i = 0; i < n; i++){\n      int kk;\n      cin >> kk;\n      for(int j = 0; j < kk; j++){\n\trock in;\n\tcin >> in.x >> in.d;\n\trocks[i].push_back(in);\n      }\n    }\n\n    //chap3\n    for(int i = 0; i < n - 1; i++){\n      for(int j = 0; j < rocks[i].size(); j++){\n\tfor(int k = 0; k < rocks[i + 1].size(); k++){\n\t  for(int l = 0; l <= m; l++){\n\t    dp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (rocks[i][j].d + rocks[i + 1][k].d) * (int)abs(rocks[i][j].x - rocks[i + 1][k].x));\n\t  }\n\t}\n\n\tif(i < n - 2){\n\t  for(int k = 0; k < rocks[i + 2].size(); k++){\n\t    for(int l = 0; l < m; l++){\n\t      dp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (rocks[i][j].d + rocks[i + 2][k].d) * (int)abs(rocks[i][j].x - rocks[i + 2][k].x));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i = 0; i < rocks[n - 1].size(); i++)\n      for(int j = 0; j <= m; j++)\n\tans = min(ans, dp[n - 1][i][j]);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdlib>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nclass State\n{\npublic:\n  int p, y, j, d;\n  State(int _p, int _y, int _j, int _d)\n    :p(_p), y(_y), j(_j), d(_d) {}\n  bool operator < (const State& st) const\n  {\n    return this->d > st.d;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if ((n|m) == 0)\n      break;\n\n    vector<vector<pair<int, int> > > s(n);\n    for (int i = 0; i < n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n\tint x, d;\n\tcin >> x >> d;\n\ts[i].push_back(make_pair(x, d));\n      }\n    }\n\n    priority_queue<State> que;\n    for (int i = 0; i < s[0].size(); ++i)\n      que.push(State(i, 0, 0, 0));\n    if (m > 0) {\n      for (int i = 0; i < s[1].size(); ++i)\n\tque.push(State(i, 1, 1, 0));\n    }\n\n    vector<vector<vector<int> > > dp(n, vector<vector<int> >(10, vector<int>(m+1, INF)));\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if ((st.y == n-2 && st.j < m) || st.y == n-1) {\n\tcout << st.d << endl;\n\tbreak;\n      }\n\n      if (dp[st.y][st.p][st.j] < st.d)\n\tcontinue;\n      dp[st.y][st.p][st.j] = st.d;\n\n      for (int i = 0; i < s[st.y+1].size(); ++i) {\n\tint danger = st.d + (s[st.y][st.p].second + s[st.y+1][i].second) * abs(s[st.y][st.p].first - s[st.y+1][i].first);\n\tif (dp[st.y+1][i][st.j] > danger) {\n\t  dp[st.y+1][i][st.j] = danger;\n\t  que.push(State(i, st.y+1, st.j, danger));\n\t}\n      }\n\n      if (st.j < m && st.y+2 < n) {\n\tfor (int i = 0; i < s[st.y+2].size(); ++i) {\n\t  int danger = st.d + (s[st.y][st.p].second + s[st.y+2][i].second) * abs(s[st.y][st.p].first - s[st.y+2][i].first);\n\t  if (dp[st.y+2][i][st.j+1] > danger) {\n\t    dp[st.y+2][i][st.j+1] = danger;\n\t    que.push(State(i, st.y+2, st.j+1, danger));\n\t  }\n\t}   \n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int inf = 999999;\n\nint memo[151][151];\nint func(vector<int> vec[151], int a[151][151], int n, int m, int rsk, int p, int q)\n{\n  if(p+1 == n){\n    return rsk;\n  }\n  if(memo[p][q] < rsk){\n    return memo[p][q];\n  }\n  if(vec[p].size() == 0){\n    return inf;\n  }\n\n  int v = inf, t;\n  if(m > 0){\n    if(p+2 >= n){\n      return rsk;\n    }\n    for(int i = 0; i < vec[p+2].size(); i++){\n      t = q-vec[p+2][i];\n      if(t < 0){\n\tt = -t;\n      }\n      v = min(v, func(vec, a, n, m-1, rsk+(a[p][q]+a[p+2][vec[p+2][i]])*t, p+2, vec[p+2][i]));\n    }\n  }\n\n  for(int i = 0; i < vec[p+1].size(); i++){\n    t = q-vec[p+1][i];\n    if(t < 0){\n      t = -t;\n    }\n    v = min(v, func(vec, a, n, m, rsk+(a[p][q]+a[p+1][vec[p+1][i]])*t, p+1, vec[p+1][i]));\n  }\n  memo[p][q] = min(memo[p][q], v);\n\n  return v;\n}\n\nint main()\n{\n  int n, m, s, t, u;\n\n  while(cin>>n>>m && n){\n    vector<int> vec[151];\n    int a[151][151];\n    fill(&a[0][0], &a[150][150], 0);\n    fill(&memo[0][0], &memo[150][150], inf);\n    for(int i = 0; i < n; i++){\n      cin >> u;\n      while(u--){\n\tcin >> s >> t;\n\tvec[i].push_back(s);\n\ta[i][s] = t;\n      }\n    }\n\n    u = inf;\n    for(int i = 0; i < vec[0].size(); i+=1){\n      u = min(u, func(vec, a, n, m, 0, 0, vec[0][i]));\n    }\n\n    cout << u << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\n\nint dp [150] [150];\nint n, m;\nvector<vector<int>> mp;\nvector<pii> st;\nint func(int pos, int stnum, int spc) {\n\tif (spc == m+1)\n\t\treturn -1;\n\tif (pos == n-1)\n\t\treturn 0;\n\tif (dp[stnum][spc] != -1)\n\t\treturn dp[stnum][spc];\n\tint res = INT_MAX;\n\tint w = st[stnum].first;\n\tint sb = st[stnum].second;\n\tREP(i, mp[pos+1].size()) {\n\t\tint cand = func(pos + 1, mp[pos + 1][i], spc);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0) {\n\t\t\tcand += (sb + st[mp[pos + 1][i]].second)*abs(w-st[mp[pos + 1][i]].first);\n\t\t}\n\t\tres = min(res, cand);\n\t}\n\tREP(i, mp[pos + 2].size()) {\n\t\tint cand = func(pos + 2, mp[pos + 2][i], spc+1);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0) {\n\t\t\tcand += (sb + st[mp[pos + 2][i]].second)*abs(w - st[mp[pos + 2][i]].first);\n\t\t}\n\t\tres = min(res,cand);\n\t}\n\tdp[stnum][spc] = res;\n\treturn res;\n}\n\nsigned main() {\n\twhile (scanf(\"%d %d\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tFill(dp, -1);\n\t\tmp.resize(n + 2);\n\t\tint s = 0;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tREP(j, c) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tmp[i].push_back(s);\n\t\t\t\tst.push_back({ a,b });\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tst.push_back({ -1,-1 });\n\t\tprintf(\"%d\\n\", func(-1, s, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Stone{\n  int x,d;\n  Stone(){}\n  Stone(int x, int d):x(x),d(d){}\n};\n\nint danger(Stone &a, Stone &b){ return abs(a.x-b.x)*(a.d+b.d);}\n\nconst int INF = 1<<30;\nint N,M;\nvector<Stone>s[256];\nint dp[160][16][80];\n\nint main(){\n  while(scanf(\"%d%d\", &N,&M) && N||M){\n    for(int i=0;i<256;i++) s[i].clear();\n    for(int i=0;i<N;i++){\n      int k; scanf(\"%d\", &k);\n      while(k--){\n\tint x,d; scanf(\"%d%d\",&x,&d);\n\ts[i].push_back(Stone(x,d));\n      }\n    }\n\n    for(int i=0;i<160;i++) for(int j=0;j<16;j++) for(int k=0;k<80;k++) dp[i][j][k] = INF;\n    for(int j=0;j<2;j++) for(int i=0;i<s[j].size();i++) dp[0][i][M-j] = 0;\n    for(int i=0;i<N-1;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int k=0;k<s[i+1].size();k++){\n\t  for(int m=0;m<=M;m++) \n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m]+danger(s[i][j],s[i+1][k]));\n\t}\n\tif(i<N-2){\n\t  for(int k=0;k<s[i+2].size();k++){\n\t    for(int m=1;m<=M;m++)\n\t      dp[i+2][k][m-1] = min(dp[i+2][k][m-1], dp[i][j][m]+danger(s[i][j],s[i+2][k]));\n\t  }\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=0;i<s[N-1].size();i++) for(int m=0;m<=M;m++) res = min(res, dp[N-1][i][m]);\n    for(int i=0;i<s[N-2].size();i++) for(int m=1;m<=M;m++) res = min(res, dp[N-2][i][m]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tREP(i, n - 1) REP(j, stone[i].size()) REP(k, m + 1) {\n\t\t\tpii &from = stone[i][j];\n\t\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2 && k > 0) {\n\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\tpii &to = stone[i + 2][l];\n\t\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\tpii &to = stone[i + 1][l];\n\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tif (n > 1) REP(i, stone[n - 2].size()) FOR(j, 1, m + 1) ans = min(ans, dp[n - 2][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m, c[155], p[155][15], v[155][15], dp[155][15][79];\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t\tfor (int j = 0; j < c[i]; j++) scanf(\"%d%d\", &p[i][j], &v[i][j]);\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < c[i]; j++) {\n\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\tdp[i][j][k] = 999999999;\n\t\t\t\t\tfor (int l = 0; l < c[i - 1]; l++) {\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + abs(p[i][j] - p[i - 1][l]) * (v[i][j] + v[i - 1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif (k == 0) continue;\n\t\t\t\t\tif (i == 1) {\n\t\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int l = 0; l < c[i - 2]; l++) {\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 2][l][k - 1] + abs(p[i][j] - p[i - 2][l]) * (v[i][j] + v[i - 2][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 999999999;\n\t\tfor (int i = 0; i < c[n - 1]; i++) ret = min(ret, dp[n - 1][i][m]);\n\t\tif (m >= 1) for (int i = 0; i < c[n - 2]; i++) ret = min(ret, dp[n - 2][i][m - 1]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 1005\n#define N 155\n#define S 85\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[S][N][M];\n\nint dijkstra(int sy,int sx){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<S;i++)\n    for(int j=0;j<n;j++)\n      for(int l=0;l<n;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint n, m;\nvector<pair<int, int> > data[150];\nint dp[150][10][80];\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    for(int i=0;i<n;i++) data[i].clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      for(int j=0;j<a;j++){\n        int b, c;\n        cin >> b >> c;\n        data[i].push_back(pair<int, int>(b, c));\n      }\n    }\n    fill(dp[0][0], dp[150][0], INF);\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[j].size();i++){\n        dp[j][i][m-j] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<data[i].size();j++){\n        for(int i1=0;i1<=m;i1++){\n          if(dp[i][j][i1] != INF){\n            for(int l=0;l<=1;l++){\n              if(i1-l<0) continue;\n              int next = i+1+l;\n              if(next >= n) continue;\n\n              for(int k=0;k<data[next].size();k++){\n                dp[next][k][i1-l] = min(dp[next][k][i1-l],\n                                   dp[i][j][i1] + (data[i][j].second + data[next][k].second) *\n                                   (abs(data[i][j].first - data[next][k].first)));\n              }\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[n-1-j].size();i++){\n        for(int k=j;k<=m;k++){\n          ans = min(ans, dp[n-1-j][i][k]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n\n#define N 200\n#define ACOL 100\n#define JUMP 100\n\nconst int infty=1<<29;\n\nusing namespace std;\n\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\n\nint dijkstra(int n,int m,\n\t     const vector< vector<int> > &C,\n\t     const vector< vector<int> > &D)\n{\n  static bool vis[N][ACOL][JUMP];\n  static int A[N][ACOL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<ACOL;++j)for(int k=0;k<JUMP;++k){vis[i][j][k]=false;A[i][j][k]=infty;}\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  \n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    if(s.r>=n+1){continue;}\n    vis[s.r][s.c][s.left]=true;\n    for(int k=1;k<=2;++k){\n      for(int i=0;i<C[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=i,nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(C[s.r][s.c]-C[nxr][nxc]),nxj=s.left-(k-1);\n\tif(s.r==0||nxr>=n+1)nxcost=s.cost;\n\tif(nxj<0)continue;\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc][nxj]&&A[nxr][nxc][nxj]>nxcost){A[nxr][nxc][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  int ret=infty;\n  for(int i=0;i<JUMP;++i){for(int j=0;j<ACOL;++j){\n      ret=min(A[n+1][j][i],min(A[n+2][j][i],ret));\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(cin.eof()||n==0&&m==0)break;\n    vector< vector<int> > D(n+3);D[n+1].push_back(0);D[n+2].push_back(0);\n    vector< vector<int> > C(n+3);C[n+1].push_back(0);C[n+2].push_back(0);\n    for(int i=0;i<n;++i){\n      int k;\n      cin>>k;\n      for(int j=0;j<k;++j){\n\tint col,danger;\n\tcin>>col>>danger;\n\tC[i+1].push_back(col);\n\tD[i+1].push_back(danger);\n      }\n    }\n    cout<<dijkstra(n,m,C,D)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nconst int inf = 4e8;\n\nint n, m;\nint k[150];\nint x[150][10];\nint d[150][10];\nint dp[150 * 10 * 76];\n\nint index(int i, int j, int k){\n\treturn (i * 10 + j) * (m + 1) + k;\n}\n\nint cost(int i, int j, int k, int l){\n\tint dx = x[i][j] - x[k][l];\n\treturn (d[i][j] + d[k][l]) * (dx >= 0 ? dx : -dx);\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, n){\n\t\t\tscanf(\"%d\", &k[i]);\n\t\t\trep(j, k[i]){\n\t\t\t\tscanf(\"%d%d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tfill_n(dp, index(n, 0, 0), inf);\n\n\t\trep(i, k[0]){\n\t\t\tdp[index(0, i, 0)] = 0;\n\t\t}\n\t\trep(i, k[1]){\n\t\t\tdp[index(1, i, 1)] = 0;\n\t\t}\n\n\t\tfor(int s = 1; s < n; ++s){\n\t\t\trep(t, k[s]){\n\t\t\t\trep(u, m + 1){\n\t\t\t\t\trep(v, k[s - 1]){\n\t\t\t\t\t\tdp[index(s, t, u)] = min(dp[index(s, t, u)], dp[index(s - 1, v, u)] + cost(s - 1, v, s, t));\n\t\t\t\t\t}\n\t\t\t\t\tif(s >= 2 && u >= 1){\n\t\t\t\t\t\trep(v, k[s - 2]){\n\t\t\t\t\t\t\tdp[index(s, t, u)] = min(dp[index(s, t, u)], dp[index(s - 2, v, u - 1)] + cost(s - 2, v, s, t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tint ans = inf;\n\t\trep(i, k[n - 1]){\n\t\t\trep(j, m + 1){\n\t\t\t\tans = min(dp[index(n - 1, i, j)], ans);\n\t\t\t}\n\t\t}\n\t\trep(i, k[n - 2]){\n\t\t\trep(j, m){\n\t\t\t\tans = min(dp[index(n - 2, i, j)], ans);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, 10) dp[0][i][m] = 0;\n\t\tREP(i, n - 1) REP(j, stone[i].size()) {\n\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2) {\n\t\t\t\tFOR(k, 1, m + 1) {\n\t\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\t\tint cost = (stone[i][j].second + stone[i + 2][l].second) * abs(stone[i][j].first - stone[i + 2][l].first);\n\t\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, m + 1) {\n\t\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\t\tint cost = (stone[i][j].second + stone[i + 1][l].second) * abs(stone[i][j].first - stone[i + 1][l].first);\n\t\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\t/*\n\t\tREP(i, n + 1) {\n\t\t\tREP(j, stone[i].size()) {\n\t\t\t\tint pri = INF;\n\t\t\t\tREP(k, m + 1) pri = min(pri, dp[i][j][k]);\n\t\t\t\tprintf(\"%d%c\", pri, j == stone[i].size() - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans;\nLL V[160][1010];\nLL mem[160][101][80];\n\nLL cal(int y,int x,int m){\n    LL res=INF;\n    if(mem[y][x][m]!=-1){\n        //cout<<\"hoge\"<<endl;\n        return mem[y][x][m];\n    }\n    if(y>=N)return 0;\n    if(y==0){\n        FOR(i,1,1000){\n            if(V[y+1][i]!=INF)\n            res=cal(y+1,i,m);\n        }\n    }\n    else{\n        if(V[y][x]!=INF){\n            FOR(i,1,1000){\n                    if(m>0&&V[y+1][i]!=INF&&V[y+2][i]!=INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,min(cal(y+2,i,m-1)+d2,res));\n                    }\n                    else if(V[y+1][i]!=INF&&V[y+2][i]==INF){\n                        LL d1=(V[y][x]+V[y+1][i])*abs(x-i);\n                        res=min(cal(y+1,i,m)+d1,res);\n                    }\n                    else if(V[y+1][i]==INF&&V[y+2][i]!=INF&&m>0){\n                        LL d2=(V[y][x]+V[y+2][i])*abs(x-i);\n                        res=min(cal(y+2,i,m-1)+d2,res);\n                    }\n            }\n        }\n    }\n    return mem[y][x][m]=res;\n}\n\nint main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(mem,-1,sizeof(mem));\n        rep(i,151)rep(j,1001)V[i][j]=INF;\n        FOR(i,1,N){\n            LL t;\n            cin>>t;\n            rep(j,t){\n                LL x,k;\n                cin>>x>>k;\n                V[i][x]=k;\n            }\n        }\n        ans=cal(0,0,M);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 10000000;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define int long long\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m;\nll dp[155][80][1005];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<vector<pair<int, int>>> st(155);\n        rep(i, n) {\n            int k;\n            cin >> k;\n            rep(j, k) {\n                int x, d;\n                cin >> x >> d;\n                x--;\n                st[i].push_back({x, d});\n            }\n        }\n        rep(i, 155)rep(j, 80)rep(k, 1005) dp[i][j][k] = LLONG_MAX / 2;\n        for (auto p : st[0]) {\n            dp[0][0][p.fi] = 0;\n        }\n        if (m != 0) {\n            for (auto p : st[1]) {\n                dp[1][1][p.fi] = 0;\n            }\n        }\n        rep(i, n)rep(j, m + 1) {\n            for (auto now : st[i]) {\n                if (dp[i][j][now.fi] == LLONG_MAX / 2) continue;\n                if (i + 1 >= n) continue;\n                for (auto nx : st[i + 1]) {\n                    dp[i + 1][j][nx.fi] = min(dp[i + 1][j][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se + nx.se));\n                }\n                if (i + 2 >= n || j + 1 > m) continue;\n                for (auto nx : st[i + 2]) {\n                    dp[i + 2][j + 1][nx.fi] = min(dp[i + 2][j + 1][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se  + nx.se));\n                }\n            }\n        }\n        rep(j, m + 1)rep(k, 1001) ans = min(ans, dp[n - 1][j][k]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  while (cin >> n >> m, n) {\n    int dp[200][15][100] = {0};\n    vector<pii> G[200];\n\n    for (int i = 1; i <= n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n        int x, d;\n        cin >> x >> d;\n        G[i].PB(pii(x, d));\n      }\n    }\n    G[n + 1].PB(pii(0, 0));\n\n    fill(dp[2][0], dp[200][0], INF);\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 0; j < G[i].size(); ++j) {\n        for (int k = 0; k <= m; ++k) {\n          for (int dy = 1; dy <= 2; ++dy) {\n            for (int j2 = 0; j2 < G[i + dy].size(); ++j2) {\n              if (dp[i][j][k] == INF) continue;\n              pii p1 = G[i][j], p2 = G[i + dy][j2];\n              int move = abs(p1.first - p2.first), sumd = p1.second + p2.second;\n              if (i + dy == n + 1) sumd = 0;\n              dp[i + dy][j2][k + dy - 1] = min(dp[i + dy][j2][k + dy - 1], dp[i][j][k] + sumd * move);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < G[n].size(); ++i) {\n      for (int j = 0; j <= m; ++j) {\n        ans = min(ans, dp[n + 1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(int)ve[2].size();i++){\n\t\t\tve[0].push_back(ve[2][i]);\n\t\t\tdp[T][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[1].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=M;j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tif(M!=0)for(int i=0;i<M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N-1].size();j++){\n\t\t\t\tres=min(res,dp[T][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\n#define F 1145141919\nusing namespace std;\nint sw[16000],sh[16000];\nint be[150];\nint dp[80][16000];\nint main(){\n\tint n,m,k;\n\twhile(true){\n\tcin>>n>>m;\n\tif(!n&&!m)break;\n\tcin>>k;\n\tfor(int i=0;i<k;i++)cin>>sw[i]>>sh[i];\n\tbe[0]=0,be[1]=k;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>k;\n\t\tbe[i+1]=be[i]+k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>sw[j+be[i]]>>sh[j+be[i]];\n\t\t\tfor(int r=0;r<=m;r++)dp[r][j+be[i]]=F;\n\t\t}\n\t}\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<n-1;j++){\n\t\t\tfor(int f=be[j];f<be[j+1];f++){\n\t\t\t\tfor(int g=be[j+1];g<be[j+2];g++)dp[i][g]=min(dp[i][g],dp[i][f]+abs(sw[f]-sw[g])*(sh[f]+sh[g]));\n\t\t\t\tif(m-i&&n-2-j)for(int g=be[j+2];g<be[j+3];g++)dp[i+1][g]=min(dp[i+1][g],dp[i][f]+abs(sw[f]-sw[g])*(sh[f]+sh[g]));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=F;\n\tfor(int i=be[n-1];i<be[n];i++)for(int j=0;j<=m;j++)ans=min(ans,dp[j][i]);\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int, int> P;\nint n, m;\nint dp[76][150][10], kosu[150];\nP stone[150][10];\nint main()\n{\n\twhile(cin >> n >> m && n)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> kosu[i];\n\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t{\n\t\t\t\tcin >> stone[i][j].F >> stone[i][j].S;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= m; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tfor(int k = 0; k < kosu[j]; k++)\n\t\t\t\t\tdp[i][j][k] = 1 << 30;\n\t\tfor(int i = 0; i < kosu[0]; i++)\n\t\t\tdp[0][0][i] = 0;\n\t\t\t\tfor(int i = 0; i < n - 1; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 1]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int l = 0; l <= m; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(dp[l][i][j] < 1 << 30)\n\t\t\t\t\t\t\t\t\tdp[l][i + 1][k] = min((stone[i + 1][k].S + stone[i][j].S) * abs(stone[i + 1][k].F - stone[i][j].F) + dp[l][i][j], dp[l][i + 1][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i + 2 < n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 2]; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor(int l = 0; l < m; l++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(dp[l][i][j] < 1 << 30)\n\t\t\t\t\t\t\t\t\t\tdp[l + 1][i + 2][k] = min((stone[i + 2][k].S + stone[i][j].S) * abs(stone[i + 2][k].F - stone[i][j].F) + dp[l][i][j], dp[l + 1][i + 2][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tfor(int i = 0; i <= m; i++)\n\t\t\t\t\tfor(int j = 0; j < kosu[n - 1]; j++)\n\t\t\t\t\t\tans = min(ans, dp[i][n - 1][j]);\n\t\t\t\t\tcout << ans << endl;\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  /*\n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\tfor(int a=0;a<=m;a++){\n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  \n\t}\n      }\n    }\n\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 152;\nconst int MAX_K = 22;\n\nint a[MAX_N];\nint dp[MAX_N][MAX_K][(MAX_N+1)/2];\nint n,m,K;\nvector<int> S[MAX_N];\nvector<int> T[MAX_N];\n\nint main()\n{\n\twhile(1){\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0){\n\t\tbreak;\n\t}\n\trep(i,n+1){\n\t\tS[i].clear();\n\t\tT[i].clear();\n\t}\n\trep(i,n){\n\t\tscanf(\"%d\",&K);\n\t\trep(j,K){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tS[i].push_back(x-1);\n\t\t\tT[i].push_back(y);\n\t\t}\n\t}\n\trep(i,S[n-2].size()){\n\t\tS[n].push_back(S[n-2][i]);\n\t\tT[n].push_back(0);\n\t}\n\trep(i,S[n-1].size()){\n\t\tS[n].push_back(S[n-1][i]);\n\t\tT[n].push_back(0);\n\t}\n\tfill(dp[0][0],dp[n+1][0],INF);\n\trep(j,S[0].size()){\n\t\tdp[0][j][0] = 0;\n\t}\n\trep(j,S[1].size()){\n\t\trep(l,S[0].size()){\n\t\t\tdp[1][j][0] = min(dp[1][j][0],(T[0][l]+T[1][j])*abs(S[1][j]-S[0][l]));\n\t\t}\n\t\tif(m>=1){\n\t\t\tdp[1][j][1] = 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\trep(j,S[i+1].size()){\n\t\t\trep(k,m+1){\n\t\t\t\trep(l,S[i].size()){\n\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i][l][k]+(T[i][l]+T[i+1][j])*abs(S[i+1][j]-S[i][l]));\n\t\t\t\t}\n\t\t\t\tif(k>=1){\n\t\t\t\t\trep(l,S[i-1].size()){\n\t\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i-1][l][k-1]+(T[i-1][l]+T[i+1][j])*abs(S[i+1][j]-S[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(j,S[n].size()){\n\t\trep(k,m+1){\n\t\t\tans = min(ans,dp[n][j][k]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<string>\n#include<stack>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define fr first\n#define sc second\n#define INF INT_MAX\ntypedef pair<int,int> Pi;\ntypedef pair< Pi,pair<Pi,int> > P;\nstruct Edge{\n  int to,denger;\n  Edge(){}\n  Edge(int to,int denger):to(to),denger(denger){};\n};\nint n,m;\nint m_cost[151][11][(151+1)/2+1];\nvector<vector<Edge> > info;\nint Dijkstra();\nint main(){\n  while(cin >> n >> m && n||m){\n    info.resize(n);\n    for(int i=0,k;i<n;i++){\n      cin >> k;\n      for(int j=0,t,d;j<k;j++){\n        cin >> t >> d;\n        info[i].push_back(Edge(t,d));\n      }\n    }\n    cout << Dijkstra() << endl;\n    info.clear();\n  }\n}\nint Dijkstra(){\n  for(int i=0;i<151;i++){\n    for(int j=0;j<11;j++){\n      for(int k=0;k<(151+1)/2+1;k++){\n        m_cost[i][j][k] = INF;\n      }\n    }\n  }\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0,l=info[0].size();i<l;i++){\n    que.push(P(Pi(0,m),make_pair(Pi(0,info[0][i].to),info[0][i].denger)));\n    m_cost[0][i][m] = 0;\n  }\n  if(m != 0){\n    for(int i=0,l=info[1].size();i<l;i++){\n      que.push(P(Pi(0,m-1),make_pair(Pi(1,info[1][i].to),info[1][i].denger)));\n      m_cost[1][i][m-1] = 0;\n    }\n  }\n  while(!que.empty()){\n    P p = que.top();\n    int den = p.fr.fr,limit = p.fr.sc,slip=p.sc.sc;\n    Pi pt = Pi(p.sc.fr.fr,p.sc.fr.sc);\n    que.pop();\n    if(pt.fr + 1 >= n) return den;\n    for(int j=1;j<3;j++){\n      if(j==2 && limit == 0) break;\n      if(j==2 && pt.fr + 1 == n) break;\n      if(j==2 && pt.fr + 2 == n) return den;\n      if(j==1 && pt.fr + 1 == n) return den;\n      for(int i=0,l=info[pt.fr+j].size();i<l;i++){\n        int next_now = info[pt.fr+j][i].to;\n        int next_den = info[pt.fr+j][i].denger;\n        int hmhm = den + (slip + next_den) * abs(next_now - pt.sc);\n        if(hmhm < m_cost[pt.fr+j][i][limit-(j-1)]){\n          m_cost[pt.fr+j][i][limit-(j-1)] = hmhm;\n          que.push(P(Pi(hmhm,limit-(j-1)),make_pair(Pi(pt.fr+j,next_now),next_den)));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n \n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n \nusing namespace std;\n \ntypedef pair<int,int> P;\n \nint main(void){\n \n  int n,m,k,a,b;\n \n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n     \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n    \tcin >> a >> b;\n   \t\t v[i].push_back(make_pair(a,b));\n      }\n    }\n \n    int dp[MAX_N][11][80];\n \n    for(int i=0;i<MAX_N;i++)\n      \tfor(int j=0;j<11;j++)\n  \t\t\tfor(int k=0;k<80;k++)\n      \t\t\tdp[i][j][k]=INF;\n \n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n    \tdp[0][i][j]=dp[1][i][j]=0;\n \n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n    \tfor(int l=m;l>=0;l--){\n      \t\tfor(int k=0;k<v[i-1].size();k++)\n        \tdp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n      \t\t\n      \t\tif(l<m){\n        \t\tif(i==2)dp[i][j][l]=0;\n        \t\tfor(int p=0;p<v[i-2].size();p++)\n          \t\t\tdp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n      \t\t}\n    \t}\n      }\n    }\n     \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>0)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n \n    cout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nvector<P>St[256];\nint N, M;\nint dp[256][16][128];\n\nint dfs(int n, int x, int m){\n  //  cout << n << \" \" << x << endl;\n  if(n>=N-1) return 0;\n  int &res = dp[n][x][m];\n  if(res >= 0) return res;\n  \n  res = INF;\n  int pos = St[n][x].first ,slip = St[n][x].second;\n  rep(i, St[n+1].size()){\n      P tar = St[n+1][i];\n      res = min(res, dfs(n+1, i, m)+(slip+tar.second)*(abs(pos-tar.first)));\n  }\n  if(m){\n    rep(i, St[n+2].size()){\n      P tar = St[n+2][i];\n      res = min(res, dfs(n+2, i, m-1)+(slip+tar.second)*(abs(pos-tar.first)));\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &N, &M) && N){\n    int k, x, d;\n    memset(dp, -1, sizeof(dp));\n    rep(i,N) St[i].clear();\n    rep(i, N){\n      scanf(\"%d\", &k);\n      rep(j,k){\n\tscanf(\"%d%d\", &x, &d);\n\tSt[i].push_back(P(x, d));\n      }\n    }\n    \n    int res = INF;\n    rep(i, St[0].size()){\n      res = min(res, dfs(0, i, M));\n    }\n\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define INF (1 << 25)\nusing namespace std;\n\nint main(){\n  int n, m, tmp;\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    int dp[3][10][100];\n    memset(dp, 0, sizeof(dp));\n    vector< pair<int, int> >stones[n];\n    for(int i = 0;i < n;i++){\n      int k, l, m;\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;j++){\n\tscanf(\"%d %d\", &l, &m);\n\tstones[i].push_back(make_pair(l, m));\n      }\n    }\n    for(int i = 0;i < n;i++){\n      int ind = i%3, prev = (i - 1) % 3, prepre = (i - 2) % 3;\n\n      for(int j = 0;j < stones[i].size();j++)\n\tfor(int k = 0;k <= m;k++)\n\t  dp[ind][j][k] = INF;\n\n      for(int j = 0;j < stones[i].size();j++){\n\tif(i == 0)dp[ind][j][m] = 0;\n\telse if(i == 1 && m - 1 >= 0)dp[ind][j][m - 1] = 0;\n      }\n      for(int j = 0;j < stones[i].size();j++){\n\tfor(int k = 0;k <= m;k++){\n\t  for(int l = 0;i > 0 && l < stones[i - 1].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prev][l][k] + abs(stones[i - 1][l].first - stones[i][j].first) * (stones[i - 1][l].second + stones[i][j].second));\n\t  }\n\t  for(int l = 0;i > 1 && k < m && l < stones[i - 2].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prepre][l][k + 1] + abs(stones[i - 2][l].first - stones[i][j].first) * (stones[i - 2][l].second + stones[i][j].second));\n\t  }\n\t}\n      }\n    }\n    int res = INF;\n    for(int i = 0;i < stones[n - 1].size();i++){\n      for(int j = 0;j <= m;j++){\n\tres = min(res, dp[(n - 1) % 3][i][j]);\n      }\n    }\n    if(n - 2 >= 0){\n      for(int i = 0;i < stones[n - 2].size();i++){\n\tfor(int j = 1;j <= m;j++){\n\t  res = min(res,dp[(n - 2) % 3][i][j];\n\t}\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int, int> P;\nint n, m;\nint dp[80][200][20], kosu[1600];\nP stone[1600][20];\nint main()\n{\n\twhile(cin >> n >> m && n)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> kosu[i];\n\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t{\n\t\t\t\tcin >> stone[i][j].F >> stone[i][j].S;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= m; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tfor(int k = 0; k < kosu[j]; k++)\n\t\t\t\t\tdp[i][j][k] = 1 << 30;\n\t\tfor(int i = 0; i < kosu[0]; i++)\n\t\t\tdp[0][0][i] = 0;\n\t\t\t\tfor(int i = 0; i < n - 1; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 1]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int l = 0; l <= m; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(dp[l][i][j] < 1 << 30)\n\t\t\t\t\t\t\t\t\tdp[l][i + 1][k] = min((stone[i + 1][k].S + stone[i][j].S) * abs(stone[i + 1][k].F - stone[i][j].F) + dp[l][i][j], dp[l][i + 1][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i + 2 < n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 2]; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor(int l = 0; l < m; l++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(dp[l][i][j] < 1 << 30)\n\t\t\t\t\t\t\t\t\t\tdp[l + 1][i + 2][k] = min((stone[i + 2][k].S + stone[i][j].S) * abs(stone[i + 2][k].F - stone[i][j].F) + dp[l][i][j], dp[l + 1][i + 2][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tfor(int i = 0; i <= m; i++)\n\t\t\t\t\tfor(int j = 0; j < kosu[n - 1]; j++)\n\t\t\t\t\t\tans = min(ans, dp[i][n - 1][j]);\n\t\t\t\t\tcout << ans << endl;\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 1000000000\nint n,m;\nint d[80][150][10];\nint r[150][1000];\nint f[150][10];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(i=0;i<n;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\td[k][i][j]=INF;\n\t\t}\n\t\tfor(i=0;i<c[0];i++){\n\t\t\td[m][0][i]=0;\n\t\t}\n\t\tif(m>=1)for(j=0;j<c[1];j++){\n\t\t\td[m-1][1][j]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][k]=min(d[j][i][k],d[j+1][i-2][l]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][k]=min(d[j][i][k],d[j][i-1][l]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][j]);\n\t\t}\n\t\tfor(i=1;i<=m;i++)for(j=0;j<c[n-2];j++){\n\t\t\tans=min(ans,d[i][n-2][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<MAX_V; i++){\n    ans=min(d[n-1][i],ans);\n    ans=min(d[n][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n-1; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(0);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(1));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint fie[152][1002][78];\nint main(){\n    while(1){\n        int M,N;\n        cin>>M>>N;\n        if(M==0&&N==0)break;\n        int lis[154][1002];\n        for(int i=0;i<154;i++){\n            for(int j=0;j<1002;j++){\n                if(i!=0&&i!=M+1)lis[i][j]=-1;\n                else lis[i][j]=0;\n            }\n        }\n        for(int i=0;i<152;i++){\n            for(int j=0;j<1002;j++){\n                for(int k=0;k<78;k++){\n                    if(i!=0||k!=0)fie[i][j][k]=2000000000;\n                    else fie[i][j][k]=0;\n                }\n            }\n        }\n        for(int i=0;i<M;i++){\n            int a;\n            cin>>a;\n            for(int j=1;j<=a;j++){\n                int b,c;\n                cin>>b>>c;\n                lis[i+1][b]=c;\n            }\n        }\n        for(int i=0;i<=M;i++){\n            for(int j=0;j<1002;j++){\n                for(int k=0;k<76;k++){\n                    if(fie[i][j][k]<2000000000){\n                        for(int l=0;l<1002;l++){\n                            if(lis[i+1][l]!=-1)\n                                fie[i+1][l][k]=min(fie[i+1][l][k],fie[i][j][k]+(lis[i][j]+lis[i+1][l])*(int)fabs(j-l));\n                            if(lis[i+2][l]!=-1)fie[i+2][l][k+1]=min(fie[i+2][l][k+1],fie[i][j][k]+(lis[i][j]+lis[i+2][l])*(int)fabs(j-l));\n                        }\n                    }\n                }\n            }\n        }\n        int ans=2000000000;\n        for(int j=0;j<1002;j++){\n            for(int k=0;k<76;k++){\n                if(k<=N)ans=min(ans,fie[M+1][j][k]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint N,M;\nint K[200];int X[200][10];int D[200][10];\nint dp[200][10][100];\nint INF=1000*1000*1000;\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(N==0&&M==0)return 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&K[i]);\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tscanf(\"%d%d\",&X[i][j],&D[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<K[0];j++)dp[0][j][0]=0;\n\t\tfor(int j=0;j<K[1];j++)dp[1][j][1]=0;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\t\tif(i==1&&k!=0)continue;\n\t\t\t\t\tint dpijk=INF;\n\t\t\t\t\tif(i!=1&&k!=0){\n\t\t\t\t\t\tfor(int l=0;l<K[i-2];l++){\n\t\t\t\t\t\t\tdpijk=min(dpijk,dp[i-2][l][k-1]+(D[i-2][l]+D[i][j])*abs(X[i-2][l]-X[i][j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l=0;l<K[i-1];l++){\n\t\t\t\t\t\tdpijk=min(dpijk,dp[i-1][l][k]+(D[i-1][l]+D[i][j])*abs(X[i-1][l]-X[i][j]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=dpijk;\n\t\t\t\t\t//printf(\"%d,%d,%d:%d\\n\",i,j,k,dpijk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int j=0;j<K[N-1];j++){\n\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\tans=min(ans,dp[N-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n\n#define N 200\n#define ACOL 100\n#define JUMP 100\n\nconst int infty=1<<29;\n\nusing namespace std;\n\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\n\nint dijkstra(int n,int m,\n\t     const vector< vector<int> > &C,\n\t     const vector< vector<int> > &D)\n{\n  static bool vis[N][ACOL][JUMP];\n  static int A[N][ACOL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<ACOL;++j)for(int k=0;k<JUMP;++k){vis[i][j][k]=false;A[i][j][k]=infty;}\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  \n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    if(s.r>=n+1){continue;}\n    vis[s.r][s.c][s.left]=true;\n    for(int k=1;k<=2;++k){\n      for(int i=0;i<C[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=i,nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(C[s.r][s.c]-C[nxr][nxc]),nxj=s.left-(k-1);\n\tif(s.r==0||nxr>=n+1)nxcost=s.cost;\n\tif(nxj<0)continue;\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc][nxj]&&A[nxr][nxc][nxj]>nxcost){A[nxr][nxc][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  int ret=infty;\n  for(int i=0;i<JUMP;++i){for(int j=0;j<ACOL;++j){\n      ret=min(A[n+1][j][i],min(A[n+2][j][i],ret));\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(n==0&&m==0)break;\n    vector< vector<int> > D(n+3);D[0].push_back(0);D[n+1].push_back(0);D[n+2].push_back(0);\n    vector< vector<int> > C(n+3);C[0].push_back(0);C[n+1].push_back(0);C[n+2].push_back(0);\n    for(int i=0;i<n;++i){\n      int k;\n      cin>>k;\n      for(int j=0;j<k;++j){\n\tint col,danger;\n\tcin>>col>>danger;\n\tC[i+1].push_back(col);\n\tD[i+1].push_back(danger);\n      }\n    }\n    cout<<dijkstra(n,m,C,D)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n//#define int long long\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m;\nll dp[155][80][1005];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<vector<pair<int, int>>> st(155);\n        rep(i, n) {\n            int k;\n            cin >> k;\n            rep(j, k) {\n                int x, d;\n                cin >> x >> d;\n                x--;\n                st[i].push_back({x, d});\n            }\n        }\n        rep(i, 155)rep(j, 80)rep(k, 1005) dp[i][j][k] = LLONG_MAX / 2;\n        for (auto p : st[0]) {\n            dp[0][0][p.fi] = 0;\n        }\n        if (m != 0) {\n            for (auto p : st[1]) {\n                dp[1][1][p.fi] = 0;\n            }\n        }\n        rep(i, n)rep(j, m + 1) {\n            for (auto now : st[i]) {\n                if (dp[i][j][now.fi] == LLONG_MAX / 2) continue;\n                if (i + 1 >= n) continue;\n                for (auto nx : st[i + 1]) {\n                    dp[i + 1][j][nx.fi] = min(dp[i + 1][j][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se + nx.se));\n                }\n                if (i + 2 >= n || j + 1 > m) continue;\n                for (auto nx : st[i + 2]) {\n                    dp[i + 2][j + 1][nx.fi] = min(dp[i + 2][j + 1][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se  + nx.se));\n                }\n            }\n        }\n        ll ans = LLONG_MAX / 2;\n        rep(j, m + 1)rep(k, 1001) ans = min(ans, dp[n - 1][j][k]);\n        rep(j, m)rep(k, 1001) ans = min(ans, dp[n - 2][j][k]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Solution for aoj:0530 Pyon-Pyon River Crossing\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int INF = 100000000, MAX_N = 150;\ntypedef pair<int, int> P;\nint n, m, ans;\nint dp[MAX_N + 2][11][76];\nP stone, stone2;\nvector<P> Stone[151]; //first:??????second:???????????????\nint main(){\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++){\n\t\tint a, b, c;\n\t\tcin >> c;\n\t\tfor (int j = 0; j < c; j++){\n\t\t\tcin >> a >> b;\n\t\t\tStone[i].push_back(P(a, b));\n\t\t}\n\t}\n\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\tstone = Stone[2][i];\n\t\tdp[2][stone.first][m - 1] = 0;\n\t}\n\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\tstone = Stone[2][i];\n\t\tdp[2][stone.first][m] = INF;\n\t}\n\tfor (int i = 3; i <= n; i++){\n\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\tstone = Stone[i][j];\n\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\tdp[i][stone.first][k] = INF;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\tstone = Stone[i][j];\n\t\t\tfor (int k = 0; k < Stone[i + 1].size(); k++){\n\t\t\t\tstone2 = Stone[i + 1][k];\n\t\t\t\tfor (int l = m; l >= m - i / 2; l--){\n\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < Stone[i + 2].size(); k++){\n\t\t\t\tstone2 = Stone[i + 2][k];\n\t\t\t\tfor (int l = m - 1; l >= m - i / 2; l--){\n\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdp[i + 2][stone2.first][l] = min(dp[i + 2][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans = INF;\n\tfor (int i = 0; i < Stone[n].size(); i++){\n\t\tstone = Stone[n][i];\n\t\tans = min(dp[n][stone.first][0], ans);\n\t}\n\tfor (int i = 0; i < Stone[n - 1].size(); i++){\n\t\tstone = Stone[n - 1][i];\n\t\tif (dp[n - 1][stone.first][1])\n\t\t\tans = min(dp[n - 1][stone.first][1], ans);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1e+9;\ntypedef pair<int, int> P;\n\nint memo[151][11][80];\nint N, M;\nvector<P> G[151];\n\nint rec(int n, int p, int m){\n\tif(memo[n][p][m] != -1)\n\t\treturn memo[n][p][m];\n\t\t\n\tint res = INF;\n\tif(n > N){\n\t\treturn 0;\n\t}\n\tif(n == N){\n\t\treturn 0;\n\t}\n\tif(n == N - 1 && m >= 1){\n\t\tres = min(res, rec(n + 2, p, m - 1));\n\t}\n\telse{\n\t\tfor(int i = 0; i < G[n].size(); ++i){\n\t\t\tres = min(res, rec(n + 1, i, m) + (G[n - 1][p].second + G[n][i].second) * abs(G[n][i].first - G[n - 1][p].first));\n\t\t}\n\t\tif(n != N - 1 && m >= 1){\n\t\t\tfor(int i = 0; i < G[n + 1].size(); ++i){\n\t\t\t\tres = min(res, rec(n + 2, i, m - 1) + (G[n - 1][p].second + G[n + 1][i].second) * abs(G[n + 1][i].first - G[n - 1][p].first));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[n][p][m] = res;\n}\n\nint main() {\n\twhile(cin >> N >> M && (N || M)){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor(int i = 0; i <= 150; ++i)\n\t\t\tG[i].clear();\n\t\tint k, d, x;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor(int j = 0; j < k; ++j){\n\t\t\t\tscanf(\"%d%d\", &d, &x);\n\t\t\t\tG[i].push_back(P(d, x));\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i = 0; i < G[0].size(); ++i){\n\t\t\tans = min(ans, rec(1, i, M));\n\t\t\tif(M >= 1){\n\t\t\t\tfor(int i = 0; i < G[1].size(); ++i){\n\t\t\t\t\tans = min(ans, rec(2, i, M - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<fstream>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint DP[150][100][11];\nint N, M;\nint K[150];\nint X[150][10], Y[150][10];\nint main()\n{\n\twhile (true){\n\t\t\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0)break;\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tfor (int k = 0; k <= 10; k++){\n\t\t\t\t\tDP[i][j][k] = 1000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tcin >> K[i];\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tcin >> X[i][j] >> Y[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < K[0]; j++){\n\t\t\tDP[0][j][0] = 0;\n\t\t}\n\t\tfor (int j = 0; j < K[1]; j++){\n\t\t\tDP[1][j][1] = 0;\n\t\t}\n\t\tfor (int j = 0; j < K[1]; j++){\n\t\t\tfor (int k = 0; k < K[0]; k++){\n\t\t\t\tDP[1][j][0] = min(DP[1][j][0], DP[0][k][0]+(Y[1][j] + Y[0][k])*abs(X[1][j] - X[0][k]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i < N; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i - 1]; k++){\n\t\t\t\t\tfor (int l = 0; l <= M; l++){\n\t\t\t\t\t\tDP[i][j][l] = min(DP[i][j][l], DP[i - 1][k][l] + (Y[i][j] + Y[i - 1][k])*abs(X[i][j] - X[i - 1][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < K[i - 2]; k++){\n\t\t\t\t\tfor (int l = 0; l < M; l++){\n\t\t\t\t\t\tDP[i][j][l + 1] = min(DP[i][j][l + 1], DP[i - 2][k][l] + (Y[i][j] + Y[i - 2][k])*abs(X[i][j] - X[i - 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\t\n\t\tfor (int j = 0; j < K[N - 1]; j++){\n\t\t\tfor (int k = 0; k <= M; k++){\n\t\t\t\tans = min(ans, DP[N - 1][j][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < K[N - 2]; j++){\n\t\t\tfor (int k = 0; k < M; k++){\n\t\t\t\tans = min(ans, DP[N - 2][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\t/*\n\t\tint XX;\n\t\tfin1 >> XX;\n\t\tif (ans == XX){\n\t\t\tprintf(\"YES\\n\");\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tbreak;\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define INF 10000000000000000\nstruct S {int x,d;};\nint n,m;\nint dp[152][1002][80];//n,x,m\nvector<S> a[152];\n\nsigned main(){\n  while(cin>>n>>m,n){\n    REP(i,n)a[i].clear();\n    REP(i,n){\n      int k,x,d;\n      cin>>k;\n      REP(j,k){\n        cin>>x>>d;\n        a[i].push_back({x,d});\n      }\n    }\n    REP(i,n)REP(j,1000)REP(k,m+1)dp[i][j+1][k]=INF;\n    REP(j,1000)dp[0][j+1][0]=0;\n    REP(i,n-1){\n      for(S s:a[i]){\n        for(S t:a[i+1]){\n          REP(c,m+1){\n            dp[i+1][t.x][c]=min(dp[i+1][t.x][c],dp[i][s.x][c]+(s.d+t.d)*abs(s.x-t.x));\n          }\n        }\n        if(i+2>=n)continue;\n        for(S u:a[i+2]){\n          REP(c,m){\n            dp[i+2][u.x][c+1]=min(dp[i+2][u.x][c+1],dp[i][s.x][c]+(s.d+u.d)*abs(s.x-u.x));\n          }\n        }\n      }\n    }\n    int ans=INF;\n    REP(i,1000)REP(c,m+1)ans=min(ans,dp[n-1][i+1][c]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst ll INF = 10000000000000LL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int n, m;\n  while(cin>>n>>m && n){\n    static ll dp[150][10][77] = {};\n    REP(i, 150)REP(j, 10)REP(k, 77) dp[i][j][k] = INF;\n    int k[151], x[151][151], s[151][151];\n    REP(i, n){\n      cin>>k[i];\n      REP(j, k[i]) cin>>x[i][j]>>s[i][j];\n    }\n    REP(i, k[0]) dp[0][i][0] = 0;\n    REP(i, k[1]) dp[1][i][1] = 0;\n    for(int i = 0; i < n - 1; i++){\n      for(int j = 0; j < k[i]; j++){\n        int from_x = x[i][j];\n        for(int l = 0; l < k[i + 1]; l++){\n          int to_x = x[i + 1][l];\n          for(int use = 0; use <= m; use++){\n            dp[i + 1][l][use] = min(dp[i + 1][l][use], dp[i][l][use] + (s[i][j] + s[i + 1][l]) * abs(from_x - to_x));\n          }\n        }\n        if(i + 2 < n){\n          for(int l = 0; l < k[i + 2]; l++){\n            int to_x = x[i + 2][l];\n            for(int use = 0; use < m; use++){\n              dp[i + 2][l][use + 1] = min(dp[i + 2][l][use + 1], dp[i][j][use] + (s[i][j] + s[i + 2][l]) * abs(from_x - to_x));\n            }\n          }\n        }\n      }\n    }\n    ll ans = INF;\n    REP(i, k[n - 1])REP(j, m + 1) ans = min(ans, dp[n-1][i][j]);\n    REP(i, k[n - 2])REP(j, m ) ans = min(ans, dp[n-2][i][j]);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n | m)\n\t{\n\t\tint k[200], x[200][16], d[200][16];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", k + i);\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t\tscanf(\"%d%d\", &x[i][j], &d[i][j]);\n\t\t}\n\n\t\tconst int INF = 1 << 26;\n\t\tstatic int dp[200][16][100];\t// row, column, jump left\n\t\tfor (int i = 0; i < 200; ++i)\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tfor (int a = 0; a < 100; ++a)\n\t\t\t\t\tdp[i][j][a] = INF;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tdp[i][j][m - i] = 0;\n\n\t\tfor (int i = 0; i < n - 1; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t{\n\t\t\t\tfor (int a = 0; a <= m; ++a)\n\t\t\t\t{\n\t\t\t\t\tfor (int b = 0; b < k[i + 1]; ++b)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin_swap(dp[i + 1][b][a]\n\t\t\t\t\t\t, dp[i][j][a] + (d[i][j] + d[i + 1][b]) * abs(x[i][j] - x[i + 1][b]));\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 2 < n && a > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int b = 0; b < k[i + 2]; ++b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmin_swap(dp[i + 2][b][a - 1],\n\t\t\t\t\t\t\t\tdp[i][j][a] + (d[i][j] + d[i + 2][b]) * abs(x[i][j] - x[i + 2][b]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = n - 2; i < n; ++i)\n\t\t\tfor (int j = 0; j < k[i]; ++j)\n\t\t\t\tfor (int a = 0; a <= m; ++a)\n\t\t\t\t\tif (i == n - 1 || a > 0)\n\t\t\t\t\t\tmin_swap(res, dp[i][j][a]);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint n,m;\nint d[76][151][1001];\nqueue< pair<int,int> > qxy;\nqueue<int> qm;\nqueue<int> qs;\n\nint main(){\n    while(true){\n\tcin >> n >> m;\n\tif(n == 0 && m == 0) break;\n\tmemset(d,-1,sizeof(d));\n\tint ans = 100000000;\n\tvector< vector< pair<int,int> > > coor(n);\n\tREP(i,n){\n\t    int k;\n\t    cin >> k;\n\t    REP(j,k){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcoor[i].PB( pair<int,int>(a,b));\n\t\tif(i==0){\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m);\n\t\t    qs.push(b);\n\t\t    d[m][i][a] = 0;\n\t\t}\n\t    }\n\t}\n\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int tm = qm.front();\n\t    int ts = qs.front();\n\t    qxy.pop();\n\t    qm.pop();\n\t    qs.pop();\n\t    if(y+1 >= n || (tm > 0 && y+2 >= n)){\n\t\tans = min(ans,d[tm][y][x]);\n\t\tcontinue;\n\t    }\n\t    REP(i,coor[y+1].size()){\n\t\tint nx = coor[y+1][i].first;\n\t\tint ny = y+1;\n\t\tint slip = coor[y+1][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(d[tm][ny][nx] < 0 || d[tm][ny][nx] > v){\n\t\t    d[tm][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t    if(y+2 >= n) continue;\n\t    REP(i,coor[y+2].size()){\n\t\tint nx = coor[y+2][i].first;\n\t\tint ny = y+2;\n\t\tint slip = coor[y+2][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(tm>0 && (d[tm-1][ny][nx] < 0 || d[tm-1][ny][nx] > v )){\n\t\t    d[tm-1][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm-1);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Solution for aoj:0530 Pyon-Pyon River Crossing\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int INF = 10000000000, MAX_N = 150;\ntypedef pair<int, int> P;\nint n, m, ans;\nint dp[MAX_N + 3][1001][76];\nP stone, stone2;\nvector<P> Stone[151]; //first:??????second:???????????????\nint main(){\n\twhile (cin >> n >> m){\n\t\tif (!n&&!m)\n\t\t\treturn 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tStone[i].clear();\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tStone[i].push_back(P(a, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tfor (int j = 1; j <= 1000; j++){\n\t\t\t\tfor (int k = 0; k <= m; k++){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\t\tstone = Stone[2][i];\n\t\t\tdp[2][stone.first][m] = INF;\n\t\t}\n\t\tfor (int i = 3; i <= n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k <= 75; k++)\n\t\t\t\t\tdp[i][stone.first][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k < Stone[i + 1].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 1][k];\n\t\t\t\t\tfor (int l = m; l >= m - (i + 1) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (l != m)\n\t\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], dp[i + 1][stone2.first][l + 1]);\n\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < Stone[i + 2].size(); k++){\n\t\t\t\t\tif (i + 2 > n)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstone2 = Stone[i + 2][k];\n\n\t\t\t\t\tfor (int l = m - 1; l >= m - (i + 2) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (l != m)\n\t\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 2][stone2.first][l], dp[i + 2][stone2.first][l + 1]);\n\t\t\t\t\t\tdp[i + 2][stone2.first][l] = min(dp[i + 2][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor (int i = 0; i < Stone[n].size(); i++){\n\t\t\tstone = Stone[n][i];\n\t\t\tans = min(dp[n][stone.first][0], ans);\n\t\t}\n\t\tfor (int i = 0; i < Stone[n - 1].size(); i++){\n\t\t\tstone = Stone[n - 1][i];\n\t\t\tif (dp[n - 1][stone.first][1])\n\t\t\t\tans = min(dp[n - 1][stone.first][1], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <assert.h>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_N = 150;\n\nstruct stone\n{\n\tint column;\n\tint slip;\n\tint dp[MAX_N / 2 + 1];\n\tstone(int c_, int s_) { column = c_; slip = s_; memset(dp, 127, sizeof(dp)); }\n};\n\nvector<stone>slist[MAX_N];\n\nint n, m;\n\nint main()\n{\n\tfor (;;)\n\t{\n\t\tfor (auto& s : slist)s.clear();\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint col; scanf(\"%d\", &col);\n\t\t\tfor (int j = 0; j < col; ++j)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tscanf(\"%d %d\", &x, &d);\n\t\t\t\tslist[i].emplace_back(x, d);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (stone &s : slist[i])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= m; ++j)\n\t\t\t\t{\n\t\t\t\t\tint q = 1234567890;\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//?????£??????\n\t\t\t\t\t\tfor (stone sf : slist[i - 1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq = min(q, sf.dp[j] + abs(sf.column - s.column) * (sf.slip + s.slip));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//??????????????£??????\n\t\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (stone sf : slist[i - 2])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tq = min(q, sf.dp[j - 1] + abs(sf.column - s.column) * (sf.slip + s.slip));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (j == 1)q = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j == 0) q = 0;\n\t\t\t\t\t}\n\t\t\t\t\ts.dp[j] = q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1234567890;\n\t\tfor (stone s : slist[n - 1])\n\t\t{\n\t\t\tfor (int i = 0; i <= m; ++i)\n\t\t\t{\n\t\t\t\tans = min(s.dp[i], ans);\n\t\t\t}\n\t\t}\n\t\tfor (stone s : slist[n - 2])\n\t\t{\n\t\t\tfor (int i = 0; i <= m - 1; ++i)\n\t\t\t{\n\t\t\t\tans = min(s.dp[i], ans);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    \n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n\tdp[0][i][m]=dp[1][i][m]=dp[2][i][m-1]=0;\n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n,vi(4));\n\t\trep(i,n){\n\t\t\tint k;cin>>k;\n\t\t\twhile(k--){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\ta--;\n\t\t\t\tin[i][a]=b;\n\t\t\t}\n\t\t}\n\t\tint dp[200][4][100];\n\t\trep(i,200)rep(j,4)rep(k,100)dp[i][j][k]=inf;\n\t\trep(i,4)if(in[0][i])dp[0][i][0]=0;\n\t\tloop(i,1,n)rep(j,4)rep(k,m+1)if(in[i][j]){\n\t\t\trep(l,4)if(in[i-1][l])dp[i][j][k]=min(dp[i][j][k],\n\t\t\t\tdp[i-1][l][k]+(in[i][j]+in[i-1][l])*(abs(l-j)));\n\t\t\tif(k&&i!=1){\n\t\t\t\trep(l,4)if(in[i-2][l])dp[i][j][k]=min(dp[i][j][k],\n\t\t\t\t\tdp[i-2][l][k-1]+(in[i][j]+in[i-2][l])*(abs(j-l)));\n\t\t\t}\n\t\t}\n//\t\trep(i,n){rep(j,4)cout<<\" \"<<dp[i][j][1];cout<<endl;}\n\t\tint out=inf;\n\t\trep(i,4)rep(j,m+1)out=min(out,dp[n-1][i][j]);\n\t\trep(i,4)rep(j,m)out=min(out,dp[n-2][i][j]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m;\nll dp[155][80][10],INF=10000000000000000LL;\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  FOR(i,155) FOR(j,80) FOR(k,10) dp[i][j][k]=INF;\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][j]=0LL;\n  for(int i=n-1;i>0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][k]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][k]=min(dp[i][j][k],dp[i+2][j-1][l]+(ll)(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][l]+(ll)(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  ll mi=INF;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][i]);\n  if(m) FOR(i,x[2].size()) mi=min(mi,dp[2][m-1][i]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[152][1010][80];\nint solve(int h,int w,int idx,int k){\n  if(h == n-1) return 0;\n  if(dp[h][w][k] != INF) return dp[h][w][k];\n  int ret = INF;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    int s = stone[h][idx].second;\n    ret = min(ret,solve(h+1,nw,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      int s = stone[h][idx].second;\n      ret = min(ret,solve(h+2,nw,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][w][k] = ret;\n}\n    \n\nint main(){\n  cin >> n >> k;\n  for(int i=0;i<n;i++){\n    int m; cin >> m;\n    for(int j=0;j<m;j++){\n      int a,b; cin >> a >> b;\n      stone[i].push_back(P(a,b));\n    }\n  }\n  int ans = INF;\n  for(int i=0;i<152;i++){\n    for(int j=0;j<1010;j++){\n      for(int k=0;k<80;k++){\n\tdp[i][j][k] = INF;\n      }\n    }\n  }\n  for(int i=0;i<stone[0].size();i++){\n    ans = min(ans,solve(0,stone[0][i].first,i,k));\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<25)\nint dp[10][150][150],stone[10][150];\nint main() {\n\tint n,m;\n\twhile(scanf(\"%d %d\",&n,&m),n|m) {\n\t\tfill((int*)stone,(int*)(stone+10),INF);\n\t\tfill((int*)dp,(int*)(dp+10),INF);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\tint x,d;\n\t\t\t\tscanf(\"%d %d\",&x,&d);\n\t\t\t\tstone[x-1][i]=d;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<10;i++) dp[i][0][0]=0;\n\t\tfor(int i=1;i<n;i++) for(int j=0;j<10;j++) {\n\t\t\tif(stone[j][i]>=INF) continue;\n\t\t\tfor(int k=0;k<=m;k++) {\n\t\t\t\tfor(int l=0;l<10;l++) {\n\t\t\t\t\tif(stone[l][i-1]<INF) {\n\t\t\t\t\t\tdp[j][i][k]=min(dp[j][i][k],dp[l][i-1][k]+(stone[j][i]+stone[l][i-1])*abs(j-l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i>1&&k>0) {\n\t\t\t\t\tfor(int l=0;l<10;l++) {\n\t\t\t\t\t\tif(stone[l][i-2]<INF) {\n\t\t\t\t\t\t\tdp[j][i][k]=min(dp[j][i][k],dp[l][i-2][k-1]+(stone[j][i]+stone[l][i-2])*abs(j-l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=0;i<10;i++) for(int j=0;j<=m;j++) {\n\t\t\tif(stone[i][n-1]<INF) ans=min(ans,dp[i][n-1][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\n\nvoid solve(void){\nint dp[1005][101];\n\n for(int i=0;i<1005;i++)\n   for(int j=0;j<=m;j++)\n     dp[i][j]=INF;\n\n   dp[0][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n\tedge e=G[i][j];\n\tfor(int k=0;k<=m;k++){\n\t  if(i+1==e.to)dp[i+1][k]=min(dp[i+1][k],dp[i][k]+e.cost);\n\t  if(i+2==e.to && k!=0)dp[i+2][m-k]=min(dp[i+2][m-k],dp[i][m-k+1]+e.cost);\n\t}\n    }\n  }\n  int ans=INF;\n  for(int j=0;j<=m;j++)\n    ans=min(ans,dp[n+1][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0 && graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\n\t    if(i==0 && graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+1==n+1){\n\t      e.to=i+1;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+2==n+1){\n\t      e.to=i+2;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t  }\n\t}\n      }\n    }\n    //solve();\n    cout << dijkstra(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 10000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    //dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nint main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[152][78]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%lld\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%lld%lld\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e >= 2 && j<b) {\n\t\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 2][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = 1 << 29;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M 99\nll dp[151][11][76],ma[151][11];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=10;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=10;l++){\n\t\t\t\t\t\t\tif(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n&&k>0){\n\t\t\t\t\t\t\t\tif(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=5;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=10;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define INF 1145141919\n\nint N, M;\nint W;\nint T[160][1010];\nint dp[160][1010][80];\n\nint main() {\n  while (cin >> N >> M) {\n    if (N == 0 && M == 0) break;\n    for (int i=0; i<160; i++) {\n      for (int j=0; j<1010; j++) {\n        T[i][j] = -1;\n      }\n    }\n    for (int i=0; i<N; i++) {\n      int k;\n      cin >> k;\n      for (int j=0; j<k; j++) {\n        int x, d;\n        cin >> x >> d;\n        T[i][x-1] = d;\n        W = max(W, x);\n      }\n    }\n\n    for (int i=0; i<160; i++) {\n      for (int j=0; j<1010; j++) {\n        for (int m=0; m<80; m++) {\n          dp[i][j][m] = INF;\n        }\n      }\n    }\n    for (int i=0; i<W; i++) {\n      if (T[0][i] > 0) dp[0][i][0] = 0;\n    }\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<W; j++) {\n        for (int m=0; m<=M; m++) {\n          if (dp[i][j][m] == INF) continue;\n          for (int nj=0; nj<W; nj++) {\n            if (T[i+1][nj] > 0) {\n              dp[i+1][nj][m] = min(dp[i+1][nj][m], dp[i][j][m] + abs(j - nj)*(T[i+1][nj] + T[i][j]));\n            }\n            if (T[i+2][nj] > 0) {\n              dp[i+2][nj][m+1] = min(dp[i+2][nj][m+1], dp[i][j][m] + abs(j - nj)*(T[i+2][nj] + T[i][j]));\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for (int i=0; i<W; i++) {\n      for (int m=0; m<=M; m++) {\n        ans = min(ans, dp[N-1][i][m]);\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n#define int long long\n#define inf 3000000000000\ntypedef pair<int, int>P;\nint dp[160][10][80];\nvector<P>s[160];//P(??????,???????????????)\n\nvoid init(int m) {\n\tfor (int i = 0; i < 160; i++) {\n\t\ts[i].clear();\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tfor (int k = 0; k < 80; k++) {\n\t\t\t\tif (!i&&k==m)dp[i][j][k]=0;\n\t\t\t\telse if (i == 1 && k == m - 1)dp[i][j][k] = 0;\n\t\t\t\telse dp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nsigned main() {\n\tint n, m;\n\twhile (cin >> n >> m) {\n\t\tif (!n && !m)break;\n\t\tinit(m);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\ts[i].push_back(P(b, c));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {//?¬?????????????\n\t\t\tfor (int j = 0; j < s[i].size(); j++) {//??????????????????\n\t\t\t\tfor (int k = m; k >= 0; k--) {//???????????§?????£??????\n\t\t\t\t\tfor (int l = 0; l < s[i - 1].size(); l++) {\n\t\t\t\t\t\tint dang = (s[i-1][l].second+s[i][j].second)*abs(s[i][j].first-s[i-1][l].first);\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + dang);\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 1) {\n\t\t\t\t\t\tfor (int l = 0; l < s[i - 2].size(); l++) {\n\t\t\t\t\t\t\tint dang = (s[i - 2][l].second + s[i][j].second)*abs(s[i][j].first - s[i - 2][l].first);\n\t\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 2][l][k + 1] + dang);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 80; j++) {\n\t\t\t\tans = min(ans, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 1; j < 80; j++) {\n\t\t\t\tans = min(ans, dp[n - 2][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77];\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int i = 0; i < 1001; i++)\n\t\t\t\tfill(cur[i],cur[i]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= max(0,m-i); l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=cur;\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,fin[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 500000000;\n\nint n, m;\nint K[151], x[151][10], d[151][10];\nint dp[151][10];\n\nvoid init()\n{\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 150; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\n\tK[0] = K[n + 1] = 1;\n\tmemset(x, 0, sizeof(x));\n\tmemset(d, 0, sizeof(d));\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\t\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (m--){\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n - 1) dp[i + 2][k] = min(dp[i + 2][k], dp[i][j]);\n\t\t\t\t\t\tdp[i + 2][k] = min(dp[i + 2][k], dp[i][j] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tmini = min(mini, dp[n + 1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nclass Data\n{\npublic:\n\tint line,pos,cost,jump;\n\tData(int l, int p, int c, int j)\n\t: line(l), pos(p), cost(c), jump(j) {}\n\tbool operator<(const Data& d) const\n\t{\n\t\tif(cost!=d.cost) return cost>d.cost;\n\t\tif(jump!=d.jump) return jump>d.jump;\n\t\tif(line!=d.line) return line>d.line;\n\t\treturn pos>d.pos;\n\t}\n};\n\nint main()\n{\n\tint size[150];\n\tint pos [150][10];\n\tint cost[150][10];\n\tbool visited[150][10][75];\n\t\n\tint N,M;\n\twhile(cin>>N>>M, N||M)\n\t{\n\t\tfor(int l=0; l<N; l++)\n\t\t{\n\t\t\tcin>>size[l];\n\t\t\tfor(int p=0; p<size[l]; p++)\n\t\t\t{\n\t\t\t\tcin>>pos[l][p]>>cost[l][p];\n\t\t\t}\n\t\t}\n\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tpriority_queue<Data> q;\n\n\t\tfor(int l=0; l<2; l++)\n\t\t{\n\t\t\tif(M<l) break;\n\t\t\tfor(int p=0; p<size[l]; p++)\n\t\t\t{\n\t\t\t\tq.push( Data(l, p, 0, l) );\n\t\t\t}\n\t\t}\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tData t=q.top(); q.pop();\n\n\t\t\tif((t.line==N-1) || (t.line==N-2 && t.jump<M))\n\t\t\t{\n\t\t\t\tcout << t.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(visited[t.line][t.pos][t.jump]) continue;\n\t\t\tvisited[t.line][t.pos][t.jump]=true;\n\n\t\t\tfor(int l=0; l<2; l++)\n\t\t\t{\n\t\t\t\tData nw(t.line+l+1, -1, -1, t.jump+l);\n\n\t\t\t\tif(M<nw.jump) break;\n\t\t\t\tfor(int p=0; p<size[nw.line]; p++)\n\t\t\t\t{\n\t\t\t\t\tnw.pos = p;\n\t\t\t\t\tif(visited[nw.line][nw.pos][nw.jump]) continue;\n\n\t\t\t\t\tint sumcost = cost[t.line][t.pos] + cost[nw.line][nw.pos];\n\t\t\t\t\tint difpos  = pos [t.line][t.pos] - pos [nw.line][nw.pos];\n\t\t\t\t\tnw.cost = t.cost + sumcost*(difpos<0 ? -difpos:difpos);\n\t\t\t\t\tq.push( nw );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nsigned main()\n{\n\twhile (scanf(\"%lld %lld\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%lld\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%lld %lld\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\trep(i, k[0]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(0, 0, i));\n\t\t}\n\n\t\tif (M > 0) {\n\t\t\trep(i, k[2]) {\n\t\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\t\tchmin(ans, rec(2, 1, i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n\n#define reps(i,f,n) for(int i = f; i < int(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define N 200\n#define W 2000\n\n\nusing namespace std;\n\n\nint dp[W][N];\n\n\nint main(void){\n\t\n\tvector<int> mx[200];\n\tvector<int> ms[200];\n\tvector<int> mi[200];\n\t\n\tint n, m, ki, x, d, in = 0;\n\trep(i,W)rep(j,N) dp[i][j] = 1000000000;\n\n\tscanf(\"%d %d\", &n, &m);\n\tm++;\n\t\n\trep(i, n){\n\t\tscanf(\"%d\", &ki);\n\t\t\n\t\trep(j, ki){\n\t\t\tscanf(\"%d %d\", &x, &d);\n\t\t\tmx[i+1].push_back(x);\n\t\t\tms[i+1].push_back(d);\n\t\t\tmi[i+1].push_back(in);\n\t\t\tin++;\n\t\t}\n\t}\n\t\n\t\n\trep(i,mx[1].size())dp[mi[1][i]][0] = 0;\n\t\n\tif(m > 0)rep(i,mx[2].size())dp[mi[2][i]][1] = 0;\n\t\n\treps(i,1,n){\n\t\trep(j,mx[i].size()){\n//\t\t\tprintf(\"---x:%d v:%d in:%d---\\n\", mx[i][j], ms[i][j], mi[i][j]);\n\t\t\trep(k, mx[i+1].size()){\n\t\t\t\trep(l, m){\n\t\t\t\t\tdp[mi[i+1][k]][l] = min(dp[mi[i+1][k]][l], \n\t\t\t\t\t\t\t\t\t\t\tdp[mi[i][j]][l] + (abs(mx[i+1][k] - mx[i][j]) * (ms[i+1][k] + ms[i][j])));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\trep(k, mx[i+2].size()){\n\t\t\t\trep(l, m-1){\n\t\t\t\t\tdp[mi[i+2][k]][l+1] = min(dp[mi[i+2][k]][l+1],\n\t\t\t\t\t\t\t\t\t\t\t  dp[mi[i][j]][l] + (abs(mx[i+2][k] - mx[i][j]) * (ms[i+2][k] + ms[i][j])));\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tint ans = 2000000000;\n\t\n\trep(i,mx[n].size()){\n\t\trep(j,m){\n\t\t\tans = min(ans, dp[mi[n][i]][j]);\n\t\t}\n\t}\n\trep(i,mx[n-1].size()){\n\t\trep(j,m-1){\n\t\t\tans = min(ans, dp[mi[n-1][i]][j]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1005;\nll dp[6][MAX_X][80];\n\nint main()\n{\n\tint n, m;\n\twhile(scanf(\"%d %d\", &n, &m) != EOF && n)\n\t{\n\t\trep(x,MAX_X) rep(y,6) rep(d,m+1) dp[y][x][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\tvector<vint> xs(n);\n\t\trep(i,MAX_X) rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tscanf(\"%d\", &s);\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\t//ifs >> x >> d;\n\t\t\t\tscanf(\"%d %d\", &x, &d);\n\t\t\t\tr[x][i] = d;\n\t\t\t\txs[i].push_back(x);\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[0][x][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[1][x][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++)\n\t\t{\n\t\t\tif(1 < y) memcpy(dp[y%5], dp[5], sizeof(dp[y%5]));\n\t\t\tfor(int x = 0; x < xs[y].size(); x++)\n\t\t\t{\n\t\t\t\t// ツ津環湘ュツジツδδδ督プ\n\t\t\t\trep(nx, xs[y-1].size()) rep(d, m+1)\n\t\t\t\t\t//if(dp[(y-1)%5][xs[y-1][nx]][d] != INF)\n\t\t\t\t\t\tchmin(dp[y%5][xs[y][x]][d], dp[(y-1)%5][xs[y-1][nx]][d] + (r[xs[y][x]][y] + r[xs[y-1][nx]][y-1]) * abs(xs[y][x] - xs[y-1][nx]));\n\n\t\t\t\t// ツ暗ェツ段ツづづ篠つオ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, xs[y-2].size()) REP(d, 1, m+1)\n\t\t\t\t\t\t//if(dp[(y-2)%5][xs[y-2][nx]][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[y%5][xs[y][x]][d-1], dp[(y-2)%5][xs[y-2][nx]][d] + (r[xs[y][x]][y] + r[xs[y-2][nx]][y-2]) * abs(xs[y][x] - xs[y-2][nx]));\n\t\t\t}\n\t\t}\n\n\t\tll res = INF;\n\t\trep(x, xs[n-1].size()) rep(d, m+1) chmin(res, dp[(n-1)%5][xs[n-1][x]][d]);\n\t\trep(x, xs[n-2].size()) REP(d, 1, m+1) chmin(res, dp[(n-2)%5][xs[n-2][x]][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define INF 2000000000\n\n#define min_aplly(x, y) if (x > y) x = y;\n\nint dp[81][150][10];\n\nint main() {\n    while (1) {\n        int i, j, k, l;\n        int n, m;\n        vector<pair<int, int> > points[150];\n        int min = INF;\n\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) return 0;\n\n        for (l=0;l<m+1;l++) {\n            for (i=0;i<n;i++) {\n                for (j=0;j<10;j++) {\n                    dp[l][i][j] = INF;\n                }\n            }\n        }\n\n        for (i=0;i<n;i++) {\n            scanf(\"%d\", &k);\n            for (j=0;j<k;j++) {\n                int x, d;\n                scanf(\"%d %d\", &x, &d);\n                points[i].push_back(make_pair(x, d));\n            }\n        }\n\n        for (j=0;j<10;j++) {\n            dp[0][0][j] = 0;\n            dp[1][1][j] = 0;\n        }\n\n        for (l=0;l<m+1;l++) {\n            for (i=1;i<n;i++) {\n                int pos1 = 0;\n                vector<pair<int, int> >::iterator it1 = points[i].begin();\n\n                for (;it1 != points[i].end();it1++, pos1++) {\n                    if (l > 0 && i > 1) {\n                         int pos2 = 0;\n                         vector<pair<int, int> >::iterator it2 = points[i-2].begin();\n\n                         for (;it2 != points[i-2].end();it2++, pos2++) {\n                             int danger;\n\n                             if (dp[l-1][i-2][pos2] == INF) continue;\n                             danger = dp[l-1][i-2][pos2] + (it1->second + it2->second) * abs(it1->first - it2->first);\n                             min_aplly(dp[l][i][pos1], danger);\n                         }\n                    }\n\n                    int pos2 = 0;\n                    vector<pair<int, int> >::iterator it2 = points[i-1].begin();\n\n                    for (;it2 != points[i-1].end();it2++, pos2++) {\n                        int danger;\n\n                        if (dp[l][i-1][pos2] == INF) continue;\n                        danger = dp[l][i-1][pos2] + (it1->second + it2->second) * abs(it1->first - it2->first);\n                        min_aplly(dp[l][i][pos1], danger);\n                    }\n                }\n            }\n        }\n\n        for (l=0;l<m+1;l++) {\n            for (j=0;j<10;j++) {\n                if (l < m) {\n                    min_aplly(min, dp[l][n-2][j]);\n                }\n\n                min_aplly(min, dp[l][n-1][j]);\n            }\n        }\n\n        printf(\"%d\\n\", min);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define MAX_N 200\n#define INF (1e9)\nstruct state{\n  int cost,h,J,cnt;\n  bool operator < (const state& p)const{\n    return cost > p.cost;\n  }\n};\n\nstruct data{\n  int w,cost;\n};\n\nvector<data> G[MAX_N];\nint n,m;\nint d[MAX_N][MAX_N][MAX_N];\n\nvoid solve(){\n  int ans=INF;\n  for(int i=0;i<MAX_N;i++)\n    for(int j=0;j<MAX_N;j++)\n      for(int k=0;k<MAX_N;k++)\n\td[i][j][k]=INF;\n \n  priority_queue < state > Q;\n  for(int i=0;i<2;i++){\n    if(m-i<0)break;\n    for(int j=0;j<(int)G[i].size();j++){\n      data e=G[i][j];\n      d[i][j][m-i]=0;\n      Q.push((state){0,i,j,m-i});\n    }\n  }\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    //cout<<s.h<<' '<<s.J<<' '<<s.cost<<' '<<s.cnt<<endl;\n    if(s.h+1==n){\n      ans=min(ans,s.cost);\n    }else if(s.h+2==n&&s.cnt>=1){\n      ans=min(ans,s.cost);\n    }\n    \n    if(s.cost>d[s.h][s.J][s.cnt])continue;\n    \n    data f=G[s.h][s.J];\n    if(s.h+1>=n)continue;\n    for(int i=0;i<(int)G[s.h+1].size();i++){\n      data e=G[s.h+1][i];\n      int ncost=(f.cost+e.cost)*abs(f.w-e.w)+s.cost;\n      if(ncost>=d[s.h+1][i][s.cnt])continue;\n      d[s.h+1][i][s.cnt]=ncost;\n      Q.push( (state){d[s.h+1][i][s.cnt],s.h+1,i,s.cnt} );\n    }\n\n    if(s.cnt==0||s.h+2>=n)continue;\n    s.cnt--;\n    for(int i=0;i<(int)G[s.h+2].size();i++){\n      data e=G[s.h+2][i];\n      int ncost=(f.cost+e.cost)*abs(f.w-e.w)+s.cost;\n      if(ncost>=d[s.h+2][i][s.cnt])continue;\n      d[s.h+2][i][s.cnt]=ncost;\n      Q.push( (state){d[s.h+2][i][s.cnt],s.h+2,i,s.cnt} );\n    }\n  }\n  cout<<ans<<endl;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++)G[i].clear();\n \n}\nint main(){\n  int a,b,c;\n  while(cin>>n>>m){\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>a;\n      for(int j=0;j<a;j++){\n\tcin>>b>>c;\n\tG[i].push_back( (data){b,c} );\n      }\n    }\n\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1000000000;\nint n, m;\nvector<vector<P>> map;\nint dp[150][10][80];\n\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tmap.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tfor (int j = 0; j < tmp; j++) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tmap[i].push_back(P(a - 1, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 150; i++)for (int j = 0; j < 10; j++)for (int k = 0; k < 80; k++)dp[i][j][k] = INF;\n\t\tfor (int i = 0; i < map[0].size(); i++) {\n\t\t\tdp[0][i][m] = 0;\n\t\t}\n\t\tfor (int i = 0; i < map[1].size(); i++) {\n\t\t\tif (m != 0)dp[1][i][m - 1] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int j = 0; j < map[i].size(); j++) {\n\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\tif (i + 1 < n) {\n\t\t\t\t\t\tfor (int l = 0; l < map[i + 1].size(); l++) {\n\t\t\t\t\t\t\tauto now = map[i][j];\n\t\t\t\t\t\t\tauto next = map[i + 1][l];\n\t\t\t\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k],\n\t\t\t\t\t\t\t\tdp[i][j][k] + abs(next.first - now.first) * (now.second + next.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 2 < n && k != 0) {\n\t\t\t\t\t\tfor (int l = 0; l < map[i + 2].size(); l++) {\n\t\t\t\t\t\t\tauto now = map[i][j];\n\t\t\t\t\t\t\tauto next = map[i + 2][l];\n\t\t\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1],\n\t\t\t\t\t\t\t\tdp[i][j][k] + abs(next.first - now.first) * (now.second + next.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < map[n - 2].size(); i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tans = min(ans, dp[n - 2][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < map[n - 1].size(); i++) {\n\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\tans = min(ans, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tmap.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1e+9;\ntypedef pair<int, int> P;\n\nint memo[152][11][80];\nint N, M;\nvector<P> G[151];\n\nint rec(int n, int p, int m){\n\tif(memo[n][p][m] != -1)\n\t\treturn memo[n][p][m];\n\t\t\n\tint res = INF;\n\tif(n > N){\n\t\treturn 0;\n\t}\n\tif(n == N){\n\t\treturn 0;\n\t}\n\tif(n == N - 1 && m >= 1){\n\t\tres = min(res, rec(n + 2, p, m - 1));\n\t}\n\telse{\n\t\tfor(int i = 0; i < G[n].size(); ++i){\n\t\t\tres = min(res, rec(n + 1, i, m) + (G[n - 1][p].second + G[n][i].second) * abs(G[n][i].first - G[n - 1][p].first));\n\t\t}\n\t\tif(n != N - 1 && m >= 1){\n\t\t\tfor(int i = 0; i < G[n + 1].size(); ++i){\n\t\t\t\tres = min(res, rec(n + 2, i, m - 1) + (G[n - 1][p].second + G[n + 1][i].second) * abs(G[n + 1][i].first - G[n - 1][p].first));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[n][p][m] = res;\n}\n\nint main() {\n\twhile(cin >> N >> M && (N || M)){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor(int i = 0; i <= 150; ++i)\n\t\t\tG[i].clear();\n\t\tint k, d, x;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor(int j = 0; j < k; ++j){\n\t\t\t\tscanf(\"%d%d\", &d, &x);\n\t\t\t\tG[i].push_back(P(d, x));\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i = 0; i < G[0].size(); ++i){\n\t\t\tans = min(ans, rec(1, i, M));\n\t\t\t\n\t\t}\n\t\tif(M >= 1){\n\t\t\tfor(int i = 0; i < G[1].size(); ++i){\n\t\t\t\tans = min(ans, rec(2, i, M - 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<24)\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[151][11][1001];\nint solve(int h,int idx,int k){\n  if(h == n-1 || (h == n-2 && k != 0)) return 0;\n  if(dp[h][idx][k] != -1) return dp[h][idx][k];\n  int ret = INF;\n  int s = stone[h][idx].second;\n  int w = stone[h][idx].first;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    ret = min(ret,solve(h+1,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      ret = min(ret,solve(h+2,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][idx][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,i,k));\n    }\n    if(k != 0){\n      for(int i=0;i<stone[1].size();i++){\n\tans = min(ans,solve(1,i,k-1));\n      }\n    }\n    cout << ans << endl;\n    for(int i=0;i<n;i++){\n      stone[i].clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  bool use[1500];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    vector<int> id[150];\n    int num = 0;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tif(i==n-1)use[num] = true;\n\telse use[num] = false;\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = 1<<30;\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    if(m>0)for(int i=0;i<(int)id[1].size();i++)q.push(P2(P1(0,id[1][i]),1));\n\n    int ans;\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n      if(use[idx]){\n\tans = risk;\n\tbreak;\n      }\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing ll = long long;\n\nconstexpr int INF = 1e9;\n\nstruct edge {\n    int to, cost, jump;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, int cost, int jump) {\n    g[from].push_back(edge{to, cost, jump});\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        vector<tuple<int, int, int>> v;\n        for(int i = 0; i < n; ++i) {\n            int k; cin >> k;\n            for(int j = 0; j < k; ++j) {\n                int x, d;\n                cin >> x >> d;\n                v.emplace_back(i, x, d);\n            }\n        }\n        graph g(v.size() + 2);\n        int s = v.size(), t = s + 1;\n        for(int i = 0; i < v.size(); ++i) {\n            int y1, x1, d1;\n            tie(y1, x1, d1) = v[i];\n            for(int j = 0; j < v.size(); ++j) {\n                if(i == j) {\n                    continue;\n                }\n                int y2, x2, d2;\n                tie(y2, x2, d2) = v[j];\n                if(1 <= y2 - y1 && y2 - y1 <= 2) {\n                    add_edge(g, i, j, (d1 + d2) * abs(x1 - x2), y2 - y1 == 2);\n                }\n            }\n            if(y1 <= 1) {\n                add_edge(g, s, i, 0, y1 == 1);\n            }\n            if(n - 2 <= y1) {\n                add_edge(g, i, t, 0, y1 == n - 2);\n            }\n        }\n        \n        int res = INF;\n        vector<vector<int>> d(g.size(), vector<int>(m + 1, INF));\n        d[s][m] = 0;\n        using state = tuple<int, int, int>;\n        priority_queue<state, vector<state>, greater<state>> que;\n        que.emplace(0, m, s);\n        while(!que.empty()) {\n            int cur_d, cnt, v;\n            tie(cur_d, cnt, v) = que.top();\n            que.pop();\n            if(v == t) {\n                res = cur_d;\n                break;\n            }\n            if(d[v][cnt] < cur_d) {\n                continue;\n            }\n            for(auto& e : g[v]) {\n                if(cnt - e.jump >= 0 && d[e.to][cnt - e.jump] > d[v][cnt] + e.cost) {\n                    d[e.to][cnt - e.jump] = d[v][cnt] + e.cost;\n                    que.emplace(d[e.to][cnt - e.jump], cnt - e.jump, e.to);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define int long long\n#define INF INT_MAX\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>c[152][78];\n\t\tint d;\n\t\tcin >> d;\n\t\tfor (int e = 0; e < d; e++) {\n\t\t\tisi h; h.mincost = 0;\n\t\t\tscanf(\"%lld%lld\", &h.zahyou, &h.suberi);\n\t\t\tc[0][b].push_back(h);\n\t\t}\n\t\tfor (int f = 1; f < a; f++) {\n\t\t\tint g; cin >> g;\n\t\t\tfor (int h = 0; h < g; h++) {\n\t\t\t\tint i, j; scanf(\"%lld%lld\", &i, &j);\n\t\t\t\tif (f == 1&&b) {\n\t\t\t\t\tisi o; o.zahyou = i; o.suberi = j; o.mincost = 0;\n\t\t\t\t\tc[1][b - 1].push_back(o);\n\t\t\t\t}\n\t\t\t\tfor (int k = b; k >= 0; k--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int l = 0; l < c[f - 1][k].size(); l++) {\n\t\t\t\t\t\tm = min(m, c[f - 1][k][l].mincost + (c[f - 1][k][l].suberi + j)*abs(c[f - 1][k][l].zahyou - i));\n\t\t\t\t\t}\n\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t}\n\t\t\t\t\tif (k != b&&f > 1) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int l = 0; l < c[f - 2][k+1].size(); l++) {\n\t\t\t\t\t\t\tm = min(m, c[f - 2][k+1][l].mincost + (c[f - 2][k+1][l].suberi + j)*abs(c[f - 2][k+1][l].zahyou - i));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int p = 0; p <= b; p++) {\n\t\t\tfor (isi q : c[a - 1][p]) {\n\t\t\t\tS = min(S, q.mincost);\n\t\t\t}\n\t\t}\n\t\tfor (int p = 1; p <= b; p++) {\n\t\t\tfor (isi q : c[a - 2][p]) {\n\t\t\t\tS = min(S, q.mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 1005\n#define N 155\n#define S 85\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[S][N][M];\n\nint dijkstra(int sy,int sx,int x){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<=(n+1)/2;i++)\n    for(int j=0;j<n;j++)\n      for(int l=0;l<M;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  if(x<=m)q.push(P1(P(0,x),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  for(int i=0;i<node[n-2].size();i++)\n    for(int j=0;j<m;j++)\n      res=min(res,d[j][n-2][node[n-2][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x,0));\n    for(int i=0;i<node[1].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x,1));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int INF = (1<<21);\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n || m)){\n    int dp[150][10][80], a[150][10], x[150][10];\n    for(int i=0;i<150;i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<80;k++) dp[i][j][k] = INF;\n\ta[i][j] = INF;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int k;\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint b,c;\n\tcin >> b >> c;\n\tx[i][j] = b;\n\ta[i][j] = c;\n      }\n    }\n    for(int i=0;i<10;i++) dp[0][i][0] = 0;\n\n    for(int i=0;i<n-1;i++){\n      for(int l=0;l<=m;l++){\n\tfor(int j=0;j<10;j++){\n\t  if(a[i][j] == INF) continue;\n\t  for(int k=0;k<10;k++){\n\t    if(a[i+1][k] == INF) continue;\n\t    dp[i+1][k][l] = min(dp[i+1][k][l],dp[i][j][l] + (a[i][j] + a[i+1][k]) * (abs(x[i+1][k]-x[i][j])));\n\t  }\n\t  if(i < n - 2 && l != m){\n\t    for(int k=0;k<10;k++){\n\t      if(a[i+2][k] == INF) continue;\n\t      dp[i+2][k][l+1] = min(dp[i+2][k][l+1],dp[i][j][l] + (a[i][j] + a[i+2][k]) * (abs(x[i+2][k]-x[i][j])));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-1][k][j]);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int INFTY = (1<<21);\nstatic const int NMAX = 150;\nstatic const int MMAX = 80;\nclass Node{\npublic:\n  int p, s, M[MMAX];\n  Node(){}\n  Node(int p, int s):p(p), s(s){\n    rep(i, MMAX) M[i] = INFTY;\n  }\n};\n\nint n, m;\nvector<Node> P[NMAX];\n\nint compute(){\n  rep(j, P[0].size()) P[0][j].M[0] = 0;\n  if ( n >= 2 ){\n    rep(j, P[1].size()) P[1][j].M[1] = 0;\n  }\n\n  rep(i, n-1){\n    rep(j, P[i].size()){\n      Node src = P[i][j];\n      rep(k, P[i+1].size()){\n\tNode tar = P[i+1][k];\n\tint cost = (src.s + tar.s)*(max(src.p, tar.p) - min(src.p, tar.p));\n\trep(l, m+1){\n\t    P[i+1][k].M[l] = min(P[i+1][k].M[l], P[i][j].M[l] + cost);\n\t}\n      }\n      if (i == n-1) continue;\n      rep(k, P[i+2].size()){\n\tNode tar = P[i+2][k];\n\tint cost = (src.s + tar.s)*(max(src.p, tar.p) - min(src.p, tar.p));\n\trep(l, m){\n\t    P[i+2][k].M[l+1] = min(P[i+2][k].M[l+1], P[i][j].M[l] + cost);\n\t}\n      }\n    }\n  }\n  int minv = INFTY;\n  rep(j, P[n-1].size()){\n    rep(l, m+1) minv = min(minv, P[n-1][j].M[l]);\n  }\n  if ( n > 1 ){\n    rep(j, P[n-2].size()){\n      rep(l, m) minv = min(minv, P[n-2][j].M[l]);\n    }\n  }\n  return minv;\n}\n\nmain(){\n  int k, p, s;\n  while(1){\n    cin >> n >> m;\n    if ( n == 0 && m == 0 ) break;\n    rep(i, n) P[i].clear();\n    rep(i, n){\n      cin >> k;\n      rep(j, k){\n\tcin >> p >> s;\n\tP[i].push_back(Node(p, s));\n      }\n    }\n    cout << compute() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tpii p;\n\tint c, j;\n\tstate(pii p, int c, int j) : p(p), c(c), j(j) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint risk(int cd, int nd, int dx) {\n\treturn (cd+nd)*dx;\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tvvi stone(n, vi(1000, -1));\n\t\tint maxx = 0;\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j, k) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tstone[i][x-1] = d;\n\t\t\t\tmaxx = max(maxx, x);\n\t\t\t}\n\t\t}\n\n\t\tvector<vvi> field(n, vvi(maxx, vi(m+1, INF)));\n\t\tpriority_queue<state> Q;\n\t\tREP(i, maxx) {\n\t\t\tif(stone[0][i] != -1) {\n\t\t\t\tfield[0][i][0] = 0;\n\t\t\t\tQ.push(state(pii(0, i), 0, 0));\n\t\t\t}\n\t\t}\n\t\tif(n > 1 && m > 0) {\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[1][i] != -1) {\n\t\t\t\t\tfield[1][i][1] = 0;\n\t\t\t\t\tQ.push(state(pii(1, i), 0, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\n\t\tint ans = INF;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tint y = st.p.first, x = st.p.second;\n\t\t\tif(y+2 == n && st.j < m) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(y+1 == n) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[y+1][i] != -1) {\n\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+1][i], abs(x-i));\n\t\t\t\t\tif(nc < field[y+1][i][st.j]) {\n\t\t\t\t\t\tfield[y+1][i][st.j] = nc;\n\t\t\t\t\t\tQ.push(state(pii(y+1, i), nc, st.j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(st.j < m && y+2 < n) {\n\t\t\t\tREP(i, maxx) {\n\t\t\t\t\tif(stone[y+2][i] != -1) {\n\t\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+2][i], abs(x-i));\n\t\t\t\t\t\tif(nc < field[y+2][i][st.j+1]) {\n\t\t\t\t\t\t\tfield[y+2][i][st.j+1] = nc;\n\t\t\t\t\t\t\tQ.push(state(pii(y+2, i), nc, st.j+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint DP[151][10][76];\nint abs(int a){\n\tif(a<=0)\n\treturn -a;\n\treturn a;\n}\nint main() {\n\twhile(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n==0)\n\tbreak;\n\tint k[151],kiS[151][10],kiP[151][10];\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> k[i];\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tcin >> kiP[i][j] >> kiS[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<151;i++)\n\t\tfor(int j=0;j<10;j++)\n\t\t\tfor(int kk=0;kk<76;kk++)\n\t\t\t\tDP[i][j][kk]=1 << 28;\n\tfor(int i=0;i<k[1];i++){\n\tDP[1][i][0]=0;\n\t}\n\tfor(int i=0;i<k[2];i++)\n\tDP[2][i][1]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int kk=0;kk<=min(m,i/2+1);kk++){\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int l=0;l<k[i-1];l++)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-1][l][kk]+(kiS[i][j]+kiS[i-1][l])*(abs(kiP[i][j]-kiP[i-1][l])));\n\t\t\t\tfor(int l=0;l<k[i-1];l++){\n\t\t\t\tif(kk!=0)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-2][l][kk-1]+(kiS[i][j]+kiS[i-2][l])*(abs(kiP[i][j]-kiP[i-2][l])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<k[i];j++)\n\t\t//\tcout << DP[i][j][0] << \" \" << i <<\" \" << j <<  endl;\n\t}*/\n\tint maxer =1 << 28;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tmaxer=min(maxer,DP[n][i][j]);\n\t\t//\tcout << n << \" \" << i << \" \" << j << \" \" << DP[n][i][j]<< endl;\n\t\t\tif(j+1<=m)\n\t\t\tmaxer=min(maxer,DP[n-1][i][j+1]);\n\t\t}\n\t}\n\tcout << maxer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[150][76][10];\nint main(){\n\twhile(true){\n\tint n,m;\tcin>>n>>m;\n\tif(n==0)\treturn 0;\n\tvector<pair<int,int>> ls[n];\n\tfor(int i=0;i<n;i++){\n\t\tint k;\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\tcin>>x>>d;\n\t\t\tls[i].push_back(make_pair(x,d));\n\t\t}\n\t}\n\tfor(int i=0;i<150;i++){\n\t\tfor(int j=0;j<=75;j++){\n\t\t\tfor(int k=0;k<10;k++)\tdp[i][j][k]=(1<<30);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)ls[0].size();i++)\tdp[0][m][i]=0;\n\tif(m!=0)\tfor(int i=0;i<(int)ls[1].size();i++)\tdp[1][m-1][i]=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<(int)ls[i].size();k++){\n\t\t\t\tif(dp[i][j][k]==(1<<30))\tcontinue;\n\t\t\t\tfor(int l=0;l<(int)ls[i+1].size();l++){\n\t\t\t\t\tdp[i+1][j][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+1][l].first)*(ls[i][k].second+ls[i+1][l].second),dp[i+1][j][l]);\n\t\t\t\t}\n\t\t\t\tif(j!=0&&i+2<n){\n\t\t\t\t\tfor(int l=0;l<(int)ls[i+2].size();l++){\n\t\t\t\t\tdp[i+2][j-1][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+2][l].first)*(ls[i][k].second+ls[i+2][l].second),dp[i+2][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=(1<<30);\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-1].size();j++){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=INT_MAX-10000;\nint dp[151][1001][76];\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvvint vv;\n\t\tinitvv(vv,n,1001,-1);\n\t\trep(i,151) rep(j,1001) rep(k,76) dp[i][j][k]=INF;\n\t\trep(i,n){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\trep(j,t){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tvv[i][a-1]=b;\n\t\t\t}\n\t\t}\n\t\t// puts(\"hoge\");\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// printf(\"%2d\",vv[i][j]);\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\trep(i,2){\n\t\t\trep(j,1001){\n\t\t\t\tif(vv[i][j]!=-1) dp[i][j][i]=0;\n\t\t\t}\n\t\t}\n\t\t// return;\n\t\trep(i,n-1){\n\t\t\trep(j,1001){\n\t\t\t\tif(vv[i][j]==-1) continue;\n\t\t\t\trep(o,76){\n\t\t\t\t\tif(dp[i][j][o]==INF) continue;\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tif(o+k>75) continue;\n\t\t\t\t\t\trep(l,1001){\n\t\t\t\t\t\t\tif(vv[i+k+1][l]==-1) continue;\n\t\t\t\t\t\t\tdp[i+k+1][l][o+k]=min(dp[i+k+1][l][o+k],dp[i][j][o]+abs(j-l)*(vv[i][j]+vv[i+k+1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==n-2) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// if(dp[i][j][0]!=INF) printf(\"%2d\",dp[i][j][0]);\n\t\t\t\t// else cout<<\"  \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// if(dp[i][j][1]!=INF) printf(\"%2d\",dp[i][j][1]);\n\t\t\t\t// else cout<<\"  \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\treep(i,n-2,n){\n\t\t\trep(j,1001){\n\t\t\t\trep(k,m){\n\t\t\t\t\tans=min(ans,dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout<<ans<<endl;\n\t\trep(i,1001){\n\t\t\trep(k,m+1){\n\t\t\t\tans=min(ans,dp[n-1][i][k]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m, n;) {\n\t\tvector<vector<int> > pos(n), danger(n);\n\t\tvector<vector<vector<int> > > dp(n, vector<vector<int> >(m + 1));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint num;\n\t\t\tcin >> num;\n\n\t\t\tfor(int j = 0; j < m + 1; ++j)\n\t\t\t\tdp[i][j].resize(num, INT_MAX);\n\n\t\t\tfor(int j = 0; j < num; ++j) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tpos[i].push_back(x);\n\t\t\t\tdanger[i].push_back(d);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < dp[0][m].size(); ++i)\n\t\t\tdp[0][m][i] = 0;\n\n\t\tfor(int i = 0; i < dp[1][m - 1].size(); ++i)\n\t\t\tdp[1][m - 1][i] = 0;\n\n\t\tint ans = INT_MAX;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < m + 1; ++j) {\n\t\t\t\tfor(int k = 0; k < dp[i][j].size(); ++k) {\n\t\t\t\t\tif(dp[i][j][k] == INT_MAX)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(j) {\n\t\t\t\t\t\tif(i + 2 >= n)\n\t\t\t\t\t\t\tchmin(ans, dp[i][j][k]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor(int l = 0; l < dp[i + 2][j - 1].size(); ++l)\n\t\t\t\t\t\t\t\tchmin(dp[i + 2][j - 1][l], dp[i][j][k] + (danger[i][k] + danger[i + 2][l]) * abs(pos[i][k] - pos[i + 2][l]));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(i + 1 >= n)\n\t\t\t\t\t\tchmin(ans, dp[i][j][k]);\n\t\t\t\t\telse\n\t\t\t\t\t\tfor(int l = 0; l < dp[i + 1][j].size(); ++l)\n\t\t\t\t\t\t\tchmin(dp[i + 1][j][l], dp[i][j][k] + (danger[i][k] + danger[i + 1][l]) * abs(pos[i][k] - pos[i + 1][l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint sz[200];\nP stone[200][20];\nint dp[200][20][200];\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && (n || m)){\n\t\tfill(sz, sz + 200, 0);\n\t\tfill(&dp[0][0][0], &dp[199][19][199] + 1, INF);\n\t\trep(i, 2){\n\t\t\trep(j, 20){\n\t\t\t\tif(i == 0) dp[i][j][0] = 0;\n\t\t\t\telse dp[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\n\t\trep(i, n){\n\t\t\tcin >> sz[i];\n\t\t\trep(j, sz[i]){\n\t\t\t\tint x, r;\n\t\t\t\tcin >> x >> r;\n\t\t\t\tstone[i][j] = P(x, r);\n\t\t\t}\n\t\t}\n\n\t\trep(i, n){\n\t\t\trep(j, sz[i]){\n\t\t\t\trep(k, m + 1){\n\t\t\t\t\tif(i == n - 1){\n\t\t\t\t\t\tres = min(res, dp[i][j][k]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trep(l, sz[i+1]){\n\t\t\t\t\t\t\tint cost = abs(stone[i][j].first - stone[i+1][l].first) * \n\t\t\t\t\t\t\t\t(stone[i][j].second + stone[i+1][l].second);\n\t\t\t\t\t\t\tdp[i+1][l][k] = min(dp[i+1][l][k], dp[i][j][k] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k < m){\n\t\t\t\t\t\tif(i == n - 2){\n\t\t\t\t\t\t\tres = min(res, dp[i][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\trep(l, sz[i+2]){\n\t\t\t\t\t\t\t\tint cost = abs(stone[i][j].first - stone[i+2][l].first) * \n\t\t\t\t\t\t\t\t\t(stone[i][j].second + stone[i+2][l].second);\n\t\t\t\t\t\t\t\tdp[i+2][l][k+1] = min(dp[i+2][l][k+1], dp[i][j][k] + cost);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\nstruct edge\n{\n\tint to, cost;\n\tedge(){};\n\tedge(int to, int cost) : to(to), cost(cost){};\n};\n\nint dist[200][200][200];\nvector<vi> x(200);\nvector<vi> d(200);\n\nint main(){\n\twhile(1){\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tif(n == 0 && m == 0) break;\n\t\tx.clear(); d.clear();\n\t\tx.resize(n); d.resize(n);\n\t\trep(i, n){\n\t\t\tint k = in.nextInt();\n\t\t\trep(j, k){\n\t\t\t\tint tx = in.nextInt(), td = in.nextInt();\n\t\t\t\tx[i].pb(tx);\n\t\t\t\td[i].pb(td);\n\t\t\t}\n\t\t}\n\t\tvector<edge> g[200][200], g2[200][200];\n\t\trep(i, n-1){\n\t\t\trep(j, x[i].size()){\n\t\t\t\trep(k, x[i+1].size()){\n\t\t\t\t\tint c = (d[i][j] + d[i+1][k]) * abs(x[i][j]- x[i+1][k]);\n\t\t\t\t\tg[i][j].pb({k, c});\n\t\t\t\t}\n\t\t\t\tif( i + 2 < n);\n\t\t\t\telse continue;\n\t\t\t\trep(k, x[i+2].size()){\n\t\t\t\t\tint c = (d[i][j] + d[i+2][k]) * abs(x[i][j]- x[i+2][k]);\n\t\t\t\t\tg2[i][j].pb({k, c});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 200) rep(j, 200) rep(k, 200) dist[i][j][k] = i == 0 ? 0 : INF;\n\t\tauto dijkstra = [&]{\n\t\t\tpriority_queue<pair<pii, pii>, vector<pair<pii, pii> >, greater<pair<pii, pii> > > q;\n\t\t\tfor(int i = 0; i < x[0].size(); i++) q.push(mp(mp(0, 0), mp(0, i)));\n\t\t\tfor(int i = 0; i < x[1].size(); i++) q.push(mp(mp(0, 1), mp(1, i)));\n\t\t\tpair<pii, pii> p;\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top();\tq.pop();\n\t\t\t\tint cost = p.fi.fi, jump = p.fi.se, from1 = p.se.fi, from2 = p.se.se;\n\t\t\t\tfor(int i = 0; i < g[from1][from2].size(); i++){\n\t\t\t\t\tint to1 = from1 + 1, to2 =g[from1][from2][i].to, c = g[from1][from2][i].cost;\n\t\t\t\t\tif(dist[to1][to2][jump] <= cost + c) continue;\n\t\t\t\t\tdist[to1][to2][jump] = cost + c;\n\t\t\t\t\tq.push(mp(mp(cost + c, jump), mp(to1, to2)));\n\t\t\t\t}\n\t\t\t\tif(jump > m) continue;\n\t\t\t\tfor(int i = 0; i < g2[from1][from2].size(); i++){\n\t\t\t\t\tint to1 = from1 + 2, to2 =g2[from1][from2][i].to, c = g2[from1][from2][i].cost;\n\t\t\t\t\tif(dist[to1][to2][jump + 1] <= cost + c) continue;\n\t\t\t\t\tdist[to1][to2][jump + 1] = cost + c;\n\t\t\t\t\tq.push(mp(mp(cost + c, jump + 1), mp(to1, to2)));\n\t\t\t\t}\t\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\tint ans = INF;\n\t\tfor(int i = 0; i  < x[n-1].size(); i++){\n\t\t\tfor(int j = 0; j <= m; j++) ans = min(ans, dist[n-1][i][j]);\n\t\t}\n\t\tfor(int i = 0; i  < x[n-2].size(); i++){\n\t\t\tfor(int j = 0; j < m; j++) ans = min(ans, dist[n-2][i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n#define for_each(it,a) for(__typeof a.begin() it = a.begin();it!=a.end();it++)\ntemplate<class T> inline void chmin(T& a, T b) { if( b < a ) a = b; }\n\nint n, m;\nstruct edge{\n  int pos, dang;\n  vector < int >  value;\n  edge( int pos, int dang): pos(pos), dang(dang), value( (n + 1) / 2 + 1, INF){};\n};\nint main(){\n\n  while( cin >> n >> m , n){\n    vector< vector < edge > > info(n + 2);\n\n    for(int i = 0; i < n; i++){\n      int k;\n      cin >> k;\n      for(int j = 0; j < k; j++){\n        int t, d;\n        cin >> t >> d;\n        info[i].push_back( edge( t, d));\n      }\n    }\n    for_each( it, info[0]) it -> value[m] = 0;\n    for_each( it, info[1]) it -> value[m - 1] = 0;\n    int ret = INF;\n    for( int i = 0; i < n; i++){\n      for_each( now, info[i]){\n        for(int j = m; j >= 0; j--){ //ジャンプできる残り回数\n          int& cost = now -> value[j], dang = now -> dang, pos = now -> pos;\n          if( cost == INF) continue;\n          if(j > 0){ //ジャンプしてみる\n            for_each( next, info[i + 2]){\n              chmin( next -> value[j - 1], cost + (dang + next -> dang) * abs( pos - next -> pos));\n            }\n          }\n          for_each( next, info[i + 1]){\n            chmin( next -> value[j], cost + (dang + next -> dang) * abs( pos - next -> pos));\n          }\n        }\n      }\n    }\n    for_each(it,info[n - 1]) chmin( ret, *min_element( it->value.begin(), it->value.end()));\n    for_each(it,info[n - 2]) chmin( ret, *min_element( it->value.begin() + 1, it->value.end()));\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n; i++){\n      for(int j=1; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=1; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(0);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(1));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n, m;\n\nstruct edge {\n\tint from,to;\n\tint cost;\n\tbool sp;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int t,int c,bool f) : to(t), cost(c), sp(f) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvector<edge> G[500];\nint d[500][500];\n\nvoid dijkstra(int s) {\n\t// cost ticket place\n\tpriority_queue<pair<int, pair<int, int> >, vector< pair<int, pair<int, int> > >, greater< pair<int, pair<int, int> > > > que;\n\trep(i, 500) rep(j, 500) d[i][j] = INF;\n\td[s][0] = 0;\n\tque.push(mp(0, mp(0,s)));\n\t\n\twhile(que.size()) {\n\t\tint c = que.top().first;\n\t\tP p = que.top().second;\n\n\t\tque.pop();\n\t\tint t = p.first;\n\t\tint v = p.second;\n\n\t\tif(d[v][t] < c) continue;\n\t\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(e.sp) {\n\t\t\t\tif(t + 1 <= m && d[e.to][t+1] > d[v][t] + e.cost) {\n\t\t\t\t\td[e.to][t+1] = d[v][t] + e.cost;\n\t\t\t\t\tque.push(mp(d[e.to][t+1], mp(t+1, e.to)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(d[e.to][t] > d[v][t] + e.cost) {\n\t\t\t\t\td[e.to][t] = d[v][t] + e.cost;\n\t\t\t\t\tque.push(mp(d[e.to][t], mp(t, e.to)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> m) {\n\t\tif(n == 0 && m == 0) break;\n\n\t\trep(i, 500) G[i].clear();\n\n\t\tvector<pair<P, int> > v[n];\n\t\tint id = 1;\n\t\trep(i, n) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\n\t\t\trep(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv[i].push_back(mp(mp(a, b), id));\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\n\t\trep(i, v[0].size()) {\n\t\t\tP p = v[0][i].first;\n\t\t\tint a = v[0][i].second;\n\t\t\tG[0].push_back(edge(a, 0, false));\n\t\t}\n\n\t\trep(i, n-1) {\n\t\t\trep(j, v[i].size()) {\n\t\t\t\tP p = v[i][j].first;\n\t\t\t\tint a = v[i][j].second;\n\t\t\t\t\n\t\t\t\trep(k, v[i+1].size()) {\n\t\t\t\t\tP q = v[i+1][k].first;\n\t\t\t\t\tint b = v[i+1][k].second;\n\t\t\t\t\tint c = (p.second + q.second) * abs(p.first - q.first);\n\n\t\t\t\t\tG[a].push_back(edge(b, c, false));\n\t\t\t\t}\n\n\t\t\t\tif(i >= n-2) continue;\n\n\t\t\t\trep(k, v[i+2].size()) {\n\t\t\t\t\tP q = v[i+2][k].first;\n\t\t\t\t\tint b = v[i+2][k].second;\n\t\t\t\t\tint c = (p.second + q.second) * abs(p.first - q.first);\n\n\t\t\t\t\tG[a].push_back(edge(b, c, true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, v[n-1].size()) {\n\t\t\tP p = v[n-1][i].first;\n\t\t\tint b = v[n-1][i].second;\n\t\t\tG[b].push_back(edge(id, 0, false));\n\t\t}\n\n\t\t// cout << \"GRAPH\" << endl;\n\t\t//\n\t\t// rep(i, id+1) {\n\t\t// \tcout << \"Node:\" << i << \"  :\";\n\t\t// \trep(j, G[i].size()) cout << \"(\" << G[i][j].to << \",\" << G[i][j].cost << \") \";\n\t\t// \tcout << endl;\n\t\t// }\n\n\t\tdijkstra(0);\n\n\t\tint ans = INF;\n\t\trep(i, m + 1) {\n\t\t\tans = min(ans, d[id][i]);\n\t\t}\n\n\t\t// rep(i, m + 1) {\n\t\t// \tcout << \"ticket:\" << i << \" \";\n\t\t// \tcout << d[id][i] << endl;\n\t\t// }\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\tint ki;\n\tvector<P> stone[150];\n\tint dp[150][10][80];\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tstone[i].clear();\n\t\t\tfor(int j = 0;j < 10;j++){\n\t\t\t\tfor(int k = 0;k <= m;k++) dp[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> ki;\n\t\t\tfor(int j = 0;j < ki;j++){\n\t\t\t\tint a,b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tstone[i].push_back(P(a - 1,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < stone[0].size();i++){\n\t\t\tdp[0][stone[0][i].first][0] = 0;\n\t\t}\n\t\tfor(int i = 0;i < stone[1].size();i++){\n\t\t\tdp[1][stone[1][i].first][1] = 0;\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tfor(int j = 0;j < stone[i].size();j++){\n\t\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\t\tfor(int l = 0;l < stone[i - 1].size();l++){\n\t\t\t\t\t\tdp[i][stone[i][j].first][k] = min(dp[i][stone[i][j].first][k],dp[i - 1][stone[i - 1][l].first][k] + (stone[i][j].second + stone[i - 1][l].second) * abs(stone[i][j].first - stone[i - 1][l].first));\n\t\t\t\t\t}\n\t\t\t\t\tif(i >= 2 && k >= 1){\n\t\t\t\t\t\tfor(int l = 0;l < stone[i - 2].size();l++){\n\t\t\t\t\t\t\tdp[i][stone[i][j].first][k] = min(dp[i][stone[i][j].first][k],dp[i - 2][stone[i - 2][l].first][k - 1] + (stone[i][j].second + stone[i - 2][l].second) * abs(stone[i][j].first - stone[i - 2][l].first));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < stone[n - 1].size();i++){\n\t\t\tfor(int j = 0;j <= m;j++){\n\t\t\t\tmi = min(mi,dp[n - 1][stone[n - 1][i].first][j]);\n\t\t\t}\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second ==0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<MAX_V; i++)\n    ans=min(d[n-1][i],ans);\n \n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][MAX_V];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<MAX_V; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=0; i<n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<n-1; i++){\n      for(int j=0; j<MAX_V; j++){\n\t\n\tif(graph[i][j]>0){\n\t  \n\t  for(int l=0; l<MAX_V; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  int res=dijkstra(0);\n  if(m>0){\n    m--;\n    res=min(res,dijkstra(1));\n  }\n  cout << res << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[152][78]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%lld\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%lld%lld\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e >= 2 && j<b) {\n\t\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 2][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = 1 << 29;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[256][16][128];\nint stones[256][16][2];\nint col[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tREP(k, 2) cin >> stones[i][j][k];\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tint x_now = stones[i][j][0], d_now = stones[i][j][1];\n\tREP(m, M+1) {\n\t  if (dp[i][j][m] == INF) continue;\n\t  REP(k, col[i+1]) {\n\t    int x_next = stones[i+1][k][0], d_next = stones[i+1][k][1];\n\t    int safe = (d_now + d_next) * abs(x_now - x_next);\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + safe);\n\t  }\n\t}\n\tif (i < N-2) {\n\t  REP(m, M) {\n\t    REP(k, col[i+2]) {\n\t      int x_next = stones[i+2][k][0], d_next = stones[i+2][k][1];\n\t      int safe = (d_now + d_next) * abs(x_now - x_next);\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<29)\nint K[150];\nint X[10][150];\nint D[10][150];\nint DP[10][150][80];\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][M]=0;\n\t\tif(M>0) for(int x=0;x<K[1];x++) DP[x][1][M-1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y==1) continue;\n\t\t\tfor(int xx=0;xx<K[y-2];xx++) for(int m=0;m<M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m+1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-2];x++) for(int m=1;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-2][m]);\n\t\t}\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nint danger[155][1010];\nvector<int> X[155];\nint dp[155][1010][80];\n\nconst int inf = 1 << 25;\n\nint solve(int col, int row, int jump)\n{\n  if(col >= n-1) return 0;\n  if(col >= n-2 && jump < m) return 0;\n  if(jump > m) return inf;\n  int& ret = dp[col][row][jump];\n  if(~ret) return ret;\n  ret = inf;\n  for(int i = 0; i < X[col+1].size(); i++){\n    if(danger[col+1][X[col+1][i]] == inf) continue;\n    int D = (danger[col][row] + danger[col+1][X[col+1][i]]) * abs(row - X[col+1][i]);\n    ret = min(ret, solve(col + 1, X[col+1][i], jump) + D);\n  }\n  if(jump < m && col < n-1){\n    for(int i = 0; i < X[col+2].size(); i++){\n      if(danger[col+2][X[col+2][i]] == inf) continue;\n      int D = (danger[col][row] + danger[col+2][X[col+2][i]]) * abs(row - X[col+2][i]);\n      ret = min(ret, solve(col + 2, X[col+2][i], jump + 1) + D);\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 155; i++){\n      for(int j = 0; j < 11; j++) danger[i][j] = inf;\n    }\n    for(int i = 0; i < n; i++){\n      int k; cin >> k;\n      for(int j = 0; j < k; j++){\n\tint x, d;\n\tcin >> x >> d;\n\t--x;\n\tdanger[i][x] = d;\n\tX[i].push_back(x);\n      }\n    }\n    memset(dp, -1, sizeof(dp));\n    int ans = inf;\n    for(int i = 0; i < X[0].size(); i++){\n      if(danger[0][X[0][i]] == inf) continue;\n      ans = min(ans, solve(0, X[0][i], 0));\n    }\n    if(m > 0 && n > 1){\n      for(int i = 0; i < X[1].size(); i++){\n\tif(danger[1][X[1][i]] == inf) continue;\n\tans = min(ans, solve(1, X[1][i], 1));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdlib>\nusing namespace std;\n\nint main(){\n\ttypedef pair<int,int> pii;\n\tvector<pii>::iterator it;\n\tint n, m, k, x, d, h, i, j;\n\tfor(; cin >> n >> m, n; ){\n\t\tvector<pii> st[151];\n\t\tfor( i = 1; i <= n; i++ ){\n\t\t\tfor( cin >> k; k--; ){\n\t\t\t\tcin >> x >> d;\n\t\t\t\tst[i].push_back( pii( x, d ) );\n\t\t\t}\n\t\t}\n\n\t\tint dp[158][151][10];\n\t\tfill( **dp, *dp[158], 1e9 );\n\t\tfor( i = st[1].size(); i--; ){\n\t\t\tdp[m][1][i] = 0;\n\t\t}\n\n\t\tfor( h = 2; h <= n; h++ ){\n\t\t\tfor( i = m; i >= 0; i-- ){\n\t\t\t\tfor( j = st[h].size(); j--; ){\n\t\t\t\t\tfor( k = st[h-1].size(); k--; ){\n\t\t\t\t\t\tx = dp[i][h-1][k]\n\t\t\t\t\t\t  + ( st[h][j].second + st[h-1][k].second )\n\t\t\t\t\t\t  * abs( st[h][j].first - st[h-1][k].first );\n\t\t\t\t\t\tdp[i][h][j] = min( dp[i][h][j], x );\n\t\t\t\t\t}\n\t\t\t\t\tfor( k = st[h-2].size(); k--; ){\n\t\t\t\t\t\tx = dp[i+1][h-2][k]\n\t\t\t\t\t\t  + ( st[h][j].second + st[h-2][k].second )\n\t\t\t\t\t\t  * abs( st[h][j].first - st[h-2][k].first );\n\t\t\t\t\t\tdp[i][h][j] = min( dp[i][h][j], x );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx = 1e9;\n\t\tfor( i = m; i >= 0; i-- ){\n\t\t\tfor( j = st[n].size(); j--; ){\n\t\t\t\tx = min( x, dp[i][n][j] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << x << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n+1){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n+1){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dijkstra(0) << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst ll INF = 9000000000000000000;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M;\nstd::vector<P> S[153];\nll dp[153][10][80];\n\nll value(const P& lp, const P& rp){\n    return (lp.second+rp.second) * std::abs(lp.first-rp.first);\n}\n\nll rec(int y, int x, int t){\n    if(y > N){return 0;}\n    if(dp[y][x][t] != -1){return dp[y][x][t];}\n\n    ll res = INF;\n    REP(i, S[y+1].size()){\n        res = std::min(res, rec(y+1, i, t) + value(S[y][x], S[y+1][i]));\n    }\n\n    if(t < M){\n        REP(i, S[y+2].size()){\n            res = std::min(res, rec(y+2, i, t+1) + value(S[y][x], S[y+2][i]));\n        }\n    }\n\n    return dp[y][x][t] = res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, N+3){\n            S[i].clear();\n        }\n\n        REP(i, N){\n            int k;\n            std::cin >> k;\n\n            REP(j, k){\n                int x, d;\n                std::cin >> x >> d;\n                x--;\n\n                S[i+1].push_back(mp(x, d));\n            }\n        }\n\n        REP(i, S[1].size()){\n            S[0].push_back(S[1][i]);\n        }\n\n        REP(i, S[2].size()){\n            S[0].push_back(S[2][i]);\n        }\n\n        REP(i, S[N].size()){\n            S[N+1].push_back(S[N][i]);\n            S[N+2].push_back(S[N][i]);\n        }\n\n        REP(i, S[N-1].size()){\n            S[N+1].push_back(S[N-1][i]);\n        }\n\n        REP(i, N+3){\n            REP(j, 10){\n                REP(k, M+1){\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n\n        ll res = INF;\n        REP(i, S[0].size()){\n            res = std::min(res, rec(0, i, 0));\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint mincost;\n\n\nvoid NoJump(VVP &G,VVI &dp)\n{\n  int n= dp.size();\n  rep(i,dp[0].size())dp[0][i] = 0;\n  rep(i,n-1)\n    {\n      int m = dp[i].size();\n      int o = dp[i+1].size();\n      rep(j,m)\n\t{\n\t  rep(k,o)\n\t    {\n\t      int cost = (G[i+1][k].S+G[i][j].S)*abs(G[i+1][k].F-G[i][j].F);\n\t      dp[i+1][k] = min(dp[i+1][k],cost+dp[i][j]);\n\t    }\t\n\t}\n    }\n}\n\nvoid printVVI(VVI &G)\n{\n  cout << \"printVVI ------------ \"<< endl;\n  rep(i,G.size())\n    {\n      rep(j,G[i].size())\n\t{\n\t  cout << G[i][j] << \" \";\n\t} \n      cout << endl;\n    }\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      mincost = (1<<29);\n      VVP G(n);\n      rep(i,n)\n\t{\n\t  int k;\n\t  cin >> k;\n\t  rep(j,k)\n\t    {\n\t      int x,d;\n\t      cin >> x >> d;\n\t      G[i].push_back(P(x,d));\n\t    }\n\t}\n    \n      VVI dp(n);\n      rep(i,n)dp[i].resize(G[i].size(),(1<<29));\n      NoJump(G,dp);\n      //printVVI(dp);      \n\n      //First jump\n      VVI prev = dp;\n      if(m != 0){\n\t\n\trep(i,G[1].size())prev[1][i] = 0;    \n\trep(i,n)\t\n\t  {\n\t    if(i+2 >= n)\n\t      {\n\t\trep(k,G[i].size())mincost = min(mincost,dp[i][k]);\n\t\tbreak;\n\t      }\n\t  rep(j,G[i].size())\n\t    {\n\t      rep(k,G[i+2].size())\n\t\t{\n\t\t  int cost = (G[i][j].S+G[i+2][k].S)*abs(G[i][j].F-G[i+2][k].F);\n\t\t  prev[i+2][k] = min(prev[i+2][k],cost+dp[i][j]); \n\t\t}\n\t    }\n\t  }\n\tdp = prev;\n\t//printVVI(dp);\n      }\n      \n      if(m == 1 || m == 0)goto Next;\n\n      for(int i=1,cnt=1;cnt<m;cnt++,i+=2)\n\t{\n\t  prev = dp;\n\t  REP(j,i,n)\n\t    {\n\t      if(j+2 >= n)\n\t\t{\n\t\t  rep(k,G[j].size())mincost = min(mincost,dp[j][k]);\n\t\t  break;\n\t\t}\n\t      rep(k,G[j].size())\n\t\t{\n\t\t  rep(l,G[j+2].size())\n\t\t    {\t  \n\t\t      int cost = (G[j][k].S+G[j+2][l].S)*abs(G[j][k].F-G[j+2][l].F);\n\t\t      prev[j+2][l] = min(prev[j+2][l],cost+dp[j][k]);\n\t\t    }\n\t\t}\n\t    }\n\t  dp = prev;\n\t}      \n      //printVVI(dp);\n     \n    Next:;\n    \n      NoJump(G,dp);\n\n      //printVVI(dp);\n\n      if(!G[n-1].empty())\n\trep(i,G[n-1].size())mincost = min(mincost,dp[n-1][i]);\n      else\n\trep(i,G[n-2].size())mincost = min(mincost,dp[n-2][i]);\n      \n      cout << mincost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX_R (3000000)\n#define min(x,y) ((x<y)?x:y)\ntypedef struct stone{\n\tint x,r;\n}Stone;\nStone p[155][15];\nint xn[155],dp[155][15][80];\nint main(){\n\tint i,j,k,h,n,m,x,y,z,ans;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&xn[i]);\n\t\t\tfor(j=0;j<xn[i];j++){\n\t\t\t\tscanf(\"%d%d\",&p[i][j].x,&p[i][j].r);\n\t\t\t\tfor(k=0;k<=m;k++)dp[i][j][k]=MAX_R;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<xn[0];i++)dp[0][i][0]=0;\n\t\tfor(i=0;i<xn[1];i++)dp[1][i][1]=0;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tfor(h=0;h<=m;h++){\n\t\t\t\tfor(j=0;j<xn[i];j++){\n\t\t\t\t\tfor(k=0;k<xn[i+1];k++){\n\t\t\t\t\t\ty=(p[i][j].r+p[i+1][k].r)*abs(p[i][j].x-p[i+1][k].x);\n\t\t\t\t\t\tdp[i+1][k][h]=min(dp[i+1][k][h],dp[i][j][h]+y);\n\t\t\t\t\t}\n\t\t\t\t\tfor(k=0;k<xn[i+2];k++){\n\t\t\t\t\t\ty=(p[i][j].r+p[i+2][k].r)*abs(p[i][j].x-p[i+2][k].x);\n\t\t\t\t\t\tdp[i+2][k][h+1]=min(dp[i+2][k][h],dp[i][j][h]+y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=MAX_R;\n\t\tfor(i=0;i<=m;i++){\n\t\t\tfor(j=0;j<xn[n-1];j++){\n\t\t\t\tans=min(ans,dp[n-1][j][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n// pair<pair<int, int>, pair<int, int> > dp[150][1000];\n\n// rec(y, x, m) = min(rec(y-1, 0, m) + |x-0| * (d(y, x) + d(y-1, 0)),\n//                    rec(y-1, 1, m) + |x-1| * (d(y, x) + d(y-1, 1)),\n//                    ...\n//                    rec(y-1, xmax, m) + |x-xmax| * (d(y, x) + d(y-1, xmax)),\n//                    rec(y-2, 0, m-1) + |x-0| * (d(y, x) + d(y-2, 0))\n//                    rec(y-2, 1, m-1) + |x-1| * (d(y, x) + d(y-2, 1))\n//                    ...\n//                    rec(y-2, xmax, m-1) + |x-xmax| * (d(y, x) + d(y-2, xmax)))\n\nint w, minv, d[1000][155];\n\nvoid rec(int y, int x, int m, int cost) {\n  // cout << y << ' ' << x << ' ' << m << ' ' << cost << endl;\n  if (y == 0 || y == 1) {\n    minv = min(minv, cost);\n    return;\n  }\n  for (int i = 0; i < w; i++) {\n    if (d[i][y-1] != -1 && minv > cost + abs(x-i) * (d[x][y] + d[i][y-1]))\n      rec(y-1, i, m, cost + abs(x-i) * (d[x][y] + d[i][y-1]));\n    if (m && d[i][y-2] != -1 && minv > cost + abs(x-i) * (d[x][y] + d[i][y-2]))\n      rec(y-2, i, m-1, cost + abs(x-i) * (d[x][y] + d[i][y-2]));\n  }\n}\n\nint main() {\n  for (;;) {\n    int n, m;\n    cin >> n >> m;\n    if (!(n || m)) return 0;\n    w = 0;\n    minv = 20000;\n    for (int y = 0; y < n+3; y++)\n      for (int x = 0; x < 1000; x++)\n        if (y <= 1 || y == n+2) d[x][y] = 0;\n        else d[x][y] = -1;\n    for (int y = 2; y < n+2; y++) {\n      int k;\n      cin >> k;\n      for (int i = 0; i < k; i++) {\n        int x;\n        cin >> x;\n        w = max(w, x);\n        cin >> d[x-1][y];\n      }\n    }\n    /*\n    for (int y = 0; y < n+3; y++) {\n      for (int x = 0; x < w; x++)\n        cout << d[x][y] << ' ';\n      cout << endl;\n    }\n    */\n    for (int x = 0; x < w; x++)\n      rec(n+2, x, m, 0);\n    cout << minv << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 5000000\nint n,m;\nint d[77][150][10];\nint r[150][10];\nint f[150][10];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tfor(i=0;i<n;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\td[k][i][f[i][j]]=INF;\n\t\t}\n\t\tfor(i=0;i<=c[0];i++)d[m][0][f[0][i]]=0;\n\t\tif(m>=1)for(j=0;j<c[1];j++)d[m-1][1][f[1][j]]=0;\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j+1][i-2][f[i-2][l]]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j][i-1][f[i-1][l]]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][f[n-1][j]]);\n\t\t}\n\t\tfor(i=1;i<=m;i++)for(j=0;j<c[n-2];j++){\n\t\t\tans=min(ans,d[i][n-2][f[n-2][j]]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n#define REP(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\n\nint dist(pair<int, int> s1, pair<int, int> s2) {\n  return abs(s1.first - s2.first) * (s1.second + s2.second);\n}\n\nint main(void) {\n  while(1) {\n    int N, M;\n    vector< pair<int, int> > S[150];\n    vector<int> dp[150][150];\n\n    cin >> N >> M;\n    if(N == 0 && M == 0) break;\n    REP(i, 0, N) {\n      int k;\n      cin >> k;\n      REP(j, 0, k) {\n        int x, d;\n        cin >> x >> d;\n        S[i].push_back(pair<int, int>(x, d));\n      }\n    }\n\n    REP(i, 0, N) {\n      REP(j, 0, M + 1) {\n        REP(k, 0, S[i].size()) {\n          int m = INT_MAX;\n          if(i >= 1) {\n            REP(l, 0, S[i - 1].size()) {\n              m = min(m, dp[i - 1][j][l] + dist(S[i][k], S[i - 1][l]));\n            }\n          }\n          if(i >= 2 && j >= 1) {\n            REP(l, 0, S[i - 2].size()) {\n              m = min(m, dp[i - 2][j - 1][l] + dist(S[i][k], S[i - 2][l]));\n            }\n          }\n          if(i == 0 && j == 0) m = 0;\n          if(i == 0 && j >= 1) m = INT_MAX;\n          if(i == 1 && j == 1) m = 0;\n          dp[i][j].push_back(m);\n        }\n      }\n    }\n\n    int ans = INT_MAX;\n    REP(i, 0, dp[N - 1][M].size()) {\n      ans = min(ans, dp[N - 1][M][i]);\n    }\n    if(M >= 1) {\n      REP(i, 0, dp[N - 1][M - 1].size()) {\n        ans = min(ans, dp[N - 1][M - 1][i]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint abst(int x){\n    return (x>=0)? x : -x;\n}\n\nint main(){\n    int n,m,ki,min,tmp;\n    int i,j,k,l;\n    scanf(\"%d %d\",&n,&m);\n    while(n||m){\n        int river[n+1][10][2],risk[n+1][10][m];//?????°??£?¨???????????????\\??????????????????????????????\n        for(i=1;i<=n;i++){\n            scanf(\"%d\",&ki);\n            river[i][0][0] = ki;\n            for(j=1;j<=ki;j++){\n                scanf(\"%d %d\",&river[i][j][0],&river[i][j][1]);\n            }\n        }\n        for(j=1;j<=river[1][0][0];j++){\n            for(k=0;k<=m;k++){\n                risk[1][j][k] = 0;\n            }\n        }\n        for(i=2;i<=n;i++){\n            for(j=1;j<=river[i][0][0];j++){\n                for(k=0;k<=m;k++){\n                    min = risk[i-1][1][k] + (river[i-1][1][1]+river[i][j][1])*abst(river[i-1][1][0]-river[i][j][0]);\n                    for(l=2;l<=river[i-1][0][0];l++){\n                        tmp = risk[i-1][l][k] + (river[i-1][l][1]+river[i][j][1])*abst(river[i-1][l][0]-river[i][j][0]);\n                        if(tmp<min)min = tmp;\n                    }\n                    if(i-2&&k){\n                        for(l=1;l<=river[i-1][0][0];l++){\n                            tmp = risk[i-2][l][k-1] + (river[i-2][l][1]+river[i][j][1])*abst(river[i-2][l][0]-river[i][j][0]);\n                            if(tmp<min)min = tmp;\n                        }\n                    }\n                    risk[i][j][k] = min;\n                }\n            }\n        }\n        min = risk[n][1][m];\n        for(j=2;j<=river[n][0][0];j++){\n            tmp = risk[n][j][m];\n            if(min>tmp)min = tmp;\n        }\n        printf(\"%d\\n\",min);\n        scanf(\"%d %d\",&n,&m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nint k[151];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n    if (n >= N - 1) return 0;\n\n    if (~memo[n][m][i]) return memo[n][m][i];\n\n    int res = inf;\n\n    rep(j, k[n + 1]) {\n        int dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n        chmin(res, dist + rec(n + 1, m, j));\n    }\n\n    if (m > 0) {\n        if (n + 2 >= N) return 0;\n        rep(j, k[n + 2]) {\n            int dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n            chmin(res, dist + rec(n + 2, m - 1, j));\n        }\n    }\n\n    return memo[n][m][i] = res;\n}\n\nsigned main()\n{\n    while (scanf(\"%lld %lld\", &N, &M), N || M) {\n        rep(i, N) {\n            scanf(\"%lld\", &k[i]);\n\n            stone[i].resize(k[i]);\n\n            rep(j, k[i]) {\n                int x, d; scanf(\"%lld %lld\", &x, &d);\n                stone[i][j].fst = x, stone[i][j].scd = d;\n            }\n        }\n\n        int ans = inf;\n\n        rep(i, k[0]) {\n            memset(memo, -1, sizeof(memo));\n            chmin(ans, rec(0, M, i));\n        }\n\n        printf(\"%lld\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nint danger[155][11];\nint dp[155][11][80];\n\nconst int inf = 1 << 25;\n\nint solve(int col, int row, int jump)\n{\n  if(col >= n-1) return 0;\n  if(jump > m) return inf;\n  int& ret = dp[col][row][jump];\n  if(~ret) return ret;\n  ret = inf;\n  for(int i = 0; i < 11; i++){\n    if(danger[col+1][i] == inf) continue;\n    int D = (danger[col][row] + danger[col+1][i]) * abs(row - i);\n    ret = min(ret, solve(col + 1, i, jump) + D);\n  }\n  if(jump < m && col < n-1){\n    for(int i = 0; i < 11; i++){\n      if(danger[col+2][i] == inf) continue;\n      int D = (danger[col][row] + danger[col+2][i]) * abs(row - i);\n      ret = min(ret, solve(col + 2, i, jump + 1) + D);\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 155; i++){\n      for(int j = 0; j < 11; j++) danger[i][j] = inf;\n    }\n    for(int i = 0; i < n; i++){\n      int k; cin >> k;\n      for(int j = 0; j < k; j++){\n\tint x, d;\n\tcin >> x >> d;\n\t--x;\n\tdanger[i][x] = d;\n      }\n    }\n    memset(dp, -1, sizeof(dp));\n    int ans = inf;\n    for(int i = 0; i < 11; i++){\n      if(danger[0][i] == inf) continue;\n      ans = min(ans, solve(0, i, 0));\n    }\n    if(m > 0 && n > 1){\n      for(int i = 0; i < 11; i++){\n\tif(danger[1][i] == inf) continue;\n\tans = min(ans, solve(1, i, 1));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define f first\n#define s second\n#define p4 pair<pair<int,int>,pair<int,int> >\n#define mp4(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\nusing namespace std;\nint flag[152][12][78] = {{{0}}};\npriority_queue<p4,vector<p4 >,greater<p4 > >Q;\nint in(){int x;scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n\n      int slip[152][12] = {{0}};\n      REP(i,1,n+1){\n         int x = in();\n         rep(j,x){\n            slip[i][in()] = in();\n         }\n      }\n      memset(flag,0,sizeof(flag));\n      while(Q.size()) Q.pop();\n\n      REP(i,1,10+1){\n         if(slip[1][i] != 0){\n            Q.push(mp4(0,1,i,0));\n         }\n         if(slip[2][i] != 0 && m != 0){\n            Q.push(mp4(0,2,i,1));\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         p4 p = Q.top(); Q.pop();\n         if(p.f.s == n){ans = p.f.f;break;}\n         else if(p.f.s == n-1 && p.s.s < m){ans = p.f.f; break;}\n\n         if(flag[p.f.s][p.s.f][p.s.s] == 1) continue;\n         flag[p.f.s][p.s.f][p.s.s] =1;\n\n         REP(i,1,10+1){\n            if(slip[p.f.s+1][i] != 0 && flag[p.f.s+1][i][p.s.s] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+1][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+1,i,p.s.s));\n            }\n            if(slip[p.f.s+2][i] != 0 && p.s.s <m && flag[p.f.s+2][i][p.s.s+1] == 0){\n               Q.push(mp4(p.f.f+(slip[p.f.s+2][i]+slip[p.f.s][p.s.f])*abs(i-p.s.f),p.f.s+2,i,p.s.s+1));\n            }\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < stones[i].size(); ++j) {\n                q.push(Tag(i, j, 0, M-i));\n            }\n        }\n\n        vector<vector<pair<int, int> > > dp(N, vector<pair<int, int> >(1000, make_pair(0, INT_MAX)));\n        unsigned ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m <= 0 && i == 2) break;\n                int y = t.y+i;\n                int nm = t.m-i+1;\n                for(int j = 0; j < stones[y].size(); ++j) {\n                    int cost = t.c + (stones[t.y][t.x].second+stones[y][j].second)*abs(stones[t.y][t.x].first-stones[y][j].first);\n                    if(nm >= dp[y][j].first && cost >= dp[y][j].second) continue;\n                    if(cost >= dp[y][j].second) dp[y][j] = make_pair(nm, cost);\n                    q.push(Tag(y, j, cost, nm));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <map>\n#include <vector>\n#include <algorithm>\n#define inf INT_MAX/2\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        vector<P> riv[155];\n        vector<vector<vector<int> > > dp(155);\n        for (int i=0; i<n; i++) {\n            int k; scanf(\"%d\",&k);\n            riv[i].clear();\n            for (int j=0; j<k; j++) {\n                int x, d; scanf(\"%d%d\",&x,&d);\n                riv[i].push_back(P(x,d));\n            }\n        }\n        for (int i=0; i<n; i++) {\n            dp[i].resize(riv[i].size(), vector<int>(m+1,inf));\n        }\n        for (int i=0; i<riv[0].size(); i++) {\n            dp[0][i][0]=0;\n        }\n        for (int i=0; i<riv[1].size(); i++) {\n            dp[1][i][1]=0;\n        }\n        int res=inf;\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<riv[i].size(); j++) {\n                for (int k=0; k<=m; k++) {\n                    if (i+1==n) {\n                        res=min(res,dp[i][j][k]);\n                    } else {\n                        for (int l=0; l<riv[i+1].size(); l++) {\n                            dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+(int)abs(riv[i][j].f-riv[i+1][l].f)*(riv[i][j].s+riv[i+1][l].s));\n                        }\n                        if (i<n-1&&k<m) {\n                            if (i+2==n) {\n                                res=min(res,dp[i][j][k]);\n                            } else {\n                                for (int l=0; l<riv[i+2].size(); l++) {\n                                    dp[i+2][l][k+1]=min(dp[i+2][l][k+1],dp[i][j][k]+(int)abs(riv[i][j].f-riv[i+2][l].f)*(riv[i][j].s+riv[i+2][l].s));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll dp[150][76][10];\nint main(){\n\twhile(true){\n\tint n,m;\tcin>>n>>m;\n\tif(n==0)\treturn 0;\n\tvector<pair<int,int>> ls[n];\n\tfor(int i=0;i<n;i++){\n\t\tint k;\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint x,d;\tcin>>x>>d;\n\t\t\tls[i].push_back(make_pair(x,d));\n\t\t}\n\t}\n\tfor(int i=0;i<150;i++){\n\t\tfor(int j=0;j<=75;j++){\n\t\t\tfor(int k=0;k<10;k++)\tdp[i][j][k]=(1<<30);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)ls[0].size();i++)\tdp[0][m][i]=0;\n\tif(m!=0)\tfor(int i=0;i<(int)ls[1].size();i++)\tdp[1][m-1][i]=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<(int)ls[i].size();k++){\n\t\t\t\tif(dp[i][j][k]==(1<<30))\tcontinue;\n\t\t\t\tfor(int l=0;l<(int)ls[i+1].size();l++){\n\t\t\t\t\tdp[i+1][j][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+1][l].first)*(ls[i][k].second+ls[i+1][l].second),dp[i+1][j][l]);\n\t\t\t\t}\n\t\t\t\tif(j!=0&&i+2<n){\n\t\t\t\t\tfor(int l=0;l<(int)ls[i+2].size();l++){\n\t\t\t\t\tdp[i+2][j-1][l]=min(dp[i][j][k]+abs(ls[i][k].first-ls[i+2][l].first)*(ls[i][k].second+ls[i+2][l].second),dp[i+2][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=(1<<30);\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-1].size();j++){\n\t\t\tans=min(ans,dp[n-1][i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tfor(int j=0;j<(int)ls[n-2].size();j++){\n\t\t\tans=min(ans,dp[n-2][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 155\n#define S 85\n#define M 15\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n \nstruct Node{\n  int X,cost;\n  Node(){};\n  Node(int a,int c){X=a,cost=c;};\n};\n \nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n \nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[S][N][M];\n\nint dijkstra(int sy,int sx,int sm){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<S;i++)\n    for(int j=0;j<N;j++)\n      for(int l=0;l<M;l++)d[i][j][l]=INF;\n  d[sm][sy][sx]=0;\n  if(sm<=m)q.push(P1(P(0,sm),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    if(n-1<=y||(n-2<=y&&mcnt<m))return cost;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=cost+e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>ncost){\n\td[f+mcnt][ny][nx]=ncost;\n\tq.push(P1(P(ncost,f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a,b));\n      }\n    }\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<=i+2&&j<n;j++)\n\tfor(int l=0;l<node[i].size();l++)\n\t  for(int p=0;p<node[j].size();p++)\n\t    e[i][l].push_back(Edge(j,p,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].X-node[j][p].X),j-i-1));\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++) ans=min(ans,dijkstra(0,i,0));\n    for(int i=0;i<node[1].size();i++) ans=min(ans,dijkstra(1,i,1));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint DP[151][10][76];\nint abs(int a){\n\tif(a<=0)\n\treturn -a;\n\treturn a;\n}\nint main() {\n\twhile(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n==0)\n\tbreak;\n\tint k[151],kiS[151][10],kiP[151][10];\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> k[i];\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tcin >> kiP[i][j] >> kiS[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<151;i++)\n\t\tfor(int j=0;j<10;j++)\n\t\t\tfor(int kk=0;kk<76;kk++)\n\t\t\t\tDP[i][j][kk]=1 << 28;\n\tfor(int i=0;i<k[1];i++){\n\tDP[1][i][0]=0;\n\t}\n\tfor(int i=0;i<k[2];i++)\n\tDP[2][i][1]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int kk=0;kk<=min(m,i/2+1);kk++){\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int l=0;l<k[i-1];l++)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-1][l][kk]+(kiS[i][j]+kiS[i-1][l])*(abs(kiP[i][j]-kiP[i-1][l])));\n\t\t\t\tfor(int l=0;l<k[i-1];l++){\n\t\t\t\tif(kk!=0)\n\t\t\t\tDP[i][j][kk]=min(DP[i][j][kk],DP[i-2][l][kk-1]+(kiS[i][j]+kiS[i-2][l])*(abs(kiP[i][j]-kiP[i-2][l])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<k[i];j++)\n\t\t//\tcout << DP[i][j][0] << \" \" << i <<\" \" << j <<  endl;\n\t}*/\n\tint maxer =1 << 28;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tmaxer=min(maxer,DP[n][i][j]);\n\t\t//\tcout << n << \" \" << i << \" \" << j << \" \" << DP[n][i][j]<< endl;\n\t\t\tif(j+1<=m)\n\t\t\tmaxer=min(maxer,DP[n-1][i][j]);\n\t\t}\n\t}\n\tcout << maxer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int n, m;\n  while(cin>>n>>m && n){\n    static int dp[151][11][80] = {};\n    REP(i, 151)REP(j, 11)REP(k, 80) dp[i][j][k] = INF;\n    int k[151], x[150][151], s[151][151];\n    REP(i, n){\n      cin>>k[i];\n      REP(j, k[i]) cin>>x[i][j]>>s[i][j];\n    }\n    REP(i, k[0]) dp[0][i][0] = 0;\n    for(int i = 0; i < n - 1; i++){\n      for(int j = 0; j < k[i]; j++){\n        int from_x = x[i][j];\n        for(int l = 0; l < k[i + 1]; l++){\n          int to_x = x[i + 1][l];\n          for(int use = 0; use <= m; use++){\n            dp[i + 1][l][use] = min(dp[i + 1][l][use], dp[i][l][use] + (s[i][j] + s[i + 1][l]) * abs(from_x - to_x));\n          }\n        }\n        if(i + 2 < n){\n          for(int l = 0; l < k[i + 2]; l++){\n            int to_x = x[i + 2][l];\n            for(int use = 0; use < m; use++){\n              dp[i + 2][l][use + 1] = min(dp[i + 2][l][use + 1], dp[i][j][use] + (s[i][j] + s[i + 2][l]) * abs(from_x - to_x));\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(i, k[n - 1])REP(j, m + 1) ans = min(ans, dp[n-1][i][j]);\n    REP(i, k[n - 2])REP(j, m ) ans = min(ans, dp[n-2][i][j]);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint dp[160][1010][100];\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n,vi(1010));\n\t\trep(i,n){\n\t\t\tint k;cin>>k;\n\t\t\twhile(k--){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\ta--;\n\t\t\t\tin[i][a]=b;\n\t\t\t}\n\t\t}\n\t\trep(i,160)rep(j,1010)rep(k,100)dp[i][j][k]=inf;\n\t\trep(i,1010)if(in[0][i])dp[0][i][0]=0;\n\t\trep(i,1010)if(in[1][i])dp[1][i][1]=0;\n\t\tloop(i,1,n)rep(j,1010)rep(k,m+1)if(in[i][j]){\n\t\t\trep(l,1010)if(in[i-1][l])dp[i][j][k]=min(dp[i][j][k],\n\t\t\t\tdp[i-1][l][k]+(in[i][j]+in[i-1][l])*(abs(l-j)));\n\t\t\tif(k&&i!=1){\n\t\t\t\trep(l,1010)if(in[i-2][l])dp[i][j][k]=min(dp[i][j][k],\n\t\t\t\t\tdp[i-2][l][k-1]+(in[i][j]+in[i-2][l])*(abs(j-l)));\n\t\t\t}\n\t\t}\n//\t\trep(i,n){rep(j,4)cout<<\" \"<<dp[i][j][1];cout<<endl;}\n\t\tint out=inf;\n\t\trep(i,1010)rep(j,m+1)out=min(out,dp[n-1][i][j]);\n\t\trep(i,1010)rep(j,m)out=min(out,dp[n-2][i][j]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][11];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,10){\n   x[0].pb(i+1);\n   x[n+1].pb(i+1);\n  }\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  \n  fill(dp[0][0],dp[n-1][0],1000000000);\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][x[n][j]]=0;\n  FOR(i,m+1) FOR(j,10) dp[n+1][i][j+1]=0;\n  for(int i=n-1;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(i!=n&&j){\n      FOR(l,x[i+2].size()){\n       dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+(i!=0)?(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]):0);\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+(i!=0)?(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]):0);\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[0].size()) mi=min(mi,dp[0][m][x[0][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\nint main()\n{\n\twhile(true) {\n\t\t\n\t\tint n, m;\n\t\tvector<vector<pair<int, int> > > s;\n\t\tvector<vector<vector<int> > > dp;\n\t\t\n\t\tconst int maxx = 1000;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\t\n\t\ts.resize(n + 2);\n\t\tfor(int i = 1; i < n + 1; ++i) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\ts[i].resize(k);\n\t\t\tfor(int j = 0; j < k; ++j) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t\ts[i][j] = make_pair(a, b);\n\t\t\t}\n\t\t}\n\t\ts[0].resize(maxx);\n\t\ts[n + 1].resize(maxx);\n\t\tfor(int i = 0; i < maxx; ++i) {\n\t\t\ts[0][i] = make_pair(i + 1, 0);\n\t\t\ts[n + 1][i] = make_pair(i + 1, 0);\n\t\t}\n\t\t\n\t\tdp.resize(n + 2);\n\t\tfor(int i = 0; i < n + 2; ++i) {\n\t\t\tdp[i].resize(s[i].size());\n\t\t\tfor(int j = 0; j < dp[i].size(); ++j)\n\t\t\t\tdp[i][j].resize(m + 1, inf);\n\t\t}\n\t\tfor(int i = 0; i < dp[0].size(); ++i)\n\t\t\tdp[0][i][m] = 0;\n\t\t\n\t\tfor(int i = 1; i < n + 2; ++i) {\n\t\t\tfor(int j = 0; j < dp[i].size(); ++j) {\n\t\t\t\tfor(int k = 0; k < m + 1; ++k) {\n\t\t\t\t\t\n\t\t\t\t\tint &x = dp[i][j][k];\n\t\t\t\t\tint col = s[i][j].first;\n\t\t\t\t\tint score = s[i][j].second;\n\t\t\t\t\t\n\t\t\t\t\tfor(int prev = 0; prev < dp[i - 1].size(); ++prev) {\n\t\t\t\t\t\tint prevcol = s[i - 1][prev].first;\n\t\t\t\t\t\tint prevscore = s[i - 1][prev].second;\n\t\t\t\t\t\tint prevdp = dp[i - 1][prev][k];\n\t\t\t\t\t\tx = min(x, prevdp + (prevscore + score) * abs(prevcol - col));\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 2 || k == m)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int prev = 0; prev < dp[i - 2].size(); ++prev) {\n\t\t\t\t\t\tint prevcol = s[i - 2][prev].first;\n\t\t\t\t\t\tint prevscore = s[i - 2][prev].second;\n\t\t\t\t\t\tint prevdp = dp[i - 2][prev][k + 1];\n\t\t\t\t\t\tx = min(x, prevdp + (prevscore + score) * abs(prevcol - col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\t\n\t\tfor(int i = 0; i < dp[n + 1].size(); ++i) {\n\t\t\tfor(int j = 0; j < m + 1; ++j)\n\t\t\t\tans = min(ans, dp[n + 1][i][j]);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 10000000;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n//#define int long long\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m;\nint dp[155][80][1005];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<vector<pair<int, int>>> st(155);\n        rep(i, n) {\n            int k;\n            cin >> k;\n            rep(j, k) {\n                int x, d;\n                cin >> x >> d;\n                x--;\n                st[i].push_back({x, d});\n            }\n        }\n        rep(i, 155)rep(j, 80)rep(k, 1005) dp[i][j][k] = INT_MAX;\n        for (auto p : st[0]) {\n            dp[0][0][p.fi] = 0;\n        }\n        if (m != 0) {\n            for (auto p : st[1]) {\n                dp[1][1][p.fi] = 0;\n            }\n        }\n        rep(i, n)rep(j, m + 1) {\n            for (auto now : st[i]) {\n                if (dp[i][j][now.fi] == INT_MAX) continue;\n                if (i + 1 >= n) continue;\n                for (auto nx : st[i + 1]) {\n                    dp[i + 1][j][nx.fi] = min(dp[i + 1][j][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se + nx.se));\n                }\n                if (i + 2 >= n || j + 1 > m) continue;\n                for (auto nx : st[i + 2]) {\n                    dp[i + 2][j + 1][nx.fi] = min(dp[i + 2][j + 1][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se  + nx.se));\n                }\n            }\n        }\n        int ans = INT_MAX;\n        rep(j, m + 1)rep(k, 1001) ans = min(ans, dp[n - 1][j][k]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x, dang\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tif (m != 0) REP(i, stone[1].size()) dp[1][i][m - 1] = 0;\n\t\t\n\t\tREP(i, n - 1) REP(j, stone[i].size()) REP(k, m + 1) {\n\t\t\tpii &from = stone[i][j];\n\t\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2 && k > 0) {\n\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\tpii &to = stone[i + 2][l];\n\t\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\tpii &to = stone[i + 1][l];\n\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tREP(i, stone[n - 2].size()) FOR(j, 1, m + 1) ans = min(ans, dp[n - 2][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nint n, m;\nint danger[155][1010];\nvector<int> X[155];\nint dp[155][1010][80];\n\nconst int inf = 1LL << 55;\n\nint solve(int col, int row, int jump)\n{\n  if(col >= n-1) return 0;\n  if(col >= n-2 && jump < m) return 0;\n  if(jump > m) return inf;\n  if(~dp[col][row][jump]) return dp[col][row][jump];\n  int ret = inf;\n  for(int i = 0; i < X[col+1].size(); i++){\n    if(danger[col+1][X[col+1][i]] == inf) continue;\n    int D = (danger[col][row] + danger[col+1][X[col+1][i]]) * abs(row - X[col+1][i]);\n    ret = min(ret, solve(col + 1, X[col+1][i], jump) + D);\n  }\n  if(jump < m && col < n-2){\n    for(int i = 0; i < X[col+2].size(); i++){\n      if(danger[col+2][X[col+2][i]] == inf) continue;\n      int D = (danger[col][row] + danger[col+2][X[col+2][i]]) * abs(row - X[col+2][i]);\n      ret = min(ret, solve(col + 2, X[col+2][i], jump + 1) + D);\n    }\n  }\n  return dp[col][row][jump] = ret;\n}\n\nsigned main()\n{\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 155; i++) X[i].clear();\n    for(int i = 0; i < 155; i++){\n      for(int j = 0; j < 11; j++) danger[i][j] = inf;\n    }\n    for(int i = 0; i < n; i++){\n      int k; cin >> k;\n      for(int j = 0; j < k; j++){\n\tint x, d;\n\tcin >> x >> d;\n\t--x;\n\tdanger[i][x] = d;\n\tX[i].push_back(x);\n      }\n    }\n\n    memset(dp, -1, sizeof(dp));\n    int ans = inf;\n    for(int i = 0; i < X[0].size(); i++){\n      if(danger[0][X[0][i]] == inf) continue;\n      ans = min(ans, solve(0, X[0][i], 0));\n    }\n    if(m > 0 && n > 1){\n      for(int i = 0; i < X[1].size(); i++){\n\tif(danger[1][X[1][i]] == inf) continue;\n\tans = min(ans, solve(1, X[1][i], 1));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct stone {\n\tint x;\n\tint y;\n\tint slip;\n};\nstruct Edge {\n\tint to;\n\tint time;\n};\nstruct aa {\n\tint now;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<stone>stos;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint k; cin >> k;\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint x, s; cin >> x >> s;\n\t\t\t\tx--;\n\t\t\t\tstos.push_back(stone{ x,i+1,s });\n\t\t\t}\n\t\t}\n\t\tvector<vector<Edge>>es(stos.size()*(M+1) + 2);\n\t\tfor (int i = 0; i < stos.size(); ++i) {\n\t\t\tfor (int j = 0; j <stos.size(); ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tfor (int m = 0; m <= M; ++m) {\n\t\t\t\t\tstone si = stos[i];\n\t\t\t\t\tint iid = i*(M + 1) + m;\n\t\t\t\t\tstone sj = stos[j];\n\t\t\t\t\tint jid = j*(M + 1) + m;\n\t\t\t\t\tif (si.y + 1 == sj.y) {\n\t\t\t\t\t\tes[iid].push_back(Edge{ jid,abs(si.x - sj.x)*(si.slip + sj.slip) });\n\t\t\t\t\t}\n\t\t\t\t\telse if (si.y + 2 == sj.y&&m!=M) {\n\t\t\t\t\t\tes[iid].push_back(Edge{ int(jid+1),abs(si.x - sj.x)*(si.slip + sj.slip) });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst int start = stos.size()*(M + 1);\n\t\tconst int goal = start + 1;\n\t\tfor (int i = 0; i < stos.size(); ++i) {\n\t\t\tstone s(stos[i]);\n\t\t\tfor (int m = 0; m < M; ++m) {\n\t\t\t\tconst int nid = i*(M+1)+ m;\n\t\t\t\tes[nid].push_back(Edge{ nid+ 1,0 });\n\t\t\t\tif (s.y == 2) {\n\t\t\t\t\tes[start].push_back(Edge{ int(nid+ 1), 0});\n\t\t\t\t}\n\t\t\t\tif (s.y == N - 1) {\n\t\t\t\t\tes[nid].push_back(Edge{ goal,0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = 0; m <= M; ++m) {\n\t\t\t\tconst int nid = i*(M + 1) + m;\n\t\t\t\tif (s.y == 1) {\n\t\t\t\t\tes[start].push_back(Edge{ nid, 0 });\n\t\t\t\t}\n\t\t\t\tif (s.y == N) {\n\t\t\t\t\tes[nid].push_back(Edge{ goal,0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tpriority_queue < aa, vector<aa>, Compare > que;\n\t\tque.push(aa{ start,0 });\n\t\tvector<long long int>memo(es.size(), 1e18);\n\t\tmemo[start] = 0;\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (atop.now == goal) {\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (auto e : es[atop.now]) {\n\t\t\t\tconst int nexttime = atop.time + e.time;\n\t\t\t\tif (memo[e.to] > nexttime) {\n\t\t\t\t\tmemo[e.to] = nexttime;\n\t\t\t\t\tque.push(aa{ e.to,nexttime });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[150][10][76];\nint sec[150][10];\nint val[150][10];\nint size[150];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d\",size+i);\n\t\t\tfor(int j=0;j<size[i];j++){\n\t\t\t\tscanf(\"%d%d\",&sec[i][j],&val[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<10;i++)\n\t\t\tfor(int j=0;j<75;j++)\n\t\t\t\tdp[0][i][j]=99999999;\n\t\tfor(int i=0;i<size[0];i++){\n\t\t\tdp[0][i][b]=0;\n\t\t}\n\t\tfor(int i=0;i<size[1];i++){\n\t\t\tdp[1][i][b-1]=0;\n\t\t}\n\t\tfor(int i=1;i<a;i++){\n\t\t\tfor(int j=0;j<size[i];j++){\n\t\t\t\tint Min=1000000000;\n\t\t\t\tfor(int k=0;k<size[i-1];k++){\n\t\t\t\t\tMin=min(Min,dp[i-1][k][b]+(val[i][j]+val[i-1][k])*abs(sec[i][j]-sec[i-1][k]));\n\t\t\t\t}\n\t\t\t\tdp[i][j][b]=Min;\n\t\t\t}\n\t\t\tif(i>1)\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tfor(int k=0;k<size[i];k++){\n\t\t\t\t\tint Min=1000000000;\n\t\t\t\t\tfor(int l=0;l<size[i-1];l++){\n\t\t\t\t\t\tMin=min(Min,dp[i-1][l][j]+(val[i][k]+val[i-1][l])*abs(sec[i][k]-sec[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l=0;l<size[i-2];l++){\n\t\t\t\t\t\tMin=min(Min,dp[i-2][l][j+1]+(val[i][k]+val[i-2][l])*abs(sec[i][k]-sec[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][k][j]=Min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=1000000000;\n\t\tfor(int i=0;i<size[a-1];i++){\n\t\t\tfor(int j=0;j<b+1;j++){\n\t\t\t\tret=min(ret,dp[a-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<size[a-2];i++){\n\t\t\tfor(int j=1;j<b+1;j++){\n\t\t\t\tret=min(ret,dp[a-2][i][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\n#define min3(i,j,k) min(min((i),(j)),(k))\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(void){\n    int n,m,k,a,b;\n    int dp[150][10][76];\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tvector< vector<pii> > s(n,vector<pii>(0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\ts[i].push_back(pii(a,b));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=m;i++)for(int j=0;j<10;j++)dp[0][j][i]=0;\n\t\tfor(int i=0;i<=m;i++)for(int j=0;j<10;j++)for(int l=1;l<n;l++)dp[l][j][i]=9999999;\n\t\tfor(int i=0;i<=m;i++){\n\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\tint l=s[j].size();\n\t\t\t\tint lb=s[j-1].size();\n\t\t\t\tfor(int w=0;w<l;w++){\n\n\t\t\t\t\tif(i>0 && j>1){\n\t\t\t\t\t\tlb = s[j-2].size();\n\t\t\t\t\t\tfor(int c=0;c<lb;c++){\n\t\t\t\t\t\t\tdp[j][w][i] = min3(dp[j][w][i],\n                                dp[j-1][c][i]+abs(s[j][w].first-s[j-1][c].first)*(s[j][w].second+s[j-1][c].second),\n\t\t\t\t\t\t\t\tdp[j-2][c][i]+abs(s[j][w].first-s[j-2][c].first)*(s[j][w].second+s[j-2][c].second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t    for(int c=0;c<lb;c++){\n                            dp[j][w][i] = min(dp[j][w][i],\n                                dp[j-1][c][i]+abs(s[j][w].first-s[j-1][c].first)*(s[j][w].second+s[j-1][c].second));\n\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 9999999;\n\t\tfor(int i=0;i<s[n-1].size();i++){\n\t\t    ans=min(ans,dp[n-1][i][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int iinf = 1<<28;\nconst int inf = -1;\nconst int H = 151;\nconst int W = 1001;\nconst int M = 76;\nshort D[H][W];\nint dp[H][W][M];\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                D[i][j] = inf;\n                for ( int k = 0; k < M; ++ k ) {\n                    dp[i][j][k] = iinf;\n                }\n            }\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int x, d;\n                cin >> x >> d;\n                -- x;\n                D[n-i-1][x] = d;\n            }\n        }\n        for ( int i = 0; i < 1001; ++ i ) {\n            if ( D[n-1][i] != inf ) dp[n - 1][i][0] = 0;\n        }\n        for ( int i = n-1; i > 0; -- i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                if ( D[i][j] == inf ) continue;\n                for ( int k = 0; k < W; ++ k ) {\n                    if ( i-2 >= 0 && D[i-2][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            if ( D[i-2][k] != inf && D[i][j] != inf )\n                                dp[i-2][k][l+1] = min( dp[i-2][k][l+1], dp[i][j][l]+(D[i-2][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                    if ( i-1 >= 0 && D[i-1][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            if ( D[i-1][k] != inf && D[i][j] != inf )\n                                dp[i-1][k][l] = min( dp[i-1][k][l], dp[i][j][l]+(D[i-1][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                }\n            }\n        }\n        int answer = iinf;\n        for ( int i = 0; i < W; ++ i ) {\n            for ( int j = 0; j <= m; ++ j ) {\n                if ( dp[0][i][j] != inf )\n                    answer = min( answer, dp[0][i][j] );\n            }\n            for ( int j = 0; j < m; ++ j ) {\n                if ( dp[1][i][j] != inf )\n                    answer = min( answer, dp[1][i][j] );\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint n,m;\nll d[76][151][1001];\n\nint main(){\n    while(true){\n\tcin >> n >> m;\n\tif(n == 0 && m == 0) break;\n\tmemset(d,-1,sizeof(d));\n\tqueue< pair<int,int> > qxy;\n\tqueue<int> qm;\n\tqueue<int> qs;\n\tvector< vector< pair<int,int> > > coor(n);\n\tll ans = 1000000000000000;\n\tREP(i,n){\n\t    int k;\n\t    cin >> k;\n\t    REP(j,k){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcoor[i].PB( pair<int,int>(a,b));\n\t\tif(i==0){\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m);\n\t\t    qs.push(b);\n\t\t    d[m][i][a] = 0;\n\t\t}else if(i == 1){\n\t\t    if(m == 0) continue;\n\t\t    qxy.push( pair<int,int>(a,i));\n\t\t    qm.push(m-1);\n\t\t    qs.push(b);\n\t\t    d[m-1][i][a] = 0;\n\t\t}\n\t    }\n\t}\n\n\twhile(!qxy.empty()){\n\t    int x = qxy.front().first;\n\t    int y = qxy.front().second;\n\t    int tm = qm.front();\n\t    int ts = qs.front();\n\t    qxy.pop();\n\t    qm.pop();\n\t    qs.pop();\n\t    if(y+1 >= n || (tm > 0 && y+2 >= n)){\n\t\tans = min(ans,d[tm][y][x]);\n\t\tcontinue;\n\t    }\n\t    REP(i,coor[y+1].size()){\n\t\tint nx = coor[y+1][i].first;\n\t\tint ny = y+1;\n\t\tint slip = coor[y+1][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(d[tm][ny][nx] < 0 || d[tm][ny][nx] > v){\n\t\t    d[tm][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t    if(y+2 >= n) continue;\n\t    REP(i,coor[y+2].size()){\n\t\tint nx = coor[y+2][i].first;\n\t\tint ny = y+2;\n\t\tint slip = coor[y+2][i].second;\n\t\tint v = d[tm][y][x] + (slip + ts)*abs(nx-x);\n\t\tif(tm>0 && (d[tm-1][ny][nx] < 0 || d[tm-1][ny][nx] > v )){\n\t\t    d[tm-1][ny][nx] = v;\n\t\t    qxy.push(pair<int,int>(nx,ny));\n\t\t    qm.push(tm-1);\n\t\t    qs.push(slip);\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[150][10][76];\nint sec[150][10];\nint val[150][10];\nint size[150];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d\",size+i);\n\t\t\tfor(int j=0;j<size[i];j++){\n\t\t\t\tscanf(\"%d%d\",&sec[i][j],&val[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<10;i++)\n\t\t\tfor(int j=0;j<75;j++)\n\t\t\t\tdp[0][i][j]=99999999;\n\t\tfor(int i=0;i<size[0];i++){\n\t\t\tdp[0][i][b]=0;\n\t\t}\n\t\tfor(int i=0;i<size[1];i++){\n\t\t\tdp[1][i][b-1]=0;\n\t\t}\n\t\tfor(int i=1;i<a;i++){\n\t\t\tfor(int j=0;j<size[i];j++){\n\t\t\t\tint Min=99999999;\n\t\t\t\tfor(int k=0;k<size[i-1];k++){\n\t\t\t\t\tMin=min(Min,dp[i-1][k][b]+(val[i][j]+val[i-1][k])*abs(sec[i][j]-sec[i-1][k]));\n\t\t\t\t}\n\t\t\t\tdp[i][j][b]=Min;\n\t\t\t}\n\t\t\tif(i>1)\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tfor(int k=0;k<size[i];k++){\n\t\t\t\t\tint Min=99999999;\n\t\t\t\t\tfor(int l=0;l<size[i-1];l++){\n\t\t\t\t\t\tMin=min(Min,dp[i-1][l][j]+(val[i][k]+val[i-1][l])*abs(sec[i][k]-sec[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l=0;l<size[i-2];l++){\n\t\t\t\t\t\tMin=min(Min,dp[i-2][l][j+1]+(val[i][k]+val[i-2][l])*abs(sec[i][k]-sec[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][k][j]=Min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=99999999;\n\t\tfor(int i=0;i<size[a-1];i++){\n\t\t\tfor(int j=0;j<b+1;j++){\n\t\t\t\tret=min(ret,dp[a-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<size[a-2];i++){\n\t\t\tfor(int j=1;j<b+1;j++){\n\t\t\t\tret=min(ret,dp[a-2][i][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, c[155], p[155][15], v[155][15], dp[155][15][79];\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t\tfor (int j = 0; j < c[i]; j++) scanf(\"%d%d\", &p[i][j], &v[i][j]);\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < c[i]; j++) {\n\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\tdp[i][j][k] = 999999999;\n\t\t\t\t\tfor (int l = 0; l < c[i - 1]; l++) {\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + abs(p[i][j] - p[i - 1][l]) * (v[i][j] + v[i - 1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif (k == 0 || i == 1) continue;\n\t\t\t\t\tfor (int l = 0; l < c[i - 2]; l++) {\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i - 2][l][k - 1] + abs(p[i][j] - p[i - 2][l]) * (v[i][j] + v[i - 2][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 999999999;\n\t\tfor (int i = 0; i < c[n - 1]; i++) ret = min(ret, dp[n - 1][i][m]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n//番号とx座標と滑りやすさ\nvector<P1>s[155];\n//滑りやすさ、x座標、y座標\nP1 d[1505];\nint n,m;\n//石番号と残り数を状態にもつdijkstra用配列\nint di[1505][76];\n//beatmania iidx楽しい!!の部分文字列ではなくindexの部分文字列\nint idx=0;\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\n\t\t\ts[i].pb(mp(idx,mp(a,b)));\n\t\t\td[idx++]=mp(b,mp(a,i));\n\t\t}\n\t}\n\tfor(int i=0;i<1505;i++)for(int j=0;j<76;j++) di[i][j]=1e9;\n\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\tfor(int i=0;i<s[1].size();i++)\n\t{\n\t\tP1 p=s[1][i];\n\t\tdi[p.first][m]=0;\n\t\tque.push(mp(0,mp(p.first,m)));\n\t}\n\tfor(int i=0;m>0 && i<s[2].size();i++)\n\t{\n\t\tP1 p=s[2][i];\n\t\tdi[p.first][m-1]=0;\n\t\tque.push(mp(0,mp(p.first,m-1)));\n\t}\n\twhile(!que.empty())\n\t{\n\t\tP1 p=que.top();\n\t\tque.pop();\n\t\tint idd=p.second.first;\n\t\tint slip1=d[idd].first;\n\t\tint x=d[idd].second.first;\n\t\tint y=d[idd].second.second;\n\t\tint zan=p.second.second;\n\t\t\n\t\tfor(int i=0;i<s[y+1].size();i++)\n\t\t{\n\t\t\tP1 p=s[y+1][i];\n\t\t\tint slip2=p.second.second;\n\t\t\tint x2=p.second.first;\n\t\t\tif(di[p.first][zan]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[p.first][zan]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[p.first][zan],mp(p.first,zan)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;zan>0 && <s[y+2].size();i++)\n\t\t{\n\t\t\tP1 p=s[y+2][i];\n\t\t\tint slip2=p.second.second;\n\t\t\tint x2=p.second.first;\n\t\t\tif(di[p.first][zan]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[p.first][zan]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[p.first][zan],mp(p.first,zan)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ret=INF;\n\tfor(int j=0;j<s[n].size();j++) for(int i=0;i<76;i++) ret=min(ret,di[s[n][j].first][i]);\n\tfor(int j=0;j<s[n-1].size();j++) for(int i=1;i<76;i++) ret=min(ret,di[s[n-1][j].first][i]);\n\t\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n\n#define ft first\n#define sd second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 99999;\nint n, m;\nmap<int, vector<P> > mpp;\n\nint solve()\n{\n  int res = inf, dp[152][152][80];\n  vector<P> v1, v2;\n \n  for(int i = 0; i <= m; i++)\n    for(int j = 0; j <= n; j++)\n      for(int k = 0; k <= n; k++)\n\tdp[j][k][i] = inf;\n\n  v1 = mpp[1];\n  for(int i = 0; i < v1.size(); i++)\n    dp[1][v1[i].ft][m] = 0;\n\n\n  for(int i = 1; i < n; i++){\n    v1 = mpp[i];\n    v2 = mpp[i+1];\n    for(int j = m; j >= 0; j--)\n      for(int k = 0; k < v1.size(); k++)\n\tfor(int l = 0; l < v2.size(); l++)\n\t  dp[i+1][v2[l].ft][j]=min(dp[i+1][v2[l].ft][j],dp[i][v1[k].ft][j]+(v1[k].sd+v2[l].sd)*((int)fabs((double)(v1[k].ft-v2[l].ft))));\n\n    if(i < n-1){\n      v2 = mpp[i+2];\n      for(int j = m; j > 0; j--)\n\tfor(int k = 0; k < v1.size(); k++)\n\t  for(int l = 0; l < v2.size(); l++)\n\t    dp[i+2][v2[l].ft][j-1]=min(dp[i+2][v2[l].ft][j-1],dp[i][v1[k].ft][j]+(v1[k].sd+v2[l].sd)*((int)fabs((double)(v1[k].ft-v2[l].ft))));\n    }\n  }\n  /*\n  for(int i = n; i > 0; i--){\n    for(int j = 1; j <= n; j++){\n      int t = inf;\n      for(int k = 0; k <= m; k++)\n\tt = min(t, dp[i][j][k]);\n      if(t == inf) cout << \" - \";\n      else cout << \" \" << t << \" \";\n    }\n    cout << endl;\n  }\n  */\n  for(int i = 0; i <= n; i++)\n    for(int j = 0; j <= m; j++)\n      res = min(res, dp[n][i][j]);\n\n  return res;\n}\n\nint main()\n{\n  int s, t, u;\n  while(cin>>n>>m && (n+m)){\n    for(int i = 1; i <= n; i++){\n      cin >> u;\n      vector<P> vec;\n      while(u--){\n\tcin >> s >> t;\n\tvec.push_back(P(s, t));\n      }\n      mpp[i] = vec;\n    }\n\n    cout << solve() << endl;\n    mpp.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n//#define int long long\n#define addm(X, Y) ((X) = ((X) + (Y) % mod) % mod)\n\nint n, m;\nint dp[155][80][1005];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<vector<pair<int, int>>> st(155);\n        rep(i, n) {\n            int k;\n            cin >> k;\n            rep(j, k) {\n                int x, d;\n                cin >> x >> d;\n                x--;\n                st[i].push_back({x, d});\n            }\n        }\n        rep(i, 155)rep(j, 80)rep(k, 1005) dp[i][j][k] = INT_MAX;\n        for (auto p : st[0]) {\n            dp[0][0][p.fi] = 0;\n        }\n        if (m != 0) {\n            for (auto p : st[1]) {\n                dp[1][1][p.fi] = 0;\n            }\n        }\n        rep(i, n)rep(j, m + 1) {\n            for (auto now : st[i]) {\n                if (dp[i][j][now.fi] == INT_MAX) continue;\n                if (i + 1 >= n) continue;\n                for (auto nx : st[i + 1]) {\n                    dp[i + 1][j][nx.fi] = min(dp[i + 1][j][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se + nx.se));\n                }\n                if (i + 2 >= n || j + 1 > m) continue;\n                for (auto nx : st[i + 2]) {\n                    dp[i + 2][j + 1][nx.fi] = min(dp[i + 2][j + 1][nx.fi], dp[i][j][now.fi] + abs(now.fi - nx.fi) * (now.se  + nx.se));\n                }\n            }\n        }\n        int ans = INT_MAX   ;\n        rep(j, m + 1)rep(k, 1001) ans = min(ans, dp[n - 1][j][k]);\n        rep(j, m)rep(k, 1001) ans = min(ans, dp[n - 2][j][k]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  vector<int> id[150];\n  bool use[1500];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    int num = 0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tif(i==n-1)use[num] = true;\n\telse use[num] = false;\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = 1<<30;\n\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    for(int i=0;i<(int)id[1].size();i++)q.push(P2(P1(0,id[1][i]),1));\n\n    int ans;\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n      if(use[idx]){\n\tans = risk;\n\tbreak;\n      }\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int n, m;\n  while(cin>>n>>m && n){\n    static int dp[151][1001][80] = {};\n    REP(i, 151)REP(j, 1001)REP(k, 80) dp[i][j][k] = INF;\n    int k[151], x[150][151], s[151][151];\n    REP(i, n){\n      cin>>k[i];\n      REP(j, k[i]) cin>>x[i][j]>>s[i][j];\n    }\n    REP(i, k[0]) dp[0][x[0][i]][0] = 0;\n    for(int i = 0; i < n - 1; i++){\n      for(int j = 0; j < k[i]; j++){\n        int from_x = x[i][j];\n        for(int l = 0; l < k[i + 1]; l++){\n          int to_x = x[i + 1][l];\n          for(int use = 0; use <= m; use++){\n            dp[i + 1][to_x][use] = min(dp[i + 1][to_x][use], dp[i][from_x][use] + (s[i][j] + s[i + 1][l]) * abs(from_x - to_x));\n          }\n        }\n        if(i + 2 < n){\n          for(int l = 0; l < k[i + 2]; l++){\n            int to_x = x[i + 2][l];\n            for(int use = 0; use < m; use++){\n              dp[i + 2][to_x][use + 1] = min(dp[i + 2][to_x][use + 1], dp[i][from_x][use] + (s[i][j] + s[i + 2][l]) * abs(from_x - to_x));\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(i, k[n - 1])REP(j, m + 1) ans = min(ans, dp[n-1][x[n-1][i]][j]);\n    REP(i, k[n - 2])REP(j, m ) ans = min(ans, dp[n-2][x[n-2][i]][j]);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 50000000000;\n\nint n, m;\nint K[152], x[152][10], d[152][10];\nlong long dp[152][10];\n\nvoid init()\n{\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 151; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tmemset(K, 0, sizeof(K));\n\tK[0] = 1;\n\tK[n + 1] = 1;\n\tmemset(x, 0, sizeof(x));\n\tmemset(d, 0, sizeof(d));\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &K[i]);\n\t\t\t\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tscanf(\"%d %d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (m--){\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\t\tfor (int k = 0; k < K[i + 2]; k++){\n\t\t\t\t\t\tif (i == 0 || i == n - 1) dp[i + 2][k] = min(dp[i + 2][k], dp[i][j]);\n\t\t\t\t\t\telse dp[i + 2][k] = min(dp[i + 2][k], dp[i][j] + (d[i][j] + d[i + 2][k]) * abs(x[i][j] - x[i + 2][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= n; i++){\n\t\t\tfor (int j = 0; j < K[i]; j++){\n\t\t\t\tfor (int k = 0; k < K[i + 1]; k++){\n\t\t\t\t\tif (i == 0 || i == n) dp[i + 1][k] = min(dp[i + 1][k], dp[i][j]);\n\t\t\t\t\telse dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (d[i][j] + d[i + 1][k]) * abs(x[i][j] - x[i + 1][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", dp[n + 1][0]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  /*\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint n,m;\nint a,b;\nint fie[210][4];\t// 行、マス\nint dp[210][210][4];// x回目１こ飛ばし、行、マス\n\nvoid calc(int u)\n{\n\tu *= 2;\n\tu++;\n\tfor(int i = u-1; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\t\t// 現在の立ち位置\n\t\t\tfor(int k = 0; k < 4; k++){\t// 次の場所\n\t\t\t\tfor(int add = 0; add <= 1; add++){\n\t\t\t\t\tif(add+(u/2) > m)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(fie[i][j] >= 0 && fie[i+1+add][k] >= 0){\n\t\t\t\t\t\tint nowRisk = (fie[i][j] + fie[i+1+add][k])*abs(j-k)+dp[u/2][i][j];\n\t\t\t\t\t\tif(dp[u/2][i][j] == -1)\n\t\t\t\t\t\t\tnowRisk += 1;\n\n//\t\t\t\t\t\tcout << nowRisk << endl ;\n\t\t\t\t\t\tif(dp[u/2+add][i+1+add][k] >= 0)\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = min(dp[u/2+add][i+1+add][k], nowRisk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = nowRisk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid solve()\n{\n\tint ans = (1 << 25);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tcin >> fie[i][b];\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i <= m; i++){\n\t\tcalc(i);\n\t\t\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif(dp[i][n+1][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+1][j]);\n\t\t\tif(dp[i][n+2][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+2][j]);\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcout << dp[0][i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tcout << ans << endl;\n\n\n\t\n}\n\nint main(void)\n{\n\n\twhile(cin >> n >> m, n | m){\n\t\tfill(fie[1], fie[1]+(200-1)*4, -1);\n\t\tfill(dp[0][0], dp[0][0] + 200*200*4, -1);\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfie[n+1][i] = 0;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint n,m;\nint a,b;\nint fie[210][4];\t// 行、マス\nint dp[210][210][4];// x回目１こ飛ばし、行、マス\n\nvoid calc(int u)\n{\n\tu *= 2;\n\tu++;\n\tfor(int i = u-1; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\t\t// 現在の立ち位置\n\t\t\tfor(int k = 0; k < 4; k++){\t// 次の場所\n\t\t\t\tfor(int add = 0; add <= 1; add++){\n\t\t\t\t\tif(add+((u/2) > m)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(fie[i][j] >= 0 && fie[i+1+add][k] >= 0){\n\t\t\t\t\t\tint nowRisk = (fie[i][j] + fie[i+1+add][k])*abs(j-k)+dp[u/2][i][j];\n\t\t\t\t\t\tif(dp[u/2][i][j] == -1)\n\t\t\t\t\t\t\tnowRisk += 1;\n\n//\t\t\t\t\t\tcout << nowRisk << endl ;\n\t\t\t\t\t\tif(dp[u/2+add][i+1+add][k] >= 0)\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = min(dp[u/2+add][i+1+add][k], nowRisk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = nowRisk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid solve()\n{\n\tint ans = (1 << 25);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tcin >> fie[i][b];\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i <= m; i++){\n\t\tcalc(i);\n\t\t\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif(dp[i][n+1][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+1][j]);\n\t\t\tif(dp[i][n+2][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+2][j]);\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcout << dp[0][i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tcout << ans << endl;\n\n\n\t\n}\n\nint main(void)\n{\n\n\twhile(cin >> n >> m, n | m){\n\t\tfill(fie[1], fie[1]+(200-1)*4, -1);\n\t\tfill(dp[0][0], dp[0][0] + 200*200*4, -1);\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfie[n+1][i] = 0;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\n#define INF (1<<30)\nint suberi(PA a,PA b){\n  return(a.second+b.second);\n}\nint yoko(PA a,PA b){\n  return(abs(a.first-b.first));\n}\nint dp[151][10][80];\nint main(){\n  int n,m,k,x,d;\n  while(scanf(\"%d %d\",&n,&m),n!=0||m!=0){\n    vector<PA> vec[151];\n    fill_n(**dp,151*10*80,INF);\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x,&d);\n\tvec[i].push_back(PA(x,d));\n\tif(i == 0) dp[0][j][0] = 0;\n\tif(i == 1) dp[1][j][1] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<vec[i].size();j++){\n\tfor(int l=0;l<=m;l++){\n\t  for(int z=0;z<vec[i+1].size();z++){\n\t    dp[i+1][z][l] = min(dp[i+1][z][l],suberi(vec[i][j],vec[i+1][z]) * yoko(vec[i][j],vec[i+1][z]) + dp[i][j][l]);\n\t  }\n\t  if(l == m || i == n-2) continue;\n\t  for(int z=0;l<=m,z<vec[i+2].size();z++){\n\t    dp[i+2][z][l+1] = min(dp[i+2][z][l+1],suberi(vec[i][j],vec[i+2][z]) * yoko(vec[i][j],vec[i+2][z]) + dp[i][j][l]);\n\t  }\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i=n-2;i<n;i++){\n      for(int j=0;j<vec[i].size();j++){\n\tfor(int l=0;l<=m;l++){\n\t  if(i!=n-2||l!=m) ans = min(ans,dp[i][j][l]);\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <vector>\ntypedef long long int ll;\n#define FOR(i, a, b) for (ll i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n - 1); i >= 0; --i)\n#define mod 1000000007\n#define INF 93193111451418101\n#define MIN -933111451418101\nusing namespace std;\ntypedef pair<ll, ll> P;\n\ntemplate <typename T, typename U>\ntypename std::enable_if<std::rank<T>::value == 0>::type fill_all(T &arr,\n\tconst U &v) {\n\tarr = v;\n}\ntemplate <typename ARR, typename U>\ntypename std::enable_if<std::rank<ARR>::value != 0>::type fill_all(ARR &arr,\n\tconst U &v) {\n\tfor (auto &i : arr) {\n\t\tfill_all(i, v);\n\t}\n}\n//------------------??????°-----------------------//\nll n, m;\nstd::vector<P> rock[1000];\nll dp[155][100][30]; // n???????????¨??°???????????°?????´???\n\t\t\t\t\t //-------------------???¢???°----------------------//\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n) {\n\t\tll k;\n\t\tcin >> k;\n\t\tREP(j, k) {\n\t\t\tll place, sliplevel;\n\t\t\tcin >> place >> sliplevel;\n\t\t\trock[i + 1].push_back(P(place, sliplevel));\n\t\t}\n\t}\n\trock[0].push_back(P(0, 0));\n\trock[n + 1].push_back(P(0, 0));\n\tfill_all(dp, INF);\n\tdp[0][0][0] = 0;\n\tREP(i, n + 1) { // 0???????????????n+1????????????\n\t\tREP(j, m+1) {   //????????¨??°?????????\n\t\t\tREP(k, (unsigned)rock[i].size()) {\n\t\t\t\tif (dp[i][j][k] == INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (i == 0 || i == n) {\n\t\t\t\t\tREP(l, (unsigned)rock[i + 1].size()) {\n\t\t\t\t\t\tdp[i + 1][j][l] = min(dp[i + 1][j][l], dp[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif (j < m ) {\n\t\t\t\t\t\tREP(l, (unsigned)rock[i + 2].size()) {\n\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tREP(l, (unsigned)rock[i + 1].size()) {\n\t\t\t\t\t\tdp[i + 1][j][l] =\n\t\t\t\t\t\t\tmin(dp[i + 1][j][l],\n\t\t\t\t\t\t\t\tdp[i][j][k] +\n\t\t\t\t\t\t\t\t(rock[i + 1][l].second + rock[i][k].second) *\n\t\t\t\t\t\t\t\t(abs(rock[i + 1][l].first - rock[i][k].first)));\n\t\t\t\t\t}\n\t\t\t\t\tif (j < m ) {\n\t\t\t\t\t\tREP(l, (unsigned)rock[i + 2].size()) {\n\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k] + (rock[i + 2][l].second + rock[i][k].second) *(abs(rock[i + 2][l].first - rock[i][k].first)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = INF;\n\tREP(j, m + 1) {\n\t\tans = min(ans, dp[n + 1][j][0]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\n\nvoid solve(void){\nint dp[1005][101];\n\n for(int i=0;i<1005;i++)\n   for(int j=0;j<=m;j++)\n     dp[i][j]=INF;\n\n   dp[0][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n\tedge e=G[i][j];\n\tfor(int k=0;k<=m;k++){\n\t  if(i+1==e.to)dp[i+1][k]=min(dp[i+1][k],dp[i][k]+e.cost);\n\t  if(i+2==e.to && k!=0)dp[i+2][m-k]=min(dp[i+2][m-k],dp[i][m-k+1]+e.cost);\n\t}\n    }\n  }\n  int ans=INF;\n  for(int j=0;j<=m;j++)\n    ans=min(ans,dp[n+1][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0){\n\t      if(graph[i+1][l]>0){\n\t\te.to=i+1;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      \n\t      if(graph[i+2][l]>0){\n\t\te.to=i+2;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+1==n+1){\n\t      e.to=i+1;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+2==n+1){\n\t      e.to=i+2;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t  }\n\t}\n      }\n    }\n    //solve();\n    cout << dijkstra(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < stones[i].size(); ++j) {\n                q.push(Tag(i, j, 0, M-i));\n            }\n        }\n\n        vector<vector<vector<unsigned> > > dp(M+1, vector<vector<unsigned> >(N, vector<unsigned>(1000, UINT_MAX)));\n        unsigned ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m <= 0 && i == 2) break;\n                int y = t.y+i;\n                int nm = t.m-i+1;\n                for(int j = 0; j < stones[y].size(); ++j) {\n                    int cost = t.c + (stones[t.y][t.x].second+stones[y][j].second)*abs(stones[t.y][t.x].first-stones[y][j].first);\n                    if(cost >= dp[nm][y][j]) continue;\n                    dp[nm][y][j] = cost;\n                    q.push(Tag(y, j, cost, nm));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\n\n\nint mins(int a,int b){\n  if(a==-1)return b;\n  if(b==-1)return a;\n  else return (a>b)?b:a;\n}\nint main(void){\n  int m,n;\n  scanf(\"%d%d\",&n,&m);\n  while(n!=0){\n\n    int dkmp[150][10][77];//動計(メモ再)用。\n    int maps[150][10][2];//盤面用。\n    //memset(maps,-1,sizeof(maps));\n    memset(dkmp,-1,sizeof(dkmp));\n    memset(maps,-1,sizeof(maps));\n    int i=0;\n    int j=0;\n    int xm;\n    for(i=0;i<n;i++){\n      scanf(\"%d\",&xm);\n      for(j=0;j<xm;j++){\n\tscanf(\"%d%d\",&(maps[i][j][0]),&(maps[i][j][1]));\n      }\n    }\n    //maps[i][j]には、岸からi+1つめの石で、j列にある石のあれ。\n    //maps[n][x]は、向こう岸。だった。\n    //maps[i][j][0]には、岸からi+1つめの石のある列。\n    //maps[i][j][1]には、岸からi+1つめの石のあるすべ。\n    for(j=0;j<10;j++){\n      if(maps[0][j][0]!=-1){\n\tdkmp[0][j][m]=0;\n      }\n      if(maps[1][j][0]!=-1 && m!=0){\n\tdkmp[1][j][m-1]=0;\n      }\n    }\n    int mema,memb,memc,memd,meme,memf;\n    for(j=0;j<10;j++){\n      if(maps[1][j][0]==-1)break;\n      mema=-1;\n      memd=maps[1][j][0];//行\n      meme=maps[1][j][1];//滑りやすさ    \n      for(i=0;i<10;i++){\n\tif(dkmp[0][i][m]!=-1){\n\t  memb=0;//=dkmp[0][p][m];累積\n\t  memc=maps[0][i][0];//行\n\t  memf=maps[0][i][1];//滑りやすさ\n\t  mema=mins(mema,abs(memd-memc)*(meme+memf)+memb);\n\t}\n\telse break;\n      }\n      dkmp[1][j][m]=mema;\n    }\n\n\n    //ここから動計部\n    //maps[i][j][m]には、i個目のj\n    int k=0,p=0;\n    for(i=2;i<n;i++){//岸からi個目の石\n      for(j=0;j<10;j++){//j番目の石\n\tif(maps[i][j][0]==-1)break;\n\telse{//石がそこにあれば\n\t  memd=maps[i][j][0];//行\n\t  meme=maps[i][j][1];//滑りやすさ    \n\t  for(k=0;k<=m;k++){//残りk回飛べるとき。\n\t    mema=-1;\n\t    for(p=0;p<10;p++){//石pから飛んできたとする。\n\t      if(dkmp[i-1][p][k]!=-1){\n\t\tmemb=dkmp[i-1][p][k];//累積\n\t\tmemc=maps[i-1][p][0];//行\n\t\tmemf=maps[i-1][p][1];//滑りやすさ\n\t\tmema=mins(mema,abs(memd-memc)*(meme+memf)+memb);\n\t      }\n\t      else break;\n\t    }\n\t    if(k<m){\n\t      for(p=0;p<10;p++){//石pから飛んできたとする。\n\t\tif(dkmp[i-2][p][k+1]!=-1){\n\t\t  memb=dkmp[i-2][p][k+1];//累積\n\t\t  memc=maps[i-2][p][0];//行\n\t\t  memf=maps[i-2][p][1];//滑りやす\n\t\t  mema=mins(mema,abs(memd-memc)*(meme+memf)+memb);\n\t\t}\n\t\telse break;\n\t      }\n\t    }\n\t    dkmp[i][j][k]=mema;\n\t  }\n\t}\n      }\n    }\n\n    printf(\"%d\\x0020%d\\n\",m,dkmp[n-1][0][0]);\n    int ans=-1;\n    for(i=0;i<10;i++){\n      if(maps[n-1][i][0]==-1)break;\n      for(j=0;j<=m;j++){\n\tans=mins(ans,dkmp[n-1][i][j]);\n\t//printf(\"%d\\n\",dkmp[n-1][i][j]);\n      }\n    }\n    for(i=0;i<10;i++){\n      if(maps[n-2][i][0]==-1)break;\n      for(j=1;j<=m;j++){\n\tans=mins(ans,dkmp[n-2][i][j]);\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n    scanf(\"%d%d\",&n,&m);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint dp[150][10][80]; //[i][j][k] i???????????§??§(i???,j??????)????????§?????????k????????£????????§????????¨??????????°????\nvector<pii> stone[150]; // x[0-indexed], suberi\nint n, m;\n\nint main() {\n\twhile (cin >> n >> m, n || m) {\n\t\tfill(dp[0][0], dp[n][0], INF);\n\t\tREP(i, n) stone[i].clear();\n\t\t\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tREP(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tstone[i].push_back(pii(a, b));\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, stone[0].size()) dp[0][i][m] = 0;\n\t\tif (m != 0) REP(i, stone[1].size()) dp[1][i][m - 1] = 0;\n\t\t\n\t\tREP(i, n - 1) REP(j, stone[i].size()) REP(k, m + 1) {\n\t\t\tpii &from = stone[i][j];\n\t\t\t\n\t\t\t// 1????£???°???\n\t\t\tif (i < n - 2 && k > 0) {\n\t\t\t\tREP(l, stone[i + 2].size()) {\n\t\t\t\t\tpii &to = stone[i + 2][l];\n\t\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\t\tdp[i + 2][l][k - 1] = min(dp[i + 2][l][k - 1], dp[i][j][k] + cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(l, stone[i + 1].size()) {\n\t\t\t\tpii &to = stone[i + 1][l];\n\t\t\t\tint cost = (from.second + to.second) * abs(from.first - to.first);\n\t\t\t\tdp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + cost);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tREP(i, stone[n - 1].size()) REP(j, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tREP(i, stone[n - 2].size()) FOR(j, 1, m + 1) ans = min(ans, dp[n - 2][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1LL << 60\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nvector<P>St[256];\nint N, M;\nll dp[256][16][128];\n\nll dfs(int n, int x, int m){\n  if(n>=N-1) return 0;\n  if(n>=N-2 && m) return 0;\n  ll &res = dp[n][x][m];\n  if(res >= 0) return res;\n  res = INF;\n  int pos = St[n][x].first ,slip = St[n][x].second;\n  rep(i, St[n+1].size()){\n      P tar = St[n+1][i];\n      res = min(res, dfs(n+1, i, m)+(ll)(slip+tar.second)*(ll)(abs(pos-tar.first)));\n  }\n  if(m && n < N-2){\n    rep(i, St[n+2].size()){\n      P tar = St[n+2][i];\n      res = min(res, dfs(n+2, i, m-1)+(ll)(slip+tar.second)*(ll)(abs(pos-tar.first)));\n    }\n  }\n  //  cout << n << \" \" << x << \" \"<< m <<\" \" << res << endl;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &N, &M) && N){\n    int k, x, d;\n    memset(dp, -1, sizeof(dp));\n    rep(i,N) St[i].clear();\n    rep(i, N){\n      scanf(\"%d\", &k);\n      rep(j,k){\n\tscanf(\"%d%d\", &x, &d);\n\tSt[i].push_back(P(x, d));\n      }\n    }\n    \n    ll res = INF;\n    rep(i, St[0].size()) res = min(res, dfs(0, i, M));\n    if(M) rep(i, St[1].size()) res = min(res, dfs(1, i, M-1));\n\n    printf(\"%lld\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define INF 90000000000000\ntypedef pair<int, int> P;\n\nint n, m;\n\n\nint main(){\nwhile(true){\n\tcin >> n >> m;\n\tif(n==0&&m==0) return 0;\n\tint k[155] = {0};\n\tP stone[155][15];\n\tlong long dp[155][15][155] = {0};\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> k[i];\n\t\tfor(int j = 0; j < k[i]; j++){\n\t\t\tcin >> stone[i][j].first >> stone[i][j].second;\n\t\t}\n\t}\n\tfor(int i = 0; i < 155; i++){\n\t\tfor(int j = 0; j < 15; j++){\n\t\t\tfor(int p = 0; p < 155; p++){\n\t\t\t\tdp[i][j][p] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j = 0; j < k[1]; j++){\n\t\tdp[1][j][0] = 0;\n\t}\n\tfor(int j = 0; j < k[2]; j++){\n\t\tdp[2][j][1] = 0;\n\t}\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 0; j < k[i]; j++){\n\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\tfor(int l = 0; l < k[i-1]; l++){\n\t\t\t\t\tdp[i][j][p] = min(dp[i][j][p], dp[i-1][l][p] + (stone[i][j].second + stone[i-1][l].second)* abs(stone[i][j].first - stone[i-1][l].first));\n\t\t\t\t}\n\t\t\t\tif(i>=3&&p>=1){\n\t\t\t\t\tfor(int l = 0; l < k[i-2]; l++){\n\t\t\t\t\t\tdp[i][j][p] = min(dp[i][j][p],dp[i-2][l][p-1] + (stone[i][j].second + stone[i-2][l].second)*abs(stone[i][j].first - stone[i-2][l].first));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n    long long res = INF;\n\tfor(int j = 0; j < k[n]; j++){\n\t\tfor(int p = 0; p <= m; p++){\n\t\t\tres = min(res, dp[n][j][p]);\n\t\t}\n\t}\n\tfor(int j = 0; j < k[n-1]; j++){\n\t\tfor(int p=0;p<=m-1;p++){\n\t\t\tres=min(res, dp[n-1][j][p]);\n\t\t}\n\t}\n\tcout << res << endl;\n}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint sz[200];\nP stone[200][20];\nint dp[200][20][200];\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && (n || m)){\n\t\tfill(sz, sz + 200, 0);\n\t\tfill(&dp[0][0][0], &dp[199][19][199] + 1, INF);\n\t\trep(i, 2){\n\t\t\trep(j, 20){\n\t\t\t\trep(k, m+1){\n\t\t\t\t\tif(i == 1 && k == 0) continue;\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\n\t\trep(i, n){\n\t\t\tcin >> sz[i];\n\t\t\trep(j, sz[i]){\n\t\t\t\tint x, r;\n\t\t\t\tcin >> x >> r;\n\t\t\t\tstone[i][j] = P(x, r);\n\t\t\t}\n\t\t}\n\n\t\trep(i, n){\n\t\t\trep(j, sz[i]){\n\t\t\t\trep(k, m + 1){\n\t\t\t\t\tif(i == n - 1){\n\t\t\t\t\t\tres = min(res, dp[i][j][k]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trep(l, sz[i+1]){\n\t\t\t\t\t\t\tint cost = abs(stone[i][j].first - stone[i+1][l].first) * \n\t\t\t\t\t\t\t\t(stone[i][j].second + stone[i+1][l].second);\n\t\t\t\t\t\t\tdp[i+1][l][k] = min(dp[i+1][l][k], dp[i][j][k] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k < m){\n\t\t\t\t\t\tif(i == n - 2){\n\t\t\t\t\t\t\tres = min(res, dp[i][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\trep(l, sz[i+2]){\n\t\t\t\t\t\t\t\tint cost = abs(stone[i][j].first - stone[i+2][l].first) * \n\t\t\t\t\t\t\t\t\t(stone[i][j].second + stone[i+2][l].second);\n\t\t\t\t\t\t\t\tdp[i+2][l][k+1] = min(dp[i+2][l][k+1], dp[i][j][k] + cost);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > x(n+1), d(n+1);\n        vector<vector<vector<int> > > dp(n+1);\n        for(int i=1; i<=n; ++i){\n            int k;\n            cin >> k;\n            for(int j=0; j<k; ++j){\n                int a, b;\n                cin >> a >> b;\n                x[i].push_back(a);\n                d[i].push_back(b);\n                if(i == 1)\n                    dp[i].push_back(vector<int>(m+1, 0));\n                else\n                    dp[i].push_back(vector<int>(m+1, INT_MAX));\n            }\n        }\n\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<x[i].size(); ++j){\n                for(unsigned k=0; k<x[i+1].size(); ++k){\n                    for(int l=0; l<=m; ++l)\n                        dp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][l] + (d[i][j]+d[i+1][k]) * abs(x[i][j]-x[i+1][k]));\n                }\n                if(i == n-1)\n                    continue;\n                for(unsigned k=0; k<x[i+2].size(); ++k){\n                    for(int l=1; l<=m; ++l)\n                        dp[i+2][k][l-1] = min(dp[i+2][k][l-1], dp[i][j][l] + (d[i][j]+d[i+2][k]) * abs(x[i][j]-x[i+2][k]));\n                }\n            }\n        }\n\n        int ret = INT_MAX;\n        for(unsigned i=0; i<x[n].size(); ++i)\n            ret = min(ret, dp[n][i][0]);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nstruct P {\n\tint p, s;\n};\nvector<P>a[160];\nlong long dp[160][20][160];\nint n;\nlong long solve(int i, int p, int m) {\n\tlong long sum = 800000000000;\n\tif (i == n) return 0;\n\tfor (int j = 0; j < a[i + 1].size(); j++) {\n\t\tlong long res = (a[i + 1][j].p - a[i][p].p);\n\t\tres = max(0 - res, res);\n\t\tres *= (a[i + 1][j].s + a[i][p].s);\n\t\tif (dp[i + 1][j][m] != -1) {\n\t\t\tsum = min(sum, res + dp[i + 1][j][m]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i+1][j][m]=solve(i + 1, j, m)));\n\t\t}\n\t}\n\tif (m > 0 && i + 2 <= n) {\n\t\tfor (int j = 0; j < a[i + 2].size(); j++) {\n\t\t\tlong long res = (a[i + 2][j].p - a[i][p].p);\n\t\t\tres = max(0 - res, res);\n\t\t\tres *= (a[i + 2][j].s + a[i][p].s);\n\t\t\tif (dp[i + 2][j][m-1] != -1) {\n\t\t\t\tsum = min(sum, res + dp[i + 2][j][m-1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = min(sum, res + (dp[i + 2][j][m-1] = solve(i + 2, j, m-1)));\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tint m;\n\twhile (cin >> n >> m&&(n != 0 || m != 0)) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tP u;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tcin >> u.p >> u.s;\n\t\t\t\ta[i].push_back(u);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\tfor (int x = 0; x <= m; x++) {\n\t\t\t\t\tdp[i][j][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long sum = 8000000000000;\n\t\tfor (int i = 0; i < a[1].size(); i++) {\n\t\t\tsum = min(sum, solve(1, i, m));\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    int y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, int cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<int> > stones(N, vector<int>(1000, INT_MAX));\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i][x] = d;\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < 1000; ++j) {\n                if(stones[i][j] != INT_MAX) {\n                    q.push(Tag(i, j, 0, M-i));\n                }\n            }\n        }\n\n        int ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m == 0 && i == 2) break;\n                for(int j = 0; j < 1000; ++j) {\n                    int cost = stones[t.y+i][j];\n                    if(cost != INT_MAX) {\n                        cost += stones[t.y][t.x];\n                        q.push(Tag(t.y+i, j, t.c + cost*abs(t.x-j), t.m-i+1));\n             //           cout << '\\t' << t.y+i << ' ' << j << ' ' << cost*abs(t.x-j) << endl;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint dp[151][1001][76];\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tmemset(dp,0x3f,sizeof(dp));\n\t\tvector<P>E[151];\n\t\trep(i,n){\n\t\t\tint k;scanf(\"%d\",&k);\n\t\t\trep(t,k){\n\t\t\t\tint x,d;scanf(\"%d%d\",&x,&d);\n\t\t\t\tE[i].push_back(P(d,--x));\n\t\t\t}\n\t\t}\n\t\tfor(P i:E[0])dp[0][i.second][0]=0;\n\t\tfor(P i:E[1])dp[0][i.second][1]=0;\n\t\trep(i,n-1){\n\t\t\tfor(P j:E[i]){\n\t\t\t\tfor(int t=0;t<=m;t++){\n\t\t\t\t\tif(dp[i][j.second][t]==INF)continue;\n\t\t\t\t\tfor(P k:E[i+1])dp[i+1][k.second][t]=\n\t\t\t\t\tmin(dp[i+1][k.second][t],dp[i][j.second][t]+(j.first+k.first)*abs(j.second-k.second));\n\t\t\t\t\tif(i<n-2){\n\t\t\t\t\t\tfor(P k:E[i+2])dp[i+2][k.second][t+1]=\n\t\t\t\t\t\tmin(dp[i+2][k.second][t+1],dp[i][j.second][t]+(j.first+k.first)*abs(j.second-k.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min=INF;\n\t\tfor(P i:E[n-1]){\n\t\t\tfor(int j=0;j<=m;j++)Min=min(Min,dp[n-1][i.second][j]);\n\t\t}\n\t\tfor(P i:E[n-2]){\n\t\t\tfor(int j=0;j<m;j++)Min=min(Min,dp[n-2][i.second][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define INF (1 << 25)\nusing namespace std;\n\nint main(){\n  int n, m, tmp;\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    int dp[3][10][100];\n    memset(dp, 0, sizeof(dp));\n    vector< pair<int, int> >stones[n];\n    for(int i = 0;i < n;i++){\n      int k, l, m;\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;j++){\n\tscanf(\"%d %d\", &l, &m);\n\tstones[i].push_back(make_pair(l, m));\n      }\n    }\n    for(int i = 0;i < n;i++){\n      int ind = i%3, prev = (i - 1) % 3, prepre = (i - 2) % 3;\n\n      for(int j = 0;j < stones[i].size();j++)\n\tfor(int k = 0;k <= m;k++)\n\t  dp[ind][j][k] = INF;\n\n      for(int j = 0;j < stones[i].size();j++){\n\tif(i == 0)dp[ind][j][m] = 0;\n\telse if(i == 1 && m - 1 >= 0)dp[ind][j][m - 1] = 0;\n      }\n      for(int j = 0;j < stones[i].size();j++){\n\tfor(int k = 0;k <= m;k++){\n\t  for(int l = 0;i > 0 && l < stones[i - 1].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prev][l][k] + abs(stones[i - 1][l].first - stones[i][j].first) * (stones[i - 1][l].second + stones[i][j].second));\n\t  }\n\t  for(int l = 0;i > 1 && k < m && l < stones[i - 2].size();l++){\n\t    dp[ind][j][k] = min(dp[ind][j][k],\n\t\t\t\tdp[prepre][l][k + 1] + abs(stones[i - 2][l].first - stones[i][j].first) * (stones[i - 2][l].second + stones[i][j].second));\n\t  }\n\t}\n      }\n    }\n    int res = INF;\n    for(int i = 0;i < stones[n - 1].size();i++){\n      for(int j = 0;j <= m;j++){\n\tres = min(res, dp[(n-1) % 3][i][j]);\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nconst int inf = 4e8;\n\nint n, m;\nint k[150];\nint x[150][10];\nint d[150][10];\nint dp[150 * 10 * 76];\n\nint index(int i, int j, int k){\n\treturn (i * 10 + j) * (m + 1) + k;\n}\n\nint cost(int i, int j, int k, int l){\n\tint dx = x[i][j] - x[k][l];\n\treturn (d[i][j] + d[k][l]) * (dx >= 0 ? dx : -dx);\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, n){\n\t\t\tscanf(\"%d\", &k[i]);\n\t\t\trep(j, k[i]){\n\t\t\t\tscanf(\"%d%d\", &x[i][j], &d[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tfill_n(dp, index(n, 0, 0), inf);\n\n\t\trep(i, k[0]){\n\t\t\tdp[index(0, i, 0)] = 0;\n\t\t}\n\t\tif(m > 0){\n\t\t\trep(i, k[1]){\n\t\t\t\tdp[index(1, i, 1)] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int s = 1; s < n; ++s){\n\t\t\trep(t, k[s]){\n\t\t\t\trep(u, m + 1){\n\t\t\t\t\trep(v, k[s - 1]){\n\t\t\t\t\t\tdp[index(s, t, u)] = min(dp[index(s, t, u)], dp[index(s - 1, v, u)] + cost(s - 1, v, s, t));\n\t\t\t\t\t}\n\t\t\t\t\tif(s >= 2 && u >= 1){\n\t\t\t\t\t\trep(v, k[s - 2]){\n\t\t\t\t\t\t\tdp[index(s, t, u)] = min(dp[index(s, t, u)], dp[index(s - 2, v, u - 1)] + cost(s - 2, v, s, t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tint ans = inf;\n\t\trep(i, k[n - 1]){\n\t\t\trep(j, m + 1){\n\t\t\t\tans = min(dp[index(n - 1, i, j)], ans);\n\t\t\t}\n\t\t}\n\t\trep(i, k[n - 2]){\n\t\t\trep(j, m){\n\t\t\t\tans = min(dp[index(n - 2, i, j)], ans);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 20000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++){\n\tdp[0][i][m]=dp[1][i][m]=dp[2][i][m-1]=0;\n    }\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][1010];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  fill(dp[0][0],dp[n-1][0],1000000000);\n  FOR(i,m+1) FOR(j,x[n].size()) dp[n][i][x[n][j]]=0;\n  for(int i=n-1;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      if(i==n-1) dp[i][j][x[i][k]]=0;\n      else{\n       FOR(l,x[i+2].size()){\n        dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]));\n       }\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]));\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[1].size()) mi=min(mi,dp[1][m][x[1][i]]);\n  if(m) FOR(i,x[2].size()) mi=min(mi,dp[2][m-1][x[2][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\nstruct edge\n{\n\tint to, cost;\n\tedge(){};\n\tedge(int to, int cost) : to(to), cost(cost){};\n};\n\nint dist[200][200][200];\nvector<vi> x(200);\nvector<vi> d(200);\n\nint main(){\n\twhile(1){\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tif(n == 0 && m == 0) break;\n\t\tx.clear(); d.clear();\n\t\tx.resize(n); d.resize(n);\n\t\trep(i, n){\n\t\t\tint k = in.nextInt();\n\t\t\trep(j, k){\n\t\t\t\tint tx = in.nextInt(), td = in.nextInt();\n\t\t\t\tx[i].pb(tx);\n\t\t\t\td[i].pb(td);\n\t\t\t}\n\t\t}\n\t\tvector<edge> g[200][200], g2[200][200];\n\t\trep(i, n-1){\n\t\t\trep(j, x[i].size()){\n\t\t\t\trep(k, x[i+1].size()){\n\t\t\t\t\tint c = (d[i][j] + d[i+1][k]) * abs(x[i][j]- x[i+1][k]);\n\t\t\t\t\tg[i][j].pb({k, c});\n\t\t\t\t}\n\t\t\t\tif( i + 2 < n);\n\t\t\t\telse continue;\n\t\t\t\trep(k, x[i+2].size()){\n\t\t\t\t\tint c = (d[i][j] + d[i+2][k]) * abs(x[i][j]- x[i+2][k]);\n\t\t\t\t\tg2[i][j].pb({k, c});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 200) rep(j, 200) rep(k, 200) dist[i][j][k] = i == 0 ? 0 : INF;\n\t\tauto dijkstra = [&]{\n\t\t\tpriority_queue<pair<pii, pii>, vector<pair<pii, pii> >, greater<pair<pii, pii> > > q;\n\t\t\tfor(int  i = 0; i < x[0].size(); i++) q.push(mp(mp(0, 0), mp(0, i)));\n\t\t\tpair<pii, pii> p;\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top();\tq.pop();\n\t\t\t\tint cost = p.fi.fi, jump = p.fi.se, from1 = p.se.fi, from2 = p.se.se;\n\t\t\t\tfor(int i = 0; i < g[from1][from2].size(); i++){\n\t\t\t\t\tint to1 = from1 + 1, to2 =g[from1][from2][i].to, c = g[from1][from2][i].cost;\n\t\t\t\t\tif(dist[to1][to2][jump] <= cost + c) continue;\n\t\t\t\t\tdist[to1][to2][jump] = cost + c;\n\t\t\t\t\tq.push(mp(mp(cost + c, jump), mp(to1, to2)));\n\t\t\t\t}\n\t\t\t\tif(jump > m) continue;\n\t\t\t\tfor(int i = 0; i < g2[from1][from2].size(); i++){\n\t\t\t\t\tint to1 = from1 + 2, to2 =g2[from1][from2][i].to, c = g2[from1][from2][i].cost;\n\t\t\t\t\tif(dist[to1][to2][jump + 1] <= cost + c) continue;\n\t\t\t\t\tdist[to1][to2][jump + 1] = cost + c;\n\t\t\t\t\tq.push(mp(mp(cost + c, jump + 1), mp(to1, to2)));\n\t\t\t\t}\t\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\tint ans = INF;\n\t\tfor(int i = 0; i  < x[n-1].size(); i++){\n\t\t\tfor(int j = 0; j <= m; j++) ans = min(ans, dist[n-1][i][j]);\n\t\t}\n\t\tfor(int i = 0; i  < x[n-2].size(); i++){\n\t\t\tfor(int j = 0; j < m; j++) ans = min(ans, dist[n-2][i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-9\n\nmap<int,int> dp[80][160]; // [m][i]<x,cost>\n\nint main(){\n\tint n,m;\n\t\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\tint ans = INT_MAX;\n\t\tvector<pair<int,int> > vp[160];\n\t\trep(i,80)rep(j,160)dp[i][j].clear();\n\t\t\n\t\trep(i,n){\n\t\t\tvector<pair<int,int> > tmp;\n\t\t\tint sz; scanf(\"%d\",&sz);\n\t\t\trep(j,sz){\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\t//printf(\"a,b , %d,%d\\n\",a,b);\n\t\t\t\ttmp.push_back( make_pair(a,b) );\n\t\t\t}\n\t\t\tvp[i] = tmp;\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tif( i==0 ){\n\t\t\t\trep(j,vp[0].size()){\n\t\t\t\t\tdp[0][0][vp[0][j].first] = 0;\n\t\t\t\t}\n\t\t\t\tif( n>1 && m>0 ){\n\t\t\t\t\trep(j,vp[1].size()){\n\t\t\t\t\t\tdp[1][1][vp[1][j].first] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(l,m+1){\n\t\t\t\t\trep(j,vp[i-1].size())if( dp[l][i-1].count(vp[i-1][j].first) ){ // src 1step\n\t\t\t\t\t\trep(k,vp[i].size()){ //dest\n\t\t\t\t\t\t\tint c = (vp[i-1][j].second+vp[i][k].second) * abs(vp[i-1][j].first-vp[i][k].first);\n\t\t\t\t\t\t\tif( dp[l][i].count(vp[i][k].first) ){\n\t\t\t\t\t\t\t\tdp[l][i][vp[i][k].first] = min(dp[l][i][vp[i][k].first], dp[l][i-1][vp[i-1][j].first]+c);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdp[l][i][vp[i][k].first] = dp[l][i-1][vp[i-1][j].first]+c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( i>1 && l<m ){\n\t\t\t\t\t\trep(j,vp[i-2].size())if( dp[l][i-2].count(vp[i-2][j].first) ){ // src 2step\n\t\t\t\t\t\t\trep(k,vp[i].size()){ //dest\n\t\t\t\t\t\t\t\tint c = (vp[i-2][j].second+vp[i][k].second) * abs(vp[i-2][j].first-vp[i][k].first);\n\t\t\t\t\t\t\t\tif( dp[l+1][i].count(vp[i][k].first) ){\n\t\t\t\t\t\t\t\t\tdp[l+1][i][vp[i][k].first] = min(dp[l+1][i][vp[i][k].first], dp[l][i-2][vp[i-2][j].first]+c);\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tdp[l+1][i][vp[i][k].first] = dp[l][i-2][vp[i-2][j].first]+c;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,n){\n\t\t\trep(j,10){\n\t\t\t\trep(k,m+1){\n\t\t\t\t\tprintf(\"dp[%d][%d][%d] : %d\\n\",k,i,j,dp[k][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\trep(l,m+1){\n\t\t\trep(i,vp[n-1].size())if( dp[l][n-1].count(vp[n-1][i].first) ){\n\t\t\t\tans = min(ans, dp[l][n-1][vp[n-1][i].first]);\n\t\t\t}\n\t\t\tif( n-2>=0 && l<m ){\n\t\t\t\trep(i,vp[n-2].size())if( dp[l][n-2].count(vp[n-2][i].first) ){\n\t\t\t\t\tans = min(ans, dp[l][n-2][vp[n-2][i].first]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i,m+1)rep(j,st_sz[n])\n\t\t//\tans = min(ans,dp[i][n][j]);\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#define N 153\n#define COL 1001\nusing namespace std;\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\nint dijkstra(int n,int m,int D[][COL],const vector< vector<int> > &T){\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  bool vis[N][COL]={false,};\n  while(!qs.empty()){\n    state now=qs.top();qs.pop();\n    if(now.r==n+1||now.r==n+2)return now.cost;\n    vis[now.r][now.c]=true;\n    for(int k=1;k<=2;++k){for(int i=0;i<T[now.r+k].size();++i){\n\tint nxr=now.r+k,nxc=T[nxr][i],nxcost=now.cost+(now.r==0?0:(D[now.r][now.c]+D[nxr][nxc])*abs(now.c-nxc));\n\tstate next(nxr,nxc,nxcost,now.left-(k-1));if(!vis[nxr][nxc]&&next.left>=0){qs.push(next);}\n      }\n    }\n  }\n  return -1;\n}\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(n==0&&m==0)break;\n    vector< vector<int> > T(n+3);for(int i=0;i<COL;++i){T[0].push_back(i);T[n+1].push_back(i);T[n+2].push_back(i);}\n    int D[N][COL]={{0,},};\n    for(int i=0;i<n;++i){int k;cin>>k;for(int j=0;j<k;++j){int col,danger;cin>>col>>danger;T[i+1].push_back(col);D[i+1][col]=danger;}}\n    cout<<dijkstra(n,m,D,T)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define rep(i,x) for(int i=0;i<(x);++i)\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint k[150];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n\tif (n >= N - 1) return 0;\n\n\tif (~memo[n][m][i]) return memo[n][m][i];\n\n\tint res = inf;\n\n\trep(j, k[n + 1]) {\n\t\tint dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n\t\tchmin(res, dist + rec(n + 1, m, j));\n\t}\n\n\tif (m < M) {\n\t\tif (n + 2 >= N) return 0;\n\t\trep(j, k[n + 2]) {\n\t\t\tint dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n\t\t\tchmin(res, dist + rec(n + 2, m + 1, j));\n\t\t}\n\t}\n\n\treturn memo[n][m][i] = res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &N, &M), N || M) {\n\t\trep(i, N) {\n\t\t\tscanf(\"%d\", &k[i]);\n\n\t\t\tstone[i].resize(k[i]);\n\n\t\t\trep(j, k[i]) {\n\t\t\t\tint x, d; scanf(\"%d %d\", &x, &d);\n\t\t\t\tstone[i][j].fst = x, stone[i][j].scd = d;\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\n\t\trep(i, k[0]) {\n\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\tchmin(ans, rec(0, 0, i));\n\t\t}\n\n\t\tif (M > 0) {\n\t\t\trep(i, k[2]) {\n\t\t\t\tmemset(memo, -1, sizeof(memo));\n\t\t\t\tchmin(ans, rec(2, 1, i));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<11;i++){\n\t\t\tve[0].push_back(MP(i,0));\n\t\t\tdp[T][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[1].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=min(i/2,M);j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tif(i!=0)for(int i=0;i<M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N-1].size();j++){\n\t\t\t\tres=min(res,dp[T][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define fi first\n#define se second\n\nconst int inf = 1e17 + 9;\n\ntypedef pair<int, int> P;\n\nint n, m;\nint k[160];\nvector<P> s[160];\n\nint dp[160][16][80];\n\nsigned main()\n{\n  while (cin >> n >> m, n){\n    rep(i, n){\n      cin >> k[i];\n      rep(j, k[i]){\n        int d, x;\n        cin >> x >> d;\n        s[i].push_back(P(x, d));\n      }\n    }\n\n    rep(i, 160) rep(j, 16) rep(l, 80) dp[i][j][l] = inf;\n\n    rep(j, k[0]) dp[0][j][m] = 0;\n    if (m) rep(j, k[1]) dp[1][j][m - 1] = 0;\n\n    rep(i, n - 1){\n      rep(j, k[i]){\n        rep(l, m + 1){\n          if (i == n - 2 && l > 0) continue;\n\n          rep(t, k[i + 1]){\n            int cost = (s[i][j].se + s[i + 1][t].se) * abs(s[i][j].fi - s[i + 1][t].fi);\n            //printf(\"%d:%d -> %d:%d = %d\\n\", i, j, i + 1, t, cost);\n            dp[i + 1][t][l] = min(dp[i + 1][t][l], dp[i][j][l] + cost);\n          }\n\n          if (l > 0){\n            rep(t, k[i + 2]){\n              int cost = (s[i][j].se + s[i + 2][t].se) * abs(s[i][j].fi - s[i + 2][t].fi);\n              //printf(\"%d:%d -> %d:%d = %d\\n\", i, j, i + 2, t, cost);\n              dp[i + 2][t][l - 1] = min(dp[i + 2][t][l - 1], dp[i][j][l] + cost);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = inf;\n    rep(j, k[n - 1]) rep(l, m + 1) ans = min(ans, dp[n - 1][j][l]);\n    rep(j, k[n - 2]) for (int l = 1; l <= m; l++) ans = min(ans, dp[n - 2][j][l]);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n\tint n , m;\n\t\n\twhile(cin >> n >> m , n ){\n\t\tint pos[151][10] ={0};\n\t\tint rate[151][10] = {0};\n\t\tint cnt[151] = {0};\n\t\tfor(int i = 1 ; i <= n ;i++){\n\t\t\tint k; cin >> k;\n\t\t\tcnt[i] = k;\n\t\t\trep(j,k){\n\t\t\t\tcin >> pos[i][j] >> rate[i][j];\n\t\t\t}\n\t\t}\n\t\tn++;\n\t\t\n\t\tint dp[152][10][80] = {0};\n\t\trep(i,151)rep(j,10)rep(k,80)dp[i][j][k] = (1<<29);\n\t\trep(j,10)rep(k,80)dp[0][j][k] = 0;\n\t\trep(j,10)rate[0][j] = 0;\n\t\tcnt[0] = 1;\n\t\t\n\t\tfor(int k = m ; k>=0 ; k--){\n\t\t\tfor(int i = 1;i<n;i++){\n\t\t\t\trep(prev,cnt[i-1]){\n\t\t\t\t\trep(cur,cnt[i]){\n\t\t\t\t\t\tif(i-1){\n\t\t\t\t\t\t\tdp[i][cur][k] = min(\n\t\t\t\t\t\t\t\tdp[i][cur][k], \n\t\t\t\t\t\t\t\tdp[i-1][prev][k] + (rate[i][cur]+rate[i-1][prev]) * abs( pos[i][cur] - pos[i-1][prev] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][cur][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k){\n\t\t\t\tfor(int i=2;i<n;i++){\n\t\t\t\t\trep(prev,cnt[i-2]){\n\t\t\t\t\t\trep(cur,cnt[i]){\n\t\t\t\t\t\t\tif(i-2){\n\t\t\t\t\t\t\t\tdp[i][cur][k-1] = min(\n\t\t\t\t\t\t\t\t\tdp[i][cur][k-1] , \n\t\t\t\t\t\t\t\t\tdp[i-2][prev][k] + (rate[i][cur]+rate[i-2][prev]) * abs( pos[i][cur] - pos[i-2][prev] )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdp[i][cur][k-1] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = (1<<29);\n\t\trep(k,m+1){\n\t\t\tif(k)rep(i,cnt[n-2])ret = min(ret,dp[n-2][i][k]);\n\t\t\trep(i,cnt[n-1])ret = min(ret,dp[n-1][i][k]);\n\t\t}\n\t\tcout << ret << endl;\n\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<24LL;\ntypedef pair<LL,LL> PLL;\n\nLL N,M;\nLL ans=INF;\nLL V[160][15];\nLL K[160][15];\nLL mem[160][15][80];\n\n\nLL cal(int y,int x,int m){\n    LL res=INF;\n    if(mem[y][x][m]!=-1){\n        return mem[y][x][m];\n    }\n    if(y==N-1)return 0;\n    rep(i,10){\n        LL d1,d2;\n        if(m>0&&K[y+1][i]&&K[y+2][i]&&y+2<=N){\n            d1=(K[y][x]+K[y+1][i])*abs(V[y][x]-V[y+1][i]);\n            d2=(K[y][x]+K[y+2][i])*abs(V[y][x]-V[y+2][i]);\n            res=min(cal(y+1,i,m)+d1,min(cal(y+2,i,m-1)+d2,res));\n        }\n        else if(K[y+1][i]){\n            d1=(K[y][x]+K[y+1][i])*abs(V[y][x]-V[y+1][i]);\n            res=min(cal(y+1,i,m)+d1,res);\n        }\n        else if(K[y+2][i]&&m>0&&y+2<=N){\n            d2=(K[y][x]+K[y+2][i])*abs(V[y][x]-V[y+2][i]);\n            res=min(cal(y+2,i,m-1)+d2,res);\n        }\n    }\n    return mem[y][x][m]=res;\n}\n\n\nint main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(mem,-1,sizeof(mem));\n        memset(V,0,sizeof(V));\n        memset(K,0,sizeof(K));\n        FOR(i,1,N){\n            LL t;\n            cin>>t;\n            rep(j,t){\n                LL x,k;\n                cin>>x>>k;\n                V[i][j]=x;\n                K[i][j]=k;\n            }\n        }\n        rep(j,10){\n            if(K[1][j]&&K[2][j]&&M>0){\n                ans=min(cal(1,j,M),min(cal(2,j,M-1),ans));\n            }\n            else if(K[1][j]){\n                ans=min(cal(1,j,M),ans);\n            }\n            else if(M>0)ans=min(cal(2,j,M-1),ans);\n        }\n        cout<<ans<<endl;\n        ans=INF;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=100;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\t\t       \n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  \n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  ll n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    if(i==2)dp[i][j][l]=0;\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    /*\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n    */\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <map>\n#include <vector>\n#include <algorithm>\n#define inf INT_MAX/2\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<P> riv[150];\nvector<int> dp[150][1000];\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        for (int i=0; i<n; i++) {\n            int k; scanf(\"%d\",&k);\n            riv[i].clear();\n            for (int j=0; j<k; j++) {\n                int x, d; scanf(\"%d%d\",&x,&d);\n                riv[i].push_back(P(x,d));\n            }\n        }\n        for (int i=0; i<n; i++) {\n            int sz=riv[i].size();\n            for (int j=0; j<sz; j++) {\n                dp[i][j].clear();\n                dp[i][j]=vector<int>(min(i+1,m+1),inf);\n                for (int k=0; k<min(i+1,m+1); k++) {\n                    if (i==0) {\n                        dp[i][j][k]=0;\n                    } else {\n                        int sz2=riv[i-1].size();\n                        for (int l=0; l<sz2; l++) {\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-1][l][k]+(int)abs(riv[i][j].f-riv[i-1][l].f)*(riv[i][j].s+riv[i-1][l].s));\n                        }\n                    }\n                    if (k!=0&&i>1) {\n                        int sz2=riv[i-2].size();\n                        for (int l=0; l<sz2; l++) {\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-2][l][k-1]+(int)abs(riv[i][j].f-riv[i-2][l].f)*(riv[i][j].s+riv[i-2][l].s));\n                        }\n                    }\n                }\n            }\n        }\n        int res=inf;\n        for (int i=0; i<riv[n-1].size(); i++) {\n            for (int k=0; k<=m; k++) res=min(res,dp[n-1][i][k]);\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  while (cin >> n >> m, n) {\n    int dp[200][15][100] = {0};\n    vector<pii> G[200];\n\n    for (int i = 1; i <= n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n        int x, d;\n        cin >> x >> d;\n        G[i].PB(pii(x, d));\n      }\n    }\n    G[n + 1].PB(pii(0, 0));\n\n    fill(dp[2][0], dp[200][0], INF);\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 0; j < G[i].size(); ++j) {\n        for (int k = 0; k <= m; ++k) {\n          for (int dy = 1; dy <= 2; ++dy) {\n            for (int j2 = 0; j2 < G[i + dy].size(); ++j2) {\n              if (dp[i][j][k] == INF) continue;\n              pii p1 = G[i][j], p2 = G[i + dy][j2];\n              int move = abs(p1.first - p2.first), sumd = p1.second + p2.second;\n              if (i + dy == n + 1) sumd = 0;\n              dp[i + dy][j2][k + dy - 1] = min(dp[i + dy][j2][k + dy - 1], dp[i][j][k] + sumd * move);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int i = 0; i <= m; ++i) {\n      ans = min(ans, dp[n + 1][0][i]);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) REP(i,0,n)\n#define f first\n#define s second\n#define mpi(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\n#define pi pair<pair<int,int>,pair<int,int> >\nusing namespace std;\nint in(){int x; scanf(\"%d\",&x); return x;}\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      vector<vector<int> > pos(150);\n      vector<vector<int> > cos(150);\n      int flag[151][10][75] = {0};\n      priority_queue<pi,vector<pi >,greater<pi > >Q;//cost,y,x,slip\n      rep(i,n){\n         int x = in();\n         rep(j,x){\n            pos[i].push_back(in());\n            cos[i].push_back(in());\n         }\n      }\n\n      rep(i,pos[0].size()){\n         Q.push(mpi(0,0,i,0));\n      }\n      rep(i,pos[1].size()){\n         if(m != 0){\n            Q.push(mpi(0,1,i,1));\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         pi p = Q.top(); Q.pop();\n         if(p.f.s == n-1){ans = p.f.f; break;}\n         if(p.f.s == n-2 && m > p.s.s){ans = p.f.f; break;}\n\n         if(flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] == 1) continue;\n         flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] = 1;\n\n         rep(i,pos[p.f.s+1].size()){\n            Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+1][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+1][i]),p.f.s+1,i,p.s.s));\n         }\n\n         rep(i,pos[p.f.s+2].size()){\n            if(p.s.s < m) Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+2][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+2][i]),p.f.s+2,i,p.s.s+1));\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<11;i++){\n\t\t\tve[0].push_back(MP(i,0));\n\t\t\tdp[T][i-1][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[1].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=min(i/2,M);j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tif(M!=0)for(int i=0;i<M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N-1].size();j++){\n\t\t\t\tres=min(res,dp[T][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint fie[152][1002][78];\nint main(){\n    while(1){\n        int M,N;\n        cin>>M>>N;\n        if(M==0&&N==0)break;\n        int lis[152][1002];\n        for(int i=0;i<152;i++){\n            for(int j=0;j<1002;j++){\n                if(i!=0&&i!=M+1)lis[i][j]=-1;\n                else lis[i][j]=0;\n            }\n        }\n        for(int i=0;i<152;i++){\n            for(int j=0;j<1002;j++){\n                for(int k=0;k<78;k++){\n                    if(i!=0||k!=0)fie[i][j][k]=2000000000;\n                    else fie[i][j][k]=0;\n                }\n            }\n        }\n        for(int i=0;i<M;i++){\n            int a;\n            cin>>a;\n            for(int j=1;j<=a;j++){\n                int b,c;\n                cin>>b>>c;\n                lis[i+1][b]=c;\n            }\n        }\n        for(int i=0;i<=M;i++){\n            for(int j=0;j<1002;j++){\n                for(int k=0;k<76;k++){\n                    if(fie[i][j][k]<2000000000){\n                        for(int l=0;l<1002;l++){\n                            if(lis[i+1][l]!=-1)\n                                fie[i+1][l][k]=min(fie[i+1][l][k],fie[i][j][k]+(lis[i][j]+lis[i+1][l])*(int)fabs(j-l));\n                            if(lis[i+2][l]!=-1)fie[i+2][l][k+1]=min(fie[i+2][l][k+1],fie[i][j][k]+(lis[i][j]+lis[i+2][l])*(int)fabs(j-l));\n                        }\n                    }\n                }\n            }\n        }\n        int ans=2000000000;\n        for(int j=0;j<1002;j++){\n            for(int k=0;k<76;k++){\n                if(k<=N)ans=min(ans,fie[M+1][j][k]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define INF INT_MAX\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>c[152][78];\n\t\tint d;\n\t\tcin >> d;\n\t\tfor (int e = 0; e < d; e++) {\n\t\t\tisi h; h.mincost = 0;\n\t\t\tscanf(\"%lld%lld\", &h.zahyou, &h.suberi);\n\t\t\tc[0][b].push_back(h);\n\t\t}\n\t\tfor (int f = 1; f < a; f++) {\n\t\t\tint g; cin >> g;\n\t\t\tfor (int h = 0; h < g; h++) {\n\t\t\t\tint i, j; scanf(\"%lld%lld\", &i, &j);\n\t\t\t\tfor (int k = b; k >= 0; k--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int l = 0; l < c[f - 1][k].size(); l++) {\n\t\t\t\t\t\tm = min(m, c[f - 1][k][l].mincost + (c[f - 1][k][l].suberi + j)*abs(c[f - 1][k][l].zahyou - i));\n\t\t\t\t\t}\n\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t}\n\t\t\t\t\tif (k != b&&f > 1) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int l = 0; l < c[f - 2][k+1].size(); l++) {\n\t\t\t\t\t\t\tm = min(m, c[f - 2][k+1][l].mincost + (c[f - 2][k+1][l].suberi + j)*abs(c[f - 2][k+1][l].zahyou - i));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m != INF) {\n\t\t\t\t\t\t\tisi r; r.zahyou = i; r.suberi = j; r.mincost = m;\n\t\t\t\t\t\t\tc[f][k].push_back(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int p = 0; p <= b; p++) {\n\t\t\tfor (isi q : c[a - 1][p]) {\n\t\t\t\tS = min(S, q.mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\nint n, m, b;\nvector<vector<PII> > a;\nint dp[ 153 ][ 153 ][ 153 ];\n\nint solve( int now, int e, int w ) {\n\tif ( now >= n || ( w && now >= n - 1 ) ) {\n\t\treturn 0;\n\t}\n\tif ( dp[ now ][ e ][ w ] >= 0 ) {\n\t\treturn dp[ now ][ e ][ w ];\n\t}\n\tint res = INF;\n\tfor ( int i = 0; i < a[ now ].size(); i++ ) {\n\t\tif ( now == 0 ) {\n\t\t\tres = min( res, solve( now + 1, i, w ) );\n\t\t}\n\t\telse {\n\t\t\tres = min( res, solve( now + 1, i, w ) + abs( a[ now - 1 ][ e ].first - a[ now ][ i ].first ) * ( a[ now - 1 ][ e ].second + a[ now ][ i ].second ) );\n\t\t}\n\t}\n\tif ( w ) {\n\t\tfor ( int i = 0; i < a[ now + 1 ].size(); i++ ) {\n\t\t\tif ( now == 0 ) {\n\t\t\t\tres = min( res, solve( now + 2, i, w - 1 ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = min( res, solve( now + 2, i, w - 1 ) + abs( a[ now - 1 ][ e ].first - a[ now + 1 ][ i ].first ) * ( a[ now - 1 ][ e ].second + a[ now + 1 ][ i ].second ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[ now ][ e ][ w ] = res;\n}\n\nint main() {\n\tscanf( \"%d %d\", &n, &m );\n\ta.resize( n );\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tscanf( \"%d\", &b );\n\t\ta[ i ].resize( b );\n\t\tfor ( int j = 0; j < a[ i ].size(); j++ ) {\n\t\t\tscanf( \"%d %d\", &a[ i ][ j ].first, &a[ i ][ j ].second );\n\t\t}\n\t}\n\tNCLR( dp );\n\tprintf( \"%d\\n\", solve( 0, 0, m ) );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\n\nvoid solve(void){\nint dp[1005][101];\n\n for(int i=0;i<1005;i++)\n   for(int j=0;j<=m;j++)\n     dp[i][j]=INF;\n\n   dp[0][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n\tedge e=G[i][j];\n\tfor(int k=0;k<=m;k++){\n\t  if(i+1==e.to)dp[i+1][k]=min(dp[i+1][k],dp[i][k]+e.cost);\n\t  if(i+2==e.to && k!=0)dp[i+2][m-k]=min(dp[i+2][m-k],dp[i][m-k+1]+e.cost);\n\t}\n    }\n  }\n  int ans=INF;\n  for(int j=0;j<=m;j++)\n    ans=min(ans,dp[n+1][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+1==n+1){\n\t      e.to=i+1;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t    if(i+2==n+1){\n\t      e.to=i+2;\n\t      e.cost=0;\n\t      G[i].push_back(e);\n\t    }\n\t  }\n\t}\n      }\n    }\n    solve();\n    //cout << dijkstra(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint n, m, f1, f2, r[150];\n\nvector<pair<int, int> > R[150]; int D[150][10][76];\n\nint distance(int x1, int c1, int x2, int c2)\n{\n\tint sums = R[x1][c1].second + R[x2][c2].second;\n\tint dist = R[x1][c1].first + R[x2][c2].first;\n\n\treturn sums * abs(dist);\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &m);\n\n\t\tif (n == 0 && m == 0) break;\n\n\t\tfor (int i = 0; i < n; i++) R[i].clear();\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r[i]);\n\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &f1);\n\t\t\t\tscanf(\"%d\", &f2);\n\n\t\t\t\tR[i].push_back(make_pair(f1, f2));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t{\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 999999999;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int> >, greater<tuple<int, int, int, int> > > que;\n\n\t\tfor (int i = 0; i < R[0].size(); i++)\n\t\t{\n\t\t\tque.push(make_tuple(0, 0, 0, i));\n\t\t}\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<int, int, int, int> state = que.top(); que.pop();\n\n\t\t\tint dist = get<0>(state);\n\t\t\tint jump = get<1>(state);\n\t\t\tint high = get<2>(state);\n\t\t\tint node = get<3>(state);\n\n\t\t\tif (high + 1 != n)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < r[high + 1]; i++)\n\t\t\t\t{\n\t\t\t\t\tint dist2 = dist + distance(high, node, high + 1, i);\n\n\t\t\t\t\tif (D[high + 1][node][jump] > dist2)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[high + 1][node][jump] = dist2;\n\n\t\t\t\t\t\tque.push(make_tuple(dist2, jump, high + 1, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (high + 2 != n && jump != m)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < r[high + 2]; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint dist2 = dist + distance(high, node, high + 2, i);\n\n\t\t\t\t\t\tif (D[high + 2][node][jump + 1] > dist2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[high + 2][node][jump + 1] = dist2;\n\n\t\t\t\t\t\t\tque.push(make_tuple(dist2, jump + 1, high + 1, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < r[n - 1]; i++)\n\t\t{\n\t\t\tret = min(ret, D[n - 1][i][m]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint n,m;\nint stone[155][11][2];\nint dp[155][11][76];\nint num[155];\nint cost(int a,int b,int c){\n\tif(a==n || (a==n-1 && c<m)){\n\t\treturn 0;\n\t}\n\tif(dp[a][b][c]!=-1) return dp[a][b][c];\n\tint mini=INF;\n\tfor(int i=1;i<=num[a+1];i++){\n\t\tmini=min(mini,(stone[a+1][i][1]+stone[a][b][1])*abs(stone[a][b][0]-stone[a+1][i][0])+cost(a+1,i,c));\n\t}\n\tif(c!=m){\n\tfor(int i=1;i<=num[a+2];i++){\n\t\tmini=min(mini,(stone[a+2][i][1]+stone[a][b][1])*abs(stone[a][b][0]-stone[a+2][i][0])+cost(a+2,i,1+c));\n\t}\n\t}\n\treturn dp[a][b][c]=mini;\n}\nint main(){\n\twhile(scanf(\"%d %d\",&n,&m) && m){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&num[i]);\n\t\t\tfor(int g=1;g<=num[i];g++){\n\t\t\t\tscanf(\"%d %d\",&stone[i][g][0],&stone[i][g][1]);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tint ans=INF;\n\t\tfor(int i=1;i<=num[1];i++){\n\t\t\tans=min(ans,cost(1,i,0));\n\t\t}\n\t\tif(m>0){\n\t\t\tfor(int i=1;i<=num[2];i++){\n\t\t\t\tans=min(ans,cost(2,i,1));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<11;i++){\n\t\t\tve[0].push_back(MP(i,0));\n\t\t\tdp[T][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[0].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=min(i/2,M);j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N-1].size();j++){\n\t\t\t\tres=min(res,dp[T][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int>  pi;\ntypedef pair<pair<int,int>,int>  ppi;\ntypedef vector<pair<pair<int,int>,int> >  vppi;\n#define ff first.first\n#define fs first.second\n#define se second\n\nstruct Stone { int row, col, d; };\n\nconst int S = 150;\nconst int T = 151;\n\nstruct Edge { int to1, to2, cost; };\nvector<Edge> G[160][80];\n\nvoid addEdge(int u1, int u2, int v1, int v2, int cost) {\n    G[u1][u2].push_back((Edge){ v1, v2, cost });\n}\n\nint risk(Stone a, Stone b) {\n    return (a.d + b.d) * abs(a.col - b.col);\n}\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        for (int i=0; i<160; ++i) {\n            for (int j=0; j<80; ++j) {\n                G[i][j].clear();\n            }\n        }\n\n        vector<Stone> stones;\n        int k;\n        for (int i=0; i<n; ++i) {\n            cin >> k;\n            int x, d;\n            for (int j=0; j<k; ++j) {\n                cin >> x >> d;\n                stones.push_back((Stone){ i, x, d });\n            }\n        }\n\n        for (int i=0; i<(int)stones.size(); ++i) {\n            // S\n            if (stones[i].row == 0) {\n                for (int j=0; j<80; ++j) {\n                    addEdge(S, j, i, j, 0);\n                }\n            } else if (stones[i].row == 1) {\n                for (int j=1; j<80; ++j) {\n                    addEdge(S, j, i, j-1, 0);\n                }\n            }\n\n            // T\n            if (stones[i].row == n-1) {\n                for (int j=0; j<80; ++j) {\n                    addEdge(i, j, T, j, 0);\n                }\n            } else if (stones[i].row == n-2) {\n                for (int j=1; j<80; ++j) {\n                    addEdge(i, j, T, j-1, 0);\n                }\n            }\n\n            // other\n            for (int j=i+1; j<(int)stones.size(); ++j) {\n                int jump = stones[j].row - stones[i].row;\n                if (3 <= jump) break;\n                if (jump == 1) {\n                    for (int k=0; k<80; ++k) {\n                        addEdge(i, k, j, k, risk(stones[i], stones[j]));\n                    }\n                } else if (jump == 2) {\n                    for (int k=1; k<80; ++k) {\n                        addEdge(i, k, j, k-1, risk(stones[i], stones[j]));\n                    }\n                }\n            }\n        }\n\n        int dist[160][80];\n        for (int i=0; i<160; ++i) {\n            for (int j=0; j<80; ++j) {\n                dist[i][j] = INT_MAX;\n            }\n        }\n        dist[S][m] = 0;\n        priority_queue<ppi, vppi, greater<ppi> > q;\n        q.push(make_pair(make_pair(0, S), m));\n        while ( ! q.empty()) {\n            int cost = q.top().ff;\n            int u1 = q.top().fs;\n            int u2 = q.top().se;\n            q.pop();\n            for (int i=0; i<(int)G[u1][u2].size(); ++i) {\n                Edge &e = G[u1][u2][i];\n                if (cost + e.cost < dist[e.to1][e.to2]) {\n                    dist[e.to1][e.to2] = cost + e.cost;\n                    q.push(make_pair(make_pair(cost + e.cost, e.to1), e.to2));\n                }\n            }\n        }\n        cout << *min_element(dist[T], dist[T]+80) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n, m;\nvector<pair<int, int> > data[150];\nint dp[150][10][76];\n\nmain(){\n  while(cin >> n >> m && (n || m)){\n    for(int i=0;i<n+2;i++) data[i].clear();\n    for(int i=0;i<n;i++){\n      int a;\n      cin >> a;\n      for(int j=0;j<a;j++){\n        int b, c;\n        cin >> b >> c;\n        data[i].push_back(pair<int, int>(b, c));\n      }\n    }\n    fill(dp[0][0], dp[150][0], INF);\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<data[j].size();i++){\n        dp[j][i][m-j] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<10;j++){\n        for(int i1=0;i1<=m;i1++){\n          if(dp[i][j][i1] != INF){\n            for(int l=0;l<=1;l++){\n              if(i1-l<0) continue;\n              if(i+1+l >= n) continue;\n              for(int k=0;k<data[i+1+l].size();k++){\n                dp[i+1+l][k][i1-l] = min(dp[i+1+l][k][i1-l],\n                                   dp[i][j][i1] + (data[i][j].second + data[i+1+l][k].second) *\n                                   (abs(data[i][j].first - data[i+1+l][k].first)));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=1;j++){\n      if(m-j<0) continue;\n      for(int i=0;i<10;i++){\n        for(int k=j;k<=m;k++){\n          ans = min(ans, dp[n-1-j][i][k]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define INF 1145141919\n\nint N, M;\nint W;\nint T[160][1010];\nint dp[160][1010][80];\n\nint main() {\n  while (cin >> N >> M) {\n    if (N == 0 && M == 0) break;\n    for (int i=0; i<160; i++) {\n      for (int j=0; j<1010; j++) {\n        T[i][j] = -1;\n      }\n    }\n    for (int i=0; i<N; i++) {\n      int k;\n      cin >> k;\n      for (int j=0; j<k; j++) {\n        int x, d;\n        cin >> x >> d;\n        T[i][x-1] = d;\n        W = max(W, x);\n      }\n    }\n\n    for (int i=0; i<160; i++) {\n      for (int j=0; j<1010; j++) {\n        for (int m=0; m<80; m++) {\n          dp[i][j][m] = INF;\n        }\n      }\n    }\n    for (int i=0; i<W; i++) {\n      if (T[0][i] > 0) dp[0][i][0] = 0;\n    }\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<W; j++) {\n        for (int m=0; m<=M; m++) {\n          if (dp[i][j][m] == INF) continue;\n          for (int nj=0; nj<W; nj++) {\n            if (T[i+1][nj] > 0) {\n              dp[i+1][nj][m] = min(dp[i+1][nj][m], dp[i][j][m] + abs(j - nj)*(T[i+1][nj] + T[i][j]));\n            }\n            if (T[i+2][nj] > 0) {\n              dp[i+2][nj][m+1] = min(dp[i+2][nj][m], dp[i][j][m] + abs(j - nj)*(T[i+2][nj] + T[i][j]));\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    for (int i=0; i<W; i++) {\n      for (int m=0; m<=M; m++) {\n        ans = min(ans, dp[N-1][i][m]);\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<11;i++){\n\t\t\tve[0].push_back(MP(i,0));\n\t\t\tdp[T][i-1][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[1].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=M;j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tif(M!=0)for(int i=0;i<M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N-1].size();j++){\n\t\t\t\tres=min(res,dp[T][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\t// your code goes here\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >>m;\n\t\tif(n==0){\n\t\t\treturn 0;\n\t\t}\n\t\tint k[152];\n\t\tint x[152][10],d[152][10];\n\t\tk[0]=1;x[0][0]=0;d[0][0]=0;\n\t\tk[n+1]=1;x[n+1][0]=0;d[n+1][0]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> k[i];\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tcin >> x[i][j] >> d[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r[152][10][76];\n\t\tint mr[152];\n\t\tmr[n+1]=0;mr[n]=0;\n\t\tr[n+1][0][0]=0;\n\t\tfor(int j=0;j<k[n];j++){\n\t\t\tr[n][j][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tmr[i]=mr[i+2]+1;\n\t\t\tif(mr[i]>m){mr[i]=m;}\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\tr[i][j][s]=-1;\n\t\t\t\t}\n\t\t\t\tfor(int jj=0;jj<k[i+1];jj++){\n\t\t\t\t\tint dr=(d[i][j]+d[i+1][jj])*abs(x[i][j]-x[i+1][jj]);\n\t\t\t\t\t//if(dr==0){cout << '<' << i << ',' << j << '>' << '<' << i+1 << ',' << jj << '>' << endl;}\n\t\t\t\t\t//if(i==5 && j==6){cout << jj << ',' << dr << endl;}\n\t\t\t\t\tif(i==0){dr=0;}\n\t\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\t\tif(r[i][j][s]==-1 || (r[i+1][jj][s]!=-1 && r[i+1][jj][s]+dr<r[i][j][s])){\n\t\t\t\t\t\t\tr[i][j][s]=r[i+1][jj][s]+dr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int jj=0;jj<k[i+2];jj++){\n\t\t\t\t\tint dr=(d[i][j]+d[i+2][jj])*abs(x[i][j]-x[i+2][jj]);\n\t\t\t\t\tif(i==0 || i==n-1){dr=0;}\n\t\t\t\t\tfor(int s=1;s<=mr[i];s++){\n\t\t\t\t\t\tif(r[i][j][s]==-1 || (r[i+2][jj][s-1]!=-1 && r[i+2][jj][s-1]+dr<r[i][j][s])){\n\t\t\t\t\t\t\tr[i][j][s]=r[i+2][jj][s-1]+dr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tcout << '(';\n\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\tcout << r[i][j][s] << ' ';\n\t\t\t\t}\n\t\t\t\tcout << ')';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tint rr=-1;\n\t\tfor(int s=0;s<=m;s++){\n\t\t\tif(rr==-1 || (r[0][0][s]!=-1 && r[0][0][s]<rr)){\n\t\t\t\trr=r[0][0][s];\n\t\t\t}\n\t\t}\n\t\tcout << rr << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 2000000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nlong long d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  long long ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n+1){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n+1){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dijkstra(0) << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define INF (100000000)\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ABS(a) ((a>0)?(a):(-(a)))\n\nint danger(P s, P t) {\n    return (s.second+t.second)*ABS(s.first-t.first);\n}\n\nvoid solve(int n,int m) {\n    vector<P> mp[n];\n    vector<int> ki(n,0);\n\n    for(int i=0; i<n; ++i) {\n        cin >> ki[i];\n        for(int j=0; j<ki[i]; ++j) {\n            int a,b;\n            cin >> a >> b;\n            mp[i].push_back(P(a,b));\n        }\n    }\n\n    int dp[m+1][n][10];\n    for(int i=0; i<=m; ++i)\n        for(int j=0; j<n; ++j)\n            for(int k=0; k<10; ++k)\n                dp[i][j][k]=INF;\n    \n    for(int k=0; k<ki[0]; ++k) dp[0][0][k]=0;\n    if(m>0) for(int k=0; k<ki[1]; ++k) dp[1][1][k]=0;\n\n    int ans=INF;\n\n    for(int i=0; i<=m; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<ki[j]; ++k) {\n                if(j==n-1 || (j==n-2 && i<m)) ans=MIN(ans,dp[i][j][k]);\n                if(j==n-1) continue;\n                for(int l=0; l<ki[j+1]; ++l) {\n                    dp[i][j+1][l]=MIN(dp[i][j+1][l],dp[i][j][k]+danger(mp[j][k],mp[j+1][l]));\n                }\n                if(j==n-2 || i==m) continue;\n                for(int l=0; l<ki[j+2]; ++l) {\n                    dp[i+1][j+2][l]=MIN(dp[i+1][j+2][l],dp[i][j][k]+danger(mp[j][k],mp[j+2][l]));\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return;\n}\n\n\nint main() {\n    while(true) {\n        int n,m;\n        cin >> n >> m;\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\n/* do your best */\n\n\nbool solve() {\n\n  int n, m; cin >> n >> m;\n  if (n == 0 and m == 0) {\n    return false;\n  }\n\n  vector<vector<pair<int, int>>> info(n); // info[i] := 行 i {位置，cost}\n\n  for (int i = 0; i < n; i++) {\n    int k; cin >> k;\n    for (int j = 0; j < k; j++) {\n      int pos, cost; cin >> pos >> cost;\n      info[i].push_back({pos, cost});\n    }\n  }\n  \n  vector<vector<vector<lint>>> dp(n, vector<vector<lint>> (1001, vector<lint> (m + 1, INF)));\n  for (int j = 0; j < info[0].size(); j++) {\n    int pos = info[0][j].first;\n    dp[0][pos][0] = 0;\n  }\n\n  for (int j = 0; j < info[1].size(); j++) {\n    int pos = info[1][j].first;\n    dp[1][pos][1] = 0;\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    for (int j = 0; j < info[i].size(); j++) {\n      for (int k = 0; k <= m; k++) {\n        // cerr << \"kudan : \" << dp[2][1][1] << endl;\n        int curPos = info[i][j].first;\n        lint cost1 = info[i][j].second;\n        lint curCost = dp[i][curPos][k];\n\n        // 普通のジャンプ\n        for (int j = 0; j < info[i + 1].size(); j++) {\n          int nxtPos = info[i + 1][j].first;\n          lint cost2 = info[i + 1][j].second;\n          lint nxtCost = (cost1 + cost2) * (lint)abs(curPos - nxtPos);\n          dp[i + 1][nxtPos][k] = min(dp[i + 1][nxtPos][k], curCost + nxtCost);\n        }\n\n        // 2 段飛ばしジャンプ\n        if (i + 2 < n and k < m) {\n          for (int j = 0; j < info[i + 2].size(); j++) {\n            int nxtPos = info[i + 2][j].first;\n            // cerr << \"i = \" << i << \", curPos = \" << curPos << \", nxtPos = \" << nxtPos << endl;\n            lint cost2 = info[i + 2][j].second;\n            lint nxtCost = (cost1 + cost2) * (lint)abs(curPos - nxtPos);\n            // cerr << \"curCost = \" << curCost << \", nxtCost = \" << nxtCost << endl;\n            // cerr << \"before: \" << i + 2 << \" \" << nxtPos << \" \" << k + 1 << \", \" << dp[i + 2][nxtPos][k + 1] << endl;\n            dp[i + 2][nxtPos][k + 1] = min(dp[i + 2][nxtPos][k + 1], curCost + nxtCost);\n            // cerr << \"after: \" << i + 2 << \" \" << nxtPos << \" \" << k + 1 << \", \" << dp[i + 2][nxtPos][k + 1] << endl;\n          }\n        }\n      }\n    }\n  }\n\n  lint ans = INF;\n  for (int j = 0; j < info[n - 1].size(); j++) {\n    for (int k = 0; k <= m; k++) {\n      int pos = info[n - 1][j].first;\n      ans = min(ans, dp[n - 1][pos][k]);\n    }\n  }\n\n  for (int j = 0; j < info[n - 2].size(); j++) {\n    for (int k = 0; k < m; k++) {\n      int pos = info[n - 2][j].first;\n      ans = min(ans, dp[n - 2][pos][k]);\n    }\n  }\n\n  cout << ans << endl;\n  return true;\n}\n\n\nint main() {\n  \n  while (1) {\n    if (!solve()) break;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 1000000000\nint n,m;\nint d[76][150][10];\nint r[150][10];\nint f[150][10];\nint c[150];\nint i,j,k,l;\nint t;\nint a,b;\nint w;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint max(int a,int b){\n\tif(a<=b)return b;\n\telse return a;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)return 0;\n\t\tw=0;\n\t\tfor(i=0;i<150;i++)c[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j=0;j<t;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\tr[i][a-1]=b;\n\t\t\t\tf[i][c[i]++]=a-1;\n\t\t\t\tw=max(w,a);\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<=m;k++)for(i=0;i<n;i++)for(j=0;j<c[i];j++){\n\t\t\tif(i==0)d[k][i][f[i][j]]=0;\n\t\t\telse d[k][i][f[i][j]]=INF;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tif(i>1){\n\t\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\t\tfor(l=0;l<c[i-2];l++){\n\t\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j+1][i-2][f[i-2][l]]+abs(f[i][k]-f[i-2][l])*(r[i][f[i][k]]+r[i-2][f[i-2][l]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tfor(k=0;k<c[i];k++){\n\t\t\t\t\tfor(l=0;l<c[i-1];l++){\n\t\t\t\t\t\td[j][i][f[i][k]]=min(d[j][i][f[i][k]],d[j][i-1][f[i-1][l]]+abs(f[i][k]-f[i-1][l])*(r[i][f[i][k]]+r[i-1][f[i-1][l]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<=m;i++)for(j=0;j<c[n-1];j++){\n\t\t\tans=min(ans,d[i][n-1][f[n-1][j]]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tX\tfirst\n#define\tSL\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1000000000;\npii river[150][11];\nint memo[150][10][76];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k;\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint x,slip;\tscanf(\"%d%d\",&x,&slip);\n\t\t\t\triver[i][j]=mp(x,slip);\n\t\t\t}\n\t\t\triver[i][k]=mp(-1,-1);\n\t\t}\n\n\t\tfor(int j=0;~river[0][j].X;j++){\n\t\t\tmemo[0][j][0]=0;\n\t\t\tfor(int k=1;k<=m;k++)\tmemo[0][j][k]=inf;\n\t\t}\n\t\tfor(int j=0;~river[1][j].X;j++){\n\t\t\tmemo[1][j][1]=0;\n\t\t}\n\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;~river[i][j].X;j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tmemo[i][j][k]=inf;\n\t\t\t\t\tint cost;\n\t\t\t\t\tfor(int b=0;~river[i-1][b].X;b++){\n\t\t\t\t\t\tif(river[i-1][b].X==inf)\tcontinue;\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-1][b].SL)*abs(river[i][j].X-river[i-1][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-1][b][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i-2<0 || k-1<0)\tcontinue;\n\t\t\t\t\tfor(int b=0;~river[i-2][b].X;b++){\n\t\t\t\t\t\tif(river[i-2][b].X==inf)\tcontinue;\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-2][b].SL)*abs(river[i][j].X-river[i-2][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-2][b][k-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mincost=inf;\n\t\tfor(int j=0;~river[n-1][j].X;j++)for(int k=0;k<=m;k++)\tmincost=min(mincost,memo[n-1][j][k]);\n\t\tfor(int j=0;~river[n-2][j].X;j++)for(int k=0;k<m;k++)\tmincost=min(mincost,memo[n-2][j][k]);\n\t\tprintf(\"%d\\n\",mincost);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst ull INF = 1 << 31;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M;\nstd::vector<P> S[153];\nstd::map<int,int> dp[153][80];// [153][80][1000];\n\null value(const P& lp, const P& rp){\n    return (lp.second+rp.second) * std::abs(lp.first-rp.first);\n}\n\null rec(int y, int x, int t){\n    if(y > N){return 0;}\n    if(dp[y][t][x] != 0){return dp[y][t][x];}\n\n    ull res = INF;\n    REP(i, S[y+1].size()){\n        res = std::min(res, rec(y+1, i, t) + value(S[y][x], S[y+1][i]));\n    }\n\n    if(t < M){\n        REP(i, S[y+2].size()){\n            res = std::min(res, rec(y+2, i, t+1) + value(S[y][x], S[y+2][i]));\n        }\n    }\n\n    return dp[y][t][x] = res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, N+3){\n            S[i].clear();\n\n            REP(j, M+1){\n                dp[i][j].clear();\n            }\n        }\n\n        REP(i, N){\n            int k;\n            std::cin >> k;\n\n            REP(j, k){\n                int x, d;\n                std::cin >> x >> d;\n                x--;\n            \n                S[i+1].push_back(mp(x, d));\n            }\n        }\n\n        REP(i, 1000){\n            S[0].push_back(mp(i, 0));\n            S[N+1].push_back(mp(i, 0));\n            S[N+2].push_back(mp(i, 0));\n        }\n\n        ull res = INF;\n        REP(i, 1000){\n            res = std::min(res, rec(0, i, 0));\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#define X first\n#define Y second\n#define F 1145141919\nusing namespace std;\n\nvector<pair<int,int> > v[160];\nint dp[80][160][12],n,m,k;\n\nint Jump(int a,int b,int c,int d){\n\tif(v[a][b].X==-1||v[c][d].X==-1)return 0;\n\tint ret=abs(v[a][b].X-v[c][d].X);\n\tret*=v[a][b].Y+v[c][d].Y;\n\treturn ret;\n}\n\nint main(){\n\tpair<int,int> p;\n\tp.X=-1,p.Y=-1;\n\tv[0].push_back(p);\n\twhile(cin>>n>>m&&n){\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>k;v[i].clear();\n\t\twhile(k--){\n\t\t\tcin>>p.X>>p.Y;\n\t\t\tv[i].push_back(p);\n\t\t}\n\t}\n\tv[n+1].clear();p.X=-1,p.Y=-1;v[n+1].push_back(p);\n\n\tfor(int i=0;i<80;i++)for(int j=0;j<160;j++)for(int k=0;k<12;k++)dp[i][j][k]=F;\n\n\tfor(int i=0;i<=m;i++)dp[i][0][0]=0;\n\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int f=0;f<=n;f++){\n\t\t\tfor(int g=0;g<v[f].size();g++){\n\t\t\t\tfor(int k=0;k<v[f+1].size();k++){\n\t\t\t\t\tdp[i][f+1][k]=min(dp[i][f+1][k],dp[i][f][g]+Jump(f,g,f+1,k));\n\t\t\t\t}\n\t\t\t\tif(f!=n&&i!=m){for(int k=0;k<v[f+2].size();k++){\n\t\t\t\t\tdp[i+1][f+2][k]=min(dp[i+1][f+2][k],dp[i][f][g]+Jump(f,g,f+2,k));\n\t\t\t\t}}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=F;\n\tfor(int i=0;i<=m;i++){\n\t\tans=min(ans,dp[i][n+1][0]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define M 1005\n#define N 155\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nstruct Node{\n  int x,cost;\n  Node(){};\n  Node(int b,int c){x=b,cost=c;};\n};\n\nstruct Edge{\n  int y,x,cost,flag;\n  Edge(){};\n  Edge(int a,int b,int c,int d){\n    y=a,x=b,cost=c,flag=d;\n  };\n};\n\nint n,m,k,a,b;\nvector<Node> node[N];\nvector<Edge> e[N][M];\nint d[N][N][M];\n\nint dijkstra(int sy,int sx){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int l=0;l<n;l++)d[i][j][l]=INF;\n  d[sy][sx][0]=0;\n  q.push(P1(P(0,0),P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first.first;\n    int mcnt=t.first.second;\n    int y=t.second.first;\n    int x=t.second.second;\n    if(d[mcnt][y][x]<cost)continue;\n    for(int i=0;i<e[y][x].size();i++){\n      int ny=e[y][x][i].y,nx=e[y][x][i].x;\n      int ncost=e[y][x][i].cost,f=e[y][x][i].flag;\n      if(f+mcnt>m)continue;\n      if(d[f+mcnt][ny][nx]>cost+ncost){\n\td[f+mcnt][ny][nx]=cost+ncost;\n\tq.push(P1(P(d[f+mcnt][ny][nx],f+mcnt),P(ny,nx)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<node[n-1].size();i++)\n    for(int j=0;j<=m;j++)\n      res=min(res,d[j][n-1][node[n-1][i].x]);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>k;\n      for(int j=0;j<k;j++){\n\tcin>>a>>b;\n\tnode[i].push_back(Node(a-1,b));\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=i+2;j++){\n\tif(j==n)break;\n\tfor(int l=0;l<node[i].size();l++){\n\t  for(int p=0;p<node[j].size();p++){\n\t    e[i][node[i][l].x].push_back(Edge(j,node[j][p].x,(node[i][l].cost+node[j][p].cost)*abs(node[i][l].x-node[j][p].x),j-i-1));\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<node[0].size();i++)\n      ans=min(ans,dijkstra(0,node[0][i].x));\n    cout<<ans<<endl;\n    for(int i=0;i<N;i++)node[i].clear();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)e[i][j].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#define INF (1000000000)\n#define MOD (1000000007)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\ntypedef vector<long>::iterator VL;\ntypedef vector<long>::iterator VLI;\ntypedef pair<int, int> P;\n\n\nint d[150][1000];\nint dp[150][1000][100];\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tmemset(d, 0, sizeof(d))\n;\t\tfor (int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; j++){\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tx--;\n\t\t\t\tscanf(\"%d\", &d[i][x]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j < 1000; j++){\n\t\t\t\tfor (int k = 0; k < 100; k++){\n\t\t\t\t\tif (i == 0 && d[i][j] && k == 0) dp[i][j][k] = 0;\n\t\t\t\t\telse dp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 1000; j++){\n\t\t\t\tfor (int k = 0; k < 1000; k++){\n\t\t\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\t\t\tif (d[i][j] && d[i + 1][k]){\n\t\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (d[i][j] + d[i + 1][k]) * abs(j - k));\n\t\t\t\t\t\t\t//printf(\"%d\\n\", dp[i + 1][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i < n - 1 && d[i][j] && d[i + 2][k]){\n\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (d[i][j] + d[i + 2][k]) * abs(j - k));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini = INF;\n\t\tfor (int i = 0; i < 1000; i++){\n\t\t\tfor (int j = 0; j <= m; j++){\n\t\t\t\tmini = min(mini, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  vector<int> id[150];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    int num = 0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = 1<<30;\n\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    \n\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n\n    int ans = 1<<30;\n    for(int i=0;i<(int)id[n-1].size();i++)\n      for(int j=0;j<=m;j++)\n\tans = min(ans,g[id[n-1][i]][j]);\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  while (cin >> n >> m, n) {\n    int dp[200][15][100] = {0};\n    vector<pii> G[200];\n\n    for (int i = 1; i <= n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; ++j) {\n        int x, d;\n        cin >> x >> d;\n        G[i].PB(pii(x, d));\n      }\n    }\n    G[0].PB(pii(0, 0));\n    G[n + 1].PB(pii(0, 0));\n\n    fill(dp[1][0], dp[200][0], INF);\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j < G[i].size(); ++j) {\n        for (int k = 0; k <= m; ++k) {\n          for (int dy = 1; dy <= 2; ++dy) {\n            for (int j2 = 0; j2 < G[i + dy].size(); ++j2) {\n              if (dp[i][j][k] == INF) continue;\n              pii p1 = G[i][j], p2 = G[i + dy][j2];\n              int move = abs(p1.first - p2.first), sumd = p1.second + p2.second;\n              if (i == 0 || i + dy == n + 1) sumd = 0;\n              dp[i + dy][j2][k + dy - 1] = min(dp[i + dy][j2][k + dy - 1], dp[i][j][k] + sumd * move);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int i = 0; i <= m; ++i) {\n      ans = min(ans, dp[n + 1][0][i]);\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tX\tfirst\n#define\tSL\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int inf=1000000000;\npii river[150][11];\nint memo[150][10][76];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k;\tscanf(\"%d\",&k);\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint x,slip;\tscanf(\"%d%d\",&x,&slip);\n\t\t\t\triver[i][j]=mp(x,slip);\n\t\t\t}\n\t\t\triver[i][k]=mp(-1,-1);\n\t\t}\n\n\t\tfor(int j=0;~river[0][j].X;j++){\n\t\t\tmemo[0][j][0]=0;\n\t\t\tfor(int k=1;k<=m;k++)\tmemo[0][j][k]=inf;\n\t\t}\n\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;~river[i][j].X;j++){\n\t\t\t\tfor(int k=0;k<=m;k++){\n\t\t\t\t\tmemo[i][j][k]=inf;\n\t\t\t\t\tint cost;\n\t\t\t\t\tfor(int b=0;~river[i-1][b].X;b++){\n\t\t\t\t\t\tint cost=(river[i][j].SL+river[i-1][b].SL)*abs(river[i][j].X-river[i-1][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-1][b][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i-2<0 || k-1<0)\tcontinue;\n\t\t\t\t\tfor(int b=0;~river[i-2][b].X;b++){\n\t\t\t\t\t\tcost=(river[i][j].SL+river[i-2][b].SL)*abs(river[i][j].X-river[i-2][b].X);\n\t\t\t\t\t\tmemo[i][j][k]=min(memo[i][j][k],cost+memo[i-2][b][k-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint mincost=inf;\n\t\tfor(int j=0;~river[n-1][j].X;j++)for(int k=0;k<=m;k++)\tmincost=min(mincost,memo[n-1][j][k]);\n\t\tfor(int j=0;~river[n-2][j].X;j++)for(int k=0;k<m;k++)\tmincost=min(mincost,memo[n-2][j][k]);\n\t\tprintf(\"%d\\n\",mincost);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nint dp[10][150][80];\nconst int INF = 1 << 30;\nconst int MAX_X = 10;\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n >> m && n)\n\t{\n\t\trep(x,MAX_X) rep(y,n) rep(d,m+1) dp[x][y][d] = INF;\n\t\tvector<vint> r(10, vint(n));\n\t\trep(i,MAX_X)rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tr[x-1][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[x][0][m] = 0;\n\n\t\tfor(int y = 1; y < n; y++) for(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ÊíWv\n\t\t\t\trep(nx, MAX_X) rep(d, m+1) //ë¯xðiÁÄ¢¯Î} èÂ\n\t\t\t\t\tif(dp[nx][y-1][d] != INF)\n\t\t\t\t\t\tchmin(dp[x][y][d], dp[nx][y-1][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// êiÆÎµ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[nx][y-2][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[x][y][d-1], dp[nx][y-2][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\n\t\tint res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[x][n-1][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[x][n-2][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n \nconst int INF = 1<<29;\n \nint dp[150][10][77];\nint stones[150][10][2];\nint col[150];\n \nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n   \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tcin >> stones[i][j][0] >> stones[i][j][1];\n      }\n    }\n \n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i+1]) {\n\tint x_now = stones[i+1][j][0], d_now = stones[i+1][j][1];\n\tREP(k, col[i]) {\n\t  int x_prev = stones[i][k][0], d_prev = stones[i][k][1];\n\t  int safe = (d_now + d_prev) * abs(x_now - x_prev);\n\t  REP(m, M+1) {\n\t    dp[i+1][j][m] = min(dp[i+1][j][m], dp[i][k][m] + safe);\n\t  }\n\t}\n\tif (i > 0) {\n\t  REP(k, col[i-1]) {\n\t    int x_prev = stones[i-1][k][0], d_prev = stones[i-1][k][1];\n\t    int safe = (d_now + d_prev) * abs(x_now - x_prev);\n\t    REP(m, M) {\n\t      dp[i+1][j][m+1] = min(dp[i+1][j][m+1], dp[i-1][k][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n \n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 152;\nconst int MAX_K = 12;\n\nint a[MAX_N];\nint dp[MAX_N][(MAX_N+1)/2][MAX_K];\nint n,m,K;\nvector<int> S[MAX_N];\nvector<int> T[MAX_N];\n\nint main()\n{\n\twhile(1){\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0){\n\t\tbreak;\n\t}\n\trep(i,n+1){\n\t\tS[i].clear();\n\t\tT[i].clear();\n\t}\n\trep(i,n){\n\t\tscanf(\"%d\",&K);\n\t\trep(j,K){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tS[i].push_back(x-1);\n\t\t\tT[i].push_back(y);\n\t\t}\n\t}\n\trep(i,S[n-2].size()){\n\t\tS[n].push_back(S[n-2][i]);\n\t\tT[n].push_back(0);\n\t}\n\trep(i,S[n-1].size()){\n\t\tS[n].push_back(S[n-1][i]);\n\t\tT[n].push_back(0);\n\t}\n\tfill(dp[0][0],dp[n+1][0],INF);\n\trep(j,S[0].size()){\n\t\tdp[0][j][0] = 0;\n\t}\n\trep(j,S[1].size()){\n\t\trep(l,S[0].size()){\n\t\t\tdp[1][j][0] = min(dp[1][j][0],(T[0][l]+T[1][j])*abs(S[1][j]-S[0][l]));\n\t\t}\n\t\tif(m>=1){\n\t\t\tdp[1][j][1] = 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\trep(j,S[i+1].size()){\n\t\t\trep(k,m+1){\n\t\t\t\trep(l,S[i].size()){\n\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i][l][k]+(T[i][l]+T[i+1][j])*abs(S[i+1][j]-S[i][l]));\n\t\t\t\t}\n\t\t\t\tif(k>=1){\n\t\t\t\t\trep(l,S[i-1].size()){\n\t\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i-1][l][k-1]+(T[i-1][l]+T[i+1][j])*abs(S[i+1][j]-S[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(j,S[n].size()){\n\t\trep(k,m+1){\n\t\t\tans = min(ans,dp[n][j][k]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nstruct P {\n\tint  p,s;\n}; \nint n, m, k;\nvector<P>a[160];\nP u;\nlong long dp[160][20][160];\nlong long solve(int i, int p, int m) {\n\tif (i == n) return 0;\n\tlong long sum = 8000000000;\n\tfor (int j = 0; j < a[i + 1].size(); j++) {\n\t\tlong long res = (a[i][p].p - a[i + 1][j].p);\n\t\tres = max(res, 0 - res);\n\t\tres *= (a[i + 1][j].s + a[i][p].s);\n\t\tif (dp[i + 1][j][m] != -1) {\n\t\t\tsum = min(sum, res + dp[i + 1][j][m]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, res+(dp[i+1][j][m]=solve(i + 1, j, m)));\n\t\t}\n\t}\n\tif (m > 0 && i + 2 <= n) {\n\t\tfor (int j = 0; j < a[i + 2].size(); j++) {\n\t\t\tlong long res = (a[i + 2][j].p - a[i][p].p);\n\t\t\tres = max(0 - res, res);\n\t\t\tres *= (a[i][p].s + a[i + 2][j].s);\n\t\t\tif (dp[i + 2][j][m - 1] != -1) {\n\t\t\t\tsum = min(sum, res + dp[i + 2][j][m - 1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = min(sum, res + (dp[i + 2][j][m - 1] = solve(i + 2, j, m - 1)));\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m&&!(n==0&&m==0)) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tcin >> u.p >> u.s;\n\t\t\t\ta[i].push_back(u);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\tfor (int x = 0; x < 160; x++) dp[i][j][x] = -1;\n\t\t\t}\n\t\t}\n\t\tlong long sum = 800000000000000;\n\t\tfor (int i = 0; i < a[1].size(); i++) {\n\t\t\tsum = min(sum, solve(1, i, m));\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct P{\n  int x,c;\n  P(int x,int c):x(x),c(c){}\n};\nint n;\nvector<P> s[155];\nint dp[155][11][77];\nint solve(int y,int i,int m){\n  if(y >= n) return 0;\n  if(dp[y][i][m] >= 0) return dp[y][i][m];\n\n  int ret = 1 << 22;\n  for(int j = 0; j < (int)s[y+1].size(); j++){\n    ret = min(ret,solve(y+1,j,m) + ((y)?(s[y][i].c + s[y+1][j].c) * abs(s[y][i].x - s[y+1][j].x):0));\n  }\n  if(m){\n    for(int j = 0; j < (int)s[y+2].size(); j++){\n      ret = min(ret,solve(y+2,j,m-1) + ((y)?(s[y][i].c + s[y+2][j].c) * abs(s[y][i].x - s[y+2][j].x):0));\n    }\n  }\n  return dp[y][i][m] = ret;\n}\nint main(void){\n  while(1){\n    int m;\n    scanf(\"%d%d\",&n,&m); if(!n) break;\n    memset(dp,-1,sizeof(dp));\n    for(int i = 1; i <= n; i++){\n      s[i].clear();\n      int k;\n      scanf(\"%d\",&k);\n      for(int j = 0; j < k; j++){\n\tint x,d;\n\tscanf(\"%d%d\",&x,&d);\n\ts[i].push_back(P(x,d));\n      }\n    }\n    s[0].push_back(P(0,0));\n    /*\n    for(int i = 0; i < (int)s[0].size(); i++){\n      ret = min(ret,solve(0,i,m));\n    }\n    */\n    printf(\"%d\\n\",solve(0,0,m));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define fr first\n#define sc second\n#define INF 100000000\ntypedef pair<int,int> Pi;\ntypedef pair< Pi,pair<Pi,int> > P;\nstruct Edge{\n  int to,denger;\n  Edge(){}\n  Edge(int to,int denger):to(to),denger(denger){};\n};\nint n,m;\nint m_cost[150][11][(150+1)/2+1];\nvector<vector<Edge> > info;\nint Dijkstra();\nint main(){\n  while(cin >> n >> m && n||m){\n    info.resize(n);\n    for(int i=0,k;i<n;i++){\n      cin >> k;\n      for(int j=0,t,d;j<k;j++){\n        cin >> t >> d;\n        info[i].push_back(Edge(t,d));\n      }\n    }\n    cout << Dijkstra() << endl;\n    info.clear();\n  }\n}\n  int Dijkstra(){\n    for(int i=0;i<150;i++){\n      for(int j=0;j<11;j++){\n        for(int k=0;k<(150+1)/2+1;k++){\n        m_cost[i][j][k] = INF;\n        }\n      }\n    }\n    int ans = INF;\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0,l=info[0].size();i<l;i++){\n    que.push(P(Pi(0,m),make_pair(Pi(0,info[0][i].to),info[0][i].denger)));\n    m_cost[0][i][m] = 0;\n  }\n  if(m != 0){\n    for(int i=0,l=info[1].size();i<l;i++){\n      que.push(P(Pi(0,m-1),make_pair(Pi(1,info[1][i].to),info[1][i].denger)));\n      m_cost[1][i][m-1] = 0;\n    }\n  }\n  while(!que.empty()){\n    P p = que.top();\n    int den = p.fr.fr,limit = p.fr.sc,slip=p.sc.sc;\n    Pi pt = Pi(p.sc.fr.fr,p.sc.fr.sc);\n    que.pop();\n    if(pt.fr + 1 == n){\n      ans = min(ans,den);\n      return ans;\n    }\n    for(int j=1;j<3;j++){\n      if(j==2 && (limit == 0 || pt.fr+1==n)) break;\n      if(j==2 && pt.fr + 2 == n){\n        ans = min(ans,den);\n        return ans;\n      }\n      if(j==1 && pt.fr + 1 == n){\n        ans = min(ans,den);\n        return ans;\n      }\n      for(int i=0,l=info[pt.fr+j].size();i<l;i++){\n        int next_now = info[pt.fr+j][i].to;\n        int next_den = info[pt.fr+j][i].denger;\n        int hmhm = den + (slip + next_den) * abs(next_now - pt.sc);\n        if(hmhm < m_cost[pt.fr+j][i][limit-(j-1)]){\n          m_cost[pt.fr+j][i][limit-(j-1)] = hmhm;\n          que.push(P(Pi(hmhm,limit-(j-1)),make_pair(Pi(pt.fr+j,next_now),next_den)));\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    if(i==2)dp[i][j][l]=0;\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    int ans=INF;\n    /*\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n    */\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100001\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int inf = 1e9;\nconst ll INF = 1e18;\n#define B 100\n\nint dp[151][11][80];\nint a[151][11], b[151][11];\nint main(){\n\tint n, m, t, t1, t2;\n\tscanf(\"%d%d\", &n, &m);\n\t//fill((int*)a, (int*)(a+151), 1);\n\tfill((int*)b, (int*)(b+151), inf);\n\tfor(int i = 2;i <= 150;i++){\n\t\trep(j,11)rep(k,80)dp[i][j][k] = inf;\n\t\trep(j,11)rep(k,80)if(k != m)dp[2][j][k] = 0;\n\t}\n\trrep(i,n){\n\t\tscanf(\"%d\", &t);\n\t\trep(j,t){\n\t\t\tscanf(\"%d%d\", &t1, &t2);\n\t\t\ta[i][j] = t1;\n\t\t\tb[i][j] = t2;\n\t\t}\n\t}\n\t\n\tint d1, d2;\n\tfor(int i = 2;i <= n;i++){\n\t\tfor(int j = 0;j <= 10;j++){\n\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\tfor(int u = 0;u <= 10;u++){\n\t\t\t\t\td1 = abs(a[i][j]-a[i-1][u]);\n\t\t\t\t\tt1 = b[i][j]+b[i-1][u];\n\t\t\t\t\td2 = abs(a[i][j]-a[i-2][u]);\n\t\t\t\t\tt2 = b[i][j]+b[i-2][u];\n\t\t\t\t\t\n\t\t\t\t\tif(b[i][j] != inf && b[i-1][u] != inf)\n\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i-1][u][k]+t1*d1);\n\t\t\t\t\tif(k < m && b[i][j] != inf && b[i-2][u] != inf)\n\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i-2][u][k+1]+t2*d2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = inf;\n\tfor(int i = 0;i <= 10;i++)ans = min(ans, dp[n][i][0]);\n\tfor(int i = 0;i <= 10;i++)ans = min(ans, dp[n-1][i][1]);\n\t/*for(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= 10;j++){\n\t\t\tprintf(\"%d \", dp[i][j][0]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 10000000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nlong long d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  long long ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t    e.to=i+2;\n\t    e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+1==n+1){\n\t    e.to=i+1;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t  if(i+2==n+1){\n\t    e.to=i+2;\n\t    e.cost=0;\n\t    G[i].push_back(e);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dijkstra(0) << endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\n\nint k[151];\nvector<pii> stone[150];\nint N, M;\n\nint memo[150][150][10];\n\nint rec(int n, int m, int i)\n{\n    if (n >= N - 1) return 0;\n\n    if (~memo[n][m][i]) return memo[n][m][i];\n\n    int res = inf;\n\n    rep(j, k[n + 1]) {\n        int dist = (stone[n][i].scd + stone[n + 1][j].scd) * abs(stone[n][i].fst - stone[n + 1][j].fst);\n        chmin(res, dist + rec(n + 1, m, j));\n    }\n\n    if (m > 0) {\n        if (n + 2 >= N) return 0;\n        rep(j, k[n + 2]) {\n            int dist = (stone[n][i].scd + stone[n + 2][j].scd) * abs(stone[n][i].fst - stone[n + 2][j].fst);\n            chmin(res, dist + rec(n + 2, m - 1, j));\n        }\n    }\n\n    return memo[n][m][i] = res;\n}\n\nsigned main()\n{\n    while (scanf(\"%d %d\", &N, &M), N || M) {\n        rep(i, N) {\n            scanf(\"%d\", &k[i]);\n\n            stone[i].resize(k[i]);\n\n            rep(j, k[i]) {\n                int x, d; scanf(\"%d %d\", &x, &d);\n                stone[i][j].fst = x, stone[i][j].scd = d;\n            }\n        }\n\n        int ans = inf;\n\n        rep(i, k[0]) {\n            memset(memo, -1, sizeof(memo));\n            chmin(ans, rec(0, M, i));\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1LL << 60\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nvector<P>St[256];\nint N, M;\nll dp[256][16][128];\n\nll dfs(int n, int x, int m){\n  if(n>=N-1) return 0;\n  if(n>=N-2 && m) return 0;\n  ll &res = dp[n][x][m];\n  if(res >= 0) return res;\n  res = INF;\n  int pos = St[n][x].first ,slip = St[n][x].second;\n  rep(i, St[n+1].size()){\n      P tar = St[n+1][i];\n      res = min(res, dfs(n+1, i, m)+(ll)(slip+tar.second)*(ll)(abs(pos-tar.first)));\n  }\n  if(m && n < N-1){\n    rep(i, St[n+2].size()){\n      P tar = St[n+2][i];\n      res = min(res, dfs(n+2, i, m-1)+(ll)(slip+tar.second)*(ll)(abs(pos-tar.first)));\n    }\n  }\n  //  cout << n << \" \" << x << \" \"<< m <<\" \" << res << endl;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &N, &M) && N){\n    int k, x, d;\n    memset(dp, -1, sizeof(dp));\n    rep(i,N) St[i].clear();\n    rep(i, N){\n      scanf(\"%d\", &k);\n      rep(j,k){\n\tscanf(\"%d%d\", &x, &d);\n\tSt[i].push_back(P(x, d));\n      }\n    }\n    \n    ll res = INF;\n    rep(i, St[0].size()) res = min(res, dfs(0, i, M));\n    rep(i, St[1].size()) res = min(res, dfs(1, i, M-1));\n\n    printf(\"%lld\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\n\nint n, m;\nint dp[150][80][10];\nvector<int> pos[150];\nvector<int> risk[150];\n\nint Abs(int x, int y){\n\tif(x > y) return x-y;\n\telse return y-x;\n}\n\nvoid solve(){\n\tfor(int i = 0; i < 150; i++){\n\t\tfor(int j = 0; j < 10; j++){\n\t\t\tfor(int k = 0; k < 80; k++){\n\t\t\t\tif(i != 0) dp[i][k][j] = INF;\n\t\t\t\telse dp[i][k][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint t; scanf(\"%d\", &t);\n\t\tfor(int j = 0; j < t; j++){\n\t\t\tint x, d; scanf(\"%d%d\", &x, &d);\n\t\t\tx--;\n\t\t\tpos[i].push_back(x);\n\t\t\trisk[i].push_back(d);\n\t\t}\n\t}\n\tfor(int i = 0; i < n-1; i++){\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tfor(int k = 0; k < risk[i+1].size(); k++){\n\t\t\t\tfor(int l = 0; l < risk[i].size(); l++){\n\t\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i][j][l]+(risk[i+1][k]+risk[i][l])*Abs(pos[i+1][k],pos[i][l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(i != n-2){\n\t\t\tfor(int j = 0; j <= m-1; j++){\n\t\t\t\tfor(int k = 0; k < risk[i+2].size(); k++){\n\t\t\t\t\tfor(int l = 0; l < risk[i].size(); l++){\n\t\t\t\t\t\tdp[i+2][j+1][k] = min(dp[i+2][j+1][k],dp[i][j][l]+(risk[i+2][k]+risk[i][l])*Abs(pos[i+2][k],pos[i][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\t//printf(\"%d\\n\", risk[n-1].size());\n\tfor(int i = 0; i <= m; i++){\n\t\tfor(int j = 0; j < risk[n-1].size(); j++){\n\t\t\tans = min(dp[n-1][i][j],ans);\n\t\t\t//printf(\"%d \", dp[n-1][i][j]);\n\t\t}\n\t}\n\t/*\n\tprintf(\"%d\\n\", ans);\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tfor(int k = 0; k < risk[i].size(); k++){\n\t\t\t\tprintf(\"%d \", dp[i][j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tif(ans == INF) ans = -1;\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m),n||m) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 100001\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int inf = 1e9;\nconst ll INF = 1e18;\n#define B 100\n\nint dp[151][11][80];\nint a[151][11], b[151][11];\nint main(){\n\tint n, m, t, t1, t2;\n\twhile(1){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n)break;\n\t\tfill((int*)b, (int*)(b+151), inf);\n\t\tfor(int i = 2;i <= 150;i++){\n\t\t\trep(j,11)rep(k,80)dp[i][j][k] = inf;\n\t\t\trep(j,11)rep(k,80)if(k != m)dp[2][j][k] = 0;\n\t\t}\n\t\trrep(i,n){\n\t\t\tscanf(\"%d\", &t);\n\t\t\trep(j,t){\n\t\t\t\tscanf(\"%d%d\", &t1, &t2);\n\t\t\t\ta[i][j] = t1;\n\t\t\t\tb[i][j] = t2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint d1, d2;\n\t\tfor(int i = 2;i <= n;i++){\n\t\t\tfor(int j = 0;j <= 10;j++){\n\t\t\t\tfor(int k = 0;k <= m;k++){\n\t\t\t\t\tfor(int u = 0;u <= 10;u++){\n\t\t\t\t\t\td1 = abs(a[i][j]-a[i-1][u]);\n\t\t\t\t\t\tt1 = b[i][j]+b[i-1][u];\n\t\t\t\t\t\td2 = abs(a[i][j]-a[i-2][u]);\n\t\t\t\t\t\tt2 = b[i][j]+b[i-2][u];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b[i][j] != inf && b[i-1][u] != inf)\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i-1][u][k]+t1*d1);\n\t\t\t\t\t\tif(k < m && b[i][j] != inf && b[i-2][u] != inf)\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k], dp[i-2][u][k+1]+t2*d2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor(int i = 0;i <= 10;i++)ans = min(ans, dp[n][i][0]);\n\t\tfor(int i = 0;i <= 10;i++)ans = min(ans, dp[n-1][i][1]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint sz[200];\nP stone[200][20];\nint dp[200][20][200];\nint main(){\n\tint n, m;\n\tifstream cin(\"2008-ho-t4-in3\");\n\tofstream cout(\"output.txt\");\n\n\twhile(cin >> n >> m && (n || m)){\n\t\tfill(sz, sz + 200, 0);\n\t\tfill(&dp[0][0][0], &dp[199][19][199] + 1, INF);\n\t\tdp[0][0][m] = 0;\n\t\tint res = INF;\n\t\tsz[0] = sz[n+1] = sz[n+2] = 1;\n\t\trep(i, n){\n\t\t\tcin >> sz[i+1];\n\t\t\trep(j, sz[i+1]){\n\t\t\t\tint x, r;\n\t\t\t\tcin >> x >> r;\n\t\t\t\tstone[i+1][j] = P(x, r);\n\t\t\t}\n\t\t}\n\n\t\trep2(i, 1, n + 3){\n\t\t\trep(j, sz[i]){\n\t\t\t\trep(k, m + 1){\n\t\t\t\t\trep(l, sz[i-1]){\n\t\t\t\t\t\tint cost = (i > n || i == 1) ? 0 :\n\t\t\t\t\t\t\tabs(stone[i][j].first - stone[i-1][l].first)\n\t\t\t\t\t\t\t * (stone[i][j].second + stone[i-1][l].second);\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i-1][l][k] + cost, dp[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\trep(l, sz[i-2]){\n\t\t\t\t\t\tint cost = (i <= 2 || n < i) ? 0 : \n\t\t\t\t\t\t\tabs(stone[i][j].first - stone[i-2][l].first) * (stone[i][j].second + stone[i-2][l].second);\n\t\t\t\t\t\tdp[i][j][k] = (i == 1) ? 0 : min(dp[i-2][l][k+1] + cost, dp[i][j][k]); \t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep2(i, n+1, n+3)rep(j, m+1) res = min(res, dp[i][0][j]);\n\t\tcout << res << endl;\n\t}\n\tcin.close();\n\tcout.close();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) REP(i,0,n)\n#define f first\n#define s second\n#define mpi(l,m,n,o) make_pair(make_pair(l,m),make_pair(n,o))\n#define pi pair<pair<int,int>,pair<int,int> >\nusing namespace std;\nint in(){int x; scanf(\"%d\",&x); return x;}\npriority_queue<pi,vector<pi >,greater<pi > >Q;//cost,y,x,slip\nint main(void){\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m),n+m){\n      vector<vector<int> > pos(151);\n      vector<vector<int> > cos(151);\n      int flag[151][11][76] = {0};\n      while(Q.size()) Q.pop();\n      rep(i,n){\n         int x = in();\n         rep(j,x){\n            pos[i].push_back(in());\n            cos[i].push_back(in());\n         }\n      }\n\n      rep(i,pos[0].size()){\n         Q.push(mpi(0,0,i,0));\n      }\n      rep(i,pos[1].size()){\n         if(m != 0){\n            Q.push(mpi(0,1,i,1));\n         }\n      }\n\n      int ans = 0;\n      while(Q.size()){\n         pi p = Q.top(); Q.pop();\n         if(p.f.s == n-1){ans = p.f.f; break;}\n         if(p.f.s == n-2 && m > p.s.s){ans = p.f.f; break;}\n\n         if(flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] == 1) continue;\n         flag[p.f.s][pos[p.f.s][p.s.f]][p.s.s] = 1;\n\n         rep(i,pos[p.f.s+1].size()){\n            Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+1][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+1][i]),p.f.s+1,i,p.s.s));\n         }\n\n         rep(i,pos[p.f.s+2].size()){\n            if(p.s.s < m) Q.push(mpi(p.f.f+(cos[p.f.s][p.s.f]+cos[p.f.s+2][i])*abs(pos[p.f.s][p.s.f]-pos[p.f.s+2][i]),p.f.s+2,i,p.s.s+1));\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  ll n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    if(i==2)dp[i][j][l]=0;\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    //dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    /*\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n    */\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstdlib>\n\n#define ft first\n#define sd second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 99999;\nint n, m;\nmap<int, vector<P> > mpp;\n\nint solve()\n{\n  int res = inf, dp[152][11][80];\n  vector<P> v1, v2;\n \n  fill(&dp[0][0][0], &dp[152][0][0], inf);\n\n  v1 = mpp[1];\n  for(int i = 0; i < v1.size(); i++)\n    dp[1][v1[i].ft][m] = 0;\n  v1 = mpp[2];\n  for(int i = 0; i < v1.size(); i++)\n    dp[0][v1[i].ft][0] = 0;\n\n\n  for(int i = 1; i < n; i++){\n    v1 = mpp[i];\n    v2 = mpp[i+1];\n    for(int j = m; j >= 0; --j)\n      for(int k = 0; k < v1.size(); k++)\n\tfor(int l = 0; l < v2.size(); l++)\n\t  dp[i+1][v2[l].ft][j] = min(dp[i+1][v2[l].ft][j], dp[i][v1[k].ft][j]+(v1[k].sd+v2[l].sd)*abs(v1[k].ft-v2[l].ft));\n\n    if(i < n-1){\n      v2 = mpp[i+2];\n      for(int j = m; j > 0; --j)\n\tfor(int k = 0; k < v1.size(); k++)\n\t  for(int l = 0; l < v2.size(); l++)\n\t    dp[i+2][v2[l].ft][j-1] = min(dp[i+2][v2[l].ft][j-1], dp[i][v1[k].ft][j]+(v1[k].sd+v2[l].sd)*abs(v1[k].ft-v2[l].ft));\n    }\n  }\n\n  for(int i = 0; i <= 10; i++){\n    for(int j = 0; j <= m; j++)\n      res = min(res, dp[n][i][j]);\n    for(int j = 1; j <= m; ++j)\n      res = min(res, dp[n-1][i][j]);\n  }\n\n  return res;\n}\n\nint main()\n{\n  int s, t, u;\n  while(cin>>n>>m && (n+m)){\n    for(int i = 1; i <= n; i++){\n      cin >> u;\n      vector<P> vec;\n      while(u--){\n\tcin >> s >> t;\n\tvec.push_back(P(s, t));\n      }\n      mpp[i] = vec;\n    }\n\n    cout << solve() << endl;\n    mpp.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector<int> K(n);\n    vector<vector<long long>> X(n), D(n);\n    vector<vector<vector<long long>>> dp(n);\n    long long INF = 1e18;\n\n    for(int i = 0; i < n; ++i){\n      cin >> K[i];\n      for(int j = 0; j < K[i]; ++j){\n        int x, d;\n        cin >> x >> d;\n        X[i].emplace_back(x);\n        D[i].emplace_back(d);\n        dp[i].emplace_back(m+1,INF);\n      }\n    }\n\n    for(int i = 0; i < K[0]; ++i){\n      dp[0][i][0] = 0;\n    }\n    if(m){\n      for(int i = 0; i < K[1]; ++i){\n        dp[1][i][1] = 0;\n      }\n    }\n\n    for(int i = 0; i < n-1; ++i){\n      for(int j = 0; j < K[i]; ++j){\n        long long x = X[i][j], d = D[i][j];\n        for(int k = 0; k <= m; ++k){\n          if(dp[i][j][k] >= INF)\n            continue;\n\n          for(int l = 0; l < K[i+1]; ++l)\n            dp[i+1][l][k] = min(dp[i+1][l][k], dp[i][j][k]+(d+D[i+1][l])*abs(X[i+1][l]-x));\n\n          if(k < m and i+2 < n){\n            for(int l = 0; l < K[i+2]; ++l)\n              dp[i+2][l][k+1] = min(dp[i+2][l][k+1], dp[i][j][k]+(d+D[i+2][l])*abs(X[i+2][l]-x));\n          }\n        }\n      }\n    }\n    \n    long long ans = INF;\n    for(int i = n-2; i < n; ++i){\n      for(int j = 0; j < K[i]; ++j){\n        for(int k = 0; k <= m; ++k){\n          if(i == n-2 and k == m) continue;\n          ans = min(ans,dp[i][j][k]);\n        }\n      }\n    }\n    \n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\n#define int ll\nint dp [1502] [152];\nint n, m, s;\nvector<vector<int>> mp;\nvector<pll> st;\nint func(int pos, int stnum, int spc) {\n\tif (spc == m+1)\n\t\treturn -1;\n\tif (stnum == s)\n\t\treturn 0;\n\tif (dp[stnum][spc] != -1)\n\t\treturn dp[stnum][spc];\n\tint res = LLONG_MAX;\n\tint w = st[stnum].first;\n\tint sb = st[stnum].second;\n\tREP(i, mp[pos+1].size()) {\n\t\tint cand = func(pos + 1, mp[pos + 1][i], spc);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0 && mp[pos+1][i] != s) {\n\t\t\tcand += (sb + st[mp[pos + 1][i]].second)*abs(w-st[mp[pos + 1][i]].first);\n\t\t}\n\t\tres = min(res, cand);\n\t}\n\tREP(i, mp[pos + 2].size()) {\n\t\tint cand = func(pos + 2, mp[pos + 2][i], spc+1);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0 && mp[pos + 2][i] != s) {\n\t\t\tcand += (sb + st[mp[pos + 2][i]].second)*abs(w - st[mp[pos + 2][i]].first);\n\t\t}\n\t\tres = min(res,cand);\n\t}\n\tdp[stnum][spc] = res;\n\tif (res == LLONG_MAX)\n\t\tres = -1;\n\treturn res;\n}\n\nsigned main() {\n\twhile (scanf(\"%lld %lld\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tFill(dp, -1);\n\t\tmp.clear();\n\t\tmp.resize(n+2);\n\t\tst.clear();\n\t\ts = 0;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tscanf(\"%lld\", &c);\n\t\t\tREP(j, c) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%lld %lld\", &a, &b);\n\t\t\t\tmp[i].push_back(s);\n\t\t\t\tst.push_back({ a,b });\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tmp[n].push_back(s);\n\t\tst.push_back({ -1,-1 });\n\t\tst.push_back({ -1,-1 });\n\t\tprintf(\"%lld\\n\", func(-1, s+1, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n//番号とx座標と滑りやすさ\nvector<P1>s[155];\n//滑りやすさ、x座標、y座標\nP1 d[1505];\nint n,m;\n//石番号と残り数を状態にもつdijkstra用配列\nint di[1505][76];\n//beatmania iidx楽しい!!の部分文字列ではなくindexの部分文字列\nint idx=0;\nint main()\n{\n\twhile(1)\n\t{\n\tidx=0;\n\tscanf(\"%d %d\",&n,&m);\n\tif(!n) return 0;\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\ts[i].clear();\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\n\t\t\ts[i].pb(mp(idx,mp(a,b)));\n\t\t\td[idx++]=mp(b,mp(a,i));\n\t\t}\n\t}\n\tfor(int i=0;i<1505;i++)for(int j=0;j<76;j++) di[i][j]=1e9;\n\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\tfor(int i=0;i<s[1].size();i++)\n\t{\n\t\tP1 p=s[1][i];\n\t\tdi[p.first][m]=0;\n\t\tque.push(mp(0,mp(p.first,m)));\n\t}\n\tfor(int i=0;m>0 && i<s[2].size();i++)\n\t{\n\t\tP1 p=s[2][i];\n\t\tdi[p.first][m-1]=0;\n\t\tque.push(mp(0,mp(p.first,m-1)));\n\t}\n\twhile(!que.empty())\n\t{\n\t\tP1 p=que.top();\n\t\tque.pop();\n\t\tint idd=p.second.first;\n\t\tint slip1=d[idd].first;\n\t\tint x=d[idd].second.first;\n\t\tint y=d[idd].second.second;\n\t\tint zan=p.second.second;\n\t\tif(p.first!=di[idd][zan]) continue;\n\t\t\n\t\tfor(int i=0;i<s[y+1].size();i++)\n\t\t{\n\t\t\tP1 pp=s[y+1][i];\n\t\t\tint slip2=pp.second.second;\n\t\t\tint x2=pp.second.first;\n\t\t\tif(di[pp.first][zan]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[pp.first][zan]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[pp.first][zan],mp(pp.first,zan)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;zan>0 && i<s[y+2].size();i++)\n\t\t{\n\t\t\tP1 pp=s[y+2][i];\n\t\t\tint slip2=pp.second.second;\n\t\t\tint x2=pp.second.first;\n\t\t\tif(di[pp.first][zan-1]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[pp.first][zan-1]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[pp.first][zan-1],mp(pp.first,zan-1)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ret=INF;\n\tfor(int j=0;j<s[n].size();j++) for(int i=0;i<76;i++) ret=min(ret,di[s[n][j].first][i]);\n\tfor(int j=0;j<s[n-1].size();j++) for(int i=1;i<76;i++) ret=min(ret,di[s[n-1][j].first][i]);\n\t\n\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n//番号とx座標と滑りやすさ\nvector<P1>s[155];\n//滑りやすさ、x座標、y座標\nP1 d[1505];\nint n,m;\n//石番号と残り数を状態にもつdijkstra用配列\nint di[1505][76];\n//beatmania iidx楽しい!!の部分文字列ではなくindexの部分文字列\nint idx=0;\nint main()\n{\n\t//while(1)\n\t{\n\tidx=0;\n\tscanf(\"%d %d\",&n,&m);\n\tif(!n) return 0;\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\ts[i].clear();\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\n\t\t\ts[i].pb(mp(idx,mp(a,b)));\n\t\t\td[idx++]=mp(b,mp(a,i));\n\t\t}\n\t}\n\tfor(int i=0;i<1505;i++)for(int j=0;j<76;j++) di[i][j]=1e9;\n\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\tfor(int i=0;i<s[1].size();i++)\n\t{\n\t\tP1 p=s[1][i];\n\t\tdi[p.first][m]=0;\n\t\tque.push(mp(0,mp(p.first,m)));\n\t}\n\tfor(int i=0;m>0 && i<s[2].size();i++)\n\t{\n\t\tP1 p=s[2][i];\n\t\tdi[p.first][m-1]=0;\n\t\tque.push(mp(0,mp(p.first,m-1)));\n\t}\n\twhile(!que.empty())\n\t{\n\t\tP1 p=que.top();\n\t\tque.pop();\n\t\tint idd=p.second.first;\n\t\tint slip1=d[idd].first;\n\t\tint x=d[idd].second.first;\n\t\tint y=d[idd].second.second;\n\t\tint zan=p.second.second;\n\t\tif(p.first!=di[idd][zan]) continue;\n\t\t\n\t\tfor(int i=0;i<s[y+1].size();i++)\n\t\t{\n\t\t\tP1 pp=s[y+1][i];\n\t\t\tint slip2=pp.second.second;\n\t\t\tint x2=pp.second.first;\n\t\t\tif(di[pp.first][zan]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[pp.first][zan]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[pp.first][zan],mp(pp.first,zan)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;zan>0 && i<s[y+2].size();i++)\n\t\t{\n\t\t\tP1 pp=s[y+2][i];\n\t\t\tint slip2=pp.second.second;\n\t\t\tint x2=pp.second.first;\n\t\t\tif(di[pp.first][zan-1]>p.first+(slip1+slip2)*abs(x-x2))\n\t\t\t{\n\t\t\t\tdi[pp.first][zan-1]=p.first+(slip1+slip2)*abs(x-x2);\n\t\t\t\tque.push(mp(di[pp.first][zan-1],mp(pp.first,zan-1)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ret=INF;\n\tfor(int j=0;j<s[n].size();j++) for(int i=0;i<76;i++) ret=min(ret,di[s[n][j].first][i]);\n\tfor(int j=0;j<s[n-1].size();j++) for(int i=1;i<76;i++) ret=min(ret,di[s[n-1][j].first][i]);\n\t\n\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint g[1500][80];\n\nint main(){\n  int n,m;\n  int k,x[1500],d[1500];\n  vector<int> id[150];\n  bool use[1500];\n\n  while(scanf(\"%d %d\",&n,&m) && (n||m)){\n    vector<P1> normal[1500];\n    vector<P1> skip[1500];\n    int num = 0;\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x[num],&d[num]);\n\tid[i].push_back(num);\n\tif(i==n-1)use[num] = true;\n\telse use[num] = false;\n\tnum++;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)id[i].size();j++){\n\tif(i+1<n){\n\t  for(int z=0;z<(int)id[i+1].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+1][z]])*abs(x[id[i][j]]-x[id[i+1][z]]),id[i+1][z]);\n\t    normal[id[i][j]].push_back(tmp);\n\t  }\n\t}\n\tif(i+2<n){\n\t  for(int z=0;z<(int)id[i+2].size();z++){\n\t    P1 tmp = P1( (d[id[i][j]]+d[id[i+2][z]])*abs(x[id[i][j]]-x[id[i+2][z]]),id[i+2][z]);\n\t    skip[id[i][j]].push_back(tmp);\n\t  }\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++)\n      for(int j=0;j<=m;j++)g[i][j] = 1<<30;\n\n \n    priority_queue<P2 ,vector<P2> ,greater<P2> > q;\n    for(int i=0;i<(int)id[0].size();i++)q.push(P2(P1(0,id[0][i]),0));\n    \n\n    int ans;\n    while(q.size()){\n      P2 p = q.top();q.pop();\n      int risk = p.first.first, idx = p.first.second, step = p.second;\n      if(use[idx]){\n\tans = risk;\n\tbreak;\n      }\n\n      for(int i=0;i<(int)normal[idx].size();i++){\n\tint r = risk + normal[idx][i].first,to = normal[idx][i].second;\n\tif(g[to][step]>r){\n\t  g[to][step] = r;\n\t  q.push(P2(P1(r, to),step));\n\t}\n      }\n      if(step<m){\n\tfor(int i=0;i<(int)skip[idx].size();i++){\n\t  int r = risk + skip[idx][i].first,to = skip[idx][i].second;\n\t  if(g[to][step+1]>r){\n\t    g[to][step+1] = r;\n\t    q.push(P2(P1(r, to),step+1));\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//滑りやすさ>=0なら大丈夫.3Dにすると、メモリがたくさんいるので、2つのナップザックを使いまわす。\n#include<iostream>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\n\nint N,M;\nint pos[151][10];\t\t//石のある場所(x座標)\nint list[151][10];\t\t//石の滑りやすさ\nint minest[2][151][10];\t//危険度ナップザック(探索用)\n\nvoid ainst(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid acopy(int *a,int *b,int index){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = b[i];\n\t}\n}\nint amin(int *a,int index){\n\tint min = a[0];\n\tfor(int i = 1;i < index;i++){\n\t\tif(min > a[i])\n\t\t\tmin = a[i];\n\t}\n\treturn min;\n}\nint nap(int n,int mode){\t//mode:0のときは一行飛ばし可能、1のときは不可能\n\tint i,j,l;\n\tint min = 2000000000;\n\tfor(i = 0;i < n-1;i++){\n\t\tfor(j = 0;j < 10;j++){\n\t\t\tif(pos[i][j] == -1)\n\t\t\t\tbreak;\n\t\t\tif(i+2 >= n && mode == 0){\n\t\t\t\tif(min > minest[0][i][j])\n\t\t\t\t\tmin = minest[0][i][j];\n\t\t\t}\n\t\t\tfor(l = 0;l < 10;l++){\n\t\t\t\tswitch(mode){\n\t\t\t\tcase 0:\n\t\t\t\t\tif(i+2 < n && pos[i+2][l] >= 0){\n\t\t\t\t\t\tif(minest[1][i+2][l] == -1 || minest[1][i+2][l] > minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l])){\n\t\t\t\t\t\t\tminest[1][i+2][l] = minest[0][i][j]+(list[i][j]+list[i+2][l])*abs(pos[i][j]-pos[i+2][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase 1:\n\t\t\t\t\tif(pos[i+1][l] >= 0){\n\t\t\t\t\t\tif(minest[0][i+1][l] == -1 || minest[0][i+1][l] > minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l])){\n\t\t\t\t\t\t\tminest[0][i+1][l] = minest[0][i][j]+(list[i][j]+list[i+1][l])*abs(pos[i][j]-pos[i+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0;i < 10;i++){\n\t\tif(minest[0][n-1][i] != -1 && min > minest[0][n-1][i])\n\t\t\tmin = minest[0][n-1][i];\n\t}\n\treturn min;\n}\nint main(){\n\tint i,j,k;\n\tint mcor,now,saisyo[1000];\n\tint saicor = 0;\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0)\n\t\t\tbreak;\n\t\tsaisyo[saicor] = 2000000000;\n\t\tfor(i = 0;i < N;i++){\n\t\t\tainst(pos[i],10,-1);\n\t\t\tainst(list[i],10,-1);\n\t\t\tainst(minest[0][i],10,-1);\n\t\t\tainst(minest[1][i],10,-1);\n\t\t\tcin >> k;\n\t\t\tfor(j = 0;j < k;j++){\n\t\t\t\tcin >> pos[i][j] >> list[i][j];\n\t\t\t}\n\t\t}\n\t\tainst(minest[0][0],10,0);\n\t\tainst(minest[1][0],10,0);\n\t\t//探索開始\n\t\tfor(mcor = 0;mcor <= M;mcor++){\n\t\t\tif(mcor < M)\n\t\t\t\tnow = nap(N,0);\n\t\t\telse\n\t\t\t\tnow = nap(N,1);\n\t\t\tif(saisyo[saicor] > now)\n\t\t\t\tsaisyo[saicor] = now;\n\t\t\tfor(i = 0;i < N;i++){\n\t\t\t\tacopy(minest[0][i],minest[1][i],10);\n\t\t\t\tainst(minest[1][i],10,-1);\n\t\t\t}\n\t\t\tainst(minest[0][0],10,0);\n\t\t\tainst(minest[1][0],10,0);\n\t\t}\n\t\tsaicor++;\n\t}\n\tfor(i = 0;i < saicor;i++){\n\t\tcout << saisyo[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nll dp[151][1001][77],ma[151][1001];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=10;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=10;l++){\n\t\t\t\t\t\t\tif(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n&&k>0){\n\t\t\t\t\t\t\t\tif(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=5;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=10;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int,int>  pi;\ntypedef pair<pair<int,int>,int>  ppi;\ntypedef vector<pair<pair<int,int>,int> >  vppi;\n#define ff first.first\n#define fs first.second\n#define se second\n\nstruct Stone { int row, col, d; };\n\nconst int VMAX = 1600;\nconst int MMAX = 80;\nconst int S = 1598;\nconst int T = 1599;\n\nstruct Edge { int to1, to2, cost; };\nvector<Edge> G[VMAX][MMAX];\nint dist[VMAX][MMAX];\n\nvoid addEdge(int u1, int u2, int v1, int v2, int cost) {\n    G[u1][u2].push_back((Edge){ v1, v2, cost });\n}\n\nint risk(Stone a, Stone b) {\n    return (a.d + b.d) * abs(a.col - b.col);\n}\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        for (int i=0; i<VMAX; ++i) {\n            for (int j=0; j<MMAX; ++j) {\n                G[i][j].clear();\n            }\n        }\n\n        vector<Stone> stones;\n        int k;\n        for (int i=0; i<n; ++i) {\n            cin >> k;\n            int x, d;\n            for (int j=0; j<k; ++j) {\n                cin >> x >> d;\n                stones.push_back((Stone){ i, x, d });\n            }\n        }\n\n        for (int i=0; i<(int)stones.size(); ++i) {\n            // S\n            if (stones[i].row == 0) {\n                for (int j=0; j<=m; ++j) {\n                    addEdge(S, j, i, j, 0);\n                }\n            } else if (stones[i].row == 1) {\n                for (int j=1; j<=m; ++j) {\n                    addEdge(S, j, i, j-1, 0);\n                }\n            }\n\n            // T\n            if (stones[i].row == n-1) {\n                for (int j=0; j<=m; ++j) {\n                    addEdge(i, j, T, j, 0);\n                }\n            } else if (stones[i].row == n-2) {\n                for (int j=1; j<=m; ++j) {\n                    addEdge(i, j, T, j-1, 0);\n                }\n            }\n\n            // other\n            for (int j=i+1; j<(int)stones.size(); ++j) {\n                int jump = stones[j].row - stones[i].row;\n                if (3 <= jump) break;\n                if (jump == 1) {\n                    for (int k=0; k<=m; ++k) {\n                        addEdge(i, k, j, k, risk(stones[i], stones[j]));\n                    }\n                } else if (jump == 2) {\n                    for (int k=1; k<=m; ++k) {\n                        addEdge(i, k, j, k-1, risk(stones[i], stones[j]));\n                    }\n                }\n            }\n        }\n\n        for (int i=0; i<VMAX; ++i) {\n            for (int j=0; j<MMAX; ++j) {\n                dist[i][j] = INT_MAX;\n            }\n        }\n        dist[S][m] = 0;\n        priority_queue<ppi, vppi, greater<ppi> > q;\n        q.push(make_pair(make_pair(0, S), m));\n        while ( ! q.empty()) {\n            int cost = q.top().ff;\n            int u1 = q.top().fs;\n            int u2 = q.top().se;\n            q.pop();\n            for (int i=0; i<(int)G[u1][u2].size(); ++i) {\n                Edge &e = G[u1][u2][i];\n                if (cost + e.cost < dist[e.to1][e.to2]) {\n                    dist[e.to1][e.to2] = cost + e.cost;\n                    q.push(make_pair(make_pair(cost + e.cost, e.to1), e.to2));\n                }\n            }\n        }\n        cout << *min_element(dist[T], dist[T]+MMAX) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAX_N = 151;\nconst int MAX_M = MAX_N/2+1;\nconst int MAX_K = 11;\nconst int INF = 1<<27;\nint N, M;\nint K[MAX_N];\nint X[MAX_N][MAX_K], D[MAX_N][MAX_K];\nint T[MAX_N][MAX_K][MAX_M];\n\nint calcCost(int si, int sj, int di, int dj) {\n  return (D[si][sj] + D[di][dj]) * abs(X[si][sj] - X[di][dj]);\n}\n\nint solve() {\n  fill(T[0][0], T[MAX_N][0], INF);\n  for(int j = 0; j < K[0]; ++j) {\n    T[0][j][M] = 0;\n  }\n  for(int i = 1; i < N; ++i) {\n    for(int j = 0; j < K[i]; ++j) {\n      for(int m = 0; m <= M; ++m) {\n\tfor(int l = 0; l < 2; ++l) {\n\t  if(m+l > M) continue;\n\t  if(i-1-l < 0) continue;\n\t  int pi = i-1-l;\n\t  for(int k = 0; k < K[pi]; ++k) {\n\t    T[i][j][m] = min(T[i][j][m],\n\t\t\t     T[pi][k][m+l] + calcCost(pi,k,i,j));\n\t  }\n\t}\n      }\n    }\n  }\n\n  int res = INF;\n  for(int j = 0; j < K[N-1]; ++j) {\n    for(int m = 0; m <= M; ++m) {\n      res = min(res, T[N-1][j][m]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    for(int i = 0; i < N; ++i) {\n      cin >> K[i];\n      for(int j = 0; j < K[i]; ++j) {\n\tcin >> X[i][j] >> D[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nvoid calc(int n,int m){\n    int c,a,b,d=-1,dp[151][10][80],ans=1000000000;\n    vector<pair<int,int> > stone[151];\n    \n    //scanf(\"%d%d\",&n,&m);\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<=m;k++){\n                dp[i][j][k]=1000000000;\n            }\n        }\n    }\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&c);\n        if(d<0 && c>0){\n            d=i;\n            for(int j=0;j<10;j++){\n                dp[i][j][0]=0;\n            }\n        }\n        \n        for(int j=0;j<c;j++){\n            scanf(\"%d%d\",&a,&b);\n            stone[i].push_back(make_pair(a,b));\n        }\n    }\n    \n    for(int i=d;i<n-1;i++){\n        \n        for(int j=0;j<stone[i].size();j++){\n            for(int k=0;k<stone[i+1].size();k++){\n                for(int l=0;l<=m;l++){\n                    dp[i+1][k][l]=min(dp[i+1][k][l],dp[i][j][l]+(stone[i][j].second+stone[i+1][k].second)*abs(stone[i][j].first-stone[i+1][k].first));\n                }\n            }\n            for(int k=0;k<stone[i+2].size();k++){\n                for(int l=0;l<m;l++){\n                    dp[i+2][k][l+1]=min(dp[i+2][k][l+1],dp[i][j][l]+(stone[i][j].second+stone[i+2][k].second)*abs(stone[i][j].first-stone[i+2][k].first));\n                }\n            }\n        }\n    }\n    \n    for(int i=0;i<stone[n-1].size();i++){\n        for(int j=0;j<=m;j++){\n            ans=min(ans,dp[n-1][i][j]);\n        }\n    }\n    \n    printf(\"%d\\n\",ans);\n    \n    return;\n}\n\nint main(){\n    int n,m;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0) break;\n        calc(n,m);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define f(i, k, j) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = 2000*1000*150;\n\nvector< vector<P> > field;\n//dp[y][x][残りジャンプ回数]\nvector <vector< vector<int> > > dp;\nint n, m;\n\nvoid solve(){\n    rep(i, field[0].size()) dp[0][i][m] = 0;\n    if(m > 0) rep(i, field[1].size()) dp[1][i][m - 1] = 0;\n\n    for(int i = 1; i < n; i++){\n        int now = i, b = i - 1, bb = i - 2;\n\n        if(i > 1){\n            rep(j, field[i].size()) rep(k, dp[i][j].size()) dp[i][j][k] = INF;\n            //bbからbへ\n            rep(j, field[bb].size()){\n                int nx = field[bb][j].first, nj = field[bb][j].second;\n                rep(k, field[b].size()){\n                    int nnx = field[b][k].first, nnj = field[b][k].second;\n                    int c = (nj + nnj) * abs(nx - nnx);\n                    rep(o, m + 1) dp[b][k][o] = min(dp[b][k][o], dp[bb][j][o] + c);\n                }\n                //bbからnowへ\n                rep(k, field[now].size()){\n                    int nnx = field[now][k].first, nnj = field[now][k].second;\n                    int c = (nj + nnj) * abs(nx - nnx);\n                    rep(o, m) dp[now][k][o] = min(dp[now][k][o], dp[bb][j][o + 1] + c);\n                }\n            }\n\n            //bからnowへ\n            rep(j, field[b].size()){\n                int nx = field[b][j].first, nj = field[b][j].second;\n                rep(k, field[now].size()){\n                    int nnx = field[now][k].first, nnj = field[now][k].second;\n                    int c = (nj + nnj) * abs(nx - nnx);\n                    rep(o, m + 1) dp[now][k][o] = min(dp[now][k][o], dp[b][j][o] + c);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >>n >>m){\n        if(n == 0 && m == 0) break;\n        field.clear(); dp.clear();\n        field = vector< vector<P> >(n);\n        rep(i, n){\n            int tmp; cin >>tmp;\n            //first = 石のx座標, second = すべりやすさ\n            field[i] = vector<P>(tmp);\n            rep(j, tmp){\n                cin >>field[i][j].first >>field[i][j].second;\n                field[i][j].first--;\n            }\n        }\n\n        dp = vector< vector< vector<int> > >(n);\n        rep(i, n){\n            dp[i] = vector< vector<int> >(10);\n            rep(j, 10) dp[i][j] = vector<int>(m + 1, INF);\n        }\n\n        solve();\n        int ans = INT_MAX;\n        rep(i, m + 1){\n            rep(j, field[n - 1].size()) ans = min(ans, dp[n - 1][j][i]);\n            if(i > 0) rep(k, field[n - 2].size()) ans = min(ans, dp[n - 2][k][i]);\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\nint dp[160][80][10];\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    using pii = pair<int, int>;\n    const int INF = 1e9;\n    int n, m;\n    while(cin >> n >> m && n) {\n        vector<vector<pii>> rocks(n);\n        for(auto& r : rocks) {\n            int k; cin >> k;\n            r.resize(k);\n            for(auto& p : r)\n              cin >> p.first >> p.second;\n        }\n        fill_n((int*)dp, 160 * 80 * 10, INF);\n        for(int i : in(2)) for(int k : in(rocks[i].size())) dp[i][i][k] = 0;\n        for(int i : in(n - 1)) for(int j : in(m + 1)) for(int k : in(rocks[i].size())) {\n            int cx, cd; tie(cx, cd) = rocks[i][k];\n            if(dp[i][j][k] == INF) continue;\n            for(int l : in(rocks[i + 1].size())) {\n                int nx, nd; tie(nx, nd) = rocks[i + 1][l];\n                int cost = (cd + nd) * abs(cx - nx);\n                dp[i + 1][j][l] = min(dp[i + 1][j][l], dp[i][j][k] + cost);\n            }\n            if(i == n - 2 || j == m) continue;\n            for(int l : in(rocks[i + 2].size())) {\n                int nx, nd; tie(nx, nd) = rocks[i + 2][l];\n                int cost = (cd + nd) * abs(cx - nx);\n                dp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k] + cost);\n            }\n        }\n        int ans = INF;\n        for(int i : in(max(0, n - 2), n))\n          for(int j : in(m + 1)) {\n              if(i == n - 2 && j == m) continue;\n              for(int k : in(rocks[i].size())) \n                ans = min(ans, dp[i][j][k]);\n          }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nint main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[152][78]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%d\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%d%d\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e > 2 && j<b) {\n\t\t\t\t\t\tint m = 1 << 29;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 1][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = 1 << 29;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M INT_MAX\nint dp[152][1001][77],ma[151][1001];\nint main(void){\n\tint n,m,i,j,k,l,a,x,d,t,mi,mx;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=1000;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=m;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tmx=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t\tmx=max(mx,x);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=mx;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=mx;l++){\n\t\t\t\t\t\t\tif(i+1==n+1) dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\telse if(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n+1&&k>0){\n\t\t\t\t\t\t\t\tif(i+2==n+1) dp[i+2][l][k]=min(dp[i+2][l][k],dp[i][j][k]);\n\t\t\t\t\t\t\t\telse if(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n+1;i++){\n\t\t\tfor(j=1;j<=mx;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n+1][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n#define REP(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\n\nlong dist(pair<int, int> s1, pair<int, int> s2) {\n  return abs(s1.first - s2.first) * (s1.second + s2.second);\n}\n\nint main(void) {\n  while(1) {\n    long N, M;\n    vector< pair<long, long> > S[150];\n    vector<long> dp[150][150];\n\n    cin >> N >> M;\n    if(N == 0 && M == 0) break;\n    REP(i, 0, N) {\n      int k;\n      cin >> k;\n      REP(j, 0, k) {\n        long x, d;\n        cin >> x >> d;\n        S[i].push_back(pair<long, long>(x, d));\n      }\n    }\n\n    REP(i, 0, N) {\n      REP(j, 0, M + 1) {\n        REP(k, 0, S[i].size()) {\n          long m = INT_MAX;\n          if(i >= 1) {\n            REP(l, 0, S[i - 1].size()) {\n              m = min(m, dp[i - 1][j][l] + dist(S[i][k], S[i - 1][l]));\n            }\n          }\n          if(i >= 2 && j >= 1) {\n            REP(l, 0, S[i - 2].size()) {\n              m = min(m, dp[i - 2][j - 1][l] + dist(S[i][k], S[i - 2][l]));\n            }\n          }\n          if(i == 0 && j == 0) m = 0;\n          if(i == 0 && j >= 1) m = INT_MAX;\n          if(i == 1 && j == 1) m = 0;\n          dp[i][j].push_back(m);\n        }\n      }\n    }\n\n    long ans = INT_MAX;\n    REP(i, 0, dp[N - 1][M].size()) {\n      ans = min(ans, dp[N - 1][M][i]);\n    }\n    if(M >= 1) {\n      REP(i, 0, dp[N - 1][M - 1].size()) {\n        ans = min(ans, dp[N - 1][M - 1][i]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pii pair<int,int>\n#define MAX \nusing namespace std;\n\nint n,m,dp[155][80][11];\nvector<int> x[155],d[155];\n\nvoid solve(){\n for(;;){\n  cin>>n>>m;\n  if(!n) break;\n  int kk,xx,dd;\n  FOR(i,10){\n   x[0].pb(i+1);\n   x[n+1].pb(i+1);\n  }\n  FOR(i,n){\n   cin>>kk;\n   FOR(j,kk){\n    cin>>xx>>dd;\n    x[i+1].pb(xx);\n    d[i+1].pb(dd);\n   }\n  }\n  fill(dp[0][0],dp[n-1][0],1000000000);\n  for(int i=n-1;i>=0;i--){\n   FOR(j,m+1){\n    FOR(k,x[i].size()){\n     if(j){\n      FOR(l,x[i+2].size()){\n       dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+2][j-1][x[i+2][l]]+(i!=0&&i<n-2)?(d[i][k]+d[i+2][l])*abs(x[i][k]-x[i+2][l]):0);\n      }\n     }\n     FOR(l,x[i+1].size()){\n      dp[i][j][x[i][k]]=min(dp[i][j][x[i][k]],dp[i+1][j][x[i+1][l]]+(i!=0&&i<n-1)?(d[i][k]+d[i+1][l])*abs(x[i][k]-x[i+1][l]):0);\n     }\n    }\n   }\n  }\n  int mi=1000000000;\n  FOR(i,x[0].size()) mi=min(mi,dp[0][m][x[0][i]]);\n  cout<<mi<<endl;\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, f1, f2, r[150];\n\nvector<pair<int, int> > R[150]; long long D[150][10][76];\n\nint distance(int x1, int c1, int x2, int c2)\n{\n\tint sums = R[x1][c1].second + R[x2][c2].second;\n\tint dist = R[x1][c1].first - R[x2][c2].first;\n\n\treturn sums * abs(dist);\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &m);\n\n\t\tif (n == 0 && m == 0) break;\n\n\t\tfor (int i = 0; i < n; i++) R[i].clear();\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r[i]);\n\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &f1);\n\t\t\t\tscanf(\"%d\", &f2);\n\n\t\t\t\tR[i].push_back(make_pair(f1, f2));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t{\n\t\t\t\t\tif (i == 0 && k == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (i == 1 && k == 1 && m != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 999999999999999999LL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int> >, greater<tuple<long long, int, int, int> > > que;\n\n\t\tfor (int i = 0; i < r[0]; i++)\n\t\t{\n\t\t\tque.push(make_tuple(0LL, 0, 0, i));\n\t\t}\n\n\t\tif (m != 0)\n\t\t{\n\t\t\tfor (int i = 0; i < r[1]; i++)\n\t\t\t{\n\t\t\t\tque.push(make_tuple(0LL, 1, 1, i));\n\t\t\t}\n\t\t}\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<long long, int, int, int> state = que.top(); que.pop();\n\n\t\t\tlong long dist = get<0>(state);\n\n\t\t\tint jump = get<1>(state);\n\t\t\tint high = get<2>(state);\n\t\t\tint node = get<3>(state);\n\n\t\t\tif (high + 1 != n)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < r[high + 1]; i++)\n\t\t\t\t{\n\t\t\t\t\tlong long dist2 = dist + distance(high, node, high + 1, i);\n\n\t\t\t\t\tif (D[high + 1][i][jump] > dist2)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[high + 1][i][jump] = dist2;\n\n\t\t\t\t\t\tque.push(make_tuple(dist2, jump, high + 1, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (high + 2 != n && jump != m)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < r[high + 2]; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long dist2 = dist + distance(high, node, high + 2, i);\n\n\t\t\t\t\t\tif (D[high + 2][i][jump + 1] > dist2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[high + 2][i][jump + 1] = dist2;\n\n\t\t\t\t\t\t\tque.push(make_tuple(dist2, jump + 1, high + 2, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong long ret = 999999999999999999LL;\n\n\t\tfor (int i = 0; i < r[n - 1]; i++)\n\t\t{\n\t\t\tret = min(ret, D[n - 1][i][m]);\n\t\t}\n\n\t\tif (m != 0)\n\t\t{\n\t\t\tfor (int i = 0; i < r[n - 2]; i++)\n\t\t\t{\n\t\t\t\tret = min(ret, D[n - 2][i][m - 1]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n, m;\n\nstruct edge {\n\tint from,to;\n\tint cost;\n\tbool sp;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int t,int c,bool f) : to(t), cost(c), sp(f) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvector<edge> G[2000];\nint d[2000][2000];\n\nvoid dijkstra(int s) {\n\t// cost ticket place\n\tpriority_queue<pair<int, pair<int, int> >, vector< pair<int, pair<int, int> > >, greater< pair<int, pair<int, int> > > > que;\n\trep(i, 2000) rep(j, 2000) d[i][j] = INF;\n\td[s][0] = 0;\n\tque.push(mp(0, mp(0,s)));\n\t\n\twhile(que.size()) {\n\t\tint c = que.top().first;\n\t\tP p = que.top().second;\n\n\t\tque.pop();\n\t\tint t = p.first;\n\t\tint v = p.second;\n\n\t\tif(d[v][t] < c) continue;\n\t\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(e.sp) {\n\t\t\t\tif(t + 1 <= m && d[e.to][t+1] > d[v][t] + e.cost) {\n\t\t\t\t\td[e.to][t+1] = d[v][t] + e.cost;\n\t\t\t\t\tque.push(mp(d[e.to][t+1], mp(t+1, e.to)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(d[e.to][t] > d[v][t] + e.cost) {\n\t\t\t\t\td[e.to][t] = d[v][t] + e.cost;\n\t\t\t\t\tque.push(mp(d[e.to][t], mp(t, e.to)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> m) {\n\t\tif(n == 0 && m == 0) break;\n\n\t\trep(i, 2000) G[i].clear();\n\n\t\tvector<pair<P, int> > v[n];\n\t\tint id = 1;\n\t\trep(i, n) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\n\t\t\trep(j, k) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv[i].push_back(mp(mp(a, b), id));\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\n\t\trep(i, v[0].size()) {\n\t\t\tP p = v[0][i].first;\n\t\t\tint a = v[0][i].second;\n\t\t\tG[0].push_back(edge(a, 0, false));\n\t\t}\n\n\t\trep(i, n-1) {\n\t\t\trep(j, v[i].size()) {\n\t\t\t\tP p = v[i][j].first;\n\t\t\t\tint a = v[i][j].second;\n\t\t\t\t\n\t\t\t\trep(k, v[i+1].size()) {\n\t\t\t\t\tP q = v[i+1][k].first;\n\t\t\t\t\tint b = v[i+1][k].second;\n\t\t\t\t\tint c = (p.second + q.second) * abs(p.first - q.first);\n\n\t\t\t\t\tG[a].push_back(edge(b, c, false));\n\t\t\t\t}\n\n\t\t\t\tif(i >= n-2) continue;\n\n\t\t\t\trep(k, v[i+2].size()) {\n\t\t\t\t\tP q = v[i+2][k].first;\n\t\t\t\t\tint b = v[i+2][k].second;\n\t\t\t\t\tint c = (p.second + q.second) * abs(p.first - q.first);\n\n\t\t\t\t\tG[a].push_back(edge(b, c, true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, v[n-1].size()) {\n\t\t\tP p = v[n-1][i].first;\n\t\t\tint b = v[n-1][i].second;\n\t\t\tG[b].push_back(edge(id, 0, false));\n\t\t}\n\n\t\t// cout << \"GRAPH\" << endl;\n\t\t//\n\t\t// rep(i, id+1) {\n\t\t// \tcout << \"Node:\" << i << \"  :\";\n\t\t// \trep(j, G[i].size()) cout << \"(\" << G[i][j].to << \",\" << G[i][j].cost << \") \";\n\t\t// \tcout << endl;\n\t\t// }\n\n\t\tdijkstra(0);\n\n\t\tint ans = INF;\n\t\trep(i, m + 1) {\n\t\t\tans = min(ans, d[id][i]);\n\t\t}\n\n\t\t// rep(i, m + 1) {\n\t\t// \tcout << \"ticket:\" << i << \" \";\n\t\t// \tcout << d[id][i] << endl;\n\t\t// }\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  /*\n\t  for(k=0;k<100;k++){\n\t    \n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t\t\t\t       */\n\t  }\n\t  /*\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30 ;\nstruct edge{\n  int pos, strong ;\n  int dp[77];\n\n  edge(int pos, int strong): pos(pos), strong(strong){\n    fill_n( dp, 77, INF);\n  };\n  edge(){};\n};\n\nint main(){\n  int n; //行数 \n  int m; //ジャンプの数\n\n  vector< edge > node[152] ;\n\n  cin >> n >> m;\n  for(int i = 0; i < n; i++){\n    int k;\n    cin >> k ;\n    node[i].resize(k) ;\n    for(int j = 0; j < k; j++){\n      int x, d;\n      cin >> x >> d ;\n      node[i][j] = edge( x, d);\n    }\n  }\n\n  for(int i = 0; i < node[0].size(); i++){ //最初は普通にジャンプ\n    node[0][i].dp[0] = 0;\n  }\n  for(int i = 0; i < node[1].size(); i++){ //最初はジャンプする\n    node[1][i].dp[1] = 0 ;\n  }\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < node[i].size(); j++){\n      for(int k = 0; k <= m; k++){\n        if(node[i][j].dp[k] != INF){\n          if(k != m){\n            for(int l = 0; l < node[i + 2].size(); l++){\n              node[i + 2][l].dp[k + 1] = min( node[i + 2][l].dp[k + 1], node[i][j].dp[k] + (node[i + 2][l].strong + node[i][j].strong) * abs(node[i + 2][l].pos - node[i][j].pos));\n            }\n          }\n          for(int l = 0; l < node[i + 1].size(); l++){\n            node[i + 1][l].dp[k] = min( node[i + 1][l].dp[k], node[i][j].dp[k] + (node[i + 1][l].strong + node[i][j].strong) * abs(node[i + 1][l].pos - node[i][j].pos));\n          }\n        }\n      }\n    }\n  }\n  int ret = INF ;\n  for(int i = 0; i < node[n - 1].size(); i++){\n    for(int j = 0; j <= m; j++){\n      ret = min( ret, node[n - 1][i].dp[j]);\n    }\n  }\n  for(int i = 0; i < node[n - 2].size(); i++){\n    for(int j = 0; j < m; j++){\n      ret = min( ret, node[n - 2][i].dp[j]);\n    }\n  }\n  cout << ret << endl ;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint n,m;\nint stone[155][11][2];\nint dp[155][11][76];\nint num[155];\nint cost(int a,int b,int c){\n\tif(a==n || (a==n-1 && c<m)){\n\t\treturn 0;\n\t}\n\tif(dp[a][b][c]!=-1) return dp[a][b][c];\n\tint mini=INF;\n\tfor(int i=1;i<=num[a+1];i++){\n\t\tmini=min(mini,(stone[a+1][i][1]+stone[a][b][1])*abs(stone[a][b][0]-stone[a+1][i][0])+cost(a+1,i,c));\n\t}\n\tif(c!=m){\n\tfor(int i=1;i<=num[a+2];i++){\n\t\tmini=min(mini,(stone[a+2][i][1]+stone[a][b][1])*abs(stone[a][b][0]-stone[a+2][i][0])+cost(a+2,i,1+c));\n\t}\n\t}\n\treturn dp[a][b][c]=mini;\n}\nint main(){\n\twhile(scanf(\"%d %d\",&n,&m) && n){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&num[i]);\n\t\t\tfor(int g=1;g<=num[i];g++){\n\t\t\t\tscanf(\"%d %d\",&stone[i][g][0],&stone[i][g][1]);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tint ans=INF;\n\t\tfor(int i=1;i<=num[1];i++){\n\t\t\tans=min(ans,cost(1,i,0));\n\t\t}\n\t\tif(m>0){\n\t\t\tfor(int i=1;i<=num[2];i++){\n\t\t\t\tans=min(ans,cost(2,i,1));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 155\n#define MAX_K 15\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct State {\n    int dng, x, y, m;\n    State(){}\n    State(int dng, int x, int y, int m) :\n        dng(dng), x(x), y(y), m(m) {}\n\n    bool operator < (const State &s) const {\n        return dng > s.dng;\n    }\n};\n\nint main()\n{\n    int N, M, K, x, d;\n    while (cin >> N >> M, N) {\n        vector<pii> G[MAX_N];\n        for (int i = 0; i < N; i++) {\n            cin >> K;            \n            for (int j = 0; j < K; j++) {\n                cin >> x >> d; \n                G[i].push_back(pii(x, d));\n            }\n        }\n        G[N].push_back(pii(0, 0));\n        \n        int dn[MAX_N][MAX_K][MAX_N];\n        for (int i = 0; i < MAX_N; i++) {\n            for (int j = 0; j < MAX_K; j++) {\n                for (int k = 0; k < MAX_N; k++) {\n                    dn[i][j][k] = INF;\n                }\n            }\n        }\n        \n        priority_queue<State> Q;\n        for (int i = 0; i < 2; i++) {\n            int size = G[i].size();\n            int nm = (i == 1 ? M - 1 : M);\n            for (int j = 0; j < size; j++) {\n                Q.push(State(0, j, i, nm)); \n                dn[i][j][nm] = 0;\n            }\n        }\n                \n        while (!Q.empty()) {\n            State s = Q.top(); Q.pop();\n            int y = s.y, x = s.x, m = s.m;\n            int dng = G[y][x].second;\n            x = G[y][x].first;\n            if (y == N) {\n                cout << s.dng << endl;\n                break;\n            }\n\n            for (int i = 1; i <= 2; i++) {\n                int ny = y + i;\n                if (ny > N) continue;                \n                for (int j = 0; j < (int)G[ny].size(); j++) {\n                    int nx = G[ny][j].first, nd = G[ny][j].second;\n                    int nm = (i == 2 ? m - 1 : m);\n                    int ncost = s.dng + (ny < N ? (dng + nd) * abs(x - nx) : 0);\n\n                    if (nm >= 0 && ncost < dn[ny][j][nm]) {\n                        dn[ny][j][nm] = ncost;\n                        Q.push(State(ncost, j, ny, nm));\n                    }\n                }\n            }\n           \n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150]; //K[i]::=i行目に何個の石があるか\nint X[10][150]; //X[i][j]::=j列目のi個目が何列目か\nint D[10][150]; //D[i][j]::=j列目のi個目のすべりやすさ\nint DP[10][150][80]; //DP[i][j][k]::=j列目のi個目にいて、あとk回ジャンプできる\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tmemset(K,0,sizeof(K));\n\t\tmemset(X,0,sizeof(X));\n\t\tmemset(D,0,sizeof(D));\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][M]=0;\n\t\tfor(int x=0;x<K[1];x++) DP[x][1][M-1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y==1) continue;\n\t\t\tfor(int xx=0;xx<K[y-2];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m+1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-2];x++) for(int m=1;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-2][m]);\n\t\t}\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint dp[100][3][1010];\nvector<vector<pint> > river;\nint k[200];\n\nint main() {\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\triver.clear();\n\t\tint i,j;\n\t\tvector<pint> buf;\n\t\tfor(i=0;i<n;i++){\n\t\t\triver.push_back(buf);\n\t\t\tk[i]=in();\n\t\t\tint j,x,d;\n\t\t\tfor(j=0;j<k[i];j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\triver[i].push_back(mp(x,d));\n\t\t\t}\n\t\t}\n//for(i=0;i<n;i++){\n//cout<<i<<endl;\n//for(j=0;j<k[i];j++){\n//cout<<\" \"<<river[i][j].first<<endl;\n//}\n//}\n\t\tfor(i=0;i<k[0];i++){\n\t\t\tdp[0][0][river[0][i].first]=0;\n\t\t}\n\t\tfor(i=0;i<k[1];i++){\n\t\t\tdp[1][1][river[1][i].first]=0;\n\t\t}\n\t\tfor(i=0;i<k[0];i++){\n\t\t\tfor(j=0;j<k[1];j++){\n\t\t\t\tif(dp[0][1][river[1][j].first]==-1||dp[0][1][river[1][j].first]>(river[0][i].second+river[1][j].second)*abs(river[0][i].first-river[1][j].first)){\n\t\t\t\t\tdp[0][1][river[1][j].first]=(river[0][i].second+river[1][j].second)*abs(river[0][i].first-river[1][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\nfor(i=0;i<10;i++){\ncout<<i<<\" \"<<dp[0][0][i]<<endl;\n}\ncout<<endl;\nfor(i=0;i<10;i++){\ncout<<i<<\" \"<<dp[1][1][i]<<endl;\n}\ncout<<endl;\nfor(i=0;i<10;i++){\ncout<<i<<\" \"<<dp[0][1][i]<<endl;\n}\ncout<<endl;\n*/\n\t\tfor(i=0;i<=n-3;i++){\n\t\t\tint t,s;\n\t\t\tfor(t=0;t<k[i];t++){\n\t\t\t\tfor(s=0;s<k[i+2];s++){\n\t\t\t\t\tfor(j=0;j<m;j++){\n//cout<<dp[j][0][river[i][t].first]<<\" \"<<river[i][t].second<<\" \"<<river[i+2][s].second<<\" \"<<river[i][t].first<<\" \"<<river[i+2][s].first<<endl;\n\t\t\t\t\t\tif(dp[j][0][river[i][t].first]==-1)continue;\n\t\t\t\t\t\tif(dp[j+1][2][river[i+2][s].first]==-1||dp[j+1][2][river[i+2][s].first]>dp[j][0][river[i][t].first]+(river[i][t].second+river[i+2][s].second)*abs(river[i][t].first-river[i+2][s].first)){\n\t\t\t\t\t\t\tdp[j+1][2][river[i+2][s].first]=dp[j][0][river[i][t].first]+(river[i][t].second+river[i+2][s].second)*abs(river[i][t].first-river[i+2][s].first);\n//cout<<\"hoge\"<<endl;\n//cout<<\" \"<<river[i+2][s].first<<\" \"<<dp[j+1][2][river[i+2][s].first]<<endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(t=0;t<k[i+1];t++){\n\t\t\t\tfor(s=0;s<k[i+2];s++){\n\t\t\t\t\tfor(j=0;j<=m;j++){\n//cout<<\"piyo\"<<endl;\n//cout<<dp[j][2][river[i+2][s].first]<<\" \"<<dp[j][0][river[i+1][t].first]<<\" \"<<river[i+1][t].second<<\" \"<<river[i+2][s].second<<\" \"<<river[i+1][t].first<<\" \"<<river[i+2][s].first<<endl;\n\t\t\t\t\t\tif(dp[j][1][river[i+1][t].first]==-1)continue;\n\t\t\t\t\t\tif(dp[j][2][river[i+2][s].first]==-1||dp[j][2][river[i+2][s].first]>dp[j][1][river[i+1][t].first]+(river[i+1][t].second+river[i+2][s].second)*abs(river[i+1][t].first-river[i+2][s].first)){\n\t\t\t\t\t\t\tdp[j][2][river[i+2][s].first]=dp[j][1][river[i+1][t].first]+(river[i+1][t].second+river[i+2][s].second)*abs(river[i+1][t].first-river[i+2][s].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(t=0;t<1010;t++){\n\t\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\t\tdp[j][0][t]=dp[j][1][t];\n\t\t\t\t\tdp[j][1][t]=dp[j][2][t];\n\t\t\t\t\tdp[j][2][t]=-1;\n\t\t\t\t}\n\t\t\t}\n\n//for(j=0;j<=m;j++){\n//for(t=0;t<10;t++){\n//cout<<i<<\" \"<<j<<\" \"<<t<<\" \"<<dp[j][1][t]<<endl;\n//}\n//}\n\t\t}\n\t\tint res=100100100;\n\t\tfor(i=0;i<1010;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tif(dp[j][1][i]!=-1)chmin(res,dp[j][1][i]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<1010;i++){\n\t\t\tfor(j=0;j<=m-1;j++){\n\t\t\t\tif(dp[j][0][i]!=-1)chmin(res,dp[j][0][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n// pair<pair<int, int>, pair<int, int> > dp[150][1000];\n\n// rec(y, x, m) = min(rec(y-1, 0, m) + |x-0| * (d(y, x) + d(y-1, 0)),\n//                    rec(y-1, 1, m) + |x-1| * (d(y, x) + d(y-1, 1)),\n//                    ...\n//                    rec(y-1, xmax, m) + |x-xmax| * (d(y, x) + d(y-1, xmax)),\n//                    rec(y-2, 0, m-1) + |x-0| * (d(y, x) + d(y-2, 0))\n//                    rec(y-2, 1, m-1) + |x-1| * (d(y, x) + d(y-2, 1))\n//                    ...\n//                    rec(y-2, xmax, m-1) + |x-xmax| * (d(y, x) + d(y-2, xmax)))\n\nint w, minv, d[1000][155];\n\nvoid rec(int y, int x, int m, int cost) {\n  // cout << y << ' ' << x << ' ' << m << ' ' << cost << endl;\n  if (y == 0 || y == 1) {\n    minv = min(minv, cost);\n    return;\n  }\n  for (int i = 0; i < w; i++) {\n    if (d[i][y-1] != -1 && minv > cost + abs(x-i) * (d[x][y] + d[i][y-1]))\n      rec(y-1, i, m, cost + abs(x-i) * (d[x][y] + d[i][y-1]));\n    if (m && d[i][y-2] != -1 && minv > cost + abs(x-i) * (d[x][y] + d[i][y-2]))\n      rec(y-2, i, m-1, cost + abs(x-i) * (d[x][y] + d[i][y-2]));\n  }\n}\n\nint main() {\n  for (;;) {\n    int n, m;\n    cin >> n >> m;\n    if (!(n || m)) return 0;\n    w = 0;\n    minv = INT_MAX / 2;\n    for (int y = 0; y < n+3; y++)\n      for (int x = 0; x < 1000; x++)\n        if (y <= 1 || y == n+2) d[x][y] = 0;\n        else d[x][y] = -1;\n    for (int y = 2; y < n+2; y++) {\n      int k;\n      cin >> k;\n      for (int i = 0; i < k; i++) {\n        int x;\n        cin >> x;\n        w = max(w, x);\n        cin >> d[x-1][y];\n      }\n    }\n    /*\n    for (int y = 0; y < n+3; y++) {\n      for (int x = 0; x < w; x++)\n        cout << d[x][y] << ' ';\n      cout << endl;\n    }\n    */\n    for (int x = 0; x < w; x++)\n      rec(n+2, x, m, 0);\n    cout << minv << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30 ;\nstruct edge{\n  int pos, strong ;\n  int dp[77];\n\n  edge(int pos, int strong): pos(pos), strong(strong){\n    fill_n( dp, 77, INF);\n  };\n  edge(){};\n};\n\nint main(){\n  int n; //行数 \n  int m; //ジャンプの数\n\n  vector< edge > node[152] ;\n\n  while(scanf(\"%d %d\", &n, &m), n){\n    for(int i = 0; i < n; i++){\n      int k;\n      scanf(\"%d\", &k);\n      node[i].resize(k) ;\n      for(int j = 0; j < k; j++){\n        int x, d;\n        scanf(\"%d %d\", &x, &d);\n        node[i][j] = edge( x, d);\n      }\n    }\n\n    for(int i = 0; i < node[0].size(); i++){ //最初は普通にジャンプ\n      node[0][i].dp[0] = 0;\n    }\n    for(int i = 0; i < node[1].size(); i++){ //最初はジャンプする\n      node[1][i].dp[1] = 0 ;\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < node[i].size(); j++){\n        for(int k = 0; k <= m; k++){\n          if(node[i][j].dp[k] != INF){\n            if(k != m){\n              for(int l = 0; l < node[i + 2].size(); l++){\n                node[i + 2][l].dp[k + 1] = min( node[i + 2][l].dp[k + 1], node[i][j].dp[k] + (node[i + 2][l].strong + node[i][j].strong) * abs(node[i + 2][l].pos - node[i][j].pos));\n              }\n            }\n            for(int l = 0; l < node[i + 1].size(); l++){\n              node[i + 1][l].dp[k] = min( node[i + 1][l].dp[k], node[i][j].dp[k] + (node[i + 1][l].strong + node[i][j].strong) * abs(node[i + 1][l].pos - node[i][j].pos));\n            }\n          }\n        }\n      }\n    }\n    int ret = INF ;\n    for(int i = 0; i < node[n - 1].size(); i++){\n      for(int j = 0; j <= m; j++){\n        ret = min( ret, node[n - 1][i].dp[j]);\n      }\n    }\n    for(int i = 0; i < node[n - 2].size(); i++){\n      for(int j = 0; j < m; j++){\n        ret = min( ret, node[n - 2][i].dp[j]);\n      }\n    }\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nconst int INF = (1<<29);\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && (n || m)){\n    int dp[150][10][80], a[150][10], x[150][10];\n    for(int i=0;i<150;i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<80;k++) dp[i][j][k] = INF;\n\ta[i][j] = INF;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int k;\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tint b,c;\n\tcin >> b >> c;\n\tx[i][j] = b;\n\ta[i][j] = c;\n      }\n    }\n    for(int i=0;i<10;i++){\n      dp[0][i][0] = 0;\n      if(m != 1) dp[1][i][1] = 0;\n    }\n    for(int i=0;i<n-1;i++){\n      for(int l=0;l<=m;l++){\n\tfor(int j=0;j<10;j++){\n\t  if(a[i][j] == INF) continue;\n\t  for(int k=0;k<10;k++){\n\t    if(a[i+1][k] == INF) continue;\n\t    dp[i+1][k][l] = min(dp[i+1][k][l],dp[i][j][l] + (a[i][j] + a[i+1][k]) * (abs(x[i+1][k]-x[i][j])));\n\t  }\n\t  if(i < n - 2 && l != m){\n\t    for(int k=0;k<10;k++){\n\t      if(a[i+2][k] == INF) continue;\n\t      dp[i+2][k][l+1] = min(dp[i+2][k][l+1],dp[i][j][l] + (a[i][j] + a[i+2][k]) * (abs(x[i+2][k]-x[i][j])));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int j=0;j<=m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-1][k][j]);\n    for(int j=0;j<m;j++) for(int k=0;k<10;k++) ans = min(ans,dp[n-2][k][j]);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1e3;\nconst int INF = 1e9;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<vector<int>> xs(n + 2), ds(n + 2);\n\t\tvector<vector<vector<int>>> dp(n + 2);\n\t\txs[0].assign(MAX, 0);\n\t\txs[n + 1].assign(MAX, 0);\n\t\tfor (int i = 0; i < MAX; i++) xs[0][i] = i;\n\t\tfor (int i = 0; i < MAX; i++) xs[n + 1][i] = i;\n\t\tds[0].assign(MAX, 0);\n\t\tds[n + 1].assign(MAX, 0);\n\t\tdp[0].assign(MAX, vector<int>(m + 1, 0));\n\t\tdp[n + 1].assign(MAX, vector<int>(m + 1, INF));\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d; x--;\n\t\t\t\txs[i].push_back(x);\n\t\t\t\tds[i].push_back(d);\n\t\t\t\tdp[i].push_back(vector<int>(m + 1, INF));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n + 2; i++) {\n\t\t\tfor (int j = 0; j < (int)xs[i - 1].size(); j++) {\n\t\t\t\tfor (int k = 0; k < (int)xs[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l <= m; l++) {\n\t\t\t\t\t\tdp[i][k][l] = min(dp[i][k][l], dp[i - 1][j][l] + abs(xs[i][k] - xs[i - 1][j]) * (ds[i][k] + ds[i - 1][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 1) continue;\n\t\t\tfor (int j = 0; j < (int)xs[i - 2].size(); j++) {\n\t\t\t\tfor (int k = 0; k < (int)xs[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\t\tdp[i][k][l + 1] = min(dp[i][k][l + 1], dp[i - 2][j][l] + abs(xs[i][k] - xs[i - 2][j]) * (ds[i][k] + ds[i - 2][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (auto last : dp[n + 1]) {\n\t\t\tfor (auto val : last) {\n\t\t\t\tres = min(res, val);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nconst int inf = 3e17;\n\nint dp[155][15][100];\nint stone[155][15];\nint X[155][15];\n\nsigned main()\n{\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        rep(i, n+5) rep(j, 15) stone[i][j] = inf, X[i][j] = inf;\n        rep(i, n+5) rep(j, 15) rep(k, 100) dp[i][j][k] = inf;\n\n        rep(i, n) {\n            int k; cin >> k;\n            rep(j, k) {\n                int x, d; cin >> x >> d;\n\n                X[i][j] = x;\n\n                stone[i][j] = d;\n                if (i == 0) dp[0][j][0] = 0;\n                if (i == 1) dp[1][j][1] = 0;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 11; ++j) {\n                if (stone[i][j] == inf) continue;\n\n                for (int k = 0; k <= m; ++k) {\n                    if (k < m) {\n                        rep(l, 11) {\n                            if (stone[i + 2][l] == inf) continue;\n\n                            dp[i + 2][l][k + 1] = min(\n                                    dp[i + 2][l][k + 1],\n                                    dp[i][j][k] + (stone[i][j] + stone[i + 2][l]) * abs(X[i][j] - X[i + 2][l])\n                                    );\n                        }\n                    }\n\n                    rep(l, 11) {\n                        if (stone[i + 1][l] == inf) continue;\n\n                        dp[i + 1][l][k] = min(\n                                dp[i + 1][l][k],\n                                dp[i][j][k] + (stone[i][j] + stone[i + 1][l]) * abs(X[i][j] - X[i + 1][l])\n                                );\n                    }\n                }\n            }\n        }\n\n        int mi = inf;\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j <= m; ++j) {\n                mi = min(mi, dp[n - 1][i][j]);\n            }\n        }\n\n        for (int i = 0; i < 11; ++i) {\n            for (int j = 0; j <= m - 1; ++j) {\n                mi = min(mi, dp[n - 2][i][j]);\n            }\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#define MAX_V 155\n#define INF 1000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\n\ntypedef pair<int, pair<int,int> > P;\n\nint d[MAX_V][MAX_V],n,m;\nvector<edge>G[MAX_V];\n\nint dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  que.push(make_pair(0,make_pair(s, m)));\n\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++)\n      d[i][j]=INF;\n\n  for(int i=0;i<MAX_V;i++)d[s][i]=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second.first;\n    if(d[v][p.second.second] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+1 && d[e.to][p.second.second] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second] = d[v][p.second.second]+e.cost;\n\tque.push(make_pair(d[e.to][p.second.second],make_pair(e.to,p.second.second)));\n      }\n    }\n    \n    if(p.second.second <=0)continue;\n   \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(e.to == v+2 && d[e.to][p.second.second-1] > d[v][p.second.second]+e.cost){\n\td[e.to][p.second.second-1] = d[v][p.second.second]+e.cost;\n\n\tque.push(make_pair(d[e.to][p.second.second-1],make_pair(e.to,p.second.second-1)));\n      }\n    }\n    \n  }\n  int ans=INF;\n  for(int i=0; i<=m; i++){\n    ans=min(d[n+1][i],ans);\n  }\n  return ans;\n}\n\n\nvoid solve(void){\nint dp[1005][101];\n\n for(int i=0;i<1005;i++)\n   for(int j=0;j<=m;j++)\n     dp[i][j]=INF;\n\n   dp[0][m]=0;\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<G[i].size();j++){\n\n\tedge e=G[i][j];\n\tfor(int k=0;k<=m;k++){\n\t  if(i+1==e.to)dp[i+1][k]=min(dp[i+1][k],dp[i][k]+e.cost);\n\t  if(i+2==e.to && k!=0)dp[i+2][m-k]=min(dp[i+2][m-k],dp[i][m-k+1]+e.cost);\n\t}\n    }\n  }\n  int ans=INF;\n  for(int j=0;j<=m;j++)\n    ans=min(ans,dp[n+1][j]);\n  \n  cout << ans << endl;\n}\n\n\nint main(void){\n  int k,x,y;\n  int graph[MAX_V][1005];\n  \n  while(cin >> n >> m,n|m){\n\n    for(int i=0; i<MAX_V; i++)G[i].clear();\n    \n    for(int i=0; i<MAX_V; i++)\n      for(int j=0; j<1005; j++)\n\tgraph[i][j]=0;\n    \n    for(int i=1; i<=n; i++){\n      cin >> k;\n      \n      for(int j=0; j<k; j++){\n\tcin >> x >> y;\n\tgraph[i][x]=y;\n      }\n    }\n    \n    edge e;\n    for(int i=0; i<=n; i++){\n      for(int j=0; j<1005; j++){\n\t\n\tif(graph[i][j]>0 || i==0){\n\t  \n\t  for(int l=0; l<1005; l++){\n\n\t    if(i==0){\n\t      if(graph[i+1][l]>0){\n\t\te.to=i+1;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      \n\t      if(graph[i+2][l]>0){\n\t\te.to=i+2;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\n\t    if(i>=n){\n\t      if(i+1==n+1){\n\t\te.to=i+1;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      if(i+2==n+1){\n\t\te.to=i+2;\n\t\te.cost=0;\n\t\tG[i].push_back(e);\n\t      }\n\t      continue;\n\t    }\n\t    \n\t    if(graph[i+1][l]>0){\n\t      e.to=i+1;\n\t      e.cost=(graph[i][j]+graph[i+1][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\t    \n\t    if(graph[i+2][l]>0){\n\t      e.to=i+2;\n\t      e.cost=(graph[i][j]+graph[i+2][l])*abs(l-j);\n\t      G[i].push_back(e);\n\t    }\n\n\t  }\n\t}\n      }\n    }\n    //solve();\n    cout << dijkstra(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int INF=1000000000;\nint z(int a){\n\tif(a<0)a=-a;\n\treturn a;\n}\n\nint main(){\nwhile(1){\n\tint n,m,k[153],x[153][10],d[153][10],dp[153][10][77],ans=INF;\n\tscanf(\"%d%d\",&n,&m);\nif(n==0&&m==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&k[i]);\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tscanf(\"%d%d\",&x[i][j],&d[i][j]);\n\t\t}\n\t}\n\tk[n+1]=0; k[n+2]=0;\n\tfor(int i=0;i<153;i++)for(int j=0;j<10;j++)for(int h=0;h<77;h++)dp[i][j][h]=INF;\n\tfor(int j=0;j<10;j++)dp[1][j][0]=0;\n\tfor(int j=0;j<10;j++)dp[2][j][1]=0;\n\tfor(int i=1;i<=n;i++)for(int j=0;j<k[i];j++)for(int h=0;h<=m;h++){\n\t\tfor(int g=0;g<k[i+1];g++){\n\t\t\tint c=dp[i][j][h]+z(x[i][j]-x[i+1][g])*(d[i][j]+d[i+1][g]);\n\t\t\tif(c<dp[i+1][g][h])dp[i+1][g][h]=c;\n\t\t}\n\t\tfor(int g=0;g<k[i+2];g++){\n\t\t\tint c=dp[i][j][h]+z(x[i][j]-x[i+2][g])*(d[i][j]+d[i+2][g]);\n\t\t\tif(c<dp[i+2][g][h+1])dp[i+2][g][h+1]=c;\n\t\t}\n\t\tif(i==n&&dp[i][j][h]<ans)ans=dp[i][j][h];\n\t\tif(i==n-1&&h<=m-1&&dp[i][j][h]<ans)ans=dp[i][j][h];\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "//  Pyon-Pyon River Crossing.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int X = 1005;\nconst int Y = 155;\nconst int MM = 80;\nconst int INF = 1 << 30;\n\nint N, M;\nint dp[3][X][MM];\n\nint main()\n{\n\tfor(; cin >> N >> M && (N || M); )\n\t{\n\t\tvector<vector<vint> > dp(3, vector<vint>(X, vint(MM, INF)));\n\t\tdp[0] = vector<vint>(X, vint(MM, 0));\n\t\t\n\t\tvector<vector<pint> > river;\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\t\n\t\t\triver.push_back(vector<pint>(k));\n\t\t\t\n\t\t\trep(i, k) cin >> river[y][i].first >> river[y][i].second;\n\t\t}\n\t\t\n\t\triver.push_back(vector<pint>(X));\n\t\trep(i, X) river[N][i] = mp(i, 0);\n\t\t\n\t\trep(y, N)\n\t\t{\n\t\t\trep(i, river[y].size())\n\t\t\t{\n\t\t\t\trep(m, M+1)\n\t\t\t\t{\n\t\t\t\t\trep(j, river[y+1].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+1][j].second + river[y][i].second) * abs(river[y+1][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[1][river[y+1][j].first][m], dp[0][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(m > 0) rep(j, river[y+2].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint d = (river[y+2][j].second + river[y][i].second) * abs(river[y+2][j].first - river[y][i].first);\n\t\t\t\t\t\tchmin(dp[2][river[y+2][j].first][m-1], dp[0][river[y][i].first][m] + d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp[0] = dp[1];\n\t\t\tdp[1] = dp[2];\n\t\t\trep(x, X) rep(m, MM) dp[2][x][m] = INF;\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\trep(x, X) rep(m, MM) chmin(ans, dp[0][x][m]);\n\n\t\tcout << ans << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150]; //K[i]::=i行目に何個の石があるか\nint X[10][150]; //X[i][j]::=j列目のi個目が何列目か\nint D[10][150]; //D[i][j]::=j列目のi個目のすべりやすさ\nint DP[10][150][80]; //DP[i][j][k]::=j列目のi個目にいて、もうk回ジャンプしてるときの最小コスト\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][0]=0;\n\t\tif(M>0) for(int x=0;x<K[1];x++) DP[x][1][1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) for(int m=0;m<=M;m++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y>1 && m>0) {\n\t\t\t\tfor(int xx=0;xx<K[y-2];xx++) {\n\t\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m-1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tif(M>0) {\n\t\t\tfor(int x=0;x<K[N-2];x++) for(int m=0;m<M;m++) {\n\t\t\t\tans=min(ans,DP[x][N-2][m]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n#define f first\n#define s second\n#define INF (1<<29)\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\n\nint field[155][4];\nint n, m;\n\nint bfs(){\n  queue<P2> que; // (x, y, m, cost)\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[0][j] != 0) que.push(P2(P(j, 0), P(0, 0)));\n  }\n  for(int j = 0 ; j < 4 ; j++){\n    if(field[1][j] != 0 && m != 0) que.push(P2(P(j, 1), P(1, 0)));\n  }\n  int ans = INF;\n  \n  while(!que.empty()){\n    P2 pos = que.front();\n    //cout << pos.f.f << ' ' << pos.f.s << endl;\n    que.pop();\n    if(pos.f.s > n) continue;\n    if(pos.f.s == n-2 && pos.s.f < m){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    if(pos.f.s == n-1){\n      ans = min(ans, pos.s.s);\n      continue;\n    }\n    \n    for(int i = 1 ; i <= 2 ; i++){\n      for(int j = -3 ; j < 3 ; j++){\n\tif(i == 2 && pos.s.f == m) continue;\n\tif(pos.f.s+i >= n || pos.f.f+j < 0 || pos.f.f+j > 3) continue;\n\tif(field[pos.f.s + i][pos.f.f + j] != 0){\n\t  if(i == 1){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\t  \t  \n\t  }\n\t  else if(i == 2){\n\t    que.push(P2(P(pos.f.f+j, pos.f.s+i),\n\t\t\tP(pos.s.f+1, pos.s.s + (field[pos.f.s][pos.f.f] + field[pos.f.s+i][pos.f.f+j]) * abs(j))));\n\t  }\n\t}\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> n >> m){\n    if(n == 0 && m == 0) break;\n    memset(field, 0, sizeof(field));\n    \n    int k, pos, cost;\n    for(int i = 0 ; i < n ; i++){\n      cin >> k;\n      for(int j = 0 ; j < k ; j++){\n\tcin >> pos >> cost;\n\tpos--;\n\tfield[i][pos] = cost;\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define vectorl vector<long long>\nint gcd(int a, int b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\tint r = a % b;\n\treturn gcd(b, r);\n}\nint squ(int x) {\n\treturn x * x;\n}\nint di(vectorl x, vectorl y, int i, int j) {\n\treturn squ(x[i] - x[j]) + squ(y[i] - y[j]);\n}\nint mmin(int &a, int b) {\n\ta = min(a, b);\n\treturn a;\n}\nint mmax(int &a, int b) {\n\ta = max(a, b);\n\treturn a;\n}\nint dan(int fg, int tg, int fr, int tr, vector<vectorl> &it, vector<vectorl> &su) {\n\treturn abs(it[fg][fr] - it[tg][tr])*(su[fg][fr] + su[tg][tr]);\n}\nsigned main() {\n\tint n, m;\n\tcin >> n >> m;\n\twhile(n!=0){\n\tint max = 2000000 * 200+1;\n\tvector<vector<vectorl> > dp(n, vector<vectorl>(m+2, vectorl(10, max)));\n\tvectorl ze(10, 0);\n\tvector<vectorl> it(n, vectorl(10));\n\tvector<vectorl> su(n, vectorl(10));\n\tvectorl k(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k[i];\n\t\tfor (int j = 0; j < k[i]; j++) {\n\t\t\tcin >> it[i][j] >> su[i][j];\n\t\t}\n\t}\n\tdp[0][0] = ze;\n\tdp[1][1] = ze;\n\tfor (int i = 0; i < k[0]; i++) {\n\t\tfor (int j = 0; j < k[1]; j++) {\n\t\t\tmmin(dp[1][0][j], abs(it[0][i] - it[1][j])*(su[0][i] + su[1][j]));\n\t\t}\n\t}\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tfor (int f = 0; f < k[i-1]; f++) {\n\t\t\t\tfor (int t = 0; t < k[i]; t++) {\n\t\t\t\t\tmmin(dp[i][j][t], dp[i-1][j][f] + dan(i - 1, i, f, t,it,su));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int f = 0; f < k[i - 2];f++) {\n\t\t\t\tfor (int t = 0; t < k[i]; t++) {\n\t\t\t\t\tmmin(dp[i][j+1][t], dp[i - 2][j][f] + dan(i - 2, i, f, t, it, su));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = max;\n\tfor (int j = 0; j <= m; j++) {\n\t\tfor (int f = 0; f < k[n - 1]; f++) {\n\t\t\tmmin(ans, dp[n - 1][j][f]);\n\t\t}\n\t\tif (j < m) {\n\t\t\tfor (int f = 0; f < k[n - 2]; f++) {\n\t\t\t\tmmin(ans, dp[n - 2][j][f]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcin >> n >> m;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i__=0;__i__<n;__i__++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\nusing namespace std;\n\nlong COST_LIMIT = 1000 * 1000 * 150;\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n, m; cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    // alloc cost table\n    long **cost_table[3];\n    loop(3, i) {\n      cost_table[i] = new long*[10];\n      loop(10, j) {\n        cost_table[i][j] = new long[m + 1];\n      }\n    }\n    int slip[3][10], slip_i[3][10];\n\n    // operation per row\n    loop(n, row_i) {\n      int prev = (row_i + 1) % 3, crr = (row_i + 2) % 3, next = row_i % 3;\n\n      // init arrays\n      loop(10, i) {\n        loop(m + 1, j) cost_table[next][i][j] = -1;\n        slip[next][i] = -1;\n        slip_i[next][i] = -1;\n      }\n\n      // input\n      {\n        int count; cin >> count;\n        loop(count, i) {\n          int index, slipness; cin >> index >> slipness;\n          slip[next][i] = slipness;\n          slip_i[next][i] = index;\n        }\n      }\n\n      // initial values\n      if (row_i == 0) { \n        loop(10, i) {\n          if (slip_i[next][i] != -1) cost_table[next][i][m] = 0;\n        }\n      }\n\n      // // !debug\n      // if (row_i > 0) \n      // {\n      //   cout << \"row: \" << row_i - 1 << endl;\n      //   loop(10, i) {\n      //     if (slip_i[crr][i] == -1) break;\n      //     loop(m + 1, j) {\n      //       cout << i << \": \" << cost_table[crr][i][j] << \" \";\n      //     }\n      //     cout << endl;\n      //   }\n      // }\n\n      // normal jump\n      if (row_i < 1) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop(m + 1, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, c_col_i) {\n            if (slip_i[crr][c_col_i] == -1) break;\n            if (cost_table[crr][c_col_i][m_i] == -1) continue;\n            int jump_cost = (slip_i[crr][c_col_i] - slip_i[next][n_col_i]) * \n              (slip[crr][c_col_i] + slip[next][n_col_i]);\n            if (jump_cost < 0) jump_cost = -jump_cost;\n\n            // if (row_i == 5 && n_col_i == 0 && c_col_i == 2) {\n            //   cout << \"crr_cost: \" << cost_table[crr][c_col_i][m_i] <<\n            //     \", crr_index: \" << slip_i[crr][c_col_i] <<\n            //     \", crr_slip: \" << slip[crr][c_col_i] <<\n            //     \", to_cost: \" << cost_table[next][n_col_i][m_i] <<\n            //     \", to_index: \" << slip_i[next][n_col_i] <<\n            //     \", to_slip: \" << slip[next][n_col_i] << endl;\n            //   cout << \"cost: \" << cost << endl;\n            // }\n\n            int cost = cost_table[crr][c_col_i][m_i] + jump_cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = c_col_i;\n            }\n          }\n          if (min_cost == -1) {\n            cost_table[next][n_col_i][m_i] = min_cost;\n          } else {\n            // // !debug\n            // if (row_i == 5 && m_i == 0) {\n            //   cout << \"from: \" << min_col << \", to: \" <<\n            //     n_col_i << endl;\n            //   cout << \"col: \" << n_col_i << \", crr_cost: \" << \n            //     cost_table[crr][min_col][m_i] << \", jump_cost: \" <<\n            //     min_cost << \", min_col: \" << min_col << endl;\n            // }\n            cost_table[next][n_col_i][m_i] = min_cost;\n            // if (row_i == 2 && m_i == 0) \n            //   cout << cost_table[next][n_col_i][m_i] << endl; \n          }\n        }\n      }\n\n      // big jump from bank\n      if (row_i == 1 && m > 0) {\n        loop(10, n_col_i) {\n          if (slip_i[next][n_col_i] == -1) break;\n          cost_table[next][n_col_i][m - 1] = 0;\n        }\n      }\n\n      // big jump\n      if (row_i < 2) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop_from_to(1, m, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, p_col_i) {\n            if (slip_i[prev][p_col_i] == -1) break;\n            if (cost_table[prev][p_col_i][m_i] == -1) continue;\n            int jump_cost = (slip_i[prev][p_col_i] - slip_i[next][n_col_i]) * \n              (slip[prev][p_col_i] + slip[next][n_col_i]);\n            if (jump_cost < 0) jump_cost = -jump_cost;\n            int cost = cost_table[prev][p_col_i][m_i] + jump_cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = p_col_i;\n            }\n          }\n          if (min_cost != -1) {\n            int prev_cost = cost_table[prev][min_col][m_i];\n            // cout << \"col\" << n_col_i << \"prev cost:\" << prev_cost << endl;\n            // cout << \"col: \" << n_col_i << \", m: \" << m_i << endl;\n            if (cost_table[next][n_col_i][m_i - 1] == -1 ||\n                cost_table[next][n_col_i][m_i - 1] > prev_cost) {\n              cost_table[next][n_col_i][m_i - 1] = min_cost;\n            }\n          }\n          // int prev_cost = cost_table[prev][min_col][m_i];\n          // if (prev_cost != -1) min_cost += prev_cost;\n          // assign_if_smaller(cost_table[next][n_col_i][m_i - 1], min_cost);\n        }\n      }\n\n    }\n\n    // // !debug\n    // cout << \"row: \" << n - 1 << endl;\n    // loop(10, i) {\n    //   if (slip_i[(n - 1) % 3][i] == -1) break;\n    //   loop(m + 1, j) {\n    //     cout << i << \": \" << cost_table[(n - 1) % 3][i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n\n    long min_cost = COST_LIMIT;\n    loop(10, i) {\n      loop(m + 1, j) {\n        int cost = cost_table[(n - 1) % 3][i][j];\n        if (cost == -1) continue;\n        assign_if_smaller(min_cost, cost);\n      }\n    }\n\n    if (n > 1)\n    {\n      loop(10, i) {\n        loop_from_to(1, m, j) {\n          int cost = cost_table[(n - 2) % 3][i][j];\n          if (cost == -1) continue;\n          assign_if_smaller(min_cost, cost);\n        }\n      }\n    }\n\n    cout << min_cost << endl;\n\n    // free cost table\n    loop(3, i) {\n      loop(10, j) delete cost_table[i][j];\n      delete cost_table[i];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#define MP make_pair\n#define INF 1000000000\nusing namespace std;\n\nint dp[3][11][85];\nvector<pair<int,int> > ve[160];\nint main(){\n\tint N,M,a,b,c,T,I,O,tmp,cnt,cntt,hog,res;\n\tvector<pair<int,int> >::iterator it,lit;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tve[0].clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tve[i].clear();\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b>>c;\n\t\t\t\tve[i].push_back(MP(b,c));\n\t\t\t}\n\t\t}\n\t\t\n\t\tT=0;I=1;O=2;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfill(dp[i][j],dp[i][j]+85,INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<11;i++){\n\t\t\tve[0].push_back(MP(0,0));\n\t\t\tdp[T][i][0]=0;\n\t\t}\n\t\tfor(int i=0;i<(int)ve[0].size();i++){\n\t\t\tdp[I][i][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcnt=0;\n\t\t\tfor(it=ve[i].begin();it!=ve[i].end();it++){\n\t\t\t\tfor(int j=0;j<=min(i/2,M);j++){\n\t\t\t\t\tcntt=0;\n\t\t\t\t\thog=INF;\n\t\t\t\t\tfor(lit=ve[i-1].begin();lit!=ve[i-1].end();lit++){\n\t\t\t\t\t\thog=min(hog,dp[I][cntt][j]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\tcntt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\tcntt=0;\n\t\t\t\t\t\tfor(lit=ve[i-2].begin();lit!=ve[i-2].end();lit++){\n\t\t\t\t\t\t\thog=min(hog,dp[T][cntt][j-1]+((lit->second)+(it->second))*abs((lit->first)-(it->first)));\n\t\t\t\t\t\t\tcntt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[O][cnt][j]=hog;\n\t\t\t\t\t//cout<<i<<\" \"<<cnt<<\" \"<<j<<\" \"<<hog<<endl;//\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ttmp=T;\n\t\t\tT=I;\n\t\t\tI=O;\n\t\t\tO=tmp;\n\t\t}\n\t\tres=INF;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tfor(int j=0;j<(int)ve[N].size();j++){\n\t\t\t\tres=min(res,dp[I][j][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define SQR(a) ((a)*(a))\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pr;\ntypedef pair<pr,ll> ppr;\ntypedef vector<pr> vpr;\nconst int INF=1<<30;\nint DP[152][152][4];\nint main() {\n\tint n,m,times,tmp;\n\twhile(cin >> n >> m && n){\n\tint block[152][4]={};\n\tREP(i,152)\n\t\tREP(j,152)\n\t\t\tREP(k,4)\n\t\t\t\tDP[i][j][k]=INF;\n\tREP(i,n){\n\t\tcin >> times;\n\t\tREP(j,times){\n\t\tcin >> tmp;\n\t\tcin >> block[i][tmp-1];\n\t\t}\n\t}\n\tREP(i,4){\n\tDP[0][0][i]=0;\n\tDP[1][1][i]=0;\n\tblock[n][i]=1;\n\t}\n\tFOR(i,1,n+1)\n\t\tREP(j,4)\n\t\t\tif(block[i][j])\n\t\t\tREP(l,m+1)\n\t\t\t\tREP(k,4){\n\t\t\t\t\tif(block[i-1][k])\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-1][l][k]+abs(j-k)*(block[i-1][k]+block[i][j]));\n\t\t\t\t\tif(block[i-2][k] && l && i!=1)\n\t\t\t\t\tDP[i][l][j]=min(DP[i][l][j],DP[i-2][l-1][k]+abs(j-k)*(block[i-2][k]+block[i][j]));\n\t\t\t\t}\n\tint minium=INF;\n\tREP(i,4)\n\t\tREP(j,m+1)\n\t\t\tminium=min(minium,DP[n][j][i]);\n\tcout << minium << endl;\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct P{\n  int x,c;\n  P(int x,int c):x(x),c(c){}\n};\nint n;\nvector<P> s[150];\nint dp[155][11][77];\nint solve(int y,int i,int m){\n  if(y >= n) return 0;\n  if(dp[y][i][m] >= 0) return dp[y][i][m];\n\n  int ret = 1 << 22;\n  for(int j = 0; j < (int)s[y+1].size(); j++){\n    ret = min(ret,solve(y+1,j,m) + ((y)?(s[y][i].c + s[y+1][j].c) * abs(s[y][i].x - s[y+1][j].x):0));\n  }\n  if(m){\n    for(int j = 0; j < (int)s[y+2].size(); j++){\n      ret = min(ret,solve(y+2,j,m-1) + ((y)?(s[y][i].c + s[y+2][j].c) * abs(s[y][i].x - s[y+2][j].x):0));\n    }\n  }\n  return dp[y][i][m] = ret;\n}\nint main(void){\n  while(1){\n    int m;\n    scanf(\"%d%d\",&n,&m); if(!n) break;\n    memset(dp,-1,sizeof(dp));\n    for(int i = 1; i <= n; i++){\n      s[i].clear();\n      int k;\n      scanf(\"%d\",&k);\n      for(int j = 0; j < k; j++){\n\tint x,d;\n\tscanf(\"%d%d\",&x,&d);\n\ts[i].push_back(P(x,d));\n      }\n    }\n    s[0].push_back(P(0,0));\n    /*\n    for(int i = 0; i < (int)s[0].size(); i++){\n      ret = min(ret,solve(0,i,m));\n    }\n    */\n    printf(\"%d\\n\",solve(0,0,m));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 1000000000\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    int dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    if(i==2)dp[i][j][l]=0;\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t  }\n\t}\n      }\n    }\n    \n    int ans=INF;\n    for(int i=0;i<v[n].size();i++)ans=min(ans,dp[n][i][0]);\n    if(m>=1)for(int i=0;i<v[n-1].size();i++)ans=min(ans,dp[n-1][i][1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define repeat(n) for(int __i__=0;__i__<n;__i__++)\n#define loop_from_to(from, to, i) for(int i=from;i<=to;i++)\n#define multi_cin(n, array) loop(n,i){cin>>array[i];}\n#define assign_if_smaller(var, val) if(var>val)var=val;\n#define assign_if_larger(var, val) if(var<val)var=val;\nusing namespace std;\n\nlong COST_LIMIT = 1000 * 1000 * 150;\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int n, m; cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    // alloc cost table\n    long **cost_table[3];\n    loop(3, i) {\n      cost_table[i] = new long*[10];\n      loop(10, j) {\n        cost_table[i][j] = new long[m + 1];\n      }\n    }\n    int slip[3][10], slip_i[3][10];\n\n    // operation per row\n    loop(n, row_i) {\n      int prev = (row_i + 1) % 3, crr = (row_i + 2) % 3, next = row_i % 3;\n\n      // init arrays\n      loop(10, i) {\n        loop(m + 1, j) cost_table[next][i][j] = -1;\n        slip[next][i] = -1;\n        slip_i[next][i] = -1;\n      }\n\n      // input\n      {\n        int count; cin >> count;\n        loop(count, i) {\n          int index, slipness; cin >> index >> slipness;\n          slip[next][i] = slipness;\n          slip_i[next][i] = index;\n        }\n      }\n\n      // initial values\n      if (row_i == 0) { \n        loop(10, i) {\n          if (slip_i[next][i] != -1) cost_table[next][i][m] = 0;\n        }\n      }\n\n      // // !debug\n      // if (row_i > 0) \n      // {\n      //   cout << \"row: \" << row_i - 1 << endl;\n      //   loop(10, i) {\n      //     if (slip_i[crr][i] == -1) break;\n      //     loop(m + 1, j) {\n      //       cout << i << \": \" << cost_table[crr][i][j] << \" \";\n      //     }\n      //     cout << endl;\n      //   }\n      // }\n\n      // normal jump\n      if (row_i < 1) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop(m + 1, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, c_col_i) {\n            if (slip_i[crr][c_col_i] == -1) break;\n            if (cost_table[crr][c_col_i][m_i] == -1) continue;\n            int jump_cost = (slip_i[crr][c_col_i] - slip_i[next][n_col_i]) * \n              (slip[crr][c_col_i] + slip[next][n_col_i]);\n            if (jump_cost < 0) jump_cost = -jump_cost;\n\n            // if (row_i == 5 && n_col_i == 0 && c_col_i == 2) {\n            //   cout << \"crr_cost: \" << cost_table[crr][c_col_i][m_i] <<\n            //     \", crr_index: \" << slip_i[crr][c_col_i] <<\n            //     \", crr_slip: \" << slip[crr][c_col_i] <<\n            //     \", to_cost: \" << cost_table[next][n_col_i][m_i] <<\n            //     \", to_index: \" << slip_i[next][n_col_i] <<\n            //     \", to_slip: \" << slip[next][n_col_i] << endl;\n            //   cout << \"cost: \" << cost << endl;\n            // }\n\n            int cost = cost_table[crr][c_col_i][m_i] + jump_cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = c_col_i;\n            }\n          }\n          if (min_cost == -1) {\n            cost_table[next][n_col_i][m_i] = min_cost;\n          } else {\n            // // !debug\n            // if (row_i == 5 && m_i == 0) {\n            //   cout << \"from: \" << min_col << \", to: \" <<\n            //     n_col_i << endl;\n            //   cout << \"col: \" << n_col_i << \", crr_cost: \" << \n            //     cost_table[crr][min_col][m_i] << \", jump_cost: \" <<\n            //     min_cost << \", min_col: \" << min_col << endl;\n            // }\n            cost_table[next][n_col_i][m_i] = min_cost;\n            // if (row_i == 2 && m_i == 0) \n            //   cout << cost_table[next][n_col_i][m_i] << endl; \n          }\n        }\n      }\n\n      // big jump from bank\n      if (row_i == 1 && m > 0) {\n        loop(10, n_col_i) {\n          if (slip_i[next][n_col_i] == -1) break;\n          cost_table[next][n_col_i][m - 1] = 0;\n        }\n      }\n\n      // big jump\n      if (row_i < 2) continue;\n      loop(10, n_col_i) {\n        if (slip_i[next][n_col_i] == -1) break;\n        loop_from_to(1, m, m_i) {\n          long min_cost = -1;\n          int min_col;\n          loop(10, p_col_i) {\n            if (slip_i[prev][p_col_i] == -1) break;\n            if (cost_table[prev][p_col_i][m_i] == -1) continue;\n            int jump_cost = (slip_i[prev][p_col_i] - slip_i[next][n_col_i]) * \n              (slip[prev][p_col_i] + slip[next][n_col_i]);\n            if (jump_cost < 0) jump_cost = -jump_cost;\n            int cost = cost_table[crr][p_col_i][m_i] + jump_cost;\n\n            if (min_cost == -1 || min_cost > cost) {\n              min_cost = cost;\n              min_col = p_col_i;\n            }\n          }\n          if (min_cost != -1) {\n            int prev_cost = cost_table[prev][min_col][m_i];\n            // cout << \"col\" << n_col_i << \"prev cost:\" << prev_cost << endl;\n            // cout << \"col: \" << n_col_i << \", m: \" << m_i << endl;\n            if (cost_table[next][n_col_i][m_i - 1] == -1 ||\n                cost_table[next][n_col_i][m_i - 1] > prev_cost) {\n              cost_table[next][n_col_i][m_i - 1] = min_cost + prev_cost;\n            }\n          }\n          // int prev_cost = cost_table[prev][min_col][m_i];\n          // if (prev_cost != -1) min_cost += prev_cost;\n          // assign_if_smaller(cost_table[next][n_col_i][m_i - 1], min_cost);\n        }\n      }\n\n    }\n\n    // // !debug\n    // cout << \"row: \" << n - 1 << endl;\n    // loop(10, i) {\n    //   if (slip_i[(n - 1) % 3][i] == -1) break;\n    //   loop(m + 1, j) {\n    //     cout << i << \": \" << cost_table[(n - 1) % 3][i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n\n    long min_cost = COST_LIMIT;\n    loop(10, i) {\n      loop(m + 1, j) {\n        int cost = cost_table[(n - 1) % 3][i][j];\n        if (cost == -1) continue;\n        assign_if_smaller(min_cost, cost);\n      }\n    }\n\n    if (n > 1)\n    {\n      loop(10, i) {\n        loop_from_to(1, m, j) {\n          int cost = cost_table[(n - 2) % 3][i][j];\n          if (cost == -1) continue;\n          assign_if_smaller(min_cost, cost);\n        }\n      }\n    }\n\n    cout << min_cost << endl;\n\n    // free cost table\n    loop(3, i) {\n      loop(10, j) delete cost_table[i][j];\n      delete cost_table[i];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n\tint n , m;\n\t\n\twhile(cin >> n >> m , n ){\n\t\tint pos[151][10] ={0};\n\t\tint rate[151][10] = {0};\n\t\tint cnt[151] = {0};\n\t\tfor(int i = 1 ; i <= n ;i++){\n\t\t\tint k; cin >> k;\n\t\t\tcnt[i] = k;\n\t\t\trep(j,k){\n\t\t\t\tcin >> pos[i][j] >> rate[i][j];\n\t\t\t}\n\t\t}\n\t\tn++;\n\t\t\n\t\tint dp[152][10][80] = {0};\n\t\trep(i,151)rep(j,10)rep(k,80)dp[i][j][k] = (1<<29);\n\t\trep(j,10)rep(k,80)dp[0][j][k] = 0;\n\t\trep(j,10)rate[0][j] = 0;\n\t\tcnt[0] = 1;\n\t\t\n\t\tfor(int k = m ; k>=0 ; k--){\n\t\t\tfor(int i = 1;i<n;i++){\n\t\t\t\trep(prev,cnt[i-1]){\n\t\t\t\t\trep(cur,cnt[i]){\n\t\t\t\t\t\tif(i-1){\n\t\t\t\t\t\t\tdp[i][cur][k] = min(\n\t\t\t\t\t\t\t\tdp[i][cur][k], \n\t\t\t\t\t\t\t\tdp[i-1][prev][k] + (rate[i][cur]+rate[i-1][prev]) * abs( pos[i][cur] - pos[i-1][prev] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][cur][k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k){\n\t\t\t\tfor(int i=2;i<n;i++){\n\t\t\t\t\trep(prev,cnt[i-2]){\n\t\t\t\t\t\trep(cur,cnt[i]){\n\t\t\t\t\t\t\tif(i-2){\n\t\t\t\t\t\t\t\tdp[i][cur][k-1] = min(\n\t\t\t\t\t\t\t\t\tdp[i][cur][k-1] , \n\t\t\t\t\t\t\t\t\tdp[i-2][prev][k] + (rate[i][cur]+rate[i-2][prev]) * abs( pos[i][cur] - pos[i-2][prev] )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdp[i][cur][k-1] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = (1<<29);\n\t\trep(k,m+1){\n\t\t\tif(k)rep(i,cnt[n-2])ret = min(ret,dp[n-2][i][k]);\n\t\t\trep(i,cnt[n-1])ret = min(ret,dp[n-1][i][k]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint sz[200];\nP stone[200][20];\nint dp[200][20][200];\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && (n || m)){\n\t\tfill(sz, sz + 200, 0);\n\t\tfill(&dp[0][0][0], &dp[199][19][199] + 1, INF);\n\t\tdp[0][0][m] = 0;\n\t\tint res = INF;\n\t\tsz[0] = sz[n+1] = sz[n+2] = 1;\n\t\trep(i, n){\n\t\t\tcin >> sz[i+1];\n\t\t\trep(j, sz[i+1]){\n\t\t\t\tint x, r;\n\t\t\t\tcin >> x >> r;\n\t\t\t\tstone[i+1][j] = P(x, r);\n\t\t\t}\n\t\t}\n\n\t\trep2(i, 1, n + 3){\n\t\t\trep(j, sz[i]){\n\t\t\t\trep(k, m + 1){\n\t\t\t\t\trep(l, sz[i-1]){\n\t\t\t\t\t\tint cost = (i > n || i == 1) ? 0 :\n\t\t\t\t\t\t\tabs(stone[i][j].first - stone[i-1][l].first)\n\t\t\t\t\t\t\t * (stone[i][j].second + stone[i-1][l].second);\n\t\t\t\t\t\tdp[i][j][k] = min(dp[i-1][l][k] + cost, dp[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\trep(l, sz[i-2]){\n\t\t\t\t\t\tint cost = (i <= 2 || n < i) ? 0 : \n\t\t\t\t\t\t\tabs(stone[i][j].first - stone[i-2][l].first) * (stone[i][j].second + stone[i-2][l].second);\n\t\t\t\t\t\tdp[i][j][k] = (i == 1) ? 0 : min(dp[i-2][l][k+1] + cost, dp[i][j][k]); \t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep2(i, n+1, n+3)rep(j, m+1) res = min(res, dp[i][0][j]);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\nint dkmp[150][1000][76];//動計(メモ再)用。\nint maps[150][1000];//盤面用。\nint m,n;\n\nint saiki(int tate,int yoko,int zan);\n\nint mins(int a,int b){\n  if(a==-2)return b;\n  else return (a>b)?b:a;\n}\nint main(void){\n\n  scanf(\"%d%d\",&n,&m);\n  while(n!=0){\n\n\n    memset(maps,-1,sizeof(maps));\n    memset(dkmp,-1,sizeof(dkmp));\n    int i=0;\n    int j=0;\n    int jm,xm;\n    for(i=0;i<n;i++){\n      scanf(\"%d\",&jm);\n      for(j=0;j<jm;j++){\n\tscanf(\"%d\",&xm);\n\tscanf(\"%d\",&(maps[i][xm-1]));\n      }\n    }\n    //maps[i][j]には、岸からi+1つめの石で、j列にある石のあれ。\n    //maps[n][x]は、向こう岸。\n    int ans=-2;\n    int memyo=0;\n    for(i=0;i<1000;i++){\n      if(maps[0][i]!=-1){\n\tmemyo=saiki(0,i,m);\n\tans=mins(ans,memyo);\n      }\n    }\n    if(m>0){\n      for(i=0;i<1000;i++){\n\tif(maps[0][i]!=-1){\n\t  memyo=saiki(1,i,m-1);\n\t  ans=mins(ans,memyo);\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n    scanf(\"%d%d\",&n,&m);\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n//再帰用。縦tate、横yokoの石で、残りzan回飛べるとき、\n//岸にたどり着くまでの危険度の最小値を返す。\n//dkmpのが-1なら未調査。-2なら到達不可能。\nint saiki(int tate,int yoko,int zan){\n  if(dkmp[tate][yoko][zan]!=-1){\n    return dkmp[tate][yoko][zan];\n  }\n\n  if(tate+1>=n || (tate+2>=n && zan>0)){\n    dkmp[tate][yoko][zan]=0;\n    return 0;\n  }\n\n  int ret=-2,si,mema=0,memb=0,memc=0;\n  for(si=0;si<1000;si++){\n    mema=maps[tate+1][si];\n    if(mema!=-1){\n      memb=saiki(tate+1,si,zan);\n      if(memb==-2)continue;\n      memc=(mema+maps[tate][yoko])*(abs(yoko-si));\n      ret=mins(ret,memb+memc);\n    }\n  }\n\n  if(zan>0){\n    for(si=0;si<1000;si++){\n      mema=maps[tate+2][si];\n      if(mema!=-1){\n\tmemb=saiki(tate+2,si,zan-1);\n\tif(memb==-2)continue;\n\tmemc=(mema+maps[tate][yoko])*(abs(yoko-si));\n\tret=mins(ret,memb+memc);\n      }\n    }\n  }\n  dkmp[tate][yoko][zan]=ret;\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint numstone[151];\npair<int,int> stones[151][11];\nint memo[151][151][11]; //memo[ツ甘敖つゥツづァツづ個仰猟猟」][ツ氾イツづ篠つオツ氾イツづ堕づーツつオツつスツ嘉アツ青脳[ツ債。ツづ個暗環置]\nint n,m;\n\nint solve(int i,int j,int k) {\n  if(memo[i][j][k] != -1) return memo[i][j][k];\n  if(i >= n-1 || (j < m && i == n-2)) return 0;\n\n  int l,ret = 1<<29;\n  if(j < m) {\n    rep(l,numstone[i+2]) {\n      int cc = stones[i][k].second+stones[i+2][l].second;\n      ret = min(ret, solve(i+2, j+1, l)\n\t\t+ cc*abs(stones[i][k].first-stones[i+2][l].first));\n    }\n  }\n\n  rep(l, numstone[i+1]) {\n    int cc = stones[i][k].second+stones[i+1][l].second;\n    ret = min(ret, solve(i+1, j, l)\n\t      + cc*abs(stones[i][k].first-stones[i+1][l].first));\n  }\n  //printf(\"row: %d double: %d nowpos: %d ret: %d\\n\", i,j,k,ret);\n  return memo[i][j][k] = ret;\n}\n\nint main() {\n  int k,i,j;\n  while(scanf(\"%d%d\", &n, &m), n|m) {\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,151) rep(j,151) rep(k,11) memo[i][j][k] = -1;\n    rep(i,n) {\n      scanf(\"%d\", &k);\n      numstone[i] = k;\n      rep(j,k) {\n\tpair<int,int> p;\n\tscanf(\"%d%d\", &(p.first), &(p.second));\n\tstones[i][j] = p;\n      }\n    }\n\n    int ans = 1<<29;\n    rep(i, numstone[0]) {\n      ans = min(ans, solve(0,0,i));\n    }\n    if(m >= 1) {\n      rep(i, numstone[1]) {\n\tans = min(ans, solve(1,1,i));\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tpii p;\n\tint c, j;\n\tstate(pii p, int c, int j) : p(p), c(c), j(j) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint risk(int cd, int nd, int dx) {\n\treturn (cd+nd)*dx;\n}\n\nint stone[150][1000];\nint field[150][1000][80];\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tREP(i, 150) {\n\t\t\tREP(j, 1000) {\n\t\t\t\tstone[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint maxx = 0;\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j, k) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tstone[i][x-1] = d;\n\t\t\t\tmaxx = max(maxx, x);\n\t\t\t}\n\t\t}\n\n\t\tREP(i, 150) {\n\t\t\tREP(j, 1000) {\n\t\t\t\tREP(k, 80) {\n\t\t\t\t\tfield[i][j][k] = INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> Q;\n\t\tREP(i, maxx) {\n\t\t\tif(stone[0][i] != -1) {\n\t\t\t\tfield[0][i][0] = 0;\n\t\t\t\tQ.push(state(pii(0, i), 0, 0));\n\t\t\t}\n\t\t}\n\t\tif(n > 1 && m > 0) {\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[1][i] != -1) {\n\t\t\t\t\tfield[1][i][1] = 0;\n\t\t\t\t\tQ.push(state(pii(1, i), 0, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\n\t\tint ans = INT_MAX;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tint y = st.p.first, x = st.p.second;\n\t\t\tif(y+2 == n && st.j < m) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(y+1 == n) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[y+1][i] != -1) {\n\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+1][i], abs(x-i));\n\t\t\t\t\tif(nc < field[y+1][i][st.j]) {\n\t\t\t\t\t\tfield[y+1][i][st.j] = nc;\n\t\t\t\t\t\tQ.push(state(pii(y+1, i), nc, st.j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(st.j < m && y+2 < n) {\n\t\t\t\tREP(i, maxx) {\n\t\t\t\t\tif(stone[y+2][i] != -1) {\n\t\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+2][i], abs(x-i));\n\t\t\t\t\t\tif(nc < field[y+2][i][st.j+1]) {\n\t\t\t\t\t\t\tfield[y+2][i][st.j+1] = nc;\n\t\t\t\t\t\t\tQ.push(state(pii(y+2, i), nc, st.j+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define MAX_N 200\n#define INF (1<<24)\nstruct state{\n  int cost,h,J,cnt;\n  bool operator < (const state& p)const{\n    return cost > p.cost;\n  }\n};\n\nstruct data{\n  int w,cost;\n};\n\nvector<data> G[MAX_N];\nint n,m;\nint d[MAX_N][MAX_N][MAX_N];\n\nvoid solve(){\n  int ans=INF;\n  for(int i=0;i<MAX_N;i++)\n    for(int j=0;j<MAX_N;j++)\n      for(int k=0;k<MAX_N;k++)\n\td[i][j][k]=INF;\n \n  priority_queue < state > Q;\n  for(int i=0;i<2;i++){\n    if(m-i<0)break;\n    for(int j=0;j<(int)G[i].size();j++){\n      data e=G[i][j];\n      d[i][j][m-i]=0;\n      Q.push((state){0,i,j,m-i});\n    }\n  }\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    //cout<<s.h<<' '<<s.J<<' '<<s.cost<<' '<<s.cnt<<endl;\n    if(s.h+1==n){\n      ans=min(ans,s.cost);\n    }else if(s.h+2==n&&s.cnt>=1){\n      ans=min(ans,s.cost);\n    }\n    \n    if(s.cost>d[s.h][s.J][s.cnt])continue;\n    \n    data f=G[s.h][s.J];\n    if(s.h+1>=n)continue;\n    for(int i=0;i<(int)G[s.h+1].size();i++){\n      data e=G[s.h+1][i];\n      int ncost=(f.cost+e.cost)*abs(f.w-e.w)+s.cost;\n      if(ncost>=d[s.h+1][i][s.cnt])continue;\n      d[s.h+1][i][s.cnt]=ncost;\n      Q.push( (state){d[s.h+1][i][s.cnt],s.h+1,i,s.cnt} );\n    }\n\n    if(s.cnt==0||s.h+2>=n)continue;\n    s.cnt--;\n    for(int i=0;i<(int)G[s.h+2].size();i++){\n      data e=G[s.h+2][i];\n      int ncost=(f.cost+e.cost)*abs(f.w-e.w)+s.cost;\n      if(ncost>=d[s.h+2][i][s.cnt])continue;\n      d[s.h+2][i][s.cnt]=ncost;\n      Q.push( (state){d[s.h+2][i][s.cnt],s.h+2,i,s.cnt} );\n    }\n  }\n  cout<<ans<<endl;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++)G[i].clear();\n \n}\nint main(){\n  int a,b,c;\n  while(cin>>n>>m){\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>a;\n      for(int j=0;j<a;j++){\n\tcin>>b>>c;\n\tG[i].push_back( (data){b,c} );\n      }\n    }\n\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define M LLONG_MAX\nll dp[151][1001][77],ma[151][1001];\nint main(void){\n\tll n,m,i,j,k,l,a,x,d,t,mi,mx;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=1000;j++){\n\t\t\t\tma[i][j]=-1;\n\t\t\t\tfor(k=0;k<=1000;k++) dp[i][j][k]=M;\n\t\t\t}\n\t\t}\n\t\tmx=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a;\n\t\t\tfor(j=0;j<a;j++){\n\t\t\t\tcin>>x>>d;\n\t\t\t\tma[i][x]=d;\n\t\t\t\tmx=max(mx,x);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tif(ma[1][i]!=-1) dp[1][i][m]=0;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\tfor(j=1;j<=mx;j++){\n\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\tif(dp[i][j][k]!=M){\n\t\t\t\t\t\tfor(l=0;l<=mx;l++){\n\t\t\t\t\t\t\tif(ma[i+1][l]!=-1){\n\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+1][l])*abs(j-l);\n\t\t\t\t\t\t\t\tdp[i+1][l][k]=min(dp[i+1][l][k],t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(i+2<=n&&k>0){\n\t\t\t\t\t\t\t\tif(ma[i+2][l]!=-1){\n\t\t\t\t\t\t\t\t\tt=dp[i][j][k]+(ma[i][j]+ma[i+2][l])*abs(j-l);\n\t\t\t\t\t\t\t\t\tdp[i+2][l][k-1]=min(dp[i+2][l][k-1],t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tcout<<endl;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tfor(j=1;j<=mx;j++) cout<<dp[i][j][0]<<':'<<dp[i][j][1]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tmi=M;\n\t\tfor(i=1;i<=mx;i++){\n\t\t\tfor(j=0;j<=m;j++) mi=min(mi,dp[n][i][j]);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <map>\n#include <vector>\n#include <algorithm>\n#define inf INT_MAX/2\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\nint n, m;\nvector<P> riv[150];\nvector<vector<vector<int> > > dp(150);\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        for (int i=0; i<n; i++) {\n            int k; scanf(\"%d\",&k);\n            riv[i].clear();\n            for (int j=0; j<k; j++) {\n                int x, d; scanf(\"%d%d\",&x,&d);\n                riv[i].push_back(P(x,d));\n            }\n        }\n        for (int i=0; i<n; i++) {\n            dp[i].resize(riv[i].size(), vector<int>(m+1,inf));\n        }\n        for (int i=0; i<riv[0].size(); i++) {\n            dp[0][i][0]=0;\n        }\n        for (int i=0; i<riv[1].size(); i++) {\n            dp[1][i][1]=0;\n        }\n        int res=inf;\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<riv[i].size(); j++) {\n                for (int k=0; k<=m; k++) {\n                    if (i+1==n) {\n                        res=min(res,dp[i][j][k]);\n                    } else {\n                        for (int l=0; l<riv[i+1].size(); l++) {\n                            dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+(int)abs(riv[i][j].f-riv[i+1][l].f)*(riv[i][j].s+riv[i+1][l].s));\n                        }\n                        if (i<n-1&&k<m) {\n                            if (i+2==n) {\n                                res=min(res,dp[i][j][k]);\n                            } else {\n                                for (int l=0; l<riv[i+2].size(); l++) {\n                                    dp[i+2][l][k+1]=min(dp[i+2][l][k+1],dp[i][j][k]+(int)abs(riv[i][j].f-riv[i+2][l].f)*(riv[i][j].s+riv[i+2][l].s));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Solution for aoj:0530 Pyon-Pyon River Crossing\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int INF = 100000000, MAX_N = 150;\ntypedef pair<int, int> P;\nint n, m, ans;\nint dp[MAX_N + 20][10010][760];\nP stone, stone2;\nvector<P> Stone[151]; //first:??????second:???????????????\nint main(){\n\twhile (cin >> n >> m){\n\t\tif (!n&&!m)\n\t\t\treturn 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tStone[i].clear();\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tcin >> a >> b;\n\t\t\t\tStone[i].push_back(P(a, b));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tfor (int j = 1; j <= 1000; j++){\n\t\t\t\tfor (int k = 0; k <= m; k++){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Stone[2].size(); i++){\n\t\t\tstone = Stone[2][i];\n\t\t\tdp[2][stone.first][m] = INF;\n\t\t}\n\t\tfor (int i = 3; i <= n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t\tdp[i][stone.first][k] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++){\n\t\t\tfor (int j = 0; j < Stone[i].size(); j++){\n\t\t\t\tstone = Stone[i][j];\n\t\t\t\tfor (int k = 0; k < Stone[i + 1].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 1][k];\n\t\t\t\t\tfor (int l = m; l >= m - (i + 1) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (l != m)\n\t\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], dp[i + 1][stone2.first][l + 1]);\n\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 1][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < Stone[i + 2].size(); k++){\n\t\t\t\t\tstone2 = Stone[i + 2][k];\n\t\t\t\t\tfor (int l = m - 1; l >= m - (i + 2) / 2; l--){\n\t\t\t\t\t\tif (l < 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (l != m)\n\t\t\t\t\t\t\tdp[i + 1][stone2.first][l] = min(dp[i + 2][stone2.first][l], dp[i + 2][stone2.first][l + 1]);\n\t\t\t\t\t\tdp[i + 2][stone2.first][l] = min(dp[i + 2][stone2.first][l], (stone.second + stone2.second)*abs(stone.first - stone2.first) + dp[i][stone.first][l + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor (int i = 0; i < Stone[n].size(); i++){\n\t\t\tstone = Stone[n][i];\n\t\t\tans = min(dp[n][stone.first][0], ans);\n\t\t}\n\t\tfor (int i = 0; i < Stone[n - 1].size(); i++){\n\t\t\tif (m == 0)\n\t\t\t\tbreak;\n\t\t\tstone = Stone[n - 1][i];\n\t\t\tif (dp[n - 1][stone.first][1])\n\t\t\t\tans = min(dp[n - 1][stone.first][1], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150]; //K[i]::=i行目に何個の石があるか\nint X[10][150]; //X[i][j]::=j列目のi個目が何列目か\nint D[10][150]; //D[i][j]::=j列目のi個目のすべりやすさ\nint DP[10][150][80]; //DP[i][j][k]::=j列目のi個目にいて、あとk回ジャンプできる\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tmemset(K,0,sizeof(K));\n\t\tmemset(X,0,sizeof(X));\n\t\tmemset(D,0,sizeof(D));\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][M]=0;\n\t\tfor(int x=0;x<K[1];x++) DP[x][1][M-1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y==1) continue;\n\t\t\tfor(int xx=0;xx<K[y-2];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m+1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-2];x++) for(int m=1;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-2][m]);\n\t\t}\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<math.h>\n#define INF 1<<30\nusing namespace std;\nint main() {\n\tint row, jump;\n\tint dp[151][11][76];\n\tint val[151][11];\n\tint Size[151];\n\tint num[151][11];\n\n\twhile (cin >> row >> jump, row)\n\t{\n\t\t\n\t\tfor (int i = 0; i < row; i++) {\n\t\t\tcin >> Size[i];\n\t\t\tfor (int j = 0; j < Size[i]; j++) {\n\t\t\t\tcin >> num[i][j] >> val[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0x7f, sizeof(dp));\t\t\t//初期化\n\t\tfor (int i = 0; i < Size[0]; i++)\t\t//岸からのジャンプ\n\t\t\tdp[0][i][0] = 0;\n\t\tfor (int i = 0; i < Size[1]; i++)\n\t\t\tdp[1][i][1] = 0;\n\n\t\tfor (int i = 0; i < row-1; i++) {\n\t\t\tfor (int j = 0; j < Size[i]; j++) {\n\t\t\t\tfor (int k = 0; k < Size[i + 1]; k++) {\n\t\t\t\t\tint risk = (val[i][j] + val[i + 1][k])*abs(num[i][j] - num[i+1][k]);\n\t\t\t\t\tfor (int m = 0; m <= jump; m++)\n\t\t\t\t\t\tdp[i + 1][k][m] = min(dp[i + 1][k][m], dp[i][j][m] + risk);\n\t\t\t\t}\n\t\t\t\tif (i == row - 2)continue;\n\t\t\t\tfor (int k = 0; k < Size[i + 2]; k++) {\n\t\t\t\t\tint risk = (val[i][j] + val[i + 2][k])*abs(num[i][j] - num[i + 2][k]);\n\t\t\t\t\tfor (int m = 0; m < jump; m++)\n\t\t\t\t\t\tdp[i + 2][k][m+1] = min(dp[i + 2][k][m+1], dp[i][j][m] + risk);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tint Min = 0x7f7f7f7f;\n\n\t\tfor (int i = 0; i < Size[row - 1]; i++)\n\t\t\tfor (int j = 0; j <= jump; j++) {\n\t\t\t\tMin = min(Min, dp[row - 1][i][j]);\n\n\t\t\t}\n\t\tfor (int i = 0; i < Size[row - 2]; i++)\n\t\t\tfor (int j = 0; j < jump; j++)\n\t\t\t\tMin = min(Min, dp[row - 2][i][j]);\n\t\t\n\t\tcout << Min << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[256][16][128];\nP stones[256][16];\nint col[256];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tint x, d;\n\tcin >> x >> d;\n\tstones[i][j] = P(x, d);\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tint x_now = stones[i][j].first, d_now = stones[i][j].second;\n\tREP(k, col[i+1]) {\n\t  int x_next = stones[i+1][k].first, d_next = stones[i+1][k].second;\n\t  int safe = (d_now + d_next) * abs(x_now - x_next);\n\t  REP(m, M+1) {\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + safe);\n\t  }\n\t}\n\tif (i < N-2) {\n\t  REP(k, col[i+2]) {\n\t    int x_next = stones[i+2][k].first, d_next = stones[i+2][k].second;\n\t    int safe = (d_now + d_next) * abs(x_now - x_next);\n\t    REP(m, M) {\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + safe);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M && N != 0) {\n    vector<vector<pair<int,int> > > g(N);\n    for (int i = 0; i < N; i++) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; j++) {\n        int c, d;\n        cin >> c >> d;\n        g[i].push_back(make_pair(c, d));\n      }\n    }\n\n    vector<vector<vector<int> > > dp(N);\n    for (int i = 0; i < N; i++) {\n      dp[i].resize(g[i].size(), vector<int>(M+1, numeric_limits<int>::max()/2));\n    }\n    for (int i = 0; i < g[0].size(); i++) {\n      dp[0][i][0] = 0;\n    }\n    for (int i = 0; i < g[1].size(); i++) {\n      dp[1][i][1] = 0;\n    }\n\n    int ans = numeric_limits<int>::max();\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < g[i].size(); j++) {\n        for (int m = 0; m <= M; m++) {\n          if (i+1 == N) {\n            ans = min(ans, dp[i][j][m]);\n          } else {\n            for (int k = 0; k < g[i+1].size(); k++) {\n              dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + (g[i][j].second + g[i+1][k].second)*abs(g[i][j].first - g[i+1][k].first));\n            }\n\n            if (i < N-1 && m < M) {\n              if (i+2 == N) {\n                ans = min(ans, dp[i][j][m]);\n              } else {\n                for (int k = 0; k < g[i+2].size(); k++) {\n                  dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + (g[i][j].second + g[i+2][k].second)*abs(g[i][j].first - g[i+2][k].first));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int inf = 1<<28;\nconst int H = 151;\nconst int W = 1001;\nconst int M = 76;\nint D[H][W];\nint dp[H][W][M];\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                D[i][j] = inf;\n                for ( int k = 0; k < M; ++ k ) {\n                    dp[i][j][k] = inf;\n                }\n            }\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int x, d;\n                cin >> x >> d;\n                -- x;\n                D[n-i-1][x] = d;\n            }\n        }\n        for ( int i = 0; i < 1001; ++ i ) {\n            if ( D[n-1][i] != inf ) dp[n - 1][i][0] = 0;\n        }\n        for ( int i = n-1; i > 0; -- i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                if ( D[i][j] == inf ) continue;\n                for ( int k = 0; k < W; ++ k ) {\n                    if ( i-2 >= 0 && D[i-2][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            if ( D[i-2][k] != inf && D[i][j] != inf )\n                                dp[i-2][k][l+1] = min( dp[i-2][k][l+1], dp[i][j][l]+(D[i-2][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                    if ( i-1 >= 0 && D[i-1][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            if ( D[i-1][k] != inf && D[i][j] != inf )\n                                dp[i-1][k][l] = min( dp[i-1][k][l], dp[i][j][l]+(D[i-1][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                }\n            }\n        }\n        int answer = inf;\n        for ( int i = 0; i < W; ++ i ) {\n            for ( int j = 0; j <= m; ++ j ) {\n                answer = min( answer, dp[0][i][j] );\n            }\n            for ( int j = 0; j < m; ++ j ) {\n                answer = min( answer, dp[1][i][j] );\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\n#define int ll\nint dp [1500] [150];\nint n, m, s;\nvector<vector<int>> mp;\nvector<pii> st;\nint func(int pos, int stnum, int spc) {\n\tif (spc == m+1)\n\t\treturn -1;\n\tif (stnum == s)\n\t\treturn 0;\n\tif (dp[stnum][spc] != -1)\n\t\treturn dp[stnum][spc];\n\tint res = INT_MAX;\n\tint w = st[stnum].first;\n\tint sb = st[stnum].second;\n\tREP(i, mp[pos+1].size()) {\n\t\tint cand = func(pos + 1, mp[pos + 1][i], spc);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0 && mp[pos+1][i] != s) {\n\t\t\tcand += (sb + st[mp[pos + 1][i]].second)*abs(w-st[mp[pos + 1][i]].first);\n\t\t}\n\t\tres = min(res, cand);\n\t}\n\tREP(i, mp[pos + 2].size()) {\n\t\tint cand = func(pos + 2, mp[pos + 2][i], spc+1);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0 && mp[pos + 2][i] != s) {\n\t\t\tcand += (sb + st[mp[pos + 2][i]].second)*abs(w - st[mp[pos + 2][i]].first);\n\t\t}\n\t\tres = min(res,cand);\n\t}\n\tdp[stnum][spc] = res;\n\tif (res == INT_MAX)\n\t\tres = -1;\n\treturn res;\n}\n\nsigned main() {\n\twhile (scanf(\"%lld %lld\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tFill(dp, -1);\n\t\tmp.clear();\n\t\tmp.resize(n+2);\n\t\ts = 0;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tscanf(\"%lld\", &c);\n\t\t\tREP(j, c) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%lld %lld\", &a, &b);\n\t\t\t\tmp[i].push_back(s);\n\t\t\t\tst.push_back({ a,b });\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tmp[n].push_back(s);\n\t\tst.push_back({ -1,-1 });\n\t\tst.push_back({ -1,-1 });\n\t\tprintf(\"%lld\\n\", func(-1, s+1, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#define INF (1000000000)\n#define MOD (1000000007)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\ntypedef vector<long>::iterator VL;\ntypedef vector<long>::iterator VLI;\ntypedef pair<int, int> P;\n\n\nint d[150][1000];\nint dp[150][1000][100];\n\nint main()\n{\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m), n + m){\n\t\tmemset(d, 0, sizeof(d));\n\t\tint maxx = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor (int j = 0; j < k; j++){\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tx--;\n\t\t\t\tscanf(\"%d\", &d[i][x]);\n\t\t\t\t\n\t\t\t\tmaxx = max(maxx, x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 150; i++){\n\t\t\tfor (int j = 0; j <= maxx; j++){\n\t\t\t\tfor (int k = 0; k < 100; k++){\n\t\t\t\t\tif (i == 0 && d[i][j] && k == 0) dp[i][j][k] = 0;\n\t\t\t\t\telse dp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j <= maxx; j++){\n\t\t\t\tfor (int k = 0; k <= maxx; k++){\n\t\t\t\t\tfor (int l = 0; l <= m; l++){\n\t\t\t\t\t\tif (d[i][j] && d[i + 1][k]){\n\t\t\t\t\t\t\tdp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (d[i][j] + d[i + 1][k]) * abs(j - k));\n\t\t\t\t\t\t\t//printf(\"%d\\n\", dp[i + 1][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i < n - 1 && d[i][j] && d[i + 2][k]){\n\t\t\t\t\t\t\tdp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (d[i][j] + d[i + 2][k]) * abs(j - k));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini = INF;\n\t\tfor (int i = 0; i <= maxx; i++){\n\t\t\tfor (int j = 0; j <= m; j++){\n\t\t\t\tmini = min(mini, dp[n - 1][i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint n,m;\nvi x[200],d[200];\nint dp[200][11][200];\n\nint main2(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tif(cin>>n>>m,!n)return 1;\n\tx[0].pb(-INF);d[0].pb(-INF);\n\tx[n+1].pb(-INF);d[n+1].pb(-INF);\n\trep2(i,1,n+1){\n\t\tint k;\n\t\tcin>>k;\n\t\tx[i].clear();\n\t\td[i].clear();\n\t\trep(j,k){\n\t\t\tint X,D;\n\t\t\tcin>>X>>D;\n\t\t\tx[i].pb(X),d[i].pb(D);\n\t\t}\n\t}\n\trep(i,n+2)rep(j,10)rep(k,m+1)dp[i][j][k]=INF;\n\tdp[0][0][m]=0;\n\trep(i,n+1)rep(j,sz(x[i]))rep(k,m+1){\n\t\trep2(dy,1,3){\n\t\t\tint ni=i+dy;\n\t\t\tif(dy==2 && (i==n || k==0))continue;\n\t\t\trep(nj,sz(x[ni])){\n\t\t\t\tint cost;\n\t\t\t\tif(i==0 || ni==n+1)cost=0;\n\t\t\t\telse cost=(d[i][j]+d[ni][nj])*abs(x[i][j]-x[ni][nj]);\n\t\t\t\tdp[ni][nj][k-(dy==2)]=min(dp[ni][nj][k-(dy==2)],dp[i][j][k]+cost);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\trep(k,m+1)ans=min(ans,dp[n+1][0][k]);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\nint main(){\n\twhile(!main2());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int inf = 1<<28;\nconst int H = 151;\nconst int W = 1001;\nconst int M = 77;\nint D[H][W];\nint dp[4][W][M];\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                D[i][j] = inf;\n            }\n        }\n        for ( int i = 0; i < 4; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                for ( int k = 0; k < M; ++ k ) {\n                    dp[i][j][k] = inf;\n                }\n            }\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int x, d;\n                cin >> x >> d;\n                -- x;\n                D[i][x] = d;\n            }\n        }\n        for ( int i = 0; i < W; ++ i ) {\n            dp[0][i][0] = ( D[0][i] == inf ? inf : 0 );\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                if ( D[i][j] == inf ) continue;\n                for ( int k = 0; k < W; ++ k ) {\n                    for ( int l = 0; l <= m; ++ l ) {\n                        if ( dp[0][j][l] == inf ) continue;\n                        if ( i + 2 < n && D[i + 2][k] != inf ) {\n                            dp[2][k][l+1] = min( dp[2][k][l+1], dp[0][j][l] + ( D[i][j] + D[i+2][k] ) * abs( j - k ) );\n                        } else if ( i + 2 >= n ) {\n                            dp[2][k][l+1] = min( dp[2][k][l+1], dp[0][j][l] );\n                        }\n                        if ( i + 1 < n && D[i + 1][k] != inf ) {\n                            dp[1][k][l] = min( dp[1][k][l], dp[0][j][l] + ( D[i][j] + D[i+1][k] ) * abs( j - k ) );\n                        } else if ( i + 1 >= n ) {\n                            dp[1][k][l] = min( dp[1][k][l], dp[0][j][l] );\n                        }\n                    }\n                }\n            }\n            for ( int j = 0; j < W; ++ j ) {\n                for ( int k = 0; k <= m; ++ k ) {\n                    for ( int t = 0; t + 1 < 4; ++ t ) {\n                        dp[t][j][k] = dp[t+1][j][k];\n                    }\n                }\n            }\n        }\n        int answer = inf;\n        for ( int i = 0; i < 4; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                for ( int k = 0; k <= m; ++ k ) {\n                    if ( dp[i][j][k] == inf ) continue;\n                    answer = min( answer, dp[i][j][k] );\n                    // cout << ( dp[i][j][k] == inf ? -1 : dp[i][j][k] ) << \", \";\n                }\n                // cout << endl;\n            }\n            // cout << endl;\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\n#define int ll\nint dp [1500] [150];\nint n, m;\nvector<vector<int>> mp;\nvector<pii> st;\nint func(int pos, int stnum, int spc) {\n\tif (spc == m+1)\n\t\treturn -1;\n\tif (pos == n-1)\n\t\treturn 0;\n\tif (dp[stnum][spc] != -1)\n\t\treturn dp[stnum][spc];\n\tint res = INT_MAX;\n\tint w = st[stnum].first;\n\tint sb = st[stnum].second;\n\tREP(i, mp[pos+1].size()) {\n\t\tint cand = func(pos + 1, mp[pos + 1][i], spc);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0) {\n\t\t\tcand += (sb + st[mp[pos + 1][i]].second)*abs(w-st[mp[pos + 1][i]].first);\n\t\t}\n\t\tres = min(res, cand);\n\t}\n\tREP(i, mp[pos + 2].size()) {\n\t\tint cand = func(pos + 2, mp[pos + 2][i], spc+1);\n\t\tif (cand == -1)\n\t\t\tcontinue;\n\t\tif (sb >= 0) {\n\t\t\tcand += (sb + st[mp[pos + 2][i]].second)*abs(w - st[mp[pos + 2][i]].first);\n\t\t}\n\t\tres = min(res,cand);\n\t}\n\tdp[stnum][spc] = res;\n\treturn res;\n}\n\nsigned main() {\n\twhile (scanf(\"%lld %lld\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tFill(dp, -1);\n\t\tmp.clear();\n\t\tmp.resize(n + 2);\n\t\tint s = 0;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tscanf(\"%lld\", &c);\n\t\t\tREP(j, c) {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%lld %lld\", &a, &b);\n\t\t\t\tmp[i].push_back(s);\n\t\t\t\tst.push_back({ a,b });\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t\tst.push_back({ -1,-1 });\n\t\tprintf(\"%lld\\n\", func(-1, s, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <cstdlib>\n\nusing namespace std;\n\nint n,m;\n\n\nconst int INF = 999999999;\n\nvector< vector< pair<int,int> > > stones;\nint dp[153][153][153];\n\nint calcd(pair<int,int> a,pair<int,int> b){\n\tif(a.first == -1 || b.first == -1){return 0;}\n\t//printf(\"CALCD:(%d,%d) -> (%d,%d) : %d\\n\",a.first,a.second,b.first,b.second,(a.second + b.second) * abs(a.first - b.first));\n\treturn (a.second + b.second) * abs(a.first - b.first);\n}\n\nvoid setvalue(int* begin,int* end,int value){\n\tint* pt = begin;\n\twhile(pt != end){\n\t\t*pt = value; \n\t\tpt++;\n\t}\n}\n\nint main(){\n\tint self;\n\tint a,b;\n\tint s,ss;\n\tint x,y;\n\twhile(scanf(\"%d %d\",&n,&m) && (n || m)){\n\t\t//printf(\"%d,%d\\n\",n,m);\n\t\tstones.clear();\n\t\tvector< pair<int,int> > vvv;\n\t\tvvv.push_back( pair<int,int>(-1,0) );\n\t\t\n\t\tstones.push_back(vvv);\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&self);\n\t\t\t//printf(\"%d :\",i);\n\t\t\tvector< pair<int,int> > vv(self);\n\t\t\tfor(int j=0;j<self;j++){\n\t\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\t\t//printf(\"(%d,%d) \",a,b);\n\t\t\t\tvv[j] = (pair<int,int>(a,b));\n\t\t\t\t\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t\tstones.push_back(vv);\n\t\t}\n\t\tstones.push_back(vvv);\n\t\t\n\t\tsetvalue(&dp[0][0][0],&dp[0][0][0] + 10 * 150 * 76,INF);\n\t\t\n\t\t\n\t\tfor(int i=0;i<stones[0].size();i++){\n\t\t\tdp[m][i][0] = 0;\n\t\t\t\n\t\t}\n\t\t/*\n\t\tif(m > 0){\n\t\t\tfor(int i=0;i<stones[1].size();i++){\n\t\t\t\tdp[m - 1][i][1] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t*/\n\t\t/*\n\t\tfor(int k = m;k >= 0;k--){\n\t\t\tprintf(\"[k:%d]\\n\",k);\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(int i = 0;i < stones[j].size();i++){\n\t\t\t\t\tprintf(\"%d \",dp[k][i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tfor(int k = m;k >= 0;k--){\n\t\t\tfor(int j = 0;j < n + 2;j++){\n\t\t\t\tfor(int i = 0;i < stones[j].size();i++){\n\t\t\t\t\t//printf(\"%d %d %d\\n\",k,i,j);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\tif(j > 0){\n\t\t\t\t\t\tself = INF;\n\t\t\t\t\t\tfor(int l = 0;l < stones[j - 1].size();l++){\n\t\t\t\t\t\t\tif(dp[k][l][j - 1] >= INF){continue;}\n\t\t\t\t\t\t\t//printf(\"call (%d,%d) , (%d,%d)\\n\",i,j,j-1,l);\n\t\t\t\t\t\t\ts = calcd(stones[j][i],stones[j - 1][l]) + dp[k][l][j - 1];\n\t\t\t\t\t\t\tif(s < self){\n\t\t\t\t\t\t\t\tself = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[k][i][j] = self;\n\t\t\t\t\t}\n\t\t\t\t\tif(j > 1 && k < m){\n\t\t\t\t\t\tself = INF;\n\t\t\t\t\t\tfor(int l = 0;l < stones[j - 2].size();l++){\n\t\t\t\t\t\t\tif(dp[k + 1][l][j - 2] >= INF){continue;}\n\t\t\t\t\t\t\t//printf(\"call (%d,%d) , (%d,%d)\\n\",i,j,j-2,l);\n\t\t\t\t\t\t\ts = calcd(stones[j][i],stones[j - 2][l]) + dp[k + 1][l][j - 2];\n\t\t\t\t\t\t\tif(s < self){\n\t\t\t\t\t\t\t\tself = s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[k][i][j] > self){\n\t\t\t\t\t\t\tdp[k][i][j] = self;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\ts = stones[n + 1].size();\n\t\tfor(int i = 0;i <= m;i++){\n\t\t\tfor(int j = 0;j < s;j++){\n\t\t\t\tif(dp[i][j][n + 1] < ans){\n\t\t\t\t\tans = dp[i][j][n + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tfor(int k = m;k >= 0;k--){\n\t\t\tprintf(\"[k:%d]\\n\",k);\n\t\t\tfor(int j = 0;j < n + 1;j++){\n\t\t\t\tfor(int i = 0;i < stones[j].size();i++){\n\t\t\t\t\tprintf(\"%d \",dp[k][i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int>P;\nconst int INF = 1<<29;\nint N,M;\nint dp[256][128][16];\nvector<P> s[151];\n\nint main(){\n  while(scanf(\"%d%d\", &N,&M) && N||M){\n    for(int i=0;i<151;i++) s[i].clear();\n    for(int i=0;i<151;i++) for(int j=0;j<76;j++) for(int k=0;k<11;k++) dp[i][j][k] = INF;\n    for(int i=0;i<N;i++){\n      int k;\n      scanf(\"%d\", &k);\n      for(int j=0;j<k;j++){\n\tint x,d; scanf(\"%d%d\", &x,&d);\n\ts[i].push_back(P(x,d));\n      }\n    }\n    \n    for(int i=0;i<s[0].size();i++) dp[0][M][i] = min(dp[0][M][i], 0);\n    if(M) for(int i=0;i<s[1].size();i++) dp[1][M-1][i] = min(dp[1][M-1][i], 0);\n    /*    for(int m=0;m<=M;m++){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<s[i].size();j++) printf(\"%d \", dp[i][m][j]);\n\tputs(\"\");\n      }puts(\"\");\n      } */   \n\n    for(int i=0;i<N-1;i++){\n      for(int j=0;j<s[i].size();j++){\n\tfor(int m=0;m<=M;m++){\n\t  if(dp[i][m][j] == INF) continue;\n\t  for(int k=0;k<s[i+1].size();k++){\n\t    dp[i+1][m][k] = min(dp[i+1][m][k],\n\t\t\t\tdp[i][m][j]+(s[i+1][k].second+s[i][j].second)*abs(s[i+1][k].first-s[i][j].first));\n\t  }\n\t  if(i+2 < N && m) for(int k=0;k<s[i+2].size();k++){\n\t      dp[i+2][m-1][k] = min(dp[i+2][m-1][k],\n\t\t\t\t    dp[i][m][j]+(s[i+2][k].second+s[i][j].second)*abs(s[i+2][k].first-s[i][j].first));\n\t    }\n\t}\n      }\n      //      printf(\"%d\\n\" ,i);\n      /*      for(int m=0;m<=M;m++){\n\tfor(int i=0;i<N;i++){\n\t  for(int j=0;j<s[i].size();j++) printf(\"%d \", dp[i][m][j]);\n\t  puts(\"\");\n\t}puts(\"\");\n      }*/\n    }\n    /*    for(int m=0;m<=M;m++){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<s[i].size();j++) printf(\"%d \", dp[i][m][j]);\n\tputs(\"\");\n      }puts(\"\");\n      }*/\n    \n    int res = INF;\n    for(int i=0;i<s[N-1].size();i++) for(int m=0;m<=M;m++) res = min(res, dp[N-1][m][i]);\n    for(int i=0;i<s[N-2].size();i++) for(int m=1;m<=M;m++) res = min(res, dp[N-2][m][i]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (1 << 30) - 1;\nint main()\n{\n    int dp[155][15][88];\n    int N, M;\n    int K[155];\n\n    while(cin >> N >> M, N || M) {\n        vector < int > X[155], D[155];\n        fill_n(**dp, 155 * 15 * 88, INF);\n        for(int i = 0; i < N; i++) {\n            cin >> K[i];\n            for(int j = 0; j < K[i]; j++) {\n                int x, d;\n                cin >> x >> d;\n                X[i].push_back(x);\n                D[i].push_back(d);\n            }\n        } for(int i = 0; i < K[0]; i++) dp[0][i][0] = 0;\n        for(int i = 0; i < K[1]; i++) dp[1][i][1] = 0;\n        for(int i = 0; i < N - 1; i++) {\n            for(int j = 0; j < K[i]; j++) {\n                for(int k = 0; k <= M; k++) {\n                    if(dp[i][j][k] == INF) continue;\n                    for(int l = 0; l < K[i + 1]; l++) {\n                        dp[i + 1][l][k] = min(dp[i + 1][l][k], dp[i][j][k] + (D[i][j] + D[i + 1][l]) * abs(X[i][j] - X[i + 1][l]));\n                    }\n                    if(k >= M || i >= N - 2) continue;\n                    for(int l = 0; l < K[i + 2]; l++) {\n                        dp[i + 2][l][k + 1] = min(dp[i + 2][l][k + 1], dp[i][j][k] + (D[i][j] + D[i + 2][l]) * abs(X[i][j] - X[i + 2][l]));\n                    }\n                }\n            }\n        }\n        int minv = INF;\n        for(int p = 0; p < 2; p++) {\n            for(int i = 0; i < K[N - 2]; i++) {\n                for(int j = 0; j < M + p; j++) {\n                    minv = min(minv, dp[N - 2 + p][i][j]);\n                }\n            }\n        }\n        cout << minv << endl;\n    }\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\nint dp[160][80][10];\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    using pii = pair<int, int>;\n    const int INF = 1e9;\n    int n, m;\n    while(cin >> n >> m && n) {\n        vector<vector<pii>> rocks(n);\n        for(auto& r : rocks) {\n            int k; cin >> k;\n            r.resize(k);\n            for(auto& p : r)\n              cin >> p.first >> p.second;\n        }\n        fill_n((int*)dp, 160 * 80 * 10, INF);\n        for(int k : in(10)) dp[0][0][k] = 0;\n        for(int i : in(n - 1)) for(int j : in(m + 1)) for(int k : in(rocks[i].size())) {\n            int cx, cd; tie(cx, cd) = rocks[i][k];\n            if(dp[i][j][k] == INF) continue;\n            for(int l : in(rocks[i + 1].size())) {\n                int nx, nd; tie(nx, nd) = rocks[i + 1][k];\n                int cost = (cd + nd) * abs(cx - nx);\n                dp[i + 1][j][l] = min(dp[i + 1][j][l], dp[i][j][k] + cost);\n            }\n            if(i == n - 2 || j == m) continue;\n            for(int l : in(rocks[i + 2].size())) {\n                int nx, nd; tie(nx, nd) = rocks[i + 2][k];\n                int cost = (cd + nd) * abs(cx - nx);\n                dp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k] + cost);\n            }\n        }\n        int ans = INF;\n        for(int i : in(max(0, n - 2), n))\n          for(int j : in(m + 1)) {\n              if(i == n - 2 && j == m) continue;\n              for(int k : in(rocks[i].size())) \n                ans = min(ans, dp[i][j][k]);\n          }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\nconst int INF=1000000;\nint main(void){\n\tint n,m;\n\tint st[152],stx[152][11],sts[152][11];\n\tint dp[152][11][76];\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(st,0,sizeof(st));\n\t\tmemset(stx,0,sizeof(stx));\n\t\tmemset(sts,0,sizeof(sts));\n\t\tfor(int i=0;i<152;i++){\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tfor(int k=0;k<76;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst[0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&st[i]);\n\t\t\tfor(int j=0;j<st[i];j++){\n\t\t\t\tscanf(\"%d%d\",&stx[i][j],&sts[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<st[0];i++){\n\t\t\tdp[0][i][0]=0;\n\t\t}\n\t\tif(m>=1)for(int i=0;i<st[1];i++){\n\t\t\tdp[1][i][1]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tfor(int k=0;k<st[i];k++){\n\t\t\t\t\tfor(int l=0;l<st[i-1];l++){\n\t\t\t\t\t\tdp[i][k][j]=min(dp[i][k][j],dp[i-1][l][j]+(sts[i][k]+sts[i-1][l])*abs(stx[i][k]-stx[i-1][l]));\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=m && i>=2)for(int l=0;l<st[i-2];l++){\n\t\t\t\t\t\tdp[i][k][j+1]=min(dp[i][k][j+1],dp[i-2][l][j]+(sts[i][k]+sts[i-2][l])*abs(stx[i][k]-stx[i-2][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int k=0;k<st[n-1];k++){\n\t\t\t\tans=min(ans,dp[n-1][k][j]);\n\t\t\t}\n\t\t\tif(j!=m)for(int k=0;k<st[n-2];k++){\n\t\t\t\tans=min(ans,dp[n-2][k][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int, int> P;\nint n, m;\nint dp[80][200][20], kosu[1600];\nP stone[1600][20];\nint main()\n{\n\twhile(cin >> n >> m && n)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> kosu[i];\n\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t{\n\t\t\t\tcin >> stone[i][j].F >> stone[i][j].S;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= m; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tfor(int k = 0; k < kosu[j]; k++)\n\t\t\t\t\tdp[i][j][k] = 1 << 30;\n\t\t\t\tfor(int i = 0; i < kosu[0]; i++)\n\t\t\t\t\tdp[0][0][i] = 0;\n\t\t\t\tfor(int i = 0; i < kosu[1]; i++)\n\t\t\t\t\tdp[1][1][i] = 0;\n\t\t\t\tfor(int i = 0; i < n - 1; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < kosu[i]; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 1]; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int l = 0; l <= m; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(dp[l][i][j] < 1 << 30)\n\t\t\t\t\t\t\t\t\tdp[l][i + 1][k] = min((stone[i + 1][k].S + stone[i][j].S) * abs(stone[i + 1][k].F - stone[i][j].F) + dp[l][i][j], dp[l][i + 1][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i + 2 < n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int k = 0; k < kosu[i + 2]; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor(int l = 0; l < m; l++)\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tif(dp[l][i][j] < 1 << 30)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdp[l + 1][i + 2][k] = min((stone[i + 2][k].S + stone[i][j].S) * abs(stone[i + 2][k].F - stone[i][j].F) + dp[l][i][j], dp[l + 1][i + 2][k]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tfor(int i = 0; i <= m; i++)\n\t\t\t\t\tfor(int j = 0; j < kosu[n - 1]; j++)\n\t\t\t\t\t\tans = min(ans, dp[i][n - 1][j]);\n\t\t\t\t\tfor(int i = 0; i < m; i++)\n\t\t\t\t\t\tfor(int j = 0; j < kosu[n - 2]; j++)\n\t\t\t\t\t\t\tans = min(ans, dp[i][n - 2][j]);\n\t\t\t\t\t\tcout << ans << endl;\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int INF = 1<<29;\n\nint dp[150][10][77];\nint stones[150][10][2];\nint col[150];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) break;\n  \n    REP(i, N) {\n      cin >> col[i];\n      REP(j, col[i]) {\n\tcin >> stones[i][j][0] >> stones[i][j][1];\n      }\n    }\n\n    REP(i, N) REP(j, col[i]) REP(k, M+1) dp[i][j][k] = INF;\n    REP(j, col[0]) dp[0][j][0] = 0;\n    REP(j, col[1]) dp[1][j][1] = 0;\n    REP(i, N-1) {\n      REP(j, col[i]) {\n\tint x_now = stones[i][j][0], d_now = stones[i][j][1];\n\tREP(m, M+1) {\n\t  if (dp[i][j][m] == INF) continue;\n\t  REP(k, col[i+1]) {\n\t    dp[i+1][k][m] = min(dp[i+1][k][m], dp[i][j][m] + (d_now + stones[i+1][k][1]) * abs(x_now - stones[i+1][k][0]));\n\t  }\n\t  if (i < N-2 && m < M) {\n\t    REP(k, col[i+2]) {\n\t      dp[i+2][k][m+1] = min(dp[i+2][k][m+1], dp[i][j][m] + (d_now + stones[i+2][k][1]) * abs(x_now - stones[i+2][k][0]));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int ans = INF;\n    REP(j, col[N-1]) REP(m, M+1) ans = min(ans, dp[N-1][j][m]);\n    REP(j, col[N-2]) REP(m, M) ans = min(ans, dp[N-2][j][m]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    int N,M,K,k1,k2,MIN,ANS;\n    while(scanf(\"%d%d\",&N,&M),N + M)\n    {\n        int field[160][4] = {0},dp[160][4][100] = {0};\n        ANS = 10000000;\n        for(int i = 0; i < N; i++)\n        {\n            scanf(\"%d\",&K);\n            for(int j = 0; j < K; j++)\n            {\n                scanf(\"%d%d\",&k1,&k2);\n                field[i + 1][k1 - 1] = k2;\n            }\n        }\n        /*for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 2; i < N + 1; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    if(field[i][k] != 0 || i - 1 == 0)\n                    {\n                        dp[i][k][j] = 10000000;\n                        if(j == 0)\n                        {\n                            for(int l = 0; l < 4; l++)\n                            {\n                                if(field[i - 1][l] != 0 || i - 1 == 0)\n                                {\n                                    dp[i][k][0] = min(dp[i][k][0],dp[i - 1][l][0] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                        else if(i >= j * 2)\n                        {\n                            for(int l = 0; l < 4; l++)\n                            {\n                                if(field[i - 1][l] != 0 || i - 1 == 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 1][l][j] + (field[i - 1][l] + field[i][k]) * abs(k - l));\n                                }\n                                if(field[i - 2][l] != 0 || i - 2 == 0)\n                                {\n                                    dp[i][k][j] = min(dp[i][k][j],dp[i - 2][l][j - 1] + (field[i - 2][l] + field[i][k]) * abs(k - l));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /*for(int i = 0; i < N + 1; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        for(int i = 0; i < N + 1; i++)\n        {\n            for(int j = 0; j < M + 1; j++)\n            {\n                for(int k = 0; k < 4; k++)\n                {\n                    printf(\"%2d\",dp[i][k][j]);\n                }\n                printf(\" / \");\n            }\n            printf(\"\\n\");\n        }*/\n        for(int i = 0; i < M + 1; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                if(field[N][j] != 0)\n                {\n                    ANS = min(ANS,dp[N][j][i]);\n                }\n                if(i < M && field[N - 1][j] != 0)\n                {\n                    ANS = min(ANS,dp[N - 1][j][i]);\n                }\n            }\n        }\n        printf(\"%d\\n\",ANS);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define f first\n#define s second\n#define MAX_N 155\n#define INF 100000000000000\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\n  int n,m,k,a,b;\n\n  while(cin >> n >> m,n|m){\n    vector<P>v[MAX_N];\n    \n    for(int i=1;i<=n;i++){\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> a >> b;\n\tv[i].push_back(make_pair(a,b));\n      }\n    }\n\n    ll dp[MAX_N][11][80];\n\n    for(int i=0;i<MAX_N;i++)\n      for(int j=0;j<11;j++)\n\tfor(int k=0;k<80;k++)\n\t  dp[i][j][k]=INF;\n\n    for(int i=0;i<11;i++)\n      for(int j=0;j<80;j++)\n\tdp[0][i][j]=dp[1][i][j]=0;\n\n    for(int i=2;i<=n;i++){\n      for(int j=0;j<v[i].size();j++){\n\tfor(int l=m;l>=0;l--){\n\t  for(int k=0;k<v[i-1].size();k++){\n\t    dp[i][j][l]=min(dp[i][j][l],dp[i-1][k][l]+(v[i][j].s+v[i-1][k].s)*abs(v[i][j].f-v[i-1][k].f));\n\t  }\n\t  if(l<m){\n\t    for(int p=0;p<v[i-2].size();p++)\n\t      dp[i][j][l]=min(dp[i][j][l],dp[i-2][p][l+1]+(v[i][j].s+v[i-2][p].s)*abs(v[i][j].f-v[i-2][p].f));\n\t    //dp[i][j][l]=min(dp[i][j][l],dp[i][j][l+1]);\n\t  }\n\t}\n      }\n    }\n    \n    ll ans=INF;\n    for(int i=0;i<v[n].size();i++){\n      for(int j=0;j<=m;j++){\n      ans=min(ans,dp[n][i][j]);\n      if(j>0)ans=min(ans,dp[n-1][i][j]);\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef long long INT;\nconst INT inf = 1<<28;\nconst int H = 151;\nconst int W = 1001;\nconst int M = 80;\nINT D[H][W];\nINT dp[H][W][M];\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                D[i][j] = inf;\n                for ( int k = 0; k < M; ++ k ) {\n                    dp[i][j][k] = inf;\n                }\n            }\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int x, d;\n                cin >> x >> d;\n                -- x;\n                D[n-i-1][x] = d;\n            }\n        }\n        for ( int i = 0; i < 1001; ++ i ) {\n            if ( D[n-1][i] != inf ) dp[n - 1][i][0] = 0;\n        }\n        for ( int i = n-1; i > 0; -- i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                for ( int k = 0; k < W; ++ k ) {\n                    if ( i-2 >= 0 && D[i-2][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            dp[i-2][k][l+1] = min( dp[i-2][k][l+1], dp[i][j][l]+(D[i-2][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                    if ( i-1 >= 0 && D[i-1][k] != inf ) {\n                        for ( int l = 0; l <= m; ++ l ) {\n                            dp[i-1][k][l] = min( dp[i-1][k][l], dp[i][j][l]+(D[i-1][k]+D[i][j])*abs(j-k) );\n                        }\n                    }\n                }\n            }\n        }\n        INT answer = inf;\n        for ( int i = 0; i < W; ++ i ) {\n            for ( int j = 0; j <= m; ++ j ) {\n                answer = min( answer, dp[0][i][j] );\n            }\n            for ( int j = 0; j < m; ++ j ) {\n                answer = min( answer, dp[1][i][j] );\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint N,M;\nint K[200];int X[200][10];int D[200][10];\nint dp[200][10][100];\nint INF=1000*1000*1000;\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(N==0&&M==0)return 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&K[i]);\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tscanf(\"%d%d\",&X[i][j],&D[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tfor(int k=0;k<M;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<K[0];j++)dp[0][j][0]=0;\n\t\tfor(int j=0;j<K[1];j++)dp[1][j][1]=0;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\t\tif(i==1&&k!=0)continue;\n\t\t\t\t\tint dpijk=INF;\n\t\t\t\t\tif(i!=1&&k!=0){\n\t\t\t\t\t\tfor(int l=0;l<K[i-2];l++){\n\t\t\t\t\t\t\tdpijk=min(dpijk,dp[i-2][l][k-1]+(D[i-2][l]+D[i][j])*abs(X[i-2][l]-X[i][j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l=0;l<K[i-1];l++){\n\t\t\t\t\t\tdpijk=min(dpijk,dp[i-1][l][k]+(D[i-1][l]+D[i][j])*abs(X[i-1][l]-X[i][j]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=dpijk;\n\t\t\t\t\t//printf(\"%d,%d,%d:%d\\n\",i,j,k,dpijk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int j=0;j<K[N-1];j++){\n\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\tans=min(ans,dp[N-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\nstruct rock\n{\n  int x, d;\n};\n\nconst int INF = 2e9;\nint n, m;\nint dp[150][10][76];\nvector<rock> rocks[150];\nint main()\n{\n  while(cin >> n >> m && (n || m)){\n\n    //chap1\n    for(int i = 0; i < n; i++){\n      rocks[i].clear();\n      for(int j = 0; j < 10; j++)\n\tfor(int k = 0; k <= m; k++)\n\t  dp[i][j][k] = INF;\n    }\n\n    for(int i = 0; i < 10; i++)\n      dp[0][i][0] = dp[1][i][1] = 0;\n    \n    //chap2\n    for(int i = 0; i < n; i++){\n      int kk;\n      cin >> kk;\n      for(int j = 0; j < kk; j++){\n\trock in;\n\tcin >> in.x >> in.d;\n\trocks[i].push_back(in);\n      }\n    }\n\n    //chap3\n    for(int i = 0; i < n - 1; i++){\n      for(int j = 0; j < rocks[i].size(); j++){\n\tfor(int k = 0; k < rocks[i + 1].size(); k++){\n\t  for(int l = 0; l <= m; l++){\n\t    dp[i + 1][k][l] = min(dp[i + 1][k][l], dp[i][j][l] + (rocks[i][j].d + rocks[i + 1][k].d) * (int)abs(rocks[i][j].x - rocks[i + 1][k].x));\n\t  }\n\t}\n\n\tif(i < n - 2){\n\t  for(int k = 0; k < rocks[i + 2].size(); k++){\n\t    for(int l = 0; l < m; l++){\n\t      dp[i + 2][k][l + 1] = min(dp[i + 2][k][l + 1], dp[i][j][l] + (rocks[i][j].d + rocks[i + 2][k].d) * (int)abs(rocks[i][j].x - rocks[i + 2][k].x));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    //chap4\n    int ans = INF;\n    \n    for(int i = 0; i < rocks[n - 1].size(); i++)\n      for(int j = 0; j <= m; j++)\n\tans = min(ans, dp[n - 1][i][j]);\n\n    for(int i = 0; i < rocks[n - 2].size(); i++)\n      for(int j = 0; j < m; j++)\n\tans = min(ans, dp[n - 2][i][j]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\tfor(int a=0;a<=m;a++){\n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  for(k=0;k<v[i+1].size();k++){\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t  }\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\nint n,m;\nint st[155][11][2];\nint dp[155][11][76];\nint num[155];\nint main(){\n    while(1)\n    {\n\tscanf(\"%d %d\",&n,&m);\n\tif(!n) return 0;\n        for(int i=1;i<=n;i++){\n            scanf(\"%d\",&num[i]);\n            for(int j=1;j<=num[i];j++){\n                scanf(\"%d %d\",&st[i][j][0],&st[i][j][1]);\n            }\n        }\n\n        for(int i=0;i<155;i++){\n            for(int j=0;j<11;j++){\n                for(int k=0;k<=m;k++){\n                    dp[i][j][k]=INF;\n                }\n            }\n        }\n\n        for(int j=1;j<=num[1];j++){\n            for(int k=0;k<=m;k++){\n                dp[1][j][k]=0;\n            }\n        }\n        for(int j=1;j<=num[2];j++){\n            for(int k=1;k<=m;k++){\n                dp[2][j][k]=0;\n            }\n            for(int y=1;y<=num[1];y++){\n                dp[2][j][0]=min(dp[2][j][0],dp[1][y][0]+abs(st[1][y][0]-st[2][j][0])*(st[1][y][1]+st[2][j][1]));\n            }\n        }\n\n        int ans=INF;\n\n        for(int i=3;i<=n;i++){\n            for(int j=1;j<=num[i];j++){\n                for(int k=0;k<=m;k++){\n                    for(int g=1;g<=num[i-1];g++){\n                        dp[i][j][k]=min(dp[i][j][k],dp[i-1][g][k]+abs(st[i][j][0]-st[i-1][g][0])*(st[i][j][1]+st[i-1][g][1]));\n                    }\n                    if(k!=0){\n                        for(int l=1;l<=num[i-2];l++){\n                            dp[i][j][k]=min(dp[i][j][k],dp[i-2][l][k-1]+abs(st[i][j][0]-st[i-2][l][0])*(st[i][j][1]+st[i-2][l][1]));\n                        }\n                    }\n                }\n            }\n        }\n\n        int res=INF;\n        for(int j=1;j<=num[n];j++){\n            for(int k=0;k<=m;k++){\n            res=min(res,dp[n][j][k]);\n            }\n        }\n        for(int j=1;j<=num[n-1];j++){\n            for(int k=1;k<m;k++){\n            res=min(res,dp[n-1][j][k]);\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\n#define INF (1<<30)\nint suberi(PA a,PA b){\n  return(a.second+b.second);\n}\nint yoko(PA a,PA b){\n  return(abs(a.first-b.first));\n}\nint dp[151][10][80];\nint main(){\n  int n,m,k,x,d;\n  vector<PA> vec[151];\n  while(scanf(\"%d %d\",&n,&m),n!=0||m!=0){\n    fill_n(**dp,151*10*80,INF);\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      for(int j=0;j<k;j++){\n\tscanf(\"%d %d\",&x,&d);\n\tvec[i].push_back(PA(x,d));\n\tif(i == 0) dp[0][j][0] = 0;\n\tif(i == 1) dp[1][j][1] = 0;\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<vec[i].size();j++){\n\tfor(int l=0;l<=m;l++){\n\t  for(int z=0;z<vec[i+1].size();z++){\n\t    dp[i+1][z][l] = min(dp[i+1][z][l],suberi(vec[i][j],vec[i+1][z]) * yoko(vec[i][j],vec[i+1][z]) + dp[i][j][l]);\n\t  }\n\t  if(l == m || i == n-2) continue;\n\t  for(int z=0;l<=m,z<vec[i+2].size();z++){\n\t    dp[i+2][z][l+1] = min(dp[i+2][z][l+1],suberi(vec[i][j],vec[i+2][z]) * yoko(vec[i][j],vec[i+2][z]) + dp[i][j][l]);\n\t  }\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i=n-2;i<n;i++){\n      for(int j=0;j<vec[i].size();j++){\n\tfor(int l=0;l<=m;l++){\n\t  if(i!=n-2||l!=m) ans = min(ans,dp[i][j][l]);\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct Tag {\n    unsigned y, x, c, m;\n    Tag() {}\n    Tag(int yy, int xx, unsigned cc, int mm) : x(xx), y(yy), c(cc), m(mm) {}\n};\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.c > t2.c;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<pair<int, int> > > stones(N);\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int x, d;\n                cin >> x >> d;\n                --x;\n                stones[i].push_back(make_pair(x, d));\n            }\n        }\n\n        priority_queue<Tag> q;\n        for(int i = 0; i < 2; ++i) {\n            if(M == 0 && i == 1) break;\n            for(int j = 0; j < stones[i].size(); ++j) {\n                q.push(Tag(i, j, 0, M-i));\n            }\n        }\n\n        vector<vector<pair<int, int> > > dp(N, vector<pair<int, int> >(1000, make_pair(0, INT_MAX)));\n        unsigned ans;\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            if(t.y+1 >= N) {\n                ans = t.c;\n                break;\n            }\n            if(t.y+2 >= N && t.m > 0) {\n                ans = t.c;\n                break;\n            }\n            //cout << t.y << ' ' << t.x << endl;\n            for(int i = 1; i <= 2; ++i) {\n                if(t.y+i >= N) break;\n                if(t.m <= 0 && i == 2) break;\n                int y = t.y+i;\n                int nm = t.m-i+1;\n                for(int j = 0; j < stones[y].size(); ++j) {\n                    int cost = t.c + (stones[t.y][t.x].second+stones[y][j].second)*abs(stones[t.y][t.x].first-stones[y][j].first);\n                    if(nm <= dp[y][j].first && cost >= dp[y][j].second) continue;\n                    if(cost >= dp[y][j].second) dp[y][j] = make_pair(nm, cost);\n                    q.push(Tag(y, j, cost, nm));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n#define N 200\n#define ACOL 100\n#define JUMP 100\n\nconst int infty=1<<29;\n\nusing namespace std;\n\nstruct state{\n  int r,c,cost,left;\n  state(int r,int c,int cost, int left):r(r),c(c),cost(cost),left(left){}\n  bool operator<(const state &t)const{return cost>t.cost;}\n};\n\nint dijkstra(int n,int m,\n\t     const vector< vector<int> > &C,\n\t     const vector< vector<int> > &D)\n{\n  static bool vis[N][ACOL][JUMP];\n  static int A[N][ACOL][JUMP];for(int i=0;i<N;++i)for(int j=0;j<ACOL;++j)for(int k=0;k<JUMP;++k){vis[i][j][k]=false;A[i][j][k]=infty;}\n  priority_queue<state> qs;qs.push(state(0,0,0,m));\n  \n  while(!qs.empty()){\n    state s=qs.top();qs.pop();\n    vis[s.r][s.c][s.left]=true;\n    if(s.r==n+1||s.r==n+2){continue;}\n    for(int k=1;k<=2;++k){\n      for(int i=0;i<C[s.r+k].size();++i){\n\tint nxr=s.r+k,nxc=i,nxcost=s.cost+(D[s.r][s.c]+D[nxr][nxc])*abs(C[s.r][s.c]-C[nxr][nxc]),nxj=s.left-(k-1);\n\tif(s.r==0||nxr==n+1||nxr==n+2)nxcost=s.cost;if(nxj<0)continue;\n\tstate next(nxr,nxc,nxcost,nxj);if(!vis[nxr][nxc][nxj]&&A[nxr][nxc][nxj]>nxcost){A[nxr][nxc][nxj]=nxcost;qs.push(next);}\n      }\n    }\n  }\n  int ret=infty;\n  for(int i=0;i<JUMP;++i){for(int j=0;j<ACOL;++j){\n      ret=min(A[n+1][j][i],min(A[n+2][j][i],ret));\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n,m;cin>>n>>m;if(cin.eof()||n==0&&m==0)break;\n    vector< vector<int> > D(n+3);D[n+1].push_back(0);D[n+2].push_back(0);\n    vector< vector<int> > C(n+3);C[n+1].push_back(0);C[n+2].push_back(0);\n    for(int i=0;i<n;++i){\n      int k;\n      cin>>k;\n      for(int j=0;j<k;++j){\n\tint col,danger;\n\tcin>>col>>danger;\n\tC[i+1].push_back(col);\n\tD[i+1].push_back(danger);\n      }\n    }\n    //cout<<dijkstra(n,m,C,D)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, f1, f2, r[150];\n\nvector<pair<int, int> > R[150]; int D[150][10][76];\n\nint distance(int x1, int c1, int x2, int c2)\n{\n\tint sums = R[x1][c1].second + R[x2][c2].second;\n\tint dist = R[x1][c1].first - R[x2][c2].first;\n\n\treturn sums * abs(dist);\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%d\", &m);\n\n\t\tif (n == 0 && m == 0) break;\n\n\t\tfor (int i = 0; i < n; i++) R[i].clear();\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r[i]);\n\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &f1);\n\t\t\t\tscanf(\"%d\", &f2);\n\n\t\t\t\tR[i].push_back(make_pair(f1, f2));\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < r[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t{\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][j][k] = 999999999;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int> >, greater<tuple<int, int, int, int> > > que;\n\n\t\tfor (int i = 0; i < R[0].size(); i++)\n\t\t{\n\t\t\tque.push(make_tuple(0, 0, 0, i));\n\t\t}\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<int, int, int, int> state = que.top(); que.pop();\n\n\t\t\tint dist = get<0>(state);\n\t\t\tint jump = get<1>(state);\n\t\t\tint high = get<2>(state);\n\t\t\tint node = get<3>(state);\n\n\t\t\tif (high + 1 != n)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < r[high + 1]; i++)\n\t\t\t\t{\n\t\t\t\t\tint dist2 = dist + distance(high, node, high + 1, i);\n\n\t\t\t\t\tif (D[high + 1][i][jump] > dist2)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[high + 1][i][jump] = dist2;\n\n\t\t\t\t\t\tque.push(make_tuple(dist2, jump, high + 1, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (high + 2 != n && jump != m)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < r[high + 2]; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint dist2 = dist + distance(high, node, high + 2, i);\n\n\t\t\t\t\t\tif (D[high + 2][i][jump + 1] > dist2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[high + 2][i][jump + 1] = dist2;\n\n\t\t\t\t\t\t\tque.push(make_tuple(dist2, jump + 1, high + 2, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < r[n - 1]; i++)\n\t\t{\n\t\t\tret = min(ret, D[n - 1][i][m]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<24)\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[200][200][80];\nint solve(int h,int idx,int k){\n  if(h == n-1 || (h == n-2 && k != 0)) return 0;\n  if(dp[h][idx][k] != INF) return dp[h][idx][k];\n  int ret = INF;\n  int s = stone[h][idx].second;\n  int w = stone[h][idx].first;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    ret = min(ret,solve(h+1,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      ret = min(ret,solve(h+2,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][idx][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    for(int i=0;i<152;i++){\n      for(int j=0;j<1010;j++){\n\tfor(int k=0;k<80;k++){\n\t  dp[i][j][k] = INF;\n\t}\n      }\n      stone[i].clear();\n    }\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,i,k));\n    }\n    if(k != 0){\n      for(int i=0;i<stone[1].size();i++){\n\tans = min(ans,solve(1,i,k-1));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nconst int INF = 1<<29;\n\nint dp[151][11][80];\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\trep(i, n) rep(j, 11) rep(k, 80) dp[i][j][k] = INF;\n\t\tvector<vector<P> > stone(n);\n\t\trep(i, n){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\trep(j, k){\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tstone[i].push_back(MP(x, d));\n\t\t\t}\t\t\t\n\t\t}\n\t\trep(i, 2) rep(j, stone[i].size()){\n\t\t\tdp[i][j][i] = 0;\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, n){\n\t\t\trep(j, stone[i].size()){\n\t\t\t\tP from = stone[i][j];\n\t\t\t\trep(l, m+1){\n\t\t\t\t\tif(i+1 < n){\n\t\t\t\t\t\trep(k, stone[i+1].size()){\n\t\t\t\t\t\t\tP to = stone[i+1][k];\n\t\t\t\t\t\t\tint cost = abs(from.X-to.X)*(from.Y+to.Y);\n\t\t\t\t\t\t\tdp[i+1][k][l] = min(dp[i+1][k][l], dp[i][j][l]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = min(ans, dp[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(l, m){\n\t\t\t\t\tif(i+2 < n){\n\t\t\t\t\t\trep(k, stone[i+2].size()){\n\t\t\t\t\t\t\tP to = stone[i+2][k];\n\t\t\t\t\t\t\tint cost = abs(from.X-to.X)*(from.Y+to.Y);\n\t\t\t\t\t\t\tdp[i+2][k][l+1] = min(dp[i+2][k][l+1], dp[i][j][l]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = min(ans, dp[i][j][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\t// your code goes here\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >>m;\n\t\tif(n==0){\n\t\t\treturn 0;\n\t\t}\n\t\tint k[152];\n\t\tint x[152][10],d[152][10];\n\t\tk[0]=1;x[0][0]=0;d[0][0]=0;\n\t\tk[n+1]=1;x[n+1][0]=0;d[n+1][0]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> k[i];\n\t\t\tfor(int j=0;j<k[i];j++){\n\t\t\t\tcin >> x[i][j] >> d[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r[152][10][76];\n\t\tint mr[152];\n\t\tmr[n+1]=0;mr[n]=0;\n\t\tr[n+1][0][0]=0;\n\t\tfor(int j=0;j<k[n];j++){\n\t\t\tr[n][j][0]=0;\n\t\t}\n\t\t\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tmr[i]=mr[i+2]+1;\n\t\t\tif(mr[i]>m){mr[i]=m;}\n\t\t\tfor(int j=0;j<k[j];j++){\n\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\tr[i][j][s]=-1;\n\t\t\t\t}\n\t\t\t\tfor(int jj=0;jj<k[i+1];jj++){\n\t\t\t\t\tint dr=(d[i][j]+d[i+1][jj])*abs(x[i][j]-x[i+1][jj]);\n\t\t\t\t\tif(i==0){dr=0;}\n\t\t\t\t\tfor(int s=0;s<=mr[i];s++){\n\t\t\t\t\t\tif(r[i][j][s]==-1 || (r[i+1][jj][s]!=-1 && r[i+1][jj][s]+dr<r[i][j][s])){\n\t\t\t\t\t\t\tr[i][j][s]=r[i+1][jj][s]+dr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int jj=0;jj<k[i+2];jj++){\n\t\t\t\t\tint dr=(d[i][j]+d[i+2][jj])*abs(x[i][j]-x[i+2][jj]);\n\t\t\t\t\tif(i==0 || i==n-1){dr=0;}\n\t\t\t\t\tfor(int s=1;s<=mr[i];s++){\n\t\t\t\t\t\tif(r[i][j][s]==-1 || (r[i+2][jj][s-1]!=-1 && r[i+2][jj][s-1]+dr<r[i][j][s])){\n\t\t\t\t\t\t\tr[i][j][s]=r[i+2][jj][s-1]+dr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint rr=-1;\n\t\tfor(int s=0;s<=m;s++){\n\t\t\tif(rr==-1 || (r[0][0][s]!=-1 && r[0][0][s]<rr)){\n\t\t\t\trr=r[0][0][s];\n\t\t\t}\n\t\t}\n\t\tcout << rr << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main(){\n    int m,n;\n    int inf = 10000000;\n    \n    while(cin>>n>>m && n){\n        int dp[150][10][76] = {};\n        for(int i=0;i<150;++i){\n            for(int j=0;j<10;++j){\n                for(int k=0;k<76;++k){\n                    dp[i][j][k]=inf;\n                }\n            }\n        }\n        int num[150],s[150][10][2];\n        for(int i=0;i<n;++i){\n            cin>>num[i];\n            for(int j=0;j<num[i];++j) cin>>s[i][j][0]>>s[i][j][1];\n        }\n        for(int i=0;i<num[0];++i) dp[0][i][0]=0;\n        for(int i=0;i<num[1];++i) dp[1][i][1]=0;\n        for(int i=0;i<n-1;++i){\n            for(int j=0;j<num[i];++j){\n                for(int k=0;k<num[i+1];++k){\n                    for(int sk=0;sk<=m;++sk){\n                        dp[i+1][k][sk]=min(dp[i+1][k][sk],dp[i][j][sk]+(s[i][j][1]+s[i+1][k][1])*abs(s[i][j][0]-s[i+1][k][0]));\n                    }\n                }\n                if(i<n-2){\n                    for(int k=0;k<num[i+2];++k){\n                        for(int sk=0;sk<m;++sk){\n                            dp[i+2][k][sk+1]=min(dp[i+2][k][sk+1],dp[i][j][sk]+(s[i][j][1]+s[i+2][k][1])*abs(s[i][j][0]-s[i+2][k][0]));\n                        }\n                    }\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=0;i<num[n-1];++i){\n            for(int j=0;j<=m;++j) ans = min(ans,dp[n-1][i][j]);\n        }\n        for(int i=0;i<num[n-2];++i){\n            for(int j=0;j<=m-1;++j) ans = min(ans,dp[n-2][i][j]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define INF LLONG_MAX/3\n#define int long long\nusing namespace std;\n\nstruct isi {\n\tint zahyou, suberi, mincost;\n};\nsigned main()\n{\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tvector<isi>I[152][78]{};//??????\n\t\tint c; cin >> c;\n\t\tfor (int d = 0; d < c; d++) {\n\t\t\tint e, f; cin >> e >> f; \n\t\t\tisi g; g.zahyou = e; g.suberi = f; g.mincost = 0;\n\t\t\tI[0][b].push_back(g);\n\t\t}\n\t\tfor (int e = 1; e < a; e++) {\n\t\t\tint f; scanf(\"%lld\", &f);\n\t\t\tfor (int g = 0; g < f; g++) {\n\t\t\t\tint h, i; scanf(\"%lld%lld\", &h, &i); \n\t\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\t\tint m = INF;\n\t\t\t\t\tfor (int k = 0; k < I[e-1][j].size(); k++) {\n\t\t\t\t\t\tm = min(m, I[e-1][j][k].mincost+(i + I[e - 1][j][k].suberi)*abs(h - I[e - 1][j][k].zahyou));\n\t\t\t\t\t}\n\t\t\t\t\tisi n;\n\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\tif (e >= 2 && j<b) {\n\t\t\t\t\t\tint m = INF;\n\t\t\t\t\t\tfor (int k = 0; k < I[e - 2][j + 1].size(); k++) {\n\t\t\t\t\t\t\tm = min(m, I[e-2][j+1][k].mincost+(i + I[e - 2][j + 1][k].suberi)*abs(h - I[e - 2][j + 1][k].zahyou));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisi n;\n\t\t\t\t\t\tn.zahyou = h; n.suberi = i; n.mincost = m;\n\t\t\t\t\t\tI[e][j].push_back(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint S = INF;\n\t\tfor (int x = 0; x <= b; x++) {\n\t\t\tfor (int y = 0; y < I[a-1][x].size(); y++) {\n\t\t\t\tS = min(S, I[a-1][x][y].mincost);\n\t\t\t}\n\t\t}\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int dp[200][200];\n    int i,j,k,x,d,a;\n    int inf = 1 << 20;\n    int ans=inf;\n    vector<PP> v[200]; \n    for(i=0;i<200;i++) v[i].clear();\n    int c=0;\n    for(i=0;i<n;i++){\n      cin >> k;\n      for(j=0;j<k;j++){\n\tcin >> x >> d;\n\tv[i].push_back(PP(c,P(x,d)));\n\tc++;\n      }\n    }\n    fill(dp[0],dp[199],inf);\n    for(i=0;i<v[0].size();i++){\n      dp[v[0][i].first][0]=0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<v[i].size();j++){\n\t\n\tfor(a=0;a<=m;a++){\n\t  \n\t  if(dp[v[i][j].first][a]==inf) continue;\n\t  \n\t  for(k=0;k<100;k++){\n\t    /*\n\t    dp[v[i+1][k].first][a]=min(dp[v[i+1][k].first][a],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+1][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+1][k].second.second+v[i][j].second.second));\n\t\t\t\t       */\n\t  }\n\t  /*\n\t  for(k=0;k<v[i+2].size();k++){\n\t    dp[v[i+2][k].first][a+1]=min(dp[v[i+2][k].first][a+1],\n\t\t\t\t       dp[v[i][j].first][a]\n\t\t\t\t       +abs(v[i+2][k].second.first-v[i][j].second.first)\n\t\t\t\t       *(v[i+2][k].second.second+v[i][j].second.second));\n\t  }\n\t  */\n\t}\n\t\n      }\n    }\n    /*\n    for(i=0;i<v[n-1].size();i++){\n      for(j=0;j<=m;j++){\n\tans=min(ans,dp[v[n-1][i].first][j]);\n      }\n    }\n    for(i=0;i<v[n-2].size();i++){\n      for(j=0;j<=m-1;j++){\n\tans=min(ans,dp[v[n-2][i].first][j]);\n      }\n    }\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[77][151][1001];\nint field[101][1001];\nconst int INF=100000000;\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 77; i++)\n\t\t\tfor(int j = 0; j < 151; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+1001,INF);\n\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[m][0][i]=0;\n\t\t\t}\n\t\t}\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(i==3){\n\t\t\t\t//cout<<endl;\n\t\t\t}\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l][i-1][k]+cost);\n\t\t\t\t\t\tif(i>=2){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tdp[l][i][j]=min(dp[l][i][j],dp[l+1][i-2][k]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,dp[j][n-1][i]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint N,M;\nint K[200];int X[200][10];int D[200][10];\nint dp[200][10][100];\nint INF=1000*1000*1000;\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(N==0&&M==0)return 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&K[i]);\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tscanf(\"%d%d\",&X[i][j],&D[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\t\tdp[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<K[0];j++)dp[0][j][0]=0;\n\t\tfor(int j=0;j<K[1];j++)dp[1][j][1]=0;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=0;j<K[i];j++){\n\t\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\t\tint dpijk=dp[i][j][k];\n\t\t\t\t\tif(i!=1&&k!=0){\n\t\t\t\t\t\tfor(int l=0;l<K[i-2];l++){\n\t\t\t\t\t\t\tdpijk=min(dpijk,dp[i-2][l][k-1]+(D[i-2][l]+D[i][j])*abs(X[i-2][l]-X[i][j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l=0;l<K[i-1];l++){\n\t\t\t\t\t\tdpijk=min(dpijk,dp[i-1][l][k]+(D[i-1][l]+D[i][j])*abs(X[i-1][l]-X[i][j]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=dpijk;\n\t\t\t\t\t//printf(\"%d,%d,%d:%d\\n\",i,j,k,dpijk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int j=0;j<K[N-1];j++){\n\t\t\tfor(int k=0;k<=M;k++){\n\t\t\t\tans=min(ans,dp[N-1][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nstruct Edge\n{\n  int to;\n  int weight;\n  Edge(int t, int w) : to(t), weight(w) {}\n};\n// using Graph = vector<vector<Edge>>;\nusing Graph = vector<vector<int>>;\n\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1000000000;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, 1, -1, 1, 0, -1};\n\nint dp[160][15][100];\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n\n  while (1)\n  {\n    cin >> n >> m;\n    if (n == 0 && m == 0)\n      break;\n\n    vector<vector<pair<int, int>>> xd(n + 2);\n    for (int i = 0; i < n; i++)\n    {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; j++)\n      {\n        int x, d;\n        cin >> x >> d;\n        x--;\n        xd[i].push_back({x, d});\n      }\n    }\n\n    for (int i = 0; i < 160; i++)\n    {\n      for (int j = 0; j < 15; j++)\n      {\n        for (int l = 0; l < 100; l++)\n        {\n          dp[i][j][l] = INT_INF;\n        }\n      }\n    }\n\n    for (int j = 0; j < xd[0].size(); j++)\n      dp[0][j][m] = 0;\n\n    if (m)\n      for (int j = 0; j < xd[1].size(); j++)\n      {\n        dp[1][j][m - 1] = 0;\n      }\n\n    for (int i = 0; i < n - 1; i++)\n    {\n      for (int j = 0; j < xd[i].size(); j++)\n      {\n        for (int l = 0; l < m + 1; l++)\n        {\n\n          for (int t = 0; t < xd[i + 1].size(); t++)\n          {\n            int cost = (xd[i][j].second + xd[i + 1][t].second) * abs(xd[i][j].first - xd[i + 1][t].first);\n            dp[i + 1][t][l] = min(dp[i + 1][t][l], dp[i][j][l] + cost);\n          }\n\n          if (l > 0)\n            for (int t = 0; t < xd[i + 2].size(); t++)\n            {\n              int cost = (xd[i][j].second + xd[i + 2][t].second) * abs(xd[i][j].first - xd[i + 2][t].first);\n              dp[i + 2][t][l - 1] = min(dp[i + 2][t][l - 1], dp[i][j][l] + cost);\n            }\n        }\n      }\n    }\n    int ans = INT_INF;\n    for (int j = 0; j < xd[n - 1].size(); j++) {\n      for (int l = 0; l < m + 1; l++) {\n        ans = min(ans, dp[n - 1][j][l]);\n      }\n    }\n    for (int j = 0; j < xd[n - 2].size(); j++) {\n      for (int l = 1; l < m + 1; l++) {\n        ans = min(ans, dp[n - 2][j][l]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n// dp[i][j][k]:= i行j列に到達したときの危険度の合計の最小値　kは1行飛ばしを行った回数　\n// グリッドDPの実装ヤバい版　DPはまず漸化式を考える　ある行iにいるときに次にどこに行くのかを考える．　i == 0のときとi == n + 1のときは例外処理をする　jを全て試してmも全て試す　行先をlとしてlも全部試す\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n\nusing namespace std;\nconst int INF =1001001001;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n\nint main(){\n\twhile(1){\n\tint N,M;\n\tint stonenum[152];\n\tint C[152][12];\n\tint G[152][12];\n\t//[i][j]=i+1行目にある石j個目の C=列(位置)、G=滑りやすさ>\n\tint dp[152][12][77];\n\t//[i][j][k]=i行(0,N行は陸)j+1番目にある石にいて、今までにk(<M<=(150+1)/2)回\n\t//飛ばした時の、対岸までの最短距離\n\tscanf(\"%d %d\",&N,&M);\n\tif(N==0&&M==0)break;\n\t\trep(i,N){\n\t\tint a=0;\n\t\tscanf(\"%d\",&a);\n\t\tstonenum[i]=a;\n\t\trep(j,a){\n\t\t\tint b,c;\n\t\t\tscanf(\"%d\",&b);\n\t\t\tscanf(\"%d\",&c);\n\t\t\tC[i][j]=b;G[i][j]=c;\n\t\t}\n\t}\n\t//printf(\"\\nyomikomiOK\");\n\tfor(int i=N;i>-1;i--){//i=N…0\n\t\trep(j,stonenum[i]){\n\t\t\trep(k,M+1){\n\t\t\t\tif(i==N-1){dp[i][j][k]=0;}\n\t\t\t\telse if(i==N-2&&k<M){//0距離\n\t\t\t\t\tdp[i][j][k]=0;\n\t\t\t\t}else{\n\t\t\t\t\tint ans=INF;\n\t\t\t\t\trep(m,stonenum[i+1]){\n\t\t\t\t\t\t//if(ans==INF)ans=((G[i][k]+G[i+1][m])*abs(C[i][k]-C[i+1][m])+dp[i+1][m][k]);\n\t\t\t\t\t\tans=min(ans,((G[i][j]+G[i+1][m])*abs(C[i][j]-C[i+1][m])+dp[i+1][m][k]));\n\t\t\t\t\t}\n\t\t\t\t\tif(k<M){\n\t\t\t\t\t\trep(m,stonenum[i+2]){\n\t\t\t\t\t\t\tans=min(ans,(G[i][j]+G[i+2][m])*abs(C[i][j]-C[i+2][m])+dp[i+2][m][k+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\trep(i,stonenum[0])ans=min(ans,dp[0][i][0]);\n\tif(M>0)rep(i,stonenum[1])ans=min(ans,dp[1][i][1]);\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntypedef std::pair<int, int> P;\ntypedef long long ll;\n\nconst ll inf = (1ll << 30);\n\nint n, m;\nstd::vector<P> map[205];\nll dp[205][11][105];\n\nint main(){\n\twhile(true){\n\t\tstd::cin >> n >> m;\n\t\tif(n == 0 && m == 0)break;\n\t\t\n\t\tfor(int i = 0; i < 205; ++i)map[i].clear();\n\t\t\n\t\tfor(int i = 0; i < 205; ++i){\n\t\t\tfor(int j = 0; j < 11; ++j){\n\t\t\t\tfor(int k = 0; k < 105; ++k){\n\t\t\t\t\tdp[i][j][k] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap[0].push_back(P(-1, -1));\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tint k;\n\t\t\tstd::cin >> k;\n\t\t\tfor(int j = 0; j < k; ++j){\n\t\t\t\tint a, b;\n\t\t\t\tstd::cin >> a >> b;\n\t\t\t\tmap[i].push_back(P(a - 1, b));\n\t\t\t}\n\t\t}\n\t\tmap[n + 1].push_back(P(-1, -1));\n\t\t\n\t\tdp[0][0][0] = 0;\n\t\tfor(int i = 0; i <= n; ++i){\n\t\t\tfor(int j = 0; j < map[i].size(); ++j){\n\t\t\t\tfor(int k = 0; k <= m; ++k){\n\t\t\t\t\tif(dp[i][j][k] == inf)continue;\n\t\t\t\t\t\n\t\t\t\t\tint v = i + 1;\n\t\t\t\t\tfor(int p = 0; p < map[v].size(); ++p){\n\t\t\t\t\t\tint cost = (map[i][j].second + map[v][p].second) * std::abs(map[i][j].first - map[v][p].first);\n\t\t\t\t\t\tif(map[i][j].first == -1 || map[v][p].first == -1)cost = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[v][p][k] = std::min(dp[v][p][k], dp[i][j][k] + cost);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tv = i + 2;\n\t\t\t\t\tfor(int p = 0; p < map[v].size(); ++p){\n\t\t\t\t\t\tint cost = (map[i][j].second + map[v][p].second) * std::abs(map[i][j].first - map[v][p].first);\n\t\t\t\t\t\tif(map[i][j].first == -1 || map[v][p].first == -1)cost = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[v][p][k + 1] = std::min(dp[v][p][k + 1], dp[i][j][k] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans = inf;\n\t\tfor(int i = 0; i <= m; ++i){\n\t\t\tans = std::min(ans, dp[n + 1][0][i]);\n\t\t}\n\t\t\n\t\tstd::cout << ans << std::endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 50;\n\nll dist[160][10][80];\n\nstruct S {\n\tint x, y, jump;\n\tll d;\n\tbool operator <(const S& x) const {\n\t\treturn d > x.d;\n\t}\n};\n\nll rec(S s) {\n\treturn dist[s.y][s.x][s.jump];\n}\n\nvoid save(S s) {\n\tdist[s.y][s.x][s.jump] = s.d;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tvector<ll> c[160];\n\t\tvector<ll> x[160];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\tll xx, cc;\n\t\t\t\tcin >> xx >> cc;\n\t\t\t\txx--;\n\t\t\t\tx[i].push_back(xx);\n\t\t\t\tc[i].push_back(cc);\n\t\t\t}\n\t\t}\n\n\t\tfill((ll*)begin(dist), (ll*)end(dist), INF);\n\t\tpriority_queue<S> q;\n\t\tfor(int i = 0; i < x[0].size(); i++) {\n\t\t\tS s = { i, 0, 0, 0 };\n\t\t\tq.push(s);\n\t\t\tsave(s);\n\t\t}\n\t\tif(m > 0) {\n\t\t\tfor(int i = 0; i < x[1].size(); i++) {\n\t\t\t\tS s = { i, 1, 1, 0 };\n\t\t\t\tq.push(s);\n\t\t\t\tsave(s);\n\t\t\t}\n\t\t}\n\n\n\t\tll ans = 0;\n\t\twhile(q.size()) {\n\t\t\tS s = q.top();\n\t\t\tq.pop();\n\t\t\tif(rec(s) < s.d) continue;\n\t\t\tif(s.y == n) {\n\t\t\t\tans = s.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 1; i <= 2; i++) {\n\t\t\t\tif(s.jump == m && i == 2) break;\n\t\t\t\tif(s.y + i > n) break;\n\t\t\t\tint nj = s.jump + (i == 2);\n\t\t\t\tif(s.y + i == n) {\n\t\t\t\t\tS ns = { 0, s.y + i, nj, s.d };\n\t\t\t\t\tif(rec(ns) > s.d) {\n\t\t\t\t\t\tq.push(ns);\n\t\t\t\t\t\tsave(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < x[s.y + i].size(); j++) {\n\t\t\t\t\t\tint nx = x[s.y + i][j];\n\t\t\t\t\t\tll cost = (c[s.y][s.x] + c[s.y + i][j]) * abs(x[s.y][s.x] - nx);\n\t\t\t\t\t\tS ns = { j, s.y + i, nj, s.d + cost };\n\t\t\t\t\t\tif(rec(ns) > ns.d) {\n\t\t\t\t\t\t\tq.push(ns);\n\t\t\t\t\t\t\tsave(ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n// dp[i][j][k]->iñÌòÎµWvðcµ,jsÚ,kñÚÉéÅ¬RXg\nint dp[3][1001][77];\nint field[151][1001];\nconst int INF=100000000;\n\nint main(){\n\n\n\tint n,m;\n\twhile(cin>>n>>m&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 3; i++)\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(dp[i][j],dp[i][j]+77,INF);\n\n\t\tint (*prv)[77]=dp[2];\n\t\tint (*pprv)[77]=dp[1];\n\t\tint (*cur)[77]=dp[0];\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x,d;\n\t\t\t\tcin>>x>>d;\n\t\t\t\tfield[i][x-1]=d;\n\t\t\t}\n\t\t}\n\t\t// ún_ÌÝè\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tif(field[0][i]!=0){\n\t\t\t\tdp[0][i][m]=0;\n\t\t\t}\n\t\t}\n\t\tint (*fin)[77];\n\t\t// dpÅÅ¬RXgðßé\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tswap(cur,prv);\n\t\t\tswap(pprv,cur);\n\t\t\tfor(int j = 0; j < 1001; j++)\n\t\t\t\tfill(cur[j],cur[j]+77,INF);\n\t\t\t// Ç±ÖWv·é©\n\t\t\tfor(int j = 0; j < 1001; j++){\n\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Ç±©çWv·é©\n\t\t\t\tfor(int k = 0;  k < 1001; k++){\n\t\t\t\t\tif(field[i-1][k]==0&&(i<=1||field[i-2][k]==0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// ÇÌRXgÅWv·é©\n\t\t\t\t\tfor(int l = m; l >= 0; l--){\n\t\t\t\t\t\t// ÓÂ¤ÉWv\n\t\t\t\t\t\tint cost=((field[i-1][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\tcur[j][l]=min(cur[j][l],prv[k][l]+cost);\n\t\t\t\t\t\tif(i>=2&&l!=m){\n\t\t\t\t\t\t\t// êÂòÎµÅWv\n\t\t\t\t\t\t\tcost=((field[i-2][k]+field[i][j])*abs(k-j));\n\t\t\t\t\t\t\tcur[j][l]=min(cur[j][l],pprv[k][l+1]+cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=cur;\n\t\t}\n\t\tint minRes=INF;\n\t\tfor(int i = 0; i < 1001; i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tminRes=min(minRes,fin[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<minRes<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nBe joyful in hope, patient in affliction, faithful in prayer.\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <functional>\n#include <iterator>\n#include <utility>\n#include <bitset>\n#include <cstdlib>\n#include <ctime>\n#include <complex>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\n#define FOR(i, a, b) for(int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define REPD(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define SZ(x) ((int)x.size())\n#define openfile {freopen(\"inp.txt\",\"rt\",stdin);freopen(\"out.txt\",\"wt\",stdout);}\n#define debug 0\n\ntemplate <typename T> inline void next_int(T &x) {\n\tx = 0; char c; bool neg = false;\n\twhile (!isdigit(c = getchar())) if (c == '-') neg = true;\n\tdo x = x*10 + c - 48; while (isdigit(c = getchar()));\n\tif (neg) x = -x;\n}\n\ntemplate <typename T> inline void write_int(T x, char last = 0) {\n\tif (x < 0) putchar('-'), x = abs(x);\n\tchar tmp[20]; int cnt = 0;\n\twhile (x >= 10) tmp[cnt++] = x % 10 + 48, x /= 10;\n\ttmp[cnt] = x + 48;\n\tFORD(i, cnt, 0) putchar(tmp[i]);\n\tif (last) putchar(last);\n}\n\nconst ll oo = (ll)1e18+7;\nint n, m;\nll dp[155][15][80];\nint k[155], x[155][25], s[155][25];\n\nint main() {\n\twhile(scanf(\"%d%d\", &n, &m) == 2 && n){\n\t\tREP(i, 0, 155) REP(j, 0, 15)REP(k, 0, 80) dp[i][j][k] = oo;\n\t\tREP(i, 0, n) {\n\t\t\tscanf(\"%d\", &k[i]);\n\t\t\tREP(j, 0, k[i]) scanf(\"%d%d\", &x[i][j], &s[i][j]);\n\t\t}\n\t\tREP(i, 0, k[0]) dp[0][i][0] = 0;\n\t\tREP(i, 0, k[1]) dp[1][i][1] = 0;\n\t\tREP(i, 0, n - 1) REP(j, 0, k[i]) {\n\t\t\tint cur = x[i][j];\n\t\t\tREP(l, 0, k[i + 1]) {\n\t\t\t\tint tmp = x[i + 1][l];\n\t\t\t\tFOR(used, 0, m) dp[i + 1][l][used] = min(dp[i + 1][l][used], dp[i][j][used] + (s[i][j] + s[i + 1][l]) * abs(cur - tmp));\n\t\t\t}\n\t\t\tif(i + 2 < n) {\n\t\t\t\tREP(l, 0, k[i + 2]) {\n\t\t\t\t\tint tmp = x[i + 2][l];\n\t\t\t\t\tREP(used, 0, m) dp[i + 2][l][used + 1] = min(dp[i + 2][l][used + 1], dp[i][j][used] + (s[i][j] + s[i + 2][l]) * abs(cur - tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = oo;\n\t\tREP(i, 0, k[n - 1]) REP(j, 0, m + 1) ans = min(ans, dp[n - 1][i][j]);\n\t\tREP(i, 0, k[n - 2]) REP(j, 0, m) ans = min(ans, dp[n - 2][i][j]);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"stdafx.h\"\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <vector>\ntypedef long long int ll;\n#define FOR(i, a, b) for (ll i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n - 1); i >= 0; --i)\n#define mod 1000000007\n#define INF 93193111451418101\n#define MIN -933111451418101\nusing namespace std;\ntypedef pair<ll, ll> P;\n\ntemplate <typename T, typename U>\ntypename std::enable_if<std::rank<T>::value == 0>::type fill_all(T &arr,\n\tconst U &v) {\n\tarr = v;\n}\ntemplate <typename ARR, typename U>\ntypename std::enable_if<std::rank<ARR>::value != 0>::type fill_all(ARR &arr,\n\tconst U &v) {\n\tfor (auto &i : arr) {\n\t\tfill_all(i, v);\n\t}\n}\n//------------------??????°-----------------------//\n\t\t\t\t\t //-------------------???¢???°----------------------//\n\nint main() {\n\twhile (1) {\n\t\tll n, m;\n\t\tstd::vector<P> rock[1000];\n\t\tll dp[155][100][30]; // n???????????¨??°???????????°?????´???\n\t\tcin >> n >> m;\n\t\tif (n + m == 0) { break; }\n\t\tREP(i, n) {\n\t\t\tll k;\n\t\t\tcin >> k;\n\t\t\tREP(j, k) {\n\t\t\t\tll place, sliplevel;\n\t\t\t\tcin >> place >> sliplevel;\n\t\t\t\trock[i + 1].push_back(P(place, sliplevel));\n\t\t\t}\n\t\t}\n\t\trock[0].push_back(P(0, 0));\n\t\trock[n + 1].push_back(P(0, 0));\n\t\tfill_all(dp, INF);\n\t\tdp[0][0][0] = 0;\n\t\tREP(i, n + 1) { // 0???????????????n+1????????????\n\t\t\tREP(j, m + 1) {   //????????¨??°?????????\n\t\t\t\tREP(k, (unsigned)rock[i].size()) {\n\t\t\t\t\tif (dp[i][j][k] == INF) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0 || i == n) {\n\t\t\t\t\t\tREP(l, (unsigned)rock[i + 1].size()) {\n\t\t\t\t\t\t\tdp[i + 1][j][l] = min(dp[i + 1][j][l], dp[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < m) {\n\t\t\t\t\t\t\tREP(l, (unsigned)rock[i + 2].size()) {\n\t\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tREP(l, (unsigned)rock[i + 1].size()) {\n\t\t\t\t\t\t\tdp[i + 1][j][l] =\n\t\t\t\t\t\t\t\tmin(dp[i + 1][j][l],\n\t\t\t\t\t\t\t\t\tdp[i][j][k] +\n\t\t\t\t\t\t\t\t\t(rock[i + 1][l].second + rock[i][k].second) *\n\t\t\t\t\t\t\t\t\t(abs(rock[i + 1][l].first - rock[i][k].first)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < m) {\n\t\t\t\t\t\t\tREP(l, (unsigned)rock[i + 2].size()) {\n\t\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = min(dp[i + 2][j + 1][l], dp[i][j][k] + (rock[i + 2][l].second + rock[i][k].second) *(abs(rock[i + 2][l].first - rock[i][k].first)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tREP(j, m + 1) {\n\t\t\tans = min(ans, dp[n + 1][j][0]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint n,m;\nint a,b;\nint fie[210][4];\t// 行、マス\nint dp[210][210][4];// x回目１こ飛ばし、行、マス\n\nvoid calc(int u)\n{\n\tu *= 2;\n\tu++;\n\tfor(int i = u-1; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\t\t// 現在の立ち位置\n\t\t\tfor(int k = 0; k < 4; k++){\t// 次の場所\n\t\t\t\tfor(int add = 0; add <= 1; add++){\n\t\t\t\t\tif(add+(u/2) > m)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(fie[i][j] >= 0 && fie[i+1+add][k] >= 0){\n\t\t\t\t\t\tint nowRisk = (fie[i][j] + fie[i+1+add][k])*abs(j-k)+dp[u/2][i][j];\n\t\t\t\t\t\tif(dp[u/2][i][j] == -1)\n\t\t\t\t\t\t\tnowRisk += 1;\n\n//\t\t\t\t\t\tcout << nowRisk << endl ;\n\t\t\t\t\t\tif(dp[u/2+add][i+1+add][k] >= 0)\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = min(dp[u/2+add][i+1+add][k], nowRisk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[u/2+add][i+1+add][k] = nowRisk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid solve()\n{\n\tint ans = (1 << 25);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a;\n\t\tfor(int j = 0; j < a; j++){\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tcin >> fie[i][b];\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i <= m; i++){\n\t\tcalc(i);\n\t\t\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif(dp[i][n+1][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+1][j]);\n\t\t\tif(dp[i][n+2][j] >= 0)\n\t\t\t\tans = min(ans,dp[i][n+2][j]);\n\t\t}\n\t}\n\n/*\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcout << dp[0][i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\tcout << ans << endl;\n\n\n\t\n}\n\nint main(void)\n{\n\n\twhile(cin >> n >> m, n | m){\n\t\tfor(int i = 1; i < 200; i++)\n\t\t\tfor(int j = 0; j < 4; j++)\n\t\t\t\tfie[i][j] = -1;\n\t\n\t\t//fill(fie[1], fie[1]+(200-1)*4, -1);\n\t\tfor(int i = 0; i < 200; i++){\n\t\t\tfor(int j = 0; j < 200; j++){\n\t\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t\t\tdp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\n\t\t//fill(dp[0][0], dp[0][0] + 200*200*4, -1);\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfie[n+1][i] = 0;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<24)\ntypedef pair<int,int> P;\nint n,k;\nvector<P> stone[200];\nint dp[151][11][78];\nint solve(int h,int idx,int k){\n  if(h == n-1 || (h == n-2 && k != 0)) return 0;\n  if(dp[h][idx][k] != -1) return dp[h][idx][k];\n  int ret = INF;\n  int s = stone[h][idx].second;\n  int w = stone[h][idx].first;\n  for(int i=0;i<stone[h+1].size();i++){\n    int nw = stone[h+1][i].first;\n    int ns = stone[h+1][i].second;\n    ret = min(ret,solve(h+1,i,k)+((s+ns)*abs(w-nw)));\n  }\n  if(k != 0 && h+2 <= n-1){\n    for(int i=0;i<stone[h+2].size();i++){\n      int nw = stone[h+2][i].first;\n      int ns = stone[h+2][i].second;\n      ret = min(ret,solve(h+2,i,k-1)+((s+ns)*abs(w-nw)));\n    }\n  }\n  return dp[h][idx][k] = ret;\n}\n    \n\nint main(){\n  while(cin >> n >> k , n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++){\n      int m; cin >> m;\n      stone[i].clear();\n      for(int j=0;j<m;j++){\n\tint a,b; cin >> a >> b;\n\tstone[i].push_back(P(a,b));\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<stone[0].size();i++){\n      ans = min(ans,solve(0,i,k));\n    }\n    if(k != 0){\n      for(int i=0;i<stone[1].size();i++){\n\tans = min(ans,solve(1,i,k-1));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n\nusing namespace std;\nconst int INF =1001001001;\n#define rep(i,n) for(int i=0;i<n;i++)\nint N,M;\nint stonenum[152];\nint C[152][12];\nint G[152][12];\n//[i][j]=i+1行目にある石j個目の C=列(位置)、G=滑りやすさ>\nint dp[152][12][77];\n//[i][j][k]=i行(0,N行は陸)j+1番目にある石にいて、今までにk(<M<=(150+1)/2)回\n//飛ばした時の、対岸までの最短距離\n\n\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\t\n\trep(i,N){\n\t\t//printf(\"CHECK/\");\n\t\tint a=0;\n\t\tscanf(\"%d\",&a);\n\t\tstonenum[i]=a;\n\t\trep(j,a){\n\t\t\tscanf(\"%d\",&C[i][j]);\n\t\t\t//printf(\"CH/\");\n\t\t\tscanf(\"%d\",&G[i][j]);\n\t\t\t//printf(\"CH/\");\n\t\t\t//printf(\"\\nOK%d,%d,%d\",i,C[i][j],G[i][j]);\n\t\t}\n\t\t//printf(\"CHE/\");\n\t}\n\t//printf(\"\\nyomikomiOK\");\n\tfor(int i=N-1;i>-1;i++){//i=N…0\n\t\trep(j,stonenum[i]){\n\t\t\trep(k,M+1){\n\t\t\t\tif(i==N-1&&k<M){//0距離\n\t\t\t\t}else{\n\t\t\t\t\tint ans=INF;\n\t\t\t\t\trep(m,stonenum[i+1]){\n\t\t\t\t\t\tans=min(ans,(G[i][k]+G[i+1][m])*abs(C[i][k]-C[i+1][m])+dp[i+1][m][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(k<M){\n\t\t\t\t\t\trep(m,stonenum[i+2]){\n\t\t\t\t\t\t\tans=min(ans,(G[i][k]+G[i+2][m])*abs(C[i][k]-C[i+2][m])+dp[i+2][m][k+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\trep(i,stonenum[0])ans=min(ans,dp[1][i][0]);\n\tif(M>0)rep(i,stonenum[1])ans=min(ans,dp[2][i][1]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tpii p;\n\tint c, j;\n\tstate(pii p, int c, int j) : p(p), c(c), j(j) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint risk(int cd, int nd, int dx) {\n\treturn (cd+nd)*dx;\n}\n\nint stone[150][1000];\nint field[150][1000][80];\n\nint main() {\n\tint n, m;\n//\twhile(cin >> n >> m, n) {\n\t{\n\t\tcin >> n >> m;\n\t\tREP(i, 150) {\n\t\t\tREP(j, 1000) {\n\t\t\t\tstone[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint maxx = 0;\n\t\tREP(i, n) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j, k) {\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tstone[i][x-1] = d;\n\t\t\t\tmaxx = max(maxx, x);\n\t\t\t}\n\t\t}\n\n\t\tREP(i, 150) {\n\t\t\tREP(j, 1000) {\n\t\t\t\tREP(k, 80) {\n\t\t\t\t\tfield[i][j][k] = INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> Q;\n\t\tREP(i, maxx) {\n\t\t\tif(stone[0][i] != -1) {\n\t\t\t\tfield[0][i][0] = 0;\n\t\t\t\tQ.push(state(pii(0, i), 0, 0));\n\t\t\t}\n\t\t}\n\t\tif(n > 1 && m > 0) {\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[1][i] != -1) {\n\t\t\t\t\tfield[1][i][1] = 0;\n\t\t\t\t\tQ.push(state(pii(1, i), 0, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\n\t\tint ans = INF;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tint y = st.p.first, x = st.p.second;\n\t\t\tif(y+2 == n && st.j < m) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(y+1 == n) {\n\t\t\t\tans = min(ans, st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(i, maxx) {\n\t\t\t\tif(stone[y+1][i] != -1) {\n\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+1][i], abs(x-i));\n\t\t\t\t\tif(nc < field[y+1][i][st.j]) {\n\t\t\t\t\t\tfield[y+1][i][st.j] = nc;\n\t\t\t\t\t\tQ.push(state(pii(y+1, i), nc, st.j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(st.j < m && y+2 < n) {\n\t\t\t\tREP(i, maxx) {\n\t\t\t\t\tif(stone[y+2][i] != -1) {\n\t\t\t\t\t\tint nc = st.c+risk(stone[y][x], stone[y+2][i], abs(x-i));\n\t\t\t\t\t\tif(nc < field[y+2][i][st.j+1]) {\n\t\t\t\t\t\t\tfield[y+2][i][st.j+1] = nc;\n\t\t\t\t\t\t\tQ.push(state(pii(y+2, i), nc, st.j+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define INF 200000\n\nint d[150][10];\nint dp[80][150][10];\n\n#define apply_min(a, b) \\\ndo {\\\n    if ((a) > (b)) a = (b);\\\n} while(0)\n\nint main() {\n    while (1) {\n        int l, i, j, k;\n        int n, m;\n        int min = INF;\n\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) return 0;\n\n        for (l=0;l<m+1;l++) {\n            for (i=0;i<n;i++) {\n                for (j=0;j<10;j++) {\n                    d[i][j] = INF;\n                    dp[l][i][j] = INF;\n                }\n            }\n        }\n\n        for (i=0;i<n;i++) {\n            scanf(\"%d\", &k);\n            for (j=0;j<k;j++) {\n                int x, di;\n\n                scanf(\"%d %d\", &x, &di);\n                d[i][x] = di;\n            }\n        }\n\n        for (i=0;i<m+1;i++) {\n            for (j=0;j<10;j++) {\n                dp[i][0][j] = 0;\n            }\n        }\n\n        for (l=0;l<m+1;l++) {\n            for (i=1;i<n;i++) {\n                for (j=0;j<10;j++) {\n                    int min_danger = INF;\n\n                    if (d[i][j] == INF) continue;\n\n                    for (k=0;k<10;k++) {\n                        int danger;\n\n                        if (l != 0 && i > 1 && d[i-2][k] != INF) {\n                            danger = dp[l-1][i-2][k] + (d[i-2][k] + d[i][j]) * abs(k - j);\n                            apply_min(min_danger, danger);\n                        }\n\n                        if (d[i-1][k] != INF) {\n                            danger = dp[l][i-1][k] + (d[i-1][k] + d[i][j]) * abs(k - j);\n                            apply_min(min_danger, danger);\n                        }\n                    }\n\n                    dp[l][i][j] = min_danger;\n                }\n            }\n        }\n\n        for (i=0;i<10;i++) {\n            apply_min(min, dp[m][n-1][i]);\n        }\n\n        printf(\"%d\\n\", min);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint dp[151][1001][76];\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvvint vv;\n\t\tinitvv(vv,n,1001,-1);\n\t\trep(i,151) rep(j,1001) rep(k,76) dp[i][j][k]=INF;\n\t\trep(i,n){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\trep(j,t){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tvv[i][a-1]=b;\n\t\t\t}\n\t\t}\n\t\t// puts(\"hoge\");\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// printf(\"%2d\",vv[i][j]);\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\trep(i,2){\n\t\t\trep(j,1001){\n\t\t\t\tif(vv[i][j]!=-1) dp[i][j][i]=0;\n\t\t\t}\n\t\t}\n\t\t// return;\n\t\trep(i,n-1){\n\t\t\trep(j,1001){\n\t\t\t\tif(vv[i][j]==-1) continue;\n\t\t\t\trep(o,76){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tif(o+k>75) continue;\n\t\t\t\t\t\trep(l,1001){\n\t\t\t\t\t\t\tif(vv[i+k+1][l]==-1) continue;\n\t\t\t\t\t\t\tdp[i+k+1][l][o+k]=min(dp[i+k+1][l][o+k],dp[i][j][o]+abs(j-l)*(vv[i][j]+vv[i+k+1][l]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==n-2) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// if(dp[i][j][0]!=INF) printf(\"%2d\",dp[i][j][0]);\n\t\t\t\t// else cout<<\"  \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\t// rep(i,n){\n\t\t\t// rep(j,n){\n\t\t\t\t// if(dp[i][j][1]!=INF) printf(\"%2d\",dp[i][j][1]);\n\t\t\t\t// else cout<<\"  \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t\treep(i,n-2,n){\n\t\t\trep(j,1001){\n\t\t\t\trep(k,m){\n\t\t\t\t\tans=min(ans,dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout<<ans<<endl;\n\t\trep(i,1001){\n\t\t\trep(k,m+1){\n\t\t\t\tans=min(ans,dp[n-1][i][k]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int>  pi;\ntypedef pair<pair<int,int>,int>  ppi;\ntypedef vector<pair<pair<int,int>,int> >  vppi;\n#define ff first.first\n#define fs first.second\n#define se second\n\nstruct Stone { int row, col, d; };\n\nconst int S = 150;\nconst int T = 151;\n\nstruct Edge { int to1, to2, cost; };\nvector<Edge> G[160][80];\nint dist[160][80];\n\nvoid addEdge(int u1, int u2, int v1, int v2, int cost) {\n    G[u1][u2].push_back((Edge){ v1, v2, cost });\n}\n\nint risk(Stone a, Stone b) {\n    return (a.d + b.d) * abs(a.col - b.col);\n}\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        for (int i=0; i<160; ++i) {\n            for (int j=0; j<80; ++j) {\n                G[i][j].clear();\n            }\n        }\n\n        vector<Stone> stones;\n        int k;\n        for (int i=0; i<n; ++i) {\n            cin >> k;\n            int x, d;\n            for (int j=0; j<k; ++j) {\n                cin >> x >> d;\n                stones.push_back((Stone){ i, x, d });\n            }\n        }\n\n        for (int i=0; i<(int)stones.size(); ++i) {\n            // S\n            if (stones[i].row == 0) {\n                for (int j=0; j<80; ++j) {\n                    addEdge(S, j, i, j, 0);\n                }\n            } else if (stones[i].row == 1) {\n                for (int j=1; j<80; ++j) {\n                    addEdge(S, j, i, j-1, 0);\n                }\n            }\n\n            // T\n            if (stones[i].row == n-1) {\n                for (int j=0; j<80; ++j) {\n                    addEdge(i, j, T, j, 0);\n                }\n            } else if (stones[i].row == n-2) {\n                for (int j=1; j<80; ++j) {\n                    addEdge(i, j, T, j-1, 0);\n                }\n            }\n\n            // other\n            for (int j=i+1; j<(int)stones.size(); ++j) {\n                int jump = stones[j].row - stones[i].row;\n                if (3 <= jump) break;\n                if (jump == 1) {\n                    for (int k=0; k<80; ++k) {\n                        addEdge(i, k, j, k, risk(stones[i], stones[j]));\n                    }\n                } else if (jump == 2) {\n                    for (int k=1; k<80; ++k) {\n                        addEdge(i, k, j, k-1, risk(stones[i], stones[j]));\n                    }\n                }\n            }\n        }\n\n        for (int i=0; i<160; ++i) {\n            for (int j=0; j<80; ++j) {\n                dist[i][j] = INT_MAX;\n            }\n        }\n        dist[S][m] = 0;\n        priority_queue<ppi, vppi, greater<ppi> > q;\n        q.push(make_pair(make_pair(0, S), m));\n        while ( ! q.empty()) {\n            int cost = q.top().ff;\n            int u1 = q.top().fs;\n            int u2 = q.top().se;\n            q.pop();\n            for (int i=0; i<(int)G[u1][u2].size(); ++i) {\n                Edge &e = G[u1][u2][i];\n                if (cost + e.cost < dist[e.to1][e.to2]) {\n                    dist[e.to1][e.to2] = cost + e.cost;\n                    q.push(make_pair(make_pair(cost + e.cost, e.to1), e.to2));\n                }\n            }\n        }\n        cout << *min_element(dist[T], dist[T]+80) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nconst int INF = 1 << 30;\nconst int MAX_X = 1010;\nint dp[MAX_X][160][80];\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n >> m && n)\n\t{\n\t\trep(x,MAX_X) rep(y,n) rep(d,m+1) dp[x][y][d] = INF;\n\t\tvector<vint> r(MAX_X, vint(n+10));\n\t\trep(i,MAX_X)rep(j,n) r[i][j]=0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\trep(j,s)\n\t\t\t{\n\t\t\t\tint x, d;\n\t\t\t\tcin >> x >> d;\n\t\t\t\tr[x][i] = d;\n\t\t\t}\n\t\t}\n\n\t\trep(x,MAX_X)if(r[x][0]) dp[x][0][m] = 0;\n\t\trep(x,MAX_X)if(r[x][1]) dp[x][1][m-1] = 0;\n\n\t\tfor(int y = 1; y < n; y++) for(int x = 0; x < MAX_X; x++)\n\t\t{\n\t\t\tif(r[x][y])\n\t\t\t{\n\t\t\t\t// ÊíWv\n\t\t\t\trep(nx, MAX_X) rep(d, m+1) //ë¯xðiÁÄ¢¯Î} èÂ\n\t\t\t\t\tif(dp[nx][y-1][d] != INF)\n\t\t\t\t\t\tchmin(dp[x][y][d], dp[nx][y-1][d] + (r[x][y] + r[nx][y-1]) * abs(x - nx));\n\n\t\t\t\t// êiÆÎµ\n\t\t\t\tif(1 < y)\n\t\t\t\t\trep(nx, MAX_X) REP(d, 1, m+1)\n\t\t\t\t\t\tif(dp[nx][y-2][d] != INF)\n\t\t\t\t\t\t\tchmin(dp[x][y][d-1], dp[nx][y-2][d] + (r[x][y] + r[nx][y-2]) * abs(x - nx));\n\t\t\t}\n\t\t}\n\n\t\tint res = INF;\n\t\trep(x, MAX_X) rep(d, m+1) chmin(res, dp[x][n-1][d]);\n\t\trep(x, MAX_X) REP(d, 1, m+1) chmin(res, dp[x][n-2][d]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define INF 10000000000000000\nstruct S {int x,d;};\nint n,m;\nint dp[152][1002][80];//n,x,m\nvector<S> a[152];\n\nsigned main(){\n  while(cin>>n>>m,n){\n    REP(i,n+2)a[i].clear();\n    REP(i,n){\n      int k,x,d;\n      cin>>k;\n      REP(j,k){\n        cin>>x>>d;\n        a[i+1].push_back({x,d});\n      }\n    }\n    REP(i,n+2)REP(j,1000)REP(k,m+1)dp[i][j+1][k]=INF;\n    REP(j,1000)a[0].push_back({j+1,0});\n    REP(j,1000)a[n+1].push_back({j+1,0});\n    REP(j,1000)dp[0][j+1][0]=0;\n    REP(i,n+2){\n      for(S s:a[i]){\n        for(S t:a[i+1]){\n          REP(c,m+1){\n            dp[i+1][t.x][c]=min(dp[i+1][t.x][c],dp[i][s.x][c]+(s.d+t.d)*abs(s.x-t.x));\n          }\n        }\n        if(i+1>n)continue;\n        for(S u:a[i+2]){\n          REP(c,m){\n            dp[i+2][u.x][c+1]=min(dp[i+2][u.x][c+1],dp[i][s.x][c]+(s.d+u.d)*abs(s.x-u.x));\n          }\n        }\n      }\n    }\n    int ans=INF;\n    REP(j,1000)REP(c,m+1)ans=min(ans,dp[n+1][j+1][c]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\nstruct po{int x,d;};\nlong long dp[155][15][80];\n\nint calc(po a,po b){return (a.d+b.d)*(abs(a.x-b.x));}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n  \n    vector <po> mp[200];\n    for(int i=0;i<200;i++)mp[i].clear();\n\n    for(int i=0,k;i<n;i++){\n      cin>>k;\n      mp[i].resize(k);\n      for(int j=0;j<k;j++) cin>>mp[i][j].x>>mp[i][j].d;\n    }\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<(int)mp[i].size();j++) \n\tfor(int k=0;k<=m;k++)dp[i][j][k]=INF;\n    \n    for(int i=0;i<(int)mp[0].size();i++) dp[0][i][0]=0;\n    if(m)for(int i=0;i<(int)mp[1].size();i++) dp[1][i][1]=0;\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<(int)mp[i].size();j++)\n\tfor(int k=0;k<=m;k++){\n\t  for(int l=0;l<(int)mp[i+1].size();l++)\n\t    dp[i+1][l][k]=min(dp[i+1][l][k],dp[i][j][k]+calc(mp[i][j],mp[i+1][l]));\n\t  \n\t  for(int l=0;l<(int)mp[i+2].size()&&k!=m;l++)\n\t    dp[i+2][l][k+1]=min(dp[i+2][l][k+1],dp[i][j][k]+calc(mp[i][j],mp[i+2][l]));\n\t}\n    }\n    \n    long long ans=INF;\n    for(int i=0;i<(int)mp[n-1].size();i++)\n      for(int j=0;j<=m;j++) ans=min(dp[n-1][i][j],ans);\n    \n    for(int i=0;i<(int)mp[n-2].size();i++)\n      for(int j=0;j<m;j++)  ans=min(dp[n-2][i][j],ans);\n    cout <<ans<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint K[150]; //K[i]::=i行目に何個の石があるか\nint X[10][150]; //X[i][j]::=j列目のi個目が何列目か\nint D[10][150]; //D[i][j]::=j列目のi個目のすべりやすさ\nint DP[10][150][80]; //DP[i][j][k]::=j列目のi個目にいて、あとk回ジャンプできる\nint main() {\n\tint N,M;\n\twhile(scanf(\"%d %d\",&N,&M),N|M) {\n\t\tfill((int*)DP,(int*)(DP+10),INF);\n\t\tfor(int y=0;y<N;y++) {\n\t\t\tscanf(\"%d\",&K[y]);\n\t\t\tfor(int x=0;x<K[y];x++) {\n\t\t\t\tscanf(\"%d %d\",&X[x][y],&D[x][y]);\n\t\t\t}\n\t\t}\n\t\tfor(int x=0;x<K[0];x++) DP[x][0][M]=0;\n\t\tif(M>0) for(int x=0;x<K[1];x++) DP[x][1][M-1]=0;\n\t\tfor(int y=1;y<N;y++) for(int x=0;x<K[y];x++) {\n\t\t\tfor(int xx=0;xx<K[y-1];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-1][m]+(D[x][y]+D[xx][y-1])*abs(X[x][y]-X[xx][y-1]));\n\t\t\t}\n\t\t\tif(y==1) continue;\n\t\t\tfor(int xx=0;xx<K[y-2];xx++) for(int m=0;m<=M;m++) {\n\t\t\t\tDP[x][y][m]=min(DP[x][y][m],DP[xx][y-2][m+1]+(D[x][y]+D[xx][y-2])*abs(X[x][y]-X[xx][y-2]));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int x=0;x<K[N-2];x++) for(int m=1;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-2][m]);\n\t\t}\n\t\tfor(int x=0;x<K[N-1];x++) for(int m=0;m<=M;m++) {\n\t\t\tans=min(ans,DP[x][N-1][m]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM)\nimport Data.Array (Array,listArray,(!),(//))\n\ntype Column = Int\ntype Danger = Int\ntype Stone = (Column,Danger)\n\ntype Point = Int\ntype PointMatrix = Array Int [Point]\n\nmain = do\n    [n,m] <- getLine >>= return . map read . words\n    if all (==0) [n,m] then return () else do\n        st <- readStones n\n        print $ solve m st\n        main\n\nreadStones :: Int -> IO [[Stone]]\nreadStones n = replicateM n readRow\n    where\n    readRow = do\n        nums <- getLine >>= return . map read . words\n        return (stones (tail nums))\n\n    stones [] = []\n    stones (c:d:ns) = (c,d) : stones ns\n\nsolve :: Int -> [[Stone]] -> Point\nsolve m (r2:r1:rs) = pm1 `seq` pm2 `seq` step rs r1 r2 pm1 pm2\n    where\n    pm2 = (listArray (0,m) (repeat [])) // [(m, map (const 0) r2)]\n\n    pm1 | m == 0 = (listArray (0,m) (repeat [])) //\n            [(m, ((r2,pm2) %% m) <*> r1)]\n        | otherwise = (listArray (0,m) (repeat [])) //\n            [(m, ((r2,pm2) %% m) <*> r1), (m-1, map (const 0) r1)]\n\n    step [] r1 r2 pm1 pm2 = case (ps1,ps2) of\n            ([],[]) -> -1\n            (ps,[]) -> minimum ps\n            ([],ps) -> minimum ps\n            (ps1,ps2) -> min (minimum ps1) (minimum ps2)\n        where\n        ps1 = concatMap (pm1!) [0..m]\n        ps2 = concatMap (pm2!) [1..m]\n\n    step (r0:rs) r1 r2 pm1 pm2 = pm0 `seq` step rs r0 r1 pm0 pm1\n        where\n        pm0 = listArray (0,m) (map points [0..m])\n        points m'\n            | m' == m = ((r1,pm1) %% m') <*> r0\n            | otherwise = takeMin\n                    (((r1,pm1) %% m') <*> r0)\n                    (((r2,pm2) %% (m'+1)) <*> r0)\n\n        takeMin [] xs = xs\n        takeMin xs [] = xs\n        takeMin xs ys = zipWith min xs ys\n\n    (%%) :: ([Stone],PointMatrix) -> Int -> [(Stone,Point)]\n    (r,pm) %% m = zip r (pm!m)\n\n    (<*>) :: [(Stone,Point)] -> [Stone] -> [Point]\n    [] <*> _ = []\n    prevs <*> currs = map safest currs\n        where\n        safest curr = minimum $ map (`newPoint` curr) prevs\n        newPoint ((c1,d1),p1) (c0,d0) = p1 + (d0+d1) * (abs (c0-c1))"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define INF (1000000000)\n\ntypedef struct {\n    int dx;\n    int lev;\n} STONE;\n\nint min(int a, int b)\n{\n    if (a > b){\n        return (b);\n    }\n    return (a);\n}\n\nint danger(STONE a, STONE b)\n{\n    return (abs(a.dx - b.dx) * (a.lev + b.lev));\n}\n\nint main(void)\n{\n    int n, m;\n    int dx, lev;\n    int i, j, k, l;\n    int num[151];\n    STONE info[151][11];\n    static int dp[151][76][11];\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d\", &num[i]);\n            for (j = 0; j < num[i]; j++){\n                scanf(\"%d%d\", &info[i][j].dx, &info[i][j].lev);\n            }\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        memset(dp[0], 0, sizeof(dp[0]));\n        if (m > 0){\n            memset(dp[1][1], 0, sizeof(dp[1][1]));\n        }\n        \n        ans = INF;\n        \n        for (i = 0; i <= m; i++){\n            for (j = 1; j < n; j++){\n                for (k = 0; k < num[j]; k++){\n                    for (l = 0; l < num[j - 1]; l++){\n                        if (dp[j][i][k] == -1 && dp[j - 1][i][l] != -1){\n                            dp[j][i][k] = dp[j - 1][i][l] + danger(info[j][k], info[j - 1][l]);\n                        }\n                        else if (dp[j - 1][i][l] != -1){\n                            dp[j][i][k] = min(dp[j][i][k], dp[j - 1][i][l] + danger(info[j][k], info[j - 1][l]));\n                        }\n                        if (dp[j][i][k] != -1 && j == n - 1){\n                            ans = min(ans, dp[j][i][k]);\n                        }\n                    }\n                    if (i != 0 && j >= 2){\n                        for (l = 0; l < num[j - 2]; l++){\n                            if (dp[j][i][k] == -1 && dp[j - 2][i - 1][l] != -1){\n                                dp[j][i][k] = dp[j - 2][i - 1][l] + danger(info[j][k], info[j - 2][l]);\n                            }\n                            else if (dp[j - 2][i - 1][l] != -1){\n                                dp[j][i][k] = min(dp[j][i][k], dp[j - 2][i - 1][l] + danger(info[j][k], info[j - 2][l]));\n                            }\n                        }\n                        if (dp[j][i][k] != -1 && ((j == n - 2 && i < m) || (j == n - 1))){\n                            ans = min(ans, dp[j][i][k]);\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n,m;\nint stone_num[160];\nint stones[160][10][2];\n\nint memo[160][100][10];\n\nint tansaku(int ypos,int tobasi_num,int xpos) {\n\tint i;\n\tint now,min;\n\tif(ypos>n)return 0;\n\tif(memo[ypos][tobasi_num][xpos]>0)return memo[ypos][tobasi_num][xpos]-1;\n\tmin=0x3fffffff;\n\tfor(i=0;i<stone_num[ypos+1];i++) {\n\t\tnow=tansaku(ypos+1,tobasi_num,i);\n\t\tif(ypos>0 && ypos+1<=n) {\n\t\t\tnow+=abs(stones[ypos][xpos][0]-stones[ypos+1][i][0])*\n\t\t\t\t(stones[ypos][xpos][1]+stones[ypos+1][i][1]);\n\t\t}\n\t\tif(now<min)min=now;\n\t}\n\tif(tobasi_num>0) {\n\t\tfor(i=0;i<stone_num[ypos+2];i++) {\n\t\t\tnow=tansaku(ypos+2,tobasi_num-1,i);\n\t\t\tif(ypos>0 && ypos+2<=n) {\n\t\t\t\tnow+=abs(stones[ypos][xpos][0]-stones[ypos+2][i][0])*\n\t\t\t\t\t(stones[ypos][xpos][1]+stones[ypos+2][i][1]);\n\t\t\t}\n\t\t\tif(now<min)min=now;\n\t\t}\n\t}\n\tmemo[ypos][tobasi_num][xpos]=min+1;\n\treturn min;\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tstone_num[0]=1;\n\t\tstones[0][0][0]=stones[0][0][1]=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\tscanf(\"%d\",&stone_num[i]);\n\t\t\tfor(j=0;j<stone_num[i];j++) {\n\t\t\t\tscanf(\"%d%d\",&stones[i][j][0],&stones[i][j][1]);\n\t\t\t}\n\t\t}\n\t\tstone_num[n+1]=1;\n\t\tstones[n+1][0][0]=stones[n+1][0][1]=0;\n\t\tstone_num[n+2]=1;\n\t\tstones[n+2][0][0]=stones[n+2][0][1]=0;\n\t\tmemset(memo,0,sizeof(memo));\n\t\tprintf(\"%d\\n\",tansaku(0,m,0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX_R (3000000)\n#define min(x,y) ((x<y)?x:y)\ntypedef struct stone{\n\tint x,r;\n}Stone;\nStone p[155][15];\nint xn[155],dp[155][15][80];\nint main(){\n\tint i,j,k,h,n,m,x,y,z,ans;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&xn[i]);\n\t\t\tfor(j=0;j<xn[i];j++){\n\t\t\t\tscanf(\"%d%d\",&p[i][j].x,&p[i][j].r);\n\t\t\t\tfor(k=0;k<=m;k++)dp[i][j][k]=MAX_R;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<xn[0];i++)dp[0][i][0]=0;\n\t\tfor(i=0;i<xn[1];i++)dp[1][i][1]=0;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tfor(h=0;h<=m;h++){\n\t\t\t\tfor(j=0;j<xn[i];j++){\n\t\t\t\t\tfor(k=0;k<xn[i+1];k++){\n\t\t\t\t\t\ty=(p[i][j].r+p[i+1][k].r)*abs(p[i][j].x-p[i+1][k].x);\n\t\t\t\t\t\tdp[i+1][k][h]=min(dp[i+1][k][h],dp[i][j][h]+y);\n\t\t\t\t\t}\n\t\t\t\t\tfor(k=0;k<xn[i+2];k++){\n\t\t\t\t\t\ty=(p[i][j].r+p[i+2][k].r)*abs(p[i][j].x-p[i+2][k].x);\n\t\t\t\t\t\tdp[i+2][k][h+1]=min(dp[i+2][k][h],dp[i][j][h]+y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=MAX_R;\n\t\tfor(i=0;i<=h;i++){\n\t\t\tfor(j=0;j<xn[n-1];j++){\n\t\t\t\tans=min(ans,dp[n-1][j][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,l,min,d;\n  int ic[150],is[2][150][10];\n  int c[80][150][11];\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int c[80][150][11]={0};\n    for(i=0;i<80;i++){\n      for(j=1;j<150;j++){\n\tfor(k=0;k<11;k++)c[i][j][k]=2100000000;\n      }\n    }\n    for(i=0;i<11;i++)c[1][1][i]=0;\n    for(i=0;i<n;i++){\n      scanf(\"%d\",&ic[i]);\n      for(j=0;j<ic[i];j++){\n\tscanf(\"%d %d\",&is[0][i][j],&is[1][i][j]);\n      }\n    }\n    for(i=0;i<=m;i++){\n      for(j=0;j+1<n;j++){\n\tfor(k=0;k<ic[j];k++){\n\t  for(l=0;l<ic[j+1];l++){\n\t    d=(is[1][j][k]+is[1][j+1][l])*abs(is[0][j][k]-is[0][j+1][l]);\n\t    //printf(\"d%d from %d %d to %d %d\\n\",\n\t    //\t   d,is[0][j][k],is[1][j][k],is[0][j+1][l],is[1][j+1][l]);\n\t    if(c[i][j+1][l]>c[i][j][k]+d)c[i][j+1][l]=c[i][j][k]+d;\n\t  }\n\t  if(j+2==n)continue;\n\t  for(l=0;l<ic[j+2];l++){\n\t    d=(is[1][j][k]+is[1][j+2][l])*abs(is[0][j][k]-is[0][j+2][l]);\n\t    //printf(\"d%d from %d %d to %d %d\\n\",\n\t    //\t   d,is[0][j][k],is[1][j][k],is[0][j+2][l],is[1][j+2][l]);\n\t    if(c[i+1][j+2][l]>c[i][j][k]+d)c[i+1][j+2][l]=c[i][j][k]+d;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<=m;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<ic[j];k++)printf(\"%d \",c[i][j][k]);printf(\"\\n\");\n      }printf(\"\\n\");\n      }//*/\n    min=2100000210;\n    for(i=0;i<=m;i++){\n      for(j=0;j<ic[n-1];j++){\n\tif(min>c[i][n-1][j])min=c[i][n-1][j];\n      }\n      if(m==i)continue;\n      for(j=0;j<ic[n-2];j++){\n\tif(min>c[i][n-2][j])min=c[i][n-2][j];\n      }\n    }\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}\n\n\n\t    \n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,l,min,d;\n  int ic[150],is[2][150][10];\n  int c[80][150][11];\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int c[80][150][11]={0};\n    for(i=0;i<80;i++){\n      for(j=1;j<150;j++){\n\tfor(k=0;k<11;k++)c[i][j][k]=2100000000;\n      }\n    }\n    for(i=0;i<11;i++)c[1][1][i]=0;\n    for(i=0;i<n;i++){\n      scanf(\"%d\",&ic[i]);\n      for(j=0;j<ic[i];j++){\n\tscanf(\"%d %d\",&is[0][i][j],&is[1][i][j]);\n      }\n    }\n    for(i=0;i<=m;i++){\n      for(j=0;j+1<n;j++){\n\tfor(k=0;k<ic[j];k++){\n\t  for(l=0;l<ic[j+1];l++){\n\t    d=(is[1][j][k]+is[1][j+1][l])*abs(is[0][j][k]-is[0][j+1][l]);\n\t    //printf(\"d%d from %d %d to %d %d\\n\",\n\t    //\t   d,is[0][j][k],is[1][j][k],is[0][j+1][l],is[1][j+1][l]);\n\t    if(c[i][j+1][l]>c[i][j][k]+d)c[i][j+1][l]=c[i][j][k]+d;\n\t  }\n\t  if(j+2==n)continue;\n\t  for(l=0;l<ic[j+2];l++){\n\t    d=(is[1][j][k]+is[1][j+2][l])*abs(is[0][j][k]-is[0][j+2][l]);\n\t    //printf(\"d%d from %d %d to %d %d\\n\",\n\t    //\t   d,is[0][j][k],is[1][j][k],is[0][j+2][l],is[1][j+2][l]);\n\t    if(c[i+1][j+2][l]>c[i][j][k]+d)c[i+1][j+2][l]=c[i][j][k]+d;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<=m;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<ic[j];k++)printf(\"%d \",c[i][j][k]);printf(\"\\n\");\n      }printf(\"\\n\");\n      }//*/\n    min=2100000210;\n    for(i=0;i<=m;i++){\n      for(j=0;j<ic[n-1];j++){\n\tif(min>c[i][n-1][j])min=c[i][n-1][j];\n      }\n      if(m==i)continue;\n      for(j=0;j<ic[n-2];j++){\n\tif(min>c[i][n-2][j])min=c[i][n-2][j];\n      }\n    }\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ImpossiblyLargeNum (1000+1000)*1000*150+1\n\nint n_max,m_max,cnt_max;\nint ADJ1[10*150+2][10*150+2];\nint ADJ2[10*150+2][10*150+2];\nint xstart[150+2];\nint xend[150+2];\nint MinCost[76][10*150+2];\n\n\ntypedef struct tag_POINT {\n\tint n;\n\tint x;\n\tint d;\n}POINT;\n\nPOINT Stone[10*150+2];\n\n\nint search();\n\nint main(){\n\tint x,n,d,k;\n\tint cnt;\n\tint i,j;\n\tint ans;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&n_max,&m_max);\n\t\tif(!n_max&&!m_max)break;\n\t\t\n\t\t\n\t\tcnt=0,n=0,x=0,d=0;\n\t\t\n\t\tStone[cnt].n=n;Stone[cnt].x=x;Stone[cnt].d=d;\n\t\txstart[n]=cnt;xend[n]=cnt;\n\t\tcnt++;\n\t\t\n\t\tfor(n=1;n<=n_max;n++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tif(k==0){xstart[n]=-1;xend[n]=-2;}\n\t\t\tfor(i=0;i<k;i++){\n\t\t\t\tif(i==0)xstart[n]=cnt;\n\t\t\t\tif(i==k-1)xend[n]=cnt;\n\t\t\t\tscanf(\"%d%d\",&x,&d);\n\t\t\t\tStone[cnt].n=n;Stone[cnt].x=x;Stone[cnt].d=d;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tStone[cnt].n=n;Stone[cnt].x=0;Stone[cnt].d=0;\n\t\txstart[n]=cnt;xend[n]=cnt;\n\t\tcnt_max=cnt;\n\t\t\n\t\t\n\t\t\n\t\tfor(i=0;i<=n_max+1;i++){\n\t\t\tfor(j=0;j<=n_max+1;j++){\n\t\t\t\tADJ1[i][j]=ADJ2[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=xstart[1];i<=xend[1];i++)ADJ1[0][i]=0;\n\t\tfor(i=xstart[2];i<=xend[2];i++)ADJ2[0][i]=0;\n\t\tfor(cnt=1;Stone[cnt].n<n_max-1;cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\t\tADJ2[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t}\n\t\tfor(cnt=xstart[n_max-1];cnt<=xend[n_max-1];cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\t\tADJ2[cnt][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(cnt=xstart[n_max];cnt<=xend[n_max];cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans=0;cnt=0;\n\t\t\n\t\tans=search();\n\t\t\n\t\tprintf (\"%d\\n\",ans);\n\t\t\n\t\t\n\t}\n\treturn 0;\n}\n\n\nint search(){\n\n\tint cnt;\n\tint m;\n\t\n\tfor(cnt=0;cnt<=cnt_max;cnt++){\n\t\tfor(m=0;m<=m_max;m++){\n\t\t\tMinCost[m][cnt]=ImpossiblyLargeNum;//impossiblly large score\n\t\t}\n\t}\n\n\tint i,j,min_temp;\n\t\n\tfor(cnt=0;cnt<=cnt_max;cnt++){\n\t\tif(cnt==0){\n\t\t\tMinCost[0][0]=0;\n\t\t}\n\t\tif(Stone[cnt].n==1){\n\t\t\tMinCost[0][cnt]=0;\n\t\t}\n\t\tif(Stone[cnt].n>=2){\n\t\t\tmin_temp=ImpossiblyLargeNum;\n\t\t\tfor(i=xstart[Stone[cnt].n-1];i<=xend[Stone[cnt].n-1];i++){\n\t\t\t\tif(min_temp>=ADJ1[i][cnt]+MinCost[0][i])min_temp=ADJ1[i][cnt]+MinCost[0][i];\n\t\t\t}\n\t\t\tMinCost[0][cnt]=min_temp;\n\t\t\t\n\t\t\tfor(m=1;m<=m_max;m++){\n\t\t\t\tmin_temp=ImpossiblyLargeNum;\n\t\t\t\tfor(i=xstart[Stone[cnt].n-1];i<=xend[Stone[cnt].n-1];i++){\n\t\t\t\t\tif(min_temp>=ADJ1[i][cnt]+MinCost[m][i])min_temp=ADJ1[i][cnt]+MinCost[m][i];\n\t\t\t\t}\n\t\t\t\tfor(i=xstart[Stone[cnt].n-2];i<=xend[Stone[cnt].n-2];i++){\n\t\t\t\t\tif(min_temp>=ADJ2[i][cnt]+MinCost[m-1][i])min_temp=ADJ2[i][cnt]+MinCost[m-1][i];\n\t\t\t\t}\n\t\t\t\tMinCost[m][cnt]=min_temp;\n\t\t\t}\n\t\t}\n\t}\n\n\tmin_temp=ImpossiblyLargeNum;\n\tfor(m=0;m<=m_max;m++){\n\t\tif(min_temp>=MinCost[m][cnt_max])min_temp=MinCost[m][cnt_max];\n\t}\n\treturn min_temp;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0530: Pyon-Pyon River Crossing\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 800000000\n\ntypedef struct { int x, d; } T;\nT tbl[151][11]; int sz[151];\nint dp[151][11][80];\nchar buf[110], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, n1, m, i, j, k, w, t, dj, ans;\n\n\twhile (fgets(p=buf, 20, stdin) && *p != '0') {\n\t\tn = getint(), n1 = n - 1, m = getint();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf, 110, stdin);\n\t\t\tsz[i] = k = getint();\n\t\t\tfor (j = 0; j < k; j++) tbl[i][j].x = getint(), tbl[i][j].d = getint();\n\t\t}\n\n\t\tmemset(dp, 0x55, sizeof(dp));\n\t\tfor (j = 0; j < sz[0]; j++) dp[0][j][m] = 0;\n\t\tif (m) for (j = 0; j < sz[1]; j++) dp[1][j][m-1] = 0;\n\n\t\tfor (i = 0; i < n1; i++) for (j = 0; j < sz[i]; j++) for (k = 0; k <= m; k++) {\n\t\t\tif (dp[i][j][k] > INF) continue;\n\t\t\tfor (w = 0; w < sz[i+1]; w++) {\n\t\t\t\tdj = tbl[i][j].x - tbl[i+1][w].x;\n\t\t\t\tif (dj < 0) dj = -dj;\n\t\t\t\tt = (tbl[i][j].d + tbl[i+1][w].d) * dj;\n\t\t\t\tif (dp[i+1][w][k] > dp[i][j][k] + t) dp[i+1][w][k] = dp[i][j][k] + t;\n\t\t\t}\n\n\t\t\tif (!k || i+2 == n) continue;\n\t\t\tfor (w = 0; w < sz[i+2]; w++) {\n\t\t\t\tdj = tbl[i][j].x - tbl[i+2][w].x;\n\t\t\t\tif (dj < 0) dj = -dj;\n\t\t\t\tt = (tbl[i][j].d + tbl[i+2][w].d) * dj;\n\t\t\t\tif (dp[i+2][w][k-1] > dp[i][j][k] + t) dp[i+2][w][k-1] = dp[i][j][k] + t;\n\t\t\t}\n\t\t}\n\n\t\tans = INF;\n\t\tfor (j = 0; j < 10; j++) for (k = 0; k <= m; k++)\n\t\t\tif (ans > dp[n-1][j][k]) ans = dp[n-1][j][k];\n\t\tfor (j = 0; j < 10; j++) for (k = 1; k <= m; k++)\n\t\t\tif (ans > dp[n-2][j][k]) ans = dp[n-2][j][k];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint n_max,m_max,cnt_max;\nint ADJ1[10*150+2][10*150+2];\nint ADJ2[10*150+2][10*150+2];\nint xstart[150+2];\nint xend[150+2];\nint MinCost[76][10*150+2];\n\n\ntypedef struct tag_POINT {\n\tint n;\n\tint x;\n\tint d;\n}POINT;\n\nPOINT Stone[10*150+2];\n\n\nint search();\n\nint main(){\n\tint x,n,d,k;\n\tint cnt;\n\tint i,j;\n\tint ans;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&n_max,&m_max);\n\t\tif(!n_max&&!m_max)break;\n\t\t\n\t\t\n\t\tcnt=0,n=0,x=0,d=0;\n\t\t\n\t\tStone[cnt].n=n;Stone[cnt].x=x;Stone[cnt].d=d;\n\t\txstart[n]=cnt;xend[n]=cnt;\n\t\tcnt++;\n\t\t\n\t\tfor(n=1;n<=n_max;n++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tif(k==0){xstart[n]=-1;xend[n]=-2;}\n\t\t\tfor(i=0;i<k;i++){\n\t\t\t\tif(i==0)xstart[n]=cnt;\n\t\t\t\tif(i==k-1)xend[n]=cnt;\n\t\t\t\tscanf(\"%d%d\",&x,&d);\n\t\t\t\tStone[cnt].n=n;Stone[cnt].x=x;Stone[cnt].d=d;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tStone[cnt].n=n;Stone[cnt].x=0;Stone[cnt].d=0;\n\t\txstart[n]=cnt;xend[n]=cnt;\n\t\tcnt_max=cnt;\n\t\t\n\t\t\n\t\t\n\t\tfor(i=0;i<=n_max+1;i++){\n\t\t\tfor(j=0;j<=n_max+1;j++){\n\t\t\t\tADJ1[i][j]=ADJ2[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=xstart[1];i<=xend[1];i++)ADJ1[0][i]=0;\n\t\tfor(i=xstart[2];i<=xend[2];i++)ADJ2[0][i]=0;\n\t\tfor(cnt=1;Stone[cnt].n<n_max-1;cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\t\tADJ2[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t}\n\t\tfor(cnt=xstart[n_max-1];cnt<=xend[n_max-1];cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\t\tADJ2[cnt][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(cnt=xstart[n_max];cnt<=xend[n_max];cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans=0;cnt=0;\n\t\t\n\t\tans=search();\n\t\t\n\t\tprintf (\"%d\\n\",ans);\n\t\t\n\t\t\n\t}\n\treturn 0;\n}\n\n\nint search(){\n\n\tint cnt;\n\tint m;\n\t\n\tfor(cnt=0;cnt<=cnt_max;cnt++){\n\t\tfor(m=0;m<=m_max;m++){\n\t\t\tMinCost[m][cnt]=1000*150+1;//impossiblly large score\n\t\t}\n\t}\n\n\tint i,j,min_temp;\n\t\n\tfor(cnt=0;cnt<=cnt_max;cnt++){\n\t\tif(cnt==0){\n\t\t\tMinCost[0][0]=0;\n\t\t}\n\t\tif(Stone[cnt].n==1){\n\t\t\tMinCost[0][cnt]=0;\n\t\t}\n\t\tif(Stone[cnt].n>=2){\n\t\t\tmin_temp=1000*150+1;\n\t\t\tfor(i=xstart[Stone[cnt].n-1];i<=xend[Stone[cnt].n-1];i++){\n\t\t\t\tif(min_temp>=ADJ1[i][cnt]+MinCost[0][i])min_temp=ADJ1[i][cnt]+MinCost[0][i];\n\t\t\t}\n\t\t\tMinCost[0][cnt]=min_temp;\n\t\t\t\n\t\t\tfor(m=1;m<=m_max;m++){\n\t\t\t\tmin_temp=1000*150+1;\n\t\t\t\tfor(i=xstart[Stone[cnt].n-1];i<=xend[Stone[cnt].n-1];i++){\n\t\t\t\t\tif(min_temp>=ADJ1[i][cnt]+MinCost[m][i])min_temp=ADJ1[i][cnt]+MinCost[m][i];\n\t\t\t\t}\n\t\t\t\tfor(i=xstart[Stone[cnt].n-2];i<=xend[Stone[cnt].n-2];i++){\n\t\t\t\t\tif(min_temp>=ADJ2[i][cnt]+MinCost[m-1][i])min_temp=ADJ2[i][cnt]+MinCost[m-1][i];\n\t\t\t\t}\n\t\t\t\tMinCost[m][cnt]=min_temp;\n\t\t\t}\n\t\t}\n\t}\n\n\tmin_temp=1000*150+1;\n\tfor(m=0;m<=m_max;m++){\n\t\tif(min_temp>=MinCost[m][cnt_max])min_temp=MinCost[m][cnt_max];\n\t}\n\treturn min_temp;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ABS(x) (x<0?(-x):(x))\nstatic int nmin,n,map[155][1050]={0};\n\nint SearchRoot(int x, int y, int m, int Risk){\n\tint i, ret, min=-1, risk;\n\tif((m && y+2 == n+1) || y+1 == n+1){\n\t\tnmin = (nmin<0 || Risk<nmin) ? Risk:nmin;\n\t\treturn 0;\n\t}\n\tfor(i=1;i<=1000;i++){\n\t\tif(map[y+1][i]){\n\t\t\trisk = (!y ? 0 : ABS((x-i) * (map[y+1][i] + map[y][x])));\n\t\t\tif(Risk + risk < nmin || nmin < 0){\n\t\t\t\tret = risk + SearchRoot(i, y+1, m, Risk+risk);\n\t\t\t\tmin = (ret-risk >= 0 && (min<0 || ret<min) ? ret : min);\n\t\t\t}\n\t\t}\n\t\tif(map[y+2][i] && m){\n\t\t\trisk = (!y ? 0 : ABS((x-i) * (map[y+2][i] + map[y][x])));\n\t\t\tif(Risk + risk < nmin || nmin < 0){\n\t\t\t\tret = risk + SearchRoot(i, y+2, m-1, Risk + risk);\n\t\t\t\tmin = (ret-risk >= 0 && (min<0 || ret<min) ? ret : min);\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"(%d,%d) %d %d %d %d \\n\", x, y, m, min, nmin, Risk);\n\treturn min;\n}\n\nint main(int argc, char *argv[]){\n\tint i,j,m,k,x;\n\t\n\twhile(scanf(\"%d %d \",&n,&m), n){\n\t\tmemset(map, 0, 155*1050);\n\t\tnmin=-1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d \", &k);\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tscanf(\"%d \", &x);\n\t\t\t\tscanf(\"%d \", &map[i][x]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", SearchRoot(0, 0, m, 0));\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define INF 1000000000\n#define NMAX 150\n#define KMAX 10\n#define MMAX 75\nstruct stone {\n  int x;\n  int w;\n};\nint main(void)\n{\n  int i, j, k, l, n, m, ans, lx[NMAX], dp[NMAX][KMAX][MMAX+1];\n  struct stone rs[NMAX][MMAX];\n  while (scanf(\"%d %d\", &n, &m), n) {\n    ans = INF;\n    for (i = 0; i < n; i++) {\n      scanf(\"%d\", &lx[i]);\n      for (j = 0; j < lx[i]; j++) {\n        scanf(\"%d %d\", &rs[i][j].x, &rs[i][j].w);\n      }\n    }\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < lx[i]; j++) {\n        for (k = 0; k <= m; k++) {\n          dp[i][j][k] = INF;\n        }\n      }\n    }\n    for (j = 0; j < lx[0]; j++) dp[0][j][0] = 0;\n    if (m) {\n      for (j = 0; j < lx[1]; j++) dp[1][j][1] = 0;\n    }\n    for (i = 0; i < n - 1; i++) {\n      for (j = 0; j < lx[i]; j++) {\n        for (k = 0; k <= m; k++) {\n          if (dp[i][j][k] == INF) continue;\n          for (l = 0; l < lx[i+1]; l++) {\n            int dj = abs(rs[i][j].x - rs[i+1][l].x), risk = (rs[i][j].w + rs[i+1][l].w) * dj;\n            if (dp[i+1][l][k] > dp[i][j][k] + risk) dp[i+1][l][k] = dp[i][j][k] + risk;\n          }\n          if (k == m || i + 2 == n) continue;\n          for (l = 0; l < lx[i+2]; l++) {\n            int dj = abs(rs[i][j].x - rs[i+2][l].x), risk = (rs[i][j].w + rs[i+2][l].w) * dj;\n            if (dp[i+2][l][k+1] > dp[i][j][k] + risk) dp[i+2][l][k+1] = dp[i][j][k] + risk;\n          }\n        }\n      }\n    }\n    for (j = 0; j < lx[n-2]; j++) {\n      for (k = 0; k < m; k++) {\n            //printf(\"%d \", dp[n-2][j][k]);\n        if (ans > dp[n-2][j][k]) ans = dp[n-2][j][k];\n      }\n    }\n    //putchar('\\n');\n    for (j = 0; j < lx[n-1]; j++) {\n      for (k = 0; k <= m; k++) {\n              //printf(\"%d \", dp[n-1][j][k]);\n        if (ans > dp[n-1][j][k]) ans = dp[n-1][j][k];\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,l,min,d;\n  int ic[150],is[2][150][10];\n  int c[80][150][11];\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int c[80][150][11]={0};\n    for(i=0;i<80;i++){\n      for(j=1;j<150;j++){\n\tfor(k=0;k<11;k++)c[i][j][k]=210000000;\n      }\n    }\n    for(i=0;i<11;i++)c[1][1][i]=0;\n    for(i=0;i<n;i++){\n      scanf(\"%d\",&ic[i]);\n      for(j=0;j<ic[i];j++){\n\tscanf(\"%d %d\",&is[0][i][j],&is[1][i][j]);\n      }\n    }\n    for(i=0;i<=m;i++){\n      for(j=0;j+1<n;j++){\n\tfor(k=0;k<ic[j];k++){\n\t  for(l=0;l<ic[j+1];l++){\n\t    d=(is[1][j][k]+is[1][j+1][l])*abs(is[0][j][k]-is[0][j+1][l]);\n\t    //printf(\"d%d from %d %d to %d %d\\n\",\n\t    //\t   d,is[0][j][k],is[1][j][k],is[0][j+1][l],is[1][j+1][l]);\n\t    if(c[i][j+1][l]>c[i][j][k]+d)c[i][j+1][l]=c[i][j][k]+d;\n\t  }\n\t  if(j+2==n)continue;\n\t  for(l=0;l<ic[j+2];l++){\n\t    d=(is[1][j][k]+is[1][j+2][l])*abs(is[0][j][k]-is[0][j+2][l]);\n\t    //printf(\"d%d from %d %d to %d %d\\n\",\n\t    //\t   d,is[0][j][k],is[1][j][k],is[0][j+2][l],is[1][j+2][l]);\n\t    if(c[i+1][j+2][l]>c[i][j][k]+d)c[i+1][j+2][l]=c[i][j][k]+d;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<=m;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<ic[j];k++)printf(\"%d \",c[i][j][k]);printf(\"\\n\");\n      }printf(\"\\n\");\n      }//*/\n    min=210000021;\n    for(i=0;i<=m;i++){\n      for(j=0;j<ic[n-1];j++){\n\tif(min>c[i][n-1][j])min=c[i][n-1][j];\n      }\n      if(m==i)continue;\n      for(j=0;j<ic[n-2];j++){\n\tif(min>c[i][n-2][j])min=c[i][n-2][j];\n      }\n    }\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n,m;\nint stone_num[160];\nint stones[160][10][2];\n\nint memo[150][100][10];\n\nint tansaku(int ypos,int tobasi_num,int xpos) {\n\tint i;\n\tint now,min;\n\tif(ypos>n)return 0;\n\tif(memo[ypos][tobasi_num][xpos]>0)return memo[ypos][tobasi_num][xpos]-1;\n\tmin=0x3fffffff;\n\tfor(i=0;i<stone_num[ypos+1];i++) {\n\t\tnow=tansaku(ypos+1,tobasi_num,i);\n\t\tif(ypos>0 && ypos+1<=n) {\n\t\t\tnow+=abs(stones[ypos][xpos][0]-stones[ypos+1][i][0])*\n\t\t\t\t(stones[ypos][xpos][1]+stones[ypos+1][i][1]);\n\t\t}\n\t\tif(now<min)min=now;\n\t}\n\tif(tobasi_num>0) {\n\t\tfor(i=0;i<stone_num[ypos+2];i++) {\n\t\t\tnow=tansaku(ypos+2,tobasi_num-1,i);\n\t\t\tif(ypos>0 && ypos+2<=n) {\n\t\t\t\tnow+=abs(stones[ypos][xpos][0]-stones[ypos+2][i][0])*\n\t\t\t\t\t(stones[ypos][xpos][1]+stones[ypos+2][i][1]);\n\t\t\t}\n\t\t\tif(now<min)min=now;\n\t\t}\n\t}\n\tmemo[ypos][tobasi_num][xpos]=min+1;\n\treturn min;\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tstone_num[0]=1;\n\t\tstones[0][0][0]=stones[0][0][1]=0;\n\t\tfor(i=1;i<=n;i++) {\n\t\t\tscanf(\"%d\",&stone_num[i]);\n\t\t\tfor(j=0;j<stone_num[i];j++) {\n\t\t\t\tscanf(\"%d%d\",&stones[i][j][0],&stones[i][j][1]);\n\t\t\t}\n\t\t}\n\t\tstone_num[n+1]=1;\n\t\tstones[n+1][0][0]=stones[n+1][0][1]=0;\n\t\tstone_num[n+2]=1;\n\t\tstones[n+2][0][0]=stones[n+2][0][1]=0;\n\t\tmemset(memo,0,sizeof(memo));\n\t\tprintf(\"%d\\n\",tansaku(0,m,0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nlong stone[150][1000],dp[150][1000][76],m,n;\n\nint main(){\n\tint i,j,k,r;\n\tlong min,danger;\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0)  break;\n\t\tmemset(stone,0,sizeof(stone));\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tscanf(\"%d\",&r);\n\t\t\t\tscanf(\"%ld\",&stone[i][r-1]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<1000;j++){\n\t\t\t\tif(stone[i][j]>0){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tdp[0][j][0]=0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\t\t\tfor(r=0;r<1000;r++){\n\t\t\t\t\t\t\t\tif(dp[i-1][r][k]>-1){\n\t\t\t\t\t\t\t\t\tif(dp[i][j][k]==-1) dp[i][j][k]=dp[i-1][r][k]+(stone[i-1][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tdanger=dp[i-1][r][k]+(stone[i-1][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k]=(dp[i][j][k]>danger)?danger:dp[i][j][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==1){\n\t\t\t\t\t\t\tif(0<m){\n\t\t\t\t\t\t\t\tdp[i][j][1]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(k=0;k<m;k++){\n\t\t\t\t\t\t\t\tfor(r=0;r<1000;r++){\n\t\t\t\t\t\t\t\t\tif(dp[i-2][r][k]>-1){\n\t\t\t\t\t\t\t\t\t\tif(dp[i][j][k+1]==-1) dp[i][j][k+1]=dp[i-2][r][k]+(stone[i-2][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\tdanger=dp[i-2][r][k]+(stone[i-2][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k+1]=(dp[i][j][k+1]>danger)?danger:dp[i][j][k+1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin=-1;\n\t\tfor(i=0;i<1000;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tif(dp[n-1][i][j]>-1){\n\t\t\t\t\tif(min==-1) min=dp[n-1][i][j];\n\t\t\t\t\telse min=(dp[n-1][i][j]<min)?dp[n-1][i][j]:min;\n\t\t\t\t}\n\t\t\t\tif(j<m){\n\t\t\t\t\tif(dp[n-2][i][j]>-1){\n\t\t\t\t\t\tif(min==-1) min=dp[n-2][i][j];\n\t\t\t\t\t\telse min=(dp[n-2][i][j]<min)?dp[n-2][i][j]:min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%ld\\n\",min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint n_max,m_max,cnt_max;\nint ADJ1[10*150+2][10*150+2];\nint ADJ2[10*150+2][10*150+2];\nint xstart[150+2];\nint xend[150+2];\n\ntypedef struct tag_POINT {\n\tint n;\n\tint x;\n\tint d;\n}POINT;\n\nPOINT Stone[10*150+2];\n\n\nint search(int m_max,int d,int cnt);\n\nint main(){\n\tint x,n,d,k;\n\tint cnt;\n\tint i,j;\n\tint ans;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&n_max,&m_max);\n\t\tif(!n_max&&!m_max)break;\n\t\t\n\t\t\n\t\tcnt=0,n=0,x=0,d=0;\n\t\t\n\t\tStone[cnt].n=n;Stone[cnt].x=x;Stone[cnt].d=d;\n\t\txstart[n]=cnt;xend[cnt]=cnt;\n\t\tcnt++;\n\t\t\n\t\tfor(n=1;n<=n_max;n++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tif(k==0){xstart[n]=-1;xend[n]=-2;}\n\t\t\tfor(i=0;i<k;i++){\n\t\t\t\tif(i==0)xstart[n]=cnt;\n\t\t\t\tif(i==k-1)xend[n]=cnt;\n\t\t\t\tscanf(\"%d%d\",&x,&d);\n\t\t\t\tStone[cnt].n=n;Stone[cnt].x=x;Stone[cnt].d=d;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tStone[cnt].n=n;Stone[cnt].x=0;Stone[cnt].d=0;\n\t\txstart[n]=cnt;xend[n]=cnt;\n\t\tcnt_max=cnt;\n\t\t\n\t\t\n\t\t\n\t\tfor(i=0;i<=n_max+1;i++){\n\t\t\tfor(j=0;j<=n_max+1;j++){\n\t\t\t\tADJ1[i][j]=ADJ2[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=xstart[1];i<=xend[1];i++)ADJ1[0][i]=0;\n\t\tfor(i=xstart[2];i<=xend[2];i++)ADJ2[0][i]=0;\n\t\tfor(cnt=1;Stone[cnt].n<n_max-1;cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\t\tADJ2[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t}\n\t\tfor(cnt=xstart[n_max-1];cnt<=xend[n_max-1];cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\t\tADJ2[cnt][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(cnt=xstart[n_max];cnt<=xend[n_max];cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans=0;cnt=0;\n\t\t\n\t\tans=search(m_max,0,cnt);\n\t\t\n\t\tprintf (\"%d\\n\",ans);\n\t\t\n\t\t\n\t}\n\treturn 0;\n}\n\n\nint search(int m_stk,int d_stk,int cnt_stk){\n\n\tint m=m_stk,d=d_stk,cnt=cnt_stk;\n\tstatic int MIN;\n\tif(d_stk==0 && cnt_stk==0)MIN=1000*150+1;//impossiblly large score\n\tint i;\n\t\n\tif(cnt==cnt_max){\n\t\tif(MIN>=d)MIN=d;\n\t\treturn MIN;\n\t}\n\tif(m>0){\n\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\tif(d+ADJ2[cnt][i]<MIN)search(m-1,d+ADJ2[cnt][i],i);\n\t\t}\n\t}\n\n\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\tif(d+ADJ1[cnt][i]<MIN)search(m,d+ADJ1[cnt][i],i);\n\t}\n\t\n\treturn MIN;\n\t\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint n_max,m_max,cnt_max;\nint ADJ1[10*150+2][10*150+2];\nint ADJ2[10*150+2][10*150+2];\nint xstart[150+2];\nint xend[150+2];\n\ntypedef struct tag_POINT {\n\tint n;\n\tint x;\n\tint d;\n}POINT;\n\nPOINT Stone[10*150+2];\n\n\nint search(int m_max,int d,int cnt);\n\nint main(){\n\tint x,n,d,k;\n\tint cnt;\n\tint i,j;\n\tint ans;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\\n\",&n_max,&m_max);\n\t\tif(!n_max&&!m_max)break;\n\t\t\n\t\t\n\t\tcnt=0,n=0,x=0,d=0;\n\t\t\n\t\tStone[cnt].n=n;Stone[cnt].x=x;Stone[cnt].d=d;\n\t\txstart[n]=cnt;xend[cnt]=cnt;\n\t\tcnt++;\n\t\t\n\t\tfor(n=1;n<=n_max;n++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tif(k==0){xstart[n]=-1;xend[n]=-2;}\n\t\t\tfor(i=0;i<k;i++){\n\t\t\t\tif(i==0)xstart[n]=cnt;\n\t\t\t\tif(i==k-1)xend[n]=cnt;\n\t\t\t\tscanf(\"%d%d\",&x,&d);\n\t\t\t\tStone[cnt].n=n;Stone[cnt].x=x;Stone[cnt].d=d;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tStone[cnt].n=n;Stone[cnt].x=0;Stone[cnt].d=0;\n\t\txstart[n]=cnt;xend[n]=cnt;\n\t\tcnt_max=cnt;\n\t\t\n\t\t\n\t\t\n\t\tfor(i=0;i<=n_max+1;i++){\n\t\t\tfor(j=0;j<=n_max+1;j++){\n\t\t\t\tADJ1[i][j]=ADJ2[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=xstart[1];i<=xend[1];i++)ADJ1[0][i]=0;\n\t\tfor(i=xstart[2];i<=xend[2];i++)ADJ2[0][i]=0;\n\t\tfor(cnt=1;Stone[cnt].n<n_max-1;cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\t\tADJ2[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t}\n\t\tfor(cnt=xstart[n_max-1];cnt<=xend[n_max-1];cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=(Stone[cnt].d+Stone[i].d)*(Stone[cnt].x>Stone[i].x?Stone[cnt].x-Stone[i].x:Stone[i].x-Stone[cnt].x);\n\t\t\t}\n\t\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\t\tADJ2[cnt][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(cnt=xstart[n_max];cnt<=xend[n_max];cnt++){\n\t\t\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\t\t\tADJ1[cnt][i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans=0;cnt=0;\n\t\t\n\t\tans=search(m_max,0,cnt);\n\t\t\n\t\tprintf (\"%d\\n\",ans);\n\t\t\n\t\t\n\t}\n\treturn 0;\n}\n\n\nint search(int m_stk,int d_stk,int cnt_stk){\n\n\tint m=m_stk,d=d_stk,cnt=cnt_stk;\n\tstatic int MIN;\n\tif(d_stk==0 && cnt_stk==0)MIN=1000*150+1;//impossiblly large score\n\tint i;\n\t\n\tif(cnt==cnt_max){\n\t\tif(MIN>=d)MIN=d;\n\t\treturn MIN;\n\t}\n\tfor(i=xstart[Stone[cnt].n+1];i<=xend[Stone[cnt].n+1];i++){\n\t\tif(d+ADJ1[cnt][i]<MIN)search(m,d+ADJ1[cnt][i],i);\n\t}\n\tif(m>0){\n\t\tfor(i=xstart[Stone[cnt].n+2];i<=xend[Stone[cnt].n+2];i++){\n\t\t\tif(d+ADJ2[cnt][i]<MIN)search(m-1,d+ADJ2[cnt][i],i);\n\t\t}\n\t}\n\t\n\treturn MIN;\n\t\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ABS(x) (x<0?(-x):(x))\nstatic int n,map[155][1050]={0};\n\nint SearchRoot(int x, int y, int m, int nmin){\n\tint i, ret, min=-1, Risk;\n\tif((m && y+2 == n+1) || y+1 == n+1) return 0;\n\tfor(i=1;i<=1000;i++){\n\t\tif(map[y+1][i]){\n\t\t\tRisk = (!y ? 0 : ABS((x-i) * (map[y+1][i] + map[y][x])));\n\t\t\tif(Risk < nmin || nmin<0){\n\t\t\t\tret = Risk + SearchRoot(i, y+1, m, min);\n\t\t\t\tmin = (ret - Risk >= 0 && (min<0 || ret<min) ? ret : min);\n\t\t\t}\n\t\t}\n\t\tif(map[y+2][i] && m){\n\t\t\tRisk = (!y ? 0 : ABS((x-i) * (map[y+2][i] + map[y][x])));\n\t\t\tif(Risk < nmin || nmin<0){\n\t\t\t\tret = Risk + SearchRoot(i, y+2, m-1, min);\n\t\t\t\tmin = (ret - Risk >= 0 && (min<0 || ret<min) ? ret : min);\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}\n\nint main(int argc, char *argv[]){\n\tint i,j,m,k,x;\n\t\n\twhile(scanf(\"%d %d \",&n,&m), n){\n\t\tmemset(map, 0, 155*1050);\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d \", &k);\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tscanf(\"%d \", &x);\n\t\t\t\tscanf(\"%d \", &map[i][x]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", SearchRoot(0, 0, m, -1));\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define INF 200000\n\nint d[150][10];\nint dp[80][150][10];\n\n#define apply_min(a, b) \\\ndo {\\\n    if ((a) > (b)) a = (b);\\\n} while(0)\n\nint main() {\n    while (1) {\n        int l, i, j, k;\n        int n, m;\n        int min = INF;\n\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) return 0;\n\n        for (l=0;l<m+1;l++) {\n            for (i=0;i<n;i++) {\n                for (j=0;j<10;j++) {\n                    d[i][j] = INF;\n                    dp[l][i][j] = INF;\n                }\n            }\n        }\n\n        for (i=0;i<n;i++) {\n            scanf(\"%d\", &k);\n            for (j=0;j<k;j++) {\n                int x, di;\n\n                scanf(\"%d %d\", &x, &di);\n                d[i][x] = di;\n            }\n        }\n\n        for (i=0;i<m+1;i++) {\n            for (j=0;j<10;j++) {\n                dp[i][0][j] = 0;\n            }\n        }\n\n        for (l=0;l<m+1;l++) {\n            for (i=1;i<n;i++) {\n                for (j=0;j<10;j++) {\n                    int min_danger = INF;\n\n                    if (d[i][j] == INF) continue;\n\n                    for (k=0;k<10;k++) {\n                        int danger;\n\n                        if (l != 0 && i > 1 && d[i-2][k] != INF) {\n                            danger = dp[l-1][i-2][k] + (d[i-2][k] + d[i][j]) * abs(k - j);\n                            apply_min(min_danger, danger);\n                        }\n\n                        if (d[i-1][k] != INF) {\n                            danger = dp[l][i-1][k] + (d[i-1][k] + d[i][j]) * abs(k - j);\n                            apply_min(min_danger, danger);\n                        }\n                    }\n\n                    dp[l][i][j] = min_danger;\n                }\n            }\n        }\n\n        for (i=0;i<10;i++) {\n            apply_min(min, dp[m][n-1][i]);\n        }\n\n        printf(\"%d\\n\", min);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define INF (1000000000)\n\ntypedef struct {\n    int dx;\n    int lev;\n} STONE;\n\nint min(int a, int b)\n{\n    if (a > b){\n        return (b);\n    }\n    return (a);\n}\n\nint danger(STONE a, STONE b)\n{\n    return (abs(a.dx - b.dx) * (a.lev + b.lev));\n}\n\nint main(void)\n{\n    int n, m;\n    int dx, lev;\n    int i, j, k, l;\n    int jump;\n    int num[151];\n    STONE info[151][11];\n    static int dp[151][76][11];\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        \n        jump = 0;\n        for (i = 0; i < n; i++){\n            scanf(\"%d\", &num[i]);\n            if (num[i] == 0){\n                jump++;\n            }\n            for (j = 0; j < num[i]; j++){\n                scanf(\"%d%d\", &info[i][j].dx, &info[i][j].lev);\n            }\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        memset(dp[0], 0, sizeof(dp[0]));\n        if (m > 0){\n            memset(dp[1][1], 0, sizeof(dp[1][1]));\n        }\n        \n        ans = INF;\n        \n        for (i = 0; i <= m; i++){\n            for (j = 1; j < n; j++){\n                for (k = 0; k < num[j]; k++){\n                    for (l = 0; l < num[j - 1]; l++){\n                        if (dp[j][i][k] == -1 && dp[j - 1][i][l] != -1){\n                            dp[j][i][k] = dp[j - 1][i][l] + danger(info[j][k], info[j - 1][l]);\n                        }\n                        else if (dp[j - 1][i][l] != -1){\n                            dp[j][i][k] = min(dp[j][i][k], dp[j - 1][i][l] + danger(info[j][k], info[j - 1][l]));\n                        }\n                        if (dp[j][i][k] != -1 && j == n - 1 && i >= jump){\n                            ans = min(ans, dp[j][i][k]);\n                        }\n                    }\n                    if (i != 0 && j >= 2){\n                        for (l = 0; l < num[j - 2]; l++){\n                            if (dp[j][i][k] == -1 && dp[j - 2][i - 1][l] != -1){\n                                dp[j][i][k] = dp[j - 2][i - 1][l] + danger(info[j][k], info[j - 2][l]);\n                            }\n                            else if (dp[j - 2][i - 1][l] != -1){\n                                dp[j][i][k] = min(dp[j][i][k], dp[j - 2][i - 1][l] + danger(info[j][k], info[j - 2][l]));\n                            }\n                        }\n                        if (dp[j][i][k] != -1 && j == n - 2 && i != m && i >= jump){\n                            ans = min(ans, dp[j][i][k]);\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX_R (3000000)\n#define min(x,y) ((x<y)?x:y)\ntypedef struct stone{\n\tint x,r;\n}Stone;\nStone p[155][15];\nint xn[155],dp[155][15][80];\nint main(){\n\tint i,j,k,h,n,m,x,y,z,ans;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&xn[i]);\n\t\t\tfor(j=0;j<xn[i];j++){\n\t\t\t\tscanf(\"%d%d\",&p[i][j].x,&p[i][j].r);\n\t\t\t\tfor(k=0;k<=m;k++)dp[i][j][k]=MAX_R;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<xn[0];i++)dp[0][i][0]=0;\n\t\tfor(i=0;i<xn[1];i++)dp[1][i][1]=0;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tfor(h=0;h<=m;h++){\n\t\t\t\tfor(j=0;j<xn[i];j++){\n\t\t\t\t\tfor(k=0;k<xn[i+1];k++){\n\t\t\t\t\t\ty=(p[i][j].r+p[i+1][k].r)*abs(p[i][j].x-p[i+1][k].x);\n\t\t\t\t\t\tdp[i+1][k][h]=min(dp[i+1][k][h],dp[i][j][h]+y);\n\t\t\t\t\t}\n\t\t\t\t\tfor(k=0;k<xn[i+2];k++){\n\t\t\t\t\t\ty=(p[i][j].r+p[i+2][k].r)*abs(p[i][j].x-p[i+2][k].x);\n\t\t\t\t\t\tdp[i+2][k][h+1]=min(dp[i+2][k][h],dp[i][j][h]+y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=MAX_R;\n\t\tfor(i=0;i<=m;i++)\n\t\t\tfor(j=0;j<xn[n-1];j++)\n\t\t\t\tans=min(ans,dp[n-1][j][i]);\n\t\tfor(i=0;i<m;i++)\n\t\t\tfor(j=0;j<xn[n-2];j++)\n\t\t\t\tans=min(ans,dp[n-2][j][i]);\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define ROW_MAX 150\n#define DANGER_MAX 2000000\n\nint dp[75][ROW_MAX][10];\n\nint main (void) {\n    int N, M, K[ROW_MAX], X[ROW_MAX][10], D[ROW_MAX][10];\n    int i, n, m, k, d, j, dmin;\n    \n    while (scanf(\"%d%d\\n\", &N, &M) != EOF && (N || M)) {\n        for (i = 0; i < N; i++) {\n            scanf(\"%d\", &K[i]);\n            for (j = 0; j < K[i]; j++) {\n                scanf(\"%d%d\", &X[i][j], &D[i][j]);\n            }\n        }\n        \n        for (m = 0; m <= M; m++) {\n            for (i = 0; i < N; i++) {\n                for (k = 0; k < K[i]; k++) {\n                    dp[m][i][k] = DANGER_MAX;\n                }\n            }\n        }\n        for (k = 0; k < K[0]; k++) {\n            dp[0][0][k] = 0;\n        }\n        for (k = 0; k < K[1]; k++) {\n            for (j = 0, dmin = DANGER_MAX; j < K[0]; j++) {\n                 d = (D[1][k] + D[0][j]) * abs(X[1][k] - X[0][j]);\n                 if (d < dmin) dmin = d;\n            }\n            dp[0][1][k] = dmin;\n            dp[1][1][k] = 0;\n        }\n        for (m = 0; m <= M; m++) {\n            for (i = 2; i < N; i++) {\n                for (j = 0; j < K[i]; j++) {\n                    for (k = 0, dmin = DANGER_MAX; k < K[i-1]; k++) {\n                        d = dp[m][i-1][k] +\n                            (D[i][j] + D[i-1][k]) * abs(X[i][j] - X[i-1][k]);\n                        if (d < dmin) dmin = d;\n                    }\n                    if (m > 0) {\n                        for (k = 0; k < K[i-2]; k++) {\n                            d = dp[m-1][i-2][k] +\n                                (D[i][j] + D[i-2][k]) * abs(X[i][j] - X[i-2][k]);\n                            if (d < dmin) dmin = d;\n                        }\n                    }\n                    dp[m][i][j] = dmin;\n                }\n            }\n        }\n        for (m = 0, dmin = DANGER_MAX; m <= M; m++) {\n            for (k = 0; k < K[N-1]; k++) {\n                if (dp[m][N-1][k] < dmin) dmin = dp[m][N-1][k];\n            }\n        }\n        printf(\"%d\\n\", dmin);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint stone[150][1000],m,n;\nint dp[150][1000][76];\n\nint main(){\n\tint i,j,k,r;\n\tint min,danger;\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0)  break;\n\t\tmemset(stone,0,sizeof(stone));\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tscanf(\"%d\",&r);\n\t\t\t\tscanf(\"%d\",&stone[i][r-1]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<1000;j++){\n\t\t\t\tif(stone[i][j]>0){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tdp[0][j][0]=0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\t\t\tfor(r=0;r<1000;r++){\n\t\t\t\t\t\t\t\tif(dp[i-1][r][k]>-1){\n\t\t\t\t\t\t\t\t\tif(dp[i][j][k]==-1) dp[i][j][k]=dp[i-1][r][k]+(stone[i-1][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tdanger=dp[i-1][r][k]+(stone[i-1][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k]=(dp[i][j][k]>danger)?danger:dp[i][j][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==1){\n\t\t\t\t\t\t\tif(0<m){\n\t\t\t\t\t\t\t\tdp[i][j][1]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(k=0;k<m;k++){\n\t\t\t\t\t\t\t\tfor(r=0;r<1000;r++){\n\t\t\t\t\t\t\t\t\tif(dp[i-2][r][k]>-1){\n\t\t\t\t\t\t\t\t\t\tif(dp[i][j][k+1]==-1) dp[i][j][k+1]=dp[i-2][r][k]+(stone[i-2][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\tdanger=dp[i-2][r][k]+(stone[i-2][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k+1]=(dp[i][j][k+1]>danger)?danger:dp[i][j][k+1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin=-1;\n\t\tfor(i=0;i<1000;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tif(dp[n-1][i][j]>-1){\n\t\t\t\t\tif(min==-1) min=dp[n-1][i][j];\n\t\t\t\t\telse min=(dp[n-1][i][j]<min)?dp[n-1][i][j]:min;\n\t\t\t\t}\n\t\t\t\tif(j<m){\n\t\t\t\t\tif(dp[n-2][i][j]>-1){\n\t\t\t\t\t\tif(min==-1) min=dp[n-2][i][j];\n\t\t\t\t\t\telse min=(dp[n-2][i][j]<min)?dp[n-2][i][j]:min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint stone[150][1000],m,n;\nlong dp[150][1000][76];\n\nint main(){\n\tint i,j,k,r;\n\tlong min,danger;\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0)  break;\n\t\tmemset(stone,0,sizeof(stone));\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tscanf(\"%d\",&r);\n\t\t\t\tscanf(\"%d\",&stone[i][r-1]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<1000;j++){\n\t\t\t\tif(stone[i][j]>0){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tdp[0][j][0]=0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\t\t\t\tfor(r=0;r<1000;r++){\n\t\t\t\t\t\t\t\tif(dp[i-1][r][k]>-1){\n\t\t\t\t\t\t\t\t\tif(dp[i][j][k]==-1) dp[i][j][k]=dp[i-1][r][k]+(stone[i-1][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tdanger=dp[i-1][r][k]+(stone[i-1][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\tdp[i][j][k]=(dp[i][j][k]>danger)?danger:dp[i][j][k];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==1){\n\t\t\t\t\t\t\tif(0<m){\n\t\t\t\t\t\t\t\tdp[i][j][1]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(k=0;k<m;k++){\n\t\t\t\t\t\t\t\tfor(r=0;r<1000;r++){\n\t\t\t\t\t\t\t\t\tif(dp[i-2][r][k]>-1){\n\t\t\t\t\t\t\t\t\t\tif(dp[i][j][k+1]==-1) dp[i][j][k+1]=dp[i-2][r][k]+(stone[i-2][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\tdanger=dp[i-2][r][k]+(stone[i-2][r]+stone[i][j])*abs(j-r);\n\t\t\t\t\t\t\t\t\t\t\tdp[i][j][k+1]=(dp[i][j][k+1]>danger)?danger:dp[i][j][k+1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin=-1;\n\t\tfor(i=0;i<1000;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tif(dp[n-1][i][j]>-1){\n\t\t\t\t\tif(min==-1) min=dp[n-1][i][j];\n\t\t\t\t\telse min=(dp[n-1][i][j]<min)?dp[n-1][i][j]:min;\n\t\t\t\t}\n\t\t\t\tif(j<m){\n\t\t\t\t\tif(dp[n-2][i][j]>-1){\n\t\t\t\t\t\tif(min==-1) min=dp[n-2][i][j];\n\t\t\t\t\t\telse min=(dp[n-2][i][j]<min)?dp[n-2][i][j]:min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%ld\\n\",min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX_R (300000000)\n#define min(x,y) ((x<y)?x:y)\ntypedef struct stone{\n\tint x,r;\n}Stone;\nStone p[155][15];\nint xn[155],dp[155][15][80];\nint main(){\n\tint i,j,k,h,n,m,x,y,z,ans;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&xn[i]);\n\t\t\tfor(j=0;j<xn[i];j++){\n\t\t\t\tscanf(\"%d%d\",&p[i][j].x,&p[i][j].r);\n\t\t\t\tfor(k=0;k<=m;k++)dp[i][j][k]=MAX_R;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<xn[0];i++)dp[0][i][0]=0;\n\t\tfor(i=0;i<xn[1];i++)dp[1][i][1]=0;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tfor(h=0;h<=m;h++){\n\t\t\t\tfor(j=0;j<xn[i];j++){\n\t\t\t\t\tfor(k=0;k<xn[i+1];k++){\n\t\t\t\t\t\ty=(p[i][j].r+p[i+1][k].r)*abs(p[i][j].x-p[i+1][k].x);\n\t\t\t\t\t\tdp[i+1][k][h]=min(dp[i+1][k][h],dp[i][j][h]+y);\n\t\t\t\t\t}\n\t\t\t\t\tfor(k=0;k<xn[i+2];k++){\n\t\t\t\t\t\ty=(p[i][j].r+p[i+2][k].r)*abs(p[i][j].x-p[i+2][k].x);\n\t\t\t\t\t\tdp[i+2][k][h+1]=min(dp[i+2][k][h+1],dp[i][j][h]+y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=MAX_R;\n\t\tfor(i=0;i<=m;i++)\n\t\t\tfor(j=0;j<xn[n-1];j++)\n\t\t\t\tans=min(ans,dp[n-1][j][i]);\n\t\tfor(i=0;i<m;i++)\n\t\t\tfor(j=0;j<xn[n-2];j++)\n\t\t\t\tans=min(ans,dp[n-2][j][i]);\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ABS(x) (x<0?(-x):(x))\nstatic int n,map[155][1050]={0};\n\nint SearchRoot(int x, int y, int m){\n\tint i, ret, min=-1;\n\tif((m && y+2 == n+1) || y+1 == n+1) return 0;\n\tfor(i=1;i<=1000;i++){\n\t\tif(map[y+1][i]){\n\t\t\tret = (!y ? 0 : ABS((x-i) * (map[y+1][i] + map[y][x]))) + SearchRoot(i, y+1, m);\n\t\t\tmin = (min<0 || ret<min ? ret : min);\n\t\t}\n\t\tif(map[y+2][i] && m){\n\t\t\tret = (!y ? 0 : ABS((x-i) * (map[y+2][i] + map[y][x]))) + SearchRoot(i, y+2, m-1);\n\t\t\tmin = (min<0 || ret<min ? ret : min);\n\t\t}\n\t}\n\treturn min;\n}\n\nint main(int argc, char *argv[]){\n\tint i,j,m,k,x;\n\t\n\twhile(scanf(\"%d %d \",&n,&m), n){\n\t\tmemset(map, 0, 155*1050);\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d \", &k);\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tscanf(\"%d \", &x);\n\t\t\t\tscanf(\"%d \", &map[i][x]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", SearchRoot(0, 0, m));\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define INF (1000000000)\n\ntypedef struct {\n    int dx;\n    int lev;\n} STONE;\n\nint min(int a, int b)\n{\n    if (a > b){\n        return (b);\n    }\n    return (a);\n}\n\nint danger(STONE a, STONE b)\n{\n    return (abs(a.dx - b.dx) * (a.lev + b.lev));\n}\n\nint main(void)\n{\n    int n, m;\n    int dx, lev;\n    int i, j, k, l;\n    int num[151];\n    STONE info[151][11];\n    static int dp[151][11][75];\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d\", &num[i]);\n            for (j = 0; j < num[i]; j++){\n                scanf(\"%d%d\", &info[i][j].dx, &info[i][j].lev);\n            }\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        memset(dp[0], 0, sizeof(dp[0]));\n        \n        ans = INF;\n        \n        for (i = 0; i <= m; i++){\n            for (j = 1; j < n; j++){\n                for (k = 0; k < num[j]; k++){\n                    for (l = 0; l < num[j - 1]; l++){\n                        if (dp[j][k][i] == -1){\n                            dp[j][k][i] = dp[j - 1][l][i] + danger(info[j][k], info[j - 1][l]);\n                        }\n                        else {\n                            dp[j][k][i] = min(dp[j][k][i], dp[j - 1][l][i] + danger(info[j][k], info[j - 1][l]));\n                        }\n                        if (j == n - 1){\n                            ans = min(ans, dp[j][k][i]);\n                        }\n                    }\n                    if (i != 0 && j >= 2){\n                        for (l = 0; l < num[j - 2]; l++){\n                            if (dp[j][k][i] == -1){\n                                dp[j][k][i] = dp[j - 2][l][i - 1] + danger(info[j][k], info[j - 2][l]);\n                            }\n                            else {\n                                dp[j][k][i] = min(dp[j][k][i], dp[j - 2][l][i - 1] + danger(info[j][k], info[j - 2][l]));\n                            }\n                            if (j == n - 1){\n                                ans = min(ans, dp[j][k][i]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "Kotlin",
    "code": "\ndata class Coordinate(val x:Int, val y:Int)\nabstract class Zone{\n    abstract val dangerLevel:Int\n    abstract val y:Int\n    open fun jumpDanger(other:Zone):Int {\n        return other.jumpDangerIfStone(this)\n    }\n    protected abstract fun jumpDangerIfStone(other:Zone):Int\n}\ndata class Stone(override val y:Int, override val dangerLevel:Int) : Zone(){\n    override fun jumpDangerIfStone(other: Zone): Int {\n        return (dangerLevel + other.dangerLevel) * (y - other.y) * y.compareTo(other.y)\n    }\n}\nobject Land:Zone(){\n    override val dangerLevel: Int = 0\n    override val y:Int = 0\n    override fun jumpDanger(other: Zone):Int = 0\n    override fun jumpDangerIfStone(other: Zone): Int = 0\n}\nfun search(start:Zone, jumpTo:Int, restM:Int, startDanger:Int, memo:Array<Array<Array<Int>>>, stones:Array<out Array<out Zone>>):Unit{\n    if (jumpTo >= stones.size || restM < 0) return\n    stones[jumpTo].filterIndexed{index, zone ->\n        memo[jumpTo][index][restM] > startDanger + start.jumpDanger(zone)\n    }.let {\n        it.forEachIndexed{index, zone ->\n            memo[jumpTo][index][restM] = startDanger + start.jumpDanger(zone)\n        }\n        it.forEachIndexed{index, zone ->\n            search(zone, jumpTo + 1, restM, memo[jumpTo][index][restM], memo, stones)\n            search(zone, jumpTo + 2, restM - 1, memo[jumpTo][index][restM], memo, stones)\n        }\n    }\n}\nfun solve(n:Int, m:Int):Unit {\n    if (n == 0 && m == 0) return\n    val stones: Array<Array<Stone>> = Array(n,{\n        readLine()!!.split(' ').map(String::toInt).toIntArray().let { info ->\n        Array(info.first(), {\n            Stone(info[it * 2 + 1], info[it * 2 + 2])\n        })}\n    })\n    val minDangerMemo = Array(n, {\n        Array(stones[it].size, {\n            Array(m + 1, {Int.MAX_VALUE})\n        })\n    })\n    search(Land, 0, m, 0, minDangerMemo, stones)\n    search(Land, 1, m - 1, 0, minDangerMemo, stones)\n    val a = minDangerMemo[n - 1].mapNotNull{it.min()}.min()\n    val b = minDangerMemo[n - 2].mapNotNull{(1 .. m).map{i -> it[i]}.min()}.min()\n    println(listOf(a,b).filterNotNull().min())\n\n    val (nn, mm) = readLine()!!.split(' ').map(String::toInt)\n    solve(nn, mm)\n}\nfun main(args:Array<String>):Unit{\n    val (n, m) = readLine()!!.split(' ').map(String::toInt)\n    solve(n, m)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.abs\n\nfun main(args:Array<String>):Unit {\n    while (true) {\n        val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val stones = Array(n){\n            val a = readLine()!!.trim().split(' ').map(String::toInt).toIntArray()\n            (1 .. a[0]).map{\n                Stone(a[it * 2 - 1], a[it * 2])\n            }.toTypedArray()\n        }\n        val dangers = stones.map{\n            Array(it.size){Array(m + 1){Int.MAX_VALUE}}\n        }.toTypedArray()\n        for (i in 0 until dangers[0].size){\n            dangers[0][i][m] = 0\n        }\n        if (m > 0) for (i in 0 until dangers[1].size){\n            dangers[1][i][m - 1] = 0\n        }\n        for (line in 1 until n){\n            for (from in 0 until dangers[line - 1].size){\n                for (to in 0 until dangers[line].size){\n                    for (d in 0 .. m){\n                        if (dangers[line][to][d] - stones[line - 1][from].jumpTo(stones[line][to]) > dangers[line - 1][from][d]){\n                            dangers[line][to][d] = dangers[line - 1][from][d] + stones[line - 1][from].jumpTo(stones[line][to])\n                        }\n                    }\n                }\n            }\n            if (line > 1){\n                for (from in 0 until dangers[line - 2].size){\n                    for (to in 0 until dangers[line].size){\n                        for (d in 1 .. m){\n                            if (dangers[line][to][d - 1] - stones[line - 2][from].jumpTo(stones[line][to]) > dangers[line - 2][from][d]){\n                                dangers[line][to][d - 1] = dangers[line - 2][from][d] + stones[line - 2][from].jumpTo(stones[line][to])\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        val l = dangers.takeLast(2)\n        println(\n                minOf(l.first().map{\n                    it.drop(1).min() ?: Int.MAX_VALUE\n                }.min() ?: Int.MAX_VALUE, l.last().map{it.min() ?: Int.MAX_VALUE}.min() ?: Int.MAX_VALUE)\n        )\n    }\n}\ndata class Stone(val x:Int, val danger:Int){\n    fun jumpTo(stone:Stone):Int {\n        return abs(x - stone.x) * (danger + stone.danger)\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n \nclass Main {\n\tstatic final int INF = 2 << 27;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint[] K = new int[n+2];\n\t\t\tint[][] map1 = new int[n+2][];\n\t\t\tint[][] map2 = new int[n+2][];\n\t\t\tint[][][] dp = new int[n+2][][];\n\t\t\tint KMax = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tK[i+1] = sc.nextInt();\n\t\t\t\tKMax = Math.max(K[i+1], KMax);\n\t\t\t\tmap1[i+1] = new int[K[i+1]];\n\t\t\t\tmap2[i+1] = new int[K[i+1]];\n\t\t\t\tfor(int j = 0; j < K[i+1]; j++) {\n\t\t\t\t\tmap2[i+1][j] = sc.nextInt();\n\t\t\t\t\tmap1[i+1][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap1[0] = new int[KMax];\n\t\t\tmap2[0] = new int[KMax];\n\t\t\tmap1[n+1] = new int[KMax];\n\t\t\tmap2[n+1] = new int[KMax];\n\t\t\tfor(int i = 0; i < KMax; i++) {\n\t\t\t\tmap2[0][i] = 0;\n\t\t\t\tmap2[n+1][i] = 0;\n\t\t\t\tmap1[0][i] = i+1;\n\t\t\t\tmap1[n+1][i] = i+1;\n\t\t\t}\n\t\t\tK[0] = KMax;\n\t\t\tK[n+1] = KMax;\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tdp[i] = new int[K[i]][m+1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tfor(int j = 0;j < dp[i].length; j++) {\n\t\t\t\t\tArrays.fill(dp[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < dp[0].length; i++) {\n\t\t\t\tdp[0][i][m] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n+1; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tfor(int k = m; k >= 0; k--) {\n\t\t\t\t\t\tfor(int l = 0; l < dp[i+1].length; l++) {\n\t\t\t\t\t\t\tif(i == 0 || i == n) {\n\t\t\t\t\t\t\t\tdp[i+1][l][k]   = Math.min(0 + dp[i][j][k],dp[i+1][l][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[i+1][l][k]   = Math.min(dp[i+1][l][k], (map1[i][j] + map1[i+1][l])*Math.abs(map2[i][j] - map2[i+1][l]) + dp[i][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i != n && k != 0)\n\t\t\t\t\t\tfor(int l = 0; l < dp[i+2].length; l++) {\n\t\t\t\t\t\t\tif(i == 0 || i == n-1) {\n\t\t\t\t\t\t\t\tdp[i+2][l][k-1]  = Math.min(0 + dp[i][j][k],dp[i+2][l][k-1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[i+2][l][k-1]  = Math.min(dp[i+2][l][k-1], (map1[i][j] + map1[i+2][l])*Math.abs(map2[i][j] - map2[i+2][l]) + dp[i][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = dp[n+1][0][0];\n\t\t\tfor(int i = 0; i < KMax; i++) {\n\t\t\t\tfor(int j = m; j >= 0; j--) {\n\t\t\t\t\tmax = Math.min(max, dp[n+1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\n\t}\n}\n             \n        "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n  static final int MAX_INT = 1 << 30;\n  static final int MAX_N = 150;\n  static final int MAX_K = 10;\n\n  // inner classes\n\n  static class Stone {\n    int id, x, y, d;\n\n    Stone(int id, int x, int y, int d) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.d = d;\n    }\n  }\n\n  static class Qt {\n    int m, id;\n\n    Qt(int m, int id) {\n      this.m = m;\n      this.id = id;\n    }\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      if ((n | m) == 0) break;\n\n      Stone[] stones = new Stone[n * MAX_K];\n      int nst = 0;\n\n      Stone[][] ystones = new Stone[n][MAX_K + 1];\n      int[] nyst = new int[n];\n      Arrays.fill(nyst, 0);\n\n      int max_x = 0;\n\n      for (int y = 0; y < n; y++) {\n        int k = sc.nextInt();\n\n        for (int i = 0; i < k; i++) {\n          int x = sc.nextInt() - 1;\n          int d = sc.nextInt();\n\n          Stone st = new Stone(nst, x, y, d);\n          stones[nst++] = st;\n          ystones[y][nyst[y]++] = st;\n\n          if (max_x <= x) max_x = x + 1;\n        }\n      }\n\n      int min_gdist = MAX_INT;\n      int[][] dists = new int[m + 1][nst];\n      boolean[][] visited = new boolean[m + 1][nst];\n\n      for (int i = 0; i <= m; i++)\n        for (int j = 0; j < nst; j++) {\n          dists[i][j] = MAX_INT;\n          visited[i][j] = false;\n        }\n\n      ArrayList<Qt> q = new ArrayList<Qt>();\n\n      for (int i = 0; i < nyst[0]; i++) {\n        Stone st0 = ystones[0][i];\n        dists[m][st0.id] = 0;\n        visited[m][st0.id] = true;\n        q.add(new Qt(m, st0.id));\n      }\n\n      if (m > 0)\n        for (int i = 0; i < nyst[1]; i++) {\n          Stone st1 = ystones[1][i];\n          dists[m - 1][st1.id] = 0;\n          visited[m - 1][st1.id] = true;\n          q.add(new Qt(m - 1, st1.id));\n        }\n\n      while (! q.isEmpty()) {\n        Qt qu = q.get(0);\n\n        for (int i = 1; i < q.size(); i++) {\n          Qt qi = q.get(i);\n          if (dists[qu.m][qu.id] > dists[qi.m][qi.id])\n            qu = qi;\n        }\n\n        q.remove(qu);\n\n        int mu = qu.m;\n        Stone stu = stones[qu.id];\n\n        if (stu.y >= n - 1 || (mu > 0 && stu.y >= n - 2)) {\n          int gdist = dists[mu][stu.id];\n          if (min_gdist > gdist) min_gdist = gdist;\n          continue;\n        }\n\n        int y1 = stu.y + 1;\n        for (int i = 0; i < nyst[y1]; i++) {\n          Stone stv = ystones[y1][i];\n          int dv =\n            dists[mu][stu.id] + (stu.d + stv.d) * Math.abs(stu.x - stv.x);\n\n          if (dists[mu][stv.id] > dv) {\n            dists[mu][stv.id] = dv;\n            if (! visited[mu][stv.id]) {\n              visited[mu][stv.id] = true;\n              q.add(new Qt(mu, stv.id));\n            }\n          }\n        }\n\n        if (mu > 0) {\n          int y2 = stu.y + 2;\n          int mv = mu - 1;\n\n          for (int i = 0; i < nyst[y2]; i++) {\n            Stone stv = ystones[y2][i];\n            int dv =\n              dists[mu][stu.id] + (stu.d + stv.d) * Math.abs(stu.x - stv.x);\n\n            if (dists[mv][stv.id] > dv) {\n              dists[mv][stv.id] = dv;\n              if (! visited[mv][stv.id]) {\n                visited[mv][stv.id] = true;\n                q.add(new Qt(mv, stv.id));\n              }\n            }\n          }\n        }\n      }\n\n      System.out.println(min_gdist);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint row, x;\n\t\tint pass;\n\t\tint denger;\n\t\t\t\t\n\t\tpublic Walk(int row, int x, int pass, int denger) {\n\t\t\tsuper();\n\t\t\tthis.row = row;\n\t\t\tthis.x = x;\n\t\t\tthis.pass = pass;\n\t\t\tthis.denger = denger;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.denger - arg0.denger;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<Map<Integer, Integer>> list = new ArrayList<Map<Integer, Integer>>();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\t\n\t\t\t\tlist.add(new HashMap<Integer, Integer>());\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int d = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tlist.get(i).put(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\t\tfor(int start : list.get(0).keySet()){\n\t\t\t\tqueue.add(new Walk(0, start, m, 0));\n\t\t\t}\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tif(walk.row == n - 1){\n\t\t\t\t\tSystem.out.println(walk.denger);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int cur_d = list.get(walk.row).get(walk.x);\n\t\t\t\t\n\t\t\t\tfor(Map.Entry<Integer, Integer> entry : list.get(walk.row + 1).entrySet()){\n\t\t\t\t\tqueue.add(new Walk(walk.row + 1, entry.getKey(), walk.pass, walk.denger + (cur_d + entry.getValue()) * Math.abs(walk.x - entry.getKey())));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.pass > 0 && walk.row < n - 2){\n\t\t\t\t\tfor(Map.Entry<Integer, Integer> entry : list.get(walk.row + 2).entrySet()){\n\t\t\t\t\t\tqueue.add(new Walk(walk.row + 2, entry.getKey(), walk.pass - 1, walk.denger + (cur_d + entry.getValue()) * Math.abs(walk.x - entry.getKey())));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 30;\n\t\n\tclass C{\n\t\tint x, d;\n\n\t\tpublic C(int x, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", d=\" + d + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\t//0250 cording\n\t//0319 cording end\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfinal int collength = 10;\n\t\tArrayList<ArrayList<C>> data = new ArrayList<ArrayList<C>>();\n\t\tfinal int MMAX = (150+1)/2 + 1;\n\t\tlong [][][] dp = new long[150][collength][MMAX];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\tdata.clear();\n\t\t\tfor(int i = 0; i < 150; i++){\n\t\t\t\tfor(int j = 0; j < collength; j++){\n\t\t\t\t\tArrays.fill(dp[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxcol = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tdata.add(new ArrayList<C>());\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tdata.get(i).add(new C(x,d));\n\t\t\t\t\tmaxcol = Math.max(maxcol, x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < data.get(0).size(); i++){\n\t\t\t\tdp[0][i][m] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tfor(int j = 0; j < data.get(i).size(); j++){\n\t\t\t\t\tfor(int k = 0; k <= m; k++){\n\t\t\t\t\t\tif(dp[i][j][k] == INF)continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int jumpoffset = 1; jumpoffset <= 2; jumpoffset++){\n\t\t\t\t\t\t\tint nexty= i + jumpoffset;\n\t\t\t\t\t\t\tif(nexty >= n){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint kValue = k - jumpoffset + 1;\n\t\t\t\t\t\t\tif(kValue < 0) continue;\n\t\t\t\t\t\t\tfor(int normalind= 0; normalind < data.get(nexty).size(); normalind++){\n\t\t\t\t\t\t\t\tlong diff = Math.abs(data.get(i).get(j).x - data.get(nexty).get(normalind).x);\n\t\t\t\t\t\t\t\tlong slip = data.get(i).get(j).d + data.get(nexty).get(normalind).d;\n\t\t\t\t\t\t\t\tlong value1 = slip * diff;\n\t\t\t\t\t\t\t\tlong value2 = dp[i][j][k] + value1;\n\t\t\t\t\t\t\t\tdp[nexty][normalind][kValue] = Math.min(dp[nexty][normalind][kValue], value2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong max = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < data.get(n-1).size(); i++){\n\t\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t\tmax = Math.min(max, dp[n-1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < data.get(n-2).size(); i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tmax = Math.min(max, dp[n-2][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ans = \");\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t\t//debug\n\t\t\t\n//\t\t\tfor(int k = 0; k <= m; k++){\n//\t\t\t\tSystem.out.println(\"k= \" + k);\n//\t\t\t\tfor(int i = 0; i < n; i++){\n//\t\t\t\t\tfor(int j = 0; j < data.get(i).size(); j++){\n//\t\t\t\t\t\tSystem.out.print(dp[i][j][k] + \" \");\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[]args){\n\t\tnew Main().doit();\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tList<Point>[] lists = new ArrayList[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tlists[i] = new ArrayList<Point>();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint cost = scanner.nextInt();\n\t\t\t\t\tlists[i - 1].add(new Point(1, x, cost));\n\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\tlists[i - 2].add(new Point(2, x, cost));\n\t\t\t\t\tif (i == n - 1)\n\t\t\t\t\t\tlists[i].add(new Point(2, x, 0));\n\t\t\t\t\tif (i == n)\n\t\t\t\t\t\tlists[i].add(new Point(1, x, 0));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Point> pq = new PriorityQueue<Main.Point>();\n\t\t\tpq.offer(new Point(0, 0, 0, 0, m));\n\t\t\tint[][][] dp = new int[m + 1][n + 2][1001];\n\t\t\tfor (int[][] d : dp)\n\t\t\t\tfor (int[] dd : d)\n\t\t\t\t\tArrays.fill(dd, 1 << 26);\n\t\t\tdp[m][0][0] = 0;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tPoint point = pq.poll();\n\t\t\t\tint y = point.y;\n\t\t\t\tint x = point.x;\n\t\t\t\tint cost = point.cost;\n\t\t\t\tint total = point.total;\n\t\t\t\tint mm = point.m;\n\t\t\t\tif (y >= n) {\n\t\t\t\t\tSystem.out.println(total);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (Point p : lists[y]) {\n\t\t\t\t\tint nc = (cost + p.cost) * Math.abs(x - p.x);\n\t\t\t\t\tif (p.y == 2) {\n\t\t\t\t\t\tif (mm >= 1) {\n\t\t\t\t\t\t\tif (dp[mm - 1][p.y + y][p.x] > nc) {\n\t\t\t\t\t\t\t\tdp[mm - 1][p.y + y][p.x] = nc;\n\t\t\t\t\t\t\t\tpq.offer(new Point(y + p.y, p.x, p.cost,\n\t\t\t\t\t\t\t\t\t\ty == 0 ? 0 : nc + total, mm - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dp[mm][p.y + y][p.x] > nc) {\n\t\t\t\t\t\t\tdp[mm][p.y + y][p.x] = nc;\n\t\t\t\t\t\t\tpq.offer(new Point(y + p.y, p.x, p.cost, y == 0 ? 0\n\t\t\t\t\t\t\t\t\t: nc + total, mm));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Point implements Comparable<Point> {\n\t\tint y, x, cost, total, m;\n\n\t\tpublic Point(int y, int x, int cost, int total, int m) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\t\t\tthis.total = total;\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic Point(int y, int x, int cost) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", cost=\" + cost + \", total=\"\n\t\t\t\t\t+ total + \", m=\" + m + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn this.total - o.total;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\n\t\t\tArrayList<ArrayList<Point>> map = new ArrayList<ArrayList<Point>>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tArrayList<Point> tmp = new ArrayList<Point>();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\ttmp.add(new Point(sc.nextInt()-1,sc.nextInt()));\n\t\t\t\t}\n\t\t\t\tmap.add(tmp);\n\t\t\t}\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\tHashSet<State> closed = new HashSet<State>();\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tif(m < i) continue;\n\t\t\t\tfor(Point p : map.get(i)){\n\t\t\t\t\tState nst = new State(p.x,i,p.y,m-i,0);\n\t\t\t\t\topen.add(nst);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tState ans = null;\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState st = open.poll();\n\t\t\t\tif(closed.contains(st)) continue;\n\t\t\t\tclosed.add(st);\n\n\t\t\t\tif(st.y == n){\n\t\t\t\t\tans = st;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\topen.addAll(st.nexts(map));\n\t\t\t}\n\n\t\t\tSystem.out.println(ans.cost);\n\t\t}\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint x,y,d,rem,cost;\n\n\tState(int x,int y,int d,int rem,int cost){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.d = d;\n\t\tthis.rem = rem;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic List<State> nexts(ArrayList<ArrayList<Point>> map){\n\t\tList<State> sts = new ArrayList<State>();\n\n\t\tfor(int i=1;i<=2;i++){\n\t\t\t//ツ古シツつアツつ、ツ甘敖づ可づつつ「ツつス\n\t\t\tif(y + i >= map.size()){\n\t\t\t\t//1ツ行ツづづ篠つオツづつォツづ按つ「ツ湘ェツ債暗按外ツづづ猟づゥ\n\t\t\t\tif(i == 1 || i == 2 && rem > 0){\n\t\t\t\t\tsts.add(new State(0,map.size(),0,0,cost));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//1ツ行ツづづ篠つオツづつォツづ按つ「ツつゥツづァツ終ツ猟ケ\n\t\t\tif(i == 2 && rem == 0) break;\n\n\t\t\tfor(Point p : map.get(y+i)){\n\t\t\t\tsts.add(new State(p.x,y+i,p.y,rem-(i-1),cost+(d+p.y)*Math.abs(x-p.x)));\n\t\t\t}\n\t\t}\n\n\t\treturn sts;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn x == st.x && y == st.y && rem == st.rem;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn rem * 1000000 + x * 1000 + y;\n\t}\n\n\tpublic String toString(){\n\t\treturn String.format(\"[(%d,%d),c:%d,r:%d]\",x,y,cost,rem);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Map.Entry;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner sc = new FastScanner(System.in);\n\t\tint INF = Integer.MAX_VALUE;\n\t\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\t\n\t\t\tint[][] d = new int[n][10];\n\t\t\tfor(int[] dd : d) Arrays.fill(dd, -1);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\t\tint dj = sc.nextInt();\n\t\t\t\t\td[i][x] = dj;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\tSystem.out.print(\"|\");\n\t\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\t\tif(d[i][j] == -1)\n\t\t\t\t\t\tSystem.out.print(\"  \");\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.print(d[i][j] + \" \");\n\t\t\t\t\tSystem.out.print(\"|\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t*/\n\t\t\t\n\t\t\tint[][][] dp = new int[n][10][m+1];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\t\tfor(int k = 0; k <= m; k++){\n\t\t\t\t\t\tif(i == 0 && k == 0)\n\t\t\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tfor(int from = 0; from < 10; from++){\n\t\t\t\t\tif(d[i][from] == -1) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int num = 0; num <= m; num++){\n\t\t\t\t\t\tif(dp[i][from][num] == INF) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int to = 0; to < 10; to++){\n\t\t\t\t\t\t\tif(d[i+1][to] == -1) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tint cost = (d[i][from] + d[i+1][to]) * Math.abs(from - to);\n\t\t\t\t\t\t\tdp[i+1][to][num] = Math.min(dp[i+1][to][num], dp[i][from][num] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int to = 0; to < 10; to++){\n\t\t\t\t\t\t\tif(i+2 >= n) continue;\n\t\t\t\t\t\t\tif(d[i+2][to] == -1) continue;\n\t\t\t\t\t\t\tif(num+1 > m) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tint cost = (d[i][from] + d[i+2][to]) * Math.abs(from - to);\n\t\t\t\t\t\t\tdp[i+2][to][num+1] = Math.min(dp[i+2][to][num+1], dp[i][from][num] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < 10; i++){\n\t\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t\tans = Math.min(ans, dp[n-1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tStone[][] stones;\n\tint n;\n\tint m;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn= sc.nextInt();\n\t\t\tm =sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tstones = new Stone[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tstones[i] = new Stone[k];\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tstones[i][j] = new Stone(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<stones[0].length;i++) stones[0][i].min[0] = 0;\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tfor(int j=0;j<stones[i].length;j++) {\n\t\t\t\t\tfor(int k=0;k<=m;k++) for(int l=0;l<stones[i-1].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-1][l].min[k] \n\t\t\t\t\t\t                      + abs( stones[i][j].p - stones[i-1][l].p)\n\t\t\t\t\t\t                      * ( stones[i][j].d + stones[i-1][l].d ) );\n\t\t\t\t\t}\n//\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t\tif( i==1 ) break;\n\t\t\t\t\tfor(int k=1;k<=m;k++) for(int l=0;l<stones[i-2].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-2][l].min[k-1] \n\t\t\t\t\t\t                           + abs( stones[i][j].p - stones[i-2][l].p)\n\t\t\t\t\t\t                    \t   * ( stones[i][j].d + stones[i-2][l].d ) );\n\t\t\t\t\t}\n//\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int j=0;j<stones[n-1].length;j++) for(int i=0;i<=m;i++) {\n\t\t\t\tmin = min(min, stones[n-1][j].min[i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tclass Stone {\n\t\tint p;\n\t\tint d;\n\t\tint[] min;\n\t\tStone(int p, int d) {\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t\tmin = new int[m+1];\n\t\t\tfill(min, INF);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 30;\n\t\n\tclass C{\n\t\tint x, d;\n\n\t\tpublic C(int x, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", d=\" + d + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\t//0250 cording\n\t//0319 cording end\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfinal int collength = 10;\n\t\tArrayList<ArrayList<C>> data = new ArrayList<ArrayList<C>>();\n\t\tfinal int MMAX = (150+1)/2 + 1;\n\t\tlong [][][] dp = new long[150][collength][MMAX];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\tdata.clear();\n\t\t\tfor(int i = 0; i < 150; i++){\n\t\t\t\tfor(int j = 0; j < collength; j++){\n\t\t\t\t\tArrays.fill(dp[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxcol = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tdata.add(new ArrayList<C>());\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tdata.get(i).add(new C(x,d));\n\t\t\t\t\tmaxcol = Math.max(maxcol, x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < data.get(0).size(); i++){\n\t\t\t\tdp[0][i][m] = 0;\n\t\t\t}\n\t\t\t//modified\n\t\t\tif(m > 0){\n\t\t\t\tfor(int i = 0; i < data.get(1).size(); i++){\n\t\t\t\t\tdp[1][i][m-1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tfor(int j = 0; j < data.get(i).size(); j++){\n\t\t\t\t\tfor(int k = 0; k <= m; k++){\n\t\t\t\t\t\tif(dp[i][j][k] == INF)continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int jumpoffset = 1; jumpoffset <= 2; jumpoffset++){\n\t\t\t\t\t\t\tint nexty= i + jumpoffset;\n\t\t\t\t\t\t\tif(nexty >= n){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint kValue = k - jumpoffset + 1;\n\t\t\t\t\t\t\tif(kValue < 0) continue;\n\t\t\t\t\t\t\tfor(int normalind= 0; normalind < data.get(nexty).size(); normalind++){\n\t\t\t\t\t\t\t\tlong diff = Math.abs(data.get(i).get(j).x - data.get(nexty).get(normalind).x);\n\t\t\t\t\t\t\t\tlong slip = data.get(i).get(j).d + data.get(nexty).get(normalind).d;\n\t\t\t\t\t\t\t\tlong value1 = slip * diff;\n\t\t\t\t\t\t\t\tlong value2 = dp[i][j][k] + value1;\n\t\t\t\t\t\t\t\tdp[nexty][normalind][kValue] = Math.min(dp[nexty][normalind][kValue], value2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong max = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < data.get(n-1).size(); i++){\n\t\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t\tmax = Math.min(max, dp[n-1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < data.get(n-2).size(); i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tmax = Math.min(max, dp[n-2][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ans = \");\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t\t//debug\n\t\t\t\n//\t\t\tfor(int k = 0; k <= m; k++){\n//\t\t\t\tSystem.out.println(\"k= \" + k);\n//\t\t\t\tfor(int i = 0; i < n; i++){\n//\t\t\t\t\tfor(int j = 0; j < data.get(i).size(); j++){\n//\t\t\t\t\t\tSystem.out.print(dp[i][j][k] + \" \");\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[]args){\n\t\tnew Main().doit();\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t//Scanner scan = new Scanner(new File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0530-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tRiver r = new River(n, m);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint k = scan.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\tr.addStone(i, j, scan.nextInt(), scan.nextInt());\n\t\t\t}\n\t\t\tSystem.out.println(r.min());\n\t\t}\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass River {\n\tprivate class Stones {\n\t\tList<Integer> x = new ArrayList<Integer>();\n\t\tList<Integer> d = new ArrayList<Integer>();\n\t}\n\n\tint M;\n\tStones[] stones;\n\n\tpublic River(int n, int m) {\n\t\tM = m;\n\t\tstones = new Stones[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tstones[i] = new Stones();\n\t}\n\n\tint currLeast = Integer.MAX_VALUE;\n\n\tpublic int min() {\n\t\tfor (int i = 0; i < stones[0].x.size(); i++) {\n\t\t\tint cost = this.jump(0, i, 0, M);\n\t\t\tif (currLeast > cost)\n\t\t\t\tcurrLeast = cost;\n\t\t}\n\t\tif (M > 0)\n\t\t\tfor (int i = 0; i < stones[1].x.size(); i++) {\n\t\t\t\tint cost = this.jump(1, i, 0, M - 1);\n\t\t\t\tif (currLeast > cost)\n\t\t\t\t\tcurrLeast = cost;\n\t\t\t}\n\n\t\treturn currLeast;\n\t}\n\n\tint[][][] result = new int[151][11][76];\n\n\tprivate int jump(int n, int k, int past, int mr) {\n\t\tif ((n >= stones.length - 1) || (n >= stones.length - 2 && mr > 0)) {\n//\t\t\tif (past < currLeast)\n//\t\t\t\tcurrLeast = past;\n\t\t\treturn 0;\n\t\t}\n\t\tif (result[n][k][mr] != 0)\n\t\t\treturn result[n][k][mr];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\tif (past < currLeast) {\n\t\t\tfor (int i = 0; i < stones[n + 1].x.size(); i++) {\n\t\t\t\tint mycost = (stones[n].d.get(k) + stones[n + 1].d.get(i))\n\t\t\t\t\t\t* (stones[n].x.get(k) - stones[n + 1].x.get(i));\n\t\t\t\tmycost = Math.abs(mycost);\n\t\t\t\tint cost = jump(n + 1, i, past + mycost, mr);\n\t\t\t\tif (cost != Integer.MAX_VALUE && cost + mycost < min)\n\t\t\t\t\tmin = cost + mycost;\n\t\t\t}\n\n\t\t\tif (mr > 0 && n < stones.length - 2)\n\t\t\t\tfor (int i = 0; i < stones[n + 2].x.size(); i++) {\n\t\t\t\t\tint mycost = (stones[n].d.get(k) + stones[n + 2].d.get(i))\n\t\t\t\t\t\t\t* (stones[n].x.get(k) - stones[n + 2].x.get(i));\n\t\t\t\t\tmycost = Math.abs(mycost);\n\t\t\t\t\tint cost = jump(n + 2, i, past + mycost, mr - 1);\n\t\t\t\t\tif (cost != Integer.MAX_VALUE && cost + mycost < min)\n\t\t\t\t\t\tmin = cost + mycost;\n\t\t\t\t}\n\t\t}\n\t\tresult[n][k][mr] = min;\n\t\treturn min;\n\t}\n\n\tpublic void addStone(int n, int k, int x, int d) {\n\t\tstones[n].x.add(x);\n\t\tstones[n].d.add(d);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n  static final int MAX_INT = 1 << 30;\n  static final int MAX_N = 150;\n  static final int MAX_K = 10;\n\n  // inner classes\n\n  static class Stone {\n    int id, x, y, d;\n\n    Stone(int id, int x, int y, int d) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.d = d;\n    }\n  }\n\n  static class Qt {\n    int m, id;\n\n    Qt(int m, int id) {\n      this.m = m;\n      this.id = id;\n    }\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      if ((n | m) == 0) break;\n\n      Stone[] stones = new Stone[n * MAX_K];\n      int nst = 0;\n\n      Stone[][] ystones = new Stone[n][MAX_K + 1];\n      int[] nyst = new int[n];\n      Arrays.fill(nyst, 0);\n\n      int max_x = 0;\n\n      for (int y = 0; y < n; y++) {\n        int k = sc.nextInt();\n\n        for (int i = 0; i < k; i++) {\n          int x = sc.nextInt() - 1;\n          int d = sc.nextInt();\n\n          Stone st = new Stone(nst, x, y, d);\n          stones[nst++] = st;\n          ystones[y][nyst[y]++] = st;\n\n          if (max_x <= x) max_x = x + 1;\n        }\n      }\n\n      int min_gdist = MAX_INT;\n      int[][] dists = new int[m + 1][nst];\n      boolean[][] visited = new boolean[m + 1][nst];\n\n      for (int i = 0; i <= m; i++)\n        for (int j = 0; j < nst; j++) {\n          dists[i][j] = MAX_INT;\n          visited[i][j] = false;\n        }\n\n      ArrayList<Qt> q = new ArrayList<Qt>();\n\n      for (int i = 0; i < nyst[0]; i++) {\n        Stone st0 = ystones[0][i];\n        dists[m][st0.id] = 0;\n        visited[m][st0.id] = true;\n        q.add(new Qt(m, st0.id));\n      }\n\n      if (m > 0)\n        for (int i = 0; i < nyst[1]; i++) {\n          Stone st1 = ystones[1][i];\n          dists[m - 1][st1.id] = 0;\n          visited[m - 1][st1.id] = true;\n          q.add(new Qt(m - 1, st1.id));\n        }\n\n      while (! q.isEmpty()) {\n        Qt qu = q.get(0);\n\n        for (int i = 1; i < q.size(); i++) {\n          Qt qi = q.get(i);\n          if (dists[qu.m][qu.id] > dists[qi.m][qi.id])\n            qu = qi;\n        }\n\n        q.remove(qu);\n\n        int mu = qu.m;\n        Stone stu = stones[qu.id];\n\n        int distu = dists[mu][stu.id];\n\n        if (stu.y >= n - 1 || (mu > 0 && stu.y >= n - 2)) {\n          if (min_gdist > distu) min_gdist = distu;\n          continue;\n        }\n\n        if (distu > min_gdist) continue;\n\n        int y1 = stu.y + 1;\n        for (int i = 0; i < nyst[y1]; i++) {\n          Stone stv = ystones[y1][i];\n          int dv = distu + (stu.d + stv.d) * Math.abs(stu.x - stv.x);\n\n          if (dists[mu][stv.id] > dv) {\n            dists[mu][stv.id] = dv;\n            if (! visited[mu][stv.id]) {\n              visited[mu][stv.id] = true;\n              q.add(new Qt(mu, stv.id));\n            }\n          }\n        }\n\n        if (mu > 0) {\n          int y2 = stu.y + 2;\n          int mv = mu - 1;\n\n          for (int i = 0; i < nyst[y2]; i++) {\n            Stone stv = ystones[y2][i];\n            int dv = distu + (stu.d + stv.d) * Math.abs(stu.x - stv.x);\n\n            if (dists[mv][stv.id] > dv) {\n              dists[mv][stv.id] = dv;\n              if (! visited[mv][stv.id]) {\n                visited[mv][stv.id] = true;\n                q.add(new Qt(mv, stv.id));\n              }\n            }\n          }\n        }\n      }\n\n      System.out.println(min_gdist);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static final int INF = 1 << 30;\n\n    public static void main(String[] args)throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            String line[] = br.readLine().split(\" \");\n            int n = Integer.parseInt(line[0]);\n            int m = Integer.parseInt(line[1]);\n            if(n==0){break;}\n\n            int[][][] stone = new int[10][n][2];\n            int[][][] table = new int[10][n][m+1];\n            for(int i=0; i<10; i++){\n                for(int j=1; j<n; j++){\n                    for(int k=0; k<=m; k++){\n                        table[i][j][k] = INF;\n                    }\n                }\n            }\n            if(m > 0){\n                for(int i=0; i<10; i++){\n                    table[i][1][1] = 0;\n                }\n            }\n\n            for (int i=0; i<n; i++){\n                String info[] = br.readLine().split(\" \");\n                int num = Integer.parseInt(info[0]);\n                for(int j=0; j<num; j++){\n                    stone[j][i][0] = Integer.parseInt(info[2*j+1]);\n                    stone[j][i][1] = Integer.parseInt(info[2*j+2]);\n                }\n            }\n\n            for(int k=0; k<=m; k++){\n                for(int j=1; j<n; j++){\n                    for(int i=0; i<10; i++){\n                        if(stone[i][j][0] != 0){\n                            for(int l=0; l<10; l++){\n                                if(stone[l][j-1][1] != 0){\n                                    table[i][j][k] = Math.min(table[i][j][k], ((stone[i][j][1]+stone[l][j-1][1]) * Math.abs(stone[i][j][0]-stone[l][j-1][0])+ table[l][j-1][k]));\n                                }\n                                if(j>1 && k>0){\n                                    if(stone[l][j-2][1] != 0){\n                                        table[i][j][k] = Math.min(table[i][j][k], ((stone[i][j][1]+stone[l][j-2][1]) * Math.abs(stone[i][j][0]-stone[l][j-2][0]) + table[l][j-2][k-1]));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            int answer = INF;\n            for(int i=0; i<10; i++){\n                for(int k=0; k<=m; k++){\n                    if(table[i][n-1][k] != 0){\n                        answer = Math.min(answer,table[i][n-1][k]);\n                    }\n                    if(table[i][n-2][k] != 0){\n                    \tif(k != m){answer = Math.min(answer,table[i][n-2][k]);}\n                    }\n                }\n            }\n            System.out.println(answer);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint row, x;\n\t\tint pass;\n\t\tint denger;\n\t\t\t\t\n\t\tpublic Walk(int row, int x, int pass, int denger) {\n\t\t\tsuper();\n\t\t\tthis.row = row;\n\t\t\tthis.x = x;\n\t\t\tthis.pass = pass;\n\t\t\tthis.denger = denger;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.denger - arg0.denger;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<Map<Integer, Integer>> list = new ArrayList<Map<Integer, Integer>>();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\t\n\t\t\t\tlist.add(new HashMap<Integer, Integer>());\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int d = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tlist.get(i).put(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\t\tfor(int start : list.get(0).keySet()){\n\t\t\t\tqueue.add(new Walk(0, start, m, 0));\n\t\t\t}\n\t\t\tif(m > 0){\n\t\t\t\tfor(int start : list.get(1).keySet()){\n\t\t\t\t\tqueue.add(new Walk(1, start, m - 1, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tif(walk.row == n - 1){\n\t\t\t\t\tSystem.out.println(walk.denger);\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(walk.row == n - 2 && walk.pass > 0){\n\t\t\t\t\tSystem.out.println(walk.denger);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int cur_d = list.get(walk.row).get(walk.x);\n\t\t\t\t\n\t\t\t\tif(walk.row < n - 1){\n\t\t\t\t\tfor(Map.Entry<Integer, Integer> entry : list.get(walk.row + 1).entrySet()){\n\t\t\t\t\t\tqueue.add(new Walk(walk.row + 1, entry.getKey(), walk.pass, walk.denger + (cur_d + entry.getValue()) * Math.abs(walk.x - entry.getKey())));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.pass > 0 && walk.row < n - 2){\n\t\t\t\t\tfor(Map.Entry<Integer, Integer> entry : list.get(walk.row + 2).entrySet()){\n\t\t\t\t\t\tqueue.add(new Walk(walk.row + 2, entry.getKey(), walk.pass - 1, walk.denger + (cur_d + entry.getValue()) * Math.abs(walk.x - entry.getKey())));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1<<30;\n\tStone[][] stones;\n\tint n;\n\tint m;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn= sc.nextInt();\n\t\t\tm =sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tstones = new Stone[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tstones[i] = new Stone[k];\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tstones[i][j] = new Stone(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<stones[0].length;i++) stones[0][i].min[0] = 0;\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tfor(int j=0;j<stones[i].length;j++) {\n\t\t\t\t\tfor(int k=0;k<=m;k++) for(int l=0;l<stones[i-1].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-1][l].min[k] \n\t\t\t\t\t\t                      + abs( stones[i][j].p - stones[i-1][l].p)\n\t\t\t\t\t\t                      * ( stones[i][j].d + stones[i-1][l].d ) );\n\t\t\t\t\t}\n\t\t\t\t\tif( i==1 ) {\n//\t\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=1;k<=m;k++) for(int l=0;l<stones[i-2].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-2][l].min[k-1] \n\t\t\t\t\t\t                           + abs( stones[i][j].p - stones[i-2][l].p)\n\t\t\t\t\t\t                    \t   * ( stones[i][j].d + stones[i-2][l].d ) );\n\t\t\t\t\t}\n//\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int j=0;j<stones[n-1].length;j++) for(int i=0;i<=m;i++) {\n\t\t\t\tmin = min(min, stones[n-1][j].min[i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tclass Stone {\n\t\tint p;\n\t\tint d;\n\t\tint[] min;\n\t\tStone(int p, int d) {\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t\tmin = new int[m+1];\n\t\t\tfill(min, INF);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"unused\")\npublic class Main {\n\t\n\t//final boolean isDebug = true;\n\tfinal boolean isDebug = false;\n\tString fileName = \"input.txt\";\n\tFastScanner sc;\n\tPrintWriter out;\n\tfinal int MOD = (int)1e9+7;\n\t//final int INF = Integer.MAX_VALUE / 2;\n\tfinal long INF = Long.MAX_VALUE / 2;\n\t\n\tvoid solve() throws Exception{\n\t\twhile(true){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tcalc(n, m);\n\t\t}\n\t}\n\t\n\tvoid calc(int n, int m){\n\t\tArrayList<ArrayList<Pair>> list = new ArrayList<>();\n\t\tlong[][][] cost = new long[n][1000][m+1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlist.add(new ArrayList<>());\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x = sc.nextInt(), d = sc.nextInt();\n\t\t\t\tlist.get(i).add(new Pair(x, d));\n\t\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\t\tif(i == 0 && p == 0) cost[i][j][p] = 0;\n\t\t\t\t\telse cost[i][j][p] = Long.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tfor(int j = 0; j < list.get(i).size(); j++){\n\t\t\t\tfor(int k = 0; k < list.get(i+1).size(); k++){\n\t\t\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\t\t\tif(cost[i][j][p] == Long.MAX_VALUE) continue;\n\t\t\t\t\t\tlong d1 = list.get(i).get(j).d, d2 = list.get(i+1).get(k).d;\n\t\t\t\t\t\tint x1 = list.get(i).get(j).x, x2 = list.get(i+1).get(k).x;\n\t\t\t\t\t\tlong c = (d1 + d2) * Math.abs(x2 - x1);\n\t\t\t\t\t\tcost[i+1][k][p] = Math.min(cost[i+1][k][p], cost[i][j][p] + c);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i >= n-2 || p == m) continue;\n\t\t\t\t\t\td2 = list.get(i+2).get(k).d;\n\t\t\t\t\t\tx2 = list.get(i+2).get(k).x;\n\t\t\t\t\t\tc = (d1 + d2) * Math.abs(x2 - x1);\n\t\t\t\t\t\tcost[i+2][k][p+1] = Math.min(cost[i+2][k][p+1], cost[i][j][p] + c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong min = Long.MAX_VALUE;\n\t\tfor(int i = 0; i < list.get(n-2).size(); i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tmin = Math.min(min, cost[n-2][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < list.get(n-1).size(); i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tmin = Math.min(min, cost[n-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\t\n\t/* end solve */\n\t\n\t/* main */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().m();\n\t}\n\t\n\tvoid m() throws Exception {\n\t\tlong S = System.currentTimeMillis();\n\t\tsc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\tif(isDebug){\n\t\t\tSystem.out.println(\"---Debug---\");\n\t\t\tSystem.out.printf(\"%8d ms\\n\", (G-S));\n\t\t}\n\t}\n\t/* end main */\n}\n/* end Main */\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public String nextLine() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(b != 10) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = Integer.MAX_VALUE;\n\tStone[][] stones;\n\tint n;\n\tint m;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn= sc.nextInt();\n\t\t\tm =sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tstones = new Stone[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tstones[i] = new Stone[k];\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tstones[i][j] = new Stone(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<stones[0].length;i++) stones[0][i].min[0] = 0;\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tfor(int j=0;j<stones[i].length;j++) {\n\t\t\t\t\tfor(int k=0;k<=m;k++) for(int l=0;l<stones[i-1].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-1][l].min[k] \n\t\t\t\t\t\t                      + abs( stones[i][j].p - stones[i-1][l].p)\n\t\t\t\t\t\t                      * ( stones[i][j].d + stones[i-1][l].d ) );\n\t\t\t\t\t}\n\t\t\t\t\tif( i==1 ) {\n\t\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=1;k<=m;k++) for(int l=0;l<stones[i-2].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-2][l].min[k-1] \n\t\t\t\t\t\t                           + abs( stones[i][j].p - stones[i-2][l].p)\n\t\t\t\t\t\t                    \t   * ( stones[i][j].d + stones[i-2][l].d ) );\n\t\t\t\t\t}\n\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int j=0;j<stones[n-1].length;j++) for(int i=0;i<=m;i++) {\n\t\t\t\tmin = min(min, stones[n-1][j].min[i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tclass Stone {\n\t\tint p;\n\t\tint d;\n\t\tint[] min;\n\t\tStone(int p, int d) {\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t\tmin = new int[m+1];\n\t\t\tfill(min, INF);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static final int INF = 1 << 31;\n\n\tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString line[] = br.readLine().split(\" \");\n\t\t\tint n = Integer.parseInt(line[0]);\n\t\t\tint m = Integer.parseInt(line[1]);\n\t\t\tif(n==0){break;}\n\n\t\t\tint[][] stone = new int[1000][n+1];\n\t\t\tint[][][] table = new int[1000][n+1][m+1];\n\t\t\tfor(int i=0; i<1000; i++){\n\t\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\t\tfor(int k=0; k<= Math.min((j/2)+1,m); k++){\n\t\t\t\t\t\ttable[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m > 0){\n\t\t\t\tfor(int i=0; i<1000; i++){\n\t\t\t\t\ttable[i][1][1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i=0; i<n; i++){\n\t\t\t\tString info[] = br.readLine().split(\" \");\n\t\t\t\tint num = Integer.parseInt(info[0]);\n\t\t\t\tfor(int j=0; j<num; j++){\n\t\t\t\t\tstone[Integer.parseInt(info[2*j+1])-1][i] = Integer.parseInt(info[2*j+2]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int k=0; k<=m; k++){\n\t\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\t\tfor(int i=0; i<1000; i++){\n\t\t\t\t\t\tif(stone[i][j] != 0 || j==n){\n\t\t\t\t\t\t\tfor(int l=0; l<1000; l++){\n\t\t\t\t\t\t\t\tif(stone[l][j-1] != 0){\n\t\t\t\t\t\t\t\t\ttable[i][j][k] = Math.min(table[i][j][k], ((stone[i][j]+stone[l][j-1]) * Math.abs(i-l)+ table[l][j-1][k]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j>1 && k>0){\n\t\t\t\t\t\t\t\t\tif(stone[l][j-2] != 0){\n\t\t\t\t\t\t\t\t\t\ttable[i][j][k] = Math.min(table[i][j][k], ((stone[i][j]+stone[l][j-2]) * Math.abs(i-l) + table[l][j-2][k-1]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint answer = INF;\n\t\t\tfor(int i=0; i<1000; i++){\n\t\t\t\tfor(int k=0; k<=m; k++){\n\t\t\t\t\tif(table[i][n][k] != 0){\n\t\t\t\t\t\tanswer = Math.min(answer,table[i][n][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\t\n\tclass C{\n\t\tint x, d;\n\n\t\tpublic C(int x, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", d=\" + d + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\t//0250 cording\n\t//0319 cording end\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfinal int collength = 1000;\n\t\tArrayList<ArrayList<C>> data = new ArrayList<ArrayList<C>>();\n\t\tfinal int MMAX = (150+1)/2 + 1;\n\t\tint [][][] dp = new int[150][collength][MMAX];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\tdata.clear();\n\t\t\tfor(int i = 0; i < 150; i++){\n\t\t\t\tfor(int j = 0; j < collength; j++){\n\t\t\t\t\tArrays.fill(dp[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxcol = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tdata.add(new ArrayList<C>());\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tdata.get(i).add(new C(x,d));\n\t\t\t\t\tmaxcol = Math.max(maxcol, x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < data.get(0).size(); i++){\n\t\t\t\tdp[0][i][m] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tfor(int j = 0; j < data.get(i).size(); j++){\n\t\t\t\t\tfor(int k = 0; k <= m; k++){\n\t\t\t\t\t\tif(dp[i][j][k] == INF)continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int jumpoffset = 1; jumpoffset <= 2; jumpoffset++){\n\t\t\t\t\t\t\tint nexty= i + jumpoffset;\n\t\t\t\t\t\t\tif(nexty >= n){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint kValue = k - jumpoffset + 1;\n\t\t\t\t\t\t\tif(kValue < 0) continue;\n\t\t\t\t\t\t\tfor(int normalind= 0; normalind < data.get(nexty).size(); normalind++){\n\t\t\t\t\t\t\t\tint diff = Math.abs(data.get(i).get(j).x - data.get(nexty).get(normalind).x);\n\t\t\t\t\t\t\t\tint slip = data.get(i).get(j).d + data.get(nexty).get(normalind).d;\n\t\t\t\t\t\t\t\tint value1 = slip * diff;\n\t\t\t\t\t\t\t\tint value2 = dp[i][j][k] + value1;\n\t\t\t\t\t\t\t\tint nextx = data.get(nexty).get(normalind).x;\n\t\t\t\t\t\t\t\t//System.out.println(\"debug = \" + value2 + \"slip = \" + slip + \" diff \" + diff + \" nextind1 =\" +nexty +  \" nextind2 =\" + nextx );\n\t\t\t\t\t\t\t\tdp[nexty][normalind][kValue] = Math.min(dp[nexty][normalind][kValue], value2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < data.get(n-1).size(); i++){\n\t\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t\tmax = Math.min(max, dp[n-1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < data.get(n-2).size(); i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tmax = Math.min(max, dp[n-2][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ans = \");\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i = 0; i < n; i++){\n//\t\t\t\tfor(int j = 0; j < data.get(i).size(); j++){\n//\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[]args){\n\t\tnew Main().doit();\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static final int INF = 1 << 30;\n\n    public static void main(String[] args)throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            String line[] = br.readLine().split(\" \");\n            int n = Integer.parseInt(line[0]);\n            int m = Integer.parseInt(line[1]);\n            if(n==0){break;}\n\n            int[][][] stone = new int[10][n][2];\n            int[][][] table = new int[10][n][m+1];\n            for(int i=0; i<10; i++){\n                for(int j=1; j<n; j++){\n                    for(int k=0; k<=m; k++){\n                        table[i][j][k] = INF;\n                    }\n                }\n            }\n            if(m > 0){\n                for(int i=0; i<10; i++){\n                    table[i][1][1] = 0;\n                }\n            }\n\n            for (int i=0; i<n; i++){\n                String info[] = br.readLine().split(\" \");\n                int num = Integer.parseInt(info[0]);\n                for(int j=0; j<num; j++){\n                    stone[j][i][0] = Integer.parseInt(info[2*j+1]);\n                    stone[j][i][1] = Integer.parseInt(info[2*j+2]);\n                }\n            }\n\n            for(int k=0; k<=m; k++){\n                for(int j=1; j<n; j++){\n                    for(int i=0; i<10; i++){\n                        if(stone[i][j][0] != 0 || j==n){\n                            for(int l=0; l<10; l++){\n                                if(stone[l][j-1][0] != 0){\n                                    table[i][j][k] = Math.min(table[i][j][k], ((stone[i][j][1]+stone[l][j-1][1]) * Math.abs(stone[i][j][0]-stone[l][j-1][0])+ table[l][j-1][k]));\n                                }\n                                if(j>1 && k>0){\n                                    if(stone[l][j-2][0] != 0){\n                                        table[i][j][k] = Math.min(table[i][j][k], ((stone[i][j][1]+stone[l][j-2][1]) * Math.abs(stone[i][j][0]-stone[l][j-2][0]) + table[l][j-2][k-1]));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            int answer = INF;\n            for(int i=0; i<10; i++){\n                for(int k=0; k<=m; k++){\n                    if(table[i][n-1][k] != 0){\n                        answer = Math.min(answer,table[i][n-1][k]);\n                    }\n                }\n            }\n            System.out.println(answer);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tList<Point>[] lists = new ArrayList[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tlists[i] = new ArrayList<Point>();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint cost = scanner.nextInt();\n\t\t\t\t\tlists[i - 1].add(new Point(1, x, cost));\n\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\tlists[i - 2].add(new Point(2, x, cost));\n\t\t\t\t\tif (i == n - 1)\n\t\t\t\t\t\tlists[i].add(new Point(2, x, 0));\n\t\t\t\t\tif (i == n)\n\t\t\t\t\t\tlists[i].add(new Point(1, x, 0));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Point> pq = new PriorityQueue<Main.Point>();\n\t\t\tpq.offer(new Point(0, 0, 0, 0, m));\n\t\t\tint[][][] dp = new int[m + 1][n + 1][1001];\n\t\t\tfor (int[][] d : dp)\n\t\t\t\tfor (int[] dd : d)\n\t\t\t\t\tArrays.fill(dd, Integer.MAX_VALUE);\n\t\t\tdp[m][0][0] = 0;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tPoint point = pq.poll();\n\t\t\t\tint y = point.y;\n\t\t\t\tint x = point.x;\n\t\t\t\tint cost = point.cost;\n\t\t\t\tint total = point.total;\n\t\t\t\tint mm = point.m;\n\n\t\t\t\tif (y >= n) {\n\t\t\t\t\tSystem.out.println(total);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (dp[mm][y][x] < total)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (Point p : lists[y]) {\n\t\t\t\t\tint nc = (cost + p.cost) * Math.abs(x - p.x) + total;\n\t\t\t\t\tint ny = Math.min(n, y + p.y);\n\t\t\t\t\tif (p.y == 2) {\n\t\t\t\t\t\tif (mm >= 1) {\n\t\t\t\t\t\t\tif (dp[mm - 1][ny][p.x] > nc) {\n\t\t\t\t\t\t\t\tdp[mm - 1][ny][p.x] = nc;\n\t\t\t\t\t\t\t\tpq.offer(new Point(ny, p.x, p.cost,\n\t\t\t\t\t\t\t\t\t\ty == 0 ? 0 : nc, mm - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dp[mm][ny][p.x] > nc) {\n\t\t\t\t\t\t\tdp[mm][ny][p.x] = nc;\n\t\t\t\t\t\t\tpq.offer(new Point(ny, p.x, p.cost, y == 0 ? 0\n\t\t\t\t\t\t\t\t\t: nc, mm));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Point implements Comparable<Point> {\n\t\tint y, x, cost, total, m;\n\n\t\tpublic Point(int y, int x, int cost, int total, int m) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\t\t\tthis.total = total;\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic Point(int y, int x, int cost) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", cost=\" + cost + \", total=\"\n\t\t\t\t\t+ total + \", m=\" + m + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.total == o.total)\n\t\t\t\treturn o.y - this.y;\n\t\t\treturn this.total - o.total;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Pyon-Pyon River Crossing\npublic class Main{\n\n\tint[][][] dp;\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tint[][] x = new int[n][];\n\t\t\tint[][] a = new int[n][];\n\t\t\tint[] num = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tx[i] = new int[k];\n\t\t\t\ta[i] = new int[k];\n\t\t\t\tnum[i] = k;\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tx[i][j] = sc.nextInt();\n\t\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = new int[n][m+1][];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\t\tdp[i][j] = new int[num[i]];\n\t\t\t\t\tArrays.fill(dp[i][j], 1<<30);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>(){\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dp[o1[0]][o1[1]][o1[2]] - dp[o2[0]][o2[1]][o2[2]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int j=0;j<num[0];j++){\n\t\t\t\tdp[0][m][j] = 0;\n\t\t\t\tq.add(new int[]{0,m,j});\n\t\t\t}\n\t\t\tif(m>0)\n\t\t\t\tfor(int j=0;j<num[1];j++){\n\t\t\t\t\tdp[1][m-1][j] = 0;\n\t\t\t\t\tq.add(new int[]{1,m-1,j});\n\t\t\t\t}\n\t\t\tint min = 1<<30;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] p = q.poll();\n\t\t\t\tint i = p[0];\n\t\t\t\tint rest = p[1];\n\t\t\t\tint pos = p[2];\n\t\t\t\tif(n-1<=i||0<rest&&n-2<=i){\n\t\t\t\t\tmin = Math.min(min, dp[i][rest][pos]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<num[i+1];j++){\n\t\t\t\t\tint v = dp[i][rest][pos] + (a[i][pos]+a[i+1][j])*Math.abs(x[i][pos]-x[i+1][j]);\n\t\t\t\t\tif(v<dp[i+1][rest][j]){\n\t\t\t\t\t\tdp[i+1][rest][j] = v;\n\t\t\t\t\t\tq.add(new int[]{i+1,rest,j});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rest==0)continue;\n\t\t\t\tfor(int j=0;j<num[i+2];j++){\n\t\t\t\t\tint v = dp[i][rest][pos] + (a[i][pos]+a[i+2][j])*Math.abs(x[i][pos]-x[i+2][j]);\n\t\t\t\t\tif(v<dp[i+2][rest-1][j]){\n\t\t\t\t\t\tdp[i+2][rest-1][j] = v;\n\t\t\t\t\t\tq.add(new int[]{i+2,rest-1,j});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString line[] = br.readLine().split(\" \");\n\t\t\tint n = Integer.parseInt(line[0]);\n\t\t\tint m = Integer.parseInt(line[1]);\n\t\t\tif(n==0){break;}\n\n\t\t\tint[][] stone = new int[1000][n+1];\n\t\t\tint[][][] table = new int[1000][n+1][m+1];\n\t\t\tfor(int i=0; i<1000; i++){\n\t\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\t\tfor(int k=0; k<= Math.min((j/2)+1,m); k++){\n\t\t\t\t\t\ttable[i][j][k] = (int)Math.pow(10, 9);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m > 0){\n\t\t\t\tfor(int i=0; i<1000; i++){\n\t\t\t\t\ttable[i][1][1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i=0; i<n; i++){\n\t\t\t\tString info[] = br.readLine().split(\" \");\n\t\t\t\tint num = Integer.parseInt(info[0]);\n\t\t\t\tfor(int j=0; j<num; j++){\n\t\t\t\t\tstone[Integer.parseInt(info[2*j+1])-1][i] = Integer.parseInt(info[2*j+2]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int k=0; k<=m; k++){\n\t\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\t\tfor(int i=0; i<1000; i++){\n\t\t\t\t\t\tif(stone[i][j] != 0 || j==n){\n\t\t\t\t\t\t\tfor(int l=0; l<1000; l++){\n\t\t\t\t\t\t\t\tif(stone[l][j-1] != 0){\n\t\t\t\t\t\t\t\t\ttable[i][j][k] = Math.min(table[i][j][k], ((stone[i][j]+stone[l][j-1]) * Math.abs(i-l)+ table[l][j-1][k]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j>1 && k>0){\n\t\t\t\t\t\t\t\t\tif(stone[l][j-2] != 0){\n\t\t\t\t\t\t\t\t\t\ttable[i][j][k] = Math.min(table[i][j][k], ((stone[i][j]+stone[l][j-2]) * Math.abs(i-l) + table[l][j-2][k-1]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint answer = (int)Math.pow(10, 9);\n\t\t\tfor(int i=0; i<1000; i++){\n\t\t\t\tfor(int k=0; k<=m; k++){\n\t\t\t\t\tif(table[i][n][k] != 0){\n\t\t\t\t\t\tanswer = Math.min(answer,table[i][n][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint row, x;\n\t\tint pass;\n\t\tint denger;\n\t\t\t\t\n\t\tpublic Walk(int row, int x, int pass, int denger) {\n\t\t\tsuper();\n\t\t\tthis.row = row;\n\t\t\tthis.x = x;\n\t\t\tthis.pass = pass;\n\t\t\tthis.denger = denger;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.denger - arg0.denger;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<Map<Integer, Integer>> list = new ArrayList<Map<Integer, Integer>>();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\t\n\t\t\t\tlist.add(new HashMap<Integer, Integer>());\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int d = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tlist.get(i).put(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\t\tfor(int start : list.get(0).keySet()){\n\t\t\t\tqueue.add(new Walk(0, start, m, 0));\n\t\t\t}\n\t\t\tif(m > 0){\n\t\t\t\tfor(int start : list.get(1).keySet()){\n\t\t\t\t\tqueue.add(new Walk(1, start, m - 1, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][][] visited = new boolean[m+1][n][1001];\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tif(visited[walk.pass][walk.row][walk.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisited[walk.pass][walk.row][walk.x] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.row == n - 1){\n\t\t\t\t\tSystem.out.println(walk.denger);\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(walk.row == n - 2 && walk.pass > 0){\n\t\t\t\t\tSystem.out.println(walk.denger);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(walk.row + \" \" + walk.x + \" \" + walk.pass);\n\t\t\t\t\n\t\t\t\tfinal int cur_d = list.get(walk.row).get(walk.x);\n\t\t\t\t\n\t\t\t\tif(walk.row < n - 1){\n\t\t\t\t\tfor(Map.Entry<Integer, Integer> entry : list.get(walk.row + 1).entrySet()){\n\t\t\t\t\t\tif(visited[walk.pass][walk.row + 1][entry.getKey()]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue.add(new Walk(walk.row + 1, entry.getKey(), walk.pass, walk.denger + (cur_d + entry.getValue()) * Math.abs(walk.x - entry.getKey())));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.pass > 0 && walk.row < n - 2){\n\t\t\t\t\tfor(Map.Entry<Integer, Integer> entry : list.get(walk.row + 2).entrySet()){\n\t\t\t\t\t\tif(visited[walk.pass][walk.row + 2][entry.getKey()]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue.add(new Walk(walk.row + 2, entry.getKey(), walk.pass - 1, walk.denger + (cur_d + entry.getValue()) * Math.abs(walk.x - entry.getKey())));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"unused\")\npublic class Main {\n\t\n\t//final boolean isDebug = true;\n\tfinal boolean isDebug = false;\n\tString fileName = \"input.txt\";\n\tFastScanner sc;\n\tPrintWriter out;\n\tfinal int MOD = (int)1e9+7;\n\t//final int INF = Integer.MAX_VALUE / 2;\n\tfinal long INF = Long.MAX_VALUE / 2;\n\t\n\tvoid solve() throws Exception{\n\t\twhile(true){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tcalc(n, m);\n\t\t}\n\t}\n\t\n\tvoid calc(int n, int m){\n\t\tArrayList<ArrayList<Pair>> list = new ArrayList<>();\n\t\tlong[][][] cost = new long[n][1000][m+1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlist.add(new ArrayList<>());\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x = sc.nextInt(), d = sc.nextInt();\n\t\t\t\tlist.get(i).add(new Pair(x, d));\n\t\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\t\tif(i == 0 && p == 0) cost[i][j][p] = 0;\n\t\t\t\t\telse cost[i][j][p] = Long.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tfor(int j = 0; j < list.get(i).size(); j++){\n\t\t\t\tfor(int k = 0; k < list.get(i+1).size(); k++){\n\t\t\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\t\t\tif(cost[i][j][p] == Long.MAX_VALUE) continue;\n\t\t\t\t\t\tlong d1 = list.get(i).get(j).d, d2 = list.get(i+1).get(k).d;\n\t\t\t\t\t\tint x1 = list.get(i).get(j).x, x2 = list.get(i+1).get(k).x;\n\t\t\t\t\t\tlong c = (d1 + d2) * Math.abs(x2 - x1);\n\t\t\t\t\t\tcost[i+1][k][p] = Math.min(cost[i+1][k][p], cost[i][j][p] + c);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i == n-2) continue;\n\t\t\t\tfor(int k = 0; k < list.get(i+2).size(); k++){\n\t\t\t\t\tfor(int p = 0; p < m; p++){\n\t\t\t\t\t\tif(cost[i][j][p] == Long.MAX_VALUE) continue;\n\t\t\t\t\t\tlong d1 = list.get(i).get(j).d, d2 = list.get(i+2).get(k).d;\n\t\t\t\t\t\tint x1 = list.get(i).get(j).x, x2 = list.get(i+2).get(k).x;\n\t\t\t\t\t\tlong c = (d1 + d2) * Math.abs(x2 - x1);\n\t\t\t\t\t\tcost[i+2][k][p+1] = Math.min(cost[i+2][k][p+1], cost[i][j][p] + c);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong min = Long.MAX_VALUE;\n\t\tfor(int i = 0; i < list.get(n-2).size(); i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tmin = Math.min(min, cost[n-2][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < list.get(n-1).size(); i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tmin = Math.min(min, cost[n-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\t\n\t/* end solve */\n\t\n\t/* main */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().m();\n\t}\n\t\n\tvoid m() throws Exception {\n\t\tlong S = System.currentTimeMillis();\n\t\tsc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\tif(isDebug){\n\t\t\tSystem.out.println(\"---Debug---\");\n\t\t\tSystem.out.printf(\"%8d ms\\n\", (G-S));\n\t\t}\n\t}\n\t/* end main */\n}\n/* end Main */\n\nclass Pair{\n\tint x;\n\tlong d;\n\tpublic Pair(int x, long d){this.x = x; this.d = d;}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public String nextLine() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(b != 10) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static final int INF = 1 << 31;\n\n\tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString line[] = br.readLine().split(\" \");\n\t\t\tint n = Integer.parseInt(line[0]);\n\t\t\tint m = Integer.parseInt(line[1]);\n\t\t\tif(n==0){break;}\n\n\t\t\tint[][] stone = new int[1000][n+1];\n\t\t\tint[][][] table = new int[1000][n+1][m+1];\n\n\t\t\tint imax = 0;\n\t\t\tfor (int i=0; i<n; i++){\n\t\t\t\tString info[] = br.readLine().split(\" \");\n\t\t\t\tint num = Integer.parseInt(info[0]);\n\t\t\t\tfor(int j=0; j<num; j++){\n\t\t\t\t\tint im = Integer.parseInt(info[2*j+1])-1;\n\t\t\t\t\tstone[im][i] = Integer.parseInt(info[2*j+2]);\n\t\t\t\t\timax = Math.max(im, imax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0; i<imax + 1; i++){\n\t\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\t\tfor(int k=0; k<= Math.min((j/2)+1,m); k++){\n\t\t\t\t\t\ttable[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m > 0){\n\t\t\t\tfor(int i=0; i<imax + 1; i++){\n\t\t\t\t\ttable[i][1][1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfor(int k=0; k<=m; k++){\n\t\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\t\tfor(int i=0; i<imax + 1; i++){\n\t\t\t\t\t\tif(stone[i][j] != 0 || j==n){\n\t\t\t\t\t\t\tfor(int l=0; l<imax + 1; l++){\n\t\t\t\t\t\t\t\tif(stone[l][j-1] != 0){\n\t\t\t\t\t\t\t\t\ttable[i][j][k] = Math.min(table[i][j][k], ((stone[i][j]+stone[l][j-1]) * Math.abs(i-l)+ table[l][j-1][k]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(j>1 && k>0){\n\t\t\t\t\t\t\t\t\tif(stone[l][j-2] != 0){\n\t\t\t\t\t\t\t\t\t\ttable[i][j][k] = Math.min(table[i][j][k], ((stone[i][j]+stone[l][j-2]) * Math.abs(i-l) + table[l][j-2][k-1]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint answer = INF;\n\t\t\tfor(int i=0; i<imax + 1; i++){\n\t\t\t\tfor(int k=0; k<=m; k++){\n\t\t\t\t\tif(table[i][n][k] != 0){\n\t\t\t\t\t\tanswer = Math.min(answer,table[i][n][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Map.Entry;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner sc = new FastScanner(System.in);\n\t\tint INF = Integer.MAX_VALUE;\n\t\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\t\n\t\t\tint[][] d = new int[n][10];\n\t\t\tfor(int[] dd : d) Arrays.fill(dd, -1);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\t\tint dj = sc.nextInt();\n\t\t\t\t\td[i][x] = dj;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\tSystem.out.print(\"|\");\n\t\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\t\tif(d[i][j] == -1)\n\t\t\t\t\t\tSystem.out.print(\"  \");\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.print(d[i][j] + \" \");\n\t\t\t\t\tSystem.out.print(\"|\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t*/\n\t\t\t\n\t\t\tint[][][] dp = new int[n][10][m+1];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\t\tfor(int k = 0; k <= m; k++){\n\t\t\t\t\t\tif(i == 0 && k == 0)\n\t\t\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tfor(int from = 0; from < 10; from++){\n\t\t\t\t\tif(d[i][from] == -1) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int num = 0; num <= m; num++){\n\t\t\t\t\t\tif(dp[i][from][num] == INF) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int to = 0; to < 10; to++){\n\t\t\t\t\t\t\tif(d[i+1][to] == -1) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tint cost = (d[i][from] + d[i+1][to]) * Math.abs(from - to);\n\t\t\t\t\t\t\tdp[i+1][to][num] = Math.min(dp[i+1][to][num], dp[i][from][num] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int to = 0; to < 10; to++){\n\t\t\t\t\t\t\tif(i+2 >= n) continue;\n\t\t\t\t\t\t\tif(d[i+2][to] == -1) continue;\n\t\t\t\t\t\t\tif(num+1 > m) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tint cost = (d[i][from] + d[i+2][to]) * Math.abs(from - to);\n\t\t\t\t\t\t\tdp[i+2][to][num+1] = Math.min(dp[i+2][to][num+1], dp[i][from][num] + cost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < 10; i++){\n\t\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t\tans = Math.min(ans, dp[n-1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tList<Point>[] lists = new ArrayList[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tlists[i] = new ArrayList<Point>();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint cost = scanner.nextInt();\n\t\t\t\t\tlists[i - 1].add(new Point(1, x, cost));\n\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\tlists[i - 2].add(new Point(2, x, cost));\n\t\t\t\t\tif (i == n - 1)\n\t\t\t\t\t\tlists[i].add(new Point(2, x, 0));\n\t\t\t\t\tif (i == n)\n\t\t\t\t\t\tlists[i].add(new Point(1, x, 0));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Point> pq = new PriorityQueue<Main.Point>();\n\t\t\tpq.offer(new Point(0, 0, 0, 0, m));\n\t\t\tint[][][] dp = new int[m + 1][n + 1][1001];\n\t\t\tfor (int[][] d : dp)\n\t\t\t\tfor (int[] dd : d)\n\t\t\t\t\tArrays.fill(dd, Integer.MAX_VALUE);\n\t\t\tdp[m][0][0] = 0;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tPoint point = pq.poll();\n\t\t\t\tint y = point.y;\n\t\t\t\tint x = point.x;\n\t\t\t\tint cost = point.cost;\n\t\t\t\tint total = point.total;\n\t\t\t\tint mm = point.m;\n\n\t\t\t\tif (y >= n) {\n\t\t\t\t\tSystem.out.println(total);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (dp[mm][y][x] < total)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (Point p : lists[y]) {\n\t\t\t\t\tint nc = (cost + p.cost) * Math.abs(x - p.x) + total;\n\t\t\t\t\tint ny = Math.min(n, y + p.y);\n\t\t\t\t\tif (p.y == 2) {\n\t\t\t\t\t\tif (mm >= 1) {\n\t\t\t\t\t\t\tif (dp[mm - 1][ny][p.x] > nc) {\n\t\t\t\t\t\t\t\tdp[mm - 1][ny][p.x] = nc;\n\t\t\t\t\t\t\t\tpq.offer(new Point(ny, p.x, p.cost, y == 0 ? 0\n\t\t\t\t\t\t\t\t\t\t: nc, mm - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dp[mm][ny][p.x] > nc) {\n\t\t\t\t\t\t\tdp[mm][ny][p.x] = nc;\n\t\t\t\t\t\t\tpq.offer(new Point(ny, p.x, p.cost,\n\t\t\t\t\t\t\t\t\ty == 0 ? 0 : nc, mm));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Point implements Comparable<Point> {\n\t\tint y, x, cost, total, m;\n\n\t\tpublic Point(int y, int x, int cost, int total, int m) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\t\t\tthis.total = total;\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic Point(int y, int x, int cost) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", cost=\" + cost + \", total=\"\n\t\t\t\t\t+ total + \", m=\" + m + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.total == o.total)\n\t\t\t\treturn o.y - this.y;\n\t\t\treturn this.total - o.total;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tList<Point>[] lists = new ArrayList[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tlists[i] = new ArrayList<Point>();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint cost = scanner.nextInt();\n\t\t\t\t\tlists[i - 1].add(new Point(1, x, cost));\n\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\tlists[i - 2].add(new Point(2, x, cost));\n\t\t\t\t\tif (i == n - 1)\n\t\t\t\t\t\tlists[i].add(new Point(2, x, 0));\n\t\t\t\t\tif (i == n)\n\t\t\t\t\t\tlists[i].add(new Point(1, x, 0));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Point> pq = new PriorityQueue<Main.Point>();\n\t\t\tpq.offer(new Point(0, 0, 0, 0, m));\n\t\t\tint[][][] dp = new int[m + 1][n + 1][1001];\n\t\t\tfor (int[][] d : dp)\n\t\t\t\tfor (int[] dd : d)\n\t\t\t\t\tArrays.fill(dd, 1 << 26);\n\t\t\tdp[m][0][0] = 0;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tPoint point = pq.poll();\n\t\t\t\tint y = point.y;\n\t\t\t\tint x = point.x;\n\t\t\t\tint cost = point.cost;\n\t\t\t\tint total = point.total;\n\t\t\t\tint mm = point.m;\n\n\t\t\t\tif (y >= n) {\n\t\t\t\t\tSystem.out.println(total);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (dp[mm][y][x] < total)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (Point p : lists[y]) {\n\t\t\t\t\tint nc = (cost + p.cost) * Math.abs(x - p.x) + total;\n\t\t\t\t\tint ny = Math.min(n, y + p.y);\n\t\t\t\t\tif (p.y == 2) {\n\t\t\t\t\t\tif (mm >= 1) {\n\t\t\t\t\t\t\tif (dp[mm - 1][ny][p.x] > nc) {\n\t\t\t\t\t\t\t\tdp[mm - 1][ny][p.x] = nc;\n\t\t\t\t\t\t\t\tpq.offer(new Point(ny, p.x, p.cost,\n\t\t\t\t\t\t\t\t\t\ty == 0 ? 0 : nc, mm - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dp[mm][ny][p.x] > nc) {\n\t\t\t\t\t\t\tdp[mm][ny][p.x] = nc;\n\t\t\t\t\t\t\tpq.offer(new Point(ny, p.x, p.cost, y == 0 ? 0\n\t\t\t\t\t\t\t\t\t: nc, mm));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Point implements Comparable<Point> {\n\t\tint y, x, cost, total, m;\n\n\t\tpublic Point(int y, int x, int cost, int total, int m) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\t\t\tthis.total = total;\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic Point(int y, int x, int cost) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", cost=\" + cost + \", total=\"\n\t\t\t\t\t+ total + \", m=\" + m + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.total == o.total)\n\t\t\t\treturn o.y - this.y;\n\t\t\treturn this.total - o.total;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n \nclass Main {\n\tstatic final int INF = 2 << 29;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint[] K = new int[n+2];\n\t\t\tint[][] map1 = new int[n+2][];\n\t\t\tint[][] map2 = new int[n+2][];\n\t\t\tint[][][] dp = new int[n+2][][];\n\t\t\tint KMax = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tK[i+1] = sc.nextInt();\n\t\t\t\tKMax = Math.max(K[i+1], KMax);\n\t\t\t\tmap1[i+1] = new int[K[i+1]];\n\t\t\t\tmap2[i+1] = new int[K[i+1]];\n\t\t\t\tfor(int j = 0; j < K[i+1]; j++) {\n\t\t\t\t\tmap2[i+1][j] = sc.nextInt();\n\t\t\t\t\tmap1[i+1][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap1[0] = new int[KMax];\n\t\t\tmap2[0] = new int[KMax];\n\t\t\tmap1[n+1] = new int[KMax];\n\t\t\tmap2[n+1] = new int[KMax];\n\t\t\tfor(int i = 0; i < KMax; i++) {\n\t\t\t\tmap2[0][i] = 0;\n\t\t\t\tmap2[n+1][i] = 0;\n\t\t\t\tmap1[0][i] = i+1;\n\t\t\t\tmap1[n+1][i] = i+1;\n\t\t\t}\n\t\t\tK[0] = KMax;\n\t\t\tK[n+1] = KMax;\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tdp[i] = new int[K[i]][m+1];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n+2; i++) {\n\t\t\t\tfor(int j = 0;j < dp[i].length; j++) {\n\t\t\t\t\tArrays.fill(dp[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < dp[0].length; i++) {\n\t\t\t\tdp[0][i][m] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n+1; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\tfor(int k = m; k >= 0; k--) {\n\t\t\t\t\t\tfor(int l = 0; l < dp[i+1].length; l++) {\n\t\t\t\t\t\t\tif(i == 0 || i == n) {\n\t\t\t\t\t\t\t\tdp[i+1][l][k]   = Math.min(0 + dp[i][j][k],dp[i+1][l][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[i+1][l][k]   = Math.min(dp[i+1][l][k], (map1[i][j] + map1[i+1][l])*Math.abs(map2[i][j] - map2[i+1][l]) + dp[i][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i != n && k != 0)\n\t\t\t\t\t\tfor(int l = 0; l < dp[i+2].length; l++) {\n\t\t\t\t\t\t\tif(i == 0 || i == n-1) {\n\t\t\t\t\t\t\t\tdp[i+2][l][k-1]  = Math.min(0 + dp[i][j][k],dp[i+2][l][k-1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[i+2][l][k-1]  = Math.min(dp[i+2][l][k-1], (map1[i][j] + map1[i+2][l])*Math.abs(map2[i][j] - map2[i+2][l]) + dp[i][j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = dp[n+1][0][0];\n\t\t\tfor(int i = 0; i < KMax; i++) {\n\t\t\t\tfor(int j = m; j >= 0; j--) {\n\t\t\t\t\tmax = Math.min(max, dp[n+1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\n\t}\n}\n             \n        "
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\t// Scanner scan = new Scanner(System.in);\n\t\tScanner scan = new Scanner(new File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0530-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tRiver r = new River(n, m);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint k = scan.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\tr.addStone(i, j, scan.nextInt(), scan.nextInt());\n\t\t\t}\n\t\t\tSystem.out.println(r.min());\n\t\t}\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass River {\n\tprivate class Stones {\n\t\tList<Integer> x = new ArrayList<Integer>();\n\t\tList<Integer> d = new ArrayList<Integer>();\n\t}\n\n\tint M;\n\tStones[] stones;\n\n\tpublic River(int n, int m) {\n\t\tM = m;\n\t\tstones = new Stones[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tstones[i] = new Stones();\n\t}\n\n\tint currLeast = Integer.MAX_VALUE;\n\n\tpublic int min() {\n\t\tfor (int i = 0; i < stones[0].x.size(); i++) {\n\t\t\tint cost = this.jump(0, i, 0, M);\n\t\t\tif (currLeast > cost)\n\t\t\t\tcurrLeast = cost;\n\t\t}\n\t\tif (M > 0)\n\t\t\tfor (int i = 0; i < stones[1].x.size(); i++) {\n\t\t\t\tint cost = this.jump(1, i, 0, M - 1);\n\t\t\t\tif (currLeast > cost)\n\t\t\t\t\tcurrLeast = cost;\n\t\t\t}\n\n\t\treturn currLeast;\n\t}\n\n\tint[][][] result = new int[151][11][76];\n\n\tprivate int jump(int n, int k, int past, int mr) {\n\t\tif ((n >= stones.length - 1) || (n >= stones.length - 2 && mr > 0)) {\n//\t\t\tif (past < currLeast)\n//\t\t\t\tcurrLeast = past;\n\t\t\treturn 0;\n\t\t}\n\t\tif (result[n][k][mr] != 0)\n\t\t\treturn result[n][k][mr];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\tif (past < currLeast) {\n\t\t\tfor (int i = 0; i < stones[n + 1].x.size(); i++) {\n\t\t\t\tint mycost = (stones[n].d.get(k) + stones[n + 1].d.get(i))\n\t\t\t\t\t\t* (stones[n].x.get(k) - stones[n + 1].x.get(i));\n\t\t\t\tmycost = Math.abs(mycost);\n\t\t\t\tint cost = jump(n + 1, i, past + mycost, mr);\n\t\t\t\tif (cost != Integer.MAX_VALUE && cost + mycost < min)\n\t\t\t\t\tmin = cost + mycost;\n\t\t\t}\n\n\t\t\tif (mr > 0 && n < stones.length - 2)\n\t\t\t\tfor (int i = 0; i < stones[n + 2].x.size(); i++) {\n\t\t\t\t\tint mycost = (stones[n].d.get(k) + stones[n + 2].d.get(i))\n\t\t\t\t\t\t\t* (stones[n].x.get(k) - stones[n + 2].x.get(i));\n\t\t\t\t\tmycost = Math.abs(mycost);\n\t\t\t\t\tint cost = jump(n + 2, i, past + mycost, mr - 1);\n\t\t\t\t\tif (cost != Integer.MAX_VALUE && cost + mycost < min)\n\t\t\t\t\t\tmin = cost + mycost;\n\t\t\t\t}\n\t\t}\n\t\tresult[n][k][mr] = min;\n\t\treturn min;\n\t}\n\n\tpublic void addStone(int n, int k, int x, int d) {\n\t\tstones[n].x.add(x);\n\t\tstones[n].d.add(d);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1<<29;\n\tStone[][] stones;\n\tint n;\n\tint m;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn= sc.nextInt();\n\t\t\tm =sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tstones = new Stone[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tstones[i] = new Stone[k];\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tstones[i][j] = new Stone(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<stones[0].length;i++) stones[0][i].min[0] = 0;\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tfor(int j=0;j<stones[i].length;j++) {\n\t\t\t\t\tfor(int k=0;k<=m;k++) for(int l=0;l<stones[i-1].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-1][l].min[k] \n\t\t\t\t\t\t                      + abs( stones[i][j].p - stones[i-1][l].p)\n\t\t\t\t\t\t                      * ( stones[i][j].d + stones[i-1][l].d ) );\n\t\t\t\t\t}\n\t\t\t\t\tif( i==1 ) {\n//\t\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=1;k<=m;k++) for(int l=0;l<stones[i-2].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-2][l].min[k-1] \n\t\t\t\t\t\t                           + abs( stones[i][j].p - stones[i-2][l].p)\n\t\t\t\t\t\t                    \t   * ( stones[i][j].d + stones[i-2][l].d ) );\n\t\t\t\t\t}\n//\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int j=0;j<stones[n-1].length;j++) for(int i=0;i<=m;i++) {\n\t\t\t\tmin = min(min, stones[n-1][j].min[i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tclass Stone {\n\t\tint p;\n\t\tint d;\n\t\tint[] min;\n\t\tStone(int p, int d) {\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t\tmin = new int[m+1];\n\t\t\tfill(min, INF);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint[][] x = new int[N + 2][];\n\t\t\tx[0] = new int[] { 0 };\n\t\t\tx[N + 1] = new int[] { 0 };\n\t\t\tint[][] d = new int[N + 2][];\n\t\t\td[0] = new int[] { 0 };\n\t\t\td[N + 1] = new int[] { 0 };\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tx[i + 1] = new int[k];\n\t\t\t\td[i + 1] = new int[k];\n\t\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\t\tx[i + 1][j] = sc.nextInt();\n\t\t\t\t\td[i + 1][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][][] dp = new int[N + 2][M + 1][];\n\t\t\tfor (int i = 0; i < N + 2; ++i) {\n\t\t\t\tfor (int j = 0; j < M + 1; ++j) {\n\t\t\t\t\tdp[i][j] = new int[x[i].length];\n\t\t\t\t\tArrays.fill(dp[i][j], Integer.MAX_VALUE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[0][0][0] = 0;\n\t\t\tfor (int i = 0; i < N + 1; ++i) {\n\t\t\t\tfor (int j = 0; j <= M; ++j) {\n\t\t\t\t\tfor (int k = 0; k < dp[i][j].length; ++k) {\n\t\t\t\t\t\tif (dp[i][j][k] == Integer.MAX_VALUE) continue;\n\t\t\t\t\t\tfor (int l = 0; l < dp[i + 1][j].length; ++l) {\n\t\t\t\t\t\t\tint nv = dp[i][j][k];\n\t\t\t\t\t\t\tif (i != 0 && i != N) nv += (d[i][k] + d[i + 1][l]) * Math.abs(x[i][k] - x[i + 1][l]);\n\t\t\t\t\t\t\tdp[i + 1][j][l] = Math.min(dp[i + 1][j][l], nv);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < N && j < M) {\n\t\t\t\t\t\t\tfor (int l = 0; l < dp[i + 2][j + 1].length; ++l) {\n\t\t\t\t\t\t\t\tint nv = dp[i][j][k];\n\t\t\t\t\t\t\t\tif (i != 0 && i != N - 1) nv += (d[i][k] + d[i + 2][l]) * Math.abs(x[i][k] - x[i + 2][l]);\n\t\t\t\t\t\t\t\tdp[i + 2][j + 1][l] = Math.min(dp[i + 2][j + 1][l], nv);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i <= M; ++i) {\n\t\t\t\tans = Math.min(dp[N + 1][i][0], ans);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 30;\n\t\n\tclass C{\n\t\tint x, d;\n\n\t\tpublic C(int x, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"C [x=\" + x + \", d=\" + d + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\t//0250 cording\n\t//0319 cording end\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfinal int collength = 1000;\n\t\tArrayList<ArrayList<C>> data = new ArrayList<ArrayList<C>>();\n\t\tfinal int MMAX = (150+1)/2 + 1;\n\t\tlong [][][] dp = new long[150][collength][MMAX];\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\tdata.clear();\n\t\t\tfor(int i = 0; i < 150; i++){\n\t\t\t\tfor(int j = 0; j < collength; j++){\n\t\t\t\t\tArrays.fill(dp[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxcol = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tdata.add(new ArrayList<C>());\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tdata.get(i).add(new C(x,d));\n\t\t\t\t\tmaxcol = Math.max(maxcol, x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < data.get(0).size(); i++){\n\t\t\t\tdp[0][i][m] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tfor(int j = 0; j < data.get(i).size(); j++){\n\t\t\t\t\tfor(int k = 0; k <= m; k++){\n\t\t\t\t\t\tif(dp[i][j][k] == INF)continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int jumpoffset = 1; jumpoffset <= 2; jumpoffset++){\n\t\t\t\t\t\t\tint nexty= i + jumpoffset;\n\t\t\t\t\t\t\tif(nexty >= n){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint kValue = k - jumpoffset + 1;\n\t\t\t\t\t\t\tif(kValue < 0) continue;\n\t\t\t\t\t\t\tfor(int normalind= 0; normalind < data.get(nexty).size(); normalind++){\n\t\t\t\t\t\t\t\tlong diff = Math.abs(data.get(i).get(j).x - data.get(nexty).get(normalind).x);\n\t\t\t\t\t\t\t\tlong slip = data.get(i).get(j).d + data.get(nexty).get(normalind).d;\n\t\t\t\t\t\t\t\tlong value1 = slip * diff;\n\t\t\t\t\t\t\t\tlong value2 = dp[i][j][k] + value1;\n\t\t\t\t\t\t\t\tdp[nexty][normalind][kValue] = Math.min(dp[nexty][normalind][kValue], value2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong max = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < data.get(n-1).size(); i++){\n\t\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t\tmax = Math.min(max, dp[n-1][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < data.get(n-2).size(); i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tmax = Math.min(max, dp[n-2][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ans = \");\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t\t//debug\n\t\t\t\n//\t\t\tfor(int k = 0; k <= m; k++){\n//\t\t\t\tSystem.out.println(\"k= \" + k);\n//\t\t\t\tfor(int i = 0; i < n; i++){\n//\t\t\t\t\tfor(int j = 0; j < data.get(i).size(); j++){\n//\t\t\t\t\t\tSystem.out.print(dp[i][j][k] + \" \");\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[]args){\n\t\tnew Main().doit();\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tList<Point>[] lists = new ArrayList[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tlists[i] = new ArrayList<Point>();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tint cost = scanner.nextInt();\n\t\t\t\t\tlists[i - 1].add(new Point(1, x, cost));\n\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\tlists[i - 2].add(new Point(2, x, cost));\n\t\t\t\t\tif (i == n - 1)\n\t\t\t\t\t\tlists[i].add(new Point(2, x, 0));\n\t\t\t\t\tif (i == n)\n\t\t\t\t\t\tlists[i].add(new Point(1, x, 0));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Point> pq = new PriorityQueue<Main.Point>();\n\t\t\tpq.offer(new Point(0, 0, 0, 0, m));\n\t\t\tint[][][] dp = new int[m + 1][n + 1][1001];\n\t\t\tfor (int[][] d : dp)\n\t\t\t\tfor (int[] dd : d)\n\t\t\t\t\tArrays.fill(dd, Integer.MAX_VALUE);\n\t\t\tdp[m][0][0] = 0;\n\t\t\tloop: while (!pq.isEmpty()) {\n\t\t\t\tPoint point = pq.poll();\n\t\t\t\tint y = point.y;\n\t\t\t\tint x = point.x;\n\t\t\t\tint cost = point.cost;\n\t\t\t\tint total = point.total;\n\t\t\t\tint mm = point.m;\n\n\t\t\t\tif (y >= n) {\n\t\t\t\t\tSystem.out.println(total);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = mm; i <= m; i++)\n\t\t\t\t\tif (dp[i][y][x] < total)\n\t\t\t\t\t\tcontinue loop;\n\t\t\t\tfor (Point p : lists[y]) {\n\t\t\t\t\tint nc = (cost + p.cost) * Math.abs(x - p.x) + total;\n\t\t\t\t\tint ny = Math.min(n, y + p.y);\n\t\t\t\t\tif (p.y == 2) {\n\t\t\t\t\t\tif (mm >= 1) {\n\t\t\t\t\t\t\tif (dp[mm - 1][ny][p.x] > nc) {\n\t\t\t\t\t\t\t\tdp[mm - 1][ny][p.x] = nc;\n\t\t\t\t\t\t\t\tpq.offer(new Point(ny, p.x, p.cost, y == 0 ? 0\n\t\t\t\t\t\t\t\t\t\t: nc, mm - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dp[mm][ny][p.x] > nc) {\n\t\t\t\t\t\t\tdp[mm][ny][p.x] = nc;\n\t\t\t\t\t\t\tpq.offer(new Point(ny, p.x, p.cost,\n\t\t\t\t\t\t\t\t\ty == 0 ? 0 : nc, mm));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Point implements Comparable<Point> {\n\t\tint y, x, cost, total, m;\n\n\t\tpublic Point(int y, int x, int cost, int total, int m) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\t\t\tthis.total = total;\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic Point(int y, int x, int cost) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.cost = cost;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", cost=\" + cost + \", total=\"\n\t\t\t\t\t+ total + \", m=\" + m + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.total == o.total)\n\t\t\t\treturn o.y - this.y;\n\t\t\treturn this.total - o.total;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1<<30;\n\tStone[][] stones;\n\tint n;\n\tint m;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn= sc.nextInt();\n\t\t\tm =sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tstones = new Stone[n+2][];\n\t\t\tfor(int i=1;i<=n;i++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tstones[i] = new Stone[k];\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tint d = sc.nextInt();\n\t\t\t\t\tstones[i][j] = new Stone(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstones[0] = new Stone[stones[1].length + stones[2].length];\n\t\t\tfor(int i=0;i<stones[1].length;i++) {\n\t\t\t\tstones[0][i] = new Stone(stones[1][i].p, stones[1][i].d);\n\t\t\t\tstones[0][i].min[0] = 0;\n\t\t\t}\n\t\t\tfor(int i=0;i<stones[2].length;i++) {\n\t\t\t\tstones[0][i+stones[1].length] = new Stone(stones[2][i].p, stones[2][i].d);\n\t\t\t\tstones[0][i+stones[1].length].min[0] = 0;\n\t\t\t}\n\t\t\tstones[n+1] = new Stone[stones[n].length + stones[n-1].length];\n\t\t\tfor(int i=0;i<stones[n].length;i++) {\n\t\t\t\tstones[n+1][i] = new Stone(stones[n][i].p, stones[n][i].d);\n\t\t\t}\n\t\t\tfor(int i=0;i<stones[n-1].length;i++) {\n\t\t\t\tstones[n+1][i+stones[n].length] = new Stone(stones[n-1][i].p, stones[n-1][i].d);\n\t\t\t}\t\n\t\t\t\t\t\t\n\t\t\tfor(int i=1;i<n+2;i++) {\n\t\t\t\tfor(int j=0;j<stones[i].length;j++) {\n\t\t\t\t\tfor(int k=0;k<=m;k++) for(int l=0;l<stones[i-1].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-1][l].min[k] \n\t\t\t\t\t\t                      + abs( stones[i][j].p - stones[i-1][l].p)\n\t\t\t\t\t\t                      * ( stones[i][j].d + stones[i-1][l].d ) );\n\t\t\t\t\t}\n\t\t\t\t\tif( i==1 ) {\n//\t\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=1;k<=m;k++) for(int l=0;l<stones[i-2].length;l++){\n\t\t\t\t\t\tstones[i][j].min[k] = min( stones[i][j].min[k], stones[i-2][l].min[k-1] \n\t\t\t\t\t\t                           + abs( stones[i][j].p - stones[i-2][l].p)\n\t\t\t\t\t\t                    \t   * ( stones[i][j].d + stones[i-2][l].d ) );\n\t\t\t\t\t}\n//\t\t\t\t\tdebug(stones[i][j].min);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int j=0;j<stones[n+1].length;j++) for(int i=0;i<=m;i++) {\n\t\t\t\tmin = min(min, stones[n+1][j].min[i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tclass Stone {\n\t\tint p;\n\t\tint d;\n\t\tint[] min;\n\t\tStone(int p, int d) {\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t\tmin = new int[m+1];\n\t\t\tfill(min, INF);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1e+9;\ntypedef pair<int, int> P;\n\nint memo[151][11][80];\nint N, M;\nvector<P> G[151];\n\nint rec(int n, int p, int m){\n\tif(memo[n][p][m] != -1)\n\t\treturn memo[n][p][m];\n\t\t\n\tint res = INF;\n\tif(n > N){\n\t\treturn 0;\n\t}\n\tif(n == N){\n\t\tres = min(res, rec(n + 1, p, m));\n\t}\n\tif(n == N - 1 && m >= 1){\n\t\tres = min(res, rec(n + 2, p, m - 1));\n\t}\n\tif(n == 0){\n\t\tfor(int i = 0; i < G[0].size(); ++i){\n\t\t\tres = min(res, rec(n + 1, i, m));\n\t\t}\n\t\tif(m >= 1){\n\t\t\tfor(int i = 0; i < G[1].size(); ++i){\n\t\t\t\tres = min(res, rec(n + 2, i, m - 1));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i = 0; i < G[n].size(); ++i){\n\t\t\tres = min(res, rec(n + 1, i, m) + (G[n - 1][p].second + G[n][i].second) * abs(G[n][i].first - G[n - 1][p].first));\n\t\t}\n\t\tif(n != N - 1 && m >= 1){\n\t\t\tfor(int i = 0; i < G[n + 1].size(); ++i){\n\t\t\t\tres = min(res, rec(n + 2, i, m - 1) + (G[n - 1][p].second + G[n + 1][i].second) * abs(G[n + 1][i].first - G[n - 1][p].first));\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[n][p][m] = res;\n}\n\nint main() {\n\twhile(cin >> N >> M && (N || M)){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor(int i = 0; i <= 150; ++i)\n\t\t\tG[i].clear();\n\t\tint k, d, x;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tscanf(\"%d\", &k);\n\t\t\tfor(int j = 0; j < k; ++j){\n\t\t\t\tscanf(\"%d%d\", &d, &x);\n\t\t\t\tG[i].push_back(P(d, x));\n\t\t\t}\n\t\t}\n\t\tcout << rec(0, 0, M) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n  static final int MAX_INT = 1 << 30;\n\n  // inner classes\n\n  static class Stone {\n    int id, x, y, d;\n\n    Stone(int id, int x, int y, int d) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.d = d;\n    }\n  }\n\n  static class Qt {\n    int m, id;\n\n    Qt(int m, int id) {\n      this.m = m;\n      this.id = id;\n    }\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      if ((n | m) == 0) break;\n\n      ArrayList<Stone> stones = new ArrayList<Stone>();\n      int nst = 0;\n\n      ArrayList<ArrayList<Stone>> ystones =\n        new ArrayList<ArrayList<Stone>>();\n      for (int y = 0; y < n; y++)\n        ystones.add(new ArrayList<Stone>());\n\n      int max_x = 0;\n\n      for (int y = 0; y < n; y++) {\n        int k = sc.nextInt();\n\n        for (int i = 0; i < k; i++) {\n          int x = sc.nextInt() - 1;\n          int d = sc.nextInt();\n\n          Stone st = new Stone(nst, x, y, d);\n          nst++;\n          stones.add(st);\n          ystones.get(y).add(st);\n\n          if (max_x <= x) max_x = x + 1;\n        }\n      }\n\n      int min_gdist = MAX_INT;\n      int[][] dists = new int[m + 1][nst];\n      boolean[][] visited = new boolean[m + 1][nst];\n\n      for (int i = 0; i <= m; i++)\n        for (int j = 0; j < nst; j++) {\n          dists[i][j] = MAX_INT;\n          visited[i][j] = false;\n        }\n\n      ArrayList<Qt> q = new ArrayList<Qt>();\n\n      for (Stone st0: ystones.get(0)) {\n        dists[m][st0.id] = 0;\n        visited[m][st0.id] = true;\n        q.add(new Qt(m, st0.id));\n      }\n\n      if (m > 0)\n        for (Stone st1: ystones.get(1)) {\n          dists[m - 1][st1.id] = 0;\n          visited[m - 1][st1.id] = true;\n          q.add(new Qt(m - 1, st1.id));\n        }\n\n      while (! q.isEmpty()) {\n        Qt qu = q.get(0);\n\n        for (int i = 1; i < q.size(); i++) {\n          Qt qi = q.get(i);\n          if (dists[qu.m][qu.id] > dists[qi.m][qi.id])\n            qu = qi;\n        }\n\n        q.remove(qu);\n\n        int mu = qu.m;\n        Stone stu = stones.get(qu.id);\n\n        if (stu.y >= n - 1 || (mu > 0 && stu.y >= n - 2)) {\n          int gdist = dists[mu][stu.id];\n          if (min_gdist > gdist) min_gdist = gdist;\n          continue;\n        }\n\n        for (Stone stv: ystones.get(stu.y + 1)) {\n          int dv =\n            dists[mu][stu.id] + (stu.d + stv.d) * Math.abs(stu.x - stv.x);\n\n          if (dists[mu][stv.id] > dv) {\n            dists[mu][stv.id] = dv;\n            if (! visited[mu][stv.id]) {\n              visited[mu][stv.id] = true;\n              q.add(new Qt(mu, stv.id));\n            }\n          }\n        }\n\n        if (mu > 0) {\n          int mv = mu - 1;\n\n          for (Stone stv: ystones.get(stu.y + 2)) {\n            int dv =\n              dists[mu][stu.id] + (stu.d + stv.d) * Math.abs(stu.x - stv.x);\n\n            if (dists[mv][stv.id] > dv) {\n              dists[mv][stv.id] = dv;\n              if (! visited[mv][stv.id]) {\n                visited[mv][stv.id] = true;\n                q.add(new Qt(mv, stv.id));\n              }\n            }\n          }\n        }\n      }\n\n      System.out.println(min_gdist);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new File(\"c:\\\\0529-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tRiver r = new River(n, m);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint k = scan.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\t\tr.addStone(i, j, scan.nextInt(), scan.nextInt());\n\t\t\t}\n\t\t\tSystem.out.println(r.min());\n\t\t}\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass River {\n\tprivate class Stones {\n\t\tList<Integer> x = new ArrayList<Integer>();\n\t\tList<Integer> d = new ArrayList<Integer>();\n\t}\n\n\tint M;\n\tStones[] stones;\n\n\tpublic River(int n, int m) {\n\t\tM = m;\n\t\tstones = new Stones[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tstones[i] = new Stones();\n\t}\n\n\tint currLeast = Integer.MAX_VALUE;\n\n\tpublic int min() {\n\t\tfor (int i = 0; i < stones[0].x.size(); i++) {\n\t\t\tint cost = this.jump(0, i, 0, M);\n\t\t\tif (currLeast > cost)\n\t\t\t\tcurrLeast = cost;\n\t\t}\n\t\treturn currLeast;\n\t}\n\n\tprivate int jump(int n, int k, int past, int mr) {\n\t\tif (n >= stones.length - 1)\n\t\t\treturn 0;\n\t\tif (past > currLeast)\n\t\t\treturn Integer.MAX_VALUE;\n\n\t\tint min = Integer.MAX_VALUE;\n\n\t\tfor (int i = 0; i < stones[n + 1].x.size(); i++) {\n\t\t\tint mycost = (stones[n].d.get(k) + stones[n + 1].d.get(i)) * (stones[n].x.get(k) - stones[n + 1].x.get(i));\n\t\t\tmycost = Math.abs(mycost);\n\t\t\tint cost = jump(n + 1, i, past + mycost, mr);\n\t\t\tif (cost != Integer.MAX_VALUE && cost + mycost < min)\n\t\t\t\tmin = cost + mycost;\n\t\t}\n\n\t\tif (mr > 0 && n < stones.length - 2)\n\t\t\tfor (int i = 0; i < stones[n + 2].x.size(); i++) {\n\t\t\t\tint mycost = (stones[n].d.get(k) + stones[n + 2].d.get(i))\n\t\t\t\t\t\t* (stones[n].x.get(k) - stones[n + 2].x.get(i));\n\t\t\t\tmycost = Math.abs(mycost);\n\t\t\t\tint cost = jump(n + 2, i, past + mycost, mr - 1);\n\t\t\t\tif (cost != Integer.MAX_VALUE && cost + mycost < min)\n\t\t\t\t\tmin = cost + mycost;\n\t\t\t}\n\n\t\treturn min;\n\t}\n\n\tpublic void addStone(int n, int k, int x, int d) {\n\t\tstones[n].x.add(x);\n\t\tstones[n].d.add(d);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"unused\")\npublic class Main {\n\t\n\t//final boolean isDebug = true;\n\tfinal boolean isDebug = false;\n\tString fileName = \"input.txt\";\n\tFastScanner sc;\n\tPrintWriter out;\n\tfinal int MOD = (int)1e9+7;\n\t//final int INF = Integer.MAX_VALUE / 2;\n\tfinal long INF = Long.MAX_VALUE / 2;\n\t\n\tvoid solve() throws Exception{\n\t\twhile(true){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tcalc(n, m);\n\t\t}\n\t}\n\t\n\tvoid calc(int n, int m){\n\t\tArrayList<ArrayList<Pair>> list = new ArrayList<>();\n\t\tlong[][][] cost = new long[n][1000][m+1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlist.add(new ArrayList<>());\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x = sc.nextInt(), d = sc.nextInt();\n\t\t\t\tlist.get(i).add(new Pair(x, d));\n\t\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\t\tif(i == 0 && p == 0) cost[i][j][p] = 0;\n\t\t\t\t\telse cost[i][j][p] = Long.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tfor(int j = 0; j < list.get(i).size(); j++){\n\t\t\t\tfor(int k = 0; k < list.get(i+1).size(); k++){\n\t\t\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\t\t\tif(cost[i][j][p] == Long.MAX_VALUE) continue;\n\t\t\t\t\t\tlong d1 = list.get(i).get(j).d, d2 = list.get(i+1).get(k).d;\n\t\t\t\t\t\tint x1 = list.get(i).get(j).x, x2 = list.get(i+1).get(k).x;\n\t\t\t\t\t\tlong c = (d1 + d2) * Math.abs(x2 - x1);\n\t\t\t\t\t\tcost[i+1][k][p] = Math.min(cost[i+1][k][p], cost[i][j][p] + c);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i >= n-2 || p == m) continue;\n\t\t\t\t\t\td2 = list.get(i+2).get(k).d;\n\t\t\t\t\t\tx2 = list.get(i+2).get(k).x;\n\t\t\t\t\t\tc = (d1 + d2) * Math.abs(x2 - x1);\n\t\t\t\t\t\tcost[i+2][k][p+1] = Math.min(cost[i+2][k][p+1], cost[i][j][p] + c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong min = Long.MAX_VALUE;\n\t\tfor(int i = 0; i < list.get(n-2).size(); i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tmin = Math.min(min, cost[n-2][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < list.get(n-1).size(); i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tmin = Math.min(min, cost[n-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\t\n\t/* end solve */\n\t\n\t/* main */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().m();\n\t}\n\t\n\tvoid m() throws Exception {\n\t\tlong S = System.currentTimeMillis();\n\t\tsc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\tif(isDebug){\n\t\t\tSystem.out.println(\"---Debug---\");\n\t\t\tSystem.out.printf(\"%8d ms\\n\", (G-S));\n\t\t}\n\t}\n\t/* end main */\n}\n/* end Main */\n\nclass Pair{\n\tint x;\n\tlong d;\n\tpublic Pair(int x, long d){this.x = x; this.d = d;}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public String nextLine() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(b != 10) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint row, x;\n\t\tint pass;\n\t\tint denger;\n\t\t\t\t\n\t\tpublic Walk(int row, int x, int pass, int denger) {\n\t\t\tsuper();\n\t\t\tthis.row = row;\n\t\t\tthis.x = x;\n\t\t\tthis.pass = pass;\n\t\t\tthis.denger = denger;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.denger - arg0.denger;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<Map<Integer, Integer>> list = new ArrayList<Map<Integer, Integer>>();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\t\n\t\t\t\tlist.add(new HashMap<Integer, Integer>());\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\t\tfinal int d = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tlist.get(i).put(x, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\t\tfor(int start : list.get(0).keySet()){\n\t\t\t\tqueue.add(new Walk(0, start, m, 0));\n\t\t\t}\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tif(walk.row == n - 1){\n\t\t\t\t\tSystem.out.println(walk.denger);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int cur_d = list.get(walk.row).get(walk.x);\n\t\t\t\t\n\t\t\t\tfor(Map.Entry<Integer, Integer> entry : list.get(walk.row + 1).entrySet()){\n\t\t\t\t\tqueue.add(new Walk(walk.row + 1, entry.getKey(), walk.pass, walk.denger + (cur_d + entry.getValue()) * Math.abs(walk.x - entry.getKey())));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.pass > 0 && walk.row < n - 2){\n\t\t\t\t\tfor(Map.Entry<Integer, Integer> entry : list.get(walk.row + 2).entrySet()){\n\t\t\t\t\t\tqueue.add(new Walk(walk.row + 2, entry.getKey(), walk.pass, walk.denger + (cur_d + entry.getValue()) * Math.abs(walk.x - entry.getKey())));\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"unused\")\npublic class Main {\n\t\n\t//final boolean isDebug = true;\n\tfinal boolean isDebug = false;\n\tString fileName = \"input.txt\";\n\tFastScanner sc;\n\tPrintWriter out;\n\tfinal int MOD = (int)1e9+7;\n\t//final int INF = Integer.MAX_VALUE / 2;\n\tfinal long INF = Long.MAX_VALUE / 2;\n\t\n\tvoid solve() throws Exception{\n\t\twhile(true){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tcalc(n, m);\n\t\t}\n\t}\n\t\n\tvoid calc(int n, int m){\n\t\tArrayList<ArrayList<Pair>> list = new ArrayList<>();\n\t\tlong[][][] cost = new long[n][1000][m+1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlist.add(new ArrayList<>());\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x = sc.nextInt(), d = sc.nextInt();\n\t\t\t\tlist.get(i).add(new Pair(x, d));\n\t\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\t\tif((i == 0 && p == 0) || (i == 1 && p == 1)) cost[i][j][p] = 0;\n\t\t\t\t\telse cost[i][j][p] = Long.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tfor(int j = 0; j < list.get(i).size(); j++){\n\t\t\t\tfor(int k = 0; k < list.get(i+1).size(); k++){\n\t\t\t\t\tfor(int p = 0; p <= m; p++){\n\t\t\t\t\t\tif(cost[i][j][p] == Long.MAX_VALUE) continue;\n\t\t\t\t\t\tlong d1 = list.get(i).get(j).d, d2 = list.get(i+1).get(k).d;\n\t\t\t\t\t\tint x1 = list.get(i).get(j).x, x2 = list.get(i+1).get(k).x;\n\t\t\t\t\t\tlong c = (d1 + d2) * Math.abs(x2 - x1);\n\t\t\t\t\t\tcost[i+1][k][p] = Math.min(cost[i+1][k][p], cost[i][j][p] + c);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i == n-2) continue;\n\t\t\t\tfor(int k = 0; k < list.get(i+2).size(); k++){\n\t\t\t\t\tfor(int p = 0; p < m; p++){\n\t\t\t\t\t\tif(cost[i][j][p] == Long.MAX_VALUE) continue;\n\t\t\t\t\t\tlong d1 = list.get(i).get(j).d, d2 = list.get(i+2).get(k).d;\n\t\t\t\t\t\tint x1 = list.get(i).get(j).x, x2 = list.get(i+2).get(k).x;\n\t\t\t\t\t\tlong c = (d1 + d2) * Math.abs(x2 - x1);\n\t\t\t\t\t\tcost[i+2][k][p+1] = Math.min(cost[i+2][k][p+1], cost[i][j][p] + c);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong min = Long.MAX_VALUE;\n\t\tfor(int i = 0; i < list.get(n-2).size(); i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tmin = Math.min(min, cost[n-2][i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < list.get(n-1).size(); i++){\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\tmin = Math.min(min, cost[n-1][i][j]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\t\n\t/* end solve */\n\t\n\t/* main */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().m();\n\t}\n\t\n\tvoid m() throws Exception {\n\t\tlong S = System.currentTimeMillis();\n\t\tsc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\tif(isDebug){\n\t\t\tSystem.out.println(\"---Debug---\");\n\t\t\tSystem.out.printf(\"%8d ms\\n\", (G-S));\n\t\t}\n\t}\n\t/* end main */\n}\n/* end Main */\n\nclass Pair{\n\tint x;\n\tlong d;\n\tpublic Pair(int x, long d){this.x = x; this.d = d;}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public String nextLine() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(b != 10) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\n\nwhile(true){\n   var last=[];\n   var nm=arr.shift().split(\" \").map(Number);\n   if(nm.join(\" \")==\"0 0\")break;\n   var n=nm[0];\n   var m=nm[1];\n   var yx=[];\n   for(var i=0;i<n;i++){\n      var ary=arr.shift().split(\" \").map(Number);\n      var d=ary.shift();\n      var data=[];\n      while(d--)data.push([ary.shift(),ary.shift()]);\n      yx.push(data);\n   }\n   var dp=[];\n   for(var i=0;i<=n;i++){\n      dp[i]=[];\n      for(var j=0;j<=1000;j++){\n         dp[i][j]=[];\n         for(var k=0;k<=m;k++){\n            dp[i][j][k]=Infinity;\n         }\n      }\n   }\n   yx[0].forEach(function(v){\n      var x=v[0];\n      dp[0][x][0]=0;\n   });\n   yx[1].forEach(function(v){\n      var x=v[0];\n      dp[1][x][1]=0;\n   });\n   for(var i=1;i<n;i++){\n      yx[i].forEach(function(v,index){\n         var x=v[0];\n         var value=v[1];\n         yx[i-1].forEach(function(V,INDEX){\n            var X=V[0];\n            var VALUE=V[1];\n            for(var j=0;j<=m;j++){\n               dp[i][x][j]=Math.min(dp[i][x][j],dp[i-1][X][j]+(value+VALUE)*Math.abs(x-X));\n            }\n         });\n      });\n      if(i==n-1){\n      yx[i].forEach(function(v,index){\n         var x=v[0];\n         var value=v[1];\n         yx[i-1].forEach(function(V,INDEX){\n            var X=V[0];\n            var VALUE=V[1];\n            for(var j=0;j<m;j++){\n               dp[i][x][j]=Math.min(dp[i][x][j],dp[i-1][X][j]);\n            }\n         });\n      });\n      }\n      if(i!=n-1){\n      yx[i+1].forEach(function(v,index){\n         var x=v[0];\n         var value=v[1];\n         yx[i-1].forEach(function(V,INDEX){\n            var X=V[0];\n            var VALUE=V[1];\n            for(var j=0;j<m;j++){\n               dp[i+1][x][j+1]=Math.min(dp[i+1][x][j+1],dp[i-1][X][j]+(value+VALUE)*Math.abs(x-X));\n            }\n         });\n      });\n      }\n      \n      if(i==n-1 && yx[i].length==0){\n         var x=0;\n         var value=0;\n         yx[i-1].forEach(function(V,INDEX){\n            var X=V[0];\n            var VALUE=V[1];\n            for(var j=0;j<m;j++){\n               last.push(dp[i-1][X][j]);\n            }\n         });\n      }\n   }\n   var min=Infinity;\n   yx[n-1].forEach(function(v){\n      var x=v[0];\n      for(var j=0;j<=m;j++){\n         min=Math.min(min,dp[n-1][x][j]);\n      }\n   });\n   if(min==Infinity){\n      last.forEach(function(v){\n         min=Math.min(min,v);\n      });\n   }\n   console.log(min);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var nm=arr.shift().split(\" \").map(Number);\n   if(nm.join(\" \")==\"0 0\")break;\n   var n=nm[0];\n   var m=nm[1];\n   var yx=[];\n   for(var i=0;i<n;i++){\n      var ary=arr.shift().split(\" \").map(Number);\n      var d=ary.shift();\n      var data=[];\n      while(d--)data.push([ary.shift(),ary.shift()]);\n      yx.push(data);\n   }\n   var dp=[];\n   for(var i=0;i<=n;i++){\n      dp[i]=[];\n      for(var j=0;j<=1000;j++){\n         dp[i][j]=[];\n         for(var k=0;k<=m;k++){\n            dp[i][j][k]=Infinity;\n         }\n      }\n   }\n   yx[0].forEach(function(v){\n      var x=v[0];\n      dp[0][x][0]=0;\n   });\n   for(var i=1;i<n;i++){\n      yx[i].forEach(function(v,index){\n         var x=v[0];\n         var value=v[1];\n         yx[i-1].forEach(function(V,INDEX){\n            var X=V[0];\n            var VALUE=V[1];\n            for(var j=0;j<=m;j++){\n               dp[i][x][j]=Math.min(dp[i][x][j],dp[i-1][X][j]+(value+VALUE)*Math.abs(x-X));\n            }\n         });\n      });\n      if(i==n-1)continue;\n      yx[i+1].forEach(function(v,index){\n         var x=v[0];\n         var value=v[1];\n         yx[i-1].forEach(function(V,INDEX){\n            var X=V[0];\n            var VALUE=V[1];\n            for(var j=0;j<m;j++){\n               dp[i+1][x][j+1]=Math.min(dp[i][x][j+1],dp[i-1][X][j]+(value+VALUE)*Math.abs(x-X));\n            }\n         });\n      });\n   }\n   var min=Infinity;\n   yx[n-1].forEach(function(v){\n      var x=v[0];\n      for(var j=0;j<=m;j++){\n         min=Math.min(min,dp[n-1][x][j]);\n      }\n   });\n   console.log(min);\n}"
  },
  {
    "language": "Ruby",
    "code": "def rec(i, j, m)\n  return $memo[i][j][m] if $memo[i][j][m] != 100\n\n  res = 1e10\n  return 0 if i+1 >= $stone.size\n  for jj in 0...$stone[i+1].size do\n    add = ($stone[i][j][1]+$stone[i+1][jj][1])*($stone[i][j][0]-$stone[i+1][jj][0]).abs\n    res = [res, rec(i+1, jj, m)+add].min\n  end\n\n  return $memo[i][j][m] = res if (i+2 >= $stone.size) || (m < 1)\n  for jj in 0...$stone[i+2].size do\n    add = ($stone[i][j][1]+$stone[i+2][jj][1])*($stone[i][j][0]-$stone[i+2][jj][0]).abs\n    res = [res, rec(i+2, jj, m)+add].min\n  end\n\n  return $memo[i][j][m] = res\nend\n\nwhile true do\n  n, m = gets.split.map(&:to_i)\n  break if n | m == 0\n  $stone = []\n  n.times do\n    line = gets.split.map(&:to_i)\n    $stone.push(Array.new(line.shift) {line.shift(2)})\n  end\n  $memo = Array.new(n-1) {Array.new(5) {Array.new(m+1, 100)}}\n  2.times {$memo.push(Array.new(5) {Array.new(m+1, 0)})}\n\n  res = 100\n  for j in 0...$stone[0].size do\n    res = [res, rec(0, j, m)].min\n  end\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "def rec(i, j, m)\n  return $memo[i][j][m] if $memo[i][j][m] != 1e10\n\n  res = 1e10\n  return 0 if i+1 >= $stone.size\n  for jj in 0...$stone[i+1].size do\n    add = ($stone[i][j][1]+$stone[i+1][jj][1])*($stone[i][j][0]-$stone[i+1][jj][0]).abs\n    res = [res, rec(i+1, jj, m)+add].min\n  end\n\n  return $memo[i][j][m] = res if (i+2 >= $stone.size) || (m < 1)\n  for jj in 0...$stone[i+2].size do\n    add = ($stone[i][j][1]+$stone[i+2][jj][1])*($stone[i][j][0]-$stone[i+2][jj][0]).abs\n    res = [res, rec(i+2, jj, m-1)+add].min\n  end\n\n  return $memo[i][j][m] = res\nend\n\nwhile true do\n  n, m = gets.split.map(&:to_i)\n  break if n | m == 0\n  $stone = []\n  n.times do\n    line = gets.split.map(&:to_i)\n    $stone.push(Array.new(line.shift) {line.shift(2)})\n  end\n  $memo = Array.new(n-1) {Array.new(1001) {Array.new(m+1, 1e10)}}\n  2.times {$memo.push(Array.new(1001) {Array.new(m+1, 0)})}\n\n  res = 1e10\n  for j in 0...$stone[0].size do\n    res = [res, rec(0, j, m)].min\n  end\n  for j in 0...$stone[1].size do\n    break if m == 0\n    res = [res, rec(1, j, m-1)].min\n  end\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef solve(jump, i)\n  to = (jump == 1) ? i + 1 : i + 2\n  (jump == 1 ? $m + 1 : $m).times do |j|\n    cnt = (jump == 1) ? j : j + 1\n    $s[i].each do |x0, d0|\n      $s[to].each do |x1, d1|\n        v = i == 0 ? 0 : $dp[i][j][x0] + (x0 - x1).abs * (d0 + d1)\n        $dp[to][cnt][x1] = v if $dp[to][cnt][x1] > v\n      end\n    end\n  end\nend\n \nloop do\n  n, $m = gets.split.map(&:to_i)\n  break if n == 0\n  $s = [[[0, 0]], *n.times.map { gets.split.map(&:to_i)[1..-1].each_slice(2).to_a } ]\n  c = $s.flatten(1).transpose[0].max\n  $dp = (n+1).times.map { ($m+1).times.map { [INF] * (c+1) } }\n  ($m+1).times{ |i| $dp[0][i].fill(0) }\n\n  n.times do |i|\n    solve(1, i)\n    break if i == n - 1\n    solve(2, i)\n  end\n  p [*$dp[n-1][0,$m].flatten , *$dp[n][$m].flatten].min\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### main\n\nloop do\n  n, m = gets.strip.split(' ').map{|s| s.to_i}\n  break if (n | m) == 0\n\n  ystones = n.times.map{[]}\n\n  for y in (0...n)\n    ks = gets.strip.split(' ').map{|s| s.to_i}\n    k = ks.shift\n    for i in (0...k)\n      ystones[y] << [ks[2 * i], ks[2 * i + 1]]\n    end\n  end\n  #p stones\n  #p max_x\n\n  dists = (n + 1).times.map{(m + 1).times.map{10.times.map{MAX_INT}}}\n\n  dists[0][m] = 10.times.map{0}\n\n  if m > 0\n    dists[1][m - 1] = 10.times.map{0}\n  end\n\n  for y in (0...(n - 1))\n    ysts0 = ystones[y]\n    ysts1 = ystones[y + 1]\n    ysts2 = ystones[y + 2]\n\n    for m0 in (0..m)\n      for i in (0...ysts0.length)\n        dst0 = dists[y][m0][i]\n        next if dst0 >= MAX_INT\n\n        x0, d0 = ysts0[i]\n\n        for j in (0...ysts1.length)\n          x1, d1 = ysts1[j]\n          dst1 = dst0 + (d0 + d1) * (x1 - x0).abs\n\n          if (dists[y + 1][m0][j] > dst1)\n            dists[y + 1][m0][j] = dst1;\n          end\n        end\n\n        next if m0 == 0 || ysts2.nil?\n\n        m1 = m0 - 1\n\n        for j in (0...ysts2.length)\n          x2, d2 = ysts2[j]\n          dst2 = dst0 + (d0 + d2) * (x2 - x0).abs\n\n          if (dists[y + 2][m1][j] > dst2)\n            dists[y + 2][m1][j] = dst2;\n          end\n        end\n      end\n    end\n  end\n\n  min_gdist = MAX_INT\n\n  for m0 in (0..m)\n    gdist = dists[n - 1][m0].compact.min\n    min_gdist = gdist if min_gdist > gdist\n  end\n\n  for m0 in (1..m)\n    gdist = dists[n - 2][m0].compact.min\n    min_gdist = gdist if min_gdist > gdist\n  end\n\n  puts min_gdist\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  s = [[[0, 0]], *n.times.map { gets.split.map(&:to_i)[1..-1].each_slice(2).to_a } ]\n  ss = s.flatten(1).transpose[0]\n  ss.sort!.uniq!\n  s_index = (n+1).times.map{ [] }\n  (n+1).times do |i|\n    s[i].each do |x, _|\n      s_index[i] << ss.index(x)\n    end\n  end\n\n  dp = (n+1).times.map { (m+1).times.map { [INF] * ss.size } }\n\n  (m+1).times{ |i| dp[0][i].fill(0) }\n  n.times do |i|\n    (m+1).times do |j|\n      s[i].each_with_index do |(x0, d0), k|\n        s[i+1].each_with_index do |(x1, d1), l|\n          v = i == 0 ? 0 : dp[i][j][s_index[i][k]] + (x0 - x1).abs * (d0 + d1)\n          dp[i+1][j][s_index[i+1][l]] = v if dp[i+1][j][s_index[i+1][l]] > v\n        end\n      end\n    end\n    next if i == n - 1\n    m.times do |j|\n      s[i].each_with_index do |(x0, d0), k|\n        s[i+2].each_with_index do |(x1, d1), l|\n          v = i == 0 ? 0 : dp[i][j][s_index[i][k]] + (x0 - x1).abs * (d0 + d1)\n          dp[i+2][j+1][s_index[i+2][l]] = v if dp[i+2][j+1][s_index[i+2][l]] > v\n        end\n      end\n    end\n  end\n  p [*dp[n-1][0,m].flatten , *dp[n][m].flatten].min\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef solve(jump, i)\n  to = (jump == 1) ? i + 1 : i + 2\n  (jump == 1 ? $m + 1 : $m).times do |j|\n    cnt = (jump == 1) ? j : j + 1\n    $s[i].each_with_index do |(x0, d0), k|\n      $s[to].each_with_index do |(x1, d1), l|\n        v = i == 0 ? 0 : $dp[i][j][$s_index[i][k]] + (x0 - x1).abs * (d0 + d1)\n        $dp[to][cnt][$s_index[to][l]] = v if $dp[to][cnt][$s_index[to][l]] > v\n      end\n    end\n  end\nend\n\nloop do\n  n, $m = gets.split.map(&:to_i)\n  break if n == 0\n  $s = [[[0, 0]], *n.times.map { gets.split.map(&:to_i)[1..-1].each_slice(2).to_a } ]\n  ss = $s.flatten(1).transpose[0]\n  ss.sort!.uniq!\n  $s_index = (n+1).times.map{ [] }\n  (n+1).times do |i|\n    $s[i].each do |x, _|\n      $s_index[i] << ss.index(x)\n    end\n  end\n\n  $dp = (n+1).times.map { ($m+1).times.map { [INF] * ss.size } }\n  ($m+1).times{ |i| $dp[0][i].fill(0) }\n\n  n.times do |i|\n    solve(1, i)\n    break if i == n - 1\n    solve(2, i)\n  end\n  p [*$dp[n-1][0,$m].flatten , *$dp[n][$m].flatten].min\nend"
  },
  {
    "language": "Ruby",
    "code": "while true do\n    n, m = gets.split.map(&:to_i)\n    break if n | m == 0\n    dp = []\n    stone = []\n    for i in 0...n do\n        line = gets.split.map(&:to_i)\n        k = line.shift\n        dp.push(Array.new(k) {Array.new(m+1, 1e10)})\n        stone.push(Array.new(k) {line.shift(2)})\n    end\n\n    for i in 0..m do\n        for j in 0...dp[i].size do\n            dp[i][j][m-i] = 0\n        end\n    end\n\n    for i in 0...n do\n        for j in 0...dp[i].size do\n            for k in 0..m do\n\n                next if i+1 >= n\n                for jj in 0...dp[i+1].size do\n                    add = (stone[i+1][jj][1]+stone[i][j][1])*(stone[i+1][jj][0]-stone[i][j][0]).abs\n                    dp[i+1][jj][k] = [dp[i+1][jj][k], dp[i][j][k]+add].min\n                end\n\n                next if (i+2 >= n) || (k-1 < 0)\n                for jj in 0...dp[i+2].size do\n                    add = (stone[i+2][jj][1]+stone[i][j][1])*(stone[i+2][jj][0]-stone[i][j][0]).abs\n                    dp[i+2][jj][k-1] = [dp[i+2][jj][k-1], dp[i][j][k]+add].min\n                end\n\n            end\n        end\n    end\n\n    ans = 1e10\n    for j in 0...dp[n-1].size do\n        ans = dp[n-1][j].min\n    end\n    puts ans\n\nend"
  },
  {
    "language": "Ruby",
    "code": "def rec(i, j, m)\n  return $memo[i][j][m] if $memo[i][j][m] != 1e10\n\n  res = 1e10\n  return 0 if i+1 >= $stone.size\n  for jj in 0...$stone[i+1].size do\n    add = ($stone[i][j][1]+$stone[i+1][jj][1])*($stone[i][j][0]-$stone[i+1][jj][0]).abs\n    res = [res, rec(i+1, jj, m)+add].min\n  end\n\n  return $memo[i][j][m] = res if (i+2 >= $stone.size) || (m < 1)\n  for jj in 0...$stone[i+2].size do\n    add = ($stone[i][j][1]+$stone[i+2][jj][1])*($stone[i][j][0]-$stone[i+2][jj][0]).abs\n    res = [res, rec(i+2, jj, m)+add].min\n  end\n\n  return $memo[i][j][m] = res\nend\n\nwhile true do\n  n, m = gets.split.map(&:to_i)\n  break if n | m == 0\n  $stone = []\n  n.times do\n    line = gets.split.map(&:to_i)\n    $stone.push(Array.new(line.shift) {line.shift(2)})\n  end\n  $memo = Array.new(n-1) {Array.new(1001) {Array.new(m+1, 1e10)}}\n  2.times {$memo.push(Array.new(1001) {Array.new(m+1, 0)})}\n\n  res = 1e10\n  for j in 0...$stone[0].size do\n    res = [res, rec(0, j, m)].min\n  end\n  for j in 0...$stone[1].size do\n    break if m == 0\n    res = [res, rec(1, j, m-1)].min\n  end\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  s = [[[0, 0]], *n.times.map { gets.split.map(&:to_i)[1..-1].each_slice(2).to_a } ]\n\n  c = s.flatten(1).transpose[0].max\n\n  dp = (n+1).times.map { (m+1).times.map { [INF] * (c+1) } }\n  (m+1).times{ |i| dp[0][i].fill(0) }\n\n  n.times do |i|\n    (m+1).times do |j|\n      s[i].each do |k, d0|\n        s[i+1].each do |l, d1|\n          x = i == 0 ? 0 : dp[i][j][k] + (l - k).abs * (d0 + d1)\n          dp[i+1][j][l] = x if dp[i+1][j][l] > x\n        end\n      end\n    end\n    next if i == n - 1\n    m.times do |j|\n      s[i].each do |k, d0|\n        s[i+2].each do |l, d1|\n          x = i == 0 ? 0 : dp[i][j][k] + (l - k).abs * (d0 + d1)\n          dp[i+2][j+1][l] = x if dp[i+2][j+1][l] > x\n        end\n      end\n    end\n  end\n  min = dp[n][m].flatten.min\n  m.times do |i|\n    min = [dp[n-1][i].flatten.min, min].min\n  end\n  p min\nend"
  },
  {
    "language": "Ruby",
    "code": "// Pyon-Pyon River Crossing\n\n// 動的計画法\n\n#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\ntypedef pair<int,int> P;\n#define X first\n#define D second\n\nint main()\n{\n    int n, m;\n    while(cin>>n>>m, n|m) {\n        vector<int> k(n);\n        int dp[150][11][77] = {0};\n        vector< vector<P> > stone(n);\n        for(int i=0; i<n; i++) {\n            cin>>k[i];\n            for(int j=0; j<k[i]; j++) {\n                int x, d;\n                cin>>x>>d;\n                stone[i].push_back(P(x,d));\n            }\n        }\n        for(int i=0; i<n; i++) for(int j=0; j<k[i]; j++) for(int l=0; l<=m; l++) dp[i][j][l] = 1<<30;\n        for(int i=0; i<k[0]; i++) dp[0][i][m] = 0;\n        for(int i=0; i<k[1]; i++) dp[1][i][m-1] = 0;\n\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<k[i]; j++) {\n                for(int l=0; l<=m; l++) {\n\n                    if(i+1>=n) continue;\n                    for(int jj=0; jj<k[i+1]; jj++) {\n                        int add;\n                        add = abs((stone[i+1][jj].D+stone[i][j].D)*(stone[i+1][jj].X-stone[i][j].X));\n                        dp[i+1][jj][l] = min(dp[i+1][jj][l], dp[i][j][l]+add);\n                    }\n\n                    if(i+2>=n) continue;\n                    for(int jj=0; jj<k[i+2]; jj++) {\n                        int add;\n                        add = abs((stone[i+2][jj].D+stone[i][j].D)*(stone[i+2][jj].X-stone[i][j].X));\n                        dp[i+2][jj][l-1] = min(dp[i+2][jj][l-1], dp[i][j][l]+add);\n                    }\n                }\n            }\n        }\n\n        int ans = 1<<30;\n        for(int j=0; j<k[n-1]; j++) {\n            for(int l=0; l<=m; l++) {\n                ans = min(ans, dp[n-1][j][l]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\nn, m = gets.split.map(&:to_i)\ns = n.times.map { gets.split.map(&:to_i)[1..-1].each_slice(2).to_a }\nc = s.flatten(1).transpose[0].max\n\ndp = (n+1).times.map { (m+1).times.map { [INF] * (c+1) } }\n(m+1).times{ |i| dp[0][i].fill(0) }\n\n(n-1).times do |i|\n  (m+1).times do |j|\n    s[i].each do |k, d0|\n      s[i+1].each do |l, d1|\n        x = dp[i][j][k] + (l - k).abs * (d0 + d1)\n        dp[i+1][j][l] = x if dp[i+1][j][l] > x\n      end\n    end\n  end\n  next if i == n - 2\n  m.times do |j|\n    s[i].each do |k, d0|\n      s[i+2].each do |l, d1|\n        x = dp[i][j][k] + (l - k).abs * (d0 + d1)\n        dp[i+2][j+1][l] = x if dp[i+2][j+1][l] > x\n      end\n    end\n  end\nend\np dp[n-1,2].flatten.min"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### main\n\nloop do\n  n, m = gets.strip.split(' ').map{|s| s.to_i}\n  break if (n | m) == 0\n\n  stones = []\n  nst = 0\n  ystones = n.times.map{[]}\n  max_x = 0\n\n  for y in (0...n)\n    ks = gets.strip.split(' ').map{|s| s.to_i}\n    k = ks.shift\n    for i in (0...k)\n      x = ks[2 * i] - 1\n      st = [nst, x, y, ks[2 * i + 1]]\n      nst += 1\n      stones << st\n      ystones[y] << st\n      max_x = x + 1 if max_x <= x\n    end\n  end\n  #p stones\n  #p max_x\n\n  edges1 = nst.times.map{[]}\n  edges2 = nst.times.map{[]}\n\n  for y in (0...(n - 1))\n    for st0 in ystones[y]\n      id0, x0, y0, d0 = st0\n      for st1 in ystones[y + 1]\n        id1, x1, y1, d1 = st1\n        edges1[id0][id1] = (d0 + d1) * (x1 - x0).abs\n      end\n\n      next if y + 2 >= n\n      for st2 in ystones[y + 2]\n        id2, x2, y2, d2 = st2\n        edges2[id0][id2] = (d0 + d2) * (x2 - x0).abs\n      end\n    end\n  end\n  #p edges1\n  #p edges2\n\n  min_gdist = MAX_INT\n  dists = (m + 1).times.map{nst.times.map{MAX_INT}}\n  visited = (m + 1).times.map{nst.times.map{false}}\n  q = []\n\n  for st0 in ystones[0]\n    dists[m][st0[0]] = 0\n    visited[m][st0[0]] = true\n    q << [m, st0[0]]\n  end\n\n  if m > 0\n    for st1 in ystones[1]\n      dists[m - 1][st1[0]] = 0\n    visited[m - 1][st1[0]] = true\n      q << [m - 1, st1[0]]\n    end\n  end\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a[0]][a[1]] <=> dists[b[0]][b[1]]}\n    q.delete u\n\n    m0 = u[0]\n    id0, x0, y0 = stones[u[1]]\n\n    if y0 >= n - 1 || (m0 > 0 && y0 >= n - 2)\n      gdist = dists[m0][id0]\n      min_gdist = gdist if min_gdist > gdist\n      next\n    end\n\n    for v in ystones[y0 + 1]\n      id1, x1, y1 = v\n      dv = dists[m0][id0] + edges1[id0][id1]\n      if dists[m0][id1] > dv\n        dists[m0][id1] = dv\n        if ! visited[m0][id1]\n          visited[m0][id1] = true\n          q << [m0, id1]\n        end\n      end\n    end\n\n    next if m0 == 0\n\n    for v in ystones[y0 + 2]\n      id2, x2, y2 = v\n      m1 = m0 - 1\n      dv = dists[m0][id0] + edges2[id0][id2]\n      if dists[m1][id2] > dv\n        dists[m1][id2] = dv\n        if ! visited[m1][id2]\n          visited[m1][id2] = true\n          q << [m1, id2]\n        end\n      end\n    end\n  end\n\n  puts min_gdist\nend"
  },
  {
    "language": "Ruby",
    "code": "def rec(i, j, m)\n  return $memo[i][j][m] if $memo[i][j][m] != 1e10\n\n  res = 1e10\n  return 0 if i+1 >= $stone.size\n  for jj in 0...$stone[i+1].size do\n    add = ($stone[i][j][1]+$stone[i+1][jj][1])*($stone[i][j][0]-$stone[i+1][jj][0]).abs\n    res = [res, rec(i+1, jj, m)+add].min\n  end\n\n  return $memo[i][j][m] = res if (i+2 >= $stone.size) || (m < 1)\n  for jj in 0...$stone[i+2].size do\n    add = ($stone[i][j][1]+$stone[i+2][jj][1])*($stone[i][j][0]-$stone[i+2][jj][0]).abs\n    res = [res, rec(i+2, jj, m)+add].min\n  end\n\n  return $memo[i][j][m] = res\nend\n\nwhile true do\n  n, m = gets.split.map(&:to_i)\n  break if n | m == 0\n  $stone = []\n  n.times do\n    line = gets.split.map(&:to_i)\n    $stone.push(Array.new(line.shift) {line.shift(2)})\n  end\n  $memo = Array.new(n-1) {Array.new(1001) {Array.new(m+1, 1e10)}}\n  2.times {$memo.push(Array.new(1001) {Array.new(m+1, 0)})}\n\n  res = 1e10\n  for j in 0...$stone[0].size do\n    res = [res, rec(0, j, m)].min\n  end\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "while true do\n    n, m = gets.split.map(&:to_i)\n    break if n | m == 0\n    dp = []\n    stone = []\n    for i in 0...n do\n        line = gets.split.map(&:to_i)\n        k = line.shift\n        dp.push(Array.new(k) {Array.new(m+1, 1e10)})\n        stone.push(Array.new(k) {line.shift(2)})\n    end\n\n    for i in 0..m do\n        for j in 0...dp[i].size do\n            dp[i][j][m-i] = 0\n        end\n    end\n\n    for i in 0...n do\n        for j in 0...dp[i].size do\n            for k in 0..m do\n\n                next if i+1 >= n\n                for jj in 0...dp[i+1].size do\n                    add = (stone[i+1][jj][1]+stone[i][j][1])*(stone[i+1][jj][0]-stone[i][j][0]).abs\n                    dp[i+1][jj][k] = [dp[i+1][jj][k], dp[i][j][k]+add].min\n                end\n\n                next if (i+2 >= n) || (k-1 < 0)\n                for jj in 0...dp[i+2].size do\n                    add = (stone[i+2][jj][1]+stone[i][j][1])*(stone[i+2][jj][0]-stone[i][j][0]).abs\n                    dp[i+2][jj][k-1] = [dp[i+2][jj][k-1], dp[i][j][k]+add].min\n                end\n\n            end\n        end\n    end\n\n    puts dp[n-1].min.min\n\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  s = [[[0, 0]], *n.times.map { gets.split.map(&:to_i)[1..-1].each_slice(2).to_a } ]\n\n  c = s.flatten(1).transpose[0].max\n\n  dp = (n+1).times.map { (m+1).times.map { [INF] * (c+1) } }\n  (m+1).times{ |i| dp[0][i].fill(0) }\n\n  n.times do |i|\n    (m+1).times do |j|\n      s[i].each do |k, d0|\n        s[i+1].each do |l, d1|\n          x = i == 0 ? 0 : dp[i][j][k] + (l - k).abs * (d0 + d1)\n          dp[i+1][j][l] = x if dp[i+1][j][l] > x\n        end\n      end\n    end\n    next if i == n - 1\n    m.times do |j|\n      s[i].each do |k, d0|\n        s[i+2].each do |l, d1|\n          x = i == 0 ? 0 : dp[i][j][k] + (l - k).abs * (d0 + d1)\n          dp[i+2][j+1][l] = x if dp[i+2][j+1][l] > x\n        end\n      end\n    end\n  end\n  p dp[n-1,2].flatten.min\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct P {\n    int x, d;\n}\n\nvoid main() {\n    int n, m;\n    while (scanf(\"%d %d\\n\", &n, &m), n || m) {\n        P[][] g = new P[][n];\n        foreach (i; 0 .. n) {\n            int k; scanf(\"%d\", &k);\n            foreach (j; 0 .. k) {\n                int x, d; scanf(\" %d %d\", &x, &d);\n                g[i] ~= P(x, d);\n            }\n        }\n        int cache[150][10][100]; memset(cast(void*)cache, -1, cache.sizeof);\n        int dfs(int y, int i, int m) {\n            if (y == n) return 0;\n            if (y == n - 1) return 0;\n            if (cache[y][i][m] >= 0) return cache[y][i][m];\n            int r = int.max;\n            P c = g[y][i];\n            if (m >= 1) {\n                if (y + 2 == n) {\n                    return 0;\n                } else {\n                    foreach (int j, s; g[y + 2]) {\n                        r = min(r, abs(s.x - c.x) * (s.d + c.d) + dfs(y + 2, j, m - 1));\n                    }\n                }\n            }\n            foreach (int j, s; g[y + 1]) {\n                r = min(r, abs(s.x - c.x) * (s.d + c.d) + dfs(y + 1, j, m));\n            }\n            return cache[y][i][m] = r;\n        }\n        int ans = int.max;\n        if (m >= 1) {\n            foreach (int i, _; g[1]) {\n                ans = min(ans, dfs(1, i, m - 1));\n            }\n        }\n        foreach (int i, _; g[0]) {\n            ans = min(ans, dfs(0, i, m));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def calc(now,nx,w):\n    return (now+nx)*abs(w)\nwhile 1:\n    n,m=map(int,raw_input().split())\n    if n==m==0:break\n\n    isi=[[0]*11]+[[float('inf')]*11 for _ in xrange(n)]+[[0]*11]\n    for i in xrange(1,n+1):\n        en=map(int,raw_input().split())\n        num=en[0]\n        for j in xrange(num):\n            isi[i][en[j*2+1]]=en[j*2+2]\n\n    dp=[[[float('inf')]*(m+1) for _ in xrange(11)] for _ in xrange(n+2)]\n    for j in xrange(11):\n        dp[0][j][0]=0\n\n    for i in xrange(n+1):\n        for j in xrange(1,11):\n            for k in xrange(m+1):\n                for l in xrange(1,11):\n                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][l][k]+calc(isi[i][l],isi[i+1][j],j-l))\n                    if i-1>=0 and k>=1:\n                        dp[i+1][j][k]=min(dp[i+1][j][k],dp[i-1][l][k-1]+calc(isi[i-1][l],isi[i+1][j],j-l))\n\n    ans=float('inf')\n    for j in xrange(11):\n        ans=min(ans,dp[n+1][j][m])\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "INF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n \ndef dfs(x, y, m):\n    if y > N :\n        return 0\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n \nwhile True:\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    mem = [[[INF for i in range(M + 1)] for j in range(N + 1)] for k in range(N + 4)]\n    import sys\n    sys.stdout.write(str((dfs(0, 0, M))) + \"\\n\")"
  },
  {
    "language": "Python",
    "code": "import sys \nsys.setrecursionlimit(100000)\nINF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n\ndef dfs(x, y, m):\n    if y > N :\n        return 0\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    mem = [[[INF for i in range(M + 1)] for j in range(N + 1)] for k in range(N + 4)]\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Python",
    "code": "def calc(now,nx,w):\n    return (now+nx)*abs(w)\n\ndef solve(n,m):\n    isi=[[[i,0] for i in xrange(11)]]+[[[float('inf'),float('inf')] for _ in xrange(11)]  for _ in xrange(n)]+[[[i,0] for i in xrange(11)]]\n    for i in xrange(1,n+1):\n        en=map(int,raw_input().split())\n        num=en[0]\n        for j in xrange(num):\n            isi[i][j+1]=[en[j*2+1],en[j*2+2]]\n\n    dp=[[[float('inf')]*(m+1) for _ in xrange(11)] for _ in xrange(n+2)]\n    for j in xrange(1,11):\n        dp[0][j][0]=0\n\n    for i in xrange(n+1):\n        for j in xrange(1,11):\n            if isi[i+1][j][0]==float('inf'):continue\n            for k in xrange(m+1):\n                for l in xrange(1,11):\n                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][l][k]+calc(isi[i][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i][l][0]))\n                    if i-1>=0 and k>=1:\n                        if isi[i-1][l][0]==float('inf'):continue\n                        dp[i+1][j][k]=min(dp[i+1][j][k],dp[i-1][l][k-1]+calc(isi[i-1][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i-1][l][0]))\n\n    ans=float('inf')\n    for j in xrange(1,11):\n        ans=min(ans,dp[n+1][j][m])\n\n    return ans\n\nwhile 1:\n    n,m=map(int,raw_input().split())\n    if n==m==0:break\n    ans=solve(n,m)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "\"\"\"\nnodes\n0 ... start\nk*num + 1 ~ (k+1)*num ... j=k (k <= m)\nnum * (m + 1) + 1 ... end\n\"\"\"\nfrom heapq import heappush, heappop\ndef main():\n  INF = 10 ** 20\n  while True:\n    n, m = map(int, input().split())\n    if n == 0:\n      break\n    lines = []\n    acc = 1\n    for _ in range(n):\n      lst = list(map(int, input().split()))\n      k = lst[0]\n      line = [(acc + i, lst[i * 2 + 1], lst[i * 2 + 2]) for i in range(k)]\n      acc += k\n      lines.append(line)\n  \n    num = acc - 1\n    edges = [[] for _ in range(num * (m + 1) + 2)]\n    for line1, line2 in zip(lines, lines[1:]):  \n      for acc1, x1, d1 in line1:\n        for acc2, x2, d2 in line2:\n          cost = (d1 + d2) * abs(x1 - x2)\n          n1 = acc1\n          n2 = acc2\n          for j in range(m + 1):\n            edges[n1].append((n2, cost))\n            n1 += num\n            n2 += num\n    \n    for line1, line2 in zip(lines, lines[2:]):  \n      for acc1, x1, d1 in line1:\n        for acc2, x2, d2 in line2:\n          cost = (d1 + d2) * abs(x1 - x2)\n          n1 = acc1\n          n2 = acc2 + num\n          for j in range(m):\n            edges[n1].append((n2, cost))\n            n1 += num\n            n2 += num\n  \n    for acc, _, _ in lines[0]:\n      edges[0].append((acc, 0))\n    if m >= 1:\n      for acc, _, _ in lines[1]:\n        edges[0].append((acc + num, 0))\n\n    end = num * (m + 1) + 1\n    for acc, _, _ in lines[-1]:\n      b = acc\n      for j in range(m + 1):\n        edges[b].append((end, 0))\n        b += num\n    for acc, _, _ in lines[-2]:\n      b = acc\n      for j in range(m):\n        edges[b].append((end, 0))\n        b += num\n    \n    def search():\n      que = []\n      heappush(que, (0, 0))\n      costs = [INF] * (num * (m + 1) + 2)\n      costs[0] = 0\n      while que:\n        total, node = heappop(que)\n        for to, cost in edges[node]:\n          new_total = total + cost\n          if to == end:\n            print(new_total)\n            return\n          if costs[to] > new_total:\n            costs[to] = new_total\n            heappush(que, (new_total, to))\n    search()\nmain()  \n"
  },
  {
    "language": "Python",
    "code": "\"\"\"\nnodes\n0 ... start\nk*num + 1 ~ (k+1)*num ... j=k (k <= m)\nnum * (m + 1) + 1 ... end\n\"\"\"\nfrom heapq import heappush, heappop\nINF = 10 ** 20\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0:\n    break\n  lines = []\n  klst = []\n  acc = 1\n  for _ in range(n):\n    lst = list(map(int, input().split()))\n    k = lst[0]\n    klst.append(k)\n    line = []\n    for i in range(k):\n      line.append((acc, lst[i * 2 + 1], lst[i * 2 + 2]))\n      acc += 1\n    lines.append(line)\n\n  num = sum(klst)\n  edges = [[] for _ in range(num * (m + 1) + 2)]\n\n  for i in range(n - 1):\n    line1 = lines[i]\n    line2 = lines[i + 1]\n    for acc1, x1, d1 in line1:\n      for acc2, x2, d2 in line2:\n        for j in range(m + 1):\n          edges[acc1 + num * j].append((acc2 + num * j, (d1 + d2) * abs(x1 - x2)))\n  \n  for i in range(n - 2):\n    line1 = lines[i]\n    line2 = lines[i + 2]\n    for acc1, x1, d1 in line1:\n      for acc2, x2, d2 in line2:\n        for j in range(m):\n          edges[acc1 + num * j].append((acc2 + num * (j + 1), (d1 + d2) * abs(x1 - x2)))\n\n  for acc, x, d in lines[0]:\n    edges[0].append((acc, 0))\n  if m >= 1:\n    for acc, x, d in lines[1]:\n      edges[0].append((acc + num, 0))\n  for acc, x, d in lines[-1]:\n    for j in range(m + 1):\n      edges[acc + num * j].append((num * (m + 1) + 1, 0))\n  for acc, x, d in lines[-2]:\n    for j in range(m):\n      edges[acc + num * j].append((num * (m + 1) + 1, 0))\n\n  que = []\n  heappush(que, (0, 0))\n  costs = [INF] * (num * (m + 1) + 2)\n  costs[0] = 0\n  while que:\n    total, node = heappop(que)\n    for to, cost in edges[node]:\n      if costs[to] > total + cost:\n        costs[to] = total + cost\n        heappush(que, (total + cost, to))\n  print(costs[num * (m + 1) + 1])\n\n"
  },
  {
    "language": "Python",
    "code": "def calc(now,nx,w):\n    return (now+nx)*abs(w)\n\ndef solve(n,m):\n    isi=[[[i,0] for i in xrange(11)]]+[[[inf,inf] for _ in xrange(11)]  for _ in xrange(n)]+[[[i,0] for i in xrange(11)]]\n    for i in xrange(1,n+1):\n        en=map(int,raw_input().split())\n        num=en[0]\n        for j in xrange(num):\n            isi[i][j+1]=[en[j*2+1],en[j*2+2]]\n\n    dp=[[[inf]*(m+1) for _ in xrange(11)] for _ in xrange(n+2)]\n    for j in xrange(1,11):\n        dp[0][j][0]=0\n\n    for i in xrange(n+1):\n        for j in xrange(1,11):\n            if isi[i+1][j][0]==inf:continue\n            for k in xrange(m+1):\n                for l in xrange(1,11):\n                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][l][k]+calc(isi[i][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i][l][0]))\n                    if i-1>=0 and k>=1:\n                        dp[i+1][j][k]=min(dp[i+1][j][k],dp[i-1][l][k-1]+calc(isi[i-1][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i-1][l][0]))\n\n    ans=float('inf')\n    for j in xrange(1,11):\n        ans=min(ans,dp[n+1][j][m])\n\n    return ans\n\ninf=10**9\nwhile 1:\n    n,m=map(int,raw_input().split())\n    if n==m==0:break\n    ans=solve(n,m)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "INF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n \ndef dfs(x, y, m):\n    if y > N :\n        return 0\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n \nwhile True:\n    N, M = map(int, raw_input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, raw_input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    mem = [[[INF for i in range(M + 1)] for j in range(N + 1)] for k in range(N + 4)]\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Python",
    "code": "\"\"\"\nnodes\n0 ... start\nk*num + 1 ~ (k+1)*num ... j=k (k <= m)\nnum * (m + 1) + 1 ... end\n\"\"\"\nfrom heapq import heappush, heappop\ndef main():\n  INF = 10 ** 20\n  while True:\n    n, m = map(int, input().split())\n    if n == 0:\n      break\n    lines = []\n    acc = 1\n    for _ in range(n):\n      lst = list(map(int, input().split()))\n      k = lst[0]\n      line = []\n      for i in range(k):\n        line.append((acc, lst[i * 2 + 1], lst[i * 2 + 2]))\n        acc += 1\n      lines.append(line)\n  \n    num = acc - 1\n    edges = [[] for _ in range(num * (m + 1) + 2)]\n  \n    for i in range(n - 1):\n      line1 = lines[i]\n      line2 = lines[i + 1]\n      for acc1, x1, d1 in line1:\n        for acc2, x2, d2 in line2:\n          for j in range(m + 1):\n            edges[acc1 + num * j].append((acc2 + num * j, (d1 + d2) * abs(x1 - x2)))\n    \n    for i in range(n - 2):\n      line1 = lines[i]\n      line2 = lines[i + 2]\n      for acc1, x1, d1 in line1:\n        for acc2, x2, d2 in line2:\n          for j in range(m):\n            edges[acc1 + num * j].append((acc2 + num * (j + 1), (d1 + d2) * abs(x1 - x2)))\n  \n    for acc, x, d in lines[0]:\n      edges[0].append((acc, 0))\n    if m >= 1:\n      for acc, x, d in lines[1]:\n        edges[0].append((acc + num, 0))\n    for acc, x, d in lines[-1]:\n      for j in range(m + 1):\n        edges[acc + num * j].append((num * (m + 1) + 1, 0))\n    for acc, x, d in lines[-2]:\n      for j in range(m):\n        edges[acc + num * j].append((num * (m + 1) + 1, 0))\n  \n    que = []\n    heappush(que, (0, 0))\n    costs = [INF] * (num * (m + 1) + 2)\n    costs[0] = 0\n    while que:\n      total, node = heappop(que)\n      for to, cost in edges[node]:\n        new_total = total + cost\n        if costs[to] > new_total:\n          costs[to] = new_total\n          heappush(que, (new_total, to))\n    print(costs[num * (m + 1) + 1])\nmain() \n"
  },
  {
    "language": "Python",
    "code": "def calc(now,nx,w):\n    return (now+nx)*abs(w)\n\nwhile 1:\n    n,m=map(int,raw_input().split())\n    if n==m==0:break\n\n    isi=[[[i,0] for i in xrange(11)]]+[[[float('inf'),float('inf')] for _ in xrange(11)]  for _ in xrange(n)]+[[[i,0] for i in xrange(11)]]\n    for i in xrange(1,n+1):\n        en=map(int,raw_input().split())\n        num=en[0]\n        for j in xrange(num):\n            isi[i][j+1]=[en[j*2+1],en[j*2+2]]\n\n    dp=[[[float('inf')]*(m+1) for _ in xrange(11)] for _ in xrange(n+2)]\n    for j in xrange(1,11):\n        dp[0][j][0]=0\n\n    for i in xrange(n+1):\n        for j in xrange(1,11):\n            if isi[i+1][j][0]==float('inf'):continue\n            for k in xrange(m+1):\n                for l in xrange(1,11):\n                    if not isi[i][l][0]==float('inf'):\n                        dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][l][k]+calc(isi[i][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i][l][0]))\n                        if i-1>=0 and k>=1:\n                            if isi[i-1][l][0]==float('inf'):continue\n                            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i-1][l][k-1]+calc(isi[i-1][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i-1][l][0]))\n                    else:\n                        if i-1>=0 and k>=1:\n                            if isi[i-1][l][0]==float('inf'):continue\n                            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i-1][l][k-1]+calc(isi[i-1][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i-1][l][0]))\n                            \n    ans=float('inf')\n    for j in xrange(1,11):\n        ans=min(ans,dp[n+1][j][m])\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "def calc(now,nx,w):\n    return (now+nx)*abs(w)\n\ndef solve(n,m):\n    isi=[[[i,0] for i in xrange(11)]]+[[[float('inf'),float('inf')] for _ in xrange(11)]  for _ in xrange(n)]+[[[i,0] for i in xrange(11)]]\n    for i in xrange(1,n+1):\n        en=map(int,raw_input().split())\n        num=en[0]\n        for j in xrange(num):\n            isi[i][j+1]=[en[j*2+1],en[j*2+2]]\n\n    dp=[[[float('inf')]*(m+1) for _ in xrange(11)] for _ in xrange(n+2)]\n    for j in xrange(1,11):\n        dp[0][j][0]=0\n\n    for i in xrange(n+1):\n        for j in xrange(1,11):\n            if isi[i+1][j][0]==float('inf'):continue\n            for k in xrange(m+1):\n                for l in xrange(1,11):\n                    if not isi[i][l][0]==float('inf'):\n                        dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][l][k]+calc(isi[i][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i][l][0]))\n                        if i-1>=0 and k>=1:\n                            if isi[i-1][l][0]==float('inf'):continue\n                            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i-1][l][k-1]+calc(isi[i-1][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i-1][l][0]))\n                    else:\n                        if i-1>=0 and k>=1:\n                            if isi[i-1][l][0]==float('inf'):continue\n                            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i-1][l][k-1]+calc(isi[i-1][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i-1][l][0]))\n\n    ans=float('inf')\n    for j in xrange(1,11):\n        ans=min(ans,dp[n+1][j][m])\n    return ans\n\nwhile 1:\n    n,m=map(int,raw_input().split())\n    if n==m==0:break\n    ans=solve(n,m)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import sys \nsys.setrecursionlimit(100000)\nINF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n\ndef dfs(x, y, m):\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    if y > N :\n        return 0\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n\nwhile True:\n    mem = [[[INF for i in range(150)] for j in range(153)] for k in range(100)]\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Python",
    "code": "import sys \nsys.setrecursionlimit(100000)\nINF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n\ndef dfs(x, y, m):\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    if y > N :\n        return 0\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n\nwhile True:\n    mem = [[[INF for i in range(200)] for j in range(200)] for k in range(200)]\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input=sys.stdin.readline\n    while True:\n        n,m=map(int,input().split())\n        if n==0:\n            break\n        kis=[list(map(int,input().split())) for _ in [0]*n]\n        dp1=[dict() for _ in [0]*(m+1)]\n        dp2=[dict() for _ in [0]*(m+1)]\n        dp3=[dict() for _ in [0]*(m+1)]\n    \n        nows=[dict() for _ in [0]*n]\n        for i in range(n):\n            j=kis[i][0]\n            for k in range(j):\n                nows[i][kis[i][2*k+1]]=kis[i][2*k+2]\n        for i in range(kis[0][0]):\n            dp1[0][kis[0][2*i+1]]=0\n        if m>=1:\n            for i in range(kis[1][0]):\n                dp2[1][kis[1][2*i+1]]=0\n        #ここからDP開始\n        for k in range(n-1):#行をn-1回分繰り返す\n            for l in range(m+1):#飛び越えた回数分\n                for i,j in dp1[l].items():#iは現在位置、jはそれまでの最小危険度\n                    for x,y in nows[k+1].items():#xは移動先、yは移動先の滑りやすさ\n                        plus=j+(nows[k][i]+y)*abs(i-x)\n                        if x in dp2[l].keys():\n                            dp2[l][x]=min(dp2[l][x],plus)\n                        else:\n                            dp2[l][x]=plus\n            if k==n-2:\n                continue\n            for l in range(m):#飛び越えた回数-1分\n                for i,j in dp1[l].items():#iは現在位置、jはそれまでの最小危険度\n                    for x,y in nows[k+2].items():#xは移動先、yは移動先の滑りやすさ\n                        plus=j+(nows[k][i]+y)*abs(i-x)\n                        if x in dp3[l+1].keys():\n                            dp3[l+1][x]=min(dp3[l+1][x],plus)\n                        else:\n                            dp3[l+1][x]=plus\n            dp1=dp2\n            dp2=dp3\n            dp3=[dict() for _ in [0]*(m+1)]\n        m=10**9\n        for i in dp1[:-1]:\n            if len(i.values())>0:\n                m=min(m,min(i.values()))\n        for i in dp2:\n            if len(i.values())>0:\n                m=min(m,min(i.values()))\n        print(m)\n    \nif __name__=='__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def calc(now,nx,w):\n    return (now+nx)*abs(w)\n\ndef solve(n,m):\n    isi=[[[i,0] for i in xrange(11)]]+[[[inf,inf] for _ in xrange(11)]  for _ in xrange(n)]+[[[i,0] for i in xrange(11)]]\n    for i in xrange(1,n+1):\n        en=map(int,raw_input().split())\n        num=en[0]\n        for j in xrange(num):\n            isi[i][j+1]=[en[j*2+1],en[j*2+2]]\n\n    dp=[[[inf]*(m+1) for _ in xrange(11)] for _ in xrange(n+2)]\n    for j in xrange(1,11):\n        dp[0][j][0]=0\n\n    for i in xrange(n+1):\n        for j in xrange(1,11):\n            for k in xrange(m+1):\n                for l in xrange(1,11):\n                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][l][k]+calc(isi[i][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i][l][0]))\n                    if i-1>=0 and k>=1:\n                        dp[i+1][j][k]=min(dp[i+1][j][k],dp[i-1][l][k-1]+calc(isi[i-1][l][1],isi[i+1][j][1],isi[i+1][j][0]-isi[i-1][l][0]))\n\n    ans=float('inf')\n    for j in xrange(1,11):\n        ans=min(ans,dp[n+1][j][m])\n\n    return ans\n\ninf=10**9\nwhile 1:\n    n,m=map(int,raw_input().split())\n    if n==m==0:break\n    ans=solve(n,m)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    P = []\n    K = []\n    for i in range(N):\n        k, *S = map(int, input().split())\n        P.append(list(zip(S[::2], S[1::2])))\n        K.append(k)\n    INF = 10**18\n    memo = {}\n    def dfs(i, j, k):\n        key = i, j, k\n        if key in memo:\n            return memo[key]\n        if i == N-2 and k < M:\n            return 0\n        if i == N-1:\n            return 0\n        res = INF\n        xi, di = P[i][j]\n        for p in range(K[i+1]):\n            xj, dj = P[i+1][p]\n            res = min(res, dfs(i+1, p, k) + abs(xi - xj)*(di + dj))\n        if i+2 < N and k < M:\n            for p in range(K[i+2]):\n                xj, dj = P[i+2][p]\n                res = min(res, dfs(i+2, p, k+1) + abs(xi - xj)*(di + dj))\n        memo[key] = res\n        return res\n    ans = INF\n    for i in range(K[0]):\n        ans = min(ans, dfs(0, i, 0))\n    if 0 < M:\n        for i in range(K[1]):\n            ans = min(ans, dfs(1, i, 1))\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "INF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n\ndef dfs(x, y, m):\n    if y > N :\n        return 0\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    mem = [[[INF for i in range(M + 1)] for j in range(N + 1)] for k in range(N + 4)]\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Python",
    "code": "INF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n\ndef dfs(x, y, m):\n    if y > N :\n        return 0\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    mem = [[[INF for i in range(M + 1)] for j in range(N + 1)] for k in range(N + 4)]\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Python",
    "code": "import sys \nsys.setrecursionlimit(100000)\nINF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n\ndef dfs(x, y, m):\n    if y > N :\n        return 0\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n\nwhile True:\n    mem = [[[INF for i in range(150)] for j in range(151)] for k in range(75)]\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\nwhile True:\n    n, m = map(int, input().split())\n    if not n:\n        break\n\n    num_stones = 0\n    row_stones = [None] * n\n    edges = [None] * n\n    for row in range(n):\n        (num, *stones) = map(int, input().split())\n        row_stones[row] = list(zip(*[iter(stones)] * 2))\n        edges[row] = [None] * num\n\n    for row, stones in enumerate(row_stones):\n        next_stones = [row_stones[row + j] if row + j < n else [] for j in (1, 2)]\n        for i, (column1, slip1) in enumerate(stones):\n            edges[row][i] = [{(abs(column1 - column2) * (slip1 + slip2), j)\n                              for j, (column2, slip2) in enumerate(next_stones[k])} for k in (0, 1)]\n\n    queue = [(0, m, 0, i) for i in range(len(row_stones[0]))]\n    if m:\n        queue.extend((0, m - 1, 1, i) for i in range(len(row_stones[1])))\n\n    while queue:\n        total_risk, remains, row, i = heappop(queue)\n        if row == n - 1 or (remains and row == n - 2):\n            print(total_risk)\n            break\n        next_stones = edges[row][i]\n        for risk, j in next_stones[0]:\n            heappush(queue, (total_risk + risk, remains, row + 1, j))\n        if remains:\n            for risk, j in next_stones[1]:\n                heappush(queue, (total_risk + risk, remains - 1, row + 2, j))"
  },
  {
    "language": "Python",
    "code": "while 1:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    P = []\n    K = []\n    for i in range(N):\n        k, *S = map(int, input().split())\n        P.append(list(zip(S[::2], S[1::2])))\n        K.append(k)\n    INF = 10**18\n    memo = {}\n    def dfs(i, j, k):\n        key = i, j, k\n        if key in memo:\n            return memo[key]\n        if i == N-1:\n            return 0\n        res = INF\n        xi, di = P[i][j]\n        for p in range(K[i+1]):\n            xj, dj = P[i+1][p]\n            res = min(res, dfs(i+1, p, k) + abs(xi - xj)*(di + dj))\n        if i+2 < N and k < M:\n            for p in range(K[i+2]):\n                xj, dj = P[i+2][p]\n                res = min(res, dfs(i+2, p, k+1) + abs(xi - xj)*(di + dj))\n        memo[key] = res\n        return res\n    ans = INF\n    for i in range(K[0]):\n        ans = min(ans, dfs(0, i, 0))\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\nwhile True:\n    n, m = map(int, input().split())\n    if not n:\n        break\n\n    num_stones = 0\n    row_stones = [None] * n\n    edges = [None] * n\n    visited = [None] * n\n    for row in range(n):\n        (num, *stones) = map(int, input().split())\n        row_stones[row] = list(zip(*[iter(stones)] * 2))\n        edges[row] = [None] * num\n        visited[row] = [1] * num\n\n    for row, stones in enumerate(row_stones):\n        next_stones = [row_stones[row + j] if row + j < n else [] for j in (1, 2)]\n        for i, (column1, slip1) in enumerate(stones):\n            edges[row][i] = [{(abs(column1 - column2) * (slip1 + slip2), j)\n                              for j, (column2, slip2) in enumerate(next_stones[k])} for k in (0, 1)]\n\n    queue = [(0, 0, -m, i) for i in range(len(row_stones[0]))]\n    if m:\n        queue.extend((0, -1, -m + 1, i) for i in range(len(row_stones[1])))\n\n    while queue:\n        total_risk, row, remains, i = heappop(queue)\n        row = -row\n        if row == n - 1 or (remains and row == n - 2):\n            print(total_risk)\n            break\n        if visited[row][i] <= remains:\n            continue\n        visited[row][i] = remains\n        next_stones = edges[row][i]\n        for risk, j in next_stones[0]:\n            heappush(queue, (total_risk + risk, -row - 1, remains, j))\n        if remains:\n            for risk, j in next_stones[1]:\n                heappush(queue, (total_risk + risk, -row - 2, remains + 1, j))"
  },
  {
    "language": "Python",
    "code": "INF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n \ndef dfs(x, y, m):\n    if y > N :\n        return 0\n    if mem[x][y][m] != INF:\n        return mem[x][y][m]\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[x][y][m] = n\n    return mem[x][y][m]\n \nwhile True:\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    mem = [[[INF for i in range(M + 1)] for j in range(N + 1)] for k in range(N + 4)]\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Python",
    "code": "while 1:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    P = []\n    K = []\n    for i in range(N):\n        k, *S = map(int, input().split())\n        P.append(list(zip(S[::2], S[1::2])))\n        K.append(k)\n    INF = 10**18\n    memo = {}\n    def dfs(i, j, k):\n        key = i, j, k\n        if key in memo:\n            return memo[key]\n        if i == N-1:\n            return 0\n        res = INF\n        xi, di = P[i][j]\n        for p in range(K[i+1]):\n            xj, dj = P[i+1][p]\n            res = min(res, dfs(i+1, p, k) + abs(xi - xj)*(di + dj))\n        if i+2 < N and k < M:\n            for p in range(K[i+2]):\n                xj, dj = P[i+2][p]\n                res = min(res, dfs(i+2, p, k+2) + abs(xi - xj)*(di + dj))\n        memo[key] = res\n        return res\n    ans = INF\n    for i in range(K[0]):\n        ans = min(ans, dfs(0, i, 0))\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "INF = 10000000000\ndx = [0, 0, 1, -1]\ndy = [-1, 1, 0, 0]\n\ndef dfs(x, y, m):\n    if y > N :\n        return 0\n    if mem[m][y][x] != INF:\n        return mem[m][y][x]\n    n = INF\n    for j in range(2 if m > 0 else 1):\n        for i, s in enumerate(st[y + 1 + j]):\n            srip = max(0, st[y][x][1] + s[1])\n            l = abs(st[y][x][0] - s[0])\n            n = min(dfs(i, y + 1 + j, m - j) + srip * l, n)\n    mem[m][y][x] = n\n    return mem[m][y][x]\n\nwhile True:\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    st = [[[-INF, -INF]] for i in range(N + 3)]\n    for s in st[1:-2]:\n        v = list(map(int, input().split()))\n        del s[0]\n        for i in range(1, len(v), 2):\n            s.append([v[i], v[i + 1]])\n    mem = [[[INF for i in range(N + 4)] for j in range(N + 1)] for k in range(M + 1)]\n    print(dfs(0, 0, M))"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main(){\n  let inf:usize = 1000000000;\n  loop {\n    let nm: Vec<usize> = read_vec();\n    let n = nm[0];\n    let m = nm[1];\n\n    if n == 0 && m == 0 { break; }\n\n    let mut rv: Vec<Vec<usize>> = vec![vec![0;1000];n];\n\n    for i in 0 .. n {\n      let kv: Vec<usize> = read_vec();\n\n      for j in 0 .. kv[0] {\n        rv[i][kv[j*2+1]-1] = kv[j*2+2];\n      }\n    }\n\n    let mut dv0: Vec<Vec<usize>> = vec![vec![inf;1000]; m+1];\n    \n    for i in 0 .. 1000 {\n      if rv[0][i] > 0 {\n        dv0[m][i] = 0;\n      }\n    }\n    \n    let mut dv1 = dv0;\n    dv0 = vec![vec![inf;1000]; m+1];\n    \n    for i in 0 .. 1000 {\n      if rv[1][i] > 0 && m > 0 {\n        dv0[m-1][i] = 0;\n      }\n      for j in 0 .. 1000 {\n        if rv[0][j] > 0 {\n          dv0[m][i] = cmp::min(dv0[m][i], dv1[m][j] + (cmp::max(i, j) - cmp::min(i, j)) * (rv[1][i] + rv[0][j]));\n        }\n      }\n    }\n\n    let mut dv2 = dv1;\n    dv1 = dv0;\n    dv0 = vec![vec![inf;1000]; m+1];\n      \n    for k in 2 .. n {\n      for i in 0 .. 1000 {\n        if rv[k][i] > 0 {\n          for j in 0 .. 1000 {\n            if rv[k-1][j] > 0 {\n              for l in 0 .. m+1 {\n                dv0[l][i] = cmp::min(dv0[l][i], dv1[l][j] + (cmp::max(i, j) - cmp::min(i, j)) * (rv[k][i] + rv[k-1][j]));\n              }\n            }\n            if rv[k-2][j] > 0 {\n              for l in 0 .. m {\n                dv0[l][i] = cmp::min(dv0[l][i], dv2[l+1][j] + (cmp::max(i, j) - cmp::min(i, j)) * (rv[k][i] + rv[k-2][j]))\n              }\n            }\n          }\n        }\n      }\n      \n      dv2 = dv1;\n      dv1 = dv0;\n      dv0 = vec![vec![inf;1000]; m+1];\n    }\n    \n    let mut ans: usize = inf;\n\n    for i in 0 .. m+1 {\n      for j in 0 .. 1000 {\n        ans = cmp::min(ans, dv1[i][j]);\n      }\n      if i > 0 {\n        for j in 0 .. 1000 {\n          ans = cmp::min(ans, dv2[i][j]);\n        }\n      }\n    }\n    println!(\"{}\", ans);\n  }\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[allow(dead_code)]\npub const INF: u64 = 1 << 30;\n\n#[allow(dead_code)]\nfn main() {\n    loop {\n        let (n, m) = get!(usize, usize);\n        if n == 0 && m == 0 {\n            break;\n        }\n        let rows: Vec<Vec<usize>> = (0..n).map(|_| util::gets()).collect();\n\n        let mut dp = vec![vec![vec![INF; m + 1]; 1001]; n];\n\n        for i in 0..n {\n            for v in rows[i][1..].chunks(2) {\n                let r = v[0];\n                let cost = v[1] as u64;\n\n                for j in 0..m + 1 {\n                    if i == 0 {\n                        dp[i][r][j] = 0;\n                    } else {\n                        for v2 in rows[i - 1][1..].chunks(2) {\n                            let r1 = v2[0];\n                            let cost1 = v2[1] as u64;\n\n                            let mov = (r1 as isize - r as isize).abs() as u64;\n                            let c = cost + cost1;\n                            dp[i][r][j] = min(dp[i][r][j], dp[i - 1][r1][j] + mov * c);\n                        }\n\n                        if i >= 2 && j > 0 {\n                            for v2 in rows[i - 2][1..].chunks(2) {\n                                let r1 = v2[0];\n                                let cost1 = v2[1] as u64;\n\n                                let mov = (r1 as isize - r as isize).abs() as u64;\n                                let c = cost + cost1;\n                                dp[i][r][j] = min(dp[i][r][j], dp[i - 2][r1][j - 1] + mov * c);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        let mut ans = INF;\n\n        for i in 0..1001 {\n            for j in 0..m + 1 {\n                ans = min(ans, dp[n - 1][i][j]);\n            }\n        }\n\n        for i in 0..1001 {\n            for j in 0..m {\n                ans = min(ans, dp[n - 2][i][j]);\n            }\n        }\n\n        println!(\"{}\", ans);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main(){\n  let inf:usize = 100000000;\n  loop {\n    let nm: Vec<usize> = read_vec();\n    let n = nm[0];\n    let m = nm[1];\n\n    if n == 0 && m == 0 { break; }\n\n    let mut rv: Vec<Vec<usize>> = vec![vec![0,0,0,0];n];\n\n    for i in 0 .. n {\n      let kv: Vec<usize> = read_vec();\n\n      for j in 0 .. kv[0] {\n        rv[i][kv[j*2+1]-1] = kv[j*2+2];\n      }\n    }\n\n    let mut dv0: Vec<Vec<usize>> = vec![vec![inf;4]; m+1];\n    \n    for i in 0 .. 4 {\n      if rv[0][i] > 0 {\n        dv0[m][i] = 0;\n      }\n    }\n    \n    let mut dv1 = dv0;\n    dv0 = vec![vec![inf;4]; m+1];\n    \n    for i in 0 .. 4 {\n      if rv[1][i] > 0 && m > 0 {\n        dv0[m-1][i] = 0;\n      }\n      for j in 0 .. 4 {\n        if rv[0][j] > 0 {\n          dv0[m][i] = cmp::min(dv0[m][i], dv1[m][j] + (cmp::max(i, j) - cmp::min(i, j)) * (rv[1][i] + rv[0][j]));\n        }\n      }\n    }\n\n    let mut dv2 = dv1;\n    dv1 = dv0;\n    dv0 = vec![vec![inf;4]; m+1];\n      \n    for k in 2 .. n {\n      for i in 0 .. 4 {\n        if rv[k][i] > 0 {\n          for j in 0 .. 4 {\n            if rv[k-1][j] > 0 {\n              for l in 0 .. m+1 {\n                dv0[l][i] = cmp::min(dv0[l][i], dv1[l][j] + (cmp::max(i, j) - cmp::min(i, j)) * (rv[k][i] + rv[k-1][j]));\n              }\n            }\n            if rv[k-2][j] > 0 {\n              for l in 0 .. m {\n                dv0[l][i] = cmp::min(dv0[l][i], dv2[l+1][j] + (cmp::max(i, j) - cmp::min(i, j)) * (rv[k][i] + rv[k-2][j]))\n              }\n            }\n          }\n        }\n      }\n      \n      dv2 = dv1;\n      dv1 = dv0;\n      dv0 = vec![vec![inf;4]; m+1];\n    }\n    \n    let mut ans: usize = inf;\n\n    for i in 0 .. m+1 {\n      for j in 0 .. 4 {\n        ans = cmp::min(ans, dv1[i][j]);\n      }\n      if i > 0 {\n        for j in 0 .. 4 {\n          ans = cmp::min(ans, dv2[i][j]);\n        }\n      }\n    }\n    println!(\"{}\", ans);\n  }\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\n#[allow(dead_code)]\npub const INF: u64 = 1 << 30;\n\n#[allow(dead_code)]\nfn main() {\n    loop {\n        let (n, m) = get!(usize, usize);\n        if n == 0 && m == 0 {\n            break;\n        }\n        let rows: Vec<Vec<usize>> = (0..n).map(|_| util::gets()).collect();\n\n        let mut dp = vec![vec![vec![INF; m + 1]; 1001]; n];\n\n        for i in 0..n {\n            for v in rows[i][1..].chunks(2) {\n                let r = v[0];\n                let cost = v[1] as u64;\n\n                for j in 0..m + 1 {\n                    if i == 0 {\n                        dp[i][r][j] = 0;\n                    } else {\n                        for v2 in rows[i - 1][1..].chunks(2) {\n                            let r1 = v2[0];\n                            let cost1 = v2[1] as u64;\n\n                            let mov = (r1 as isize - r as isize).abs() as u64;\n                            let c = cost + cost1;\n                            dp[i][r][j] = min(dp[i][r][j], dp[i - 1][r1][j] + mov * c);\n                        }\n\n                        if i >= 2 && j > 0 {\n                            for v2 in rows[i - 2][1..].chunks(2) {\n                                let r1 = v2[0];\n                                let cost1 = v2[1] as u64;\n\n                                let mov = (r1 as isize - r as isize).abs() as u64;\n                                let c = cost + cost1;\n                                dp[i][r][j] = min(dp[i][r][j], dp[i - 2][r1][j - 1] + mov * c);\n                            }\n                        }\n                    }\n                }\n\n                if i == 1 {\n                    for j in 1..m + 1 {\n                        dp[i][r][j] = 0;\n                    }\n                }\n                // debug!(i, r, dp[i][r]);\n            }\n        }\n\n        let mut ans = INF;\n\n        for i in 0..1001 {\n            for j in 0..m + 1 {\n                ans = min(ans, dp[n - 1][i][j]);\n            }\n        }\n\n        for i in 0..1001 {\n            for j in 0..m {\n                ans = min(ans, dp[n - 2][i][j]);\n            }\n        }\n\n        println!(\"{}\", ans);\n    }\n}\n\n"
  }
]