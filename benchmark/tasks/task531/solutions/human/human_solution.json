[
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  val n = readLine.trim.toInt\n\n  val numbers = readLine.trim.split(' ').map(_.toInt)\n  val mod = 1000000007L\n  println(\n    calPattern(numbers)\n  )\n  def calPattern(numbers: Array[Int]): Long = {\n    val memo = Array.tabulate(n){_ ⇒ Array.tabulate(2){_ ⇒ None: Option[Long]}}\n    val prime = primes(1000000)\n    def sub(number: List[Int], position: Int, lastPrime: Int, count: Int = 0): Long = {\n      number match {\n        case Nil ⇒ 1L\n        case p::t ⇒\n          memo(position)(count) match {\n            case Some(r) ⇒ r\n            case None if lastPrime < p ⇒\n              (binarySearch(prime, p) match {\n                case Some(_) ⇒\n                  t match {\n                    case e::rest ⇒ (sub(rest, position + 2, p, 1) + sub(t, position + 1, p, 0)) % mod\n                    case Nil ⇒ 1L\n                  }\n                case None ⇒ 0L\n              }).also{r ⇒ memo(position)(count) = Some(r)}\n            case None ⇒\n              memo(position)(count) = Some(0L)\n              0L\n          }\n      }\n    }\n    sub(numbers.toList, 0, 0)\n  }\n  def binarySearch(array: Array[Int], target: Int): Option[Int] = {\n    var left = 0\n    var right = array.length\n    while (left < right){\n      val mid = (left + right) / 2\n      if (array(mid) < target){\n        left = mid + 1\n      }else {\n        right = mid\n      }\n    }\n    if (right < array.length && array(right) == target) Some(right)\n    else None\n  }\n  def primes(upper: Int): Array[Int] = {\n    val memo = Array.tabulate(upper + 1){_ ⇒ true}\n    for (i ← 2 to math.sqrt(upper).toInt){\n      if (memo(i)){\n        for (j ← i * 2 to upper by i){\n          memo(j) = false\n        }\n      }\n    }\n    (2 to upper).filter(i ⇒ memo(i)).toArray\n  }\n\n\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\n\nconst int N = 1111111;\nbool prime[N + 1];\nvector<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tif (!prime[i]) continue;\n\t\tfor (int j = i; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i])\n\t\t{\n\t\t\tprimes.push_back(i);\n\t\t}\n\t}\n}\n\nll pow(ll x, ll n, ll mod)\n{\n\tll res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x*x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint n;\nvi q;\nll dp[111111];\n\nll solve(int p)\n{\n\tif (dp[p] >= 0) return dp[p];\n\tif (p == n) return 0;\n\tif (p == n - 1)\n\t{\n\t\tif(prime[q[p]])\treturn 1;\n\t\telse return 0;\n\t}\n\tll res = 0;\n\tif (prime[q[p + 1]] && q[p + 1] > q[p]) res += solve(p + 1);\n\tif (p + 2 < n && prime[q[p + 2]] && q[p + 2] > q[p]) res += solve(p + 2);\n\tif (p + 2 == n) return 1;\n\treturn dp[p] = res % MOD;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tMS(dp, -1);\n\thurui();\n\tcin >> n;\n\tq.resize(n);\n\tcin >> q;\n\tcout << solve(0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nbool prime[1000009];\n\nvoid era(){\n    prime[0]=1;\n    prime[1]=1;\n    for(int i=2;i<1000009;i++){\n        if(!prime[i]){\n            for(int j=i+i;j<1000009;j+=i) prime[j]=1;\n        }\n    }\n}\n\nint dp[100009][2];\n\nsigned main(){\n    era();\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++)cin>>a[i];\n    if(!prime[a[0]]){\n        dp[0][0]=1;\n        dp[0][1]=1;\n    }\n    for(int i=0;i<n;i++){\n\n        // 1\n\n        if( i+1<n && a[i]<a[i+1] &&!prime[a[i+1]] )dp[i+1][0] += dp[i][0];\n        if( i+2<n && a[i]<a[i+1] &&!prime[a[i+1]] )dp[i+1][1] += dp[i][0];\n\n        // 2\n\n        if( i+2<n && a[i]<a[i+2] &&!prime[a[i+2]] )dp[i+2][0] += dp[i][1];\n        if( i+3<n && a[i]<a[i+2] &&!prime[a[i+2]] )dp[i+2][1] += dp[i][1];\n\n        dp[i+1][0]%=1000000007;\n        dp[i+1][1]%=1000000007;\n        dp[i+2][0]%=1000000007;\n        dp[i+2][1]%=1000000007;\n    }\n    cout<<dp[n-1][0]+dp[n-2][1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nbool isp[1111111];\n\nll dp[100010][2];\n\nvoid era(){\n\tisp[0] = isp[1] = true;\n\tfor(int i = 2 ; i < 1000001;i++){\n\t\tif(!isp[i]){\n\t\t\tfor(int j = 2*i;j < 1000001;j += i){\n\t\t\t\tisp[j] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tera();\n\t\n\t//SHOW1d(isp,100);\n\t\n\tint n;cin >> n;\n\tvector<int> v(n);\n\tREP(i,n){\n\t\tcin >> v[i];\n\t}\n\t\n\tdp[0][0] = 1;\n\t\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < 2;j++){\n\t\t\tif(dp[i][j]){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tif((i == 0 && !isp[v[i]]) ||(i > 1 && !isp[v[i]] && v[i] > v[i-2])){\n\t\t\t\t\t\tdp[i+1][1] = (dp[i+1][1] + dp[i][0]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(!isp[v[i]] && v[i] > v[i-1]){\n\t\t\t\t\t\tdp[i+1][1] = (dp[i+1][1] + dp[i][j]) %MOD;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+1][0] = (dp[i+1][0] + dp[i][j]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//REP(i,n+1)cout << dp[i][0] << ' ';cout << endl;\n\t//REP(i,n+1)cout << dp[i][1] << ' ';cout << endl;\n\t\n\tcout << (dp[n][0] + dp[n][1]) % MOD << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nbool Is_Prime(ll n){\n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0) return 0;\n\t}\n\treturn n!=1;\n}\n\nint n;\nvi a,b;\n\nint main(){\n\tcin>>n;\n\ta=b=vi(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\tb[i]=Is_Prime(a[i]);\n\t}\n\tvi dp0(n),dp1(n);\n\tif(b[0]) dp0[0]++;\n\tif(n>=2&&b[0]) dp1[1]++;\n\tfor(int i=1;i<n;i++){\n\t\tif(b[i]){\n\t\t\tif(i-2>=0&&b[i-2]&&a[i-2]<a[i]) (dp0[i]+=dp1[i-1])%=mod;\n\t\t\tif(b[i-1]&&a[i-1]<a[i]) (dp0[i]+=dp0[i-1])%=mod;\n\t\t}\n\t\tif(b[i-1]){\n\t\t\tif(i-2>=0&&b[i-2]&&a[i-2]<a[i-1]) (dp1[i]+=dp0[i-2])%=mod;\n\t\t\tif(i-3>=0&&b[i-3]&&a[i-3]<a[i-1]) (dp1[i]+=dp1[i-2])%=mod;\n\t\t}\n\t}\n\tcout<<(dp0[n-1]+dp1[n-1])%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint n;\nint q[100000];\nbool isPrime[1000001];\n\nvoid setPrime(int n) {\n\tint i, j;\n\tfor (i = 2; i <= n; i++) isPrime[i] = true; isPrime[0] = isPrime[1] = false;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (isPrime[i]) {\n\t\t\tfor (j = i * 2; j <= n; j += i)\n\t\t\t\tisPrime[j] = false;\n\t\t}\n\t}\n}\n\nint dp[100001];\nint mod = 1000000007;\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> q[i];\n\tsetPrime(1000000);\n\t\n\tif (!isPrime[q[0]]) { cout << 0 << endl; return 0; }\n\t\n\tdp[0] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tif (i + 1 == n || (isPrime[q[i + 1]] && q[i] < q[i + 1])) {\n\t\t\tdp[i + 1] += dp[i];\n\t\t\tdp[i + 1] %= mod;\n\t\t}\n\t\tif (i == n - 1) continue;\n\t\tif (i + 2 == n || (isPrime[q[i + 2]] && q[i] < q[i + 2])) {\n\t\t\tdp[i + 2] += dp[i];\n\t\t\tdp[i + 2] %= mod;\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day3/problems/D>\n問題文============================================================\n\n えびちゃんは素因数分解マシンの不良品を持っています。\n この機械は、2 以上の自然数 M を与えると O(logM) でその素因数分解を行ってくれますが、\n 困ったことに数字以外を表示できないバグがありました。\n \n 一般に、M の素因数分解が p1e1×p2e2×…×pKeK (ただし i<j ならば pi<pj、また各 pi は素数) の場合を考えます。\n M を与えると、この機械は i=1 から順に以下のように出力を行います。全ての数字はスペース区切りで表示されます。\n \n ei=1 ならば pi を出力する\n ei>1 ならば pi ei を出力する\n \n たとえば、22 や 2048 を与えると 2 11 と表示され、24 や 54 を与えると 2 3 3 と表示されます。\n \n さて、えびちゃんは表示された素因数分解をメモしておいたのですが、\n 与えた自然数をメモしておくのを忘れていたことに気づきました。\n 素因数分解のメモが与えられるので、元の自然数としてありえるものがいくつあるかを求めてください。\n ただし、メモが間違っていて、条件を満たす自然数が一つも存在しないこともあります。\n \n また、その個数は非常に大きくなる場合があるので、109+7 (素数) で割ったあまりを出力してください。\n \n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\n#define MAX_N 1000005\nbool is_prime[MAX_N];\nconst ll MOD = 1e9+7;\n\nbool IsPrime(int num)\n{\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2){\n        if (num % i == 0){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid init(){\n    for(int i = 1; i < MAX_N;i++){\n        is_prime[i] = IsPrime(i);\n    }\n}\nll solve(){\n    ll N; cin >> N;\n    vector<ll> q(N);\n    for(auto& in:q)cin >> in;\n\n    if(!is_prime[q[0]]) return 0;\n\n    int cnt = 0;\n    for(int i = 0; i < N;i++){\n        if(!is_prime[q[i]]) cnt++;\n        else cnt = 0;\n        if(cnt == 2) return 0;\n    }\n\n    vector<ll> dp(N+1,0);\n    dp[0] = 1;\n    for(int i = 0; i < N;i++){\n        if(is_prime[q[i]]){\n            if((i+1 == N || is_prime[q[i+1]]) && (q[i] < q[i+1])){\n                (dp[i+1] += dp[i])%=MOD;\n            }\n            if((i+2 == N || is_prime[q[i+2]])&& (q[i] < q[i+2])){\n                (dp[i+2] += dp[i])%=MOD;\n            }\n        }\n    }\n    return dp[N];\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    init();\n    cout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nconst ll ccc=1000000;\nbool prime[ccc+1];\nvector<ll> pr;\nvoid makeprime(){\n\tll i,j;\n\tfor(i=2;i<=ccc;i++) prime[i]=true;\n\tfor(i=2;i*i<=ccc;i++) if(prime[i]) for(j=2;j*i<=ccc;j++) prime[j*i]=false;\n\tfor(i=2;i<=ccc;i++) if(prime[i]) pr.push_back(i);\n}\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nint main(){\n\tmakeprime();\n\tint N;\n\tcin>>N;\n\tmint a=1,b=0,c=0;\n\tvector<int> xs(N);\n\trep(i,N) cin>>xs[i];\n\trep(i,N){\n\t\tint x = xs[i];\n\t\tmint na = 0, nb = 0, nc = 0;\n\t\tif(prime[x] && (i-2<0||xs[i-2]<xs[i])){\n\t\t\tnb += a;\n\t\t\tnc += a;\n\t\t}\n\t\tif(prime[x] && (i-1<0||xs[i-1]<xs[i])){\n\t\t\tnb += b;\n\t\t\tnc += c;\n\t\t}\n\t\t{\n\t\t\tna += c;\n\t\t}\n\t\ta = na,b = nb,c = nc;\n\t}\n\tcout<<a+b<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid eratosthenes(int N, int* arr){\n  for(int i=0; i < N; i++){\n    arr[i] = 1;\n  }\n  for(int i=2; i < sqrt(N); i++){\n    if(arr[i]){\n      for(int j=0; i * (j + 2) < N; j++){\n        arr[i*(j+2)] = 0;\n      }\n    }\n  }\n}\n\nint main(void){\n  const int NMAX = 100002;\n  const int QMAX = 1000001;\n  const int MOD = 1e9+7;\n  int dp[NMAX][2]; // dp[idx][自分が素因数(0)か肩(1)か]\n  int isprime[QMAX];\n  for(int i = 0; i < NMAX; i++) for(int j = 0; j < 2; j++) dp[i][j] = 0;\n  eratosthenes(QMAX, isprime);\n\n\n\n  int N; cin >> N;\n  vector<int> q(N);\n  for(int i = 0; i < N; i++) cin >> q[i];\n  q.push_back(0);\n\n  if(isprime[q[0]])\n    dp[0][0] = 1;\n\n  for(int i = 0; i < N-1; i++){\n    for(int j = 0; j < 2; j++){\n      if(j == 0){\n        dp[i+1][1] = (dp[i+1][1] + dp[i][j]) % MOD;\n        if(q[i+1] > q[i] && isprime[q[i+1]]){\n          dp[i+1][0] = (dp[i+1][0] + dp[i][j]) % MOD;\n        }\n      }else{\n        if((i == 0 || q[i+1] > q[i-1]) && isprime[q[i+1]]){\n          dp[i+1][0] = (dp[i+1][0] + dp[i][j]) % MOD;\n        }\n      }\n    }\n  }\n  cout << (dp[N-1][0] + dp[N-1][1]) % MOD << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day3/problems/D>\n問題文============================================================\n\n えびちゃんは素因数分解マシンの不良品を持っています。\n この機械は、2 以上の自然数 M を与えると O(logM) でその素因数分解を行ってくれますが、\n 困ったことに数字以外を表示できないバグがありました。\n \n 一般に、M の素因数分解が p1e1×p2e2×…×pKeK (ただし i<j ならば pi<pj、また各 pi は素数) の場合を考えます。\n M を与えると、この機械は i=1 から順に以下のように出力を行います。全ての数字はスペース区切りで表示されます。\n \n ei=1 ならば pi を出力する\n ei>1 ならば pi ei を出力する\n \n たとえば、22 や 2048 を与えると 2 11 と表示され、24 や 54 を与えると 2 3 3 と表示されます。\n \n さて、えびちゃんは表示された素因数分解をメモしておいたのですが、\n 与えた自然数をメモしておくのを忘れていたことに気づきました。\n 素因数分解のメモが与えられるので、元の自然数としてありえるものがいくつあるかを求めてください。\n ただし、メモが間違っていて、条件を満たす自然数が一つも存在しないこともあります。\n \n また、その個数は非常に大きくなる場合があるので、109+7 (素数) で割ったあまりを出力してください。\n \n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\n#define MAX_N 1000005\nbool is_prime[MAX_N];\nconst ll MOD = 1e9+7;\n\nbool IsPrime(int num)\n{\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2){\n        if (num % i == 0){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid init(){\n    for(int i = 1; i < MAX_N;i++){\n        is_prime[i] = IsPrime(i);\n    }\n}\nll solve(){\n    ll N; cin >> N;\n    vector<ll> q(N);\n    for(auto& in:q)cin >> in;\n\n    if(!is_prime[q[0]]) return 0;\n\n    int cnt = 0;\n    for(int i = 0; i < N;i++){\n        if(!is_prime[q[i]]) cnt++;\n        else cnt = 0;\n        if(cnt == 2) return 0;\n    }\n\n    vector<ll> dp(N+1,0);\n    dp[0] = 1;\n    for(int i = 0; i < N;i++){\n        if(is_prime[q[i]]){\n            if(/*is_prime[q[i+1]] &&*/ (q[i] < q[i+1])){\n                (dp[i+1] += dp[i])%=MOD;\n            }\n            if(/* is_prime[q[i+2]] &&*/ (q[i] < q[i+2])){\n                (dp[i+2] += dp[i])%=MOD;\n            }\n        }\n    }\n    return dp[N];\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    init();\n    cout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nbool prime[1000009];\n\nvoid era(){\n    prime[0]=1;\n    prime[1]=1;\n    for(int i=2;i<1000009;i++){\n        if(!prime[i]){\n            for(int j=i+i;j<1000009;j+=i) prime[j]=1;\n        }\n    }\n}\n\nint dp[100009][2];\n\nsigned main(){\n    era();\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++)cin>>a[i];\n    if(!prime[a[0]]){\n        dp[0][0]=1;\n        dp[0][1]=1;\n    }\n    for(int i=0;i<n;i++){\n\n        // 1\n\n        if( i+1<n && a[i]<a[i+1] &&!prime[a[i+1]] )dp[i+1][0] += dp[i][0];\n        if( i+2<n && a[i]<a[i+1] &&!prime[a[i+1]] )dp[i+1][1] += dp[i][0];\n\n        // 2\n\n        if( i+2<n && a[i]<a[i+2] &&!prime[a[i+2]] )dp[i+2][0] += dp[i][1];\n        if( i+3<n && a[i]<a[i+2] &&!prime[a[i+2]] )dp[i+2][1] += dp[i][1];\n\n        dp[i+1][0]%=1000000007;\n        dp[i+1][1]%=1000000007;\n        dp[i+2][0]%=1000000007;\n        dp[i+2][1]%=1000000007;\n    }\n    cout<<(dp[n-1][0]+dp[n-2][1])%1000000007<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  vector<vint> dp(2, vint(n+1, 0));\n  dp[0][0] = 1;\n  dp[1][0] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(q[i-1] < q[i]) (dp[0][i] += dp[0][i-1]) %= mod;\n      if(i>1&&q[i-2] < q[i]) (dp[0][i] += dp[1][i-1]) %= mod;\n    }\n    (dp[1][i] += dp[0][i-1]) %= mod;\n  }\n  cout << (dp[0][n-1]+dp[1][n-1])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<ll,ll> pint;\n\nll dp[100003];\nconst int max_n=1000001;\nbool is_prime[max_n];\nint prime[max_n];\nint sieve(int n){\n    int p=0;\n    rep(i,n+1) is_prime[i]=true;\n    is_prime[0]=is_prime[1]=false;\n    FOR(i,2,n+1){\n        if(is_prime[i]){\n            prime[p++]=i;\n            for(int j=2*i;j<=n;j+=i) is_prime[j]=false;\n        }\n    }\n    return p;\n}\nint q[100001];\nconst int mod=1000000007;\nint main(){\n    int n;\n    cin>>n;\n    sieve(1000000);\n    dp[0]=1;\n    rep(i,n) cin>>q[i];\n    rep(i,n){\n        if(i+2<=n&&is_prime[q[i]]&&(i+2==n||q[i+2]>q[i])){\n            dp[i+2]+=dp[i];\n            dp[i+2]%=mod;\n        }\n        if(is_prime[q[i]]&&(i+1==n||q[i+1]>q[i])){\n            dp[i+1]+=dp[i];\n            dp[i+1]%=mod;\n        }\n    }\n    cout<<dp[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nconstexpr int Q_MAX = 1000006;\nbool is_prime[Q_MAX];\nvoid init() {\n    rep(i, Q_MAX) is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n    rep(i, Q_MAX) if (i >= 2) {\n        if (is_prime[i]) {\n            for (int j = i * 2; j < Q_MAX; j += i) is_prime[j] = false;\n        }\n    }\n}\n\nint n,a[1<<17];\nlong long dp[1<<17];\nlong long mod=1e9+7;\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tinit();\n\tif(n==1)\n\t{\n\t\tcout<<is_prime[a[0]]<<endl;\n\t\treturn 0;\n\t}\n\tdp[0]=is_prime[a[0]];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(!is_prime[a[i]])continue;\n\t\tif(is_prime[a[i+2]]&&a[i+2]>a[i])dp[i+2]=(dp[i+2]+dp[i])%mod;\n\t\tif(is_prime[a[i+1]]&&a[i+1]>a[i])dp[i+1]=(dp[i+1]+dp[i])%mod;\n\t}\n\tcout<<((dp[n-1]+dp[n-2])%mod)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define LOOP(i,x,n) for(int i=x;i<n;i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\n\nconst int MOD=1e9+7;\nconst int INF=1e10;\nconst int MAX_N = 1123456;\nbool isPrime[MAX_N];\nvoid e(){\n  REP(i,MAX_N){\n    isPrime[i]=true;\n  }\n  isPrime[0]=isPrime[1]=false;\n  REP(i,MAX_N){\n    if(isPrime[i]){\n      for(int j = i+i;j<MAX_N;j+=i){\n        isPrime[j]=false;\n      }\n    }\n  }\n}\nbool Is_Prime(int n){\n  return isPrime[n];\n}\nint dp[100005];\nsigned main(){\n  e();\n  int n;\n  cin>>n;\n  vector<int> q(n);\n  REP(i,n)cin>>q[i];\n  if(Is_Prime(q[0]))dp[0]=1;\n  REP(i,n){\n    //cout<<dp[i]<<endl;\n    if(i+2<n&&q[i]<q[i+2]&&Is_Prime(q[i+2])){\n      dp[i+2]+=dp[i];\n      dp[i+2]%=MOD;\n    }\n    if(i+1<n&&q[i]<q[i+1]&&Is_Prime(q[i+1])){\n      dp[i+1]+=dp[i];\n      dp[i+1]%=MOD;\n    }\n  }\n  cout<<(dp[n-1]+dp[n-2])%MOD<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct prime_num{\n    int number;\n    bool if_prime_num;\n};\n\nvector<prime_num> prime_nums;\n\nlong dp[int(2e5)];\n\nlong choose(int now){\n    if(dp[now] != -1){\n        return dp[now];\n    }else if(now >= int(prime_nums.size()) - 1){\n        return dp[now] = 1;\n    }else if(!prime_nums[now].if_prime_num && prime_nums[now].number < prime_nums[now + 1].number){\n        return dp[now] = choose(now + 1);\n    }else if(!prime_nums[now].if_prime_num){\n        return dp[now] = 0;\n    }else if(!prime_nums[now + 1].if_prime_num && prime_nums[now].number < prime_nums[now + 1].number){\n        return dp[now] = choose(now + 1);\n    }else if(!prime_nums[now + 1].if_prime_num){\n        return dp[now] = 0;\n    }else if(now == int(prime_nums.size()) - 2 && prime_nums[now].number < prime_nums[now + 1].number){\n        return dp[now] = 2;\n    }else if(now == int(prime_nums.size()) - 2){\n        return dp[now] = 1;\n    }else if(prime_nums[now].number < prime_nums[now + 1].number && prime_nums[now].number < prime_nums[now + 2].number){\n        return dp[now] = (choose(now + 1) + choose(now + 2)) % long(1e9 + 7);\n    }else if(prime_nums[now].number < prime_nums[now + 1].number){\n        return dp[now] = choose(now + 1);\n    }else if(prime_nums[now].number < prime_nums[now + 2].number){\n        return dp[now] = choose(now + 2);\n    }else{\n        return dp[now] = 0;\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    int if_prime[int(2e6)];\n    fill(if_prime, if_prime + int(2e6), -1);\n    if_prime[0] = 0;\n    if_prime[1] = 0;\n    for(int i = 2; i * i <= int(2e6); i++){\n        if(if_prime[i] == -1){\n            if_prime[i] = 1;\n            for(int j = i * 2; j < int(2e6); j += i){\n                if_prime[j] = 0;\n            }\n        }\n    }\n    int nums[N];\n    for(int i = 0; i < N; i++){\n        cin >> nums[i];\n    }\n    if(!if_prime[nums[0]]){\n        cout << 0 << endl;\n        return 0;\n    }\n    prime_nums.push_back({nums[0], true});\n    for(int i = 1; i < N; i++){\n        if(!if_prime[nums[i - 1]] && !if_prime[nums[i]]){\n            cout << 0 << endl;\n            return 0;\n        }else if(!if_prime[nums[i]] && prime_nums.empty()){\n            cout << 0 << endl;\n            return 0;\n        }else if(!if_prime[nums[i]]){\n            prime_num insert_item = {prime_nums.back().number, false};\n            prime_nums.pop_back();\n            prime_nums.push_back(insert_item);\n        }else{\n            prime_nums.push_back({nums[i], true});\n        }\n    }\n    fill(dp, dp + int(2e5), -1);\n    cout << choose(0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nint sosu[1000020]={0};\nint q[100002];\nint dp1[100020][2]={0};\nint dp2[100020][2]={0};\nsigned main(){\nint n,m;\n\tsosu[1]=1;\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(sosu[i]) continue;\n\t\tfor(int j=2*i;j<=1000000;j+=i)sosu[j]=1;\n\t}\n\t\n\n\tcin>>n;\n\t\n\tfor(int i=1;i<=n;i++)cin>>q[i];\n\t\n\tdp1[0][0]=1;\n\tdp1[0][1]=1;\n\tdp2[0][0]=1;\n\tdp2[0][1]=1;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(sosu[q[i]]==0){\n\t\t\tif( dp1[i-1][1]<q[i]){\n\t\t\t\tdp1[i][0]+=dp1[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tif(dp2[i-1][1]<q[i] && i>=3){\n\t\t\t\tdp1[i][0]+=dp2[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tdp1[i][0]%=inf;\n\t\t}\n\t\t\n\t\tif(sosu[q[i-1]]==0){\n\t\t\tif(dp1[i-2][1]<q[i-1] && i>=2){\n\t\t\t\tdp2[i][0]+=dp1[i-2][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tif(dp2[i-2][1]<q[i-1] && i>=4){\n\t\t\t\tdp2[i][0]+=dp2[i-1][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tdp2[i][0]%=inf;\t\t\n\t\t}\n\t\t\n\t//\tcout<<dp1[i][0]<<\" \"<<dp2[i][0]<<endl;\n\t//\tcout<<dp1[i][1]<<\" \"<<dp2[i][1]<<endl;\n\t}\n\tcout<<(dp1[n][0]+dp2[n][0])%inf<<endl;\n return 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-2]]) {\n\tif((!is_p[q[i-1]] || q[i-1] <= q[i]) && q[i-2] >= q[i]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nint sosu[1000020]={0};\nint q[100002];\nint dp1[100020][2]={0};\nint dp2[100020][2]={0};\nsigned main(){\nint n,m;\n\tsosu[1]=1;\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(sosu[i]) continue;\n\t\tfor(int j=2*i;j<=1000000;j+=i)sosu[j]=1;\n\t}\n\t\n\n\tcin>>n;\n\t\n\tfor(int i=1;i<=n;i++)cin>>q[i];\n\t\n\tdp1[0][0]=1;\n\tdp1[0][1]=1;\n\tdp2[0][0]=1;\n\tdp2[0][1]=1;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(sosu[q[i]]==0){\n\t\t\tif( dp1[i-1][1]<q[i]){\n\t\t\t\tdp1[i][0]+=dp1[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tif(dp2[i-1][1]<q[i] && i>=3){\n\t\t\t\tdp1[i][0]+=dp2[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tdp1[i][0]%=inf;\n\t\t}\n\t\t\n\t\tif(sosu[q[i-1]]==0){\n\t\t\tif(dp1[i-2][1]<q[i-1] && i>=2){\n\t\t\t\tdp2[i][0]+=dp1[i-2][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tif(dp2[i-2][1]<q[i] && i>=4){\n\t\t\t\tdp2[i][0]+=dp2[i-1][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tdp2[i][0]%=inf;\t\t\n\t\t}\n\t\t\n\t//\tcout<<dp1[i][0]<<\" \"<<dp2[i][0]<<endl;\n\t//\tcout<<dp1[i][1]<<\" \"<<dp2[i][1]<<endl;\n\t}\n\tcout<<(dp1[n][0]+dp2[n][0])%inf<<endl;\n return 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cassert>\n#include <exception>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\nll box[200010];\n\nbool prime[100010];\n\nvoid hurui(){\n  clr(prime,false);\n  prime[0] = prime[1] = true;\n  rep(i,2,100010){\n    if(!prime[i]){\n      for(int j = 2;i * j < 100010;j++)prime[i * j] = true;\n    }\n  }\n}\n\nbool isprime(ll num){\n  return !prime[num];\n}\n\nint main(){\n  hurui();\n  clr(d,0);\n  vi vec;\n  cin >> n;\n  ll p,q;\n  p = q = 0;\n  lep(i,1,n){\n    cin >> d[i];\n    if(isprime(d[i]))p++;\n    else q++;\n  }\n  bool ex = true;\n  lep(i,1,n){\n    if(prime[d[i-1]] && prime[d[i]] && prime[d[i+1]])ex = false;\n    else{\n      if(d[i] > d[i+1])vec.pb(1);\n      else if(isprime(d[i-1]) && isprime(d[i]) && isprime(d[i+1]))vec.pb(2);\n      else if(prime[d[i]] && prime[d[i+1]]){\n        vec.pb(1);\n      }else if(prime[d[i-1]] && prime[d[i]]){\n        vec.pb(1);\n      }\n    }\n  }\n  if(ex){\n    ll ans = 1;\n    rep(i,0,vec.sz){\n      ans *= vec[i];\n      ans %= INF;\n    }\n    print(ans);\n  }else{\n    puts(\"0\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\n\nint main(){\n    bool np[1000001] = {};\n    np[0] = np[1] = true;\n    for(int i = 2; i < 1000001; i++){\n        if(np[i])   continue;\n        for(int j = i+i; j < 1000001; j += i)   np[j] = true;\n    }\n\n    int n;\n    cin >> n;\n    vector<int> q(n);\n    for(int i = 0; i < n; i++)  cin >> q[i];\n\n    if(np[q[0]]){\n        cout << 0 << endl;\n        return 0;\n    }\n    if(n == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n\n    vector<vector<ll>> dp(2, vector<ll>(n,0));\n    dp[1][0] = 1;\n    dp[0][1] = 1;\n    if(!np[q[1]] && q[1] > q[0])    dp[1][1] = 1;\n    for(int i = 2; i < n; i++){\n        // 指数の肩ver\n        if(!np[q[i-1]]) dp[0][i] = (dp[0][i] + dp[1][i-1]) % mod;\n        // 素数ver\n        if(!np[q[i]]){\n            if(!np[q[i-1]] && q[i] > q[i-1]) dp[1][i] = (dp[1][i] + dp[1][i-1]) % mod;\n            if(!np[q[i-2]] && q[i] > q[i-2]) dp[1][i] = (dp[1][i] + dp[1][i-2]) % mod;\n        }\n    }\n\n    cout << (dp[0][n-1]+dp[1][n-1])%mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n#define M 1000000007\nint n,q[100005];\nll dp[2][100005];\nbool s[1000005];\nint main(void){\n    cin>>n;\n    for(int i=0;i<n;i++)cin>>q[i];\n    for(int i=2;i<=1000;i++){\n        if(!s[i]){\n            for(int j=i*2;j<=1000000;j+=i)s[j]=true;\n        }\n    }\n    if(!s[q[0]])dp[1][1]=1;\n    for(int i=1;i<n;i++){\n        dp[0][i+1]=dp[1][i];\n        if(!s[q[i]]){\n            if(i>0&&q[i-1]<q[i])dp[1][i+1]=dp[1][i];\n            if(i>1&&q[i-2]<q[i])dp[1][i+1]=(dp[1][i+1]+dp[0][i])%M;\n        }\n    }\n    cout<<(dp[0][n]+dp[1][n])%M<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long dp[100009], n, a[100009], mod = 1000000007;\nbool prime[1000009];\n\nint main() {\n\tfor (int i = 2; i <= 1000004; i++) prime[i] = true;\n\tfor (int i = 2; i <= 1000; i++) {\n\t\tfor (int j = i*i; j <= 1000000; j += i) prime[j] = false;\n\t}\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tif (prime[a[1]] == false) {\n\t\tcout << \"0\" << endl;\n\t\treturn 0;\n\t}\n\ta[n + 1] = 1000003;\n\tdp[1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i + 1] > a[i] && prime[a[i + 1]] == true) dp[i + 1] += dp[i];\n\t\tif (a[i + 2] > a[i] && prime[a[i + 2]] == true) dp[i + 2] += dp[i];\n\t\tdp[i + 1] %= mod; dp[i + 2] %= mod;\n\t}\n\tcout << dp[n + 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2870.cc: The Diversity of Prime Factorization\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int MAX_P = 1000000;\nconst int MOD = 1000000007;\n\n/* typedef */\n\n/* global variables */\n\nbool primes[MAX_P + 1];\nint qs[MAX_N], dp[MAX_N][2];\n\n/* subroutines */\n\nvoid gen_primes(int maxp) {\n  memset(primes, true, sizeof(primes));\n  primes[0] = primes[1] = false;\n\n  for (int p = 2; p * p <= maxp; p++)\n    if (primes[p])\n      for (int q = p * p; q <= maxp; q += p) primes[q] = false;\n}\n\ninline void addmod(int &a, int b) { a = (a + b) % MOD; }\n\n/* main */\n\nint main() {\n  gen_primes(MAX_P);\n\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 0; i < n; i++) scanf(\"%d\", qs + i);\n\n  if (! primes[qs[0]]) {\n    puts(\"0\");\n    return 0;\n  }\n\n  dp[0][0] = 1;\n  for (int i = 1; i < n; i++) {\n    if (primes[qs[i]]) {\n      if (primes[qs[i - 1]] && qs[i - 1] < qs[i])\n\taddmod(dp[i][0], dp[i - 1][0]);\n      if (i >= 2 && primes[qs[i - 2]] && qs[i - 2] < qs[i])\n\taddmod(dp[i][0], dp[i - 1][1]);\n    }\n\n    dp[i][1] = dp[i - 1][0];\n  }\n  //for (int i = 0; i < n; i++) printf(\"%d,%d \", dp[i][0], dp[i][1]);\n\n  printf(\"%d\\n\", (dp[n - 1][0] + dp[n - 1][1]) % MOD);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-2]] && q[i-2] >= q[i]) {\n\tif(!is_p[q[i-1]]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t} else if(q[i-1] <= q[i]) {\n\t  dp[0][i+1] = 0;\n\t  dp[1][i+1] = dp[0][i];\n\t  continue;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(auto i = a; i < b; i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nint n;\nint q[100010];\nvector <bool> sosu;\n\nvector <bool> eratosthenes(int n) {\n\tvector <bool> prime(n + 1, true);\n\tprime = vector <bool> (n + 1, true);\n\tif(n >= 0) prime[0] = false;\n\tif(n >= 1) prime[1] = false;\n\tfor(int i = 2; i * i <= n; i++)\n\t\tif(prime[i])\n\t\t\tfor(int j = i * 2; j < n; j += i)\n\t\t\t\tprime[j] = false;\n\treturn prime;\n}\n\nlong long solve(int i = 0, int prevSosu = 1, int prevIsE = true) {\n\tint pear = 1, berry = 1;\n\tbool flaga = false, flagb = false;\n\tif (i == n) {\n\t\treturn 1;\n\t}\n\tif (sosu[q[i]] && prevSosu < q[i]) {\n\t\tpear *= solve(i + 1, q[i], false);\n\t\tflaga = true;\n\t}\n\tif (!prevIsE) {\n\t\tberry *= solve(i + 1, prevSosu, true);\n\t\tflagb = true;\n\t}\n\tpear *= flaga;\n\tberry *= flagb;\n\treturn pear + berry;\n}\n\n\nsigned main() {\n\tcin >> n;\n\trep (i, n) cin >> q[i];\n\tsosu = eratosthenes(1000000);\n\tcout << solve() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<ll,ll> pint;\n\nll dp[100003];\nconst int max_n=1000001;\nbool is_prime[max_n];\nint sieve(int n){\n    int p=0;\n    rep(i,n+1) is_prime[i]=true;\n    is_prime[0]=is_prime[1]=false;\n    FOR(i,2,n+1){\n        if(is_prime[i]){\n            for(int j=2*i;j<=n;j+=i) is_prime[j]=false;\n        }\n    }\n    return p;\n}\nint q[100001];\nconst int mod=1000000007;\nint main(){\n    int n;\n    cin>>n;\n    sieve(1000000);\n    dp[0]=1;\n    rep(i,n) cin>>q[i];\n    rep(i,n){\n        if(i+2<=n&&is_prime[q[i]]&&(i+2==n||q[i+2]>q[i])){\n            dp[i+2]+=dp[i];\n            dp[i+2]%=mod;\n        }\n        if(is_prime[q[i]]&&(i+1==n||q[i+1]>q[i])){\n            dp[i+1]+=dp[i];\n            dp[i+1]%=mod;\n        }\n    }\n    cout<<dp[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> prime_nums;\n\nlong dp[int(2e5)];\n\nlong choose(int now){\n    if(dp[now] != -1){\n        return dp[now];\n    }else if(now >= int(prime_nums.size()) - 1){\n        return dp[now] = 1;\n    }else if(now == int(prime_nums.size()) - 2 && prime_nums[now] < prime_nums[now + 1]){\n        return dp[now] = 2;\n    }else if(now == int(prime_nums.size()) - 2){\n        return dp[now] = 1;\n    }else if(prime_nums[now] < prime_nums[now + 1] && prime_nums[now] < prime_nums[now + 2]){\n        return dp[now] = (choose(now + 1) + choose(now + 2)) % long(1e9 + 7);\n    }else if(prime_nums[now] < prime_nums[now + 1]){\n        return dp[now] = choose(now + 1);\n    }else if(prime_nums[now] < prime_nums[now + 2]){\n        return dp[now] = choose(now + 2);\n    }else{\n        return dp[now] = 0;\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    int if_prime[int(2e6)];\n    fill(if_prime, if_prime + int(2e6), -1);\n    if_prime[0] = 0;\n    if_prime[1] = 0;\n    for(int i = 2; i * i <= int(2e6); i++){\n        if(if_prime[i] == -1){\n            if_prime[i] = 1;\n            for(int j = i * 2; j < int(2e6); j += i){\n                if_prime[j] = 0;\n            }\n        }\n    }\n    int nums[N];\n    for(int i = 0; i < N; i++){\n        cin >> nums[i];\n    }\n    if(!if_prime[nums[0]]){\n        cout << 0 << endl;\n        return 0;\n    }\n    prime_nums.push_back(nums[0]);\n    for(int i = 1; i < N; i++){\n        if(!if_prime[nums[i - 1]] && !if_prime[nums[i]]){\n            cout << 0 << endl;\n            return 0;\n        }else if(!if_prime[nums[i]] && prime_nums.empty()){\n            cout << 0 << endl;\n            return 0;\n        }else if(!if_prime[nums[i]]){\n            prime_nums.pop_back();\n        }else{\n            prime_nums.push_back(nums[i]);\n        }\n    }\n    fill(dp, dp + int(2e5), -1);\n    cout << choose(0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007LL;\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<ll> P(N);\n  REP(i, 0, N) cin >> P[i];\n\n  const ll PMAX = 1000001;\n  vector<bool> prime(PMAX, true);\n  prime[1] = false;\n  REP(i, 2, PMAX) if(prime[i]) for(ll j = i + i; j < PMAX; j += i) prime[j] = false;\n\n  vector<ll> dp1(N, 0), dp2(N, 0);\n  REP(i, 0, N) {\n    if(i == 0) {\n      if(prime[P[i]]) (dp1[i] += 1) %= MOD;\n    } else if(i == 1) {\n      if(prime[P[i]] && P[i - 1] < P[i]) (dp1[i] += dp1[i - 1]) %= MOD;\n      if(prime[P[i - 1]]) (dp2[i] += 1) %= MOD;\n    } else if(i == 2) {\n      if(prime[P[i]] && P[i - 1] < P[i]) (dp1[i] += dp1[i - 1]) %= MOD;\n      if(prime[P[i]] && P[i - 2] < P[i]) (dp1[i] += dp2[i - 1]) %= MOD;\n      if(prime[P[i - 1]] && P[i - 2] < P[i - 1]) (dp2[i] += dp1[i - 2]) %= MOD;\n    } else {\n      if(prime[P[i]] && P[i - 1] < P[i]) (dp1[i] += dp1[i - 1]) %= MOD;\n      if(prime[P[i]] && P[i - 2] < P[i]) (dp1[i] += dp2[i - 1]) %= MOD;\n      if(prime[P[i - 1]] && P[i - 2] < P[i - 1]) (dp2[i] += dp1[i - 2]) %= MOD;\n      if(prime[P[i - 1]] && P[i - 3] < P[i - 1]) (dp2[i] += dp2[i - 2]) %= MOD;\n    }\n  }\n  cout << (dp1[N - 1] + dp2[N - 1]) % MOD << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day3/problems/D>\n問題文============================================================\n\n えびちゃんは素因数分解マシンの不良品を持っています。\n この機械は、2 以上の自然数 M を与えると O(logM) でその素因数分解を行ってくれますが、\n 困ったことに数字以外を表示できないバグがありました。\n \n 一般に、M の素因数分解が p1e1×p2e2×…×pKeK (ただし i<j ならば pi<pj、また各 pi は素数) の場合を考えます。\n M を与えると、この機械は i=1 から順に以下のように出力を行います。全ての数字はスペース区切りで表示されます。\n \n ei=1 ならば pi を出力する\n ei>1 ならば pi ei を出力する\n \n たとえば、22 や 2048 を与えると 2 11 と表示され、24 や 54 を与えると 2 3 3 と表示されます。\n \n さて、えびちゃんは表示された素因数分解をメモしておいたのですが、\n 与えた自然数をメモしておくのを忘れていたことに気づきました。\n 素因数分解のメモが与えられるので、元の自然数としてありえるものがいくつあるかを求めてください。\n ただし、メモが間違っていて、条件を満たす自然数が一つも存在しないこともあります。\n \n また、その個数は非常に大きくなる場合があるので、109+7 (素数) で割ったあまりを出力してください。\n \n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\n#define MAX_N 1000005\nbool is_prime[MAX_N];\nconst ll MOD = 1e9+7;\n\nbool IsPrime(int num)\n{\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2){\n        if (num % i == 0){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid init(){\n    for(int i = 1; i < MAX_N;i++){\n        is_prime[i] = IsPrime(i);\n    }\n}\nll solve(){\n    ll res = 0;\n    ll N; cin >> N;\n    vector<ll> q(N);\n    for(auto& in:q)cin >> in;\n\n    if(!is_prime[q[0]]) return 0;\n\n    int cnt = 0;\n    for(int i = 0; i < N;i++){\n        if(!is_prime[q[i]]) cnt++;\n        else cnt = 0;\n        if(cnt == 2) return 0;\n    }\n\n    vector<ll> dp(N+1,0);\n    dp[0] = 1;\n    for(int i = 0; i < N;i++){\n        if(is_prime[q[i]]){\n            if((i < N || is_prime[q[i+1]]) && (q[i] < q[i+1])){\n                (dp[i+1] += dp[i])%=MOD;\n            }\n            if((i < N-1 || is_prime[q[i+2]])&& (q[i] < q[i+2])){\n                (dp[i+2] += dp[i])%=MOD;\n            }\n        }\n    }\n    return dp[N];\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    init();\n    cout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n;\nll a[100100];\nll dp[2][100100];\nbool used[1001000];\n\nvector<int> prime;\nbool is_prime[1001000];\n\nint sieve(int n) {//n以下の素数の数を返す\n\tint p = 0;\n\tfor (int i = 0; i <= n; i++)is_prime[i] = 1;\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tfor (int j = 2 * i; j <= n; j += i)is_prime[j] = 0;\n\t\t}\n\t}\n\treturn p;\n}\n\nint main() {\n\tsieve(1001000);\n\tcin >> n;\n\trep(i, n)cin >> a[i];\n\tif (!is_prime[a[0]])cout << 0 << endl;\n\telse {\n\t\tused[a[0]] = 1;\n\t\tdp[0][0] = 1;\n\t\tll maxp = a[0];\n\t\tFOR(i, 1, n) {\n\t\t\tif (maxp <= a[i] && is_prime[a[i]]) {\n\t\t\t\tif(!used[a[i]])dp[0][i] = mod_add(dp[0][i - 1], dp[0][i]);\n\t\t\t\tdp[0][i] = mod_add(dp[1][i - 1], dp[0][i]);\n\t\t\t\tused[a[i]] = 1;\n\t\t\t\tmaxp = a[i];\n\t\t\t}\n\t\t\tdp[1][i] = mod_add(dp[0][i - 1], dp[1][i]);\n\t\t}\n\t\t//rep(i, n)cout << dp[0][i] << \" \";\n\t\t//cout << endl;\n\t\t//rep(i, n)cout << dp[1][i] << \" \";\n\t\t//cout << endl;\n\t\tcout << mod_add(dp[0][n - 1], dp[1][n - 1]) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day3/problems/D>\n問題文============================================================\n\n えびちゃんは素因数分解マシンの不良品を持っています。\n この機械は、2 以上の自然数 M を与えると O(logM) でその素因数分解を行ってくれますが、\n 困ったことに数字以外を表示できないバグがありました。\n \n 一般に、M の素因数分解が p1e1×p2e2×…×pKeK (ただし i<j ならば pi<pj、また各 pi は素数) の場合を考えます。\n M を与えると、この機械は i=1 から順に以下のように出力を行います。全ての数字はスペース区切りで表示されます。\n \n ei=1 ならば pi を出力する\n ei>1 ならば pi ei を出力する\n \n たとえば、22 や 2048 を与えると 2 11 と表示され、24 や 54 を与えると 2 3 3 と表示されます。\n \n さて、えびちゃんは表示された素因数分解をメモしておいたのですが、\n 与えた自然数をメモしておくのを忘れていたことに気づきました。\n 素因数分解のメモが与えられるので、元の自然数としてありえるものがいくつあるかを求めてください。\n ただし、メモが間違っていて、条件を満たす自然数が一つも存在しないこともあります。\n \n また、その個数は非常に大きくなる場合があるので、109+7 (素数) で割ったあまりを出力してください。\n \n=================================================================\n\n解説=============================================================\n \n x y z\n と素数(x<y<z)が並んでいるとすると\n 直接zに繋がる遷移としては\n y^1 z\n x^y z\n の二通りが考えられる\n \n ここで dp[i] := i番目にある素数を見たときの場合の数とすると\n \n q[i] is prime という条件のもとで\n     if q[i+1] is prime  && q[i] < q[i+1] then\n         dp[i+1] += dp[i] ( x^y )\n     if q[i+2] is prime && q[i] < q[i+2] then\n         dp[i+2] += dp[i] ( x^y z )\n \n と遷移できる\n \n 出力は dp[N-1] + dp[N-2]    ( y^1 z のパターン と x^y z のパターン)\n================================================================\n*/\n\n#define MAX_N 1000005\nbool is_prime[MAX_N];\nconst ll MOD = 1e9+7;\n\nbool IsPrime(int num)\n{\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2){\n        if (num % i == 0){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid init(){\n    for(int i = 1; i < MAX_N;i++){\n        is_prime[i] = IsPrime(i);\n    }\n}\nll solve(){\n    ll N; cin >> N;\n    vector<ll> q(N);\n    for(auto& in:q)cin >> in;\n\n    if(!is_prime[q[0]]) return 0;\n    if(N == 1) return 1;\n    \n    int cnt = 0;\n    for(int i = 0; i < N;i++){\n        if(!is_prime[q[i]]) cnt++;\n        else cnt = 0;\n        if(cnt == 2) return 0;\n    }\n\n    vector<ll> dp(N+1,0);\n    dp[0] = 1;\n    for(int i = 0; i < N;i++){\n        if(is_prime[q[i]]){\n            if( i+1 < N && is_prime[q[i+1]] && (q[i] < q[i+1])){\n                (dp[i+1] += dp[i])%=MOD;\n            }\n            if( i+2 < N && is_prime[q[i+2]] && (q[i] < q[i+2])){\n                (dp[i+2] += dp[i])%=MOD;\n            }\n        }\n    }\n    return (dp[N-1]+dp[N-2])%MOD;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    init();\n    cout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(iinclude<snt i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\ntypedef pair<int, P> speP;\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint h, w;\nchar mp[50][50];\nint d[50][50];\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> a(n+1);\n\trep(i, n)cin >> a[i+1];\n\tvector<ll> dp(n+1), dp2(n+1);\n\tvector<int> isprime(1000001, 1);\n\tisprime[0] = isprime[1] = 0;\n\tfor (int i = 2; i <= 1000000; ++i) {\n\t\tif (!isprime[i])continue;\n\t\tfor (int j = 2 * i; j <= 1000000; j += i) {\n\t\t\tisprime[j] = false;\n\t\t}\n\t}\n\tdp[0] = 1;\n\trep(i, n) {\n\t\tdp[i + 1] += dp2[i];\n\t\tif (a[i + 1] > a[i] && isprime[a[i + 1]])(dp2[i + 1] += dp2[i])%=mod;\n\t\tif (i >= 1 && a[i + 1] > a[i - 1] && isprime[a[i + 1]])(dp2[i + 1] += dp[i]) %= mod;\n\t\tif (i ==0  && isprime[a[i + 1]])dp2[i + 1] += dp[i];\n\t}\n\tcout << (dp[n] + dp2[n]) % mod << endl;\n\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n    is_p.resize(N, true);\n    is_p[0] = is_p[1] = false;\n    for(int i = 2; i*i <= N; i++) {\n        if(!is_p[i]) continue;\n        for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n    }\n}\n\nsigned main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout << fixed << setprecision(12);\n    \n    const int MAX_Q = 1000000;\n    \n    vector<bool> is_p;\n    enum_prime(MAX_Q, is_p);\n    \n    int n;\n    cin >> n;\n    vint q(n);\n    rep(i, n) cin >> q[i];\n    sort(all(q));\n    if(!is_p[q[0]]) {\n        cout << 0 << endl;\n        return 0;\n    } else {\n        bool flag = true;\n        rep(i, n-1) {\n            if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;a\n        }\n        if(!flag) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n    \n    vector<vint> dp(2, vint(n+1, -1));\n    dp[0][1] = 1;\n    dp[1][1] = 0;\n    reps(i, 1, n) {\n        if(is_p[q[i]]) {\n            if(i > 1 && is_p[q[i-1]] && is_p[q[i-2]]) {\n                if(q[i-1] == q[i] && q[i-2] >= q[i]) {\n                    cout << 0 << endl;\n                    return 0;\n                }\n            }\n            if(is_p[q[i-1]] && q[i-1] > q[i]) {\n                dp[0][i+1] = 0;\n                dp[1][i+1] = dp[0][i];\n            } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n                dp[0][i+1] = dp[1][i];\n                dp[1][i+1] = dp[0][i];\n            } else {\n                dp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n                dp[1][i+1] = dp[0][i];\n            }\n        } else {\n            dp[0][i+1] = 0;\n            dp[1][i+1] = dp[0][i];\n        }\n    }\n    cout << (dp[0][n]+dp[1][n])%mod << endl;\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector<int> sieve_of_eratosthenes(int n) {\n\tvector<int> primes(n);\n\tfor (int i = 2; i < n; ++i)\n\t\tprimes[i] = i;\n\tfor (int i = 2; i*i < n; ++i)\n\t\tif (primes[i])\n\t\t\tfor (int j = i*i; j < n; j += i)\n\t\t\t\tprimes[j] = 0;\n\treturn primes;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector<int> primes = sieve_of_eratosthenes(1000005);\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tvector<int> B;\n\tvector<int> C;\n\tbool f1, f2, f3;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i > 0) {\n\t\t\tf1 = (primes[A[i - 1]] != 0);\n\t\t}\n\t\telse {\n\t\t\tf1 = false;\n\t\t}\n\t\tf2 = (primes[A[i]] != 0);\n\t\tif (i < N - 1) {\n\t\t\tf3 = (primes[A[i + 1]] != 0);\n\t\t}\n\t\telse {\n\t\t\tf3 = true;\n\t\t}\n\t\tif (!f2 && !f3) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!f1 && !f2) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (f2) {\n\t\t\tif (!f1) {\n\t\t\t\tB.push_back(A[i]);\n\t\t\t\tC.push_back(1);\n\t\t\t}\n\t\t\telse if (!f3) {\n\t\t\t\tB.push_back(A[i]);\n\t\t\t\tC.push_back(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tB.push_back(A[i]);\n\t\t\t\tC.push_back(0);\n\t\t\t}\n\n\t\t}\n\t}\n\t/*for (int i = 0; i < B.size(); i++) {\n\t\tcerr << B[i] << \" \";\n\t}\n\tcerr << endl;\n\tfor (int i = 0; i < C.size(); i++) {\n\t\tcerr << C[i] << \" \";\n\t}\n\tcerr << endl;*/\n\tvector<vector<int> > dp((int)B.size() + 1, vector<int>(3, 0));\n\tdp[0][1] = 1;\n\tfor (int i = 1; i < B.size(); i++) {\n\t\t//for (int k = 0; k < 3; k++) {\n\t\t\tif (C[i] == 0) {\n\t\t\t\tif (i > 0 && B[i] > B[i - 1]) {\n\t\t\t\t\tdp[i][1] = dp[i - 1][1];\n\t\t\t\t}\n\t\t\t\tif (i <= 1 || B[i] > B[i - 2]) {\n\t\t\t\t\tdp[i][1] = (dp[i][1] + dp[i - 1][0]) % MOD;\n\t\t\t\t}\n\t\t\t\tdp[i][0] = (dp[i][0] + dp[i - 1][1]) % MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i > 0 && B[i] > B[i - 1]) {\n\t\t\t\t\tdp[i][1] = dp[i - 1][1];\n\t\t\t\t}\n\t\t\t\tif (i <= 1 || B[i] > B[i - 2]) {\n\t\t\t\t\tdp[i][1] = (dp[i][1] + dp[i - 1][0]) % MOD;\n\t\t\t\t}\n\t\t\t\tdp[i][0] = 0;\n\t\t\t}\n\t\t//}\n\t}\n\t/*for (int i = 0; i < dp.size(); i++) {\n\t\tcerr << dp[i][0] << \" \";\n\t}\n\tcerr << endl;\n\tfor (int i = 0; i < dp.size(); i++) {\n\t\tcerr << dp[i][1] << \" \";\n\t}\n\tcerr << endl;*/\n\tcout << (dp[B.size() - 1][0] + dp[B.size() - 1][1])%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MAX = 1e6+10;\n  vector<Int> p(MAX,0);\n  for(Int i=2;i<MAX;i++){\n    if(p[i]) continue;\n    for(Int j=i+i;j<MAX;j+=i) p[j]=1;\n  }\n  Int n;\n  cin>>n;\n  vector<Int> q(n);\n  for(Int i=0;i<n;i++) cin>>q[i];\n\n  vector<Int> dp(n+1,0);\n  const Int MOD = 1e9+7;\n  dp[0]=!p[q[0]];\n  for(Int i=0;i<n;i++){\n    if(i+1==n) (dp[i+1]+=dp[i])%=MOD;\n    if(i+2==n) (dp[i+2]+=dp[i])%=MOD;\n\n    if(i+1<n&&!p[q[i+1]]&&q[i]<q[i+1]) (dp[i+1]+=dp[i])%=MOD;\n    if(i+2<n&&!p[q[i+2]]&&q[i]<q[i+2]) (dp[i+2]+=dp[i])%=MOD;\n  }\n\n  cout<<dp[n]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nint sosu[1000020]={0};\nint q[100002];\nint dp1[100020][2]={0};\nint dp2[100020][2]={0};\nsigned main(){\nint n,m;\n\tsosu[1]=1;\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(sosu[i]) continue;\n\t\tfor(int j=2*i;j<=1000000;j+=i)sosu[j]=1;\n\t}\n\t\n\n\tcin>>n;\n\t\n\tfor(int i=1;i<=n;i++)cin>>q[i];\n\t\n\tdp1[0][0]=1;\n\tdp1[0][1]=1;\n\tdp2[0][0]=1;\n\tdp2[0][1]=1;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(sosu[q[i]]==0){\n\t\t\tif( dp1[i-1][1]<q[i]){\n\t\t\t\tdp1[i][0]+=dp1[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tif(dp2[i-1][1]<q[i] && i>=3){\n\t\t\t\tdp1[i][0]+=dp2[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tdp1[i][0]%=inf;\n\t\t}\n\t\t\n\t\tif(sosu[q[i-1]]==0){\n\t\t\tif(dp1[i-2][1]<q[i-1]){\n\t\t\t\tdp2[i][0]+=dp1[i-2][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tif(dp2[i-2][1]<q[i] && i>=4){\n\t\t\t\tdp2[i][0]+=dp2[i-1][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tdp2[i][0]%=inf;\t\t\n\t\t}\n\t\t\n\t//\tcout<<dp1[i][0]<<\" \"<<dp2[i][0]<<endl;\n\t//\tcout<<dp1[i][1]<<\" \"<<dp2[i][1]<<endl;\n\t}\n\tcout<<(dp1[n][0]+dp2[n][0])%inf<<endl;\n return 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\n\nbool isPrime(ll x){\n  if(x<2)return false;\n  for(ll i=2;i*i<=x;i++)\n    if(x%i==0)return false;\n  return true;\n}\n\nint n;\nll a[100005];\nll dp[100005][2];\n\nint main(){\n  cin>>n;\n  for(int i=1;i<=n;i++)cin>>a[i];\n  \n  dp[0][0]=1;\n\n  for(int i=1;i<=n;i++){\n    \n    if( isPrime(a[i]) ){\n      if(a[i] > a[i-1] &&i-1>=0){\n        dp[i][0]+=dp[i-1][0];\n      }\n      if(a[i] > a[i-2] &&i-2>=0){\n        dp[i][0]+=dp[i-1][1];\n      }\n    }\n\n    if( isPrime(a[i-1]) &&i-1>=0 ){\n      if( a[i-1] > a[i-2] &&i-2>=0){\n        dp[i][1]+=dp[i-2][0];\n      }\n      if( a[i-1] > a[i-3] &&i-3>=0){\n        dp[i][1]+=dp[i-2][1];\n      }\n    }\n\n    dp[i][0]%=mod;\n    dp[i][1]%=mod;\n  }\n  \n  cout<< (dp[n][0]+dp[n][1])   % mod <<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\n// x > 0\nbool isPrime(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return n != 1;\n}\n\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  int n;\n  cin >> n;\n  vi a(n + 2);\n  a[0] = 1;\n  rep(i, n) cin >> a[i + 1];\n  a.back() = mod;\n\n  vi dp(n + 2, 0);\n  if (!isPrime(a[1])) {\n    cout << 0 << endl;\n    return 0;\n  }\n  dp[1] = 1;\n\n  rep2(i, 2, n + 2) {\n    if (isPrime(a[i])) {\n      if (a[i] > a[i - 1]) dp[i] += dp[i - 1];\n      if (a[i] > a[i - 2]) dp[i] += dp[i - 2];\n      dp[i] %= mod;\n    }\n  }\n\n  cout << dp.back() << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n;\nint q[100000 + 5];\nint dp[100000 + 5];\nbool prime[100000 + 5];\n\nbool isPrime(ll x) {\n    if (x == 2) return true;\n    else if (x < 2 || x % 2 == 0) return false;\n    else {\n        for (int i = 3; i * i <= x; i += 2) {\n            if (x % i == 0) return false;\n        }\n    }\n    return true;\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i, n) {\n      cin >> q[i];\n      prime[i] = isPrime(q[i]);\n    }\n    q[n] = INFLL;\n    dp[0] = 1;\n    rep(i, n) {\n      if (prime[i]) {\n        if (i == n - 1) {\n          addm(dp[i + 1], dp[i]);\n        }\n        else {\n          if (prime[i + 1]) {\n            if (q[i] < q[i + 1]) {\n              addm(dp[i + 1], dp[i]);\n              if (q[i] < q[i + 2]) {\n                addm(dp[i + 2], dp[i]);\n              }\n            }\n            else {\n              if (q[i] < q[i + 2]) {\n                addm(dp[i + 2], dp[i]);\n              }\n            }\n          }\n          else {\n            if (q[i] < q[i + 2]) {\n              addm(dp[i + 2], dp[i]);\n            }\n          }\n        }\n      }\n    }\n    cout << dp[n] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nbool prime[1000009];\n \nvoid era(){\n    prime[0]=1;\n    prime[1]=1;\n    for(int i=2;i<1000009;i++){\n        if(!prime[i]){\n            for(int j=i+i;j<1000009;j+=i) prime[j]=1;\n        }\n    }\n}\n \nint dp[100009][2];\n \nsigned main(){\n    era();\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++)scanf(\"%d\",&a[i]);\n    if(!prime[a[0]]){\n        dp[0][0]=1;\n        dp[0][1]=1;\n    }\n    for(int i=0;i<n;i++){\n \n        // 1\n \n        if( i+1<n && a[i]<a[i+1] &&!prime[a[i+1]] )dp[i+1][0] += dp[i][0];\n        if( i+2<n && a[i]<a[i+1] &&!prime[a[i+1]] )dp[i+1][1] += dp[i][0];\n \n        // 2\n \n        if( i+2<n && a[i]<a[i+2] &&!prime[a[i+2]] )dp[i+2][0] += dp[i][1];\n        if( i+3<n && a[i]<a[i+2] &&!prime[a[i+2]] )dp[i+2][1] += dp[i][1];\n \n        dp[i+1][0]%=1000000007;\n        dp[i+1][1]%=1000000007;\n        dp[i+2][0]%=1000000007;\n        dp[i+2][1]%=1000000007;\n    }\n    cout<<(dp[n-1][0]+dp[n-2][1])%1000000007<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< bool > get_prime(int n) {\n  vector< bool > prime(n + 1, true);\n\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n\n  for(int i = 2; i * i <= n; i++) {\n    if(prime[i]) {\n      for(int j = i + i; j <= n; j += i) prime[j] = false;\n    }\n  }\n\n  return (prime);\n}\n\nauto table = get_prime(1000000);\nconst int mod = 1e9 + 7;\n\nint N, Q[100000];\nint dp[100000];\n\nint rec(int idx) {\n  if(idx == N) return 1;\n  if(~dp[idx]) return dp[idx];\n  if(!table[Q[idx]]) return dp[idx] = 0;\n  int ret = 0;\n  if(idx + 1 == N || Q[idx] < Q[idx + 1]) {\n    (ret += rec(idx + 1)) %= mod;\n  }\n  if(idx + 1 < N) {\n    if(Q[idx + 1] > 1) {\n      if(idx + 2 == N || Q[idx] < Q[idx + 2]) {\n        (ret += rec(idx + 2)) %= mod;\n      }\n    }\n  }\n  return dp[idx] = ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> Q[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid eratosthenes(int N, int* arr){\n  for(int i=0; i < N; i++){\n    arr[i] = 1;\n  }\n  for(int i=2; i < sqrt(N); i++){\n    if(arr[i]){\n      for(int j=0; i * (j + 2) < N; j++){\n        arr[i*(j+2)] = 0;\n      }\n    }\n  }\n}\n\nint main(void){\n  const int NMAX = 100002;\n  const int QMAX = 1000001;\n  const int MOD = 1e9+7;\n  int dp[NMAX][2]; // dp[idx][自分が素因数(0)か肩(1)か]\n  int isprime[QMAX];\n  for(int i = 0; i < NMAX; i++) for(int j = 0; j < 2; j++) dp[i][j] = 0;\n  eratosthenes(QMAX, isprime);\n\n\n\n  int N; cin >> N;\n  vector<int> q(N);\n  for(int i = 0; i < N; i++) cin >> q[i];\n  q.push_back(0);\n\n  if(isprime[q[0]])\n    dp[0][0] = 1;\n\n  for(int i = 0; i < N-1; i++){\n    for(int j = 0; j < 2; j++){\n      if(j == 0){\n        dp[i+1][1] = (dp[i+1][1] + dp[i][j]) % MOD;\n        if(q[i+1] > q[i] && isprime[q[i+1]]){\n          dp[i+1][0] = (dp[i+1][0] + dp[i][j]) % MOD;\n        }\n      }else{\n        if((i == 0 || q[i+1] > q[i-1]) && isprime[q[i+1]]){\n          dp[i+1][0] = (dp[i+1][0] + dp[i][j]) % MOD;\n        }\n      }\n    }\n  }\n  cout << (dp[N-1][0] + dp[N-1][1]) % MOD << endl;\n  return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define mod 1000000007\nusing namespace std;\n\nbool prime[1000010];\nlong long dp[1000000];\nint q[1000000];\n\nint main(){\n\trep(i,1000000)prime[i]=true;\n\tprime[0]=prime[1]=false;\n\tloop(i,2,1000000){\n\t\tfor(int j=2*i;j<1000000;j+=i)prime[j]=false;\n\t}\n\tint n;\n\tcin>>n;\n\trep(i,n)cin>>q[i];\n\tdp[1]=(prime[q[0]]?1:0);\n\tloop(i,1,n+1){\n\t\tdp[i]%=mod;\n\t\tif(prime[q[i+1]]&&q[i-1]<q[i+1])dp[i+2]+=dp[i];\n\t\tif(prime[q[i]]&&q[i-1]<q[i])dp[i+1]+=dp[i];\n\t}\n\tcout<<(dp[n]+dp[n-1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nint sosu[1000020]={0};\nint q[100002];\nint dp1[100020][2]={0};\nint dp2[100020][2]={0};\nsigned main(){\nint n,m;\n\tsosu[1]=0;\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(sosu[i]) continue;\n\t\tfor(int j=2*i;j<=1000000;j+=i)sosu[j]=1;\n\t}\n\t\n\n\tcin>>n;\n\t\n\tfor(int i=1;i<=n;i++)cin>>q[i];\n\t\n\tdp1[0][0]=1;\n\tdp1[0][1]=1;\n\tdp2[0][0]=1;\n\tdp2[0][1]=1;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(sosu[q[i]]==0){\n\t\t\tif(sosu[q[i-1]]==0)if( q[i-1]<q[i]){\n\t\t\t\tdp1[i][0]+=dp1[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tif(sosu[q[i-2]]==0)if(q[i-2]<q[i] && i>=3){\n\t\t\t\tdp1[i][0]+=dp2[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tdp1[i][0]%=inf;\n\t\t}\n\t\t\n\t\tif(sosu[q[i-1]]==0){\n\t\t\tif(sosu[q[i-2]]==0)if(q[i-2]<q[i-1] && i>=2){\n\t\t\t\tdp2[i][0]+=dp1[i-2][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tif(sosu[q[i-3]]==0)if(q[i-3]<q[i-1] && i>=4){\n\t\t\t\tdp2[i][0]+=dp2[i-1][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tdp2[i][0]%=inf;\t\t\n\t\t}\n\t\t\n\t//\tcout<<dp1[i][0]<<\" \"<<dp2[i][0]<<endl;\n\t//\tcout<<dp1[i][1]<<\" \"<<dp2[i][1]<<endl;\n\t}\n\tcout<<(dp1[n][0]+dp2[n][0])%inf<<endl;\n return 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\nchar prime[1000005];\nvoid init_prime() {\n    fill(prime, prime+1000005, 1);\n    prime[0] = prime[1] = 0;\n    for (int x = 2; x <= 1000000; ++x) {\n        if (prime[x]) {\n            for (int y = x*x; y <= 1000000; y += x) prime[y] = 0;\n        }\n    }\n\n}\n\nll N, Q[101010];\n\nll memo[101010];\n\nint main() {\n    init_prime();\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N;\n    for (int j = 1; j <= N; ++j) cin >> Q[j];\n    reverse(Q+1, Q+N+1);\n\n    fill(memo, memo+N+1, 0);\n    memo[0] = 1;\n    memo[1] = prime[Q[1]] ? 1 : 0;\n\n    for (int j = 2; j <= N; ++j) {\n        if (prime[Q[j]]) {\n            if (Q[j-1] > Q[j]) {\n                memo[j] = (memo[j] + memo[j-1]) % MOD;\n            }\n\n            if (Q[j-1] > 1 && (j < 3 || (prime[Q[j-2]] && Q[j-2] > Q[j]))) {\n                memo[j] = (memo[j] + memo[j-2]) % MOD;\n            }\n        }\n    }\n\n    cout << memo[N] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nbool prime[1000009];\n \nvoid era(){\n    prime[0]=1;\n    prime[1]=1;\n    for(int i=2;i<1000009;i++){\n        if(!prime[i]){\n            for(int j=i+i;j<1000009;j+=i) prime[j]=1;\n        }\n    }\n}\n \nint dp[100009][2];\n \nsigned main(){\n    era();\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++)scanf(\"%ld\",&a[i]);\n    if(!prime[a[0]]){\n        dp[0][0]=1;\n        dp[0][1]=1;\n    }\n    for(int i=0;i<n;i++){\n \n        // 1\n \n        if( i+1<n && a[i]<a[i+1] &&!prime[a[i+1]] )dp[i+1][0] += dp[i][0];\n        if( i+2<n && a[i]<a[i+1] &&!prime[a[i+1]] )dp[i+1][1] += dp[i][0];\n \n        // 2\n \n        if( i+2<n && a[i]<a[i+2] &&!prime[a[i+2]] )dp[i+2][0] += dp[i][1];\n        if( i+3<n && a[i]<a[i+2] &&!prime[a[i+2]] )dp[i+2][1] += dp[i][1];\n \n        dp[i+1][0]%=1000000007;\n        dp[i+1][1]%=1000000007;\n        dp[i+2][0]%=1000000007;\n        dp[i+2][1]%=1000000007;\n    }\n    cout<<(dp[n-1][0]+dp[n-2][1])%1000000007<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\nbool isprime(int num){\n  if(num<2)return false;\n  else if(num==2)return true;\n  else if(num % 2 == 0)return false;\n\n  int sqrtnum=sqrt(num);\n  for(int i=3;i<=sqrtnum;i+=2){\n    if(num%i==0){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  ll q[100001]={0};\n  for(int i=0;i<n;++i){\n    cin>>q[i];\n  }\n  ll dp[100001]={0};\n  if(isprime(q[0]))dp[0]=1;\n  if(isprime(q[1]))if(dp[0]==1 && q[0]<q[1])dp[1]=1;\n  for(int i=2;i<n;++i){\n    if(!isprime(q[i]))continue;\n    if(q[i-1]<q[i])dp[i]+=dp[i-1];\n    if(q[i-2]<q[i])dp[i]+=dp[i-2];\n    dp[i]%=1000000007;\n  }\n  if(n==1)cout<<dp[0]<<endl;\n  else cout<<dp[n-2]+dp[n-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-1]] && is_p[q[i-2]]) {\n\tif(q[i-1] == q[i] && q[i-2] >= q[i]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\nbool isprime(int num){\n  if(num<2)return false;\n  else if(num==2)return true;\n  else if(num % 2 == 0)return false;\n\n  int sqrtnum=sqrt(num);\n  for(int i=3;i<=sqrtnum;i+=2){\n    if(num%i==0){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  ll q[100001]={0};\n  for(int i=0;i<n;++i){\n    cin>>q[i];\n  }\n  ll dp[100001]={0};\n  if(isprime(q[0]))dp[0]=1;\n  if(dp[0]==1 && q[0]<q[1])dp[1]=1;\n  for(int i=2;i<n;++i){\n    if(!isprime(q[i]))continue;\n    if(q[i-1]<q[i])dp[i]+=dp[i-1];\n    if(q[i-2]<q[i])dp[i]+=dp[i-2];\n    dp[i]%=1000000007;\n  }\n  if(n==1)cout<<dp[0]<<endl;\n  else cout<<dp[n-2]+dp[n-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-1]] && is_p[q[i-2]]) {\n\tif(q[i-1] >= q[i] && q[i-2] >= q[i]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      assert(false);\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-1]] && is_p[q[i-2]]) {\n\tif(q[i-1] == q[i] && q[i-2] >= q[i]) {\n\t  assert(false);\n\t  cout << 0 << endl;\n\t  return 0;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-1]] && is_p[q[i-2]]) {\n\tif(q[i-1] == q[i] && q[i-2] >= q[i]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst lint mod=1e9+7;\nconst int K=1e6+10;\n\nint pr[K];\nvoid init(){\n  rep(i,K)if(i>=2)pr[i]=1;\n  for(int i=2;i<K;++i){\n    if(!pr[i])continue;\n    for(int j=2;j*i<K;++j)pr[i*j]=0;\n  }\n}\n\nconst int N=110000;\nlint dp[N];\n\nint main(){\n  init();\n  int n;\n  cin>>n;\n  vi q(n+1);\n  rep(i,n)cin>>q[i];\n  q[n]=K;\n  dp[n]=1;\n  for(int i=n-1;i>=0;--i){\n    if(pr[q[i]]&&q[i]<q[i+1]){\n      dp[i]=(dp[i]+dp[i+1])%mod;\n    }\n    if(i<n-1&&pr[q[i]]&&q[i+1]>=2&&q[i]<q[i+2]){\n      dp[i]=(dp[i]+dp[i+2])%mod;\n    }\n  }\n  cout<<dp[0]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nint n, q[100005];\nint prime[1000005];\nint dp[100005];\n\nsigned main(){\n  \n  for(int i=0;i<1000005;i++) prime[i] = 1;\n  \n  prime[0] = prime[1] = 0;\n  \n  for(int i=1;i*i<1000005;i++){\n\n    if(prime[i]==0) continue;\n    \n    for(int j=i*2;j<1000005;j+=i) prime[j] = 0;\n    \n  }\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++) cin>>q[i];\n  \n  dp[0] = 1;\n  \n  for(int i=0;i<n;i++){\n    \n    if( prime[q[i]] == 0 ) continue;\n    \n    if( i == n-1 ){\n      dp[i+1] += dp[i];\n      dp[i+1] %= mod;\n      continue;\n    }\n    \n    if(q[i]<q[i+1]){\n      dp[i+1] += dp[i];\n      dp[i+1] %= mod;\n    }\n    \n    if( i+2 == n ){\n      dp[i+2] += dp[i];\n      dp[i+2] %= mod;\n    }\n    else if(q[i]<q[i+2]){\n      dp[i+2] += dp[i];\n      dp[i+2] %= mod;\n    }\n    \n  }\n\n  cout<<dp[n]<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nbool isprime(int x){\n    for (int y = 2; y * y <= x; y++){\n        if (x % y == 0) return false;\n    }\n    return true;\n}\n\nconst ll mod = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n    VI a(n);\n    REP(i,n) a[i] = in();\n\n    VI isp(n);\n    REP(i,n) isp[i] = isprime(a[i]);\n\n    VVI dp(n+2, VI(2));\n    if (isp[0]){\n        dp[1][0] = 1;\n        dp[2][1] = 1;\n    }\n\n    FOR(i,1,n-1) REP(j,2){\n        if (!isp[i]) continue;\n        if (a[i] <= a[i-j-1]) continue;\n        dp[i+1][0] = (dp[i+1][0] + dp[i][j]) % mod;\n        dp[i+2][1] = (dp[i+2][1] + dp[i][j]) % mod;\n    }\n\n    cout << (dp[n][0] + dp[n][1]) % mod << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool prime[1000009];\n\nvoid era(){\n    prime[0]=1;\n    prime[1]=1;\n    for(int i=2;i<1000009;i++){\n        if(!prime[i]){\n            for(int j=i+i;j<1000009;j+=i) prime[j]=1;\n        }\n    }\n}\n\nint dp[100009];\n\nint main(){\n    era();\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++)cin>>a[i];\n    if(!prime[a[0]])dp[0]=1;\n    for(int i=0;i<n-1;i++){\n        if(!prime[a[i]]&&!prime[a[i+1]]&&a[i]<a[i+1])dp[i+1]+=dp[i];\n        if(i<n-2&&!prime[a[i]]&&!prime[a[i+2]]&&a[i]<a[i+2])dp[i+2]+=dp[i];\n        dp[i+1]%=1000000007;\n        dp[i+2]%=1000000007;\n    }\n    cout<<dp[n-1]+dp[n-2]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst int MAX = 1e6+1;\nconst lli mod = 1e9+7;\n\nint main(){\n\tvector<bool> prime(MAX, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i*i<MAX; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j=i*2; j<MAX; j+=i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> q(n+1, 0);\n\tfor(int i=1; i<=n; i++){\n\t\tcin >> q[i];\n\t}\n\t\n\tvector<vector<lli> > dp(n+1, vector<lli>(2, 0));\n\tdp[0][0] = 1;\n\tfor(int i=0; i<n; i++){\n\t\tif(!prime[q[i+1]]) continue;\n\t\tfor(int j=0; j<2; j++){\n\t\t\tif(dp[i][j] != 0){\n\t\t\t\tif(q[i-j] < q[i+1]){\n\t\t\t\t\tdp[i+1][0] = (dp[i+1][0] +dp[i][j])%mod;\n\t\t\t\t\t\tif(i+2 <= n){\n\t\t\t\t\t\tdp[i+2][1] = (dp[i+2][1] +dp[i][j])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dp[n][0] +dp[n][1])%mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nint sosu[1000020]={0};\nint q[100002];\nint dp1[100020][2]={0};\nint dp2[100020][2]={0};\nsigned main(){\nint n,m;\n\tsosu[1]=0;\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(sosu[i]) continue;\n\t\tfor(int j=2*i;j<=1000000;j+=i)sosu[j]=1;\n\t}\n\t\n\n\tcin>>n;\n\t\n\tfor(int i=1;i<=n;i++)cin>>q[i];\n\t\n\tdp1[0][0]=1;\n\tdp1[0][1]=1;\n\tdp2[0][0]=1;\n\tdp2[0][1]=1;\n\tfor(int i=1;i<n;i++){\n\t\tif(sosu[q[i]]==1 && sosu[q[i+1]]==1){\n\t\tcout<<0<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\n\t}\n\tq[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(sosu[q[i]]==0){\n\t\t\tif(sosu[q[i-1]]==0)if( q[i-1]<q[i]){\n\t\t\t\tdp1[i][0]+=dp1[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tif(sosu[q[i-2]]==0)if(q[i-2]<q[i] && i>=3){\n\t\t\t\tdp1[i][0]+=dp2[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tdp1[i][0]%=inf;\n\t\t}\n\t\t\n\t\tif(sosu[q[i-1]]==0){\n\t\t\tif(sosu[q[i-2]]==0)if(q[i-2]<q[i-1] && i>=2){\n\t\t\t\tdp2[i][0]+=dp1[i-2][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tif(sosu[q[i-3]]==0)if(q[i-3]<q[i-1] && i>=4){\n\t\t\t\tdp2[i][0]+=dp2[i-2][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tdp2[i][0]%=inf;\t\t\n\t\t}\n\t\t\n\t//\tcout<<dp1[i][0]<<\" \"<<dp2[i][0]<<endl;\n\t//\tcout<<dp1[i][1]<<\" \"<<dp2[i][1]<<endl;\n\t}\n\tcout<<(dp1[n][0]+dp2[n][0])%inf<<endl;\n return 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1e18 : 1e9;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nint n;\nint q[100010];\nint dp[100010][2];\nbool b[100010];\n\nsigned main() {\n\tcin >> n;\n\trep (i, n) {\n\t\tcin >> q[i];\n\t\tb[i] = true;\n\t\tfor (int j = 2; j * j <= q[i]; j++) b[i] = b[i] && (q[i] % j != 0 || q[i] == j);\n\t}\n\trep (i, n) {\n\t\t// i 番目を q とする\n\t\tif (i == 0) {\n\t\t\tdp[i][0] = b[i];\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[i]) {\n\t\t\tif (q[i - 1] < q[i]) dp[i][0] = (dp[i][0] + dp[i - 1][0]) % MOD;\n\t\t\tif (i > 1 && q[i - 2] < q[i]) dp[i][0] = (dp[i][0] + dp[i - 1][1]) % MOD;\n\t\t}\n\t\t// i 番目を e とする\n\t\tdp[i][1] = (dp[i][1] + dp[i - 1][0]) % MOD;\n\t}\n\tcout << (dp[n - 1][0] + dp[n - 1][1]) % MOD << endl;\n\t//rep (i, n + 1) cout << dp[i][0] << \" \" << dp[i][1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nconst ll MOD = (1e9+7);\n\n#define MAX_NUM 1000000\nbool era[MAX_NUM+1]={false};\n\nvoid makeERA(){\n    for(int i=2;i<MAX_NUM;i++){\n        if(era[i]==true){\n            int x=MAX_NUM/i;\n            for(int j=2;j<=x;j++){\n                era[i*j]=false;\n            }\n        }\n    }\n    era[2]=true;\n}\n\nint main(){\n    for(int i=0;i<MAX_NUM;i++)era[i]=true;\n    era[0]=false;era[1]=false;\n    makeERA();\n    \n    int n;\n    cin>>n;\n    vector<int> q(n);\n    rep(i,n)cin>>q[i];\n    \n    \n    static ll dp[100001][2];\n    rep(i,100001)rep(j,2)dp[i][j] = 0;\n    if(era[q[0]]){\n        dp[0][0] = 1;\n        dp[1][1] = 1;\n    }\n    \n    \n    for(int i=1;i<n;i++){\n        rep(j,2){\n            rep(l,2){\n                if( era[q[i-j]] == false )dp[i][j] = 0;\n                else{\n                    if(i-1-j-l>=0 && q[i-j]>q[i-1-j-l]){\n//                        cout<<i<<\" \"<<j<<\" = \"<<i-1-j<<\" \"<<l<<endl;\n                        (dp[i][j] += dp[i-1-j][l])%=MOD;\n                    }\n                }\n            }\n        }\n    }\n    \n    cout<<(dp[n-1][0] + dp[n-1][1])%MOD<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n\n  if(n != 3 && n != 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-2]]) {\n\tif((!is_p[q[i-1]] || q[i-1] <= q[i]) && q[i-2] >= q[i]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll n;\nll a[101010];\nbool is_prime[1000001];\n\nll dp[100001][2];\n\nint main(){\n\n  repl(i,2,1000001)is_prime[i]=true;\n  for(ll i=2;i<=1000000;i++){\n    if(!is_prime[i])continue;\n    for(ll j=i*2;j<=1000000;j+=i){\n      is_prime[j]=false;\n    }\n  }\n\n  cin>>n;\n  rep(i,n)cin>>a[i];\n\n  if(!is_prime[a[0]]){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  dp[1][0]=1;\n  repl(i,1,n){\n    rep(j,2){\n      if(j){\n        if(is_prime[a[i]]&&a[i-2]<a[i]){\n          (dp[i+1][0]+=dp[i][j])%=mod;\n        }\n      }else{\n        if(is_prime[a[i]]&&a[i-1]<a[i]){\n          (dp[i+1][0]+=dp[i][j])%=mod;\n          (dp[i+1][1]+=dp[i][j])%=mod;\n        }else{\n          (dp[i+1][1]+=dp[i][j])%=mod;\n        }\n      }\n    }\n  }\n\n  cout<<(dp[n][0]+dp[n][1])%mod<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\nchar prime[1000005];\nvoid init_prime() {\n    fill(prime, prime+1000005, 1);\n    prime[0] = prime[1] = 0;\n    for (int x = 2; x <= 1000000; ++x) {\n        if (prime[x] && x <= 1000) {\n            for (int y = x*x; y <= 1000000; y += x) prime[y] = 0;\n        }\n    }\n\n}\n\nll N, Q[101010];\n\nll memo[101010];\n\nint main() {\n    init_prime();\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N;\n    for (int j = 1; j <= N; ++j) cin >> Q[j];\n    reverse(Q+1, Q+N+1);\n\n    fill(memo, memo+N+1, 0);\n    memo[0] = 1;\n    memo[1] = prime[Q[1]] ? 1 : 0;\n\n    for (int j = 2; j <= N; ++j) {\n        if (prime[Q[j]]) {\n            if (Q[j-1] > Q[j]) {\n                memo[j] = (memo[j] + memo[j-1]) % MOD;\n            }\n\n            if (Q[j-1] > 1 && (j < 3 || (prime[Q[j-2]] && Q[j-2] > Q[j]))) {\n                memo[j] = (memo[j] + memo[j-2]) % MOD;\n            }\n        }\n    }\n\n    cout << memo[N] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n            if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i]) \n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    int[] P;\n    void phi(int n)\n    {\n        P = new int[n + 1];\n        for (int i = 0; i <= n; i++) P[i] = i;\n        for (int i = 2; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                P[i] -= P[i] / i;\n                for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 1001000;\nbool prime[N];\n\nconst ll mod = 1e9+7;\n\nint main(){\n    fill(prime,prime+N,true);\n    prime[0] = prime[1] = false;\n    for(int i=2; i<N; ++i){\n        if(prime[i]) for(int j=2*i; j<N; j+=i) prime[j] = false;\n    }\n\n    int n;\n    cin >>n;\n    vector<int> q(n);\n    rep(i,n) cin >>q[i];\n    q.pb(1000999);\n\n    vector<ll> dp(n+1);\n    dp[0] = 1;\n    rep(i,n)if(prime[q[i]]){\n        // 1個\n        if(i+1<=n && prime[q[i+1]] && q[i]<q[i+1]) (dp[i+1] += dp[i]) %= mod;\n\n        // 2個\n        if(i+2<=n && prime[q[i+2]] && q[i]<q[i+2]) (dp[i+2] += dp[i]) %= mod;\n    }\n    cout << dp[n] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> Eratosthenes(int n) {\n\tstd::vector<int> num(n + 1, 0);\n\tnum[0] = num[1] = -1;\n\tint cnt = 0;\n\tfor (int i = 2; i*i < n; ++i) {\n\t\tif (num[i] == 0) {\n\t\t\tfor (int j = 2; (i + 1)*j <= n; ++j) {\n\t\t\t\tnum[i*j] = -1;\n\t\t\t}\n\t\t\tnum[i] = cnt++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint dp[2][2][78500];\n// dp[i][j][k] = i%2番目までみてi番目を(j:p->0/e->1)として出てきた\n//               最大の素数がk番目の素数の場合の数\n\nint solve(int n, std::vector<int> q) {\n\tauto p(Eratosthenes(1000001));\n\n\tif (p[q[0]] == -1) return 0;\n\tdp[1][0][p[q[0]]] = 1;\n\tint mi = p[q[0]], ma = p[q[0]];\n\tFOR(i, 1, n) {\n\t\tint nmi = INFINT, nma = -INFINT;\n\t\tREP(j, 2) {\n\t\t\tif (p[q[i]] == -1 && j == 1) continue;\n\t\t\tFOR(k, mi, ma + 1) {\n\t\t\t\tif (dp[i & 1][j][k] == 0) continue;\n\t\t\t\tif (p[q[i]] == -1) { // 素数じゃない\n\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t}\n\t\t\t\telse { // 素数\n\t\t\t\t\tif (k >= p[q[i]]) {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(dp[1 - i % 2][0][p[q[i]]] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\tCHMIN(nmi, p[q[i]]);\n\t\t\t\t\t\tCHMAX(nma, p[q[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nmi > nma) return 0;\n\t\tmi = nmi;\n\t\tma = nma;\n\t\tFILL(dp[i % 2], 0);\n\t}\n\tint ans = 0;\n\tREP(j, 2) REP(k, ma + 1) {\n\t\t(ans += dp[n % 2][j][k]) %= MOD;\n\t}\n\treturn ans;\n};\n\nint solve2(int n, std::vector<int> q) {\n\tauto p(Eratosthenes(1000001));\n\n\tstd::map<PAIR, int> map;\n\tstd::function<int(int, int)> rec = [&](int i, int ma) {\n\t\tif (i == n) return 1;\n\t\tif (i > n) return 0;\n\t\tif (p[q[i]] == -1) return 0;\n\t\tif (ma >= q[i]) return 0;\n\t\tif (map.count(PAIR(i, ma))) return map[PAIR(i, ma)];\n\n\t\tint re = 0;\n\t\t(re += rec(i + 1, q[i])) %= MOD;\n\t\t(re += rec(i + 2, q[i])) %= MOD;\n\t\treturn map[PAIR(i, ma)] = re;\n\t};\n\treturn rec(0, -1);\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC(int, q, n);\n\n\tOUT(solve2(n, q))BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nbool prime[1000009];\n \nvoid era(){\n    prime[0]=1;\n    prime[1]=1;\n    for(int i=2;i<1000009;i++){\n        if(!prime[i]){\n            for(int j=i+i;j<1000009;j+=i) prime[j]=1;\n        }\n    }\n}\n \nint dp[100009];\n \nsigned main(){\n    era();\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++)cin>>a[i];\n    if(!prime[a[0]])dp[0]=1;\n    for(int i=0;i<n-1;i++){\n        if(!prime[a[i]]&&!prime[a[i+1]]&&a[i]<a[i+1])dp[i+1]+=dp[i];\n        if(i<n-2&&!prime[a[i]]&&!prime[a[i+2]]&&a[i]<a[i+2])dp[i+2]+=dp[i];\n        dp[i+1]%=1000000007;\n        dp[i+2]%=1000000007;\n    }\n    cout<<(dp[n-1]+dp[n-2])%1000000007<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> P;\n#define M 1000000007\n#define F first\n#define S second\n#define PB push_back\nll n,dp[100005][2],a[100005];\nbool p[1000005];\nint main(void){\n    for(int i=2;i<=1000;i++)if(!p[i])for(int j=i*2;j<=1000000;j+=i)p[j]=true;\n    scanf(\"%lld\",&n);\n    for(int i=0;i<n;i++)scanf(\"%lld\",a+i);\n    if(!p[a[0]])dp[1][0]=1;\n    for(int i=1;i<n;i++){\n        dp[i+1][1]=(dp[i+1][1]+dp[i][0])%M;\n        if(!p[a[i]]&&a[i-1]<a[i])dp[i+1][0]=(dp[i+1][0]+dp[i][0])%M;\n        if(i>1&&!p[a[i]]&&a[i-2]<a[i])dp[i+1][0]=(dp[i+1][0]+dp[i][1])%M;\n    }\n    cout<<(dp[n][0]+dp[n][1])%M<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing ll  = long long;\n#define int ll\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define erep(e,v) for(auto && e :v)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? (int)1e9:(int)1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){for(auto itr :a){if(itr != *a.begin())cout << \" \"; cout << itr;} }\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nint MOD = 1e9 + 7;\nclass Prime{\n    vector<bool>Isprime;\n    vector<int>prime;\npublic:\n    int size;\n    Prime(int n) : Isprime(n+1,true),size(n+1){\n        Isprime[0] = Isprime[1] = false;\n        for(int i = 2; i<=size; i++){\n            if(!Isprime[i])continue;\n            prime.push_back(i);\n            for(int j = 2;i*j <=size;j++) Isprime[i*j] = false;\n        }\n    }\n    bool isPrime(int n){assert(n<=size);return (n<=size? Isprime[n]:false);}\n    int indexOf(int i){return (i<prime.size()?prime[i]:INF);}\n};\nsigned main(){\n    int n;\n    cin >> n;\n    Prime p(10000000);\n    vector<int>q(n);\n    erep(e,q) cin >> e;\n    auto dp = vectors(n,2,0LL);\n    dp[0][0] = (p.isPrime(q[0]) ? 1:0);\n    rep(i,q.size()){\n        if(i == 0)continue;\n        if(p.isPrime(q[i])){\n            dp[i][0] = (q[i] > q[i-1] and p.isPrime(q[i-1]) ? dp[i-1][0]:0); dp[i][0] %= MOD;\n            dp[i][0] += (i - 2 >= 0 and q[i] > q[i - 2]  and p.isPrime(q[i-2]) ? dp[i-1][1] : 0); dp[i][0] %= MOD;\n            dp[i][1] = dp[i-1][0];\n        } else {\n            dp[i][1] = dp[i-1][0];  dp[i][1] %= MOD;\n        }\n    }\n    cout << (dp[n-1][0] + dp[n-1][1]) % MOD << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day3/problems/D>\n問題文============================================================\n\n えびちゃんは素因数分解マシンの不良品を持っています。\n この機械は、2 以上の自然数 M を与えると O(logM) でその素因数分解を行ってくれますが、\n 困ったことに数字以外を表示できないバグがありました。\n \n 一般に、M の素因数分解が p1e1×p2e2×…×pKeK (ただし i<j ならば pi<pj、また各 pi は素数) の場合を考えます。\n M を与えると、この機械は i=1 から順に以下のように出力を行います。全ての数字はスペース区切りで表示されます。\n \n ei=1 ならば pi を出力する\n ei>1 ならば pi ei を出力する\n \n たとえば、22 や 2048 を与えると 2 11 と表示され、24 や 54 を与えると 2 3 3 と表示されます。\n \n さて、えびちゃんは表示された素因数分解をメモしておいたのですが、\n 与えた自然数をメモしておくのを忘れていたことに気づきました。\n 素因数分解のメモが与えられるので、元の自然数としてありえるものがいくつあるかを求めてください。\n ただし、メモが間違っていて、条件を満たす自然数が一つも存在しないこともあります。\n \n また、その個数は非常に大きくなる場合があるので、109+7 (素数) で割ったあまりを出力してください。\n \n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\n#define MAX_N 1000005\nbool is_prime[MAX_N];\nconst ll MOD = 1e9+7;\n\nbool IsPrime(int num)\n{\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2){\n        if (num % i == 0){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid init(){\n    for(int i = 1; i < MAX_N;i++){\n        is_prime[i] = IsPrime(i);\n    }\n}\nll solve(){\n    ll N; cin >> N;\n    vector<ll> q(N);\n    for(auto& in:q)cin >> in;\n\n    if(!is_prime[q[0]]) return 0;\n\n    int cnt = 0;\n    for(int i = 0; i < N;i++){\n        if(!is_prime[q[i]]) cnt++;\n        else cnt = 0;\n        if(cnt == 2) return 0;\n    }\n\n    vector<ll> dp(N+1,0);\n    dp[0] = 1;\n    for(int i = 0; i < N;i++){\n        if(is_prime[q[i]]){\n            if(i+1 == N || is_prime[q[i+1]] && (q[i] < q[i+1])){\n                (dp[i+1] += dp[i])%=MOD;\n            }\n            if(i+2 == N || is_prime[q[i+2]] && (q[i] < q[i+2])){\n                (dp[i+2] += dp[i])%=MOD;\n            }\n        }\n    }\n    return dp[N]%MOD;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    init();\n    cout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n;\nll a[100100];\nll dp[2][1001000];\nmap<ll, ll> id;\nbool used[1001000];\n\nvector<int> prime;\nbool is_prime[1001000];\n\nint sieve(int n) {//n以下の素数の数を返す\n\tint p = 0;\n\tfor (int i = 0; i <= n; i++)is_prime[i] = 1;\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tid[i] = prime.size() - 1;\n\t\t\tfor (int j = 2 * i; j <= n; j += i)is_prime[j] = 0;\n\t\t}\n\t}\n\treturn p;\n}\n\nint main() {\n\tsieve(1001000);\n\tcin >> n;\n\trep(i, n)cin >> a[i];\n\tif (!is_prime[a[0]])cout << 0 << endl;\n\telse {\n\t\tdp[0][0] = 1;\n\t\tFOR(i, 1, n) {\n\t\t\tif (is_prime[a[i]]) {\n\t\t\t\tif (i > 1 && a[i] > a[i - 2])dp[0][i] = (dp[0][i] + dp[1][i - 1]) % MOD;\n\t\t\t\tif (a[i] > a[i - 1])dp[0][i] = (dp[0][i] + dp[0][i - 1]) % MOD;\n\t\t\t\tif (is_prime[a[i - 1]])dp[1][i] = (dp[1][i] + dp[0][i - 1]) % MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (is_prime[a[i - 1]])dp[1][i] = (dp[1][i] + dp[0][i - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tcout << mod_add(dp[0][n - 1], dp[1][n - 1]) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nconst int MAX = 1e6+10;\nbool isp[MAX];\nLL dp[MAX];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  VI xs(N);\n  cin >> xs;\n\n  fill(isp, isp+MAX, true);\n  isp[0] = isp[1] = false;\n  for(int i=2;i<MAX;++i)\n\tif(isp[i])\n\t  for(int j=i+i;j<MAX;j+=i)\n\t\tisp[j] = false;\n\n  if(!isp[xs[0]]){\n\tcout << 0 << endl;\n\treturn 0;\n  }\n  if(N == 1){\n\tcout << 1 << endl;\n\treturn 0;\n  }\n\n  dp[0] = 1;\n  for(int i=1;i<N;++i){\n\tif(isp[xs[i]]){\n\t  if(isp[xs[i-1]] && xs[i-1] < xs[i])\n\t\t(dp[i] += dp[i-1]) %= MOD;\n\t  if(i>=2 && isp[xs[i-2]] && xs[i-2] < xs[i])\n\t\t(dp[i] += dp[i-2]) %= MOD;\n\t}\n  }\n\n  LL ans = 0;\n  if(isp[xs[N-1]]) ans += dp[N-1];\n  if(isp[xs[N-2]]) ans += dp[N-2];\n\n  cout << ans%MOD << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cassert>\n#include <exception>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\nll box[200010];\n\nbool prime[100010];\n\nvoid hurui(){\n  clr(prime,false);\n  prime[0] = prime[1] = true;\n  rep(i,2,100010){\n    if(!prime[i]){\n      for(int j = 2;i * j < 100010;j++)prime[i * j] = true;\n    }\n  }\n}\n\nbool isprime(ll num){\n  return !prime[num];\n}\n\nint main(){\n  hurui();\n  clr(d,0);\n  vi vec;\n  cin >> n;\n  ll p,q;\n  p = q = 0;\n  lep(i,1,n){\n    cin >> d[i];\n    if(isprime(d[i]))p++;\n    else q++;\n  }\n  bool ex = true;\n  lep(i,1,n){\n    l = 0;\n    lep(j,-1,1)if(prime[d[i+j]] && d[i+j] != 0)l++;\n    if(l > 1)ex = false;\n    // else if(!isprime(d[i-1]) && isprime(d[i]) && i == n && d[i-2] > d[i])ex = false;\n    else{\n      if(isprime(d[i-1]) && isprime(d[i]) && isprime(d[i+1])){\n        if(d[i-1] < d[i+1])vec.pb(2);\n        else vec.pb(1);\n      }else{\n        vec.pb(1);\n      }\n    }\n  }\n  if(ex){\n    ll ans = 1;\n    rep(i,0,vec.sz){\n      ans *= vec[i];\n      ans %= INF;\n    }\n    print(ans);\n  }else{\n    puts(\"0\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nbool p[1000010];\nvoid init(){\n    int MAX = 1000010;\n    for(int i=0;i<MAX;i++) p[i]=1;\n    p[0]=0, p[1] = 1;\n    for(int i=2;i<=MAX/2;i++){\n        if(p[i]){\n            for(int j=i+i;j<MAX;j+=i) p[j]=0;\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int n;\n    cin>>n;\n    int a[n];\n    init();\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    if(p[a[0]]==false){\n        cout << 0 << endl;\n        return 0;\n    }\n    ll mod = 1e9+7;\n    ll dp[n+1][2]={};\n    dp[0][0]=1;\n    for(int i=0;i<n;i++){\n        if(i) dp[i+1][1] += dp[i][0];\n        dp[i+1][1] %= mod;\n        if(i-2>=0 && a[i]>a[i-2] && p[a[i]]){\n            dp[i+1][0] += dp[i][1];\n        }\n        if(i && a[i]>a[i-1] && p[a[i]]){\n            dp[i+1][0] += dp[i][0];\n        }\n        if(i==0){\n            dp[i+1][0] += dp[i][0];\n        }\n        dp[i+1][0] %= mod;\n    }\n    ll ans = dp[n][0] + dp[n][1];\n    ans %= mod;\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t N;\n\nstd::vector<bool> IsPrime;\nvoid sieve(uint64_t max) {\n\tif (max + 1 > IsPrime.size()) {     // resizeで要素数が減らないように\n\t\tIsPrime.resize(max + 1, true); // IsPrimeに必要な要素数を確保\n\t}\n\tIsPrime[0] = false; // 0は素数ではない\n\tIsPrime[1] = false; // 1は素数ではない\n\n\tfor (uint64_t i = 2; i*i <= max; ++i) // 0からsqrt(max)まで調べる\n\t\tif (IsPrime[i]) // iが素数ならば\n\t\t\tfor (uint64_t j = 2; i*j <= max; ++j) // (max以下の)iの倍数は\n\t\t\t\tIsPrime[i*j] = false;      // 素数ではない\n}\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<1000000007> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(1)+初期化O(NlogMOD)\n\tstatic const auto fact_v = fact_set_c<要素数 + 1>();\n\tstatic const auto fact_div_v = [&]() {\n\t\tauto tmp = fact_v;\n\t\tfor (auto& i : tmp) { i = ~i; }\n\t\treturn tmp;\n\t}();\n\t//return fact_v[all] / (fact_v[get] * fact_v[all - get]);\n\treturn fact_v[all] * fact_div_v[get] * fact_div_v[all - get];\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 要素数;// 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\n//9592\n\nint32_t q[100000];\nbool used[100000][2][2];\nmint dp[100000][2][2];\n\nmint func(int i, int diff, int is_bef_prime)\n{\n\tif (i == N) {\n\t\treturn 1_mi;\n\t}\n\tauto& memo = dp[i][diff - 1][is_bef_prime];\n\tif (used[i][diff - 1][is_bef_prime]) {\n\t\treturn memo;\n\t}\n\tused[i][diff - 1][is_bef_prime] = true;\n\n\tif (i == 0 ){\n\t\t//素数only\n\t\tif (IsPrime[q[i]]) {\n\t\t\treturn memo = func(i + 1, 1, true);\n\t\t}\n\t\telse{\n\t\t\treturn memo = 0;\n\t\t}\n\t}\n\n\tif (IsPrime[q[i]] == false || q[i - diff] >= q[i]) {\n\t\t//係数only\n\t\tif (is_bef_prime) {\n\t\t\treturn memo = func(i + 1, 2, false);\n\t\t}\n\t\telse {\n\t\t\treturn memo = 0_mi;\n\t\t}\n\t}\n\tif (is_bef_prime == false) {\n\t\t//素数only\n\t\treturn memo = func(i + 1, 1, true);\n\t}\n\n\t//両方\n\treturn memo = func(i + 1, 2, false) + func(i+1, 1, true);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tsieve(100000);\n\n\tin >> N;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> q[i];\n\n\t}\n\n\tout << func(0, 1, true) << endl;\n\n\treturn 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid eratosthenes(int N, int* arr){\n  for(int i=0; i < N; i++){\n    arr[i] = 1;\n  }\n  for(int i=2; i < sqrt(N); i++){\n    if(arr[i]){\n      for(int j=0; i * (j + 2) < N; j++){\n        arr[i*(j+2)] = 0;\n      }\n    }\n  }\n}\n\nint main(void){\n  const int NMAX = 100011;\n  const int QMAX = 1000001;\n  const int MOD = 1e9+7;\n  int dp[NMAX][2]; // dp[idx][自分が素因数(0)か肩(1)か]\n  int isprime[QMAX];\n  for(int i = 0; i < NMAX; i++) for(int j = 0; j < 2; j++) dp[i][j] = 0;\n  eratosthenes(QMAX, isprime);\n\n\n\n  int N; cin >> N;\n  vector<int> q(N);\n  for(int i = 0; i < N; i++) cin >> q[i];\n  q.push_back(0);\n\n  if(isprime[q[0]])\n    dp[0][0] = 1;\n\n  for(int i = 0; i < N-1; i++){\n    for(int j = 0; j < 2; j++){\n      if(j == 0){\n        dp[i+1][1] = (dp[i+1][1] + dp[i][j]) % MOD;\n        if(q[i+1] > q[i] && isprime[q[i+1]]){\n          dp[i+1][0] = (dp[i+1][0] + dp[i][j]) % MOD;\n        }\n      }else{\n        if((i == 0 || q[i+1] > q[i-1]) && isprime[q[i+1]]){\n          dp[i+1][0] = (dp[i+1][0] + dp[i][j]) % MOD;\n        }\n      }\n    }\n  }\n  cout << (dp[N-1][0] + dp[N-1][1]) % MOD << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n \nconst LD eps=1e-10;\nconst long long INFLL=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9;\n \ntemplate<class T>\nvoid chmin(T& a, const T b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tfor(int i=0;i<q;i++)\n\t\tt*=p;\n\treturn t;\n}\n\ntemplate <typename T>\nstruct has_iter\n{\n\tprivate:\n\t\ttemplate <typename U>\n\t\tstatic constexpr true_type check(typename U::iterator*);\n\t\ttemplate <typename U>\n\t\tstatic constexpr false_type check(...);\n\n\tpublic:\n\t\tstatic constexpr bool value = decltype(check<T>(nullptr))::value;\n};\n\ntemplate<typename T, typename U = typename T::iterator>\nvoid print(const T& container)\n{\n\t\tauto&& first=begin(container), last=end(container);\n\t\tauto&& back=prev(last);\n\t\tfor(auto e=first; e!=last; e=next(e))\n\t\t\tcout<<*e<<\" \\n\"[e==back];\n}\n\nextern void* enabler;\ntemplate<typename Head, typename enable_if<!has_iter<Head>::value>::type*& = enabler>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec)\n{\n\tfor(T& x: vec) is >> x;\n\treturn is;\n}\n\ntemplate<typename T>\nvector<T> read(int n)\n{\n\tvector<T> t(n);\n\tcin>>t;\n\treturn t;\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\n\n\nclass Mod\n{\n    private:\n        static const long long MODULO = 1e9+7;\n        long long value;\n\n        const void Normalize()\n        {\n            value=value<0?(value%MODULO+MODULO):(value%MODULO);\n        }\n\n    public:\n        Mod():value(0){}\n        Mod(const long long &val)\n        {\n            value=val;\n            Normalize();\n        }\n        \n        explicit operator long long () const\n        {\n            return value;\n        }\n\n        const Mod operator -() const\n        {\n            return Mod(MODULO - value);\n        }\n        const Mod operator +(const Mod &rhs) const\n        {\n            return Mod(value + rhs.value);\n        }\n        const Mod operator -(const Mod &rhs) const\n        {\n            return Mod(value + (-rhs).value);\n        }\n        const Mod operator *(const Mod &rhs) const\n        {\n            return Mod(value * rhs.value);\n        }\n        Mod &operator +=(const Mod &rhs)\n        {\n            return *this = *this + rhs;\n        }\n        Mod &operator -=(const Mod &rhs)\n        {\n            return *this = *this - rhs;\n        }\n        Mod &operator *=(const Mod &rhs)\n        {\n            return *this = *this * rhs;\n        }\n\n\n        Mod pow(long long p) const;\n\n        Mod inv() const\n        {\n            return pow(MODULO-2);\n        }\n\n        const Mod operator /(const Mod &rhs) const\n        {\n            return *this * rhs.inv();\n        }\n        Mod &operator /=(const Mod &rhs)\n        {\n            return *this = *this / rhs;\n        }  \n        bool operator ==(const Mod &rhs)\n        {\n            return value == rhs.value;\n        }\n};\n\nMod Mod::pow(long long p) const\n{\n    Mod tmp=1, mult=*this;\n    while(p)\n    {\n        if((p&1)>0) tmp*=mult;\n        p>>=1;\n        mult*=mult;\n    }\n    return tmp;\n}\n\nnamespace std\n{\n    ostream& operator<<(ostream& os, const Mod mod)\n    {\n        os<<(long long)mod;\n        return os;\n    }\n};\n\nint main()\n{\n    const int N=1000010;\n    vector<char> is_prime(N+1,1);\n    is_prime[0]=0;\n    is_prime[1]=0;\n    for(int i=2;i<N+1;i++)\n    {\n        if(!is_prime[i])  continue;\n        for(int j=i+i;j<N+1;j+=i)\n            is_prime[j]=0;\n    }\n    /*\n    REP(i,100)\n    {\n        if(is_prime[i])\n        print(i);\n    }*/\n\n    int n;\n    cin>>n;\n    vector<int> q(n+1);\n    q[0]=1;\n    REP(i,n)\n        cin>>q[i+1];\n\n    vector<vector<Mod>> dp(n+1, vector<Mod>(2));\n    dp[0][0]=1;\n    REP(i,n)\n    {\n        if(is_prime[q[i+1]])\n        {\n            //print(\"Yes\");\n            if(q[i]<q[i+1])\n                dp[i+1][0] += dp[i][0];\n            if(q[i]<q[i+1] && i+2<n+1)\n                dp[i+2][1] += dp[i][0];\n            if(i-1<=0) continue;\n            if(q[i-1]<q[i+1])\n                dp[i+1][0] += dp[i][1];\n            if(q[i-1]<q[i+1] && i+2<n+1)\n                dp[i+2][1] += dp[i][1];\n        }    \n    }\n    print(dp[n][0] + dp[n][1]);\n    /*REP(j,2)\n    {\n        REP(i,n+1)\n            cout<<dp[i][j]<<\" \\n\"[i==n];\n    }*/\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cassert>\n#include <exception>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\nll box[200010];\n\nbool prime[100010];\n\nvoid hurui(){\n  clr(prime,false);\n  prime[0] = prime[1] = true;\n  rep(i,2,100010){\n    if(!prime[i]){\n      for(int j = 2;i * j < 100010;j++)prime[i * j] = true;\n    }\n  }\n}\n\nbool isprime(ll num){\n  return !prime[num];\n}\n\nint main(){\n  hurui();\n  clr(d,0);\n  vi vec;\n  cin >> n;\n  ll p,q;\n  p = q = 0;\n  lep(i,1,n){\n    cin >> d[i];\n    if(isprime(d[i]))p++;\n    else q++;\n  }\n  bool ex = true;\n  lep(i,1,n){\n    if(prime[d[i-1]] && prime[d[i]] && prime[d[i+1]])ex = false;\n    else if(!isprime(d[i-1]) && isprime(d[i]) && i == n && d[i-2] > d[i])ex = false;\n    else{\n      if(isprime(d[i-1]) && isprime(d[i]) && isprime(d[i+1])){\n        if(d[i-1] < d[i+1])vec.pb(2);\n        else vec.pb(1);\n      }\n      else if(prime[d[i]] && prime[d[i+1]]){\n        vec.pb(1);\n      }else if(prime[d[i-1]] && prime[d[i]]){\n        vec.pb(1);\n      }else{\n        vec.pb(1);\n      }\n    }\n  }\n  if(ex){\n    ll ans = 1;\n    rep(i,0,vec.sz){\n      ans *= vec[i];\n      ans %= INF;\n    }\n    print(ans);\n  }else{\n    puts(\"0\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <cstdlib>\n#include <unordered_map>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 3000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007 \n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define seg_size 524288\nusing namespace std;\nlong long dp[300000][2] = {};\nint sosuu(int now) {\n\tfor (int q = 2; q <= sqrt(now); ++q) {\n\t\tif (now%q == 0) return 0;\n\t}\n\treturn 1;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> a;\n\ta.push_back(0);\n\tREP(i, n) {\n\t\tint b;\n\t\tcin >> b;\n\t\ta.push_back(b);\n\t}\n\tdp[0][0] = 1;\n\tdp[1][1] = -1;\n\tn++;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (sosuu(a[i]) == 1) {\n\t\t\t//back 2\n\t\t\tif (sosuu(a[i-1]) == 1&&a[i - 1] < a[i]) {\n\t\t\t\tdp[i][0] += dp[i - 1][0];\n\t\t\t}\n\t\t\tif (i >= 2 && sosuu(a[i - 2]) == 1 && a[i - 2] < a[i]) {\n\t\t\t\tdp[i][0] += dp[i - 1][1];\n\t\t\t}\n\t\t\tdp[i][0] %= MAX_MOD;\n\t\t}\n\t\tdp[i][1] += dp[i - 1][0];\n\t\tdp[i][1] %= MAX_MOD;\n\t}\n\tcout << (dp[n - 1][0] + dp[n - 1][1]) % MAX_MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\nbool isprime(int num){\n  if(num<2)return false;\n  else if(num==2)return true;\n  else if(num % 2 == 0)return false;\n\n  int sqrtnum=sqrt(num);\n  for(int i=3;i<=sqrtnum;i+=2){\n    if(num%i==0){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  ll q[100001]={0};\n  for(int i=0;i<n;++i){\n    cin>>q[i];\n  }\n  ll dp[100001]={0};\n  if(isprime(q[0]))dp[0]=1;\n  if(isprime(q[1]))if(dp[0]==1 && q[0]<q[1])dp[1]=1;\n  for(int i=2;i<n;++i){\n    if(!isprime(q[i]))continue;\n    if(q[i-1]<q[i])dp[i]+=dp[i-1];\n    if(q[i-2]<q[i])dp[i]+=dp[i-2];\n    dp[i]%=1000000007;\n  }\n  if(n==1)cout<<dp[0]<<endl;\n  else cout<<(dp[n-2]+dp[n-1])%1000000007<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nvector<int> eratosthenes(int n) {\n  vector<int> res, p(n + 1, 1);\n  p[0] = p[1] = 0;\n  for (int i = 2; i * i <= n; ++i) {\n    if (p[i]) {\n      for (int j = 2 * i; j <= n; j += i) {\n        p[j] = 0;\n      }\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    if (p[i]) res.push_back(i);\n  }\n  // return res;\n  return p;\n}\n\nconst int mod = 1e9 + 7;\nvector<int> prime = eratosthenes(1000000);\n\nint n;\nvector<int> q;\n\nint dp[101010][2];\n\nint dfs(int idx = 1, int pre = 0) {\n  if (idx > q.size()) return 0;\n  if (idx == q.size()) {\n    return 1;\n  }\n\n  int &res = dp[idx][pre + 1 == idx];\n  if (~res) return res;\n  res = 0;\n  if (prime[q[idx]] && q[pre] < q[idx]) {\n    res += dfs(idx + 2, idx);\n    res %= mod;\n\n    res += dfs(idx + 1, idx);\n    res %= mod;\n  }\n\n  return res;\n}\n\nsigned main(int argc, char *argv[]) {\n  memset(dp, -1, sizeof dp);\n\n  cin >> n;\n  q = vector<int>(n + 1);\n  for (int i = 1; i <= n; ++i) cin >> q[i];\n\n  cout << dfs() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nint sosu[1000020]={0};\nint q[100002];\nint dp1[100020][2]={0};\nint dp2[100020][2]={0};\nsigned main(){\nint n,m;\n\tsosu[1]=0;\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(sosu[i]) continue;\n\t\tfor(int j=2*i;j<=1000000;j+=i)sosu[j]=1;\n\t}\n\t\n\n\tcin>>n;\n\t\n\tfor(int i=1;i<=n;i++)cin>>q[i];\n\t\n\tdp1[0][0]=1;\n\tdp1[0][1]=1;\n\tdp2[0][0]=1;\n\tdp2[0][1]=1;\n\tfor(int i=1;i<n;i++){\n\t\tif(sosu[q[i]]==1 && sosu[q[i+1]]==1){\n\t\tcout<<0<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(sosu[q[i]]==0){\n\t\t\tif(sosu[q[i-1]]==0)if( q[i-1]<q[i]){\n\t\t\t\tdp1[i][0]+=dp1[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tif(sosu[q[i-2]]==0)if(q[i-2]<q[i] && i>=3){\n\t\t\t\tdp1[i][0]+=dp2[i-1][0];\n\t\t\t\tdp1[i][1]=q[i];\n\t\t\t}\n\t\t\tdp1[i][0]%=inf;\n\t\t}\n\t\t\n\t\tif(sosu[q[i-1]]==0){\n\t\t\tif(sosu[q[i-2]]==0)if(q[i-2]<q[i-1] && i>=2){\n\t\t\t\tdp2[i][0]+=dp1[i-2][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tif(sosu[q[i-3]]==0)if(q[i-3]<q[i-1] && i>=4){\n\t\t\t\tdp2[i][0]+=dp2[i-1][0];\n\t\t\t\tdp2[i][1]=q[i-1];\n\t\t\t}\n\t\t\tdp2[i][0]%=inf;\t\t\n\t\t}\n\t\t\n\t//\tcout<<dp1[i][0]<<\" \"<<dp2[i][0]<<endl;\n\t//\tcout<<dp1[i][1]<<\" \"<<dp2[i][1]<<endl;\n\t}\n\tcout<<(dp1[n][0]+dp2[n][0])%inf<<endl;\n return 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MAX = 1e6+10;\n  vector<Int> p(MAX,0);\n  for(Int i=2;i<MAX;i++){\n    if(p[i]) continue;\n    for(Int j=i+i;j<MAX;j+=i) p[j]=1;\n  }\n  Int n;\n  cin>>n;\n  vector<Int> q(n);\n  for(Int i=0;i<n;i++) cin>>q[i];\n\n  vector<Int> dp(n+1,0);\n  const Int MOD = 1e9+7;\n  dp[0]=!p[q[0]];\n  for(Int i=0;i<n;i++){\n    if(i+1==n) (dp[i+1]+=dp[i])%=MOD;\n    if(i+2==n) (dp[i+2]+=dp[i])%=MOD;\n\n    if(i+1<n&&!p[q[i+1]]&&q[i]<q[i+1]) (dp[i+1]+=dp[i])%=MOD;\n    if(i+2<n&&!p[q[i+2]]&&q[i]<q[i+2]) (dp[i+2]+=dp[i])%=MOD;\n  }\n\n  cout<<dp[n]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t N;\n\nstd::vector<bool> IsPrime;\nvoid sieve(uint64_t max) {\n\tif (max + 1 > IsPrime.size()) {     // resizeで要素数が減らないように\n\t\tIsPrime.resize(max + 1, true); // IsPrimeに必要な要素数を確保\n\t}\n\tIsPrime[0] = false; // 0は素数ではない\n\tIsPrime[1] = false; // 1は素数ではない\n\n\tfor (uint64_t i = 2; i*i <= max; ++i) // 0からsqrt(max)まで調べる\n\t\tif (IsPrime[i]) // iが素数ならば\n\t\t\tfor (uint64_t j = 2; i*j <= max; ++j) // (max以下の)iの倍数は\n\t\t\t\tIsPrime[i*j] = false;      // 素数ではない\n}\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<1000000007> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\n//9592\n\nint32_t q[100000];\nbool used[100000][2][2];\nmint dp[100000][2][2];\n\nmint func(int i, int diff, int is_bef_prime)\n{\n\tassert((is_bef_prime && diff == 1) || (is_bef_prime == false && diff == 2));\n\n\tif (i == N) {\n\t\treturn 1_mi;\n\t}\n\tauto& memo = dp[i][diff - 1][is_bef_prime];\n\tif (used[i][diff - 1][is_bef_prime]) {\n\t\treturn memo;\n\t}\n\tused[i][diff - 1][is_bef_prime] = true;\n\n\tif (i == 0 ){\n\t\t//素数only\n\t\tif (IsPrime[q[i]]) {\n\t\t\treturn memo = func(i + 1, 1, true);\n\t\t}\n\t\telse{\n\t\t\treturn memo = 0_mi;\n\t\t}\n\t}\n\n\tif (IsPrime[q[i]] == false || q[i - diff] >= q[i]) {\n\t\t//係数only\n\t\tif (is_bef_prime) {\n\t\t\treturn memo = func(i + 1, 2, false);\n\t\t}\n\t\telse {\n\t\t\treturn memo = 0_mi;\n\t\t}\n\t}\n\tif (is_bef_prime == false) {\n\t\t//素数only\n\t\treturn memo = func(i + 1, 1, true);\n\t}\n\n\t//両方\n\treturn memo = func(i + 1, 2, false) + func(i+1, 1, true);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tsieve(1000000);\n\n\tin >> N;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> q[i];\n\t}\n\n\tout << func(0, 2, false) << endl;\n\n\treturn 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll=long long;\n\nbool isprime(int num){\n  if(num<2)return false;\n  else if(num==2)return true;\n  else if(num % 2 == 0)return false;\n\n  int sqrtnum=sqrt(num);\n  for(int i=3;i<=sqrtnum;i+=2){\n    if(num%i==0){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  ll q[100001]={0};\n  for(int i=0;i<n;++i){\n    cin>>q[i];\n  }\n  ll dp[100001]={0};\n  if(isprime(q[0]))dp[0]=1;\n  if(isprime(q[1]))if(dp[0]==1 && q[0]<q[1])dp[1]=1;\n  for(int i=2;i<n;++i){\n    if(!isprime(q[i]))continue;\n    if(q[i-1]<q[i])dp[i]+=dp[i-1];\n    if(q[i-2]<q[i])dp[i]+=dp[i-2];\n    dp[i]%=1000000007;\n  }\n  if(n==1)cout<<dp[0]<<endl;\n  else cout<<dp[n-2]+dp[n-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\n\nconst int N = 1111111;\nbool prime[N + 1];\nvector<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tif (!prime[i]) continue;\n\t\tfor (int j = i; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i])\n\t\t{\n\t\t\tprimes.push_back(i);\n\t\t}\n\t}\n}\n\nll pow(ll x, ll n, ll mod)\n{\n\tll res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x*x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint n;\nvi q;\nll dp[111111];\n\nll solve(int p)\n{\n\tif (dp[p] >= 0) return dp[p];\n\tif (p == n) return 0;\n\tif (p == n - 1)\n\t{\n\t\tif(prime[q[p]])\treturn 1;\n\t\telse return 0;\n\t}\n\tll res = 0;\n\tif (prime[q[p + 1]] && q[p + 1] > q[p]) res += solve(p + 1);\n\tif (p + 2 < n && prime[q[p + 2]] && q[p + 2] > q[p]) res += solve(p + 2);\n\tif (p + 2 == n) return 1;\n\treturn dp[p] = res % MOD;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tMS(dp, -1);\n\thurui();\n\tcin >> n;\n\tq.resize(n);\n\tcin >> q;\n\tif(prime[q[0]]) cout << solve(0) << endl;\n\telse cout << 0 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-2]] && q[i-2] >= q[i]) {\n\tif(!is_p[q[i-1]]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t} else if(q[i-1] <= q[i]) {\n\t  dp[0][i+1] = 0;\n\t  dp[1][i+1] = dp[1][i-1];\n\t  continue;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-1]] && is_p[q[i-2]]) {\n\tif(q[i-1] <= q[i] && q[i-2] >= q[i]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n// #define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> Eratosthenes(int n) {\n\tstd::vector<int> num(n + 1, 0);\n\tnum[0] = num[1] = -1;\n\tint cnt = 0;\n\tfor (int i = 2; i*i < n; ++i) {\n\t\tif (num[i] == 0) {\n\t\t\tfor (int j = 2; (i + 1)*j <= n; ++j) {\n\t\t\t\tnum[i*j] = -1;\n\t\t\t}\n\t\t\tnum[i] = cnt++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint dp[2][2][78500];\n// dp[i][j][k]=i%2番目までみてi番目を(j:p->0/e->1)として出てきた最大の素数がkの場合の数\n\nauto solve() {\n\tVAR(int, n);\n\tVEC(int, q, n);\n\tauto p(Eratosthenes(1000001));\n\n\tif (p[q[0]] == -1) return 0;\n\tdp[1][0][p[q[0]]] = 1;\n\tint mi = p[q[0]], ma = p[q[0]];\n\tFOR(i, 1, n) {\n\t\tint nmi = INFINT, nma = -INFINT;\n\t\tREP(j, 2) {\n\t\t\tif (p[q[i]] == -1 && j == 0) continue;\n\t\t\tFOR(k, mi, ma + 1) {\n\t\t\t\tif (dp[i & 1][j][k] == 0) continue;\n\t\t\t\tif (p[q[i]] == -1) { // 素数じゃない\n\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t}\n\t\t\t\telse { // 素数\n\t\t\t\t\tif (k >= p[q[i]]) {\n\t\t\t\t\t\tif (j == 0) (dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j == 0) (dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t(dp[1 - i % 2][0][p[q[i]]] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\tCHMAX(nma, p[q[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = nmi;\n\t\tma = nma;\n\t\tFILL(dp[i % 2], 0);\n\t}\n\tint ans = 0;\n\tREP(j, 2) REP(k, ma + 1) {\n\t\t(ans += dp[n & 1][j][k]) %= MOD;\n\t}\n\treturn ans;\n};\n\nsigned main() {\n\tINIT;\n\n\tOUT(solve())BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define rep(i, n) REPS(i, 0, n)\n#define REP0(i,n) for (ll i = 0; i <= (ll)(n); ++i)\n#define REP1(i,n) for (ll i = 1; i <= (ll)(n); ++i)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) is >> x;\n  //for(int i=0; i<vec.size(); i++) is >> x[i]; とかでもいいです。\n  return is;\n}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){\n  for(int i=0; i<vec.size(); i++){\n    os << vec[i] << ( i+1 == vec.size() ? \"\" : \" \" );\n  }\n  return os;\n}\n/* }}} */\n\nvector<long long int> dijkstra(int s,int v, vector<vector<pii>> G)\n{\n  //s: 始点, v: 頂点数, G: 隣接リスト\n  PQ<pair<long long int,int>> wait;\n  vector<long long int> result(v,INF);\n  result[s]=0;\n  wait.push(mp(0,s));\n  while(!wait.empty())\n  {\n    long long int nowpoint=wait.top().Se;\n    long long int nowcost=wait.top().Fi;\n    wait.pop();\n    if(nowcost<=result[nowpoint])\n    {\n      rep(i,G[nowpoint].size())\n      {\n        long long int nextpoint=G[nowpoint][i].Se;\n        long long int nextcost= G[nowpoint][i].Fi-nowcost;\n        if(nextcost<result[nextpoint])\n        {\n          wait.push(mp(-nextcost,nextpoint));\n          result[nextpoint]=nextcost;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nvector<bool> IsPrime;\n\nvoid sieve(size_t max){\n    if(max+1 > IsPrime.size()){     // resizeで要素数が減らないように\n        IsPrime.resize(max+1,true); // IsPrimeに必要な要素数を確保\n    } \n    IsPrime[0] = false; // 0は素数ではない\n    IsPrime[1] = false; // 1は素数ではない\n\n    for(size_t i=2; i*i<=max; ++i) // 0からsqrt(max)まで調べる\n        if(IsPrime[i]) // iが素数ならば\n            for(size_t j=2; i*j<=max; ++j) // (max以下の)iの倍数は\n                IsPrime[i*j] = false;      // 素数ではない\n}\n\nbool f(int a, int b)\n{\n  if(IsPrime[a]&&(b<a)) return true;\n  else return false;\n}\n\nsigned main() \n{\n  sieve(1000001);\n  int n=in();\n  int q[n];\n  rep(i,n) cin>>q[i];\n\n  ll p,e,mp,me;\n  if(IsPrime[q[0]]) mp=q[0];\n  else\n  {\n    cout<<0<<endl;\n    return 0;\n  }\n  me=1;\n  p=1,e=0;\n  for(int i=1;i<n;++i)\n  {\n    ll tp,te,tmp,tme; \n    if(f(q[i],mp)) \n    {\n      tp=p;\n      tmp=q[i];\n      te=p;\n      tme=mp;\n    }\n    else\n    {\n      tp=0;\n      tmp=mp;\n      te=p;\n      tme=mp;\n    }\n    if(f(q[i],me))\n    {\n      tp+=e%MOD;\n      tmp=q[i];\n    }\n    p=tp,e=te,mp=tmp,me=tme;\n\n  }\n  ll ans=(e+p)%MOD;\n  cout<<ans<<endl;\n\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nconst int MAX_P = 1000000; //max\nbool prime[MAX_P+1];\n\nvoid Eratosthenes(void){\n  for(int i=2;i<=MAX_P;i++)\n    prime[i]=true;\n  \n  for(int i=2;i*i<=MAX_P;i++)\n    if(prime[i])  \n      for(int j=i;i*j<=MAX_P;j++)\n        prime[i*j]=false;\n}\n\n\nint dp[SIZE][2];\n\n\nint main(){\n  int n;\n  int q[SIZE];\n  \n  Eratosthenes();\n\n  scanf(\"%d\",&n);\n\n  for(int i=1;i<=n;i++){\n    scanf(\"%d\",q+i);\n  }\n  q[0] = 1;\n\n  dp[0][0] = 1;\n  \n  for(int i=0;i<n;i++){\n    if(prime[q[i+1]]){\n      if(i < n-1){\n        if(q[i] < q[i+1])            dp[i+2][1] = (dp[i+2][1] + dp[i][0])%mod;\n        if(i > 0 && q[i-1] < q[i+1]) dp[i+2][1] = (dp[i+2][1] + dp[i][1])%mod;\n      }\n      if(q[i] < q[i+1])              dp[i+1][0] = (dp[i+1][0] + dp[i][0])%mod;\n      if(i > 0 && q[i-1] < q[i+1])   dp[i+1][0] = (dp[i+1][0] + dp[i][1])%mod;\n    } \n  }\n\n  printf(\"%d\\n\",(dp[n][0] + dp[n][1])%mod);\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\nvb isp;\nint max_p;\nvoid init_p( int mp = 1000010 ){\n  max_p = mp;\n  isp.resize( max_p , true );\n  isp[0] = isp[1] = false;\n  FOR( i , 2 , max_p ){\n    if( isp[i] ){\n      for( int j = i*2; j < max_p; j += i )\n\tisp[j] = false;\n    }\n  }\n}\nbool is_prime( int x ){\n  return isp[x];\n}\n\n\nint n;\n\nint a[100010];\n\nMod dp[100010][2];\n\nint main(){\n  init_p();\n  \n  n = in();\n  a[0] = -1;\n  REP( i , n ){\n    a[i+1] = in();\n  }\n\n  dp[0][0] = 1;\n  REP( i , n ){\n    REP( j , 2 ){\n      if(dp[i][j].n != 0){\n        if(a[i-j] < a[i+1] && is_prime(a[i+1])){\n          // cout << \"* \" << i+1 << \" \" << 0 << \" \" << dp[i+1][0].n << \" \" << dp[i][j].n << endl;\n          dp[i+1][0] += dp[i][j];\n          if(i+2 <= n && a[i+2] >= 2){\n            dp[i+2][1] += dp[i][j];\n            //cout << \"* \" << i+2 << \" \" << 1 << \" \" << dp[i+1][0].n << \" \" << dp[i][j].n << endl;\n          }\n        }\n      }\n    }\n  }\n\n  /*\n  REP( i , n+1 ){\n    cout << dp[i][0].n << \" \" << dp[i][1].n << endl;\n  }\n  */\n\n  Mod ans = dp[n][0] + dp[n][1];\n\n  cout << ans.n << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool prime[1000009];\n\nvoid era(){\n    prime[0]=1;\n    prime[1]=1;\n    for(int i=2;i<1000009;i++){\n        if(!prime[i]){\n            for(int j=i+i;j<1000009;j+=i) prime[j]=1;\n        }\n    }\n}\n\nint dp[100009];\n\nint main(){\n    era();\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++)cin>>a[i];\n    if(!prime[a[0]])dp[0]=1;\n    for(int i=0;i<n-1;i++){\n        if(!prime[a[i]]&&!prime[a[i+1]]&&a[i]<a[i+1])dp[i+1]+=dp[i];\n        if(i<n-2&&!prime[a[i]]&&!prime[a[i+2]]&&a[i]<a[i+2])dp[i+2]+=dp[i];\n    }\n    cout<<dp[n-1]+dp[n-2]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nvector<int> eratosthenes(int n) {\n  vector<int> res, p(n + 1, 1);\n  p[0] = p[1] = 0;\n  for (int i = 2; i * i <= n; ++i) {\n    if (p[i]) {\n      for (int j = 2 * i; j <= n; j += i) {\n        p[j] = 0;\n      }\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    if (p[i]) res.push_back(i);\n  }\n  // return res;\n  return p;\n}\n\nconst int mod = 1e9 + 7;\nvector<int> prime = eratosthenes(1000000);\n\nint n;\nvector<int> q;\n\nint dp[101010][2];\n\nint dfs(int idx = 1, int pre = 0) {\n  if (idx > q.size()) return 0;\n  if (idx == q.size()) {\n    return 1;\n  }\n\n  int &res = dp[idx][pre + 1 == idx];\n  if (~res) return res;\n  res = 0;\n  if (prime[q[idx]] && q[pre] < q[idx]) {\n    res += dfs(idx + 2, idx);\n    res %= mod;\n\n    res += dfs(idx + 1, idx);\n  }\n\n  return res;\n}\n\nsigned main(int argc, char *argv[]) {\n  memset(dp, -1, sizeof dp);\n\n  cin >> n;\n  q = vector<int>(n + 1);\n  for (int i = 1; i <= n; ++i) cin >> q[i];\n\n  cout << dfs() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n    is_p.resize(N, true);\n    is_p[0] = is_p[1] = false;\n    for(int i = 2; i*i <= N; i++) {\n        if(!is_p[i]) continue;\n        for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n    }\n}\n\nsigned main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout << fixed << setprecision(12);\n    \n    const int MAX_Q = 1000000;\n    \n    vector<bool> is_p;\n    enum_prime(MAX_Q, is_p);\n    \n    int n;\n    cin >> n;\n    vint q(n);\n    rep(i, n) cin >> q[i];\n    map<int,int>mp;\n    rep(i,n)mp[q[i]]++;\n    for(auto itr:mp){\n        if(is_p[itr.first]&&itr.second>=3)return puts(\"0\")*0;\n    }\n    if(!is_p[q[0]]) {\n        cout << 0 << endl;\n        return 0;\n    } else {\n        bool flag = true;\n        rep(i, n-1) {\n            if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n        }\n        if(!flag) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n    \n    vector<vint> dp(2, vint(n+1, -1));\n    dp[0][1] = 1;\n    dp[1][1] = 0;\n    reps(i, 1, n) {\n        if(is_p[q[i]]) {\n            if(i > 1 && is_p[q[i-1]] && is_p[q[i-2]]) {\n                if(q[i-1] == q[i] && q[i-2] >= q[i]) {\n                    cout << 0 << endl;\n                    return 0;\n                }\n            }\n            if(is_p[q[i-1]] && q[i-1] > q[i]) {\n                dp[0][i+1] = 0;\n                dp[1][i+1] = dp[0][i];\n            } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n                dp[0][i+1] = dp[1][i];\n                dp[1][i+1] = dp[0][i];\n            } else {\n                dp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n                dp[1][i+1] = dp[0][i];\n            }\n        } else {\n            dp[0][i+1] = 0;\n            dp[1][i+1] = dp[0][i];\n        }\n    }\n    cout << (dp[0][n]+dp[1][n])%mod << endl;\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nlist<int> Prime(int num) {\n\tlist<int>P;\n\tfor (int i = 5; i <= num; i += 6) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t\tflag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i + 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((i + 2) % j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i + 2);\n\t}\n\tP.push_front(3);\n\tP.push_front(2);\n\treturn P;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tlist<int>P = Prime(1000000);\n\tvector<bool>flag(1000001);\n\tfor (auto i : P) {\n\t\tif (i > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tflag[i] = true;\n\t}\n\tcin >> N;\n\tvector<int>v(N + 4);\n\tv[0] = 0;\n\tv[N + 1] = MOD;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> v[i];\n\t}\n\tvector<long long int>dp(N + 4);\n\tdp[0] = 1;\n\tfor (int i = 0; i <= N; i++) {\n\t\tif (!i){\n\t\t\tif (flag[v[1]]) {\n\t\t\t\tdp[1] = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (v[i] < v[i + 1]) {\n\t\t\tif (v[i + 1] == MOD || flag[v[i + 1]]) {\n\t\t\t\tdp[i + 1] += dp[i];\n\t\t\t\tdp[i + 1] %= MOD;\n\t\t\t}\n\t\t}\n\t\tif (v[i] < v[i + 2]) {\n\t\t\tif (v[i + 2] == MOD || flag[v[i + 2]]) {\n\t\t\t\tdp[i + 2] += dp[i];\n\t\t\t\tdp[i + 2] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N + 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvoid enum_prime(int N, vector<bool>& is_p)\n{\n  is_p.resize(N+1, true);\n  is_p[0] = is_p[1] = false;\n  for(int i = 2; i*i <= N; i++) {\n    if(!is_p[i]) continue;\n    for(int j = i+i; j <= N; j+=i) is_p[j] = false;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  const int MAX_Q = 1000000;\n\n  vector<bool> is_p;\n  enum_prime(MAX_Q, is_p);\n\n  int n;\n  cin >> n;\n\n  vint q(n);\n  rep(i, n) cin >> q[i];\n\n  if(n != 3 && n != 1) {\n    if(q[0] != 2 && q[0] != 3 && q[0] != 4) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  if(!is_p[q[0]]) {\n    cout << 0 << endl;\n    return 0;\n  } else {\n    bool flag = true;\n    rep(i, n-1) {\n      if(!is_p[q[i]] && !is_p[q[i+1]]) flag = false;\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<vint> dp(2, vint(n+1, -1));\n  dp[0][1] = 1;\n  dp[1][1] = 0;\n  reps(i, 1, n) {\n    if(is_p[q[i]]) {\n      if(i > 1 && is_p[q[i-2]]) {\n\tif((!is_p[q[i-1]] || q[i-1] <= q[i]) && q[i-2] >= q[i]) {\n\t  cout << 0 << endl;\n\t  return 0;\n\t}\n      }\n      if(is_p[q[i-1]] && q[i-1] > q[i]) {\n\tdp[0][i+1] = 0;\n\tdp[1][i+1] = dp[0][i];\n      } else if(is_p[q[i-1]] && q[i-1] == q[i]) {\n\tdp[0][i+1] = dp[1][i];\n\tdp[1][i+1] = dp[0][i];\n      } else {\n\tdp[0][i+1] = (dp[0][i]+dp[1][i])%mod;\n\tdp[1][i+1] = dp[0][i];\n      }\n    } else {\n      dp[0][i+1] = 0;\n      dp[1][i+1] = dp[0][i];\n    }\n  }\n  cout << (dp[0][n]+dp[1][n])%mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n;\nll a[100100];\nll dp[2][1001000];\nmap<ll, ll> id;\nbool used[1001000];\n\nvector<int> prime;\nbool is_prime[1001000];\n\nint sieve(int n) {//n以下の素数の数を返す\n\tint p = 0;\n\tfor (int i = 0; i <= n; i++)is_prime[i] = 1;\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tid[i] = prime.size() - 1;\n\t\t\tfor (int j = 2 * i; j <= n; j += i)is_prime[j] = 0;\n\t\t}\n\t}\n\treturn p;\n}\n\nint main() {\n\tsieve(1001000);\n\tcin >> n;\n\trep(i, n)cin >> a[i];\n\tif (!is_prime[a[0]])cout << 0 << endl;\n\telse {\n\t\tdp[0][0] = 1;\n\t\tFOR(i, 1, n) {\n\t\t\tif (is_prime[a[i]]) {\n\t\t\t\tif (i > 1 && a[i] > a[i - 2])dp[0][i] = (dp[0][i] + dp[1][i - 1]) % MOD;\n\t\t\t\tif (a[i] > a[i - 1])dp[0][i] = (dp[0][i] + dp[0][i - 1]) % MOD;\n\t\t\t\tif (is_prime[a[i - 1]])dp[1][i] = (dp[1][i] + dp[0][i - 1]) % MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (is_prime[a[i - 1]])dp[1][i] = (dp[1][i] + dp[0][i - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\trep(i, n)cout << dp[0][i] << \" \";\n\t\tcout << endl;\n\t\trep(i, n)cout << dp[1][i] << \" \";\n\t\tcout << endl;\n\t\tcout << mod_add(dp[0][n - 1], dp[1][n - 1]) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\nbool isprime(int v) {\n\tif (v == 1) return false;\n\tfor (int i = 2; 1LL*i*i <= v; i++) if (v%i == 0) return false;\n\treturn true;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n/*\n\n合成数は累乗にするしかない\n前回のpは最低2個前\n\n*/\n\n\n\n\n\n\n\n\n\nint N, A[101010];\nmint dp[101010][3];\n// dp[i][j] := i番目まででj個前がpとして使われている\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> A[i];\n\n    if (!isprime(A[0])) {\n        printf(\"0\\n\");\n        return;\n    }\n\n    dp[1][1] = 1;\n    rep(i, 1, N) rep(j, 1, 3) {\n        // 新しくpを作る\n        if (isprime(A[i]) and 0<=i-j and A[i - j] < A[i]) dp[i + 1][1] += dp[i][j];\n\n        // 累乗にする\n        if (j == 1) dp[i + 1][2] += dp[i][j];\n    }\n\n    mint ans = dp[N][1] + dp[N][2];\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 1001000;\nbool prime[N];\n\nconst ll mod = 1e9+7;\n\nint main(){\n    fill(prime,prime+N,true);\n    prime[0] = prime[1] = false;\n    for(int i=2; i<N; ++i){\n        if(prime[i]) for(int j=2*i; j<N; j+=i) prime[j] = false;\n    }\n\n    int n;\n    cin >>n;\n    vector<int> q(n);\n    rep(i,n) cin >>q[i];\n    q.pb(1000999);\n\n    vector<ll> dp(n+1);\n    dp[0] = 1;\n    rep(i,n)if(prime[q[i]]){\n        // 1個\n        if(i+1<=n && prime[q[i+1]] && q[i]<q[i+1]) (dp[i+1] += dp[i]) %= mod;\n\n        // 2個\n        if(i+2<=n && prime[q[i+2]] && q[i]<q[i+2]) (dp[i+2] += dp[i]) %= mod;\n    }\n    cout << dp[n] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <bitset>\n#include <climits>\n#define REP(i, n) for(LL i = 0;i < n;i++)\n#define REPR(i, n) for(LL i = n;i >= 0;i--)\n#define FOR(i, m, n) for(LL i = m;i < n;i++)\n#define FORR(i, m, n) for(LL i = m;i >= n;i--)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define INF (int)1e9\n#define INFL (LL)1e15\n#define MOD 1000000007\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n//#define int long long\nbool isprime(LL x){\n    if(x == 2) return true;\n    if(x < 2 || x % 2 == 0) return false;\n    LL i = 3;\n    LL sqrtx = sqrt(x);\n    while(i <= sqrtx){\n        if(x % i == 0) return false;\n        i += 2;\n    }\n    return true;\n}\n// maxまでの素数をvectorに入れて返す\nvector<LL> eratos(LL max){\n    vector<LL> primeVec;\n    vector<bool> isprime;\n    double sqrtmax = sqrt(max);\n    isprime.resize(max + 1);\n    isprime[0] = false; isprime[1] = false;\n    FOR(i, 2, max + 1){\n        isprime[i] = true;\n    }\n    FOR(i, 2, sqrtmax){\n        if(isprime[i]){\n            for(int j = 0; i * (j + 2) < max + 1; ++j){\n                isprime[i * (j + 2)] = false;\n            }\n        }\n    }\n    REP(i, max + 1){\n        if(isprime[i])  primeVec.pb(i);\n    }\n    return primeVec;\n}\n/*************** using variables ***************/\nint pre_prime = 0;\nLL ans = 0;\nint n;\nvector<int> q;\nbool flag = false;\n/**********************************************/\n\nLL kaijou(LL n){\n    LL ret = 1;\n    REP(i, n){\n        ret = ret * 2 % MOD;\n    }\n\n    return ret;\n}\n\nsigned main(){\n    cin >> n;\n    q.resize(n);\n    REP(i, n) cin >> q[i];\n    \n    if(n == 1){\n        if(!isprime((LL)q[0]) || q[0] < pre_prime){\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n    REP(i, n){\n        int cnt = -1;\n        if(!isprime((LL)q[i]) || q[i] < pre_prime){\n            if(flag == true){\n                cout << 0 << endl;\n                return 0;\n            }\n            flag = true;\n            if(cnt <= 1){\n                ans = ans + 1 % MOD;\n            }else if(cnt == 2){\n                ans = ans + 2 % MOD;\n            }else if(cnt % 2 == 0){\n                ans = (ans + kaijou(n/2)) % MOD;\n            }else{\n                ans = (ans + kaijou(n/2) * 2 % MOD) % MOD;\n            }\n            cnt = -1;\n        }else{\n            cnt++;\n            if(i == n-1){\n                if(cnt <= 1){\n                    ans = ans + 1 % MOD;\n                }else if(cnt == 2){\n                    ans = ans + 2 % MOD;\n                }else if(cnt % 2 == 0){\n                    ans = (ans + kaijou(n/2)) % MOD;\n                }else{\n                    ans = (ans + kaijou(n/2) * 2 % MOD) % MOD;\n                }\n            }\n            pre_prime = q[i];\n            flag = false;\n        }\n    }\n\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n// #define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> Eratosthenes(int n) {\n\tstd::vector<int> num(n + 1, 0);\n\tnum[0] = num[1] = -1;\n\tint cnt = 0;\n\tfor (int i = 2; i*i < n; ++i) {\n\t\tif (num[i] == 0) {\n\t\t\tfor (int j = 2; (i + 1)*j <= n; ++j) {\n\t\t\t\tnum[i*j] = -1;\n\t\t\t}\n\t\t\tnum[i] = cnt++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint dp[2][2][78500];\n// dp[i][j][k]=i%2番目までみてi番目を(j:p->0/e->1)として出てきた最大の素数がkの場合の数\n\nauto solve() {\n\tVAR(int, n);\n\tVEC(int, q, n);\n\tauto p(Eratosthenes(1000001));\n\n\tif (p[q[0]] == -1) return 0;\n\tdp[1][0][p[q[0]]] = 1;\n\tint mi = p[q[0]], ma = p[q[0]];\n\tFOR(i, 1, n) {\n\t\tint nmi = INFINT, nma = -INFINT;\n\t\tREP(j, 2) {\n\t\t\tif (p[q[i]] == -1 && j == 1) continue;\n\t\t\tFOR(k, mi, ma + 1) {\n\t\t\t\tif (dp[i & 1][j][k] == 0) continue;\n\t\t\t\tif (p[q[i]] == -1) { // 素数じゃない\n\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t}\n\t\t\t\telse { // 素数\n\t\t\t\t\tif (k >= p[q[i]]) {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(dp[1 - i % 2][0][p[q[i]]] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\tCHMIN(nmi, p[q[i]]);\n\t\t\t\t\t\tCHMAX(nma, p[q[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nmi > nma) return 0;\n\t\tmi = nmi;\n\t\tma = nma;\n\t\tFILL(dp[i % 2], 0);\n\t}\n\tint ans = 0;\n\tREP(j, 2) REP(k, ma + 1) {\n\t\t(ans += dp[n & 1][j][k]) %= MOD;\n\t}\n\treturn ans;\n};\n\nsigned main() {\n\tINIT;\n\n\tOUT(solve())BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> Eratosthenes(int n) {\n\tstd::vector<int> num(n + 1, 0);\n\tnum[0] = num[1] = -1;\n\tint cnt = 0;\n\tfor (int i = 2; i*i < n; ++i) {\n\t\tif (num[i] == 0) {\n\t\t\tfor (int j = 2; (i + 1)*j <= n; ++j) {\n\t\t\t\tnum[i*j] = -1;\n\t\t\t}\n\t\t\tnum[i] = cnt++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint dp[2][2][78500];\n// dp[i][j][k] = i%2番目までみてi番目を(j:p->0/e->1)として出てきた\n//               最大の素数がk番目の素数の場合の数\n\nint solve() {\n\tVAR(int, n);\n\tVEC(int, q, n);\n\tauto p(Eratosthenes(1000001));\n\n\tif (p[q[0]] == -1) return 0;\n\tdp[1][0][p[q[0]]] = 1;\n\tint mi = p[q[0]], ma = p[q[0]];\n\tFOR(i, 1, n) {\n\t\tint nmi = INFINT, nma = -INFINT;\n\t\tREP(j, 2) {\n\t\t\tif (p[q[i]] == -1 && j == 1) continue;\n\t\t\tFOR(k, mi, ma + 1) {\n\t\t\t\tif (dp[i & 1][j][k] == 0) continue;\n\t\t\t\tif (p[q[i]] == -1) { // 素数じゃない\n\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t}\n\t\t\t\telse { // 素数\n\t\t\t\t\tif (k >= p[q[i]]) {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(dp[1 - i % 2][0][p[q[i]]] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\tCHMIN(nmi, p[q[i]]);\n\t\t\t\t\t\tCHMAX(nma, p[q[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nmi > nma) return 0;\n\t\tmi = nmi;\n\t\tma = nma;\n\t\tFILL(dp[i % 2], 0LL);\n\t}\n\tint ans = 0;\n\tREP(j, 2) REP(k, ma + 1) {\n\t\t(ans += dp[n % 2][j][k]) %= MOD;\n\t}\n\treturn ans;\n};\n\nsigned main() {\n\tINIT;\n\n\tOUT(solve())BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n#define MAX 1000100\nint MOD=1000000007;\nint sosu[MAX]={1,1,0};\nvi sos;\nvoid init(){\n\tfor(int i=2;i*i<=MAX;i++)if(!sosu[i])\n\tfor(int j=i*2;j<MAX;j+=i)sosu[j]=true;\n\trep(i,MAX)if(sosu[i]==0)sos.pb(i);\n}\nint main(){\n\tinit();\n\tint n;\n\tcin>>n;\n\tvi in(n+1,inf);\n\trep(i,n)cin>>in[i];\n\t\n\tif(n==1){\n\t\tcout<<!sosu[in[0]]<<endl;\n\t\treturn 0;\n\t}\n\t\n\tvi dp(n+1);\n\tdp[n]=1;\n\tif(!sosu[in[n-1]])dp[n-1]=1;\n\tfor(int i=n-2;i>=0;i--)if(!sosu[in[i]]){\n\t\tif(in[i]<in[i+1])(dp[i]+=dp[i+1])%=MOD;\n\t\tif(in[i]<in[i+2])(dp[i]+=dp[i+2])%=MOD;\n\t}\n\tcout<<dp[0]<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t N;\n\nstd::vector<bool> IsPrime;\nvoid sieve(uint64_t max) {\n\tif (max + 1 > IsPrime.size()) {     // resizeで要素数が減らないように\n\t\tIsPrime.resize(max + 1, true); // IsPrimeに必要な要素数を確保\n\t}\n\tIsPrime[0] = false; // 0は素数ではない\n\tIsPrime[1] = false; // 1は素数ではない\n\n\tfor (uint64_t i = 2; i*i <= max; ++i) // 0からsqrt(max)まで調べる\n\t\tif (IsPrime[i]) // iが素数ならば\n\t\t\tfor (uint64_t j = 2; i*j <= max; ++j) // (max以下の)iの倍数は\n\t\t\t\tIsPrime[i*j] = false;      // 素数ではない\n}\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<1000000007> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\n//9592\n\nint32_t q[100000];\nbool used[100000][2][2];\nmint dp[100000][2][2];\n\nmint func(int i, int diff, int is_bef_prime)\n{\n\tif (i == N) {\n\t\treturn 1_mi;\n\t}\n\tauto& memo = dp[i][diff - 1][is_bef_prime];\n\tif (used[i][diff - 1][is_bef_prime]) {\n\t\treturn memo;\n\t}\n\tused[i][diff - 1][is_bef_prime] = true;\n\n\tif (i == 0 ){\n\t\t//素数only\n\t\tif (IsPrime[q[i]]) {\n\t\t\treturn memo = func(i + 1, 1, true);\n\t\t}\n\t\telse{\n\t\t\treturn memo = 0;\n\t\t}\n\t}\n\n\tif (IsPrime[q[i]] == false || q[i - diff] >= q[i]) {\n\t\t//係数only\n\t\tif (is_bef_prime) {\n\t\t\treturn memo = func(i + 1, 2, false);\n\t\t}\n\t\telse {\n\t\t\treturn memo = 0_mi;\n\t\t}\n\t}\n\tif (is_bef_prime == false) {\n\t\t//素数only\n\t\treturn memo = func(i + 1, 1, true);\n\t}\n\n\t//両方\n\treturn memo = func(i + 1, 2, false) + func(i+1, 1, true);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tsieve(100000);\n\n\tin >> N;\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> q[i];\n\n\t}\n\n\tout << func(0, 1, true) << endl;\n\n\treturn 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> Eratosthenes(int n) {\n\tstd::vector<int> num(n + 1, 0);\n\tnum[0] = num[1] = -1;\n\tint cnt = 0;\n\tfor (int i = 2; i*i < n; ++i) {\n\t\tif (num[i] == 0) {\n\t\t\tfor (int j = 2; i*j <= n; ++j) {\n\t\t\t\tnum[i*j] = -1;\n\t\t\t}\n\t\t\tnum[i] = cnt++;\n\t\t}\n\t}\n\treturn num;\n}\n\nint dp[2][2][78500];\n// dp[i][j][k] = i%2番目までみてi番目を(j:p->0/e->1)として出てきた\n//               最大の素数がk番目の素数の場合の数\n\nint solve(int n, std::vector<int> q) {\n\tauto p(Eratosthenes(1000001));\n\n\tif (p[q[0]] == -1) return 0;\n\tdp[1][0][p[q[0]]] = 1;\n\tint mi = p[q[0]], ma = p[q[0]];\n\tFOR(i, 1, n) {\n\t\tint nmi = INFINT, nma = -INFINT;\n\t\tREP(j, 2) {\n\t\t\tif (p[q[i]] == -1 && j == 1) continue;\n\t\t\tFOR(k, mi, ma + 1) {\n\t\t\t\tif (dp[i & 1][j][k] == 0) continue;\n\t\t\t\tif (p[q[i]] == -1) { // 素数じゃない\n\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t}\n\t\t\t\telse { // 素数\n\t\t\t\t\tif (k >= p[q[i]]) {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\t(dp[1 - i % 2][1][k] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\t\tCHMIN(nmi, k);\n\t\t\t\t\t\t\tCHMAX(nma, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(dp[1 - i % 2][0][p[q[i]]] += dp[i % 2][j][k]) %= MOD;\n\t\t\t\t\t\tCHMIN(nmi, p[q[i]]);\n\t\t\t\t\t\tCHMAX(nma, p[q[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nmi > nma) return 0;\n\t\tmi = nmi;\n\t\tma = nma;\n\t\tFILL(dp[i % 2], 0);\n\t}\n\tint ans = 0;\n\tREP(j, 2) REP(k, ma + 1) {\n\t\t(ans += dp[n % 2][j][k]) %= MOD;\n\t}\n\treturn ans;\n};\n\nint solve2(int n, std::vector<int> q) {\n\tauto p(Eratosthenes(2000001));\n\n\tstd::map<PAIR, ll> map;\n\tstd::function<ll(int, int)> rec = [&](int i, int ma) {\n\t\tif (i == n) return 1LL;\n\t\tif (i > n) return 0LL;\n\t\tif (p[q[i]] == -1) return 0LL;\n\t\tif (ma >= q[i]) return 0LL;\n\t\tif (map.count(PAIR(i, ma))) return map[PAIR(i, ma)];\n\n\t\tll re = 0;\n\t\t(re += rec(i + 1, q[i])) %= MOD;\n\t\t(re += rec(i + 2, q[i])) %= MOD;\n\t\treturn map[PAIR(i, ma)] = re;\n\t};\n\treturn rec(0, -1) % MOD;\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC(int, q, n);\n\n\tOUT(solve2(n, q))BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(auto i = a; i < b; i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nint n;\nlong long q[1000010];\nbool b[1000010];\nlong long memo[100010][2];\n\nlong long solve(int i = 0, int prevIsE = true) {\n\tint pear = 1, berry = 1;\n\tbool flaga = false, flagb = false;\n\tif (i == n) {\n\t\treturn 1;\n\t}\n\tif (memo[i][prevIsE] != -1) {\n\t\treturn memo[i][prevIsE];\n\t}\n//\tcout << i << \" \" << b[q[i]] << \" \" << q[i - 1 - prevIsE] << \" \" << q[i] << endl;\n\tif (i != 0 && b[q[i]] && q[i - 1 - prevIsE] < q[i]\n\t || i == 0 && b[q[i]]) {\n//\tif (sosu[q[i]] && prevSosu < q[i]) {\n//\t\tcout << i << \" is q\" << endl;\n\t\tpear = pear * solve(i + 1, false) % MOD;\n\t\tflaga = true;\n\t}\n\tif (!prevIsE) {\n//\t\tcout << i << \" is e\" << endl;\n\t\tberry = berry * solve(i + 1, true) % MOD;\n\t\tflagb = true;\n\t}\n\tpear *= flaga;\n\tberry *= flagb;\n//\tcout << i << \" \" << pear + berry << endl;\n\treturn memo[i][prevIsE] = (pear + berry) % MOD;\n}\n\n\nsigned main() {\n\tcin >> n;\n\trep (i, n) {\n\t\tcin >> q[i];\n\t\tb[q[i]] = true;\n\t\tfor (int j = 2; j * j <= q[i]; j++) b[q[i]] = b[q[i]] && (q[i] % j != 0);\n\t}\n\trep (i, 100010) rep (j, 2) memo[i][j] = -1;\n\tcout << solve() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\nvi ps;\nvb isp;\nint max_p;\nvoid init_p( int mp = 1000010 ){\n  max_p = mp;\n  isp.resize( max_p , true );\n  isp[0] = isp[1] = false;\n  FOR( i , 2 , max_p ){\n    if( isp[i] ){\n      ps.pb( i );\n      for( int j = i*2; j < max_p; j += i )\n\tisp[j] = false;\n    }\n  }\n}\nbool is_prime( int x ){\n  if( max_p <= x ) init_p( x+1 );\n  return isp[x];\n}\n\n\nint n;\n\nint a[100010];\n\nMod dp[100010][2];\n\nint main(){\n\n  n = in();\n  a[0] = -1;\n  REP( i , n ){\n    a[i+1] = in();\n  }\n\n  dp[0][0] = 1;\n  REP( i , n ){\n    REP( j , 2 ){\n      if(dp[i][j].n != 0){\n        if(a[i-j] < a[i+1] && is_prime(a[i+1])){\n          // cout << \"* \" << i+1 << \" \" << 0 << \" \" << dp[i+1][0].n << \" \" << dp[i][j].n << endl;\n          dp[i+1][0] += dp[i][j];\n          if(i+2 <= n && a[i+2] >= 2){\n            dp[i+2][1] += dp[i][j];\n            //cout << \"* \" << i+2 << \" \" << 1 << \" \" << dp[i+1][0].n << \" \" << dp[i][j].n << endl;\n          }\n        }\n      }\n    }\n  }\n\n  /*\n  REP( i , n+1 ){\n    cout << dp[i][0].n << \" \" << dp[i][1].n << endl;\n  }\n  */\n\n  Mod ans = dp[n][0] + dp[n][1];\n\n  cout << ans.n << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<unsigned MOD>\nclass ModInt {\npublic:\n  unsigned x;\n  ModInt(): x(0) { }\n  ModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n  unsigned get() const { return x; }\n\n  // 逆数\n  ModInt inv() const {\n    ll a = 1, p = x, e = MOD-2;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // e乗\n  ModInt pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n  // 2のx乗\n  ModInt pow2() {\n    ll a = 1, p = 2, e = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    a %= MOD;\n    return ModInt(a);\n  }\n\n  // Comparators\n  bool operator <(ModInt b) { return x < b.x; }\n  bool operator >(ModInt b) { return x > b.x; }\n  bool operator<=(ModInt b) { return x <= b.x; }\n  bool operator>=(ModInt b) { return x >= b.x; }\n  bool operator!=(ModInt b) { return x != b.x; }\n  bool operator==(ModInt b) { return x == b.x; }\n\n  // increment, decrement\n  ModInt operator++() { x++; return *this; }\n  ModInt operator--() { x--; return *this; }\n\n  // Basic Operations\n  ModInt &operator+=(ModInt that) {\n    x = ((ll)x+that.x)%MOD;\n    return *this;\n  }\n  ModInt &operator-=(ModInt that) {\n    x = ((((ll)x-that.x)%MOD)+MOD)%MOD;\n    return *this;\n  }\n  ModInt &operator*=(ModInt that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  // O(log(mod))かかるので注意\n  ModInt &operator/=(ModInt that) {\n    x = (ll)x * that.inv() % MOD;\n    return *this;\n  }\n  ModInt &operator%=(ModInt that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  ModInt operator+(ModInt that)const{return ModInt(*this) += that;}\n  ModInt operator-(ModInt that)const{return ModInt(*this) -= that;}\n  ModInt operator*(ModInt that)const{return ModInt(*this) *= that;}\n  ModInt operator/(ModInt that)const{return ModInt(*this) /= that;}\n  ModInt operator%(ModInt that)const{return ModInt(*this) %= that;}\n};\ntypedef ModInt<1000000007> mint;\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\nbool prime[1000010];\nmint dp[100010][2];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n; cin >> n;\n  VI q(n);\n  REP(i, n) cin >> q[i];\n\n  memset(prime, true, sizeof(prime));\n  prime[0] = prime[1] = false;\n  for (int i = 2; i * i <= 1000010; i++) {\n    if (prime[i]) {\n      for (int j = 2 * i; j <= 1000010; j += i) {\n        prime[j] = false;\n      }\n    }\n  }\n\n  dp[0][1] = (prime[q[0]] ? 1 : 0);\n  FOR(i, 1, n) {\n    if(prime[q[i-1]]) dp[i][0] += dp[i-1][1];\n    if(prime[q[i]] && prime[q[i-1]] && q[i-1] < q[i]) dp[i][1] += dp[i-1][1];\n    if(i >= 2 && prime[q[i]] && prime[q[i-2]] && q[i-2] < q[i]) dp[i][1] += dp[i-1][0];\n  }\n  cout << dp[n-1][0] + dp[n-1][1] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nbool p[1000010];\nvoid init(){\n    int MAX = 1000010;\n    for(int i=0;i<MAX;i++) p[i]=1;\n    p[0]=0, p[1] = 1;\n    for(int i=2;i<=MAX/2;i++){\n        if(p[i]){\n            for(int j=i+i;j<MAX;j+=i) p[j]=0;\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int n;\n    cin>>n;\n    int a[n];\n    init();\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    if(p[a[0]]==false){\n        cout << 0 << endl;\n        return 0;\n    }\n    ll mod = 1e9+7;\n    ll dp[n+1][2]={};\n    dp[0][0]=1;\n    for(int i=0;i<n;i++){\n        if(i) dp[i+1][1] += dp[i][0];\n        dp[i+1][1] %= mod;\n        if(i-2>=0 && a[i]>a[i-2] && p[a[i]]){\n            dp[i+1][0] += dp[i][1];\n        }\n        if(i && a[i]>a[i-1] && p[a[i]]){\n            dp[i+1][0] += dp[i][0];\n        }\n        if(i==0){\n            dp[i+1][0] += dp[i][0];\n        }\n        dp[i+1][0] %= mod;\n    }\n    ll ans = dp[n][0] + dp[n][1];\n    ans %= mod;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1010000\n\nenum Type{\n\tprime,\n\tmult,\n};\n\nbool is_prime[NUM];\nll table[100001];\nll dp[100001][2];\n\nint main(){\n\n\tfor(int i = 0; i < NUM; i++)is_prime[i] = true;\n\n\tis_prime[0] = false;\n\tis_prime[1] = false;\n\n\tfor(int i = 2; i <= sqrt(NUM); i++){\n\t\tif(is_prime[i]){\n\t\t\tfor(int k = 2*i; k < NUM; k += i){\n\t\t\t\tis_prime[k] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++)scanf(\"%lld\",&table[i]);\n\n\tif(!is_prime[table[0]]){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tdp[i][prime] = 0;\n\t\tdp[i][mult] = 0;\n\t}\n\n\tdp[0][prime] = 1;\n\n\tfor(int i = 1; i <= N-1; i++){\n\t\tdp[i][mult] += dp[i-1][prime];\n\n\t\tif(is_prime[table[i]]){\n\n\t\t\tif(table[i-1] < table[i] && is_prime[table[i-1]] == true){\n\t\t\t\tdp[i][prime] += dp[i-1][prime];\n\t\t\t}\n\n\t\t\tif(i >= 2 && table[i-2] < table[i] && is_prime[table[i-2]] == true){\n\t\t\t\tdp[i][prime] += dp[i-1][mult];\n\t\t\t}\n\t\t}\n\t\tdp[i][mult] %= MOD;\n\t\tdp[i][prime] %= MOD;\n\t}\n\n\tll ans = dp[N-1][prime]+dp[N-1][mult];\n\tans %= MOD;\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nbool isPrime(ll n){\n  for(ll i=2;i*i<=n;i++)if(n%i==0) return 0;\n  return 1;\n}\n\nint n;\nvector<int> A;\n\nint mem[N],used[N];\n\nbool check(int i,int j){return A[i] < A[j];}\n\nint dfs(int idx){\n  if(idx > n) return 0;\n  if(idx == n) return 1;\n  if(used[idx]++) return mem[idx];\n  \n  int num = A[idx];\n  if(!isPrime(num)) return mem[idx] = 0;\n  \n  int res = 0;\n  if(check(idx,idx+1)) res = (res + dfs(idx+1)) % mod;\n  if(check(idx,idx+2)) res = (res + dfs(idx+2)) % mod;\n  return mem[idx] = res;\n}\n\nsigned main(){\n  cin>>n;\n  A.resize(n);\n  cin>>A;\n  \n  A.push_back(1e9);\n  A.push_back(1e9);\n\n  int ans = dfs(0);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day3/problems/D>\n問題文============================================================\n\n えびちゃんは素因数分解マシンの不良品を持っています。\n この機械は、2 以上の自然数 M を与えると O(logM) でその素因数分解を行ってくれますが、\n 困ったことに数字以外を表示できないバグがありました。\n \n 一般に、M の素因数分解が p1e1×p2e2×…×pKeK (ただし i<j ならば pi<pj、また各 pi は素数) の場合を考えます。\n M を与えると、この機械は i=1 から順に以下のように出力を行います。全ての数字はスペース区切りで表示されます。\n \n ei=1 ならば pi を出力する\n ei>1 ならば pi ei を出力する\n \n たとえば、22 や 2048 を与えると 2 11 と表示され、24 や 54 を与えると 2 3 3 と表示されます。\n \n さて、えびちゃんは表示された素因数分解をメモしておいたのですが、\n 与えた自然数をメモしておくのを忘れていたことに気づきました。\n 素因数分解のメモが与えられるので、元の自然数としてありえるものがいくつあるかを求めてください。\n ただし、メモが間違っていて、条件を満たす自然数が一つも存在しないこともあります。\n \n また、その個数は非常に大きくなる場合があるので、109+7 (素数) で割ったあまりを出力してください。\n \n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\n#define MAX_N 1000005\nbool is_prime[MAX_N];\nconst ll MOD = 1e9+7;\n\nbool IsPrime(int num)\n{\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2){\n        if (num % i == 0){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid init(){\n    for(int i = 1; i < MAX_N;i++){\n        is_prime[i] = IsPrime(i);\n    }\n}\nll solve(){\n    ll N; cin >> N;\n    vector<ll> q(N);\n    for(auto& in:q)cin >> in;\n\n    if(!is_prime[q[0]]) return 0;\n    if(N == 1) return 1;\n    \n    int cnt = 0;\n    for(int i = 0; i < N;i++){\n        if(!is_prime[q[i]]) cnt++;\n        else cnt = 0;\n        if(cnt == 2) return 0;\n    }\n\n    vector<ll> dp(N+1,0);\n    dp[0] = 1;\n    for(int i = 0; i < N;i++){\n        if(is_prime[q[i]]){\n            if( i+1 < N && is_prime[q[i+1]] && (q[i] < q[i+1])){\n                (dp[i+1] += dp[i])%=MOD;\n            }\n            if( i+2 < N && is_prime[q[i+2]] && (q[i] < q[i+2])){\n                (dp[i+2] += dp[i])%=MOD;\n            }\n        }\n    }\n    return (dp[N-1]+dp[N-2])%MOD;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    init();\n    cout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nbool prime[1000009];\n\nvoid era(){\n    prime[0]=1;\n    prime[1]=1;\n    for(int i=2;i<1000009;i++){\n        if(!prime[i]){\n            for(int j=i+i;j<1000009;j+=i) prime[j]=1;\n        }\n    }\n}\n\nint dp[100009];\n\nsigned main(){\n    era();\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++)cin>>a[i];\n    if(!prime[a[0]])dp[0]=1;\n    for(int i=0;i<n-1;i++){\n        if(!prime[a[i]]&&!prime[a[i+1]]&&a[i]<a[i+1])dp[i+1]+=dp[i];\n        if(i<n-2&&!prime[a[i]]&&!prime[a[i+2]]&&a[i]<a[i+2])dp[i+2]+=dp[i];\n        dp[i+1]%=1000000007;\n        dp[i+2]%=1000000007;\n    }\n    cout<<dp[n-1]+dp[n-2]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nconstexpr int M = 1e9 + 7;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> q(N);\n    vector<bool> b(N, false);\n    for(int i = 0; i < N; ++i) {\n        cin >> q[i];\n        for(int x = 2; x * x <= q[i]; ++x) {\n            if(q[i] % x == 0) b[i] = true;\n        }\n    }\n\n    // dp[i][pre is p]\n    vector<vector<int>> dp(N + 1, vector<int>(2));\n    dp[0][0] = 1;\n    for(int i = 0; i < N; ++i) {\n        if(i == 0 && !b[i]) {\n            dp[i + 1][1] = 1;\n            continue;\n        }\n        for(int j = 0; j < 2; ++j) {\n            if(j == 0) {\n                if((i < 2 || (q[i - 2] != q[i] && q[i - 2] < q[i]))\n                    && !b[i]) {\n                    (dp[i + 1][1] += dp[i][j]) %= M;\n                }\n            } else { // pre is p\n                if(q[i - 1] == q[i]) {\n                    (dp[i + 1][0] += dp[i][j]) %= M;\n                } else {\n                    if(q[i - 1] < q[i] && !b[i]) {\n                        (dp[i + 1][1] += dp[i][j]) %= M;\n                    }\n                    (dp[i + 1][0] += dp[i][j]) %= M;\n                }\n            }\n        }\n    }\n    int ans = (dp[N][0] + dp[N][1]) % M;\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nint main() {\n    int isp[1000010] = {};\n    for (int i = 2; i < 1000010; i++) isp[i] = 1;\n    for (int i = 2; i * i < 1000010; i++) if (isp[i]) for (int j = i * i; j < 1000010; j += i) isp[j] = 0;\n\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<vector<long long>> dp(n, vector<long long>(2));\n    dp[0][0] = isp[a[0]];\n    for (int i = 1; i < n; ++i) {\n        if (a[i] > a[i - 1] && isp[a[i]]) {\n            dp[i][0] = (dp[i][0] + dp[i - 1][0]) % M;\n        }\n        if (i > 1 && a[i] > a[i - 2] && isp[a[i]]) {\n            dp[i][0] = (dp[i][0] + dp[i - 2][0]) % M;\n        }\n        dp[i][1] = dp[i - 1][0];\n    }\n    cout << (dp[n - 1][0] + dp[n - 1][1]) % M << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\n\nconst int N = 1111111;\nbool prime[N + 1];\nvector<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tif (!prime[i]) continue;\n\t\tfor (int j = i; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i])\n\t\t{\n\t\t\tprimes.push_back(i);\n\t\t}\n\t}\n}\n\nll pow(ll x, ll n, ll mod)\n{\n\tll res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x*x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint n;\nvi q;\nll dp[111111];\n\nll solve(int p)\n{\n\tif (dp[p] >= 0) return dp[p];\n\tif (p == n) return 0;\n\tif (p == n - 1)\n\t{\n\t\tif (prime[q[p]])\treturn 1;\n\t\telse return 0;\n\t}\n\tll res = 0;\n\tif (prime[q[p + 1]] && q[p + 1] > q[p])\n\t{\n\t\tres += solve(p + 1);\n\t}\n\tif (p + 2 < n && prime[q[p + 2]] && q[p + 2] > q[p])\n\t{\n\t\tres += solve(p + 2);\n\t}\n\tif (p + 2 == n)\n\t{\n\t\tres += 1;\n\t}\n\treturn dp[p] = res % MOD;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tMS(dp, -1);\n\thurui();\n\tcin >> n;\n\tq.resize(n);\n\tcin >> q;\n\tif(prime[q[0]]) cout << solve(0) << endl;\n\telse cout << 0 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MOD 1000000007\nint prime[1000000+10];\nvoid makep(int n){prime[0]=prime[1]=1;for(int i=2;i*i<=n;i++)if(!prime[i])for(int j=i*i;j<=n;j+=i)prime[j]=1;}\n\nint dp[100010];//a[i]を素数として使う場合の数\nint a[100010];\nint main(){\n\tmakep(1000005);\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tdp[1]=!prime[a[1]];\n\t\n\tfor(int i=2;i<=n;i++)if(!prime[a[i]]){\n\t\t//素数\n\t\tif(a[i-1]<a[i])dp[i]+=dp[i-1];\n\t\tif(a[i-2]<a[i])dp[i]+=dp[i-2];\n\t\tdp[i]%=MOD;\n\t}\n\tprintf(\"%d\\n\",(dp[n]+dp[n-1])%MOD);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define p (int)(1e9 + 7)\n\nint main(){\n\tint N, i, j, maxq = 0;\n\tscanf(\"%d\", &N);\n\tint *q = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &q[i]);\n\t\tif(q[i] > maxq){\n\t\t\tmaxq = q[i];\n\t\t}\n\t}\n\tint *is_prime = (int *)malloc(sizeof(int) * (maxq + 1));\n\tfor(i = 0; i <= maxq; i++){\n\t\tis_prime[i] = 1;\n\t}\n\tfor(i = 2; i <= maxq; i++){\n\t\tif(is_prime[i] == 1){\n\t\t\tfor(j = 2; i * j <= maxq; j++){\n\t\t\t\tis_prime[i * j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif(N == 1){\n\t\tif(is_prime[q[0]] == 1){\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\tint *dp1 = (int *)malloc(sizeof(int) * N);\n\tint *dp2 = (int *)malloc(sizeof(int) * N);\n\tdp1[0] = is_prime[q[0]] == 1 ? 1 : 0;\n\tdp2[0] = 0;\n\tdp1[1] = (is_prime[q[1]] == 1 && q[0] < q[1]) ? dp1[0] : 0;\n\tdp2[1] = dp1[0];\n\tfor(i = 2; i < N; i++){\n\t\tdp1[i] = 0;\n\t\tif(is_prime[q[i]] == 1){\n\t\t\tif(q[i - 1] < q[i]){\n\t\t\t\tdp1[i] += dp1[i - 1];\n\t\t\t}\n\t\t\tif(q[i - 2] < q[i]){\n\t\t\t\tdp1[i] += dp2[i - 1];\n\t\t\t}\n\t\t}\n\t\tdp1[i] %= p;\n\t\tdp2[i] = dp1[i - 1];\n\t}\n\tprintf(\"%d\\n\", (dp1[N - 1] + dp2[N - 1]) % p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint isPrime(int n){\n    if(n==2)return 1;\n    for(int i=2;i*i<=n;i++)if(n%i==0)return 0;\n    return 1;\n}\n\nint main(void){\n    const int  yamada = 1e9+7;\n    int N;\n    scanf(\"%d\",&N);\n   // for(int i=0;i<1145140;i++)prime[i]=1;\n   // prime[1]=0;\n   // prime[2]=1;\n    //for(int i=3;i<1145140;i++)for(int j=2;j*j<=i;j++){if(i%j==0)prime[i]=0;}\n    long long int po[2];\n    po[0]=1;\n    po[1]=0;\n    int a[N+2];\n    a[0]=1;\n    a[1]=1;\n    for(int i=2;i<N+2;i++){scanf(\"%d\",&a[i]);\n        long long int kari[2];\n        kari[0]=po[0];\n        kari[1]=po[1];\n        po[0]=isPrime(a[i])*((a[i-1]<a[i])*kari[0]+(a[i-2]<a[i])*kari[1]);\n        po[0]%=yamada;\n        if(i>2)po[1]=kari[0];\n        po[1]%=yamada;\n       // printf(\"%lld %lld\\n\",po[0],po[1]);\n    }\n    po[0]+=po[1];\n    po[0]%=yamada;\n    printf(\"%lld\\n\",po[0]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2870 The Diversity of Prime Factorization\n// 2018.3.29 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define M 1000000007\nchar prime[1000010];         // prime table\nint  q[100005];\nint dp[100005];\n\nvoid mkprime()\n{\n#define MAX  1000005\n#define SQRT 1000\t     // sqrt(MAX)\n\tint i, j;\n\n\tmemset(prime+2, 1, 1000003);\n\tfor (i = 4; i <= MAX; i += 2) prime[i] = 0;\n\tfor (i = 3; i <= SQRT; i += 2) {\n\t\tfor (j = i*i; j <= MAX; j += i) prime[j] = 0;  // j = i*i !!!!!\n\t}\n}\n\nint main()\n{\n\tint N, i;\n\n\tmkprime();\n\n\tN = in();\n\tfor (i = 0; i < N; i++) q[i] = in();\n\tq[N] = 1000003;\n\n\tdp[0] = 1;\n\tfor (i = 0; i < N; i++) if (prime[q[i]]) {\n\t\tif (prime[q[i+1]] && q[i] < q[i+1]) {\n\t\t\tdp[i+1] += dp[i]; if (dp[i+1] >= M) dp[i+1] -= M;\n\t\t}\n\t\tif (prime[q[i+2]] && q[i] < q[i+2]) {\n\t\t\tdp[i+2] += dp[i]; if (dp[i+2] >= M) dp[i+1] -= M;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2870 The Diversity of Prime Factorization\n// 2018.3.29 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define MAX  1000005\n#define SQRT 1000\t     // sqrt(MAX)\nchar prime[MAX+3];       // prime table\n\nint tbl[168] = {\n     2,      3,      5,      7,     11,     13,     17,     19,     23,     29, \n    31,     37,     41,     43,     47,     53,     59,     61,     67,     71, \n    73,     79,     83,     89,     97,    101,    103,    107,    109,    113, \n   127,    131,    137,    139,    149,    151,    157,    163,    167,    173, \n   179,    181,    191,    193,    197,    199,    211,    223,    227,    229, \n   233,    239,    241,    251,    257,    263,    269,    271,    277,    281, \n   283,    293,    307,    311,    313,    317,    331,    337,    347,    349, \n   353,    359,    367,    373,    379,    383,    389,    397,    401,    409, \n   419,    421,    431,    433,    439,    443,    449,    457,    461,    463, \n   467,    479,    487,    491,    499,    503,    509,    521,    523,    541, \n   547,    557,    563,    569,    571,    577,    587,    593,    599,    601, \n   607,    613,    617,    619,    631,    641,    643,    647,    653,    659, \n   661,    673,    677,    683,    691,    701,    709,    719,    727,    733, \n   739,    743,    751,    757,    761,    769,    773,    787,    797,    809, \n   811,    821,    823,    827,    829,    839,    853,    857,    859,    863, \n   877,    881,    883,    887,    907,    911,    919,    929,    937,    941, \n   947,    953,    967,    971,    977,    983,    991,    997 };\n\nvoid primetbl()\n{\n\tint i, j, k;\n\tmemset(prime+2, 1, 1000003);\n\tfor (i = 4; i < MAX; i += 2) prime[i] = 0;\n\tfor (k = 1; k < 168; k++) {\n\t\ti = tbl[k];\n\t\tfor (j = i*i; j <= MAX; j += i) prime[j] = 0;  // j = i*i !!!!!\n\t}\n}\n\n#define M 1000000007\nint  q[100005];\nint dp[100005];\n\nint main()\n{\n\tint N, i;\n\n\tprimetbl();\n\n\tN = in();\n\tfor (i = 0; i < N; i++) q[i] = in();\n\tq[N] = 1000003;\n\n\tdp[0] = 1;\n\tfor (i = 0; i < N; i++) if (prime[q[i]]) {\n\t\tif (prime[q[i+1]] && q[i] < q[i+1]) {\n\t\t\tdp[i+1] += dp[i]; if (dp[i+1] >= M) dp[i+1] -= M;\n\t\t}\n\t\tif (prime[q[i+2]] && q[i] < q[i+2]) {\n\t\t\tdp[i+2] += dp[i]; if (dp[i+2] >= M) dp[i+1] -= M;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\nint main(void){\n    const int  yamada = 1e9+7;\n    int N;\n    scanf(\"%d\",&N);\n    int prime[114514];\n    for(int i=0;i<114514;i++)prime[i]=1;\n    prime[1]=0;\n    prime[2]=1;\n    for(int i=3;i<114514;i++)for(int j=2;j*j<=i;j++){if(i%j==0)prime[i]=0;}\n    long long int po[2];\n    po[0]=1;\n    po[1]=0;\n    int a[N+2];\n    a[0]=1;\n    a[1]=1;\n    for(int i=2;i<N+2;i++){scanf(\"%d\",&a[i]);\n        long long int kari[2];\n        kari[0]=po[0];\n        kari[1]=po[1];\n        po[0]=prime[a[i]]*((a[i-1]<a[i])*kari[0]+(a[i-2]<a[i])*kari[1]);\n        po[0]%=yamada;\n        if(i>2)po[1]=kari[0];\n        po[1]%=yamada;\n       // printf(\"%lld %lld\\n\",po[0],po[1]);\n    }\n    po[0]+=po[1];\n    po[0]%=yamada;\n    printf(\"%lld\\n\",po[0]);\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        boolean[] isNotPrimes = new boolean[1000001];\n        isNotPrimes[0] = true;\n        isNotPrimes[1] = true;\n        for (int i = 2; i < isNotPrimes.length; i++) {\n            if (isNotPrimes[i]) {\n                continue;\n            }\n            for (int j = 2; j * i < isNotPrimes.length; j++) {\n                isNotPrimes[i * j] = true;\n            }\n        }\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n        int[][] dp = new int[n][2];\n        if (!isNotPrimes[arr[0]]) {\n            dp[0][0] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            dp[i][1] += dp[i - 1][0];\n            dp[i][1] %= MOD;\n            if (!isNotPrimes[arr[i]]) {\n                if (i >= 2 && arr[i - 2] < arr[i]) {\n                    dp[i][0] += dp[i - 1][1];\n                    dp[i][0] %= MOD;\n                }\n                if (arr[i - 1] < arr[i]) {\n                    dp[i][0] += dp[i - 1][0];\n                    dp[i][0] %= MOD;\n                }\n            }\n        }\n        System.out.println((dp[n - 1][0] + dp[n - 1][1]) % MOD);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        var dp = new long[N, 2];\n        dp[0, 1] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            dp[i, 0] = dp[i - 1, 1];\n            if (is_prime[Q[i]] && Q[i - 1] < Q[i]) dp[i, 1] += dp[i - 1, 1];\n            if (is_prime[Q[i]] && i - 2 >= 0 && Q[i - 2] < Q[i]) dp[i, 1] += dp[i - 1, 0];\n            dp[i, 1] %= mod;\n        }\n        Console.WriteLine((dp[N, 0] + dp[N, 1]) % mod);\n\n        //long zero = 1; int zero_prime = 0;\n        //long one = 0; int one_prime = 0;\n\n        //for (int i = 1; i < N; i++)\n        //{\n        //    long tmp = one;\n        //    if (is_prime[Q[i]])\n        //    {\n        //        if (Q[i - 1] < Q[i] && Q[i - 2] < Q[i])\n        //        {\n        //            long tmp = one;\n        //            one = (zero + one) % mod;\n        //            zero = tmp;\n        //            zero_prime = one_prime;\n        //            one_prime = Q[i];\n        //        }\n        //        else if (zero_prime < Q[i])\n        //        {\n        //            long tmp = one;\n        //            one = zero;\n        //            zero = tmp;\n        //            zero_prime = one_prime;\n        //            one_prime = Q[i];\n        //        }\n        //        else if (one_prime < Q[i])\n        //        {\n        //            zero = one;\n        //            one_prime = Q[i];\n        //        }\n        //        else\n        //        {\n        //            zero = one;\n        //            one = 0;\n        //            one_prime = 0;\n        //        }\n        //    }\n\n        //    //Console.WriteLine(one + \" \" + zero);\n        //}\n\n        //Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        //var dp = new long[N, 1];\n        //dp[0, 1] = 1;\n        //for (int i = 1; i < N; i++)\n        //{\n        //    if (is_prime[Q[i]])\n        //    {\n\n        //    }\n        //}\n\n\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n\n            if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i] && zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (one_prime < Q[i])\n                {\n                    zero = one;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                    one_prime = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        var dp = new long[N, 2];\n        dp[0, 1] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            dp[i, 0] = dp[i - 1, 1];\n            if (is_prime[Q[i]] && Q[i - 1] < Q[i]) dp[i, 1] += dp[i - 1, 1];\n            if (is_prime[Q[i]] && i - 2 >= 0 && Q[i - 2] < Q[i]) dp[i, 1] += dp[i - 1, 0];\n            dp[i, 1] %= mod;\n        }\n        Console.WriteLine((dp[N - 1, 0] + dp[N - 1, 1]) % mod);\n\n        //long zero = 1; int zero_prime = 0;\n        //long one = 0; int one_prime = 0;\n\n        //for (int i = 1; i < N; i++)\n        //{\n        //    long tmp = one;\n        //    if (is_prime[Q[i]])\n        //    {\n        //        if (Q[i - 1] < Q[i] && Q[i - 2] < Q[i])\n        //        {\n        //            long tmp = one;\n        //            one = (zero + one) % mod;\n        //            zero = tmp;\n        //            zero_prime = one_prime;\n        //            one_prime = Q[i];\n        //        }\n        //        else if (zero_prime < Q[i])\n        //        {\n        //            long tmp = one;\n        //            one = zero;\n        //            zero = tmp;\n        //            zero_prime = one_prime;\n        //            one_prime = Q[i];\n        //        }\n        //        else if (one_prime < Q[i])\n        //        {\n        //            zero = one;\n        //            one_prime = Q[i];\n        //        }\n        //        else\n        //        {\n        //            zero = one;\n        //            one = 0;\n        //            one_prime = 0;\n        //        }\n        //    }\n\n        //    //Console.WriteLine(one + \" \" + zero);\n        //}\n\n        //Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        var B = new int[N];\n        //B[i]=1 素数, B[i]=-1 素数でない B[i] = 0どちらでもいい\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        int min_prime = Q[0];\n        B[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            if (Q[i] <= min_prime || !is_prime[Q[i]])\n            {\n                B[i] = -1;\n                B[i - 1] = 1;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n            if (3 <= i && Q[i - 2] == Q[i - 1] && Q[i - 1] == Q[i])\n            {\n                B[i - 3] = 1;\n                B[i - 2] = 0;\n                B[i - 1] = 1;\n                B[i] = 0;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n        }\n\n\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n\n            if (B[i] == 1)\n            {\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n            }\n            else if (B[i] == -1)\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            else if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                    one_prime = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        //var dp = new long[N, 2];\n        //dp[0, 1] = 1;\n        //for (int i = 1; i < N; i++)\n        //{\n        //    dp[i, 0] = dp[i - 1, 1];\n        //    if (is_prime[Q[i]] && Q[i - 1] < Q[i]) dp[i, 1] += dp[i - 1, 1];\n        //    if (is_prime[Q[i]] && i - 2 >= 0 && Q[i - 2] < Q[i]) dp[i, 1] += dp[i - 1, 0];\n        //    dp[i, 1] %= mod;\n        //}\n        //Console.WriteLine((dp[N - 1, 0] + dp[N - 1, 1]) % mod);\n\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 1; i < N; i++)\n        {\n            long tmp = one;\n            if (is_prime[Q[i]])\n            {\n                if (Q[i - 1] < Q[i] && Q[i - 2] < Q[i])\n                {\n                    one = (zero + one) % mod;\n                }\n                else if (Q[i - 2] < Q[i])\n                {\n                    one = zero;\n                }\n                else if (one_prime < Q[i])\n                {\n                    one = one;\n                }\n                else\n                {\n                    one = 0;\n                }\n            }\n\n            zero = tmp;\n        }\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        var B = new int[N];\n        //B[i]=1 素数, B[i]=-1 素数でない B[i] = 0どちらでもいい\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        int min_prime = Q[0];\n        B[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            if (Q[i] <= min_prime || !is_prime[Q[i]])\n            {\n                B[i] = -1;\n                B[i - 1] = 1;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n            if (3 <= i && Q[i - 2] == Q[i - 1] && Q[i - 1] == Q[i])\n            {\n                B[i - 3] = 1;\n                B[i - 2] = 0;\n                B[i - 1] = 1;\n                B[i] = 0;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n        }\n\n\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n\n            if (B[i] == 1)\n            {\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n            }\n            else if (B[i] == -1)\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            else if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                    one_prime = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        //var dp = new long[N, 2];\n        //dp[0, 1] = 1;\n        //for (int i = 1; i < N; i++)\n        //{\n        //    dp[i, 0] = dp[i - 1, 1];\n        //    if (is_prime[Q[i]] && Q[i - 1] < Q[i]) dp[i, 1] += dp[i - 1, 1];\n        //    if (is_prime[Q[i]] && i - 2 >= 0 && Q[i - 2] < Q[i]) dp[i, 1] += dp[i - 1, 0];\n        //    dp[i, 1] %= mod;\n        //}\n        //Console.WriteLine((dp[N - 1, 0] + dp[N - 1, 1]) % mod);\n\n        //long zero = 0; int zero_prime = 0;\n        //long one = 1; int one_prime = 0;\n\n        //for (int i = 1; i < N; i++)\n        //{\n        //    long tmp = one;\n        //    if (is_prime[Q[i]])\n        //    {\n        //        if (Q[i - 1] < Q[i] && 0 <= i - 2 && Q[i - 2] < Q[i])\n        //        {\n        //            one = (zero + one) % mod;\n        //        }\n        //        else if (0 <= i - 2 && Q[i - 2] < Q[i])\n        //        {\n        //            one = zero;\n        //        }\n        //        else if (Q[i - 1] < Q[i])\n        //        {\n        //            one = one;\n        //        }\n        //        else\n        //        {\n        //            one = 0;\n        //        }\n        //    }\n        //    else\n        //    {\n        //        one = 0;\n        //    }\n\n        //    zero = tmp;\n        //}\n\n        //Console.WriteLine((one + zero) % mod);\n\n        long zero = 0; int zero_prime = 0;\n        long one = 1; int one_prime = Q[0];\n\n        for (int i = 1; i < N; i++)\n        {\n\n            if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i] && zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (one_prime < Q[i])\n                {\n                    zero = one;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                    one_prime = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        var B = new int[N];\n        //B[i]=1 素数, B[i]=-1 素数でない B[i] = 0どちらでもいい\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        int min_prime = Q[0];\n        B[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            if (Q[i] <= min_prime || !is_prime[Q[i]])\n            {\n                B[i] = -1;\n                B[i - 1] = 1;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n            if (3 <= i && Q[i - 2] == Q[i - 1] && Q[i - 1] == Q[i])\n            {\n                B[i - 3] = 1;\n                B[i - 2] = 0;\n                B[i - 1] = 1;\n                B[i] = 0;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n        }\n\n\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n\n            if (B[i] == 1)\n            {\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n            }\n            else if (B[i] == -1)\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            else if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                    one_prime = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        var B = new int[N];\n        //B[i]=1 素数, B[i]=-1 素数でない B[i] = 0どちらでもいい\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        int min_prime = Q[0];\n        B[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            if (Q[i] <= min_prime || !is_prime[Q[i]])\n            {\n                B[i] = -1;\n                B[i - 1] = 1;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n            if (3 <= i && Q[i - 2] == Q[i - 1] && Q[i - 1] == Q[i])\n            {\n                B[i - 3] = 1;\n                B[i - 2] = 0;\n                B[i - 1] = 1;\n                B[i] = 0;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n        }\n\n\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n\n            if (B[i] == 1)\n            {\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n            }\n            else if (B[i] == -1)\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            else if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                    one_prime = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        //var dp = new long[N, 2];\n        //dp[0, 1] = 1;\n        //for (int i = 1; i < N; i++)\n        //{\n        //    dp[i, 0] = dp[i - 1, 1];\n        //    if (is_prime[Q[i]] && Q[i - 1] < Q[i]) dp[i, 1] += dp[i - 1, 1];\n        //    if (is_prime[Q[i]] && i - 2 >= 0 && Q[i - 2] < Q[i]) dp[i, 1] += dp[i - 1, 0];\n        //    dp[i, 1] %= mod;\n        //}\n        //Console.WriteLine((dp[N - 1, 0] + dp[N - 1, 1]) % mod);\n\n        long zero = 0; int zero_prime = 0;\n        long one = 1; int one_prime = 0;\n\n        for (int i = 1; i < N; i++)\n        {\n            long tmp = one;\n            if (is_prime[Q[i]])\n            {\n                if (Q[i - 1] < Q[i] && 0 <= i - 2 && Q[i - 2] < Q[i])\n                {\n                    one = (zero + one) % mod;\n                }\n                else if (0 <= i - 2 && Q[i - 2] < Q[i])\n                {\n                    one = zero;\n                }\n                else if (Q[i - 1] < Q[i])\n                {\n                    one = one;\n                }\n                else\n                {\n                    one = 0;\n                }\n            }\n            else\n            {\n                one = 0;\n            }\n\n            zero = tmp;\n        }\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        //var dp = new long[N, 2];\n        //dp[0, 1] = 1;\n        //for (int i = 1; i < N; i++)\n        //{\n        //    dp[i, 0] = dp[i - 1, 1];\n        //    if (is_prime[Q[i]] && Q[i - 1] < Q[i]) dp[i, 1] += dp[i - 1, 1];\n        //    if (is_prime[Q[i]] && i - 2 >= 0 && Q[i - 2] < Q[i]) dp[i, 1] += dp[i - 1, 0];\n        //    dp[i, 1] %= mod;\n        //}\n        //Console.WriteLine((dp[N - 1, 0] + dp[N - 1, 1]) % mod);\n\n        long zero = 0; int zero_prime = 0;\n        long one = 1; int one_prime = 0;\n\n        for (int i = 1; i < N; i++)\n        {\n            long tmp = one;\n            if (is_prime[Q[i]])\n            {\n                if (Q[i - 1] < Q[i] && 0 <= i - 2 && Q[i - 2] < Q[i])\n                {\n                    one = (zero + one) % mod;\n                }\n                else if (0 <= i - 2 && Q[i - 2] < Q[i])\n                {\n                    one = zero;\n                }\n                else if (Q[i - 1] < Q[i])\n                {\n                    one = one;\n                }\n                else\n                {\n                    one = 0;\n                }\n            }\n\n            zero = tmp;\n        }\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    //int[] P;\n    //void phi(int n)\n    //{\n    //    P = new int[n + 1];\n    //    for (int i = 0; i <= n; i++) P[i] = i;\n    //    for (int i = 2; i <= n; i++)\n    //    {\n    //        if (is_prime[i])\n    //        {\n    //            P[i] -= P[i] / i;\n    //            for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n    //        }\n    //    }\n    //}\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n            if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i]) \n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    int[] P;\n    void phi(int n)\n    {\n        P = new int[n + 1];\n        for (int i = 0; i <= n; i++) P[i] = i;\n        for (int i = 2; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                P[i] -= P[i] / i;\n                for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        int zero = 1; int zero_prime = 0;\n        int one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    int tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i]) \n                {\n                    int tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n            }\n            //Console.WriteLine((one + zero) % mod);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    int[] P;\n    void phi(int n)\n    {\n        P = new int[n + 1];\n        for (int i = 0; i <= n; i++) P[i] = i;\n        for (int i = 2; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                P[i] -= P[i] / i;\n                for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        var B = new int[N];\n        //B[i]=1 素数, B[i]=-1 素数でない B[i] = 0どちらでもいい\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        int min_prime = Q[0];\n        B[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            if (Q[i] <= min_prime || !is_prime[Q[i]])\n            {\n                B[i] = -1;\n                B[i - 1] = 1;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n            if (3 <= i && Q[i - 2] == Q[i - 1] && Q[i - 1] == Q[i])\n            {\n                B[i - 3] = 1;\n                B[i - 2] = 0;\n                B[i - 1] = 1;\n                B[i] = 0;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n        }\n\n\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n\n            if (B[i] == 1)\n            {\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n            }\n            else if (B[i] == -1)\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            else if (is_prime[Q[i]])\n            {            \n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i]) \n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                    one_prime = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    int[] P;\n    void phi(int n)\n    {\n        P = new int[n + 1];\n        for (int i = 0; i <= n; i++) P[i] = i;\n        for (int i = 2; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                P[i] -= P[i] / i;\n                for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        int zero = 1; int zero_prime = 0;\n        int one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n            if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    int tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i]) \n                {\n                    int tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n            }\n            Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    int[] P;\n    void phi(int n)\n    {\n        P = new int[n + 1];\n        for (int i = 0; i <= n; i++) P[i] = i;\n        for (int i = 2; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                P[i] -= P[i] / i;\n                for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        int zero = 1; int zero_prime = 0;\n        int one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n            if (is_prime[Q[i]])\n            {\n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    int tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i]) \n                {\n                    int tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    int[] P;\n    void phi(int n)\n    {\n        P = new int[n + 1];\n        for (int i = 0; i <= n; i++) P[i] = i;\n        for (int i = 2; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                P[i] -= P[i] / i;\n                for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int n; rd(n);\n  auto q=readln.split.to!(int[]);\n\n  const int m=1_000_000+5;\n  auto isPrime=new bool[](m);\n  fill(isPrime, true);\n  isPrime[1]=false;\n  for(int i=2; i*i<=m; i++)if(isPrime[i]){\n    for(int j=2; i*j<m; j++) isPrime[i*j]=false;\n  }\n\n  const long mod=1_000_000_000+7;\n\n  auto dp_p=new long[](n), dp_e=new long[](n);\n  dp_p[0]=(isPrime[q[0]] ? 1L : 0L);\n  for(int i=1; i<n; i++){\n    if(isPrime[q[i-1]]) (dp_e[i]+=dp_p[i-1])%=mod;\n    if(isPrime[q[i]]){\n      if(isPrime[q[i-1]] && q[i-1]<q[i]) (dp_p[i]+=dp_p[i-1])%=mod;\n      if(i-2>=0 && isPrime[q[i-2]] && q[i-2]<q[i]) (dp_p[i]+=dp_e[i-1])%=mod;\n    }\n  }\n\n  writeln((dp_p[n-1]+dp_e[n-1])%mod);\n\n}\n\n/+\n  qi: 素数\n    dp_e[i]=dp_p[i-1]\n    q(i-1):素数 and q(i-1)<qi: dp_p[i]+=dp_p[i-1]\n    q(i-2):素数 and q(i-2)<qi: dp_p[i]+=dp_p[i-2] ? xx\n                               dp_p[i]+=dp_e[i-1] ? ok\n  qi: 合成数\n    dp_e[i]=dp_p[i-1]\n+/\n\nvoid rd(T...)(ref T x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int n; rd(n);\n  auto q=readln.split.to!(int[]);\n\n  const int m=1_000_000+5;\n  auto isPrime=new bool[](m);\n  fill(isPrime, true);\n  isPrime[1]=false;\n  for(int i=2; i*i<=m; i++)if(isPrime[i]){\n    for(int j=2; i*j<m; j++) isPrime[i*j]=false;\n  }\n  \n  auto dp_p=new long[](n), dp_e=new long[](n);\n  dp_p[0]=(isPrime[q[0]] ? 1L : 0L);\n  for(int i=1; i<n; i++){\n    if(isPrime[q[i-1]]) dp_e[i]+=dp_p[i-1];\n    if(isPrime[q[i]]){\n      if(isPrime[q[i-1]] && q[i-1]<q[i]) dp_p[i]+=dp_p[i-1];\n      if(i-2>=0 && isPrime[q[i-2]] && q[i-2]<q[i]) dp_p[i]+=dp_e[i-1];\n    }\n  }\n\n  writeln(dp_p[n-1]+dp_e[n-1]);\n\n}\n\n/+\n  qi: 素数\n    dp_e[i]=dp_p[i-1]\n    q(i-1):素数 and q(i-1)<qi: dp_p[i]+=dp_p[i-1]\n    q(i-2):素数 and q(i-2)<qi: dp_p[i]+=dp_p[i-2] ? xx\n                               dp_p[i]+=dp_e[i-1] ? ok\n  qi: 合成数\n    dp_e[i]=dp_p[i-1]\n+/\n\nvoid rd(T...)(ref T x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    int mod = 1000000007;\n\n    void Solve()\n    {\n        int N = cin.Nextint;\n        var Q = cin.Scanint;\n        eratos(Q.Max());\n        var B = new int[N];\n        //B[i]=1 素数, B[i]=-1 素数でない B[i] = 0どちらでもいい\n        if (!is_prime[Q[0]])\n        {\n            Console.WriteLine(0);\n            return;\n        }\n\n        int min_prime = Q[0];\n        B[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            if (Q[i] <= min_prime || !is_prime[Q[i]])\n            {\n                B[i] = -1;\n                B[i - 1] = 1;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n            if (3 <= i && Q[i - 2] == Q[i - 1] && Q[i - 1] == Q[i])\n            {\n                B[i - 3] = 1;\n                B[i - 2] = 0;\n                B[i - 1] = 1;\n                B[i] = 0;\n                min_prime = Q[i - 1];\n                if (i < N - 1)\n                {\n                    B[i + 1] = 1;\n                    min_prime = Q[i + 1];\n                    i++;\n                }\n            }\n\n        }\n\n\n        long zero = 1; int zero_prime = 0;\n        long one = 0; int one_prime = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (one == 0 && (!is_prime[Q[i]] || Q[i] < zero_prime))\n            {\n                Console.WriteLine(0);\n                return;\n            }\n\n            if (B[i] == 1)\n            {\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = 0;\n                    zero_prime = 0;\n                    one_prime = Q[i];\n                }\n            }\n            else if (B[i] == -1)\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            else if (is_prime[Q[i]])\n            {            \n                //oneの後に0を置くとき、zero_primeはone_primeになる\n                if (one_prime < Q[i])\n                {\n                    long tmp = one;\n                    one = (zero + one) % mod;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else if (zero_prime < Q[i]) \n                {\n                    long tmp = one;\n                    one = zero;\n                    zero = tmp;\n                    zero_prime = one_prime;\n                    one_prime = Q[i];\n                }\n                else\n                {\n                    zero = one;\n                    one = 0;\n                    one_prime = 0;\n                }\n            }\n            else\n            {\n                zero = one;\n                one = 0;\n                one_prime = 0;\n            }\n            //Console.WriteLine(one + \" \" + zero);\n        }\n\n\n\n\n        Console.WriteLine((one + zero) % mod);\n\n    }\n\n\n\n    List<int> prime;\n    bool[] is_prime;\n    void eratos(int n)\n    {\n        prime = new List<int>();\n        is_prime = new bool[n + 1];\n        for (int i = 0; i <= n; i++) is_prime[i] = true;\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 0; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                prime.Add(i);\n                for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n            }\n        }\n    }\n    int[] P;\n    void phi(int n)\n    {\n        P = new int[n + 1];\n        for (int i = 0; i <= n; i++) P[i] = i;\n        for (int i = 2; i <= n; i++)\n        {\n            if (is_prime[i])\n            {\n                P[i] -= P[i] / i;\n                for (int j = 2 * i; j <= n; j += i) P[j] -= P[j] / i;\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nMAX = 1000000\nROOT = 1000\nMOD = 1000000007\nis_prime = [True] * (MAX + 1)\nis_prime[0] = is_prime[1] = False\nfor i in range(2, ROOT + 1):\n  if is_prime[i]:\n    for j in range(i * i, MAX + 1, i):\n      is_prime[j] = False\n\nn = int(input())\nqlst = list(map(int, input().split()))\ntotal1 = 0#next is kisuu or sisuu\ntotal2 = 1#next is kisuu only(pre is index)\nlast_prime = 0\ndic = {}\ndic[(last_prime, 0)] = total1\ndic[(last_prime, 1)] = total2\nfor q in qlst:\n  new_dic = defaultdict(int)\n  for k, v in dic.items():\n    last_prime, t = k\n    if is_prime[q]:\n      if t == 0:\n        if last_prime < q:\n          new_dic[(q, 0)] = (new_dic[(q, 0)] + v) % MOD\n          new_dic[(last_prime, 1)] = (new_dic[(last_prime, 1)] + v) % MOD\n        else:\n          new_dic[(last_prime, 1)] = (new_dic[(last_prime, 1)] + v) % MOD\n      else:\n        if last_prime < q:\n          new_dic[(q, 0)] = (new_dic[(q, 0)] + v) % MOD\n    \n    if not is_prime[q]:\n      if t == 0:\n        new_dic[(last_prime, 1)] = (new_dic[(last_prime, 1)] + v) % MOD\n  dic = new_dic\nprint(sum(dic.values()) % MOD)\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\npub fn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char) \n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nconst MOD: u64 = 1_000_000_007;\n\nfn rec(k: usize, p: usize, prev: u32, q: &Vec<u32>, dp: &mut Vec<Vec<Option<u64>>>, is_prime: &Vec<bool>) -> u64 {\n    if let Some(res) = dp[k][p] {\n        return res;\n    }\n\n    let res = if k == q.len() {\n        1\n    } else {\n        if is_prime[q[k] as usize] && prev < q[k] {\n            let mut res = 0;\n            res += rec(k + 1, 0, q[k], q, dp, is_prime);\n            if k + 2 <= q.len() {\n                res += rec(k + 2, 1, q[k], q, dp, is_prime);\n            }\n            res % MOD\n        } else {\n            0\n        }\n    };\n\n    // println!(\"{} {} {} -> {}\", k, p, prev, res);\n    dp[k][p] = Some(res);\n    res\n}\n\nfn main() {\n    let n = read();\n    let q: Vec<u32> = (0..n).map(|_| read()).collect();\n    let max = *q.iter().max().unwrap() as usize;\n    let mut is_prime = vec![true; max + 1];\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for i in 2..max {\n        if i as u64 * i as u64 > max as u64 {\n            break;\n        }\n        if !is_prime[i] {\n            continue;\n        }\n        let mut j = i * i;\n        while j <= max {\n            is_prime[j] = false;\n            j += i;\n        }\n    }\n\n    let mut dp = vec![vec![None; 2]; n + 1];\n    println!(\"{}\", rec(0, 0, 0, &q, &mut dp, &is_prime));\n}\n\n"
  }
]