[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\n\nobject Main extends App {\n  import scala.io.StdIn._\n  val str = readLine.trim\n  val count = str.count(_ == '.')\n  if (count == 0) {\n    str match{\n      case Expression(e) ⇒ println(e)\n      case _ ⇒ println(-1)\n    }\n  }else {\n    println((0 until count).foldLeft(List(str)){case (l, _) ⇒ List(\"0\",\"1\",\"+\",\"-\",\"*\",\"(\",\")\").flatMap{c ⇒ l.map{_.replaceFirst(\"\\\\.\", c)}}}.collect{\n      case Expression(e) ⇒ e\n    } match {\n      case e if e.nonEmpty ⇒ e.max\n      case _ ⇒ -1\n    })\n  }\n}\nobject Expression {\n  def unapply(arg: String): Option[Int] = {\n    arg.toList match {\n      case f Formula Nil ⇒ f.value\n      case _ ⇒ None\n    }\n  }\n  object Number {\n    def unapply(arg: List[Char]): Option[(Term, List[Char])] = {\n      arg.span(_.isDigit) match {\n        case (Nil, _) ⇒ None\n        case (n, rest) ⇒ Some(new Number(n.foldLeft(0){case (acc, d) ⇒ acc * 2 + d.asDigit}), rest)\n      }\n    }\n  }\n  object Factor{\n    def unapply(arg: List[Char]): Option[(Term, List[Char])] = {\n      arg match {\n        case n Number rest ⇒ Some(n, rest)\n        case '('::(t Formula ')'::r) if t.count > 1 ⇒ Some(Bracket(t), r)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Formula {\n    def unapply(arg: List[Char]): Option[(Term, List[Char])] = {\n      arg match {\n        case left Term rest ⇒ Some(takeAll(rest, left))\n        case _ ⇒ None\n      }\n    }\n    @tailrec private[this] def takeAll(arg: List[Char], left: Term): (Term, List[Char]) = {\n      arg match {\n        case '+'::(right Term rest) ⇒ takeAll(rest, new Add(left, right))\n        case '-'::(right Term rest) ⇒ takeAll(rest, new Sub(left, right))\n        case _ ⇒ (left, arg)\n      }\n    }\n  }\n  object Term {\n    def unapply(arg: List[Char]): Option[(Term, List[Char])] = {\n      arg match {\n        case f Factor rest ⇒ Some(takeAll(rest, f))\n        case _ ⇒ None\n      }\n    }\n    @tailrec private[this] def takeAll(arg: List[Char], left: Term): (Term, List[Char]) = {\n      arg match {\n        case '*'::(right Factor rest) ⇒ takeAll(rest, new HighPriority(left, right))\n        case _ ⇒ (left, arg)\n      }\n    }\n  }\n  sealed trait Term {\n    def count: Int\n    def value: Option[Int]\n  }\n  sealed trait BiOp extends Term\n  class HighPriority(left: Term, right: Term) extends BiOp {\n    override val count: Int = left.count + right.count\n    override val value: Option[Int] = left.value.flatMap(a ⇒ right.value.map(a * _)).filter(v ⇒ 0 <= v && v < 1024)\n  }\n  class Add(left: Term, right: Term) extends BiOp {\n    override val count: Int = left.count + right.count\n    override val value: Option[Int] = left.value.map(a ⇒ a.+(_: Int)).flatMap(right.value.map).filter(v ⇒ 0 <= v && v < 1024)\n  }\n  class Sub(left: Term, right: Term) extends BiOp {\n    override val count: Int = left.count + right.count\n    override val value: Option[Int] = left.value.map(a ⇒ a.-(_: Int)).flatMap(right.value.map).filter(v ⇒ 0 <= v && v < 1024)\n  }\n  case class Bracket(term: Term) extends Term {\n    override def count: Int = 1\n    override def value: Option[Int] = term.value\n  }\n  class Number(v: Int) extends Term {\n    override def count: Int = 1\n    override def value: Option[Int] = Some(v).filter(v ⇒ 0 <= v && v < 1024)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\n\nbool invalid;\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\tif(not isdigit(*begin)){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 2;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n\tif(invalid) return 0;\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tint ret = expression(begin);\n\t\tbegin++; // ')'を飛ばす。\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n\treturn 0;\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nint term(State &begin) {\n\tif(invalid) return 0;\n\tint ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin) {\n\tif(invalid) return 0;\n\tint ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n//beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\t//throw ParseError();\n\t}\n}\n\nconst string c = \"01+-*()\";\n\nbool check(string& s){\n\tint cnt = 0;\n\tbool op = false;\n\trep(i,s.size()){\n\t\tif(s[i] == '('){\n\t\t\tcnt++;\n\t\t\top = true;\n\t\t}else if(s[i] == ')'){\n\t\t\tif(op) return false;\n\t\t\tcnt--;\n\t\t\top = false;\n\t\t}else if(s[i] == '+' or s[i] == '-'){\n\t\t\top = false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(string s, int i){\n\tif(i == s.size()){\n\t\tif(not check(s)) return -1e5;\n\n\t\tinvalid = false;\n\t\tState tmp = s.begin();\n\n\t\tint ans = expression(tmp);\n\t\tif(tmp != s.end()) return -1e5;\n\t\t//cout << ans << ' ' << s << endl;\n\t\treturn invalid ? -1e5 : ans;\n\t}\n\n\twhile(s[i] != '.' and i < s.size()){\n\t\ti++;\n\t}\n\n\tif(s[i] == '.'){\n\t\tint res = -1e5;\n\t\trep(j,c.size()){\n\t\t\ts[i] = c[j];\n\t\t\tres = max(res, dfs(s, i));\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn dfs(s, i);\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\n\tcout << dfs(s, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstring ch = \"01+-*()\";\nint ans = -1;\n\nint expression(const string& s, int& k);\nint factor(const string& s, int& k);\nint term(const string& s, int& k);\n\n// 数字が [0,1023] かチェック\nbool valid(const int n){\n\treturn (0 <= n && n < 1024);\n}\n\n// <number> ::= <digit> | <number> <digit>\nint number(const string& s, int& k){\n\tint r = 0;\n\twhile( s[k] == '0' || s[k] == '1' ){\n\t\tr = r * 2 + (s[k] - '0');\n\t\t++k;\n\t}\n\treturn r;\n}\n\nint expression(const string& s, int& k){\n\tint r1 = term(s, k);\n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r1;\n}\n\nint factor(const string& s, int& k){\n\tif( s[k] == '(' ){ // 括弧のはじまりのとき\n\t\t++k; // '(' の 1つ先に進める.\n\t\tint r = expression(s, k);\n\t\t// 数字が [0,1023] の範囲にない or ')' がないとき\n\t\tif( !valid(r) || s[k] != ')' ) return -1;\n\t\t\n\t\t++k; // ')' の 1つ先に進める.\n\t\treturn r;\n\t}else if( s[k] == '0' || s[k] == '1' ){ // 数字のとき\n\t\treturn number(s, k);\n\t}else{\n\t\treturn -1;\n\t}\n}\n\nint term(const string& s, int& k){\n\tint r1 = factor(s, k);\n\t// 数字が [0,1023] の範囲にないとき \n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '*' ){\n\t\t\t++k;\n\t\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 * r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r1;\n}\n\n// 式が正しいかどうか.\nbool check(const string& s){\n\tint par = 0;\n\tchar prev = '\\0';\n\tdeque<bool> op(100, false);\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( prev == '\\0' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '(' ){\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '0' || prev == '1' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}\n\t\t\tprev = s[i];\n\t\t}else if( prev == '+' || prev == '-' || prev == '*' ){\n\t\t\tif( par > 0 ){\n\t\t\t\top[par] = true;\n\t\t\t}\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == ')' ){\n\t\t\tif( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tint t=0;\n\t\t// 式が正しいときだけ解を更新.\n\t\tif( check(s) ){\n\t\t\tint res = expression(s, t);\n\t\t\tans = max( ans , res );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <iostream>\n\nusing namespace std;\n\nint n, cl[5], cnum, num, p;\nchar str[101], cc[] = {\"01+-*()\"}, t[501];\n\nint eq(char c1,char c2,char c3,char c4){\n\treturn c1 == c3 && c2 == c4;\n}\n\nint calc(){\n\tint ret = 0, i, c;\n\tchar e = '+';\n\tfor(;p < num;p++){\n\t\tif(t[p] == '('){\n\t\t\tp++;\n\t\t\tc = calc();\n\t\t\tif(e == '+')\n\t\t\t\tret += c;\n\t\t\telse if(e == '-')\n\t\t\t\tret -= c;\n\t\t\telse if(e == '*')\n\t\t\t\tret *= c;\n\t\t}\n\t\telse if(isdigit(t[p])){\n\t\t\tc = 0;\n\t\t\tfor(i = p;isdigit(t[i]);i++) c = (c << 1) + t[i] - '0';\n\t\t\tp = i - 1;\n\t\t\tif(e == '+')\n\t\t\t\tret += c;\n\t\t\telse if(e == '-')\n\t\t\t\tret -= c;\n\t\t\telse if(e == '*')\n\t\t\t\tret *= c;\n\t\t}\n\t\telse if(t[p] == '+' || t[p] == '-' || t[p] == '*'){\n\t\t\te = t[p];\n\t\t}\n\t\telse if(t[p] == ')')\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n\nvoid priority(void){\n\tint i, j, k, c;\n\tnum = n;\n\tmemcpy(t,str,sizeof(str));\n\tfor(i = 0;i < num;i++){\n\t\tif(t[i] == '*'){\n\t\t\tc = 0;\n\t\t\tfor(j = i - 1;j > 0;j--){\n\t\t\t\tif(t[j] == ')') c++;\n\t\t\t\telse if(t[j] == '(') c--;\n\t\t\t\tif(c == 0 && !isdigit(t[j])) break;\n\t\t\t}\n\t\t\tif(j != 0) j--;\n\t\t\tfor(k = num;k >= j;k--) t[k + 1] = t[k];\n\t\t\tnum++,i++;\n\t\t\tt[j] = '(';\n\t\t\tc = 0;\n\t\t\tfor(j = i + 1;j < num;j++){\n\t\t\t\tif(t[j] == '(') c++;\n\t\t\t\telse if(t[j] == ')') c--;\n\t\t\t\tif(c == 0 && !isdigit(t[j])) break;\n\t\t\t}\n\t\t\tfor(k = num;k >= j;k--) t[k + 1] = t[k];\n\t\t\tnum++;\n\t\t\tt[j] = ')';\n\t\t}\n\t}\n}\n\t\t\t\t\n\n\nint judge(void){\n\tint i, j, k = 0, c;\n\tchar c1, c2;\n\n\t// 式が成り立たないもの\n\tfor(i = 0;i < n - 1;i++){\n\t\tc1 = str[i],c2 = str[i + 1];\n\t\tif(eq(c1,c2,'(','+') || eq(c1,c2,'(','-') || eq(c1,c2,'(','*') || eq(c1,c2,'+',')') || eq(c1,c2,'-',')') || eq(c1,c2,'*',')') || eq(c1,c2,'0','(') || eq(c1,c2,'1','(') || eq(c1,c2,')','0') || eq(c1,c2,')','1') || eq(c1,c2,'+','+') || eq(c1,c2,'-','-') || eq(c1,c2,'*','*') || eq(c1,c2,'+','-') || eq(c1,c2,'+','*') || eq(c1,c2,'-','+') || eq(c1,c2,'-','*') || eq(c1,c2,'*','+') || eq(c1,c2,'*','-'))\n\t\t\treturn 0;\n\t}\n\tif(str[0] == '+' || str[0] == '-' || str[0] == '*' || str[n - 1] == '+' || str[n - 1] == '-' || str[n - 1] == '*')\n\t\treturn 0;\n\n\tc = 0;\n\tfor(i = 0;i < n;i++){\n\t\tif(str[i] == ')' && c == 0) return 0;\n\t\tif(str[i] == '(') c++;\n\t\telse if(str[i] == ')') c--;\n\t}\n\tif(c != 0) return 0;\n\n\t//括弧の中に式があるかどうか\n\tfor(i = 0;i < n;i++){\n\t\tif(str[i] == '('){\n\t\t\tfor(j = i;str[j] != ')';j++);\n\t\t\tc = 1;\n\t\t\tfor(k = i + 1;k < j;k++){\n\t\t\t\tif(str[k] == '+' || str[k] == '-' || str[k] == '*'){\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c) return 0;;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint dfs(int c){\n\tint ret = 0x80000000,i, e;\n\tif(c == cnum){\n\t\tif(judge()){\n\t\t\tpriority();\n\t\t\tp = 0;\n\t\t\tret = max(ret,e = calc());\n//\t\t\tprintf(\"%s = %3d   \",str,e);\n//\t\t\tprintf(\"%s\\n\",t);\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(i = 0;i < 7;i++){\n\t\tstr[cl[c]] = cc[i];\n\t\tret = max(ret,dfs(c + 1));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint i = 0,ans;\n\tchar c;\n\twhile((c = getchar()) != '\\n')\n\t\tstr[i++] = c;\n\tstr[i] = '\\0';\n\tn = strlen(str);\n\tcnum = 0;\n\tfor(i = 0;i < n;i++)\n\t\tif(str[i] == '.') cl[cnum++] = i;\n\tans = dfs(0);\n\tprintf(\"%d\\n\",ans!=0x80000000?ans:-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\n\nusing ll = long long;\nusing pll = pair<ll, ll>;\n \nconstexpr ll M = 1e9+7;\n\nconst string w = \"01+-*()\";\n\nconstexpr int mi = 0;\nconstexpr int ma = 1023;\n\nbool isrange(int n) {\n    return mi <= n && n <= ma;\n}\n\nint expr(string const& s, int& p);\nint term(string const& s, int& p);\nint factor(string const& s, int& p);\nint number(string const& s, int& p);\n\nint expr(string const& s, int& p) {\n    int res = term(s, p);\n    while(p < s.size() && (s[p] == '+' || s[p] == '-')) {\n        if(s[p] == '+') {\n            res += factor(s, ++p);\n        } else if(s[p] == '-') {\n            res -= factor(s, ++p);\n        }\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    }\n    return res;\n}\n\nint term(string const& s, int& p) {\n    int res = factor(s, p);\n    while(p < s.size() && s[p] == '*') {\n        res *= factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    }\n    return res;\n}\n\nint factor(string const& s, int& p) {\n    if(isdigit(s[p])) {\n        return number(s, p);\n    }\n    if(s[p] == '-') {\n        int res = -factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    } else if(s[p] == '(') {\n        int res = expr(s, ++p);\n        ++p;\n        return res;\n    } else {\n        throw runtime_error(\"\");\n    }\n}\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(p < s.size() && isdigit(s[p])) {\n        res <<= 1;\n        res |= s[p] == '1';\n        ++p;\n    }\n    if(!isrange(res)) {\n        throw runtime_error(\"\");\n    }\n    return res;\n}\n\nbool check(string const& s) {\n    stack<int> st;\n    vector<vector<bool>> par(s.size(), vector<bool>(s.size()));\n    bool ok = true;\n    for(int i=0; i<s.size(); ++i) {\n        if(s[i] == '(') {\n            st.push(i);\n        }\n        if(s[i] == ')') {\n            if(st.empty()) {\n                ok = false;\n                break;\n            }\n            if(s[st.top()+1] == '(' && s[i-1] == ')' && par[st.top()+1][i-1]) {\n                ok = false;\n                break;\n            }\n            par[st.top()][i] = true;\n            bool f = false;\n            for(int j=st.top()+1; j<i; ++j) {\n                f |= !isdigit(s[j]);\n            }\n            st.pop();\n            ok &= f;\n        }\n    }\n    return st.empty() && ok;\n}\n\nint solve(int i, string& s, vector<int> const& lost) {\n    int res = -1;\n    if(i == lost.size()) {\n        try {\n            int p = 0;\n            if(check(s)) {\n                res = expr(s, p);\n            }\n            return (p == s.size() ? res : -1);\n        } catch(...) {\n            return -1;\n        }\n    }\n    for(int j=0; j<w.size(); ++j) {\n        s[lost[i]] = w[j];\n        res = max(res, solve(i+1, s, lost));\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    vector<int> pos;\n    for(int i=0; i<s.size(); ++i) {\n        if(s[i] == '.') {\n            pos.push_back(i);\n        }\n    }\n    cout << solve(0, s, pos) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nstring s;\nconst int limit = (1 << 10);\nint expr(int&);\n\ninline bool out_range(int x) {\n\treturn x < 0 || x >= limit;\n}\n\nint number(int& idx) {\n\tint res = 0;\n\twhile(isdigit(s[idx])) {\n\t\tres <<= 1;\n\t\tif(s[idx] == '1')\n\t\t\tres += 1;\n\n\t\t++idx;\n\t}\n\n\tif(out_range(res))\n\t\tthrow 0;\n\n\treturn res;\n}\n\nint factor(int& idx) {\n\tif(isdigit(s[idx])) {\n\t\treturn number(idx);\n\t}\n\telse if(s[idx] == '(') {\n\t\t++idx;\n\t\tint tmp = idx;\n\t\tnumber(tmp);\n\t\tif(s[tmp] == ')')\n\t\t\tthrow 0;\n\n\t\tconst int res = expr(idx);\n\t\tif(s[idx++] != ')')\n\t\t\tthrow 0;\n\n\t\treturn res;\n\t}\n\telse\n\t\tthrow 0;\n}\n\n\nint term(int& idx) {\n\tint res = factor(idx);\n\twhile(s[idx] == '*') {\n\t\t++idx;\n\t\tres *= factor(idx);\n\t\tif(out_range(res))\n\t\t\tthrow 0;\n\t}\n\n\treturn res;\n}\n\nint expr(int& idx) {\n\tint res = term(idx);\n\twhile(s[idx] == '+' || s[idx] == '-') {\n\t\tif(s[idx++] == '+') {\n\t\t\tres += term(idx);\n\t\t\tif(out_range(res))\n\t\t\t\tthrow 0;\n\t\t}\n\t\telse {\n\t\t\tres -= term(idx);\n\t\t\tif(out_range(res))\n\t\t\t\tthrow 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvector<int> cant_read;\nconst string candidate = \"01+-*()\";\n\nint dfs(int depth = 0) {\n\tif(cant_read.size() == depth) {\n\t\ttry {\n\t\t\tint idx = 0;\n\t\t\tconst int res = expr(idx);\n\t\t\tif(idx != s.size())\n\t\t\t\tthrow 0;\n\n\t\t\treturn res;\n\t\t} catch(...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tint res = -1;\n\tconst int next_depth = depth + 1;\n\n\tfor(int i = 0; i < (int)candidate.size(); ++i) {\n\t\ts[cant_read[depth]] = candidate[i];\n\t\tchmax(res, dfs(next_depth));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < (int)s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tcant_read.push_back(i);\n\n\tcout << dfs(0) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool onlynum;\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tonlynum = false;\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tonlynum = false;\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tonlynum = true;\n\tint ret = expr(s, num);\n\tif (onlynum)return -1;\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num]))n = n * 2 + s[num++] - '0';\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tonlynum=false;\n\t\tint ans = expr(s, num);\n\t\tma = max(ma,ans );\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nchar rp[]={'0','1','+','-','*','(',')'};\n \nvector<string> check(vector<string> ss){\n    vector<string> ans;\n    for(string x:ss){\n        bool sw=true;\n        int c=0;\n        for(int i=0;i<x.size()&&sw;i++){\n            if(x[i]=='(')c++;\n            if(x[i]==')')c--;\n            if(c<0)sw=false;\n        }\n        if(!c){\n            ans.push_back(x);\n        }\n    }\n    return ans;\n}\n \nvector<string> rek(vector<string> ss){\n    vector<string> ans;\n    int t;\n    if(ss[0].find(\".\")!=string::npos){\n        bool sw=true;\n        for(int i=0;i<ss[0].size()&&sw;i++){\n            if(ss[0][i]=='.'){\n                t=i;\n                sw=false;\n            }\n        }\n        for(string s:ss){\n            for(int i=0;i<7;i++){\n                s[t]=rp[i];\n                ans.push_back(s);\n            }\n        }\n        ans=rek(ans);\n        return ans;\n    }\n    else{\n        return ss;\n    }\n}\n \nint ana(string s){\n    if(s.size()==0)return -1;\n    if(*s.begin()=='('&&*(s.end()-1)==')'){\n        s=s.substr(1,s.size()-2);\n    }\n    int res;\n    int c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n            if(!c&&s[i]=='*'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a*b;\n                return(res>=0&&res<1024?res:-1);\n            }\n    }\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n        if(!c&&s[i]=='+'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a+b;\n            return(res>=0&&res<1024?res:-1);\n        }\n        if(!c&&s[i]=='-'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a-b;\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    // if(*s.begin()=='('&&*(s.end()-1)==')'){\n    //     ///////\n    //     if(str.find(\"+\")==string::npos&&str.find(\"-\")==string::npos&&str.find(\"*\")==string::npos)return -1;\n    //     res=ana(s.substr(1,s.size()-2));\n    //     return (res>=0&&res<1024?res:-1);\n    // }\n    //if(s.find(\"(\")!=string::npos)return -1;\n    //else{\n        res=stoi(s,nullptr,2);\n        return(res>=0&&res<1024?res:-1);\n    //}\n    //return -1;\n}\n \n \nvoid solve(string s){\n    int ans=-1,anssub=0;\n    vector<string> ss;\n    ss.push_back(s);\n    ss=rek(ss);\n    ss=check(ss);\n    for(string x:ss){\n        anssub=ana(x);\n        if(anssub<1024&&anssub>=0)ans=max(ans,anssub);\n        //cout<<x<<\"  \"<<anssub<<endl;\n    }\n    cout<<ans<<endl;\n     \n     \n     \n}\n \nint main(){\n    string s;\n    cin>>s;\n    solve(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(e==fail||!e.second||s[x]!=')')return fail;\n    x++;\n    return e;\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(f==fail)return f;\n  if(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(l==fail)return l;\n    return make_pair(f.first*l.first,true);\n  }else{\n    return f;\n  }\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(f==fail)return f;\n  if(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(l==fail)return l;\n    return make_pair(f.first+sign*l.first,true);\n  }else{\n    return f;\n  }\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tm=max(m,dfs());\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p;\nbool flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  if(s[p]=='('){\n    flg&=check2();\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\nint calc(){\n  int res=0;\n  p++;\n  flg&=check2()&check(p);\n  if(s[p]=='('){\n    res=bnf();\n    if(res<0||res>=1024)flg=0;\n    return res;\n  }\n  res=Num();\n  if(s[p]=='*') res*=calc();\n  if(res<0||res>=1024) flg=0;\n  return res;\n}\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(p+1);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n    if(res<0||res>=1024) flg=0;\n  }\n  if(!flg||res>=1024||res<0)return -INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n        }else{\n            res -= term(++pos);\n            if(res<0){\n                ppppp = 1;\n            }\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    bool ok = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n        }\n    }\n    if(flag){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n        pos = 0;\n        cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool is_num(char x){return x=='0' || x=='1';}\n\nbool valid_num(int x){\n  const int SUP=1024;\n  return 0<=x && x<SUP;\n}\n\nint calc(int lhs,int rhs,char op){\n  int res;\n  if(op=='+'){\n    res=lhs+rhs;\n  }else if(op=='-'){\n    res=lhs-rhs;\n  }else if(op=='*'){\n    res=lhs*rhs;\n  }else{\n    throw \"calc\";\n  }\n  if(!valid_num(res)) throw \"invalid\";\n\n  return res;\n}\n\nint formula(int &p);\nint formulap(int &p);\nint term1(int &p);\npair<int,bool> term1p(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint formula(int &p){\n  int res=term1(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formula\";\n    int rhs=term1(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\nint formulap(int &p){\n  bool isok=false;\n  auto ret=term1p(p);\n  isok|=ret.second;\n  int res=ret.first;\n  if(p>=s.size()) throw \"AHO\";\n  while(s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formulap_op\";\n    isok=true;\n    int rhs=term1p(p).first;\n    res=calc(res,rhs,op);\n      if(p>=s.size()) throw \"AHO\";\n  }\n\n  if(!isok) throw \"formulap_isok\";\n  return res;\n}\n\nint term1(int& p){\n  int res=term2(p);\n  while(p<s.size() && (s[p]!='+' && s[p]!='-')){\n    char op=s[p];\n    p++;\n    if(op!='*') throw \"term1_op\";\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\npair<int,bool> term1p(int &p){\n  int res=term2(p);\n  bool isop=false;\n  if(p>=s.size()) throw \"AHO\";\n  while(s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;    \n    if(op!='*') throw \"term1p\";\n    isop=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n    if(p>=s.size()) throw \"AHO\";\n  }\n  return {res,isop};\n}\n\nint term2(int& p){\n  if(p>=s.size()) throw \"MANUKE\";\n  if(s[p]=='('){\n    p++;\n    int res=formulap(p);\n    if(p>=s.size() || s[p]!=')') throw \"term2\";\n    p++;\n    return res;\n  }else if(is_num(s[p])){\n    int res=get_num(p);\n    return res;\n  }else throw \"term2\";\n}\n\nint get_num(int& p){\n  int res=0;\n  while(p<s.size() && is_num(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    if(!valid_num(res)) throw \"Invalid\";\n    p++;\n  }\n\n  return res;\n}\n\nint dfs(int i){\n  if(i==s.size()){\n    int res=-1;\n     try{\n       int p=0;\n       res=formula(p); \n     }catch(const char* &e){\n       return -1;\n     }\n     return res;\n  }\n  else if(s[i]=='.'){\n    const string ch=\"01+-*()\";\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      int ret=dfs(i+1);\n      res=max(ret,res);\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nchar rp[]={'0','1','+','-','*','(',')'};\n \nvector<string> check(vector<string> ss){\n    vector<string> ans;\n    for(string x:ss){\n        bool sw=true;\n        int c=0;\n        for(int i=0;i<x.size()&&sw;i++){\n            if(x[i]=='(')c++;\n            if(x[i]==')')c--;\n            if(c<0)sw=false;\n        }\n        if(!c){\n            ans.push_back(x);\n        }\n    }\n    return ans;\n}\n \nvector<string> rek(vector<string> ss){\n    vector<string> ans;\n    int t;\n    if(ss[0].find(\".\")!=string::npos){\n        bool sw=true;\n        for(int i=0;i<ss[0].size()&&sw;i++){\n            if(ss[0][i]=='.'){\n                t=i;\n                sw=false;\n            }\n        }\n        for(string s:ss){\n            for(int i=0;i<7;i++){\n                s[t]=rp[i];\n                ans.push_back(s);\n            }\n        }\n        ans=rek(ans);\n        return ans;\n    }\n    else{\n        return ss;\n    }\n}\n \nint ana(string s){\n    int c=0;\n    if(s.size()==0)return -1;\n    bool sw=false;\n    int res;\n    if(s[0]=='('){\n        for(int i=0;i<s.size()-1;i++){\n            if(s[i]=='(')c++;\n            if(s[i]==')')c--;\n            if(!c)sw=true;\n        }\n        if(!sw){\n            s=s.substr(1,s.size()-2);\n            for(int i=0;i<s.size();i++){\n                if(s[i]=='(')c++;\n                if(s[i]==')')c--;\n                if(!c&&s[i]=='*'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a*b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n            }\n            c=0;\n            for(int i=0;i<s.size();i++){\n                if(s[i]=='(')c++;\n                if(s[i]==')')c--;\n                if(!c&&s[i]=='+'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a+b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n                if(!c&&s[i]=='-'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a-b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n            }\n            return -1;\n        }\n    }\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n            if(!c&&s[i]=='*'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a*b;\n                return(res>=0&&res<1024?res:-1);\n            }\n    }\n    c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n        if(!c&&s[i]=='+'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a+b;\n            return(res>=0&&res<1024?res:-1);\n        }\n        if(!c&&s[i]=='-'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a-b;\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    if(s.find(\"(\")!=string::npos)return -1;\n    else{\n        try{\n            res=stoi(s,nullptr,2);\n        }catch(...){\n            return -1;\n        }\n        return(res>=0&&res<1024?res:-1);\n    }\n}\n \n \nvoid solve(string s){\n    int ans=-1,anssub=0;\n    vector<string> ss;\n    ss.push_back(s);\n    ss=rek(ss);\n    ss=check(ss);\n    for(string x:ss){\n        anssub=ana(x);\n        if(anssub<1024&&anssub>=0)ans=max(ans,anssub);\n    }\n    cout<<ans<<endl;\n}\n \nint main(){\n    string s;\n    cin>>s;\n    solve(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(char ch){return ch&&ch!='+'&&ch!='-'&&ch!='*'&&ch!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\nbool check3(int a){return 0<=a&&a<1024;}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  flg&=check3(res);\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(s[p]);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(s[p]=='*') res*=calc();\n  }\n  flg&=check3(res);\n  return res;\n}\n\nint bnf(){\n  flg&=check(s[p]);\n  int res=Num();\n  while(p<s.size()&&flg&&s[p]!=')'){\n    flg&=check3(res)&&s[p]!='('&&check(s[p+1]);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n  }\n  if(!flg)res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint p,flag,ans=-1;\nstring s;\nmap<int,char>cc;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])){\n    while(isdigit(s[p]))res=res*2+(s[p++]-'0');\n  }\n  else flag++;\n  return res;\n}\nint bnf2(){\n  int res=get_A();\n  while(s[p]=='*'){\n    int t=p++;\n    if(s[t]=='+')res*=get_A();\n  }\n  return res;\n}\nint bnf1(){\n  int res=bnf2();\n  while(s[p]=='+'||s[p]=='-'){\n    int t=p++;\n    if(s[t]=='+')res+=bnf2();\n    if(s[t]=='-')res-=bnf2();\n  }\n  return res;\n}\nbool ch(){\n  int res=0;\n  while(s[p]!=')'){\n    if(s[p]=='('){\n      p++;\n      if(!ch())return 0;\n      else{\n        if(p==s.size())flag++;\n      }\n    }\n    if(s[p]=='+'||s[p]=='-'||s[p]=='*')res++;\n    if(p>=s.size())return 0;\n    p++;\n  }\n  p++;\n  return res;\n}\nvoid dfs(int d){\n  if(d==s.size()){\n    p=flag=0;\n    if(ch()||flag){\n      p=flag=0;\n      int res=bnf1();\n      if(!flag&&p==s.size())ans=max(ans,res);\n    }\n  }\n  else if(s[d]=='.'){\n    r(i,7){\n      s[d]=cc[i];\n      dfs(d+1);\n    }\n    s[d]='.';\n  }\n  else dfs(d+1);\n}\nmain(){\n  cin>>s;\n  cc[0]='0';\n  cc[1]='1';\n  cc[2]='+';\n  cc[3]='-';\n  cc[4]='*';\n  cc[5]='(';\n  cc[6]=')';\n  dfs(0);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[200];\nchar *p;\nint n;\n\nbool ok(int n){\n    return 0<=n && n<(1<<10);\n}\n\nint E();\nint F();\nint T();\nint N();\n\nint E(){\n    int res = F();\n    while(*p=='+' || *p=='-'){\n        if(*p=='+') p++, res += F();\n        else if(*p=='-') p++, res -= F();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint F(){\n    int res = T();\n    while(*p=='*' || *p=='/'){\n        if(!ok(res)) throw \"\";\n        if(*p=='*') p++, res *= T();\n        else if(*p=='/') p++, res /= T();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint T(){\n    int res;\n    if(*p=='(') p++, res = E(), p++;\n    else res = N();\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nint N(){\n    int res = 0;\n    if(!isdigit(*p)) throw \"\";\n    while(isdigit(*p)){\n        res = res*2 + *p - '0';\n        p++;\n    }\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nbool chk(){\n    for(int i=0;i<n;i++){\n        if(s[i]!='(') continue;\n        int j = i;\n        int d = 0;\n        int cnt = 0;\n        while(s[j]){\n            if(s[j]=='(') d++;\n            else if(s[j]==')') d--;\n            if(d==1) if(s[j]=='+' || s[j]=='-' || s[j]=='*' || s[j]=='/') cnt++;\n            if(d==0) break;\n            j++;\n        }\n        dump(cnt);\n        dump(d);\n        if(d!=0 || cnt==0) return false;\n    }\n    return true;\n}\n\nint main(){\n    cin >> s;\n    n = strlen(s);\n    int x[6], k = 0;\n    char cand[] = \"01+-*())\";\n    for(int i=0;i<n;i++){\n        if(s[i]=='.') x[k++] = i;\n    }\n    int ans = -1;\n    for(int mask=0;mask<1<<(3*k);mask++){\n        p = s;\n        int t = mask;\n        for(int i=0;i<k;i++) s[x[i]] = cand[t>>(3*i)&7];\n        dump(s);\n        if(!chk()) continue;\n        try {\n            int t = E();\n            if(p-s!=n) continue;\n            dump(t);\n            ans = max(ans,t);\n        } catch(...){}\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 9999999\n\n\nvector<string> toRPN(string s){\n    stack<string> ope;\n    vector<string> ret;\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ){\n            string tmp=\"\";\n            for(int j=i;j<len;j++){\n                if( isdigit(s[j]) )tmp+=s[j];\n                else break;\n            }\n            ret.push_back(tmp);\n            i+=tmp.size()-1;\n            \n        }else{\n            if( s[i]=='(' )ope.push(\"(\");\n            \n            else if( s[i]==')' ){\n                if( ope.empty() )return {\"invalid\"};\n                if( ope.top()==\"(\" )return {\"invalid\"};\n                \n                while( ope.top()!=\"(\" ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                    \n                    if( ope.empty() )return {\"invalid\"};\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" || ope.top()==\"+\" || ope.top()==\"-\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n            }\n        }\n    }\n    while( ope.size() ){\n        ret.push_back( ope.top() );\n        ope.pop();\n    }\n    \n    return ret;\n}\n\n\nint toDeci(string s){\n    int ret=0;\n    for(int i=0;i<s.size();i++){\n        if( s[ s.size()-i-1 ]=='1' ){\n            ret+=1<<i;\n        }\n        if(ret>=1024)return 9999;\n    }\n    return ret;\n}\n\n\n\nint solveRPN(vector<string> s){\n    stack<int> stk;\n    \n    \n    for(int i=0;i<s.size();i++){\n        if( (s[i]!=\"+\" && s[i]!=\"-\" && s[i]!=\"*\" && s[i]!=\"/\") )stk.push( toDeci(s[i])  );\n        else{\n            if(stk.size()<2)return -1;\n\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            if(s[i]==\"+\")stk.push(a+b);\n            if(s[i]==\"-\")stk.push(a-b);\n            if(s[i]==\"*\")stk.push(a*b);\n            if(s[i]==\"/\")stk.push(a/b);\n        }\n        if( stk.top() <0 || 1024<=stk.top() )return -1;\n    }\n    \n    if( stk.size()>1 )return -1;\n    return stk.top();\n}\n\n\nvi dot;\nint maxi=-INF;\n\n\nint solve(string s){\n    vector<string> poland=toRPN(s);\n    \n    if(poland[0]==\"invalid\")return -INF;\n    \n    int result=solveRPN(poland);\n    \n    if(result==-1)return -INF;\n    else return result;\n}\n\n\nvoid dfs(string s,int flor){\n    if(flor>=dot.size()){\n        maxi=max( maxi , solve(s) );\n        return ;\n    }\n    \n    char ch[]={'0','1','+','-','(',')'};\n    rep(i,6){\n        s[ dot[flor] ] = ch[i];\n        dfs(s,flor+1);\n        s[ dot[flor] ] = '.';\n    }\n}\n\n\nint main(){\n    string s;\n    cin>>s;\n    \n    rep(i,s.size()) if(s[i]=='.')dot.pb(i);\n    \n    dfs(s,0);\n    \n    if( maxi==-INF )cout<<\"-1\"<<endl;\n    else cout<<maxi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;Cursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(int& opc){\n\t\t\tll l=term(opc);\n\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t\n\t\t\twhile(*c=='+' || *c=='-'){\n\t\t\t\tif(*c=='+'){\n\t\t\t\t\tc++;ll r=term(opc);\n\t\t\t\t\tif(!IN(0,r,1<<10)) throw ParseError();\n\t\t\t\t\tl+=r;\n\t\t\t\t}else{\n\t\t\t\t\tc++;ll r=term(opc);\n\t\t\t\t\tif(!IN(0,r,1<<10)) throw ParseError();\n\t\t\t\t\tl-=r;\n\t\t\t\t}\n\t\t\t\topc++;\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll term(int& opc){\n\t\t\tll l=factor();\n\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\n\t\t\twhile(*c=='*'){\n\t\t\t\tc++;ll r=factor();\n\t\t\t\tif(!IN(0,r,1<<10)) throw ParseError();\n\t\t\t\tl*=r;\n\t\t\t\topc++;\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll factor(){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;\n\t\t\t\tint opc=0;\n\t\t\t\tll v=expression(opc);\n\t\t\t\t\n\t\t\t\tif(!IN(0,v,1<<10)) throw ParseError();\n\t\t\t\tif(*c!=')' || opc==0)  throw ParseError();\n\t\t\t\tc++;\n\t\t\t\treturn v;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\treturn number();\n\t\t\t}else{\n\t\t\t\tthrow ParseError();\n\t\t\t}\n\t\t}\n\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t\t\tss << *c;c++;\n\t\t    }\n\t\t    string str;ss>>str;\n\t\t    ll res=0;\n\t\t    REP(i,str.size()){\n\t\t\t\tres*=2;if(str[i]=='1')res++;\n\t\t\t\tif(!IN(0,res,1<<10)) throw ParseError();\n\t\t    }\n\t\t    if(!IN(0,res,1<<10)) throw ParseError();\n\t\t\treturn res;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nchar symb[7]={'0','1','+','-','*','(',')'};\n\nclass Main{\npublic:\n\tstring s;\t\t\n\tbool input(){\n\t\tgetline(cin,s);\n\t\treturn true;\n\t}\n\n\tll dfs(int i){\n\t\tll Mv=-1;\n\t\tif(i==s.size()){\n\t\t\ttry{\n\t\t\t\tCursor c=s.begin();Syntax sy(s,c);int opc=0;\n\t\t\t\tll res=sy.expression(opc);\n\t\t\t\t\n\t\t\t\tif(c!=s.end())throw ParseError();\n\t\t\t\treturn res;\n\t\t\t}catch(ParseError e){return -1;}\n\t\t}\n\t\tif(s[i]=='.'){\n\t\t\tREP(j,7){\n\t\t\t\ts[i]=symb[j];\n\t\t\t\tMv=max(Mv,dfs(i+1));\n\t\t\t\ts[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tMv=max(Mv,dfs(i+1));\n\t\t}\n\t\treturn Mv;\n\t}\n\n\tvoid run(){\n\t\tinput();\n\t\tcout << dfs(0)<<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nbool valid(int n) {return 0 <= n && n < 1024;}\n\nint num(string str) {\n  int n = 0;\n  rep (i, str.size()) {\n    n = n * 2 + str[i] - '0';\n    if (n >= 1024) throw 1;\n  }\n  return n;\n}\n\nint exp1(string str);\nint exp2(string str);\nint exp3(string str);\n\nint exp1(string str) {\n  if (str.size() == 0u) throw 1;\n  int t = 0, n = str.size(), s = 0;\n  vector<int> v;\n  rep (i, n) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) throw 1;\n    }\n    if (t == 0 && (str[i] == '+' || str[i] == '-')) {\n      v.push_back((s == 0 || str[s - 1] == '+' ? 1 : -1) * exp1(str.substr(s, i - s)));\n      s = i + 1;\n    }\n  }\n  if (t != 0) throw 1;\n  if (v.size() == 0u) return exp2(str);\n  v.push_back((s == 0 || str[s - 1] == '+' ? 1 : -1) * exp1(str.substr(s, n - s)));\n  int res = 0;\n  rep (i, v.size()) {\n    res += v[i];\n    if (!valid(res)) throw 1;\n  }\n  return res;\n}\n\nint exp2(string str) {\n  int t = 0, n = str.size(), s = 0;\n  vector<int> v;\n  rep (i, n) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) throw 1;\n    }\n    if (t == 0 && str[i] == '*') {\n      v.push_back(exp1(str.substr(s, i - s)));\n      s = i + 1;\n    }\n  }\n  if (v.size() == 0u) return exp3(str);\n  v.push_back(exp1(str.substr(s, n - s)));\n  int res = 1;\n  rep (i, v.size()) {\n    res *= v[i];\n    if (!valid(res)) throw 1;\n  }\n  return res;\n}\n\nint exp3(string str) {\n  int t = 0, n = str.size();\n  bool f = true;\n  rep (i, n) if (!isdigit(str[i])) f = false;\n  if (f) return num(str);\n  if (str[0] != '(' || str[n - 1] != ')') throw 1;\n  str = str.substr(1, n - 2);\n  vector<int> v;\n  rep (i, n) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) throw 1;\n    }\n    if (t == 0 && (str[i] == '+' || str[i] == '-' || str[i] == '*')) {\n      return exp1(str);\n    }\n  }\n  throw 1;\n}\n\nconst char c[] = {'0', '1', '+', '-', '*', '(', ')'};\nint solve0(string str, vector<int> dot) {\n  if (dot.size() == 0u) {\n    try {\n      return exp1(str);\n    } catch(int n) {\n      return -1;\n    }\n  }\n  int n = dot.back();\n  dot.pop_back();\n  int res = -1;\n  rep (i, 7) {\n    str[n] = c[i];\n    res = max(res, solve0(str, dot));\n  }\n  return res;\n}\n\nint main() {\n  string str;\n  cin >> str;\n  vector<int> dot;\n  rep (i, str.size()) if (str[i] == '.') dot.push_back(i);\n  cout << solve0(str, dot) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstring s;\nint n;\nchar c[7] = {'0','1','+','-','*','(',')'};\nconst int up = 1<<10;\n\nint parse(int l,int r,int p){\n  if(r<=l)return -1;\n  int k=0,a,b;\n  for(int i=r-1;i>=l;i--){\n    if(s[i]=='(')k++;\n    else if(s[i] == ')')k--;\n    if(k>0)return -1;\n    if(!k){\n      if(s[i] == '+'){\n\ta = parse(l,i,0); b = parse(i+1,r,0);\n\tif(a<0 || b<0 || up<=a || up<=b || a+b<0 || up<=a+b)return -1;\n\treturn a+b;\n      }else if(s[i] == '-'){\n\ta = parse(l,i,0); b = parse(i+1,r,0);\n\tif(a<0 || b<0 || up<=a || up<=b || a-b<0 || up<=a-b)return -1;\n\treturn a-b;\n      }\n    }\n  }\n  if(k)return -1;\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i]=='(')k++;\n    else if(s[i] == ')')k--;\n    if(!k && s[i] == '*'){\n      a = parse(l,i,0); b = parse(i+1,r,0);\n      if(a<0 || b<0 || up<=a || up<=b || a*b<0 || up<=a*b)return -1;\n      return a*b;\n    }\n  }\n\n  if(p)return -1;\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1,1);\n\n  int res = 0;\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '1'){\n      if(r-1-i>=10)return -1;\n      else res += 1 << (r-1-i);\n    }\n  }\n  return res;\n}\n\nint rec(int pos){\n  int i,res = -1;\n  for(i=pos;i<n;i++){\n    if(s[i] == '.'){\n      for(int j=0;j<7;j++){\n\ts[i] = c[j];\n\tres = max(res,rec(i+1));\n      }\n      s[i] = '.'; break;\n    }\n  }\n  \n  if(i==n)return parse(0,n,0);\n  else return res;\n}\n\nint main(){\n  cin >> s; n = s.size();\n  cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nclass SyntaxAnalysis\n{\npublic:\n    using T = pair<bool, int>;\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '*';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '(';\n    static T plus(const T& n, const T& k) { return {n.first and k.first and prop(n.second + k.second), n.second + k.second}; }\n    static T minus(const T& n, const T& k) { return {n.first and k.first and prop(n.second - k.second), n.second - k.second}; }\n    static T product(const T& n, const T& k) { return {n.first and k.first and prop(n.second * k.second), n.second * k.second}; }\n    static T divide(const T& n, const T& k) { return n; }\n    static T brace(const T& n) { return n; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '1'; }\n    static int encode(const char c) { return c - '0'; }\n    static bool prop(const int l) { return l >= 0 and l < (1 << 10); }\n    T number()\n    {\n        int ans = 0, start = S.size();\n        for (; pos < S.size() and is_digit(S[pos]); pos++) {\n            if (S[pos] == '1') { start = min(start, pos); }\n            ans = ans * 2 + encode(S[pos]);\n        }\n        return {pos - start <= 10, ans};\n    }\n    T factor()\n    {\n        if (S[pos] == BRACE) {\n            T ans;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    T term()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, f = factor(), ans = product(ans, f);\n            } else if (S[pos] == DIVIDE) {\n                pos++, f = factor(), ans = divide(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    T expression()\n    {\n        T ans = term();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = term(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = term(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\ntemplate <typename S, typename T>\ninline ostream& operator<<(ostream& os, const pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\n\nint main()\n{\n    constexpr char C[7] = {'0', '1', '+', '-', '*', '(', ')'};\n    string s;\n    cin >> s;\n    vector<int> p;\n    int NUM = 1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '.') { p.push_back(i), NUM *= 7; }\n    }\n    const int sz = p.size();\n    int ans = -1;\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0, num = i; j < sz; j++, num /= 7) { s[p[j]] = C[num % 7]; }\n        stack<int> st;\n        st.push(0);\n        bool ok = true, num = false;\n        for (const char c : s) {\n            if (c == '(') {\n                if (num) {\n                    ok = false;\n                    break;\n                }\n                st.push(0);\n            } else if (c == ')') {\n                if (st.size() <= 1 or st.top() == 0) {\n                    ok = false;\n                    break;\n                }\n                num = true;\n                st.pop();\n            } else if (c == '+' or c == '-' or c == '*') {\n                if (not num) {\n                    ok = false;\n                    break;\n                }\n                num = false;\n                const int n = st.top() + 1;\n                st.pop(), st.push(n);\n            } else {\n                num = true;\n            }\n        }\n        if (not ok or st.size() != 1) { continue; }\n        //show(s);\n        const auto sub = SyntaxAnalysis{s}.Expression();\n        //show(sub);\n        if (sub.first) { ans = max(ans, sub.second); }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstdlib>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\nbool deb;\n\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\n  bool safe,mul;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n    safe = mul = false;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      safe = true;\n      int p = expression();\n      safe = false;\n      mul = false;\n      //cout << \"in fact, p = \" << p << endl;\n      pos++;\n      return p;\n    }else{\n      int ru = 0;\n      string p; p.clear();\n      \n      while('0' <= parse[pos] && parse[pos] <= '1'){\n\tp += parse[pos];\n\tpos++;\n      }\n      reverse(p.begin(),p.end());\n      int ip = 0;\n      bool ook = false;\n      for(int i=0;i<p.length();i++){\n\tif(p[i] == '1'){\n\t  ip += pow((double)2,(double)ru);\n\t}\n\took = true;\n\tru++;\n      }\n      if(!ook)ip = -1;\n      //cout << \"in fact, ip = \" << ip << endl;\n      return ip;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p < 0 || p >=1024){\n      //cout << \"error! in term, limit over error\" << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tmul = true;\n\tint fac= fact();\n       \n\tif(fac < 0 || fac >= 1024){\n\t  //cout << \"error! in term(while *), BNF error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n\tp *= fac;\n\t//cout << \"in term(while *), fact =  \" << fac << endl;\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(p < 0 || p >= 1024){\n      //cout << \"error! in expression, limit over error\" << endl;\n      deb = true;\n      return -1;\n    }\n    if(!(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*' || pos == parse.length() || (safe && mul && parse[pos] == ')'))){\n      //cout << \"error! in expression, not operator. parse[pos] = \" << parse[pos] << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tp+=term();\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else if(parse[pos] == '-'){\n\tpos++;\n\tp-=term();\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else {\n\t//cout << \"error! in expression, not operator Ver2.\" << endl;\n\t//assert(true);\n\tdeb = true;\n\treturn -1;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\n\nint Fans;\nchar perm[7] = {'0','1','+','-','*','(',')'};\nvoid all_permutation(string s){\n\n  for(int i=0;i<s.length();i++){\n    if(s[i] == '.'){\n      for(int j=0;j<7;j++){\n\tstring pre = s;\n\ts[i] = perm[j];\n\tall_permutation(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      deb = false;\n      bool opok = false;\n      int cnt = 0;\n      for(int j=0;j<s.length();j++){\n\tif(s[j] == '('){\n\t  opok = false;\n\t  cnt++;\n\t  for(int k=j+1;k<s.length();k++){\n\t    if(s[k] == ')')break;\n\t    if(s[k] == '+' || s[k] == '-' || s[k] == '*'){\n\t      opok = true;\n\t      break;\n\t    }\n\t  }\n\t  if(!opok){\n\t    break;\n\t  }\n\t}\n      }      \n      if(cnt == 0)opok = true;\n      if(opok){\n      Parsing par = Parsing(s);\n      int ans = par.expression();\n      //if(!deb)cout << \"s = \" << s << \", opok = \" << opok << endl;\n      //if(!deb)cout <<\"ans = \" << ans  << \",deb = \" << deb << \",true =\" << true<< endl;\n      if(!deb) Fans = max(Fans,ans); \n      }\n\n\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  while(cin >> s){\n  Fans = -1;\n \n  all_permutation(s);\n  cout << Fans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\nbool isd(string s){return isdigit(s[0]);}\n\nstring calc(vs s){\n    stack<int> p;\n    for(int i=0;i<s.size();i++){\n        if(s[i]==\"(\")p.push(i);\n        else if(s[i]==\")\"){\n            int f=p.top(); p.pop();\n            vs tmp;\n            s[f]=s[i]=\"-1\";\n            for(int j=f+1;j<i;j++){\n                tmp.pb(s[j]);\n                s[j]=\"-1\";\n            }\n            s[f]=calc(tmp);\n            if(s[f]==\"-1\") return \"-1\";\n            //cout<<\"ans\"<<s[f]<<endl;\n        }\n    }\n    //for(auto c:s)cout<<setw(3)<<c;cout<<endl;\n    auto itr=remove(all(s),\"-1\");\n    s.erase(itr,s.end());\n    if(s.size()==0)return \"-1\";\n    //for(auto c:s)cout<<c<<\"      \";\n    \n    deque<int> oper;\n    deque<string> opec;\n    for(int i=0;i<s.size();i++){\n        if(isd(s[i])){\n            oper.pb(stoi(s[i]));\n        }else{\n            if(s[i]==\"*\"){\n                oper.back()*=stoi(s[++i]);\n                if(oper.back()<0 || oper.back()>1023) return \"-1\";\n            }else opec.pb(s[i]);\n        }\n    }\n    while(!opec.empty()){\n        int d=oper[0];\n        string c=opec[0];\n        oper.pop_front();\n        opec.pop_front();\n        oper.front()=(c==\"+\" ? d+oper.front() : d-oper.front());\n        if(oper.front()<0 || oper.front()>1023) return \"-1\";\n    }\n    return to_string(oper[0]);\n}\n\n\nstring solve(string in){\n    vector<string> s;\n    bool ren=false;\n    for(auto c:in){\n        if(c=='0' || c=='1'){\n            if(ren){\n                s.back()+=c;\n            }else s.pb(\"\"s+c);\n            ren=true;\n        } else {\n            s.pb(\"\"s+c);\n            ren=false;\n        }\n    }\n\n    int dep=0;\n    for(int i=0;i<s.size();i++){\n        string &c=s[i];\n        if(c.length()>10){\n            return \"-1\";\n        }else{\n            try{\n                int p=stoi(c,nullptr,2);\n                c=to_string(p);\n            }catch(...){\n                if(c==\"(\")dep++;\n                else if(c==\")\")dep--;\n                if(dep<0 || dep>25)return \"-1\";\n            }\n        }\n    }\n    if(dep)return \"-1\";\n\n    //for(auto c:s)cout<<c;cout<<endl;\n    int exist=0,depth=0;\n    for(int i=0;i<s.size()-1;i++){\n        if(isd(s[i])){\n            if(s[i+1]==\"(\" || isd(s[i+1])) return \"-1\";\n        }else if(s[i]==\"(\"){\n            depth++;\n            if(s[i+1]==\"+\" || s[i+1]==\"-\" || s[i+1]==\"*\" || s[i+1]==\")\") return \"-1\";\n        }else if(s[i]==\")\"){\n            //cout<<depth<<\",\"<<exist<<endl;\n            if((exist&(1<<depth))==0) return \"-1\";\n            //cout<<\"OK\"<<endl;\n            exist&=~(1<<depth);\n            depth--;\n            if(isd(s[i+1]) || s[i+1]==\"(\") return \"-1\";\n        }else{\n            exist|=(1<<depth);\n            if(s[i+1]!=\"(\" && !isd(s[i+1])) return \"-1\";\n        }\n    }\n\n    if(s.back()==\")\"){\n        if((exist&(1<<depth))==0) return \"-1\";\n    }\n    int t=s.size()-1;\n    if(s[0]==\")\" || s[0]==\"+\" || s[0]==\"-\" || s[0]==\"*\") return \"-1\";\n    if(s[t]==\"(\" || s[t]==\"+\" || s[t]==\"-\" || s[t]==\"*\") return \"-1\";\n\n    //ここまでで除去ができているはず\n    //for(auto c:s)cout<<c;cout<<endl;\n    string ans=calc(s);\n    //cout<<\"=\"<<ans<<endl;\n    return ans;\n}\n\nint bur(string s){\n    int ans=-1;\n    if(count(all(s),'.')==0) {\n        return stoi(solve(s));\n    }\n    for(auto d:\"01+-*()\"s){\n        string os=s;\n        os[s.find('.')]=d;\n        ans=max(ans,bur(os));\n    }\n    return ans;\n}\n\nint main(){\n    string o;\n    cin>>o;\n    cout<<bur(o)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tconst int kind = 7;\n\tStage(){\n\t}\n\t\n\tvoid action(){\n\t\tstring text;\n\t\tcin >> text;\n\n\t\tint res = -1;\n\t\tREP(transWay, pow(kind, count_dot(text))) {\n\t\t\tstring transedText = trans(transWay, text);\n\t\t\tif (transWay == 265) {\n\t\t\t\tint a;\n\t\t\t\ta = 5;\n\t\t\t}\n\t\t\tlist<char> ls;\n\t\t\tfor (char c : transedText)ls.push_back(c);\n\t\t\tauto grams = trans_gram(ls);\n\t\t\tint score = read(grams);\n\n\t\t\tres = max(res, score);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tchar data;\n\t\tint num;\n\t};\n\t\n\tint count_dot(const string& text) {\n\t\tint res = 0;\n\t\tfor (char c : text)if (c == '.')res++;\n\t\treturn res;\n\t}\n\tstring trans(int n, string text) {\n\t\tfor (char& c : text)if (c == '.') {\n\t\t\tswitch (n % kind) {\n\t\t\tcase 0:c = '0'; break;\n\t\t\tcase 1:c = '1'; break;\n\t\t\tcase 2:c = '+'; break;\n\t\t\tcase 3:c = '-'; break;\n\t\t\tcase 4:c = '*'; break;\n\t\t\tcase 5:c = '('; break;\n\t\t\tcase 6:c = ')'; break;\n\t\t\t}\n\t\t\tn /= kind;\n\t\t}\n\t\treturn text;\n\t}\n\n\tlist<Gram> trans_gram(const list<char>& ls) {\n\t\tlist<Gram> grams;\n\t\tfor (auto itr = ls.begin(); itr != ls.end(); ++itr) {\n\t\t\tGram gram;\n\t\t\tswitch (*itr) {\n\t\t\tcase '+':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '+';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '-';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '*';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = '(';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = ')';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgram.kind = 'n';\n\t\t\t\tgram.data = 't';\n\t\t\t\tgram.num = 0;\n\t\t\t\tdo {\n\t\t\t\t\tgram.num *= 2;\n\t\t\t\t\tgram.num += *itr - '0';\n\t\t\t\t\t++itr;\n\t\t\t\t} while (itr != ls.end() && isDigit(*itr));\n\t\t\t\t--itr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tint read(list<Gram> grams){\n\t\ttry {\n\t\t\t// ( , ) delete\n\t\t\tfor (auto right = grams.begin(); right != grams.end(); ++right)\n\t\t\t{\n\t\t\t\tif (right->data == ')') {\n\t\t\t\t\tlist<Gram> subset;\n\t\t\t\t\tauto left = right;\n\n\t\t\t\t\t//move: (expression)\n\t\t\t\t\twhile (left != grams.begin() && left->data != '(') --left;\n\t\t\t\t\tif (left->data != '(')throw - 1;\n\t\t\t\t\t++right;\n\t\t\t\t\tsubset.splice(subset.begin(), move(grams), left, right);\n\n\t\t\t\t\t// delete: ( , )\n\t\t\t\t\tsubset.pop_front();\n\t\t\t\t\tsubset.pop_back();\n\n\t\t\t\t\tif (subset.size() == 1)throw - 1;\n\n\t\t\t\t\tint res = read(subset);\n\t\t\t\t\tif (res < 0)throw - 1;\n\t\t\t\t\tif (1024 <= res)throw - 1;\n\n\t\t\t\t\tGram gram;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = res;\n\t\t\t\t\tgrams.insert(right, gram);\n\t\t\t\t\tright = grams.begin();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperator_erase(grams, '*', '*');\n\t\t\toperator_erase(grams, '+', '-');\n\t\t\tif (grams.size() != 1) {\n\t\t\t\t//cerr << \"size is too much\" << endl;\n\t\t\t\tthrow - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (grams.front().kind != 'n')throw - 1;\n\n\t\t\t\tint res = grams.front().num;\n\t\t\t\tif (res < 0 || 1024 <= res)throw -1;\n\t\t\t\telse return res;\n\t\t\t}\n\t\t}\n\t\tcatch (...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tbool isDigit(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tbool isnumber(const list<char>& ls){\n\t\tfor (char c : ls) {\n\t\t\tif (!isDigit(c)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isoperator(const char& c) {\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tlist<char> n2b(int num) {\n\t\tlist<char> b;\n\t\twhile (num > 0) {\n\t\t\tint tmp = num % 2;\n\t\t\tnum /= 2;\n\t\t\tb.push_front(tmp + '0');\n\t\t}\n\t\treturn b;\n\t}\n\n\tint b2n(const list<char>& ls) {\n\t\tint res = 0;\n\t\tfor (char c: ls) {\n\t\t\tres *= 2;\n\t\t\tres += c - '0';\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid operator_erase(\n\t\tlist<Gram>& grams,\n\t\tchar ope1,\n\t\tchar ope2\n\t){\n\t\tfor (auto center = grams.begin(); center != grams.end(); ++center) {\n\t\t\tif (center->data == ope1 || center->data == ope2) {\n\t\t\t\tauto left = center; if (distance(grams.begin(), left) == 0)break; left--;\n\t\t\t\tauto right = center; if (distance(right, grams.end()) == 1)break; right++;\n\t\t\t\tif (left->kind != 'n' || right->kind != 'n')continue;\n\n\t\t\t\tswitch (center->data) {\n\t\t\t\tcase '+':left->num += right->num; break;\n\t\t\t\tcase '-':left->num -= right->num; break;\n\t\t\t\tcase '*':left->num *= right->num; break;\n\t\t\t\t}\n\n\t\t\t\tif (left->num < 0 || 1024 <= left->num)throw - 1;\n\t\t\t\tgrams.erase(center);\n\t\t\t\tgrams.erase(right);\n\t\t\t\tcenter = left;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tStage stage;\n\tstage.action();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\ntypedef string::iterator Iterator;\nconst int LIMIT = 1<<10;\n\nint number(Iterator &it) {\n    int val = 0;\n    if(!isdigit(*it)) throw \"not a number\";\n    while(isdigit(*it)) {\n        val <<= 1;\n        val += *it - '0';\n        ++it;\n    }\n    if(val >= LIMIT) throw \"limit over\";\n    return val;\n}\n\nint expression(Iterator &it, bool &operated);\nint term(Iterator &it, bool &operated) {\n    int lhs;\n    if(*it == '(') {\n        lhs = expression(it, operated);\n    } else {\n        lhs = number(it);\n    }\n    while(*it == '*') {\n        ++it;\n        int rhs;\n        if(*it == '(') {\n            rhs = expression(it, operated);\n        } else {\n            rhs = number(it);\n        }\n        lhs *= rhs;\n        if(lhs >= LIMIT) throw \"limit over\";\n        operated = true;\n    }\n    return lhs;\n}\n\nint factor(Iterator &it, bool &operated) {\n    int lhs = term(it, operated);\n    while(*it == '+' || *it == '-') {\n        char op = *it;\n        ++it;\n        int rhs = term(it, operated);\n        if(op == '+') {\n            lhs += rhs;\n            if(lhs >= LIMIT) throw \"limit over\";\n            operated = true;\n        } else if(op == '-') {\n            lhs -= rhs;\n            if(lhs < 0) throw \"limit under\";\n            operated = true;\n        } else {\n            throw \"syntax error\";\n        }\n    }\n    return lhs;\n}\n\nint expression(Iterator &it, bool &operated) {\n    if(*it == '(') {\n        ++it;\n        bool operated = false;\n        int val = expression(it, operated);\n        if(val < 0 || val >= LIMIT) throw \"limit over\";\n        if(!operated) throw \"paren without operator\";\n        if(*it != ')') throw \"unmatched paren\";\n        ++it;\n        return val;\n    } else if(isdigit(*it)) {\n        return factor(it, operated);\n    } else {\n        throw \"syntax error\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    string str;\n    cin >> str;\n    vector<int> dotpos;\n    for(int i = 0; i < str.size(); ++i) {\n        if(str[i] == '.') dotpos.push_back(i);\n    }\n    int allpat = 1;\n    for(int i = 0; i < dotpos.size(); ++i) {\n        allpat *= 7;\n    }\n    int ans = -1;\n    for(int pat = 0; pat < allpat; ++pat) {\n        int tmp = pat;\n        string expr(str);\n        for(int i = 0; i < dotpos.size(); ++i) {\n            int n = tmp % 7;\n            tmp /= 7;\n            expr[dotpos[i]] = \"01+-*()\"[n];\n        }\n        try {\n            bool dmy;\n            Iterator it = expr.begin();\n            int val = expression(it, dmy);\n            if(val < 0 || val >= LIMIT) throw \"limit over\";\n            if(it != expr.end()) throw \"premature end\";\n            ans = max(ans, val);\n        } catch (const char *msg) {\n            //cout << expr << ' ' << msg << endl;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\ntypedef string::iterator Iterator;\nconst int LIMIT = 1<<10;\n\nint number(Iterator &it) {\n    int val = 0;\n    if(!isdigit(*it)) throw \"not a number\";\n    while(isdigit(*it)) {\n        val <<= 1;\n        val += *it - '0';\n        if(val >= LIMIT) throw \"limit over\";\n        ++it;\n    }\n    return val;\n}\n\nint expression(Iterator &it, bool &operated);\nint factor(Iterator &it, bool &operated) {\n    if(*it == '(') {\n        ++it;\n        bool opr = false;\n        int val = expression(it, opr);\n        if(*it == ')' && opr) {\n            ++it;\n            return val;\n        } else {\n            throw \"Illegal paren\";\n        }\n    } else {\n        return number(it);\n    }\n    throw \"error\";\n}\nint term(Iterator &it, bool &operated) {\n    int lhs = factor(it, operated);\n    while(*it == '*') {\n        ++it;\n        lhs *= factor(it, operated);\n        if(lhs < 0 || lhs >= LIMIT) throw \"limit over\";\n        operated = true;\n    }\n    return lhs;\n}\n\nint expression(Iterator &it, bool &operated) {\n    int lhs = term(it, operated);\n    while(*it == '+' || *it == '-') {\n        char op = *it;\n        ++it;\n        if(op == '+') {\n            lhs += term(it, operated);\n        } else if(op == '-') {\n            lhs -= term(it, operated);\n        }\n        operated = true;\n        if(lhs < 0 || lhs >= LIMIT) throw \"limit over\";\n    }\n    return lhs;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    string str;\n    cin >> str;\n    vector<int> dotpos;\n    for(int i = 0; i < str.size(); ++i) {\n        if(str[i] == '.') dotpos.push_back(i);\n    }\n    int allpat = 1;\n    for(int i = 0; i < dotpos.size(); ++i) {\n        allpat *= 7;\n    }\n    int ans = -1;\n    for(int pat = 0; pat < allpat; ++pat) {\n        int tmp = pat;\n        string expr(str);\n        for(int i = 0; i < dotpos.size(); ++i) {\n            int n = tmp % 7;\n            tmp /= 7;\n            expr[dotpos[i]] = \"01+-*()\"[n];\n        }\n        try {\n            bool dmy;\n            Iterator it = expr.begin();\n            int val = expression(it, dmy);\n            if(val < 0 || val >= LIMIT) throw \"limit over\";\n            if(it != expr.end()) throw \"premature end\";\n            ans = max(ans, val);\n        } catch (const char *msg) {\n            //cout << expr << ' ' << msg << endl;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint digit(State& begin);\nint number(State& begin);\nint term(State& begin);\nint fact(State& begin);\nint expr(State& begin);\n\nint digit(State& begin) {\n    int res = *begin - '0';\n    begin++;\n    return res;\n}\n\nint number(State& begin) {\n    if (!isdigit(*begin)) throw ParseError();\n    int res = digit(begin);\n    while (isdigit(*begin)) {\n        res *= 2;\n        res += digit(begin);\n    }\n    if (res >= 1024 || 0 > res) throw ParseError();\n    return res;\n}\n\nint term(State& begin) {\n    int res = fact(begin);\n    while (*begin == '*') {\n        begin++;\n        res *= fact(begin);\n    }\n    if (res >= 1024 || 0 > res) throw ParseError();\n    return res;\n}\n\nint fact(State& begin) {\n    if (*begin == '(') {\n        begin++;\n        int res = expr(begin);\n        if (*begin != ')') throw ParseError();\n        begin++;\n        return res;\n    }\n    return number(begin);\n}\n\nint expr(State& begin) {\n    int res = term(begin);\n    while (true) {\n        if (*begin == '+') {\n            begin++;\n            res += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            res -= term(begin);\n        } else {\n            break;\n        }\n        if (res >= 1024 || 0 > res) throw ParseError();\n    }\n    return res;\n}\n\nbool check(string s) {\n    vector<int> v;\n    set<int> S;\n    map<int, bool> m;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '(') {\n            v.push_back(i);\n            S.insert(i);\n        }\n        if ((s[i] == '*' || s[i] == '+' || s[i] == '-') && v.size()) {\n            m[v[v.size() - 1]] = true;\n        }\n        if (s[i] == ')') {\n            v.pop_back();\n        }\n    }\n    bool flag = true;\n    for (auto x : S) {\n        flag &= m[x];\n    }\n    return flag;\n}\n\nint solve(string s) {\n    State begin = s.begin();\n    try {\n        int res = expr(begin);\n        if (begin == s.end() && check(s)) {\n            return res;\n        } else {\n            return -1;\n        }\n    } catch (ParseError p) {\n        return -1;\n    }\n}\n\nint main() {\n    string s;\n    cin >> s;\n    string kouho = \"01+-*()\";\n    int SIZE = 1;\n    int n = 7;\n    int N = 0;\n    vector<int> index;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '.') {\n            index.push_back(i);\n            N++;\n        }\n    }\n    for (int i = 0; i < N; i++) SIZE *= n;\n    vector<vector<char>> v(SIZE, vector<char>());\n    for (int rep = 0; rep < N; rep++) {\n        SIZE /= n;\n        for (int i = 0; i < v.size(); i++) {\n            v[i].push_back(kouho[(i / SIZE) % n]);\n        }\n    }\n    int ans = -1;\n    for (auto V : v) {\n        for (int i = 0; i < N; i++) {\n            s[index[i]] = V[i];\n        }\n        ans = max(ans, solve(s));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstring ch = \"01+-*()\";\nint ans = -1;\n\nint expression(const string& s, int& k);\nint factor(const string& s, int& k);\nint term(const string& s, int& k);\n\n// 数字が [0,1023] かチェック\nbool valid(const int n){\n\treturn (0 <= n && n < 1024);\n}\n\n// <number> ::= <digit> | <number> <digit>\nint number(const string& s, int& k){\n\tint r = 0;\n\twhile( s[k] == '0' || s[k] == '1' ){\n\t\tr = r * 2 + (s[k] - '0');\n\t\t++k;\n\t}\n\treturn r;\n}\n\nint expression(const string& s, int& k){\n\tint r1 = term(s, k);\n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r1;\n}\n\nint factor(const string& s, int& k){\n\tif( s[k] == '(' ){ // 括弧のはじまりのとき\n\t\t++k; // '(' の 1つ先に進める.\n\t\tint r = expression(s, k);\n\t\t// 数字が [0,1023] の範囲にない or ')' がないとき\n\t\tif( !valid(r) || s[k] != ')' ) return -1;\n\t\t\n\t\t++k; // ')' の 1つ先に進める.\n\t\treturn r;\n\t}else if( s[k] == '0' || s[k] == '1' ){ // 数字のとき\n\t\treturn number(s, k);\n\t}else{\n\t\treturn -1;\n\t}\n}\n\nint term(const string& s, int& k){\n\tint r1 = factor(s, k);\n\t// 数字が [0,1023] の範囲にないとき \n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '*' ){\n\t\t\t++k;\n\t\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 * r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r1;\n}\n\n// 式が正しいかどうか.\nbool check(const string& s){\n\tint par = 0;\n\tchar prev = '\\0';\n\tdeque<bool> op(100, false);\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( prev == '\\0' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '(' ){\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '0' || prev == '1' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}\n\t\t\tprev = s[i];\n\t\t}else if( prev == '+' || prev == '-' || prev == '*' ){\n\t\t\tif( par > 0 ){\n\t\t\t\top[par] = true;\n\t\t\t}\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == ')' ){\n\t\t\tif( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tint t=0;\n\t\t// 式が正しいときだけ解を更新.\n\t\tif( check(s) ){\n\t\t\tint res = expression(s, t);\n\t\t\tans = max( ans , res );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[200];\nchar *p;\nint n;\n\nbool ok(int n){\n    return 0<=n && n<=(1<<10);\n}\n\nint E();\nint F();\nint T();\nint N();\n\nint E(){\n    int res = F();\n    while(*p=='+' || *p=='-'){\n        if(*p=='+') p++, res += F();\n        else if(*p=='-') p++, res -= F();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint F(){\n    int res = T();\n    while(*p=='*' || *p=='/'){\n        if(!ok(res)) throw \"\";\n        if(*p=='*') p++, res *= T();\n        else if(*p=='/') p++, res /= T();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint T(){\n    int res;\n    if(*p=='(') p++, res = E(), p++;\n    else res = N();\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nint N(){\n    int res = 0;\n    if(!isdigit(*p)) throw \"\";\n    while(isdigit(*p)){\n        res = res*2 + *p - '0';\n        p++;\n    }\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nbool chk(){\n    for(int i=0;i<n;i++){\n        if(s[i]!='(') continue;\n        int j = i;\n        int d = 0;\n        int cnt = 0;\n        while(s[j]){\n            if(s[j]=='(') d++;\n            else if(s[j]==')') d--;\n            if(d==1) if(s[j]=='+' || s[j]=='-') cnt++;\n            if(d==0) break;\n            j++;\n        }\n        dump(cnt);\n        dump(d);\n        if(d!=0 || cnt==0) return false;\n    }\n    return true;\n}\n\nint main(){\n    cin >> s;\n    n = strlen(s);\n    int x[6], k = 0;\n    char cand[] = \"01+-*())\";\n    for(int i=0;i<n;i++){\n        if(s[i]=='.') x[k++] = i;\n    }\n    int ans = -1;\n    for(int mask=0;mask<1<<(3*k);mask++){\n        p = s;\n        int t = mask;\n        for(int i=0;i<k;i++) s[x[i]] = cand[t>>(3*i)&7];\n        dump(s);\n        if(!chk()) continue;\n        try {\n            dump(\"ok\");\n            ans = max(ans, E());\n        } catch(...){}\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')')return false;\n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    assert(s[i] != '.');\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '(' || s[i] == ')'){\n      if(s[i] == ')' && s[i+1] == '(')return false;\n      if(s[i] == '(' && s[i+1] == ')')return false;\n      if(s[i] == ')' && i+1 < s.length()){\n\tif(!(s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      }\n      if(s[i] == '(' && i-1 >= 0){\n\tif(s[i-1] == '0' || s[i-1] == '1' || s[i-1] == ')')return false;\n      }\n      \n    }\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(!(0<= p && p < 1024))return FAILED;\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' == parse[pos] || parse[pos] == '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[200];\nchar *p;\nint n;\n\nbool ok(int n){\n    return 0<=n && n<=(1<<10);\n}\n\nint E();\nint F();\nint T();\nint N();\n\nint E(){\n    int res = F();\n    while(*p=='+' || *p=='-'){\n        if(*p=='+') p++, res += F();\n        else if(*p=='-') p++, res -= F();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint F(){\n    int res = T();\n    while(*p=='*' || *p=='/'){\n        if(!ok(res)) throw \"\";\n        if(*p=='*') p++, res *= T();\n        else if(*p=='/') p++, res /= T();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint T(){\n    int res;\n    if(*p=='(') p++, res = E(), p++;\n    else res = N();\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nint N(){\n    int res = 0;\n    if(!isdigit(*p)) throw \"\";\n    while(isdigit(*p)){\n        res = res*2 + *p - '0';\n        p++;\n    }\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nbool chk(){\n    for(int i=0;i<n;i++){\n        if(s[i]!='(') continue;\n        int j = i;\n        int d = 0;\n        int cnt = 0;\n        while(s[j]){\n            if(s[j]=='(') d++;\n            else if(s[j]==')') d--;\n            if(d==1) if(s[j]=='+' || s[j]=='-' || s[j]=='*' || s[j]=='/') cnt++;\n            if(d==0) break;\n            j++;\n        }\n        dump(cnt);\n        dump(d);\n        if(d!=0 || cnt==0) return false;\n    }\n    return true;\n}\n\nint main(){\n    cin >> s;\n    n = strlen(s);\n    int x[6], k = 0;\n    char cand[] = \"01+-*())\";\n    for(int i=0;i<n;i++){\n        if(s[i]=='.') x[k++] = i;\n    }\n    int ans = -1;\n    for(int mask=0;mask<1<<(3*k);mask++){\n        p = s;\n        int t = mask;\n        for(int i=0;i<k;i++) s[x[i]] = cand[t>>(3*i)&7];\n        dump(s);\n        if(!chk()) continue;\n        try {\n            int t = E();\n            if(p-s!=n) continue;\n            dump(t);\n            ans = max(ans,t);\n        } catch(...){}\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\n\nstruct Parser{\n\tstring s;\n\tint N;\n\tint c;\n\n\tll parse(string s){\n\t\tthis->s = s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\ttry{\n\t\t\tll ret = expr();\n\t\t\tif(!check(ret) || c != N) throw \"\";\n\t\t\treturn ret;\n\t\t}\n\t\tcatch(...){\n\t\t\treturn INF;\n\t\t}\n\t}\n\n\tbool check(ll n){\n\t\treturn 0 <= n && n < 1024;\n\t}\n\n\tvoid debug(string text){\n\t\treturn;\n\t\tcout << text + \" \";\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\t\telse cout << s[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tll expr(){\n\t\tdebug(\"expr\");\n\t\tll x = term();\n\t\tif(!check(x)) throw \"\";\n\t\twhile(c < N){\n\t\t\tif(s[c] == '+'){\n\t\t\t\tc++;\n\t\t\t\tx += term();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse if(s[c] == '-'){\n\t\t\t\tc++;\n\t\t\t\tx -= term();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll term(){\n\t\tdebug(\"term\");\n\t\tll x = factor();\n\t\tif(!check(x)) throw \"\";\n\t\twhile(c < N){\n\t\t\tif(s[c] == '*'){\n\t\t\t\tc++;\n\t\t\t\tx *= factor();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll factor(){\n\t\tdebug(\"factor\");\n\t\tif(s[c] == '('){\n\t\t\tc++;\n\t\t\tint start = c;\n\t\t\tll ret = expr();\n\t\t\tif(s[c] != ')') throw \"\";\n\t\t\tif(!check(ret)) throw \"\";\n\t\t\t//assert(s[c] == ')');\n\t\t\tint cnt = 0;\n\t\t\tbool op = 0;\n\t\t\tfor(int i = start; i < c; i++){\n\t\t\t\tif(s[i] == '(') cnt++;\n\t\t\t\tif(s[i] == ')') cnt--;\n\t\t\t\tif(cnt == 0 && (s[i] == '+' || s[i] == '*' || s[i] == '-')) op = 1;\n\t\t\t}\n\t\t\tif(!op) throw \"\";\n\t\t\tc++;\n\t\t\treturn ret;\n\t\t}\n\t\treturn num();\n\t}\n\n\tll num(){\n\t\tdebug(\"num\");\n\t\tif(!isdigit(s[c])) throw \"\";\n\t\tll ret = 0;\n\t\twhile(c < N && isdigit(s[c])){\n\t\t\tret = ret * 2 + s[c] - '0';\n\t\t\tif(!check(ret)) throw \"\";\n\t\t\tc++;\n\t\t}\n\t\treturn ret;\n\t}\n} parser;\n\nstring t = \"01+*-()\";\nll ans = -1;\n\nvoid dfs(int n, string s){\n\tif(n == s.size()){\n\t\tll res = parser.parse(s);\n\t\tif(res != INF) ans = max(ans, res);\n\t\treturn;\n\t}\n\tif(s[n] != '.'){\n\t\treturn dfs(n + 1, s);\n\t}\n\tfor(int i = 0; i < t.size(); i++){\n\t\ts[n] = t[i];\n\t\tdfs(n + 1, s);\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tstring s;\n\tcin >> s;\n\tdfs(0, s);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool err;\n\nvoid valid(int n)\n{\n\tif (n<0 || 1023<n)\n\t\terr = true;\n}\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\tvalid(res);\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else if (isdigit(s[p])) {\n\t\treturn number(s);\n\t} else {\n\t\terr = true;\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tp++;\n\t\tret *= factor(s);\n\t\tvalid(ret);\n\t}\n\t\n\tvalid(ret);\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\tfor(;;) {\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += term(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= term(s);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tvalid(res);\n\t}\n\t\n\tvalid(res);\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\tvalid(res);\n\treturn res;\n}\n\nbool isOpe(char c)\n{\n\treturn (c=='+'||c=='-'||c=='*');\n}\n\nbool check(string s)\n{\n\tvector<int> ope;\n\t\n\tif (s[N-1]=='+' || s[N-1]=='-' || s[N-1]=='*' || s[N-1]=='(')\n\t\treturn false;\n\t\n\trep(i, s.size()-1) {\n\t\tif (isOpe(s[i])&&isOpe(s[i+1]))\n\t\t\treturn false;\n\t}\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tif (i!=0 && !isOpe(s[i-1]) && s[i-1]!='(')\n\t\t\t\treturn false;\n\t\t\tope.push_back(0);\n\t\t} else if (s[i]==')') {\n\t\t\tif (d<0 || !ope[d]) return false;\n\t\t\tope.erase(ope.begin()+d);\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), 0);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>=1024) res=-1;\n\t\t\n\t\tcerr << \"Persing : \" << s << endl;\n\t\tcerr << \"    res : \" << (err?-1:res) << endl;\n\t\t\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <stdexcept>\n\n#define fprintf(...) void(0)\n\nstruct Tsurai: public std::out_of_range {\n  Tsurai(int d): std::out_of_range(std::string(\"L: \")+std::to_string(d)) {}\n};\n\nvoid apply(int &lhs, char op, int rhs) {\n  switch (op) {\n  case '+':\n    lhs += rhs;\n    break;\n  case '-':\n    lhs -= rhs;\n    break;\n  case '*':\n    lhs *= rhs;\n    break;\n  }\n  if (!(0 <= lhs && lhs < 1024))\n    throw Tsurai(__LINE__);\n}\n\nint parse_bin(const std::string &s, size_t &i) {\n  int res=0;\n  while (i < s.length() && isdigit(s[i])) {\n    res = res*2+s[i]-'0';\n    ++i;\n    if (res >= 1024) throw Tsurai(__LINE__);\n  }\n  assert(res < 1024);\n  return res;\n}\n\nstd::pair<int, int> parse(\n    const std::string &s, size_t &i,\n    const std::vector<std::string> &ops={\"+-\", \"*\", \"\"}, size_t prec=0) {\n\n  // <calculates, num of terms/factors>\n  fprintf(stderr, \"C%zu\\n\", i);\n  fprintf(stderr, \"S: %s\\n\", s.c_str());\n  if (prec == ops.size()) {\n    if (s.at(i) == '(') {\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      ++i;\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (s.at(i) == ')') throw Tsurai(__LINE__);\n      size_t j=i;\n      (void)parse_bin(s, j);\n      if (s.at(j) == ')') throw Tsurai(__LINE__);\n\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      std::pair<int, int> res=parse(s, i, ops, 0);\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (s.at(i) != ')')\n        throw Tsurai(__LINE__);\n      ++i;\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (res.second <= 1)\n        throw Tsurai(__LINE__);\n      return {res.first, 1};\n    }\n    fprintf(stderr, \"%d\\n\", __LINE__);\n    if (isdigit(s.at(i))) {\n      fprintf(stderr, \"%d\\n\", __LINE__);\n      return {parse_bin(s, i), 1};\n    }\n    throw Tsurai(__LINE__);\n  }\n\n  std::pair<int, int> lhs(parse(s, i, ops, prec+1).first, 1);\n  fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n\n  while (i < s.length()) {\n    char op=s.at(i);\n    if (op == ')')\n      break;\n    if (!(op == '+' || op == '-' || op == '*'))\n      throw Tsurai(__LINE__);\n    if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n      break;\n\n    int rhs=parse(s, ++i, ops, prec+1).first;\n    apply(lhs.first, op, rhs);\n    ++lhs.second;\n  }\n  return lhs;\n}\n\nint rec(std::string &s, std::vector<size_t> &dot) {\n  if (dot.empty()) {\n    try {\n      size_t i=0;\n      return parse(s, i).first;\n      if (i != s.length()) return -1;\n    } catch (std::out_of_range x) {\n      fprintf(stderr, \"Tsurai on %s\\n\", x.what());\n      return -1;\n    }\n  }\n\n  size_t x=dot.back();\n  dot.pop_back();\n  int res=-1;\n  for (char ch: {'0', '1', '+', '-', '*', '(', ')'}) {\n    s[x] = ch;\n    res = std::max(res, rec(s, dot));\n  }\n  s[x] = '.';\n  dot.push_back(x);\n  return res;\n}\n\nint main() {\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  std::vector<size_t> dot;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '.')\n      dot.push_back(i);\n  }\n\n  printf(\"%d\\n\", rec(s, dot));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\ntypedef string::iterator Iterator;\nconst int LIMIT = 2<<10;\n\nint number(Iterator &it) {\n    int val = 0;\n    if(!isdigit(*it)) throw \"not a number\";\n    while(isdigit(*it)) {\n        val <<= 1;\n        val += *it - '0';\n        ++it;\n    }\n    if(val >= LIMIT) throw \"limit over\";\n    return val;\n}\n\nint expression(Iterator &it, bool &operated);\nint term(Iterator &it, bool &operated) {\n    int lhs;\n    if(*it == '(') {\n        lhs = expression(it, operated);\n    } else {\n        lhs = number(it);\n    }\n    while(*it == '*') {\n        ++it;\n        int rhs;\n        if(*it == '(') {\n            rhs = expression(it, operated);\n        } else {\n            rhs = number(it);\n        }\n        lhs *= rhs;\n        if(lhs >= LIMIT) throw \"limit over\";\n        operated = true;\n    }\n    return lhs;\n}\n\nint factor(Iterator &it, bool &operated) {\n    int lhs = term(it, operated);\n    while(*it == '+' || *it == '-') {\n        char op = *it;\n        ++it;\n        int rhs = term(it, operated);\n        if(op == '+') {\n            lhs += rhs;\n            if(lhs >= LIMIT) throw \"limit over\";\n            operated = true;\n        } else if(op == '-') {\n            lhs -= rhs;\n            if(lhs < 0) throw \"limit under\";\n            operated = true;\n        } else {\n            throw \"syntax error\";\n        }\n    }\n    return lhs;\n}\n\nint expression(Iterator &it, bool &operated) {\n    if(*it == '(') {\n        ++it;\n        bool operated = false;\n        int val = expression(it, operated);\n        if(val < 0 || val >= LIMIT) throw \"limit over\";\n        if(!operated) throw \"paren without operator\";\n        if(*it != ')') throw \"unmatched paren\";\n        ++it;\n        return val;\n    } else if(isdigit(*it)) {\n        return factor(it, operated);\n    } else {\n        throw \"syntax error\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    string str;\n    cin >> str;\n    vector<int> dotpos;\n    for(int i = 0; i < str.size(); ++i) {\n        if(str[i] == '.') dotpos.push_back(i);\n    }\n    int allpat = 1;\n    for(int i = 0; i < dotpos.size(); ++i) {\n        allpat *= 7;\n    }\n    int ans = -1;\n    for(int pat = 0; pat < allpat; ++pat) {\n        int tmp = pat;\n        string expr(str);\n        for(int i = 0; i < dotpos.size(); ++i) {\n            int n = tmp % 7;\n            tmp /= 7;\n            expr[dotpos[i]] = \"01+-*()\"[n];\n        }\n        try {\n            bool dmy;\n            Iterator it = expr.begin();\n            int val = expression(it, dmy);\n            if(val < 0 || val >= LIMIT) throw \"limit over\";\n            if(it != expr.end()) throw \"premature end\";\n            ans = max(ans, val);\n        } catch (const char *msg) {\n            //cout << expr << ' ' << msg << endl;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int MAX = 1023;\n/*\n\t<expression> ::= <number> | <expression> <operation> <expression>\n\t| ( <expression> <operation> <expression> )\n\t<number> ::= <digit> | <number> <digit>\n\t<operation> ::= + | - | *\n\t<digit> ::= 0 | 1\n*/\nstruct Parser {\n\tusing Iter = string::const_iterator;\n\tconst char kTerminator = '$';\n\tstring s;\n\tIter it;\n\tParser(const string &t) :s(t) { s += kTerminator; it = s.begin(); }\n\tvoid cmp(char expected) {\n\t\tif (*it != expected) {\n\t\t\tthrow 0;\n\t\t\tcerr << *it << \" is not \" << expected << endl;\n\t\t}\n\t}\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == '+') {\n\t\t\t\tit++;\n\t\t\t\tret += b();\n\t\t\t}\n\t\t\telse if (*it == '-') {\n\t\t\t\tit++;\n\t\t\t\tret -= b();\n\t\t\t}\n\t\t\telse break;\n\t\t\tif (ret > MAX || ret < 0)\n\t\t\t\tthrow 0;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == '*') {\n\t\t\t\tit++;\n\t\t\t\tret *= c();\n\t\t\t}\n\t\t\telse break;\n\t\t\tif (ret > MAX || ret < 0)\n\t\t\t\tthrow 0;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\tif (ret > MAX || ret < 0)\n\t\t\tthrow 0;\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 2;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t\tif (ret > MAX)\n\t\t\t\tthrow 0;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool isOp(char c) {\n\treturn c == '+' || c == '-' || c == '*';\n}\n\nstruct Parser2 {\n\tusing Iter = string::const_iterator;\n\tconst char kTerminator = '$';\n\tstring s;\n\tIter it;\n\tParser2(const string &t) :s(t) { s += kTerminator; it = s.begin(); }\n\tvoid cmp(char expected) {\n\t\tif (*it != expected) {\n\t\t\tthrow 0;\n\t\t\tcerr << *it << \" is not \" << expected << endl;\n\t\t}\n\t}\n\tbool a() {\n\t\tIter it2 = it;\n\t\tstack<int> st;\n\t\twhile (*it != kTerminator) {\n\t\t\tif (st.size() && isOp(*it))\n\t\t\t\tst.push(*it);\n\t\t\telse if (*it == '(') {\n\t\t\t\tst.push(*it);\n\t\t\t}\n\t\t\telse if (*it == ')') {\n\t\t\t\tif (st.empty())\n\t\t\t\t\treturn true;\n\t\t\t\tif (st.top() == '(')\n\t\t\t\t\treturn true;\n\t\t\t\twhile (st.top() != '(') {\n\t\t\t\t\tst.pop();\n\t\t\t\t\tif (st.empty())\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t\tif (st.size())return true;\n\t\treturn false;\n\t}\n};\n\nvector<int> powerArray(int p, int n) {\n\tvector<int> power(n + 1); power[0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tpower[i + 1] = power[i] * p;\n\treturn power;\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\n\tvector<int> idx;\n\trep(i, 0, s.size()) {\n\t\tif (s[i] == '.')\n\t\t\tidx.push_back(i);\n\t}\n\tint cnt = idx.size();\n\n\tchar c[7] = { '0','1','+','-','*','(',')' };\n\tvector<int> pow7 = powerArray(7, cnt);\n\tint ans = -1;\n\trep(mask, 0, pow7[cnt]) {\n\t\trep(i, 0, cnt)\n\t\t\ts[idx[i]] = c[mask / pow7[i] % 7];\n\t\ttry {\n\t\t\tParser parser(s);\n\t\t\tParser2 parser2(s);\n\n\t\t\tfor (int i = 0; i < (int)s.size() - 1; i++) {\n\t\t\t\tif (isOp(s[i]) && isOp(s[i + 1]))\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (s[i] == '(' && isOp(s[i + 1]))\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (s[i] == ')' && isdigit(s[i + 1]))\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (isOp(s[i]) && s[i + 1] == ')')\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (isdigit(s[i]) && s[i + 1] == '(')\n\t\t\t\t\tthrow 0;\n\t\t\t}\n\t\t\tif (isOp(s.front()) || isOp(s.back()))\n\t\t\t\tthrow 0;\n\n\t\t\tdump(s);\n\t\t\tif (parser2.a())\n\t\t\t\tthrow 0;\n\t\t\tint res = parser.a();\n\t\t\tif (res > MAX || res < 0)\n\t\t\t\tthrow 0;\n\t\t\tchmax(ans, res);\n\t\t\tdump(ans);\n\t\t}\n\t\tcatch (...) {\n\t\t\t//dump(\"error\");\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tconst int kind = 7;\n\tStage(){\n\t}\n\t\n\tvoid action(){\n\t\tstring text;\n\t\tcin >> text;\n\n\t\tint res = -1;\n\t\tREP(transWay, pow(kind, count_dot(text))) {\n\t\t\tstring transedText = trans(transWay, text);\n\t\t\tlist<char> ls;\n\t\t\tfor (char c : transedText)ls.push_back(c);\n\t\t\tint score = read(ls);\n\t\t\tres = max(res, score);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tchar data;\n\t\tint num;\n\t};\n\t\n\tint count_dot(const string& text) {\n\t\tint res = 0;\n\t\tfor (char c : text)if (c == '.')res++;\n\t\treturn res;\n\t}\n\tstring trans(int n, string text) {\n\t\tfor (char& c : text)if (c == '.') {\n\t\t\tswitch (n % kind) {\n\t\t\tcase 0:c = '0'; break;\n\t\t\tcase 1:c = '1'; break;\n\t\t\tcase 2:c = '+'; break;\n\t\t\tcase 3:c = '-'; break;\n\t\t\tcase 4:c = '*'; break;\n\t\t\tcase 5:c = '('; break;\n\t\t\tcase 6:c = ')'; break;\n\t\t\t}\n\t\t\tn /= kind;\n\t\t}\n\t\treturn text;\n\t}\n\n\tlist<Gram> trans_gram(const list<char>& ls) {\n\t\tlist<Gram> grams;\n\t\tfor (auto itr = ls.begin(); itr != ls.end(); ++itr) {\n\t\t\tGram gram;\n\t\t\tswitch (*itr) {\n\t\t\tcase '+':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '+';\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '-';\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '*';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgram.kind = 'n';\n\t\t\t\tgram.num = 0;\n\t\t\t\tdo {\n\t\t\t\t\tgram.num *= 2;\n\t\t\t\t\tgram.num += *itr - '0';\n\t\t\t\t\t++itr;\n\t\t\t\t} while (itr != ls.end() && isdigit(*itr));\n\t\t\t\t--itr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tint read(list<char> ls) {\n\t\ttry {\n\t\t\t// ( , ) delete\n\t\t\tfor (auto right = ls.begin(); right != ls.end(); ++right)\n\t\t\t{\n\t\t\t\tif (*right == ')') {\n\t\t\t\t\tlist<char> subset;\n\t\t\t\t\tauto left = right;\n\n\t\t\t\t\t//move: (expression)\n\t\t\t\t\twhile (left!=ls.begin() && *left != '(') --left;\n\t\t\t\t\tif (*left != '(')throw - 1;\n\t\t\t\t\t++right;\n\t\t\t\t\tsubset.splice(subset.begin(), move(ls), left, right);\n\n\t\t\t\t\t// delete: ( , )\n\t\t\t\t\tsubset.pop_front();\n\t\t\t\t\tsubset.pop_back(); \n\t\t\t\t\tif (isnumber(subset))throw - 1;\n\n\t\t\t\t\tint res = read(subset);\n\t\t\t\t\tif (res < 0)throw - 1;\n\t\t\t\t\tsubset = n2b(res);\n\t\t\t\t\tif (ls.empty()) {\n\t\t\t\t\t\tfor (auto num : subset)ls.push_back(num);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tls.splice(left, move(subset));\n\t\t\t\t\t}\n\t\t\t\t\tright = ls.begin();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tauto grams = trans_gram(ls);\n\t\t\toperator_erase(grams, '*');\n\t\t\toperator_erase(grams, '+', '-');\n\t\t\tif (grams.size() != 1) {\n\t\t\t\t//cerr << \"size is too much\" << endl;\n\t\t\t\tthrow - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn grams.front().num;\n\t\t\t}\n\t\t}\n\t\tcatch (...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbool isnumber(const list<char>& ls){\n\t\tfor (char c : ls) {\n\t\t\tif (c < '0' || '9' < c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isoperator(const char& c) {\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tlist<char> n2b(int num) {\n\t\tlist<char> b;\n\t\twhile (num > 0) {\n\t\t\tint tmp = num % 2;\n\t\t\tnum /= 2;\n\t\t\tb.push_front(tmp + '0');\n\t\t}\n\t\treturn b;\n\t}\n\n\tint b2n(const list<char>& ls) {\n\t\tint res = 0;\n\t\tfor (char c: ls) {\n\t\t\tres *= 2;\n\t\t\tres += c - '0';\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid operator_erase(\n\t\tlist<Gram>& grams,\n\t\tconst char& ope1,\n\t\tconst char& ope2 = '.'\n\t){\n\t\tfor (auto center = grams.begin(); center != grams.end(); ++center) {\n\t\t\tif (center->data == ope1 || center->data == ope2) {\n\t\t\t\tauto left = center; if (distance(grams.begin(), left) == 0)break; left--;\n\t\t\t\tauto right = center; if (distance(right, grams.end()) == 1)break; right++;\n\n\t\t\t\tswitch (center->data) {\n\t\t\t\tcase '+':left->num += right->num; break;\n\t\t\t\tcase '-':left->num -= right->num; break;\n\t\t\t\tcase '*':left->num *= right->num; break;\n\t\t\t\t}\n\n\t\t\t\tif (left->num < 0 || 1024 <= left->num)throw - 1;\n\t\t\t\tgrams.erase(center);\n\t\t\t\tgrams.erase(right);\n\t\t\t\tcenter = left;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tStage stage;\n\tstage.action();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(p);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(s[p]=='*') res*=calc();\n  }\n  if(res<0||res>=1024) flg=0;\n  return res;\n}\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(p+1);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n    if(res<0||res>=1024) flg=0;\n  }\n  if(res<0||res>=1024) flg=0;\n  if(!flg)res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nchar ln[7]={'0','1','+','-','*','(',')'};\nint n=0,ans=-1;\nint p[5]={};\nint ind[5]={};\nstring s,t;\nmap<int,int> mp;\n\nstring f(string a){\n  if(a==\"+\" || a==\"-\" || a==\"*\" || a==\"(\" || a==\")\")return a;\n  reverse(a.begin(),a.end());\n  int res=0;\n  for(int i=0;i<a.length();i++)res+=(pow(2,i)*(a[i]-'0'));\n  ostringstream os;\n  os<<res;\n  return os.str();\n}\n\nint cal(vector<string> v){\n  if(v.empty())return -1;\n  //if(v.size()==3 && (v[1][0]=='0' || v[1][0]=='1') && v[0]==\"(\" && v[2]==\")\")return -1; \n  vector<string> vs1,vs2,vs3;\n  for(int i=0;i<v.size();i++){\n    if(v[i]==\"(\"){\n      vector<string> tmp;\n      int l=1,r=0,count=0;\n      for(int j=i+1;j<v.size();j++){\n\tif(v[j]==\"(\")l++;\n\tif(v[j]==\")\")r++;\n\tif((l-r)==1 && (v[j]==\"+\" || v[j]==\"*\" || v[j]==\"-\"))count++;\n\tif(r==l){\n\t  if(count==0)return -1;\n\t  i=j;\n\t  break;\n\t}\n\ttmp.push_back(v[j]);\n      }\n      int res=cal(tmp);\n      if(res==-1 || 1024<=res)return -1;\n      ostringstream os;\n      os<<res;\n      vs1.push_back(os.str());\n    }\n    else vs1.push_back(v[i]);\n  }\n  //if((vs1[1][0]=='0' || vs1[1][0]=='1') && vs1[0]==\"(\" && vs1[2]==\")\")return -1;\n  if(vs1[0]==\"+\" || vs1[0]==\"*\" || vs1[0]==\"-\")return -1;\n  int size=vs1.size()-1;\n  if(vs1[size]==\"+\" || vs1[size]==\"*\" || vs1[size]==\"-\")return -1;\n  for(int i=0;i<vs1.size();i++){\n    if(vs1[i]==\"*\"){\n      if('0'<=vs1[i+1][0] && vs1[i+1][0]<='9' && '0'<=vs2.back()[0] && vs2.back()[0]<='9' ){\n\tint tmp1=atoi(vs2.back().c_str()),tmp2=atoi(vs1[i+1].c_str());\n\tvs2.pop_back();\n\tostringstream os;\n\tos<<(tmp1*tmp2);\n\tif(1024<=tmp1*tmp2)return -1;\n\tvs2.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs2.push_back(vs1[i]);\n  }\n  for(int i=0;i<vs2.size();i++){\n    if(vs2[i]==\"+\" || vs2[i]==\"-\"){\n      string tmp=vs3.back();\n      if('0'<=vs2[i+1][0] && vs2[i+1][0]<='9' && '0'<=tmp[0] && tmp[0]<='9' ){\n\tint tmp1=atoi(tmp.c_str()),tmp2=atoi(vs2[i+1].c_str());\n\tvs3.pop_back();\n\tostringstream os;\n\tint res;\n\tif(vs2[i]==\"+\")res=(tmp1+tmp2);\n\tif(vs2[i]==\"-\")res=(tmp1-tmp2);\n\tif(res<0 || 1024<=res)return -1;\n\tos<<res;\n\tvs3.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs3.push_back(vs2[i]);\n  }\n  int res=-1;\n  if(vs3.size()==1 && '0'<=vs3[0][0] && vs3[0][0]<='9')res=atoi(vs3[0].c_str());\n  if(res<0 || 1024<=res)res=-1;\n  return res;\n}\n\nvoid rec(int v){\n  if(v==n){\n    t=s;\n    for(int i=0;i<n;i++)t[ind[i]]=ln[p[i]];\n    string tmp=\"\";\n    vector<string> vs;\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='0' || t[i]=='1')tmp+=t[i];\n      else {\n\tif(tmp!=\"\")vs.push_back(tmp);\n\ttmp=\"\";\n\tstring st=\"\";\n\tst+=t[i];\n\tvs.push_back(st);\n      }\n    }\n    if(tmp!=\"\")vs.push_back(tmp);\n    stack<int> st;\n    for(int i=0;i<vs.size();i++){\n      if(vs[i]==\"(\")st.push(i);\n      if(vs[i]==\")\"){\n        if(st.empty())return;\n        st.pop();\n      }\n    }\n    if(!st.empty())return;\n    /*\n    for(int i=1;i<vs.size()-1;i++){\n      if((vs[i][0]=='0' || vs[i][0]=='1') && vs[i-1]==\"(\" && vs[i+1]==\")\")return;\n    }\n    for(int i=1;i<vs.size();i++){\n      if(vs[i]==\")\" && !('0'<=vs[i-1][0] && vs[i-1][0]<='9'))return;\n    }\n    for(int i=0;i<vs.size()-1;i++){\n      if(vs[i]==\"(\" && !('0'<=vs[i+1][0] && vs[i+1][0]<='9'))return;\n      }*/\n    for(int i=0;i<vs.size();i++)vs[i]=f(vs[i]);\n    int res=cal(vs);\n    ans=max(ans,res);\n  }\n  else {\n    for(int i=0;i<7;i++){\n      rec(v+1);\n      p[v]++;\n    }\n    p[v]=0;\n  }\n}\n\nint main()\n{\n  cin>>s;\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='.'){\n      ind[n]=i;\n      n++;\n    }\n  }\n  rec(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef string::iterator State;\nconst int MA=1023,MI=0;\n\nstring str;\n\nint number(State &begin);\nint term(State &begin);\nint expr(State &begin);\nint term(State &begin);\nint expr2(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tint d=*begin-'0';\n\t\tret*=2;\n\t\tret+=d;\n\t\tbegin++;\n\t\tif(ret>MA) return -1;\n\t}\n\tif(ret>MA||ret<MI) return -1;\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\tif(ret==-1) return -1;\n\twhile(true){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else break;\n\t}\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\nint expr(State &begin){\n\tint ret=term(begin);\n\tif(ret<MI||ret>MA) return -1;\n\tint c=0;\n\twhile(true){\n\t\tif(*begin=='+'){\n\t\t\tc++;\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret+=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else if(*begin=='-'){\n\t\t\tc++;\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}\n\t\telse break;\n\t}\n//\tif(c==0){\n//\t\tprintf(\"c==0---------------\\n\");\n//\t\treturn -1;\n//\t}\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\n\nint expr2(State &begin){\n\tint ret=term(begin);\n\tif(ret<MI||ret>MA) return -1;\n\twhile(true){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret+=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}\n\t\telse break;\n\t}\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expr(begin);\n//\t\tif(ret==-1) printf(\"expr -1\\n\");\n\t\tbegin++;\n\t\treturn ret;\n\t}else if(!isdigit(*begin)){\n\t\treturn -1;\n\t}\n\telse return number(begin);\n}\n\nint ans=-1;\nvector<int> dots;\n\nstring chars=\"01()+-*\";\n\nstack<int> ops;\nint a[1010],b[1010];\nbool check(){\n\tint c=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='('){\n\t\t\tops.push(i);\n\t\t}else if(str[i]==')'){\n\t\t\tif(ops.empty()) return false;\n\t\t\tint x=ops.top();\n\t\t\tops.pop();\n\t\t\ta[c]=x;\n\t\t\tb[c]=i;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tint in=0;\n\t\tint cnt=0;\n\t\tfor(int j=a[i]+1;j<b[i];j++){\n\t\t\tif(str[j]=='(') in++;\n\t\t\telse if(str[j]==')') in--;\n\t\t\telse if(in==0&&!isdigit(str[j])) cnt++;\n\t\t}\n\t\tif(cnt==0) return false;\n\t}\n\treturn true;\n}\n\nvoid dfs(int id){\n\tif(id==dots.size()){\n\t\tState s=str.begin();\n\t\tint a=expr2(s);\n\t\tif(s!=str.end()){\n\t\t\treturn;\n\t\t}\n\t\tans=max(ans,a);\n\t}\n\telse{\n\t\tfor(int i=0;i<7;i++){\n\t\t\tstr[dots[id]]=chars[i];\n\t\t\tdfs(id+1);\n\t\t}\n\t\tstr[dots[id]]='.';\n\t}\n}\n\nint main(){\n\tcin>>str;\n\tfor(int i=0;i<str.size();i++) if(str[i]=='.') dots.push_back(i);\n\tdfs(0);\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef string::iterator State;\nclass ParseError {};\nint op_cnt;\n\nint ParseExpression(State &itr);\n\nint ParseNumber(State &itr) {\n  int ret = 0;\n  if (*itr != '0' && *itr != '1') throw ParseError();\n\n  while (*itr == '0' || *itr == '1') {\n    ret = ret*2 + (*itr-'0');\n    if (ret >= 1024) throw ParseError();\n    itr++;\n  }\n  return ret;\n}\n\nint ParseFactor(State &itr) {\n  if (*itr == '(') {\n    itr++;\n    int op_cnt_ = op_cnt;\n    int ret = ParseExpression(itr);\n    if (op_cnt_ == op_cnt) throw ParseError();\n    op_cnt = op_cnt_;\n    if (*itr != ')') throw ParseError();\n    itr++;\n    return ret;\n  }\n  \n  //op_cnt++;\n  return ParseNumber(itr);\n}\n\nint ParseTerm(State &itr) {\n  int ret = ParseFactor(itr);\n  \n  while (1) {\n    if (*itr == '*') {\n      itr++;\n      ret *= ParseFactor(itr);\n      if (ret >= 1024) throw ParseError();\n      op_cnt++;\n    } else break;\n  }\n\n  return ret;\n}\n\nint ParseExpression(State &itr) {\n  int ret = ParseTerm(itr);\n  while (1) {\n    if (*itr == '+') {\n      itr++;\n      ret += ParseTerm(itr);\n      if (ret >= 1024) throw ParseError();\n      op_cnt++;\n    } else if (*itr == '-' ) {\n      itr++;\n      ret -= ParseTerm(itr);\n      if (ret < 0) throw ParseError();\n      op_cnt++;\n    } else break;\n  }\n  return ret;\n}\n\nint n;\nint ans = -1;\nchar cs[] = \"+-01*().\";\nchar buf[114514];\nstring s;\nvector<int> pos;\n\nvoid rec(int idx) {\n  if (n <= idx) {\n    auto itr = s.begin();\n    try {\n      int ret = ParseExpression(itr);\n      if (itr != s.end()) throw ParseError();\n      ans = max(ans, ret);\n    } catch (const ParseError &e) {}\n    return;\n  }\n\n  for (int i=0; i<8; i++) {\n    s[pos[idx]] = cs[i];\n    rec(idx+1);\n  }\n}\n\nint main() {\n  scanf(\"%s\", buf);\n  s = buf;\n  while (1) {\n    int idx = s.find('.');\n    if (idx == string::npos) break;\n    pos.emplace_back(idx);\n    s[idx] = '$';\n    n++;\n  }\n\n  ans = -1;\n  rec(0);\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(char ch){return ch&&ch!='+'&&ch!='-'&&ch!='*'&&ch!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(s[p]);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(s[p]=='*') res*=calc();\n  }\n  if(res<0||res>=1024) flg=0;\n  return res;\n}\n\nint bnf(){\n  flg&=check(s[p]);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(s[p+1]);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n    if(res<0||res>=1024) flg=0;\n  }\n  if(res<0||res>=1024) flg=0;\n  if(!flg)res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nbool valid(int n) {return 0 <= n && n < 1024;}\nbool valid(string str) {\n  int t = 0;\n  rep (i, str.size()) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) return false;\n    }\n  }\n  return t == 0;\n}\n\nint num(string str) {\n  int n = 0;\n  rep (i, str.size()) {\n    n = n * 2 + str[i] - '0';\n    if (n >= 1024) throw 1;\n  }\n  return n;\n}\n\nint exp(string str) {\n  int n = str.size();\n  if (str[0] == '(') {\n    int t = 0;\n    rep (i, n - 2) {\n      if (str[i] == '(') ++t;\n      if (str[i] == ')') {\n\t--t;\n\tif (t == 0) {\n\t  if (str[i + 1] == '+') {\n\t    int r = exp(str.substr(0, i + 1)) + exp(str.substr(i + 2));\n\t    if (!valid(r)) throw 1;\n\t    return r;\n\t  }\n\t  if (str[i + 1] == '-') {\n\t    int r = exp(str.substr(0, i + 1)) - exp(str.substr(i + 2));\n\t    if (!valid(r)) throw 1;\n\t    return r;\n\t  }\n\t  if (str[i + 1] == '*') {\n\t    int r = exp(str.substr(0, i + 1)) * exp(str.substr(i + 2));\n\t    if (!valid(r)) throw 1;\n\t    return r;\n\t  }\n\t  throw 1;\n\t}\n      }\n    }\n    if (str[str.size() - 1] != ')') throw 1;\n    if (str[1] == '(' && str[str.size() - 1] == ')') if (valid(str.substr(2, str.size() - 4))) throw 1;\n    rep (i, n - 1) if (i != 0 && !isdigit(str[i])) return exp(str.substr(1, str.size() - 2));\n    throw 1;\n  }\n  int d = str.size();\n  rep (i, str.size()) if (!isdigit(str[i])) {\n    d = i;\n    break;\n  }\n  if (d == n) return num(str);\n  if (d == n - 1) throw 1;\n  if (str[d] == '+') {\n    int r = exp(str.substr(0, d)) + exp(str.substr(d + 1));\n    if (!valid(r)) throw 1;\n    return r;\n  }\n  if (str[d] == '-') {\n    int r = exp(str.substr(0, d)) - exp(str.substr(d + 1));\n    if (!valid(r)) throw 1;\n    return r;\n  }\n  if (str[d] == '*') {\n    int r = exp(str.substr(0, d)) * exp(str.substr(d + 1));\n    if (!valid(r)) throw 1;\n    return r;\n  }\n  throw 1;\n}\n\nconst char c[] = {'0', '1', '+', '-', '*', '(', ')'};\nint solve0(string str, vector<int> dot) {\n  if (dot.size() == 0u) {\n    try {\n      return exp(str);\n    } catch(int n) {\n      return -1;\n    }\n  }\n  int n = dot.back();\n  dot.pop_back();\n  int res = -1;\n  rep (i, 7) {\n    str[n] = c[i];\n    res = max(res, solve0(str, dot));\n  }\n  return res;\n}\n\nint main() {\n  string str;\n  cin >> str;\n  vector<int> dot;\n  rep (i, str.size()) if (str[i] == '.') dot.push_back(i);\n  cout << solve0(str, dot) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\ntypedef string::const_iterator State;\nint number(State&);\npair<int,bool> factor(State&);\npair<int,bool> term(State&);\npair<int,bool> expression(State&);\n\nbool invalid;\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\tif(not isdigit(*begin)){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 2;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\npair<int,bool> factor(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tpair<int,bool> ret = expression(begin);\n\t\tif(not ret.second) {\n\t\t\tinvalid = true;\n\t\t}\n\t\tbegin++; // ')'を飛ばす。\n\t\tret.second = 0;\n\t\treturn ret;\n\t} else {\n\t\treturn make_pair(number(begin), 0);\n\t}\n\treturn make_pair(0, 0);\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\npair<int,bool> term(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first *= factor(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\npair<int,bool> expression(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first += term(begin).first;\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first -= term(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n//beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\t//throw ParseError();\n\t}\n}\n\nconst string c = \"01+-*()\";\n\nbool check(string& s){\n\tint cnt = 0;\n\tbool op = false, st = false;\n\tshow(s)\n\trep(i,s.size()){\n\t\tcout << i << endl;\n\t\tif(s[i] == '('){\n\t\t\tif(st) return false;\n\t\t\tcnt++;\n\t\t\top = true;\n\t\t}else if(s[i] == ')'){\n\t\t\tif(op or st) return false;\n\t\t\tcnt--;\n\t\t\top = false;\n\t\t\tst = true;\n\t\t}else if(s[i] == '+' or s[i] == '-'){\n\t\t\top = false;\n\t\t\tst = false;\n\t\t}\n\t}\n\tshow(cnt)\n\treturn cnt == 0;\n}\n\nint dfs(string s, int i){\n\tif(i == s.size()){\n\t\t//if(not check(s)) return -1e5;\n\n\t\tinvalid = false;\n\t\tState tmp = s.begin();\n\n\t\tpair<int,bool> ans = expression(tmp);\n\t\tif(ans.first >= 1024) continue;\n\t\tif(tmp != s.end()) return -1e5;\n\t\t//cout << ans << ' ' << s << endl;\n\t\treturn invalid ? -1e5 : ans.first;\n\t}\n\n\twhile(s[i] != '.' and i < s.size()){\n\t\ti++;\n\t}\n\n\tif(s[i] == '.'){\n\t\tint res = -1e5;\n\t\trep(j,c.size()){\n\t\t\ts[i] = c[j];\n\t\t\tres = max(res, dfs(s, i));\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn dfs(s, i);\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\n\tcout << dfs(s, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\n \nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\nbool OVER;\n \nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n \n  return true;\n}\n \nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n \n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n \n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true;\n  }\n  return false;\n}\n \nbool parapos(string s){\n  int p = 0;\n \n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n  }\n  return p == 0;\n}\n \nbool isvalid(string s){\n \n  if(!parapos(s)) return false;\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n \nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n \nint get(string s){\n  //  cout << \"S \" << s << endl;\n  \n  if(isnum(s)) return tob(s);\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+'){\n\tint tmp = get(s.substr(0,i))+get(s.substr(i+1));\n\tif(tmp > 1023) OVER = true;\n\treturn tmp;\n      }\n      if(p == 0 && s[i] == '-') return get(s.substr(0,i))-get(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*'){\n\tint tmp =  get(s.substr(0,i))*get(s.substr(i+1));\n\tif(tmp > 1023) OVER = true;\n\treturn tmp;\n      }\n    }\n  }\n}\n \nvoid solve(int n){\n \n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n\n    if(isvalid(in)){\n      int num = get(in);\n      if(0 <= num && num < 1024 && !OVER) ans = max(ans,num);\n    }\n  }\n}\n \nint main(){\n \n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n \n  solve(0);\n \n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc();\nint expr();\nint number();\nstring tmp;\nint pos;\nchar c[]=\"()+-*01\";\nint ans=-1;\nbool f=0,ff;\nint calc(){\n  int res=expr();\n  if(tmp[pos]=='*') {pos++;res*=expr();}\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint expr(){\n  int res=number();\n  if(tmp[pos]=='+') {pos++;res+=number();}\n  if(tmp[pos]=='-') {pos++;res-=number();}\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint number(){\n  int res=0;\n  if(tmp[pos]=='(') {\n    pos++;res=calc();pos++;\n  }else{\n    while(pos<(int)tmp.size()&&isdigit(tmp[pos])) res=res*2+tmp[pos]-'0',pos++;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\n\nbool check(string s){\n  int o=0;\n  bool op[100]={};\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') {\n      o++;\n      op[o]=1;\n      if(i+1>=(int)s.size()) return 0;\n      if(!isdigit(s[i+1])) return 0;\n    }    \n    if(s[i]==')') {\n      if(op[o]) return 0;\n      o--;\n      if(i-1<0) return 0;\n      if(!isdigit(s[i-1])) return 0;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*') {\n      op[o]=0;\n      if(i-1<0||i+1>=(int)s.size()) return 0;\n      if((!isdigit(s[i-1])&&s[i-1]!=')')||(!isdigit(s[i+1])&&s[i+1]!='(')) return 0;\n    }\n    if(o<0) return 0;\n  }\n  if(o) return 0;\n  return 1;\n}\nvoid rec(string s){\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]!='.') continue;\n    for(int j=0;j<8;j++){\n      s[i]=c[j];\n      rec(s);\n    }\n    return;\n  }\n  if(!check(s)) return;\n  tmp=s;pos=0;ff=1;\n  int k=calc();\n  if(ff) ans=max(ans,k);\n}\nint main(){\n  string s;\n  cin>>s;\n  rec(s);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Node{\npublic:\n    char ope;\n    string s;\n    Node *left, *right;\n    Node(){\n        ope = '\\0';\n        left = right = NULL;\n    }\n    ~Node(){\n        delete left;\n        delete right;\n    }\n};\n\n// 数式の構文木を作成する\nclass syntacticAnalysis\n{\n    vector<int> binaryPriority;       // 二項演算子の優先順位（数値が小さいほど優先順位が高い。-1ならば二項演算子ではない）\n    vector<bool> binaryAssociativity; // 二項演算子の結合規則（trueならば左から右に結合）\n    vector<bool> isUnaryOpe;          // 単項演算子\n    stack<pair<Node*, bool> > stk;\n    void deleteAllNodes()\n    {\n        while(!stk.empty()){\n            delete stk.top().first;\n            stk.pop();\n        }\n    }\n    bool calc(int maxPriority)\n    {\n        if(!stk.top().second)\n            return false;\n        pair<Node*, bool> right = stk.top();\n        stk.pop();\n        while(stk.top().first != NULL){\n            pair<Node*, bool> ope = stk.top();\n            if(ope.second)\n                break;\n            stk.pop();\n            if(binaryPriority[ope.first->ope] != -1 && stk.top().second){\n                if(binaryPriority[ope.first->ope] > maxPriority ||\n                        binaryPriority[ope.first->ope] == maxPriority && !binaryAssociativity[ope.first->ope]){\n                    stk.push(ope);\n                    break;\n                }\n                ope.first->right = right.first;\n                ope.first->left = stk.top().first;\n                ope.second = true;\n                right = ope;\n                stk.pop();\n            }else if(isUnaryOpe[ope.first->ope]){\n                ope.first->right = right.first;\n                ope.second = true;\n                right = ope;\n            }else{\n                stk.push(ope);\n                break;\n            }\n        }\n        bool ret = (stk.top().first == NULL);\n        stk.push(right);\n        return ret;\n    }\npublic:\n    // binaryOpe : 二項演算子（優先順位の高い順に並べる。secondは結合規則を表し、trueならば左から右に結合）\n    // unaryOpe  : 単項演算子（前置演算子のみ対応）\n    syntacticAnalysis(const vector<pair<string, bool> >& binaryOpe, const string& unaryOpe)\n    {\n        binaryPriority.assign(128, -1);\n        binaryAssociativity.resize(128);\n        isUnaryOpe.assign(128, false);\n        for(unsigned i=0; i<binaryOpe.size(); ++i){\n            for(unsigned j=0; j<binaryOpe[i].first.size(); ++j){\n                binaryPriority[binaryOpe[i].first[j]] = i;\n                binaryAssociativity[binaryOpe[i].first[j]] = binaryOpe[i].second;\n            }\n        }\n        for(unsigned i=0; i<unaryOpe.size(); ++i)\n            isUnaryOpe[unaryOpe[i]] = true;\n    }\n    Node* makeTree(const string& s)\n    {\n        int n = s.size();\n        int i = 0;\n        stk.push(make_pair((Node*)NULL, false));\n        while(i < n){\n            if(s[i] == '('){\n                stk.push(make_pair((Node*)NULL, false));\n                ++ i;\n            }else if(s[i] == ')'){\n                if(!calc(INT_MAX) || stk.size() == 2 || stk.top().first->ope == '\\0'){\n                    deleteAllNodes();\n                    return NULL;\n                }\n                pair<Node*, bool> node = stk.top();\n                stk.pop();\n                stk.pop();\n                stk.push(node);\n                ++ i;\n            }else if(binaryPriority[s[i]] != -1 || isUnaryOpe[s[i]]){\n                calc(binaryPriority[s[i]]);\n                Node* node = new Node;\n                node->ope = s[i];\n                stk.push(make_pair(node, false));\n                ++ i;\n            }else{\n                Node* node = new Node;\n                while(i < n && s[i] != '(' && s[i] != ')' && binaryPriority[s[i]] == -1 && !isUnaryOpe[s[i]]){\n                    node->s += s[i];\n                    ++ i;\n                }\n                stk.push(make_pair(node, true));\n            }\n        }\n\n        if(!calc(INT_MAX) || stk.size() != 2){\n            deleteAllNodes();\n            return NULL;\n        }else{\n            Node* ret = stk.top().first;\n            stk.pop();\n            stk.pop();\n            return ret;\n        }\n    }\n};\n\nint solve(const Node* node)\n{\n    if(node->ope == '\\0'){\n        int ret = 0;\n        for(unsigned i=0; i<node->s.size(); ++i){\n            ret *= 2;\n            if(node->s[i] == '1')\n                ++ ret;\n            if(ret >= 1024)\n                return -1;\n        }\n        return ret;\n    }\n\n    int left = solve(node->left);\n    int right = solve(node->right);\n    if(left == -1 || right == -1)\n        return -1;\n\n    int ret;\n    if(node->ope == '+')\n        ret = solve(node->left) + solve(node->right);\n    else if(node->ope == '-')\n        ret = solve(node->left) - solve(node->right);\n    else\n        ret = solve(node->left) * solve(node->right);\n\n    if(ret < 0 || ret >= 1024)\n        return -1;\n    else\n        return ret;\n}\n\nconst string c = \"01+-*()\";\n\nint main()\n{\n    vector<pair<string, bool> > binaryOpe(2);\n    binaryOpe[0] = make_pair(\"*\", true);\n    binaryOpe[1] = make_pair(\"+-\", true);\n    syntacticAnalysis sa(binaryOpe, \"\");\n\n    string s;\n    cin >> s;\n    int n = s.size();\n\n    int m = 0;\n    vector<int> index;\n    for(int i=0; i<n; ++i){\n        if(s[i] == '.'){\n            index.push_back(i);\n            ++ m;\n        }\n    }\n\n    int ret = -1;\n    if(m == 0){\n        Node* node = sa.makeTree(s);\n        ret = max(ret, solve(node));\n    }else{\n        for(int i=0; ; ++i){\n            int a = i;\n            for(int j=0; j<m; ++j){\n                s[index[j]] = c[a%8];\n                a /= 8;\n            }\n            if(a > 0)\n                break;\n\n            bool ng = false;\n            int j = -1;\n            for(;;){\n                j = s.find(\"((\", j+1);\n                if(j == string::npos)\n                    break;\n                int k = j+2;\n                int bracket = 0;\n                while(k < n){\n                    if(s[k] == '(')\n                        ++ bracket;\n                    else if(s[k] == ')')\n                        -- bracket;\n                    if(bracket == -1)\n                        break;\n                    ++ k;\n                }\n                if(k < n && s.substr(k, 2) == \"))\")\n                    ng = true;\n            }\n            if(ng)\n                continue;\n\n            Node* node = sa.makeTree(s);\n            if(node != NULL)\n                ret = max(ret, solve(node));\n            delete node;\n        }\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\n \n \nll N;\nchar S[111];\n \n#define INF (-(1<<20))\n \nll check(ll x){\n  if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  return INF;\n}\n \n \nll number(ll l,ll r){\n  ll ret = 0;\n  for(ll i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n    ret = check(ret);\n    if( ret < 0 ) return INF;\n  }\n  \n  return ret;\n}\n \n \n \nll check(ll a,ll b,char op){\n  if( 0LL <= a && a < (1LL<<10LL) && 0LL <= b && b < (1LL<<10LL)){ \n    ll x;\n    if( op == '+' )\n      x = a+b;\n    if( op == '-' )\n      x = a-b;\n    if( op == '*' )\n      x = a * b;\n    if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  }\n  return INF;\n}\n \nbool check_n(ll l,ll r){\n  for(ll i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return false;\n  }\n  return true;\n}\nbool check_k2(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt > 0 ) return false;\n  }\n  if( cnt == 0 ) return true;\n  return false;\n}\n \nbool check_k3(ll l,ll r){\n  int cnt = 0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt ++ ;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 &&!( S[i] == '(' || S[i] == ')') ) return true; \n  }\n  return false;\n}\n \n \nbool check_k(ll l,ll r){\n  ll cnt =0;\n  if( l==r ) return false;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n \nbool check_m(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n \nbool check_w(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n \n \nvoid view(ll l,ll r){\n  for(ll i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n \nbool check_h(ll l,ll r){\n  if( S[l] == '+' || S[r] == '+' || S[l] == '-' || S[r] == '-' || S[l] == '*' || S[r] == '*' ||  S[l] == ')' || S[r] == '(' ) return true;\n  if( l > r ) return true;\n  return false;\n}\n \nll exp(ll l,ll r){\n  //view(l,r);\n  if( check_h(l,r) ) return INF;\n  if( !check_k2(l,r) ) return INF;\n  if( check_k(l,r) ) {\n    if( check_n(l+1,r-1) ) return INF;\n    if( !check_k3(l+1,r-1) ) return INF;\n    return check(exp(l+1,r-1));\n  }\n  if( check_w(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return check(exp(l,i-1), exp(i+1,r),'+');\n      if( cnt == 0 && S[i] == '-' ) return check(exp(l,i-1), exp(i+1,r),'-');\n    }\n  }\n  if( check_m(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return check(exp(l,i-1), exp(i+1,r),'*');\n    }\n  }\n  if( check_n(l,r) )\n    return check(number(l,r));\n  return INF;\n}\n \nint main(){\n  cin >> S;\n  N  = strlen(S);\n  ll M = 0;\n  for(ll i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  ll res = -1;\n  ll K=1;\n  for(ll i=0;i<M;i++) K*=7;\n  for(ll i=0;i<K;i++){\n    ll c = i;\n    strcpy( S, buf );\n    for(ll j=0;j<N;j++){\n      if( S[j] == '.' ){\n    if( c%7 == 0 ) S[j] = '0';\n    if( c%7 == 1 ) S[j] = '1';\n    if( c%7 == 2 ) S[j] = '+';\n    if( c%7 == 3 ) S[j] = '-';\n    if( c%7 == 4 ) S[j] = '*';\n    if( c%7 == 5 ) S[j] = '(';\n    if( c%7 == 6 ) S[j] = ')';      \n    c/=7;\n      }    \n    }\n    \n    res = max( res, exp(0,N-1) );\n     \n  }\n  cout << res << endl;\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef string::iterator State;\nclass ParseError {};\nint op_cnt;\n\nint ParseExpression(State &itr);\n\nint ParseNumber(State &itr) {\n  int ret = 0;\n  if (*itr != '0' && *itr != '1') throw ParseError();\n\n  while (*itr == '0' || *itr == '1') {\n    ret = ret*2 + (*itr-'0');\n    if (ret >= 1024) throw ParseError();\n    itr++;\n  }\n  return ret;\n}\n\nint ParseFactor(State &itr) {\n  if (*itr == '(') {\n    itr++;\n    int op_cnt_ = op_cnt;\n    int ret = ParseExpression(itr);\n    if (op_cnt_ == op_cnt) throw ParseError();\n    if (*itr != ')') throw ParseError();\n    itr++;\n    return ret;\n  }\n  \n  //op_cnt++;\n  return ParseNumber(itr);\n}\n\nint ParseTerm(State &itr) {\n  int ret = ParseFactor(itr);\n  \n  while (1) {\n    if (*itr == '*') {\n      itr++;\n      ret *= ParseFactor(itr);\n      if (ret >= 1024) throw ParseError();\n      op_cnt++;\n    } else break;\n  }\n\n  return ret;\n}\n\nint ParseExpression(State &itr) {\n  int ret = ParseTerm(itr);\n  while (1) {\n    if (*itr == '+') {\n      itr++;\n      ret += ParseTerm(itr);\n      if (ret >= 1024) throw ParseError();\n      op_cnt++;\n    } else if (*itr == '-' ) {\n      itr++;\n      ret -= ParseTerm(itr);\n      if (ret < 0) throw ParseError();\n      op_cnt++;\n    } else break;\n  }\n  return ret;\n}\n\nint n;\nint ans = -1;\nchar cs[] = \"01+-*().\";\nchar buf[114514];\nstring s;\nvector<int> pos;\n\nvoid rec(int idx) {\n  if (n <= idx) {\n    auto itr = s.begin();\n    try {\n      int ret = ParseExpression(itr);\n      if (itr != s.end()) throw ParseError();\n      ans = max(ans, ret);\n    } catch (const ParseError &e) {}\n    return;\n  }\n\n  for (int i=0; i<8; i++) {\n    s[pos[idx]] = cs[i];\n    rec(idx+1);\n  }\n}\n\nint main() {\n  scanf(\"%s\", buf);\n  s = buf;\n  while (1) {\n    int idx = s.find('.');\n    if (idx == string::npos) break;\n    pos.emplace_back(idx);\n    s[idx] = '$';\n    n++;\n  }\n\n  ans = -1;\n  rec(0);\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\n\nusing ll = long long;\nusing pll = pair<ll, ll>;\n \nconstexpr ll M = 1e9+7;\n\nconst string w = \"01+-*()\";\n\nconstexpr int mi = 0;\nconstexpr int ma = 1023;\n\nbool isrange(int n) {\n    return mi <= n && n <= ma;\n}\n\nint expr(string const& s, int& p);\nint term(string const& s, int& p);\nint factor(string const& s, int& p);\nint number(string const& s, int& p);\n\nint expr(string const& s, int& p) {\n    int res = term(s, p);\n    while(p < s.size() && (s[p] == '+' || s[p] == '-')) {\n        if(s[p] == '+') {\n            res += term(s, ++p);\n        } else if(s[p] == '-') {\n            res -= term(s, ++p);\n        }\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    }\n    return res;\n}\n\nint term(string const& s, int& p) {\n    int res = factor(s, p);\n    while(p < s.size() && s[p] == '*') {\n        res *= factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    }\n    return res;\n}\n\nint factor(string const& s, int& p) {\n    if(isdigit(s[p])) {\n        return number(s, p);\n    }\n    if(s[p] == '-') {\n        int res = -factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n        return res;\n    } else if(s[p] == '(') {\n        int res = expr(s, ++p);\n        if(p < s.size() && s[p] != ')') {\n            throw runtime_error(\"\");\n        }\n        ++p;\n        return res;\n    } else {\n        throw runtime_error(\"\");\n    }\n}\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(p < s.size() && isdigit(s[p])) {\n        res <<= 1;\n        res |= s[p] == '1';\n        ++p;\n    }\n    if(!isrange(res)) {\n        throw runtime_error(\"\");\n    }\n    return res;\n}\n\nbool check(string const& s) {\n    stack<int> st;\n    vector<vector<bool>> par(s.size(), vector<bool>(s.size()));\n    bool ok = true;\n    for(int i=0; i<s.size(); ++i) {\n        if(s[i] == '(') {\n            st.push(i);\n        }\n        if(s[i] == ')') {\n            if(st.empty()) {\n                ok = false;\n                break;\n            }\n            if(s[st.top()+1] == '(' && s[i-1] == ')' && par[st.top()+1][i-1]) {\n                ok = false;\n                break;\n            }\n            par[st.top()][i] = true;\n            bool f = false;\n            for(int j=st.top()+1; j<i; ++j) {\n                f |= !isdigit(s[j]);\n            }\n            st.pop();\n            ok &= f;\n        }\n    }\n    return st.empty() && ok;\n}\n\nint solve(int i, string& s, vector<int> const& lost) {\n    int res = -1;\n    if(i == lost.size()) {\n        try {\n            int p = 0;\n            if(check(s)) {\n                res = expr(s, p);\n            }\n            return (p == s.size() ? res : -1);\n        } catch(...) {\n            return -1;\n        }\n    }\n    for(int j=0; j<w.size(); ++j) {\n        s[lost[i]] = w[j];\n        res = max(res, solve(i+1, s, lost));\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    vector<int> pos;\n    for(int i=0; i<s.size(); ++i) {\n        if(s[i] == '.') {\n            pos.push_back(i);\n        }\n    }\n    cout << solve(0, s, pos) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\npi expr(), term();\nstring s;\nint p;\npi digit(){\n\tint d = 0;\n\twhile(p < s.size() && isdigit(s[p])){\n\t\td *= 2; d += s[p++] - '0';\n\t\tif(d >= 1 << 10) throw \"bigdigit\";\n\t}\n\treturn mp(d, 0);\n}\npi expr(){\n\tpi a = term();\n\twhile(p < s.size() && (s[p] == '+' || s[p] == '-')){\n\t\tbool pr = s[p++] == '+';\n\t\tpi b = term();\n\t\ta.first = a.first + (pr ? b.first : -b.first);\n\t\ta.second = 1;\n\t\tif(a.first < 0 || a.first >= 1 << 10) throw \"overflow\";\n\t}\n\treturn a;\n}\npi term(){\n\tpi a = mp(1, 0);\n\tint fac = 0;\n\tp--;\n\tdo{\n\t\tif(++p >= s.size()) throw \"syntaxerorr\";\n\t\t\n\t\tpi b;\n\t\tif(isdigit(s[p])) b = digit();\n\t\telse if(s[p] == '('){\n\t\t\tp++;\n\t\t\tb = expr();\n\t\t\tif(!b.second) throw \"(())\";\n\t\t\tif(s[p++] != ')') throw \"closep\";\n\t\t}\n\t\ta.first *= b.first;\n\t\tfac++;\n\t}while(p < s.size() && s[p] == '*');\n\treturn mp(a.first, fac > 1);\n}\n\nint main(){\n\tcin >> s;\n\tvi v;\n\trep(i, s.size()) if(s[i] == '.') v.pb(i);\n\tint pw[10], ans = -1;\n\tpw[0] = 1;\n\trep(i, 9) pw[i + 1] = pw[i] * 7;\n\t\n\trep(i, pw[v.size()]){\n\t\trep(j, v.size()) s[v[j]] = \"01+-*()\"[i / pw[j] % 7];\n\t\tp = 0;\n\t\ttry{\n\t\t\tpi res = expr();\n\t\t\tif(p < s.size()) throw \"syntaxerror\";\n\t\t\tans = max(ans, res.first);\n\t\t}catch(const char *e){\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool err;\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else {\n\t\treturn number(s);\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\twhile (s[p] == '+' || s[p] == '-') {\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += expression(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= expression(s);\n\t\t}\n\t}\n\t\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\treturn res;\n}\n\nbool check(string s)\n{\n\tvector<int> ope;\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tope.push_back(0);\n\t\t} else if (s[i]==')') {\n\t\t\tif (d<0 || !ope[d]) return false;\n\t\t\tope.erase(ope.begin()+d);\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), 0);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>=1024) res=-1;\n\t\t\n\t\t//cerr << \"Persing : \" << s << endl;\n\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <stack>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef string::const_iterator State;\nint expr(State &be);\nint num(State &be){\n\tif(!isdigit(*be)) return -1;\n\tint ret=0;\n\twhile(isdigit(*be)){\n\t\tret*=2;\n\t\tret+=(*be-'0');\n\t\tbe++;\n\t}\n\treturn ret;\n}\nint factor(State& be){\n\tint ret;\n\tif(*be=='('){\n\t\tbe++;\n\t\tret=expr(be);\n\t\tif(*be!=')') return -1;\n\t\tbe++;\n\t\treturn ret;\n/*\t\tcout << ret << endl;\n\t\tif(ret==-1) return -1;\n\t\tint k=-1;\n\t\tcout << *be << endl;\n\t\tif(*be=='+') k=0;\n\t\tif(*be=='-') k=1;\n\t\tif(*be=='*') k=2;\n\t\tif(k==-1) return -1;\n\t\tbe++;\n\t\tint ret1=expr(be);\n\t\tif(ret1==-1) return -1;\n\t\tbe++;\n\t\tif(k==0) return ret+ret1;\n\t\tif(k==1) return max(-1,ret-ret1);\n\t\tif(k==2) return ret*ret1;\n\t\tcout << \"hoge\";*/\n\t}\n\treturn num(be);\n}\nint term(State& be){\n\tint ret=factor(be);\n\tif(ret==-1) return -1;\n\twhile(*be=='*'){\n\t\tbe++;\n\t\tret*=factor(be);\n\t\tif(ret<0) return -1;\n\t}\n\treturn ret;\n}\nint expr(State& be){\n\tint ret=term(be);\n\tif(ret==-1) return ret;\n\twhile(true){\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret+=a;\n\t\t}else if(*be=='-'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret-=a;\n\t\t}else break;\n\t}\n\treturn ret;\n}\nint main(){\n\tstring s,ch=\"01+-*()\";\n\tvector<int> vc;\n\tcin >> s;\n\tState be=s.begin();\n\trep(i,s.size()) if(s[i]=='.') vc.push_back(i);\n\tint n=vc.size(),p7=1,ans=-1;\n\trep(i,n) p7*=7;\n\trep(i,p7){\n\t\tstring t=s;\n\t\tint tmp=i;\n\t\trep(j,n){\n\t\t\tt[vc[j]]=ch[tmp%7];\n\t\t\ttmp/=7;\n\t\t}\n\t\tstack<int> id;\n\t\tint cal[101]={};\n\t\tbool ok=true;\n\t\trep(i,t.size()){\n\t\t\tif(t[i]=='('){\n\t\t\t\tid.push(i);\n\t\t\t\tcal[i]=-1;\n\t\t\t}\n\t\t\tif(t[i]==')'){\n\t\t\t\tif(id.empty()){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tid.pop();\n\t\t\t}\n\t\t\tif(t[i]=='+' || t[i]=='-' || t[i]=='*'){\n\t\t\t\tif(!id.empty()) cal[id.top()]++;\n\t\t\t}\n\t\t}\n\t\trep(i,t.size()) if(cal[i]<0) ok=false;\n\t\tif(!ok) continue;\n\t\tState be=t.begin();\n\t\tans=max(ans,expr(be));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <stack>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef string::const_iterator State;\nint expr(State &be);\nint num(State &be){\n\tif(!isdigit(*be)) return -1;\n\tint ret=0;\n\twhile(isdigit(*be)){\n\t\tret*=2;\n\t\tret+=(*be-'0');\n\t\tbe++;\n\t}\n\treturn ret;\n}\nint factor(State& be){\n\tint ret;\n\tif(*be=='('){\n\t\tbe++;\n\t\tret=expr(be);\n\t\tif(*be!=')') return -1;\n\t\tbe++;\n\t\treturn ret;\n/*\t\tcout << ret << endl;\n\t\tif(ret==-1) return -1;\n\t\tint k=-1;\n\t\tcout << *be << endl;\n\t\tif(*be=='+') k=0;\n\t\tif(*be=='-') k=1;\n\t\tif(*be=='*') k=2;\n\t\tif(k==-1) return -1;\n\t\tbe++;\n\t\tint ret1=expr(be);\n\t\tif(ret1==-1) return -1;\n\t\tbe++;\n\t\tif(k==0) return ret+ret1;\n\t\tif(k==1) return max(-1,ret-ret1);\n\t\tif(k==2) return ret*ret1;\n\t\tcout << \"hoge\";*/\n\t}\n\treturn num(be);\n}\nint term(State& be){\n\tint ret=factor(be);\n\tif(ret==-1) return -1;\n\twhile(*be=='*'){\n\t\tbe++;\n\t\tret*=factor(be);\n\t\tif(ret<0) return -1;\n\t}\n\treturn ret;\n}\nint expr(State& be){\n\tint ret=term(be);\n\tif(ret==-1) return ret;\n\twhile(true){\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret+=a;\n\t\t}else if(*be=='-'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<0) return -1;\n\t\t}else break;\n\t}\n\treturn ret;\n}\nint main(){\n\tstring s,ch=\"01+-*()\";\n\tvector<int> vc;\n\tcin >> s;\n\tState be=s.begin();\n\trep(i,s.size()) if(s[i]=='.') vc.push_back(i);\n\tint n=vc.size(),p7=1,ans=-1;\n\trep(i,n) p7*=7;\n\trep(i,p7){\n\t\tstring t=s;\n\t\tint tmp=i;\n\t\trep(j,n){\n\t\t\tt[vc[j]]=ch[tmp%7];\n\t\t\ttmp/=7;\n\t\t}\n\t\tstack<int> id;\n\t\tint cal[101]={};\n\t\tbool ok=true;\n\t\trep(i,t.size()){\n\t\t\tif(t[i]=='('){\n\t\t\t\tid.push(i);\n\t\t\t\tcal[i]=-1;\n\t\t\t}\n\t\t\tif(t[i]==')'){\n\t\t\t\tif(id.empty()){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tid.pop();\n\t\t\t}\n\t\t\tif(t[i]=='+' || t[i]=='-' || t[i]=='*'){\n\t\t\t\tif(!id.empty()) cal[id.top()]++;\n\t\t\t}\n\t\t}\n\t\trep(i,t.size()) if(cal[i]<0) ok=false;\n\t\tif(!ok) continue;\n\t\tState be=t.begin();\n\t\tans=max(ans,expr(be));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 9999999\n\n\nvector<string> toRPN(string s){\n    stack<string> ope;\n    vector<string> ret;\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ){\n            string tmp=\"\";\n            for(int j=i;j<len;j++){\n                if( isdigit(s[j]) )tmp+=s[j];\n                else break;\n            }\n            ret.push_back(tmp);\n            i+=tmp.size()-1;\n            \n        }else{\n            if( s[i]=='(' )ope.push(\"(\");\n            \n            else if( s[i]==')' ){\n                if( ope.empty() )return {\"invalid\"};\n                if( ope.top()==\"(\" )return {\"invalid\"};\n                \n                while( ope.top()!=\"(\" ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                    \n                    if( ope.empty() )return {\"invalid\"};\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" || ope.top()==\"+\" || ope.top()==\"-\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n            }\n        }\n    }\n    while( ope.size() ){\n        ret.push_back( ope.top() );\n        ope.pop();\n    }\n    \n    return ret;\n}\n\n\nint toDeci(string s){\n    int ret=0;\n    for(int i=0;i<s.size();i++){\n        if( s[ s.size()-i-1 ]=='1' ){\n            ret+=1<<i;\n        }\n        if(ret>=1024)return 9999;\n    }\n    return ret;\n}\n\n\n\nint solveRPN(vector<string> s){\n    stack<int> stk;\n    \n    \n    for(int i=0;i<s.size();i++){\n        if( (s[i]!=\"+\" && s[i]!=\"-\" && s[i]!=\"*\" && s[i]!=\"/\") )stk.push( toDeci(s[i])  );\n        else{\n            if(stk.size()<2)return -1;\n\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            if(s[i]==\"+\")stk.push(a+b);\n            if(s[i]==\"-\")stk.push(a-b);\n            if(s[i]==\"*\")stk.push(a*b);\n            if(s[i]==\"/\")stk.push(a/b);\n        }\n        if( stk.top() <0 || 1024<=stk.top() )return -1;\n    }\n    \n    if( stk.size()>1 )return -1;\n    return stk.top();\n}\n\n\nvi dot;\nint maxi=-INF;\n\n\nint solve(string s){\n    vector<string> poland=toRPN(s);\n    \n    if(poland[0]==\"invalid\")return -INF;\n    \n    int result=solveRPN(poland);\n    \n    if(result==-1)return -INF;\n    else return result;\n}\n\n\nvoid dfs(string s,int flor){\n    if(flor>=dot.size()){\n        cout<<s<<endl;\n        maxi=max( maxi , solve(s) );\n        return ;\n    }\n    \n    char ch[]={'0','1','+','-','*','(',')'};\n    rep(i,6){\n        s[ dot[flor] ] = ch[i];\n        dfs(s,flor+1);\n        s[ dot[flor] ] = '.';\n    }\n}\n\n\nint main(){\n    string s;\n    cin>>s;\n    \n    rep(i,s.size()) if(s[i]=='.')dot.pb(i);\n    \n    dfs(s,0);\n    \n    if( maxi==-INF )cout<<\"-1\"<<endl;\n    else cout<<maxi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint p,len,flg;\n\nint calc();\n\nint getNum(){\n  if(flg)return 0;\n  \n  if(s[p]=='('){\n    p++;\n    int res=calc();\n    if(s[p]!=')')flg=1;\n    p++;\n    return res;\n  }else if('0'<=s[p]&&s[p]<='1'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='1'){\n      res=res*2+(s[p]-'0');\n      if(res>=1024){\n        flg=1;\n        return 0;\n      }\n      p++;\n    }\n    return res;\n  }else{\n    flg=1;\n    return 0;\n  }\n}\n\nint calc(){\n  int cnt=0;\n  int res=0;\n  int num=getNum();\n  while(p<len){\n    if(flg)return 0;\n    \n    char ch=s[p++];\n    if(ch=='+'){\n      res+=num;\n      num=getNum();\n      if(res<0||1024<=res)flg=1;\n    }else if(ch=='-'){\n      res+=num;\n      num=-getNum();\n      if(res<0||1024<=res)flg=1;\n    }else if(ch=='*'){\n      num*=getNum();\n      if(1024<=num)flg=1;\n    }else if(ch==')'){\n      p--;\n      if(cnt==0)flg=1;\n      break;\n    }else{\n      flg=1;\n    }\n    cnt++;\n  }\n  res+=num;\n  if(res<0||res>=1024)flg=1;\n  return res;\n}\n\nstring tmp=\"01+-*()\";\n\nstring str;\nint ans;\n\nvoid dfs(int pos){\n  if((int)str.size()==pos){\n    s=str;\n    len=str.size();\n    p=flg=0;\n    int k=calc();\n    if(flg==0&&p==(int)s.size())ans=max(ans,k);\n    return;\n  }\n\n  if(str[pos]=='.'){\n    for(int i=0;i<(int)tmp.size();i++){\n      str[pos]=tmp[i];\n      dfs(pos+1);\n      str[pos]='.';\n    }\n  }else{\n    dfs(pos+1);\n  }\n}\n\nint main(){\n  cin>>str;\n  ans=-1;\n  dfs(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    int N;\n    void input() {\n        cin >> s;\n        N = s.size();\n    }\n\n    int valid(int x) {\n        return 0 <= x && x < 1024;\n    }\n\n    int number(int& index) {\n        int x = 0;\n        while (isdigit(s[index])) {\n            int c = s[index] - '0';\n            x = x * 2 + c;\n            index++;\n        }\n        return x;\n    }\n    int oper(int x, int y, char op) {\n        int ret = 0;\n        if (op == '+') {\n            ret = x + y;\n        } else if (op == '-') {\n            ret = x - y;\n        } else if (op == '*') {\n            ret = x * y;\n        } else {\n            return -1;\n        }\n        if (not valid(ret)) return -1;\n        return ret;\n    }\n    int expr(int& index, bool flag = false) {\n        if (isdigit(s[index])) {\n            int x = number(index);\n            if (index == N || (!flag && s[index] == ')')) return x;\n            if (not valid(x)) return -1;\n            char op = s[index]; index++;\n            int y = expr(index);\n            if (not valid(y)) return -1;\n            /*\n            cout << \"x: \" << x << endl;\n            cout << \"y: \" << y << endl;\n            cout << \"op: \" << op << endl;\n            cout << \"res: \" << oper(x, y, op) << endl;\n            */\n            return oper(x, y, op);\n        }\n        if (s[index] == '(') {\n            index++;\n            int ret = expr(index, true);\n            if (s[index] != ')') return -1;\n            index++;\n            return ret;\n        }\n        return -1;\n    }\n\n    int calc(int index) {\n        const string C = \"01+-*()\";\n        if (index == N) {\n            int i = 0;\n            //cout << s << \" -> \" << expr(i) << endl;\n            i = 0;\n            return expr(i);\n        }\n        if (s[index] == '.') {\n            int ret = -1;\n            for (int i = 0; i < C.size(); i++) {\n                s[index] = C[i];\n                ret = max(ret, calc(index + 1));\n            }\n            s[index] = '.';\n            return ret;\n        } else {\n            return calc(index + 1);\n        }\n    }\n\n    void solve() {\n        cout << calc(0) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 110;\nconstexpr int INF = (1 << 14);\n\nint N;\nstring s;\n\nbool is_num(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (!isdigit(s[i])) return 0;\n    }\n    return 1;\n}\n\nint num(int L, int R)\n{\n    int res = 0;\n    for (int i = R; i >= L; i--) {\n        if (R - L > 10 && s[i] == '1') return -INF;                   \n        res *= 2;\n        res += (s[i] - '0');\n    }\n    return res;\n}\n\nbool is_op(char c)\n{\n    return (c == '+' || c == '-' || c == '*');\n}\n\nbool check_op(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (is_op(s[i])) return 1;\n    }\n    return 0;\n}\n\nint mem[MAX][MAX];\n\nint expr(int L, int R)\n{\n    int& res = mem[L][R];\n    if (res != -1) return res;\n    \n    if (is_num(L, R)) return num(L, R);\n    \n    if (s[L] == '(' && s[R] == ')') {\n        if (check_op(L, R)) {\n            return expr(L + 1, R - 1);\n        } else {\n            return -1;\n        }\n    }\n    for (int i = L + 1; i <= R - 1; i++) {\n        if (!is_op(s[i])) continue;\n        int v = -1;\n        switch (s[i]) {            \n            case '+':\n                v = expr(L, i - 1) + expr(i + 1, R);\n                break;\n            case '-':\n                v = expr(L, i - 1) - expr(i + 1, R);\n                break;\n            case '*':\n                v = expr(L, i - 1) * expr(i + 1, R);\n                break;\n        }\n        if (v < 0 || v > (1 << 10)) continue;\n        res = max(res, v);\n    }\n    return res;\n}\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid()\n{\n    int p = 0;\n    for (int i = 0; i < N; i++) {\n        if (is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n    }\n    return (p == 0);\n}\n\nint solve()\n{\n    N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        memset(mem, -1, sizeof(mem));\n        return expr(0, N - 1);\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        memset(mem, -1, sizeof(mem));\n        if (valid()) {\n            res = max(res, expr(0, N - 1));\n        }            \n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    cin >> s;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc();\nint expr();\nint number();\nstring tmp;\nint pos;\nchar c[]=\"()+-*01\";\nint ans=-1;\nbool f=0,ff;\nint calc(){\n  int res=expr();\n  while(1){\n    if(tmp[pos]=='*') {pos++;res*=expr();}\n    else break;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint expr(){\n  int res=number();\n  while(1){\n    if(tmp[pos]=='+') {pos++;res+=number();}\n    else if(tmp[pos]=='-') {pos++;res-=number();}\n    else break;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint number(){\n  int res=0;\n  if(tmp[pos]=='(') {\n    pos++;res=calc();pos++;\n  }else{\n    while(pos<(int)tmp.size()&&isdigit(tmp[pos])) res=res*2+tmp[pos]-'0',pos++;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\n \nbool check(string s){\n  int o=0;\n  bool op[100]={};\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') {\n      o++;\n      op[o]=1;\n      if(i+1>=(int)s.size()) return 0;\n      if(!isdigit(s[i+1])&&s[i+1]!='(') return 0;\n    }    \n    if(s[i]==')') {\n      if(op[o]) return 0;\n      o--;\n      if(i-1<0) return 0;\n      if(!isdigit(s[i-1])&&s[i-1]!=')') return 0;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*') {\n      for(int k=0;k<=o;k++) op[k]=0;\n      if(i-1<0||i+1>=(int)s.size()) return 0;\n      if((!isdigit(s[i-1])&&s[i-1]!=')')||(!isdigit(s[i+1])&&s[i+1]!='(')) return 0;\n    }\n    if(o<0) return 0;\n  }\n  if(o) return 0;\n  return 1;\n}\nvoid rec(string s){\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]!='.') continue;\n    for(int j=0;j<8;j++){\n      s[i]=c[j];\n      rec(s);\n    }\n    return;\n  }\n  if(!check(s)) return;\n  tmp=s;pos=0;ff=1;\n  int k=calc();\n  if(ff) ans=max(ans,k);//,cout<<k<<\":\"<<tmp<<endl;\n}\nint main(){\n  string s;\n  cin>>s;\n  rec(s);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool err;\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else {\n\t\treturn number(s);\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\twhile (s[p] == '+' || s[p] == '-') {\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += expression(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= expression(s);\n\t\t}\n\t}\n\t\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\treturn res;\n}\n\nbool check(string s)\n{\n\tvector<int> ope;\n\t\n\tif (s[N-1]=='+' || s[N-1]=='-' || s[N-1]=='*' || s[N-1]=='(')\n\t\treturn false;\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tope.push_back(0);\n\t\t} else if (s[i]==')') {\n\t\t\tif (d<0 || !ope[d]) return false;\n\t\t\tope.erase(ope.begin()+d);\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), 0);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>=1024) res=-1;\n\t\t\n\t\t//cerr << \"Persing : \" << s << endl;\n\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstring alp = \"01+-*()\";\nvoid search(int cnt, string &curr, vector<string> &res){\n    if(cnt == 0){\n        res.push_back(curr);\n        return;\n    }\n    for(char c: alp){\n        curr += c;\n        search(cnt-1, curr, res);\n        curr.pop_back();\n    }\n}\n\nbool is_operator(char c){\n    return c=='+' or c=='-' or c=='*';\n}\n\nint parse(int b, int e, string &s){\n    vector<int> nums;\n    vector<char> opes;\n    enum type{num, ope, brac};\n    type prevtype = ope;\n    int currnum = 0;\n    for(int p=b; p<e; p++){\n        if(prevtype == ope and is_operator(s[p])) return -1;\n        if(prevtype == brac and !is_operator(s[p])) return -1;\n        if(s[p] == ')') return -1;\n        if(prevtype != ope and s[p] == '(') return -1;\n        \n        if(is_operator(s[p])){\n            nums.push_back(currnum);\n            opes.push_back(s[p]);\n            currnum = 0;\n            prevtype = ope;\n        }else if(s[p] == '('){\n            int depth = 1;\n            int beginpos = ++p;\n            while(p < e){\n                if(s[p]=='(') depth++;\n                if(s[p]==')') depth--;\n                if(depth==0) break;\n                p++;\n            }\n            if(p==e and depth>0) return -1;\n            currnum = parse(beginpos, p, s);\n            if(currnum == -1) return -1;\n            prevtype = brac;\n        }else{\n            currnum *= 2;\n            currnum += s[p]-'0';\n            if(currnum >= 1024) return -1;\n            prevtype = num;\n        }\n    }\n    if(prevtype == ope) return -1;\n    nums.push_back(currnum);\n\n    if(b == e) return -1;\n    if((b!=0 or e!=(int)s.length()) and opes.empty()) return -1;\n    vector<int> newnums;\n    vector<int> newopes;\n    newnums.push_back(nums[0]);\n    for(int i=0; i<(int)opes.size(); i++){\n        if(opes[i] == '*'){\n            newnums.back() *= nums[i+1];\n            if(newnums.back() >= 1024) return -1;\n        }else{\n            newopes.push_back(opes[i]);\n            newnums.push_back(nums[i+1]);\n        }\n    }\n    int res = newnums[0];\n    for(int i=0; i<(int)newopes.size(); i++){\n        if(newopes[i] == '+'){\n            res += newnums[i+1];\n        }else{\n            res -= newnums[i+1];\n        }\n        if(res<0 or 1024<=res) return -1;\n    }\n    return res;\n}\n\nint main(){\n    string s;\n    cin >> s;\n    vector<int> dots_idx;\n    for(int i=0; i<(int)s.length(); i++){\n        if(s[i] == '.') dots_idx.push_back(i);\n    }\n\n    vector<string> filling;\n    string tmp = \"\";\n    search(dots_idx.size(), tmp, filling);\n    int ans = -1;\n    for(string fil: filling){\n        for(int i=0; i<(int)dots_idx.size(); i++){\n            s[dots_idx[i]] = fil[i];\n        }\n        ans = max(ans, parse(0, s.length(), s));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\nll N;\nchar S[111];\n\n#define INF (-(1<<20))\n\nll number(ll l,ll r){\n  ll ret = 0;\n  for(ll i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n  }\n \n  return ret;\n}\n\n\nll check(ll x){\n  if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  return INF;\n}\n\nll check(ll a,ll b,char op){\n  if( 0LL <= a && a < (1LL<<10LL) && 0LL <= b && b < (1LL<<10LL)){ \n    ll x;\n    if( op == '+' )\n      x = a+b;\n    if( op == '-' )\n      x = a-b;\n    if( op == '*' )\n      x = a * b;\n    if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  }\n  return INF;\n}\n\nbool check_n(ll l,ll r){\n  for(ll i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return false;\n  }\n  return true;\n}\nbool check_k2(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt > 0 ) return false;\n  }\n  if( cnt == 0 ) return true;\n  return false;\n}\n\n\nbool check_k(ll l,ll r){\n  ll cnt =0;\n  if( l==r ) return false;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n\nbool check_m(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n\nbool check_w(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n\n\nvoid view(ll l,ll r){\n  for(ll i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n\nbool check_h(ll l,ll r){\n  if( S[l] == '+' || S[r] == '+' || S[l] == '-' || S[r] == '-' || S[l] == '*' || S[r] == '*' ||  S[l] == ')' || S[r] == '(' ) return true;\n  if( l > r ) return true;\n  return false;\n}\n\nll exp(ll l,ll r){\n  //view(l,r);\n  if( check_h(l,r) ) return INF;\n  if( !check_k2(l,r) ) return INF;\n  if( check_k(l,r) ) {\n    if( check_n(l+1,r-1) ) return INF;\n    return check(exp(l+1,r-1));\n  }\n  if( check_w(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return check(exp(l,i-1), exp(i+1,r),'+');\n      if( cnt == 0 && S[i] == '-' ) return check(exp(l,i-1), exp(i+1,r),'-');\n    }\n  }\n  if( check_m(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return check(exp(l,i-1), exp(i+1,r),'*');\n    }\n  }\n  if( check_n(l,r) )\n    return check(number(l,r));\n  return INF;\n}\n\nint main(){\n  cin >> S;\n  N  = strlen(S);\n  ll M = 0;\n  for(ll i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  ll res = -1;\n  ll K=1;\n  for(ll i=0;i<M;i++) K*=7;\n  bool f = false;\n  for(ll i=0;i<K;i++){\n    ll c = i;\n    strcpy( S, buf );\n    for(ll j=0;j<N;j++){\n      if( S[j] == '.' ){\n\tif( c%7 == 0 ) S[j] = '0';\n\tif( c%7 == 1 ) S[j] = '1';\n\tif( c%7 == 2 ) S[j] = '+';\n\tif( c%7 == 3 ) S[j] = '-';\n\tif( c%7 == 4 ) S[j] = '*';\n\tif( c%7 == 5 ) S[j] = '(';\n\tif( c%7 == 6 ) S[j] = ')';\t\t\n\tc/=7;\n      }    \n    }\n   \n    res = max( res, exp(0,N-1) );\n    \n  }\n  cout << res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar s[1010];\n\nint number(int &i) {\n  ll a = 0;\n  while(isdigit(s[i])) {\n    a = a*2 + (s[i]-'0');\n    if (a >= 1024) throw 0;\n    i++;\n  }\n  return a;\n}\n\nbool op_exp(int &i);\n\nvoid check_exp(int &i, bool f) {\n  //cout << s[i] << \" \" << f << endl;\n  if (isdigit(s[i])) {\n    number(i);\n    bool r = op_exp(i);\n    if (f && !r) throw 0;       // 括弧で囲まれてるのにopがない\n  } else if (s[i] == '(') {\n    i++;\n    check_exp(i,1);\n    if (s[i] != ')') throw 0;\n    i++;\n    bool r = op_exp(i);\n    if (f && !r) throw 0;\n  } else {\n    throw 0;\n  }\n}\n\nbool op_exp(int &i) {\n  if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n    i++;\n    check_exp(i,0);\n    return 1;\n  }\n  return 0;\n}\n\nint term(int &i);\nint fact(int &i);\n\nint exp(int &i) {\n  int p = term(i);\n  while(s[i]=='+' || s[i]=='-') {\n    char c = s[i++];\n    if (c == '+') {\n      int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n    if (p>=1024 || p<0) throw 0;\n  }\n  return p;\n}\n\nint term(int &i) {\n  int p = fact(i);\n  while(s[i]=='*') {\n    i++;\n    p *= fact(i);\n    if (p>=1024 || p<0) throw 0;\n  }\n  return p;\n}\n\nint fact(int &i) {\n  if (s[i] == '(') {\n    i++;\n    int p = exp(i);\n    assert(s[i++]==')');\n    return p;\n  } else {\n    return number(i);\n  }\n}\n\nvector<int> v;\n\nint rec(int now) {\n  if (now == -1) {\n    //cout << s << endl;\n    try {\n      int i = 0;\n      check_exp(i,0);\n      if (s[i]) throw 0;\n      i = 0;\n      int res = exp(i);\n      //cout << res << endl;\n      return res;\n    } catch(int a) {\n      return -1;\n    }\n  }\n  int ma = -1;\n  static const string hoge = \"01+-*()\";\n  FOR(it, hoge) {\n    s[v[now]] = *it;\n    ma = max(ma, rec(now-1));\n  }\n  return ma;\n}\n\nint main() {\n  while(cin >> s) {\n    v.clear();\n    REP(i,strlen(s)) {\n      if (s[i] == '.') v.push_back(i);\n    }\n    cout << rec(v.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nchar ln[7]={'0','1','+','-','*','(',')'};\nint n=0,ans=-1;\nint p[5]={};\nint ind[5]={};\nstring s,t;\nmap<int,int> mp;\n\nstring f(string a){\n  if(a==\"+\" || a==\"-\" || a==\"*\" || a==\"(\" || a==\")\")return a;\n  reverse(a.begin(),a.end());\n  int res=0;\n  for(int i=0;i<a.length();i++)res+=(pow(2,i)*(a[i]-'0'));\n  ostringstream os;\n  os<<res;\n  return os.str();\n}\n\nint cal(vector<string> v){\n  if(v.empty())return -1;\n  vector<string> vs1,vs2,vs3;\n  for(int i=0;i<v.size();i++){\n    if(v[i]==\"(\"){\n      vector<string> tmp;\n      int l=1,r=0;\n      for(int j=i+1;j<v.size();j++){\n\tif(v[j]==\"(\")l++;\n\tif(v[j]==\")\")r++;\n\tif(r==l){\n\t  i=j;\n\t  break;\n\t}\n\ttmp.push_back(v[j]);\n      }\n      int res=cal(tmp);\n      if(res==-1 || 1024<=res)return -1;\n      ostringstream os;\n      os<<res;\n      vs1.push_back(os.str());\n    }\n    else vs1.push_back(v[i]);\n  }\n  if(vs1[0]==\"+\" || vs1[0]==\"*\" || vs1[0]==\"-\")return -1;\n  int size=vs1.size()-1;\n  if(vs1[size]==\"+\" || vs1[size]==\"*\" || vs1[size]==\"-\")return -1;\n  for(int i=0;i<vs1.size();i++){\n    if(vs1[i]==\"*\"){\n      if('0'<=vs1[i+1][0] && vs1[i+1][0]<='9' && '0'<=vs2.back()[0] && vs2.back()[0]<='9' ){\n\tint tmp1=atoi(vs2.back().c_str()),tmp2=atoi(vs1[i+1].c_str());\n\tvs2.pop_back();\n\tostringstream os;\n\tos<<(tmp1*tmp2);\n\tif(1024<=tmp1*tmp2)return -1;\n\tvs2.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs2.push_back(vs1[i]);\n  }\n  for(int i=0;i<vs2.size();i++){\n    if(vs2[i]==\"+\" || vs2[i]==\"-\"){\n      string tmp=vs3.back();\n      if('0'<=vs2[i+1][0] && vs2[i+1][0]<='9' && '0'<=tmp[0] && tmp[0]<='9' ){\n\tint tmp1=atoi(tmp.c_str()),tmp2=atoi(vs2[i+1].c_str());\n\tvs3.pop_back();\n\tostringstream os;\n\tint res;\n\tif(vs2[i]==\"+\")res=(tmp1+tmp2);\n\tif(vs2[i]==\"-\")res=(tmp1-tmp2);\n\tif(res<0 || 1024<=res)return -1;\n\tos<<res;\n\tvs3.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs3.push_back(vs2[i]);\n  }\n  if(vs3.size()==1 && '0'<=vs3[0][0] && vs3[0][0]<='9')return atoi(vs3[0].c_str());\n  return -1;\n}\n\nvoid rec(int v){\n  if(v==n){\n    t=s;\n    for(int i=0;i<n;i++)t[ind[i]]=ln[p[i]];\n    string tmp=\"\";\n    vector<string> vs;\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='0' || t[i]=='1')tmp+=t[i];\n      else {\n\tif(tmp!=\"\")vs.push_back(tmp);\n\ttmp=\"\";\n\tstring st=\"\";\n\tst+=t[i];\n\tvs.push_back(st);\n      }\n    }\n    if(tmp!=\"\")vs.push_back(tmp);\n    stack<int> st;\n    for(int i=0;i<vs.size();i++){\n      if(vs[i]==\"(\")st.push(i);\n      if(vs[i]==\")\"){\n        if(st.empty())return;\n        st.pop();\n      }\n    }\n    if(!st.empty())return;\n    for(int i=1;i<vs.size()-1;i++){\n      if((vs[i][0]=='0' || vs[i][0]=='1') && vs[i-1]==\"(\" && vs[i+1]==\")\")return;\n    }\n    for(int i=0;i<vs.size();i++)vs[i]=f(vs[i]);\n    int res=cal(vs);\n    ans=max(ans,res);\n  }\n  else {\n    for(int i=0;i<7;i++){\n      rec(v+1);\n      p[v]++;\n    }\n    p[v]=0;\n  }\n}\n\nint main()\n{\n  cin>>s;\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='.'){\n      ind[n]=i;\n      n++;\n    }\n  }\n  rec(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 32;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(it+length==end || *(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    *result *= rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint expression(State &begin, State &end);\nint term(State &begin, State &end);\nint number(State &begin, State &end);\nint factor(State &begin, State &end);\n\nint number(State &begin, State &end) {\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret = ret << 1;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn (0 <= ret && ret < pow(2, 10))? ret : -inf;\n}\n\nint term(State &begin, State &end) {\n\tint ret = factor(begin, end);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin, end);\n\t\t\tif(!(0 <= ret && ret < pow(2, 10))) return -inf;\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin, end);\n\t\t\tif(!(0 <= ret && ret < pow(2, 10))) return -inf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (0 <= ret && ret < pow(2, 10))? ret : -inf;\n}\n\nint expression(State &begin, State &end) {\n\tint ret = term(begin, end);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin, end);\n\t\t\tif(!(0 <= ret && ret < pow(2, 10))) return -inf;\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin, end);\n\t\t\tif(!(0 <= ret && ret < pow(2, 10))) return -inf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin, State &end) {\n\tif (*begin == '(') {\n\t\tbegin++; // '('テ」ツつ津ゥツ」ツ崚」ツ?ーテ」ツ?凖」ツ??\n\t\tint ret = expression(begin, end);\n\t\tbegin++; // ')'テ」ツつ津ゥツ」ツ崚」ツ?ーテ」ツ?凖」ツ??\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin, end);\n\t}\n}\n\nvector<int> v;\n\nint f(int idx, string s){\n\tint ret = -1;\n\tif(idx == v.size() || v.size() == 0){\n\t\tint brackets = 0, op = 0;\n\t\tbool possible = true;\n\t\trep(i, s.size()){\n\t\t\tif(s[i] == '(') brackets++;\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*') op++;\n\t\t\tif(s[i] == ')' && op != brackets){possible = false; break;}\n\t\t}\n\t\tstring t = s;\n\t\trep(i, s.size()){\n\t\t\tif(s[i] == '(' || s[i] == ')'){ s = s.substr(0, i) + s.substr(i+1); i--;}\n\t\t}\n\t\tint c = 0;\n\t\twhile(c < s.size()){\n\t\t\twhile(isdigit(s[c])) c++;\n\t\t\tif(!(c < s.size())) break;\n\t\t\tif(s[c] == '+' || s[c] == '-' || s[c] == '*') c++;\n\t\t\telse {possible = false; break;}\n\t\t\tif(!(c < s.size())){possible = false; break;}\n\t\t}\n\t\tif(!possible) return -1;\n\t\ts = t;\n\t\tState begin = s.begin();\n\t\tState end = s.end();\n\t\treturn expression(begin, end);\n\t}\n\telse {\n\t\tstring t = \"01+-*()\";\n\t\tfor(int i=0; i< t.size(); i++){\n\t\t\ts = s.replace(v[idx], 1, t.substr(i, 1));\n\t\t\tint n = f(idx+1, s);\n\t\t\tif(0 <= n && n < pow(2, 10)) ret = max(ret, n);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tstring s;\n\tgetline(cin, s);\n\trep(i, s.size()) if(s[i] == '.') v.push_back(i);\n\tcout << f(0, s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <stdexcept>\n\n#define fprintf(...) void(0)\n\nstruct Tsurai: public std::out_of_range {\n  Tsurai(int d): std::out_of_range(std::string(\"L: \")+std::to_string(d)) {}\n};\n\nvoid apply(int &lhs, char op, int rhs) {\n  switch (op) {\n  case '+':\n    lhs += rhs;\n    break;\n  case '-':\n    lhs -= rhs;\n    break;\n  case '*':\n    lhs *= rhs;\n    break;\n  }\n  if (!(0 <= lhs && lhs < 1024))\n    throw Tsurai(__LINE__);\n}\n\nint parse_bin(const std::string &s, size_t &i) {\n  int res=0;\n  while (i < s.length() && isdigit(s[i])) {\n    res = res*2+s[i]-'0';\n    ++i;\n    if (res >= 1024) throw Tsurai(__LINE__);\n  }\n  assert(res < 1024);\n  return res;\n}\n\nstd::pair<int, int> parse(\n    const std::string &s, size_t &i, int &balance,\n    const std::vector<std::string> &ops={\"+-\", \"*\", \"\"}, size_t prec=0) {\n\n  // <calculates, num of terms/factors>\n  fprintf(stderr, \"C%zu\\n\", i);\n  fprintf(stderr, \"S: %s\\n\", s.c_str());\n  if (prec == ops.size()) {\n    if (s.at(i) == '(') {\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      ++i;\n      ++balance;\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (s.at(i) == ')') throw Tsurai(__LINE__);\n      size_t j=i;\n      (void)parse_bin(s, j);\n      if (s.at(j) == ')') throw Tsurai(__LINE__);\n\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      std::pair<int, int> res=parse(s, i, balance, ops, 0);\n      fprintf(stderr, \"# on line %d: %d\\n\", __LINE__, res.second);\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (s.at(i) != ')')\n        throw Tsurai(__LINE__);\n      ++i;\n      --balance;\n      if (balance < 0)\n        throw Tsurai(__LINE__);\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (res.second <= 1)\n        throw Tsurai(__LINE__);\n      return {res.first, 1};\n    }\n    fprintf(stderr, \"%d\\n\", __LINE__);\n    if (isdigit(s.at(i))) {\n      fprintf(stderr, \"%d\\n\", __LINE__);\n      return {parse_bin(s, i), 1};\n    }\n    throw Tsurai(__LINE__);\n  }\n\n  std::pair<int, int> lhs=parse(s, i, balance, ops, prec+1);\n  fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n\n  while (i < s.length()) {\n    char op=s.at(i);\n    if (op == ')') {\n      break;\n    }\n    if (!(op == '+' || op == '-' || op == '*'))\n      throw Tsurai(__LINE__);\n    if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n      break;\n\n    std::pair<int, int> rhs=parse(s, ++i, balance, ops, prec+1);\n    apply(lhs.first, op, rhs.first);\n    ++lhs.second;\n    lhs.second += rhs.second;\n    fprintf(stderr, \"# on line %d: %d\\n\", __LINE__, lhs.second);\n  }\n  fprintf(stderr, \"# on line %d: %d\\n\", __LINE__, lhs.second);\n  return lhs;\n}\n\nint rec(std::string &s, std::vector<size_t> &dot) {\n  if (dot.empty()) {\n    try {\n      size_t i=0;\n      int b=0;\n      int res=parse(s, i, b).first;\n      if (i != s.length() || b < 0) return -1;\n      return res;\n    } catch (std::out_of_range x) {\n      fprintf(stderr, \"Tsurai on %s\\n\", x.what());\n      return -1;\n    }\n  }\n\n  size_t x=dot.back();\n  dot.pop_back();\n  int res=-1;\n  for (char ch: {'0', '1', '+', '-', '*', '(', ')'}) {\n    s[x] = ch;\n    res = std::max(res, rec(s, dot));\n  }\n  s[x] = '.';\n  dot.push_back(x);\n  return res;\n}\n\nint main() {\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  std::vector<size_t> dot;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '.')\n      dot.push_back(i);\n  }\n\n  printf(\"%d\\n\", rec(s, dot));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstring ch = \"01+-*()\";\nint ans = -1;\n\nint expression(const string& s, int& k);\nint factor(const string& s, int& k);\nint term(const string& s, int& k);\n\n// 数字が [0,1023] かチェック\nbool valid(const int n){\n\treturn (0 <= n && n < 1024);\n}\n\n// <number> ::= <digit> | <number> <digit>\nint number(const string& s, int& k){\n\tint r = 0;\n\twhile( s[k] == '0' || s[k] == '1' ){\n\t\tr = r * 2 + (s[k] - '0');\n\t\t++k;\n\t}\n\treturn r;\n}\n\nint expression(const string& s, int& k){\n\tint r1 = term(s, k);\n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r1;\n}\n\nint factor(const string& s, int& k){\n\tif( s[k] == '(' ){ // 括弧のはじまりのとき\n\t\t++k; // '(' の 1つ先に進める.\n\t\tint r = expression(s, k);\n\t\t// 数字が [0,1023] の範囲にない or ')' がないとき\n\t\tif( !valid(r) || s[k] != ')' ) return -1;\n\t\t\n\t\t++k; // ')' の 1つ先に進める.\n\t\treturn r;\n\t}else if( s[k] == '0' || s[k] == '1' ){ // 数字のとき\n\t\treturn number(s, k);\n\t}else{\n\t\treturn -1;\n\t}\n}\n\nint term(const string& s, int& k){\n\tint r1 = factor(s, k);\n\t// 数字が [0,1023] の範囲にないとき \n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '*' ){\n\t\t\t++k;\n\t\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 * r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r1;\n}\n\n// 式が正しいかどうか.\nbool check(const string& s){\n\tint par = 0;\n\tchar prev = '\\0';\n\tdeque<bool> op(100, false);\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( prev == '\\0' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '(' ){\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '0' || prev == '1' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}\n\t\t\tprev = s[i];\n\t\t}else if( prev == '+' || prev == '-' || prev == '*' ){\n\t\t\tif( par > 0 ){\n\t\t\t\top[par] = true;\n\t\t\t}\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == ')' ){\n\t\t\tif( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tint t=0;\n\t\t// 式が正しいときだけ解を更新.\n\t\t//if( check(s) ){\n\t\t\tint res = expression(s, t);\n\t\t\tans = max( ans , res );\n\t\t//}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\ntypedef string::const_iterator State;\nint number(State&);\npair<int,bool> factor(State&);\npair<int,bool> term(State&);\npair<int,bool> expression(State&);\n\nbool invalid;\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\tif(not isdigit(*begin)){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 2;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\tif(ret >= 1024){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\npair<int,bool> factor(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tpair<int,bool> ret = expression(begin);\n\t\tif(not ret.second) {\n\t\t\tinvalid = true;\n\t\t}\n\t\tbegin++; // ')'を飛ばす。\n\t\tret.second = 0;\n\t\treturn ret;\n\t} else {\n\t\treturn make_pair(number(begin), 0);\n\t}\n\treturn make_pair(0, 0);\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\npair<int,bool> term(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first *= factor(begin).first;\n\t\t\tif(ret.first >= 1024) {\n\t\t\t\tinvalid = true;\n\t\t\t\treturn make_pair(0,0);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\npair<int,bool> expression(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first += term(begin).first;\n\t\t\tif(ret.first >= 1024) {\n\t\t\t\tinvalid = true;\n\t\t\t\treturn make_pair(0,0);\n\t\t\t}\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first -= term(begin).first;\n\t\t\tif(ret.first < 0) {\n\t\t\t\tinvalid = true;\n\t\t\t\treturn make_pair(0,0);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nconst string c = \"01+-*()\";\n\nint dfs(string& s, int i){\n\tif(i == s.size()){\n\t\tinvalid = false;\n\t\tState tmp = s.begin();\n\n\t\tpair<int,bool> ans = expression(tmp);\n\t\tif(ans.first >= 1024 or ans.first < 0 or tmp != s.end()) return -1e5;\n\t\treturn invalid ? -1e5 : ans.first;\n\t}\n\n\twhile(s[i] != '.' and i < s.size()){\n\t\ti++;\n\t}\n\n\tif(s[i] == '.'){\n\t\tint res = -1e5;\n\t\trep(j,c.size()){\n\t\t\ts[i] = c[j];\n\t\t\tres = max(res, dfs(s, i));\n\t\t\ts[i] = '.';\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn dfs(s, i);\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\n\tint ans = dfs(s, 0);\n\tcout << (ans == -1e5 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst char cs[] = \"01+-*()\";\nchar src[128], s[128];\nint _i, token;\n\nvoid check(int a) {\n    if (a < 0 || a >= 1024) throw \"overflow\";\n}\n\nint next() {\n    if (s[_i] == 0) return 0;\n    if (s[_i] == '0' || s[_i] == '1') {\n        int a = 0;\n        while (s[_i] == '0' || s[_i] == '1') {\n            a = a * 2 + (s[_i++]-'0');\n            check(a);\n        }\n        return -(a+1);\n    }\n    return s[_i++];\n}\n\npair<int, bool> expr(), term(), factor();\n\nint parse() {\n    _i = 0;\n    token = next();\n    const int ans = expr().first;\n    if (token != 0) throw \"ill end\";\n    return ans;\n}\n\npair<int, bool> expr() {\n    pair<int, bool> a = term();\n    while (token == '+' || token == '-') {\n        const char op = token;\n        token = next();\n        const pair<int, bool> b = term();\n        a.first = op == '+' ? a.first + b.first : a.first - b.first;\n        a.second = true;\n        check(a.first);\n    }\n    return a;\n}\n\npair<int, bool> term() {\n    pair<int, bool> a = factor();\n    while (token == '*') {\n        token = next();\n        const pair<int, bool> b = factor();\n        a.first = a.first * b.first;\n        a.second = true;\n        check(a.first);\n    }\n    return a;\n}\n\npair<int, bool> factor() {\n    if (token < 0) {\n        const int a = -(token+1);\n        token = next();\n        return mp(a, false);\n    }\n    if (token == '(') {\n        token = next();\n        pair<int, bool> a = expr();\n        if (a.second == false) throw \"(-)\";\n        if (token != ')') throw \"unmatched\";\n        token = next();\n        return mp(a.first, false);\n    }\n    throw \"ill char\";\n}\n\nint main() {\n    scanf(\"%s\", src);\n    int ans = -1;\n    rep (b, 7*7*7*7*7) {\n        for (int i = 0, p = b; src[i]; i++) {\n            s[i] = src[i];\n            if (s[i] == '.') {\n                s[i] = cs[p%7];\n                p /= 7;\n            }\n        }\n        try {\n            ans = max(ans, parse());\n        }\n        catch (const char *err) {\n            //printf(\"%s\\n\", err);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc();\nint expr();\nint number();\nstring tmp;\nint pos;\nchar c[]=\"()+-*01\";\nint ans=-1;\nint calc(){\n  int res=expr();\n  if(tmp[pos]=='*') {pos++;res*=expr();}\n  return res;\n}\nint expr(){\n  int res=number();\n  if(tmp[pos]=='+') {pos++;res+=number();}\n  if(tmp[pos]=='-') {pos++;res-=number();}\n  return res;\n}\nint number(){\n  int res=0;\n  if(tmp[pos]=='(') {\n    pos++;res=calc();pos++;\n  }else{\n    while(pos<(int)tmp.size()&&isdigit(tmp[pos])) res=res*2+tmp[pos]-'0',pos++;\n  }\n  return res;\n}\n\nbool check(string s){\n  int o=0;\n  bool op[100]={};\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') {\n      o++;\n      op[o]=1;\n      if(i+1>=(int)s.size()) return 0;\n      if(!isdigit(s[i+1])) return 0;\n    }    \n    if(s[i]==')') {\n      if(op[o]) return 0;\n      o--;\n      if(i-1<0) return 0;\n      if(!isdigit(s[i-1])) return 0;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*') {\n      op[o]=0;\n      if(i-1<0||i+1>=(int)s.size()) return 0;\n      if((!isdigit(s[i-1])&&s[i-1]!=')')||(!isdigit(s[i+1])&&s[i+1]!='(')) return 0;\n    }\n    if(o<0) return 0;\n  }\n  if(o) return 0;\n  return 1;\n}\nvoid rec(string s){\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]!='.') continue;\n    for(int j=0;j<8;j++){\n      s[i]=c[j];\n      rec(s);\n    }\n    return;\n  }\n  if(!check(s)) return;\n  tmp=s;pos=0;\n  ans=max(ans,calc());\n}\nint main(){\n  string s;\n  cin>>s;\n  rec(s);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nclass SyntaxAnalysis\n{\npublic:\n    using T = pair<bool, int>;\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '*';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '(';\n    static T plus(const T& n, const T& k) { return {n.first and k.first and prop(n.second + k.second), n.second + k.second}; }\n    static T minus(const T& n, const T& k) { return {n.first and k.first and prop(n.second - k.second), n.second - k.second}; }\n    static T product(const T& n, const T& k) { return {n.first and k.first and prop(n.second * k.second), n.second * k.second}; }\n    static T divide(const T& n, const T& k) { return n; }\n    static T brace(const T& n) { return n; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '1'; }\n    static int encode(const char c) { return c - '0'; }\n    static bool prop(const int l) { return l >= 0 and l < 1 << 10; }\n    T number()\n    {\n        int ans = 0, start = S.size();\n        for (; pos < S.size() and is_digit(S[pos]); pos++) {\n            if (S[pos] == '1') { start = min(start, pos); }\n            ans = ans * 2 + encode(S[pos]);\n        }\n        return {pos - start <= 10, ans};\n    }\n    T factor()\n    {\n        if (S[pos] == BRACE) {\n            T ans;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    T term()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, f = factor(), ans = product(ans, f);\n            } else if (S[pos] == DIVIDE) {\n                pos++, f = factor(), ans = divide(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    T expression()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = factor(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = factor(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\ntemplate <typename S, typename T>\ninline ostream& operator<<(ostream& os, const pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\n\nint main()\n{\n    constexpr char C[7] = {'0', '1', '+', '-', '*', '(', ')'};\n    string s;\n    cin >> s;\n    vector<int> p;\n    int NUM = 1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '.') { p.push_back(i), NUM *= 7; }\n    }\n    const int sz = p.size();\n    int ans = -1;\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0, num = i; j < sz; j++, num /= 7) { s[p[j]] = C[num % 7]; }\n        stack<int> st;\n        st.push(0);\n        bool ok = true, num = false;\n        for (const char c : s) {\n            if (c == '(') {\n                if (num) {\n                    ok = false;\n                    break;\n                }\n                st.push(0);\n            } else if (c == ')') {\n                if (st.size() <= 1 or st.top() == 0) {\n                    ok = false;\n                    break;\n                }\n                num = true;\n                st.pop();\n            } else if (c == '+' or c == '-' or c == '*') {\n                if (not num) {\n                    ok = false;\n                    break;\n                }\n                num = false;\n                const int n = st.top() + 1;\n                st.pop(), st.push(n);\n            } else {\n                num = true;\n            }\n        }\n        if (not ok or st.size() != 1) { continue; }\n        const auto sub = SyntaxAnalysis{s}.Expression();\n        // show(sub);\n        if (sub.first) { ans = max(ans, sub.second); }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n        }else{\n            res -= term(++pos);\n            if(res<0){\n                ppppp = 1;\n            }\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    cout << tmp2 << endl;\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint p,flag,ans=-1;\nstring s;\nmap<int,char>cc;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])){\n    while(isdigit(s[p]))res=res*2+(s[p++]-'0');\n  }\n  else flag++;\n  return res;\n}\nint bnf2(){\n  int res=get_A();\n  while(s[p]=='*'){\n    int t=p++;\n    if(s[t]=='+')res*=get_A();\n  }\n  return res;\n}\nint bnf1(){\n  int res=bnf2();\n  while(s[p]=='+'||s[p]=='-'){\n    int t=p++;\n    if(s[t]=='+')res+=bnf2();\n    if(s[t]=='-')res-=bnf2();\n  }\n  return res;\n}\nbool ch(int t){\n  int res=0;\n  while(s[p]!=')'){\n    if(s[p]=='('){\n      p++;\n      if(!ch(1))return 0;\n    }\n    if(p>=s.size())break;\n    if(s[p]=='+'||s[p]=='-'||s[p]=='*')res++;\n    if(p>=s.size())return 0;\n    p++;\n  }\n  p++;\n  return (!t)||res;\n}\nvoid dfs(int d){\n  if(d==s.size()){\n    p=0;\n    if(ch(0)){\n      p=flag=0;\n      int res=bnf1();\n      if(!flag&&p==s.size())ans=max(ans,res);\n    }\n  }\n  else if(s[d]=='.'){\n    r(i,7){\n      s[d]=cc[i];\n      dfs(d+1);\n    }\n    s[d]='.';\n  }\n  else dfs(d+1);\n}\nmain(){\n  cin>>s;\n  cc[0]='0';\n  cc[1]='1';\n  cc[2]='+';\n  cc[3]='-';\n  cc[4]='*';\n  cc[5]='(';\n  cc[6]=')';\n  dfs(0);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <stack>\nusing namespace std;\n\nconst int ADD      = 1;\nconst int SUBTRACT = 2;\nconst int MULTIPLY = 3;\nconst int OPEN     = 4;\nconst int CLOSE    = 5;\nconst int NUMBER   = 6;\nconst string C = \"01+-*()\";\n\nvector<pair<int,int> > S;\nint pos;\n\nint fact();\nint term();\nint exp();\n\ninline void validNum(int n) {\n  if(0 <= n && n < (1<<10)) ; else throw \"\";\n}\n\nint fact() {\n  int x;\n  if(S[pos].first == NUMBER) {\n    x = S[pos].second;\n    validNum(x);\n    ++pos;\n  } else if(S[pos].first == OPEN) {\n    ++pos;\n    x = exp();\n    validNum(x);\n    if(S[pos].first != CLOSE) throw \"\";\n    ++pos;\n  } else {\n    throw \"\";\n  }\n  return x;\n}\n\nint term() {\n  int x = fact();\n  validNum(x);\n  while(S[pos].first == MULTIPLY) {\n    ++pos;\n    x *= fact();\n    validNum(x);\n  }\n  return x;\n}\n\nint exp() {\n  int x = term();\n  validNum(x);\n  while(S[pos].first == ADD || S[pos].first == SUBTRACT) {\n    if(S[pos].first == ADD) {\n      ++pos;\n      x += term();\n      validNum(x);\n    } else if(S[pos].first == SUBTRACT) {\n      ++pos;\n      x -= term();\n      validNum(x);\n    }\n  }\n  return x;\n}\n\nint btod(const string &s) {\n  if(s.size() > 31) throw \"\";\n  int res = 0;\n  for(int i = 0; i < s.size(); ++i) {\n    res = (res << 1);\n    if(s[i] == '1') res |= 1;\n  }\n  return res;\n}\n\nbool isValid(const vector<pair<int,int> > &v) {\n  stack<int> stk;\n  stk.push(0);\n  for(int i = 0; i < v.size(); ++i) {\n    if(v[i].first == OPEN) {\n      stk.push(0);\n    } else if(v[i].first == CLOSE) {\n      if(stk.size() == 1) return false;\n      if(stk.top() == 0) return false;\n      stk.pop();\n    } else if(v[i].first == NUMBER) {\n    } else {\n      stk.top() += 1;\n    }\n  }\n  return stk.size() == 1;\n}\n\nvector<pair<int,int> > make(const string &s) {\n  vector<pair<int,int> > res;\n  S.clear();\n  for(int i = 0; i < s.size(); ++i) {\n    pair<int,int> p;\n    if(isdigit(s[i])) {\n      string num = \"\";\n      while(isdigit(s[i])) {\n        if(num.empty() && s[i] == '0') ; else {\n          num += s[i];\n        }\n        ++i;\n      }\n      if(num.empty()) num += '0';\n\n      p = make_pair(NUMBER, btod(num));\n      --i;\n    } else {\n      switch(s[i]) {\n        case '+': p.first = ADD; break;\n        case '-': p.first = SUBTRACT; break;\n        case '*': p.first = MULTIPLY; break;\n        case '(': p.first = OPEN; break;\n        case ')': p.first = CLOSE; break;\n      }\n    }\n    res.push_back(p);\n  }\n  return res;\n}\n\nint main() {\n  string s;\n  while(cin >> s) {\n    vector<int> ind;\n    for(int i = 0; i < s.size(); ++i) {\n      if(s[i] == '.') ind.push_back(i);\n    }\n    int res = -1;\n    for(int a = 0; a < C.size(); ++a) {\n      for(int b = 0; b < C.size(); ++b) {\n        for(int c = 0; c < C.size(); ++c) {\n          for(int d = 0; d < C.size(); ++d) {\n            for(int e = 0; e < C.size(); ++e) {\n              if(ind.size() > 0) s[ind[0]] = C[a];\n              if(ind.size() > 1) s[ind[1]] = C[b];\n              if(ind.size() > 2) s[ind[2]] = C[c];\n              if(ind.size() > 3) s[ind[3]] = C[d];\n              if(ind.size() > 4) s[ind[4]] = C[e];\n\n              try {\n                S = make(s);\n                if(isValid(S)) {\n                  pos = 0;\n                  int tmp = exp();\n                  validNum(tmp);\n                  if(pos != S.size()) throw \"\";\n                  res = max(res, tmp);\n                }\n              } catch(const char *error) {}\n            }\n          }\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s, tmp, let = \"01+-*()\";\nvi v;\nint n, p, ans;\n\nbool range(int t)\n{\n\treturn t >= 0 && t < (1 << 10);\n}\n\nint num()\n{\n\tint res = 0;\n\twhile (p < n && isdigit(tmp[p]))\n\t{\n\t\tres *= 2;\n\t\tres += tmp[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nint plu();\n\nint unit()\n{\n\tint res;\n\tif (tmp[p] == '(')\n\t{\n\t\tp++;\n\t\tres = plu();\n\t\tif (tmp[p] != ')') return -1;\n\t\tp++;\n\t}\n\telse \n\t{ \n\t\tif (!isdigit(tmp[p])) return -1;\n\t\tres = num();\n\t}\n\tif (!range(res)) return -1;\n\telse return res;\n}\n\nint mul()\n{\n\tint res = unit();\n\twhile (tmp[p] == '*')\n\t{\n\t\tp++;\n\t\tint rhs = unit();\n\t\tif (rhs == -1) return -1;\n\t\tres *= rhs;\n\t}\n\tif (!range(res)) return -1;\n\telse return res;\n}\n\nint plu()\n{\n\tint res = mul();\n\tif (res == -1) return -1;\n\twhile (tmp[p] == '+' || tmp[p] == '-')\n\t{\n\t\tif (tmp[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul();\n\t\t\tif (rhs == -1) return -1;\n\t\t\tres += rhs;\n\t\t}\n\t\telse if (tmp[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul();\n\t\t\tif (rhs == -1) return -1;\n\t\t\tres -= rhs;\n\t\t}\n\t}\n\tif (!range(res)) return -1;\n\telse return res;\n}\n\nint parse()\n{\n\tp = 0;\n\tint res = plu();\n\tif (p != tmp.size()) return -1;\n\telse return res;\n}\n\nbool check1()\n{\n\tbool res = true;\n\tREP(i, tmp.size()) if (!isdigit(tmp[i])) res = false;\n\treturn res;\n}\n\nbool check2()\n{\n\tbool res;\n\tstring elem; //0 = number, 1 = operator, 2 = '('\n\tREP(i, tmp.size())\n\t{\n\t\tif (isdigit(tmp[i]))\n\t\t{\n\t\t\twhile (isdigit(tmp[i])) i++;\n\t\t\ti--;\n\t\t\telem.push_back('0');\n\t\t}\n\t\telse if (tmp[i] == '+' || tmp[i] == '-' || tmp[i] == '*')\n\t\t{\n\t\t\telem.push_back('1');\n\t\t}\n\t\telse if (tmp[i] == '(') elem.push_back('(');\n\t\telse if (tmp[i] == ')') elem.push_back(')');\n\t\telse assert(false);\n\t}\n\tREP(i, elem.size() - 2)\n\t{\n\t\tif (elem[i] == '('&&elem[i + 1] == '0'&&elem[i + 2] == ')') return false;\n\t}\n\tREP(i, elem.size() - 1)\n\t{\n\t\tif (elem[i] == '('&&elem[i + 1] == ')') return false;\n\t}\n\treturn true;\n}\n\n\n\nvoid solve(int i, vi w)\n{\n\tif (i == v.size())\n\t{\n\t\ttmp = s;\n\t\tREP(i, v.size())\n\t\t{\n\t\t\ttmp[v[i]] = let[w[i]];\n\t\t}\n\t\tp = 0;\n\t\tif (check1())\n\t\t{\n\t\t\tint res = num();\n\t\t\tchmax(ans, res);\n\t\t}\n\t\telse if (check2())\n\t\t{\n\t\t\tint res = parse();\n\t\t\tchmax(ans, res);\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, 7)\n\t\t{\n\t\t\tvi tmp = w;\n\t\t\ttmp.push_back(j);\n\t\t\tsolve(i + 1, tmp);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tans = -1;\n\tcin >> s;\n\tn = s.size();\n\tREP(i, n)\n\t{\n\t\tif (s[i] == '.') v.push_back(i);\n\t}\n\tvi emp;\n\tsolve(0, emp);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\n\nstruct Parser{\n\tstring s;\n\tint N;\n\tint c;\n\n\tll parse(string s){\n\t\tthis->s = s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\ttry{\n\t\t\tll ret = expr();\n\t\t\tif(c != N) throw \"\";\n\t\t\treturn ret;\n\t\t}\n\t\tcatch(...){\n\t\t\treturn INF;\n\t\t}\n\t}\n\n\tbool check(ll n){\n\t\treturn 0 <= n && n < 1024;\n\t}\n\n\tvoid debug(string text){\n\t\treturn;\n\t\tcout << text + \" \";\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\t\telse cout << s[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tll expr(){\n\t\tdebug(\"expr\");\n\t\tll x = term();\n\t\tif(!check(x)) throw \"\";\n\t\twhile(c < N){\n\t\t\tif(s[c] == '+'){\n\t\t\t\tc++;\n\t\t\t\tx += term();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse if(s[c] == '-'){\n\t\t\t\tc++;\n\t\t\t\tx -= term();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll term(){\n\t\tdebug(\"term\");\n\t\tll x = factor();\n\t\twhile(c < N){\n\t\t\tif(s[c] == '*'){\n\t\t\t\tc++;\n\t\t\t\tx *= factor();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll factor(){\n\t\tdebug(\"factor\");\n\t\tif(s[c] == '('){\n\t\t\tc++;\n\t\t\tint start = c;\n\t\t\tll ret = expr();\n\t\t\tif(s[c] != ')') throw \"\";\n\t\t\t//assert(s[c] == ')');\n\t\t\tint cnt = 0;\n\t\t\tbool op = 0;\n\t\t\tfor(int i = start; i < c; i++){\n\t\t\t\tif(s[i] == '(') cnt++;\n\t\t\t\tif(s[i] == ')') cnt--;\n\t\t\t\tif(cnt == 0 && (s[i] == '+' || s[i] == '*')) op = 1;\n\t\t\t}\n\t\t\tif(!op) throw \"\";\n\t\t\tc++;\n\t\t\treturn ret;\n\t\t}\n\t\treturn num();\n\t}\n\n\tll num(){\n\t\tdebug(\"num\");\n\t\tif(!isdigit(s[c])) throw \"\";\n\t\tll ret = 0;\n\t\twhile(c < N && isdigit(s[c])){\n\t\t\tret = ret * 2 + s[c] - '0';\n\t\t\tc++;\n\t\t}\n\t\treturn ret;\n\t}\n} parser;\n\nstring t = \"01+-()\";\nll ans = -1;\n\nvoid dfs(int n, string s){\n\tif(n == s.size()){\n\t\tll res = parser.parse(s);\n\t\tif(res != INF) ans = max(ans, res);\n\t\treturn;\n\t}\n\tif(s[n] != '.'){\n\t\treturn dfs(n + 1, s);\n\t}\n\tfor(int i = 0; i < t.size(); i++){\n\t\ts[n] = t[i];\n\t\tdfs(n + 1, s);\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tstring s;\n\tcin >> s;\n\tdfs(0, s);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-9;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i > 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint o_rank(char c){\n    if(c == '+') return 0;\n    else if (c == '-') return 1;\n    else if (c == '*') return 2;\n    else return -1;\n}\n\nbool comp(char a, char b){\n    return o_rank(a) > o_rank(b);\n}\n\nbool calc(stack<int> &num, stack<char> &ope){\n    if(num.size() < 2 || ope.size() < 1) return false;\n    if(ope.top() == '(') return false;\n    if(ope.top() == '+'){\n        int n1, n2;\n        n2 = num.top(); num.pop();\n        n1 = num.top(); num.pop();\n        num.push(n1+n2);\n    }\n    else if(ope.top() == '-'){\n        int n1, n2;\n        n2 = num.top(); num.pop();\n        n1 = num.top(); num.pop();\n        num.push(n1-n2);\n    }\n    else if(ope.top() == '*'){\n        int n1, n2;\n        n2 = num.top(); num.pop();\n        n1 = num.top(); num.pop();\n        num.push(n1*n2);\n    }\n    else return false;\n    if(num.top() < 0 || num.top() >= (1<<10)) return false;\n    ope.pop();\n    return true;\n}\n\nint solve(string &s){\n    stack<int> num;\n    stack<char> ope;\n    int b = -IINF;\n    char pre = '#';\n    for(auto c : s){\n        if(c == '0' || c == '1'){\n            if(b == -IINF) b = 0;\n            b = (b<<1) + c-'0';\n        }\n        else if(c == '('){\n            if(b != -IINF) return -IINF;\n            ope.push('(');\n        }\n        else if(c == ')'){\n            if(pre == '+' || pre == '-' || pre == '*') return -IINF;\n            if(b != -IINF){\n                num.push(b);\n                b = -IINF;\n            }\n            int cnt = 0;\n            while(calc(num, ope)) cnt++;\n            if(ope.empty() || ope.top() != '(' || cnt == 0){\n                return -IINF;\n            }\n            ope.pop();\n        }\n        else if(c=='+' || c=='-' || c=='*'){\n            if(b != -IINF){\n                num.push(b);\n                b = -IINF;\n            }\n            while(!ope.empty() && comp(ope.top(), c)){\n                if(!calc(num, ope)){\n                    return -IINF;\n                }\n            }\n            ope.push(c);\n        }\n        else{\n            return -IINF;\n        }\n        if(!num.empty() && (num.top() < 0 || num.top() >= (1<<10))) return -IINF;\n        pre = c;\n    }\n    if(b != -IINF) num.push(b);\n    while(calc(num, ope));\n    if(num.size() != 1 || ope.size() != 0 || num.top() < 0 || num.top() >= (1<<10)){\n        return -IINF;\n    }\n    else return num.top();\n}\n\nint main() {\n    string s;\n    vector<int> dots;\n    vector<char> ch = {'0', '1', '+', '-', '*', '(', ')'};\n    cin >> s;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.'){\n            dots.push_back(i);\n        }\n    }\n    int m = int(pow(7, dots.size()));\n    int ans = solve(s);\n    for(int i=0;i<m;i++){\n        int t = i;\n        for(int j=0;j<int(dots.size());j++){\n            s[dots[j]] = ch[t%7];\n            t /= 7;\n        }\n        int tmp = solve(s);\n        ans = max(ans, tmp);\n    }\n    if(ans == -IINF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint ans=-1;\n\nint ex(string::iterator &it,int r){\n    if(r==0){\n        int res=ex(it,r+1);\n        if(res==-1)return -1;\n        while(true){\n            if(*it=='*'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res*=x;\n            }\n            else break;\n            if(res<0||res>=1024)return -1;\n        }\n        return res;\n    }\n    if(r==1){\n        int res=ex(it,r+1);\n        if(res==-1)return -1;\n        while(true){\n            if(*it=='+'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res+=x;\n            }\n            else if(*it=='-'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res-=x;\n            }\n            else break;\n            if(res<0||res>=1024)return -1;\n        }\n        return res;\n    }\n    if(r==2){\n        if(*it=='('){\n            it++;\n            int res=ex(it,0);\n            it++;\n            return res;\n        }\n        return ex(it,r+1);\n    }\n    if(r==3){\n        if(!isdigit(*it))return -1;\n        int res=0;\n        while(isdigit(*it)){\n            res=res*2+*it-'0';\n            it++;\n            if(res>=1024)return -1;\n        }\n        return res;\n    }\n}\n\nvoid solve(string s){\n    stack<int>st;\n    vint beet(s.size(),-1);\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='('){\n            st.push(i);\n        }\n        else if(s[i]==')'){\n            if(st.size()==0)return;\n            int t=st.top();\n            beet[t]=i;\n            st.pop();\n            if(s[t+1]=='('&&beet[t+1]==i-1)return;\n            bool ok=false;\n            for(int j=t+1;j<i;j++)if(s[j]=='+'||s[j]=='-'||s[j]=='*')ok=true;\n            if(!ok)return;\n        }\n    }\n    if(st.size())return;\n    s+=\"=\";\n    auto it=s.begin();\n    int tmp=ex(it,0);\n    if(*it!='=')return;\n    chmax(ans,tmp);\n}\n\nvoid dfs(int n,string &S){\n    if(n==S.size()){\n        solve(S);\n        return;\n    }\n    if(S[n]=='.'){\n        rep(i,7){\n            S[n]=\"01+-*()\"[i];\n            dfs(n+1,S);\n        }\n        S[n]='.';\n    }\n    else{\n        dfs(n+1,S);\n    }\n}\n\nsigned main(){\n    string S;\n    cin>>S;\n    dfs(0,S);\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110];\nint b[11];\nint sz;\nint expr();\nint cur;\nchar s[10]=\"01+-*().\";\nint term(){\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tint ret=expr();\n\t\tif(str[cur]!=')')return -1;\n\t\tcur++;\n\t\treturn ret;\n\t}else if('0'<=str[cur]&&str[cur]<='1'){\n\t\tint ret=0;\n\t\twhile(str[cur]=='0'||str[cur]=='1'){\n\t\t\tret*=2;\n\t\t\tret+=str[cur]-'0';\n\t\t\tcur++;\n\t\t\tif(ret>=1024)return -1;\n\t\t}\n\t\treturn ret;\n\t}else return -1;\n}\nint fact(){\n\tint ret=term();\n\tif(ret==-1)return -1;\n\twhile(1){\n\t\tif(str[cur]=='0')return -1;\n\t\tif(str[cur]=='1')return -1;\n\t\tif(str[cur]=='(')return -1;\n\t\tif(str[cur]!='*')break;\n\t\tcur++;\n\t\tint tmp=term();\n\t\tif(tmp==-1)return -1;\n\t\tret*=tmp;\n\t\tif(ret<0||ret>=1024)return -1;\n\t}\n\treturn ret;\n}\nint expr(){\n\tint ret=fact();\n\tif(ret==-1)return -1;\n\twhile(1){\n\t\tif(str[cur]=='0')return -1;\n\t\tif(str[cur]=='1')return -1;\n\t\tif(str[cur]=='(')return -1;\n\t\tif(str[cur]!='+'&&str[cur]!='-')break;\n\t\tchar ch=str[cur];\n\t\tcur++;\n\t\tint tmp=fact();\n\t\tif(tmp==-1)return -1;\n\t\tif(ch=='+')ret+=tmp;\n\t\telse ret-=tmp;\n\t\tif(ret<0||ret>=1024)return -1;\n\t}\n\treturn ret;\n}\nint solve(int a){\n\tif(a==sz){\n\t\tcur=0;\n\t\tint left=0;\n\t\tfor(int i=0;str[i];i++){\n\t\t\tif(str[i]=='(')left=1;\n\t\t\telse if(str[i]==')'&&left)return -1;\n\t\t\telse if(str[i]!='1'&&str[i]!='0')left=0;\n\t\t}\n\t\treturn expr();\n\t}\n\tint ret=-1;\n\tfor(int i=0;i<7;i++){\n\t\tstr[b[a]]=s[i];\n\t\tret=max(ret,solve(a+1));\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\",str);\n\tfor(int i=0;str[i];i++){\n\t\tif(str[i]=='.')b[sz++]=i;\n\t}\n\tprintf(\"%d\\n\",solve(0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nclass ex{\n};\n\nvoid ass(bool cond){\n\tif(!cond){\n\t\tthrow ex();\n\t}\n}\nvoid inrange(int n){\n\tass(0<=n&&n<(1<<10));\n}\n\nint number(string &s,int &p){\n\tass(isdigit(s[p]));\n\tint ret=s[p]-'0';\n\tp++;\n\twhile(isdigit(s[p])){\n\t\tret<<=1;\n\t\tret+=s[p]-'0';\n\t\tinrange(ret);\n\t\tp++;\n\t}\n\tinrange(ret);\n\treturn ret;\n}\nint expression(string &s, int &p,bool &op_exist);\nint term(string &s,int &p,bool &op_exist);\n\n//factor ::= number | (expression)\nint factor(string &s,int &p){\n\tif(s[p]=='('){\n\t\tp++;\n\t\tbool op_exist=false;\n\t\tint ret=expression(s,p,op_exist);\n\t\tass(op_exist);\n\t\tinrange(ret);\n\t\tass(s[p]==')');\n\t\tp++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(s,p);\n\t}\n}\n\n//term ::= factor | factor * factor\nint term(string &s,int &p,bool &op_exist){\n\tint ret=factor(s,p);\n\twhile(s[p]=='*'){\n\t\tp++;\n\t\tret*=factor(s,p);\n\t\tinrange(ret);\n\t\top_exist=true;\n\t}\n\treturn ret;\n}\n\n//expression ::= term | term [+-] expression\nint expression(string &s, int &p,bool &op_exist){\n\tint ret=term(s,p,op_exist);\n\tchar op=s[p];\n\twhile(op=='+'||op=='-'){\n\t\tp++;\n\t\tint t=term(s,p,op_exist);\n\t\tif(op=='+'){\n\t\t\tret+=t;\n\t\t}else if(op=='-'){\n\t\t\tret-=t;\n\t\t}else{\n\t\t\tass(0);\n\t\t}\n\t\tinrange(ret);\n\t\top=s[p];\n\t\top_exist=true;\n\t}\n\treturn ret;\n}\n\nchar chars[]={'0','1','+','-','*','(',')'};\n\nint main(){\n\tstring s;\n\tcin>>s;\n\tvi rpl(5);\n\tint ans=-1;\n\tfor(rpl[0]=0;rpl[0]<7;rpl[0]++)\n\tfor(rpl[1]=0;rpl[1]<7;rpl[1]++)\n\tfor(rpl[2]=0;rpl[2]<7;rpl[2]++)\n\tfor(rpl[3]=0;rpl[3]<7;rpl[3]++)\n\tfor(rpl[4]=0;rpl[4]<7;rpl[4]++){\n\t\tstring ns(s);\n\t\tint pos=0;\n\t\tREP(i,5){\n\t\t\tpos=ns.find('.',pos);\n\t\t\tif(pos!=ns.npos){\n\t\t\t\tns[pos]=chars[rpl[i]];\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttry{\n\t\t\tint p=0;\n\t\t\tbool op_exist=false;\n\t\t\tint val=expression(ns,p,op_exist);\n\t\t\tass(p==ns.size());\n\t\t\tans=max(ans,val);\n\t\t}catch(ex){\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n \nusing namespace std;\ntypedef long long ll;\nint INF=1;\n// 四則演算\n// 構文がおかしい場合は-INF\nint analysis(string s,bool ope){\n  if(s==\"\")return -INF;\n  if(!ope){\n    bool isNumber=true;\n    int minOnePos=1000000;\n    for(int i=0;i<(int)s.size();i++){\n      if(!(s[i]>='0'&&s[i]<='1'))isNumber=false;\n      else if(s[i]=='1')minOnePos=min(minOnePos,i);\n    }\n    if(isNumber){\n      if((int)s.size()-minOnePos>11)return -INF;\n      int num=0;\n      for(int i=0;i<(int)s.size();i++){\n\tnum=num*2;\n\tif(s[i]=='1')num+=(s[i]-'0');\n      }\n      if(num<0||num>=1024)return -INF;\n      return num;\n    }\n    if(s[0]=='('){\n      int cnt=1;\n      bool ok=true;\n      for(int i=1;i<(int)s.size()-1;i++){\n\tif(s[i]=='(')cnt++;\n\telse if(s[i]==')')cnt--;\n\tif(cnt==0)ok=false;\n      }\n      // 括弧を取る場合、必ず中にoperatorが存在\n      if(ok&&cnt==1&&s[s.size()-1]==')')\n\treturn analysis(s.substr(1,s.size()-2),true);\n    }\n  }\n  int cnt=0;\n  for(int i=s.size()-1;i>=0;i--){\n    if(s[i]==')')cnt++;\n    else if(s[i]=='(')cnt--;\n    else if(cnt==0&&s[i]=='+'){\n      int res1=analysis(s.substr(0,i),false);\n      int res2=analysis(s.substr(i+1),false);\n      if(res1==-INF||res2==-INF)return -INF;\n      else{\n\tif(res1+res2>=1024||res1+res2<0)return -INF;\n\treturn res1+res2;\n      }\n    }\n    else if(cnt==0&&s[i]=='-'){\n      int res1=analysis(s.substr(0,i),false);\n      int res2=analysis(s.substr(i+1),false);\n      if(res1==-INF||res2==-INF)return -INF;\n      else{\n\tif(res1-res2>=1024||res1-res2<0)return -INF;\n\treturn res1-res2;\n      }\n    }\n  }\n  cnt=0;\n  for(int i=s.size()-1;i>=0;i--){\n    if(s[i]==')')cnt++;\n    else if(s[i]=='(')cnt--;\n    else if(cnt==0&&s[i]=='*'){\n      int res1=analysis(s.substr(0,i),false);\n      int res2=analysis(s.substr(i+1),false);\n      if(res1==-INF||res2==-INF)return -INF;\n      else{\n\tif(res1*res2>=1024||res1*res2<0)return -INF;\n\treturn res1*res2;\n      }\n    }\n  }\n  return -INF;\n}\n\nstring s;\nvector<int> poss;\nint res;\nchar chs[]={'0','1','+','-','*','(',')'};\nvoid rec(int depth){\n  if(depth==(int)poss.size()){\n    int b=analysis(s,false);\n    res=max(res,b);\n  }\n  else{\n    for(int i=0;i<7;i++){\n      s[poss[depth]]=chs[i];\n      rec(depth+1);\n    }\n  }\n}\n\nint main(){\n  while(cin>>s){\n    poss.clear();\n    for(int i=0;i<(int)s.size();i++)\n      if(s[i]=='.')poss.push_back(i);\n    res=-1;\n    rec(0);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <stack>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef string::const_iterator State;\nint expr(State &be);\nint num(State &be){\n\tif(!isdigit(*be)) return -1;\n\tint ret=0;\n\twhile(isdigit(*be)){\n\t\tret*=2;\n\t\tret+=(*be-'0');\n\t\tbe++;\n\t}\n\treturn ret;\n}\nint factor(State& be){\n\tint ret;\n\tif(*be=='('){\n\t\tbe++;\n\t\tret=expr(be);\n\t\tif(*be!=')') return -1;\n\t\tbe++;\n\t\treturn ret;\n/*\t\tcout << ret << endl;\n\t\tif(ret==-1) return -1;\n\t\tint k=-1;\n\t\tcout << *be << endl;\n\t\tif(*be=='+') k=0;\n\t\tif(*be=='-') k=1;\n\t\tif(*be=='*') k=2;\n\t\tif(k==-1) return -1;\n\t\tbe++;\n\t\tint ret1=expr(be);\n\t\tif(ret1==-1) return -1;\n\t\tbe++;\n\t\tif(k==0) return ret+ret1;\n\t\tif(k==1) return max(-1,ret-ret1);\n\t\tif(k==2) return ret*ret1;\n\t\tcout << \"hoge\";*/\n\t}\n\treturn num(be);\n}\nint term(State& be){\n\tint ret=factor(be);\n\tif(ret==-1) return -1;\n\twhile(*be=='*'){\n\t\tbe++;\n\t\tint a=factor(be);\n\t\tif(a<0) return -1;\n\t\tret*=a;\n\t}\n\treturn ret;\n}\nint expr(State& be){\n\tint ret=term(be);\n\tif(ret==-1) return -1;\n\twhile(true){\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret+=a;\n\t\t}else if(*be=='-'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<0) return -1;\n\t\t}else break;\n\t}\n\treturn ret;\n}\nint main(){\n\tstring s,ch=\"01+-*()\";\n\tvector<int> vc;\n\tcin >> s;\n\tState be=s.begin();\n\trep(i,s.size()) if(s[i]=='.') vc.push_back(i);\n\tint n=vc.size(),p7=1,ans=-1;\n\trep(i,n) p7*=7;\n\trep(i,p7){\n\t\tstring t=s;\n\t\tint tmp=i;\n\t\trep(j,n){\n\t\t\tt[vc[j]]=ch[tmp%7];\n\t\t\ttmp/=7;\n\t\t}\n\t\tcout << t << \"  \";\n\t\tstack<int> id;\n\t\tint cal[101]={};\n\t\tbool ok=true;\n\t\trep(i,t.size()){\n\t\t\tif(t[i]=='('){\n\t\t\t\tid.push(i);\n\t\t\t\tcal[i]=-1;\n\t\t\t}\n\t\t\tif(t[i]==')'){\n\t\t\t\tif(id.empty()){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tid.pop();\n\t\t\t}\n\t\t\tif(t[i]=='+' || t[i]=='-' || t[i]=='*'){\n\t\t\t\tif(!id.empty()) cal[id.top()]++;\n\t\t\t}\n\t\t}\n\t\tif(!id.empty()) ok=false;\n\t\trep(i,t.size()) if(cal[i]<0) ok=false;\n\t\tcout << (ok ? \"valid\" : \"invalid\\n\");\n\t\tif(!ok) continue;\n\t\tState be=t.begin();\n\t\tint h=expr(be);\n\t\tif(be!=t.end()){\n\t\t\tcout << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"     \" << h << endl;\n\t\tans=max(ans,h);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nbool valid(int n) {return 0 <= n && n < 1024;}\nbool valid(string str) {\n  int t = 0;\n  rep (i, str.size()) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) return false;\n    }\n  }\n  return t == 0;\n}\n\nint num(string str) {\n  int n = 0;\n  rep (i, str.size()) {\n    n = n * 2 + str[i] - '0';\n    if (n >= 1024) throw 1;\n  }\n  return n;\n}\n\nint exp(string str) {\n  int n = str.size();\n  if (str[0] == '(') {\n    int t = 0;\n    rep (i, n - 2) {\n      if (str[i] == '(') ++t;\n      if (str[i] == ')') {\n\t--t;\n\tif (t == 0) {\n\t  if (str[i + 1] == '+') {\n\t    int r = exp(str.substr(1, i - 1)) + exp(str.substr(i + 2));\n\t    if (!valid(r)) throw 1;\n\t    return r;\n\t  }\n\t  if (str[i + 1] == '-') {\n\t    int r = exp(str.substr(1, i - 1)) - exp(str.substr(i + 2));\n\t    if (!valid(r)) throw 1;\n\t    return r;\n\t  }\n\t  throw 1;\n\t}\n      }\n    }\n    if (str[str.size() - 1] != ')') throw 1;\n    if (str[1] == '(' && str[str.size() - 1] == ')') if (valid(str.substr(2, str.size() - 4))) throw 1;\n    rep (i, n - 1) if (i != 0 && !isdigit(str[i])) return exp(str.substr(1, str.size() - 2));\n    throw 1;\n  }\n  int d = str.size();\n  rep (i, str.size()) if (!isdigit(str[i])) {\n    d = i;\n    break;\n  }\n  if (d == n) return num(str);\n  if (d == n - 1) throw 1;\n  if (str[d] == '+') {\n    int r = exp(str.substr(0, d)) + exp(str.substr(d + 1));\n    if (!valid(r)) throw 1;\n    return r;\n  }\n  if (str[d] == '-') {\n    int r = exp(str.substr(0, d)) - exp(str.substr(d + 1));\n    if (!valid(r)) throw 1;\n    return r;\n  }\n  throw 1;\n}\n\nconst char c[] = {'0', '1', '+', '-', '*', '(', ')'};\nint solve0(string str, vector<int> dot) {\n  if (dot.size() == 0u) {\n    try {\n      return exp(str);\n    } catch(int n) {\n      return -1;\n    }\n  }\n  int n = dot.back();\n  dot.pop_back();\n  int res = -1;\n  rep (i, 7) {\n    str[n] = c[i];\n    res = max(res, solve0(str, dot));\n  }\n  return res;\n}\n\nint main() {\n  string str;\n  cin >> str;\n  vector<int> dot;\n  rep (i, str.size()) if (str[i] == '.') dot.push_back(i);\n  cout << solve0(str, dot) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\n\nconst string OP = \"01+-*()\";\n\nint expression(const string& s, unsigned int& p);\n\nbool valid(const int n)\n{\n  if (n < 0 || 1024 <= n)\n    return false;\n  return true;\n}\n\nint number(const string& s, unsigned int& p)\n{\n  int ret = 0;\n  while (s[p] == '0' || s[p] == '1') {\n    ret *= 2;\n    ret += (s[p] - '0');\n    ++p;\n  }\n  return ret;\n}\n\nint factor(const string& s, unsigned int& p)\n{\n  if (s[p] == '(') {\n    ++p;\n    int ret = expression(s, p);\n    if (!valid(ret) || s[p] != ')')\n      return -1;\n    ++p;\n    return ret;\n  } else if (s[p] == '0' || s[p] == '1') {\n    return number(s, p);\n  } else {\n    return -1;\n  }\n}\n\nint term(const string& s, unsigned int& p)\n{\n  int lhs = factor(s, p);\n  if (!valid(lhs))\n    return -1;\n\n  while (p < s.size()) {\n    if (s[p] == '*') {\n      ++p;\n      int rhs = factor(s, p);\n      if (!valid(rhs) || !valid(lhs*rhs))\n        return -1;\n      lhs *= rhs;\n    } else {\n      break;\n    }\n  }\n  return lhs;\n}\n\nint expression(const string& s, unsigned int& p)\n{\n  int lhs = term(s, p);\n  if (!valid(lhs))\n    return -1;\n\n  while (p < s.size()) {\n    if (s[p] == '+') {\n      ++p;\n      int rhs = term(s, p);\n      if (!valid(rhs) || !valid(lhs+rhs))\n        return -1;\n      lhs += rhs;\n    } else if (s[p] == '-') {\n      ++p;\n      int rhs = term(s, p);\n      if (!valid(rhs) || !valid(lhs-rhs))\n        return -1;\n      lhs -= rhs;\n    } else {\n      break;\n    }\n  }\n  return lhs;\n}\n\nbool check(const string& s)\n{\n  vector<char> par;\n  for (unsigned int i = 0; i < s.size(); ++i) {\n    if (s[i] == '(') {\n      par.push_back('(');\n    } else if (s[i] == ')') {\n      if (par.empty() || par.back() == '(')\n        return false;\n      par.pop_back();\n      par.pop_back();\n    } else if (!par.empty() && par.back() == '(' && (s[i] == '+' || s[i] == '-' || s[i] == '*')) {\n      par.push_back(s[i]);\n    }\n  }\n\n  if (par.empty())\n    return true;\n  return false;\n}\n\nint solve(unsigned int idx, string& s)\n{\n  if (idx >= s.size()) {\n    if (!check(s))\n      return -1;\n    idx = 0;\n    return expression(s, idx);\n  }\n\n  if (s[idx] == '.') {\n    int ret = -INF;\n    for (unsigned int i = 0; i < OP.size(); ++i) {\n      s[idx] = OP[i];\n      ret = max(ret, solve(idx+1, s));\n      s[idx] = '.';\n    }\n    return ret;\n  } else {\n    return solve(idx+1, s);\n  }\n}\n\nint main()\n{\n  string s;\n  while (cin >> s)\n    cout << solve(0, s) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nstring s;\nconst int limit = (1 << 10);\nint expr(int&);\n\ninline bool out_range(int x) {\n\treturn x < 0 || x >= limit;\n}\n\nint number(int& idx) {\n\tint res = 0;\n\twhile(isdigit(s[idx])) {\n\t\tres <<= 1;\n\t\tif(s[idx] == '1')\n\t\t\tres += 1;\n\n\t\t++idx;\n\t}\n\n\tif(out_range(res))\n\t\tthrow 0;\n\n\treturn res;\n}\n\nint factor(int& idx) {\n\tif(isdigit(s[idx])) {\n\t\treturn number(idx);\n\t}\n\telse if(s[idx] == '(') {\n\t\tint end = ++idx;\n\t\tconst int res = expr(end);\n\t\tif(s[end] != ')')\n\t\t\tthrow 0;\n\n\t\tbool ok = false;\n\t\tint cnt = 0;\n\t\tfor(int i = idx; i < end; ++i) {\n\t\t\tif(s[i] == '(')\n\t\t\t\t++cnt;\n\n\t\t\telse if(s[i] == ')')\n\t\t\t\t--cnt;\n\n\t\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-' || s[i] == '*')) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)\n\t\t\tthrow 0;\n\n\t\tidx = end + 1;\n\t\treturn res;\n/*\n\t\t++idx;\n\t\tint tmp = idx;\n\t\tnumber(tmp);\n\t\tif(s[tmp] == ')')\n\t\t\tthrow 0;\n\n\t\tconst int res = expr(idx);\n\t\tif(s[idx++] != ')')\n\t\t\tthrow 0;\n\n\t\treturn res;\n*/\n\t}\n\telse\n\t\tthrow 0;\n}\n\n\nint term(int& idx) {\n\tint res = factor(idx);\n\twhile(s[idx] == '*') {\n\t\t++idx;\n\t\tres *= factor(idx);\n\t\tif(out_range(res))\n\t\t\tthrow 0;\n\t}\n\n\treturn res;\n}\n\nint expr(int& idx) {\n\tint res = term(idx);\n\twhile(s[idx] == '+' || s[idx] == '-') {\n\t\tif(s[idx++] == '+') {\n\t\t\tres += term(idx);\n\t\t\tif(out_range(res))\n\t\t\t\tthrow 0;\n\t\t}\n\t\telse {\n\t\t\tres -= term(idx);\n\t\t\tif(out_range(res))\n\t\t\t\tthrow 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvector<int> cant_read;\nconst string candidate = \"01+-*()\";\n\nint dfs(int depth = 0) {\n\tif(cant_read.size() == depth) {\n\t\ttry {\n\t\t\tint idx = 0;\n\t\t\tconst int res = expr(idx);\n\t\t\tif(idx != s.size())\n\t\t\t\tthrow 0;\n\n\t\t\treturn res;\n\t\t} catch(...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tint res = -1;\n\tconst int next_depth = depth + 1;\n\n\tfor(int i = 0; i < (int)candidate.size(); ++i) {\n\t\ts[cant_read[depth]] = candidate[i];\n\t\tchmax(res, dfs(next_depth));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < (int)s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tcant_read.push_back(i);\n\n\tcout << dfs(0) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring cs=\"01+-*()\";\nstring s;\nint n;\n\nint f(int l,int r){\n  bool isn=true;\n  repl(i,l,r)if(!isdigit(s[i]))isn=false;\n  if(isn){\n    int res=0;\n    repl(i,l,r){\n      res*=2;\n      res+=s[i]-'0';\n    }\n    if(res>=pow(2,10))return -1;\n    else return res;\n  }\n\n  bool ok=false;\n  {\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(lev==0)ok=true;\n      if(s[i]==')')lev--;\n    }\n  }\n\n  if(!ok){\n    if(s[r-1]!=')')return -1;\n    int lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1||vl+vr>=pow(2,10))return -1;\n        else return vl+vr;\n      }\n    }\n    lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1||vl*vr>=pow(2,10))return -1;\n        else return vl*vr;\n      }\n    }\n  }else{\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1||vl+vr>=pow(2,10))return -1;\n        else return vl+vr;\n      }\n    }\n    lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1||vl*vr>=pow(2,10))return -1;\n        else return vl*vr;\n      }\n    }\n  }\n  return -1;\n}\n\nint dfs(int i){\n  if(i==n){\n    return f(0,n);\n  }else{\n    if(s[i]=='.'){\n      int res=-1;\n      rep(j,7){\n        s[i]=cs[j];\n        int tmp=dfs(i+1);\n        maxch(res,tmp);\n      }\n      s[i]='.';\n      return res;\n    }else{\n      return dfs(i+1);\n    }\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n\ntypedef long long ll;\nusing namespace std;\n\nll MAX = 1<<10;\n\nint chs[] = {'1','0','+','-','*','(',')'};\nint dotpoint[6],dotnum;\n\nint idx=0,pos=0;\nchar str[101];\nchar dot[101];\nint p7[10];\n\nchar peekc(){\n  if(str[pos]=='.')\n    return dot[pos];\n  else \n    return str[pos];\n}\n\nchar readc(){\n  char c=peekc();\n  pos++;\n  return c;\n}\n\nint opcall(char op,int a,int b){\n  if(a==-1||b==-1){\n    return -1;\n  }\n\n  int c;\n  switch(op){\n  case '+':\n    c = a+b;\n    break;\n  case '-':\n    c = a-b;\n    break;\n  case '*':\n    c = a*b;\n  }\n  if(c<0||c>=1024)\n    return -1;\n  else\n    return c;\n}\n\nint read1();\nint read2();\nint read3();\nint readparen();\nint readnum();\nbool flag=false;\n\nint read1(){\n  int l=read2();\n  while(1){\n    char op=peekc();\n    if(op=='+'||op=='-'){\n      flag=true;\n      readc();\n      l=opcall(op,l,read2());\n    }else{\n      break;\n    }\n  }\n  return l;\n}\n\nint read2(){\n  int l=read3();\n  while(1){\n    char op=peekc();\n    if(op=='*'){\n      flag=true;\n      readc();\n      l=opcall(op,l,read2());\n    }else{\n      break;\n    }\n  }\n  return l;\n}\n\nint read3(){\n  if(peekc()=='('){\n    return readparen();\n  }else if(peekc()=='0'||peekc()=='1'){\n    return readnum();\n  }else{\n    return -1;\n  }\n}\n\nint readparen(){\n  readc(); // '('\n  bool flag2=flag;\n  flag=false;\n  int l=read1();;\n  if(flag&&readc()==')'){\n    flag=flag2;\n    return l;\n  }else{\n    return -1;\n  }\n}\n\nint readnum(){\n  int i=0;\n  for(;peekc()=='0'||peekc()=='1';)\n    i=i*2+(readc()-'0');\n  if(i<0||i>=1024)\n    return -1;\n  else\n    return i;\n}\n\nint main(){\n  p7[0]=1;\n  for(int i=1; i<6; i++)\n    p7[i]=7*p7[i-1];\n\n  scanf(\"%s\",str);\n\n  dotnum=0;\n  for(int i=0; str[i]; i++){\n    if(str[i]=='.'){\n      dotpoint[dotnum++]=i;\n    }\n  }\n\n  int ans=-1;\n  for(int stat=0; stat<p7[dotnum]; stat++){\n    for(int j=0; j<dotnum; j++){\n      dot[dotpoint[j]]=chs[(stat/p7[j])%7];\n    }\n    pos=0;\n    int ret=read1();\n    if(str[pos]==0)\n      ans=(ans<ret)?ret:ans;\n  }\n\n  printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* 再帰下降法 */\n// char *p = str; res = expr(p);\n\nint term(char* &s);\nint number(char* &s);\nint factor(char* &s);\nint expr(char* &s);\n\nconst int LIMIT = 1 << 10;\n\n//数\nint number(char* &s){\n  if (!*s) throw \"number\";\n\n  int res = 0;\n  while('0' <= *s && *s <= '9')\n    res = res*2 + (*s++ - '0');\n\n  if (*s == '(') throw \"number\";\n\n  if (res < 0 || LIMIT <= res)\n    throw \"number\";\n\n  return res;\n}\n\n//乗算除算(優先順位:高)\nint term(char* &s){\n  if (!*s) throw \"term\";\n\n  int res = factor(s);\n  while(1){\n    if(*s == '*') res *= factor(++s);\n    else if(*s == '/') res /= factor(++s);\n    else break;\n\n    if (res < 0 || LIMIT <= res)\n      throw \"term\";\n  }\n\n  if (res < 0 || LIMIT <= res)\n    throw \"term\";\n\n  return res;\n}\n\n//括弧か数\nint factor(char* &s){\n  if (!*s) throw \"factor\";\n  if (!isdigit(*s) && *s != '(') throw \"factor\";\n\n  if(*s != '(') return number(s);\n  int res = expr(++s);\n\n  if (!*s) throw \"factor\";\n\n  s++;\n\n  if (res < 0 || LIMIT <= res)\n    throw \"factor\";\n\n  return res;\n}\n\n//式(優先順位: 低)\nint expr(char* &s){\n  if (!*s) throw \"expr\";\n\n  int res = term(s);\n  while(1){\n    if(*s == '+') res += term(++s);\n    else if(*s == '-') res -= term(++s);\n    else break;\n\n    if (res < 0 || LIMIT <= res)\n      throw \"term\";\n  }\n\n  if (res < 0 || LIMIT <= res)\n    throw \"expr\";\n\n  return res;\n}\n\nbool check(string s) {\n  stack<int> st;\n\n  for (int i=0; i<s.size(); i++) {\n    switch (s[i]) {\n    case '(':\n      st.push(1);\n      break;\n    case ')': {\n      if (st.empty()) return false;\n      if (st.top() > 0) return false;\n      while(st.size() && st.top() < 0) st.pop();\n      if (st.empty()) return false;\n      st.pop();\n    }\n      break;\n    case '0':\n    case '1':\n      break;\n    default:\n      st.push(-1);\n      break;\n    }\n  }\n\n  while(st.size() && st.top() < 0)\n    st.pop();\n\n  return st.empty();\n}\n\n\nint calc(string s2) {\n  if (!check(s2)) return -1;\n\n  char s[1000];\n  strcpy(s, s2.c_str());\n  char *p = s;\n\n  try{\n    int res = expr(p);\n\n    if (*p) return -1;\n\n    return res;\n\n  }catch(...){\n\n    return -1;\n  }\n}\n\nint main(){\n  string str;\n\n  cin >> str;\n\n  vector<int> dots;\n\n  for (int i=0; i<str.size(); i++)\n    if (str[i] == '.') dots.push_back(i);\n\n  int ans = -1;\n\n  int limit = 7 * 7 * 7 * 7 * 7;\n  for (int i=0; i<limit; i++) {\n    int tmp = i;\n\n    for (int p : dots) {\n      str[p] = \"01+-*()\"[tmp % 7];\n      tmp /= 7;\n    }\n\n    int res = calc(str);\n    if (ans < res) {\n      debug(str); debug(res);\n    }\n\n    ans = max(ans, res);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int MAX = 1023;\n/*\n\t<expression> ::= <number> | <expression> <operation> <expression>\n\t| ( <expression> <operation> <expression> )\n\t<number> ::= <digit> | <number> <digit>\n\t<operation> ::= + | - | *\n\t<digit> ::= 0 | 1\n*/\nstruct Parser {\n\tusing Iter = string::const_iterator;\n\tconst char kTerminator = '$';\n\tstring s;\n\tIter it;\n\tParser(const string &t) :s(t) { s += kTerminator; it = s.begin(); }\n\tvoid cmp(char expected) {\n\t\tif (*it != expected) {\n\t\t\tthrow 0;\n\t\t\tcerr << *it << \" is not \" << expected << endl;\n\t\t}\n\t}\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == '+') {\n\t\t\t\tit++;\n\t\t\t\tret += b();\n\t\t\t}\n\t\t\telse if (*it == '-') {\n\t\t\t\tit++;\n\t\t\t\tret -= b();\n\t\t\t}\n\t\t\telse break;\n\t\t\tif (ret > MAX || ret < 0)\n\t\t\t\tthrow 0;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == '*') {\n\t\t\t\tit++;\n\t\t\t\tret *= c();\n\t\t\t}\n\t\t\telse break;\n\t\t\tif (ret > MAX || ret < 0)\n\t\t\t\tthrow 0;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\tif (ret > MAX || ret < 0)\n\t\t\tthrow 0;\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 2;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t\tif (ret > MAX)\n\t\t\t\tthrow 0;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nbool isOp(char c) {\n\treturn c == '+' || c == '-' || c == '*';\n}\n\nstruct Parser2 {\n\tusing Iter = string::const_iterator;\n\tconst char kTerminator = '$';\n\tstring s;\n\tIter it;\n\tParser2(const string &t) :s(t) { s += kTerminator; it = s.begin(); }\n\tvoid cmp(char expected) {\n\t\tif (*it != expected) {\n\t\t\tthrow 0;\n\t\t\tcerr << *it << \" is not \" << expected << endl;\n\t\t}\n\t}\n\tbool a() {\n\t\tIter it2 = it;\n\t\tstack<int> st;\n\t\twhile (*it != kTerminator) {\n\t\t\tif (st.size() && isOp(*it))\n\t\t\t\tst.push(*it);\n\t\t\telse if (*it == '(') {\n\t\t\t\tst.push(*it);\n\t\t\t}\n\t\t\telse if (*it == ')') {\n\t\t\t\tif (st.empty())\n\t\t\t\t\treturn true;\n\t\t\t\tif (st.top() == '(')\n\t\t\t\t\treturn true;\n\t\t\t\twhile (st.top() != '(') {\n\t\t\t\t\tst.pop();\n\t\t\t\t\tif (st.empty())\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t\tif (st.size())return true;\n\t\treturn false;\n\t}\n};\n\nvector<int> powerArray(int p, int n) {\n\tvector<int> power(n + 1); power[0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tpower[i + 1] = power[i] * p;\n\treturn power;\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\n\tvector<int> idx;\n\trep(i, 0, s.size()) {\n\t\tif (s[i] == '.')\n\t\t\tidx.push_back(i);\n\t}\n\tint cnt = idx.size();\n\n\tchar c[7] = { '0','1','+','-','*','(',')' };\n\tvector<int> pow7 = powerArray(7, cnt);\n\tint ans = -1;\n\trep(mask, 0, pow7[cnt]) {\n\t\trep(i, 0, cnt)\n\t\t\ts[idx[i]] = c[mask / pow7[i] % 7];\n\t\ttry {\n\t\t\tParser parser(s);\n\t\t\tParser2 parser2(s);\n\n\t\t\tfor (int i = 0; i < (int)s.size() - 1; i++) {\n\t\t\t\tif (isOp(s[i]) && isOp(s[i + 1]))\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (s[i] == ')' && s[i + 1] == '(')\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (s[i] == '(' && isOp(s[i + 1]))\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (s[i] == ')' && isdigit(s[i + 1]))\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (isOp(s[i]) && s[i + 1] == ')')\n\t\t\t\t\tthrow 0;\n\t\t\t\tif (isdigit(s[i]) && s[i + 1] == '(')\n\t\t\t\t\tthrow 0;\n\t\t\t}\n\t\t\tif (isOp(s.front()) || isOp(s.back()))\n\t\t\t\tthrow 0;\n\n\t\t\tdump(s);\n\t\t\tif (parser2.a())\n\t\t\t\tthrow 0;\n\t\t\tint res = parser.a();\n\t\t\tif (res > MAX || res < 0)\n\t\t\t\tthrow 0;\n\t\t\tchmax(ans, res);\n\t\t\tdump(ans);\n\t\t}\n\t\tcatch (...) {\n\t\t\t//dump(\"error\");\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\nbool isd(string s){return isdigit(s[0]);}\n\nstring calc(vs s){\n    stack<int> p;\n    for(int i=0;i<s.size();i++){\n        if(s[i]==\"(\")p.push(i);\n        else if(s[i]==\")\"){\n            int f=p.top(); p.pop();\n            vs tmp;\n            s[f]=s[i]=\"-1\";\n            for(int j=f+1;j<i;j++){\n                tmp.pb(s[j]);\n                s[j]=\"-1\";\n            }\n            s[f]=calc(tmp);\n        }\n    }\n    auto itr=remove(all(s),\"-1\");\n    s.erase(itr,s.end());\n    \n    //for(auto c:s)cout<<c<<\"      \";\n    \n    deque<int> oper;\n    deque<string> opec;\n    for(int i=0;i<s.size();i++){\n        if(isd(s[i])){\n            oper.pb(stoi(s[i]));\n        }else{\n            if(s[i]==\"*\"){\n                oper.back()*=stoi(s[++i]);\n                if(oper.back()<0 || oper.back()>1023) return \"-1\";\n            }else opec.pb(s[i]);\n        }\n    }\n    while(!opec.empty()){\n        int d=oper[0];\n        string c=opec[0];\n        oper.pop_front();\n        opec.pop_front();\n        oper.front()=(c==\"+\" ? d+oper.front() : d-oper.front());\n        if(oper.front()<0 || oper.front()>1023) return \"-1\";\n    }\n    //cout<<\"ans:\"<<to_string(oper[0])<<endl;\n    return to_string(oper[0]);\n}\n\n\nstring solve(string in){\n    vector<string> s;\n    bool ren=false;\n    for(auto c:in){\n        if(c=='0' || c=='1'){\n            if(ren){\n                s.back()+=c;\n            }else s.pb(\"\"s+c);\n            ren=true;\n        } else {\n            s.pb(\"\"s+c);\n            ren=false;\n        }\n    }\n    int dep=0;\n    for(int i=0;i<s.size();i++){\n        string &c=s[i];\n        if(c.length()>30){\n            return \"-1\";\n        }else{\n            try{\n                int p=stoi(c,nullptr,2);\n                c=to_string(p);\n            }catch(...){\n                if(c==\"(\")dep++;\n                else if(c==\")\")dep--;\n                if(dep<0 || dep>25)return \"-1\";\n            }\n        }\n    }\n    if(dep)return \"-1\";\n    int exist=0,depth=0;\n    for(int i=0;i<s.size()-1;i++){\n        if(isd(s[i])){\n            if(s[i+1]==\"(\" || isd(s[i+1])) return \"-1\";\n        }else if(s[i]==\"(\"){\n            depth++;\n            if(s[i+1]==\"+\" || s[i+1]==\"-\" || s[i+1]==\"*\" || s[i+1]==\")\") return \"-1\";\n        }else if(s[i]==\")\"){\n            cout<<depth<<\",\"<<exist<<endl;\n            if((exist&(1<<depth))==0) return \"-1\";\n            depth--;\n            if(isd(s[i+1]) || s[i+1]==\"(\") return \"-1\";\n        }else{\n            exist|=(1<<depth);\n            if(s[i+1]!=\"(\" && !isd(s[i+1])) return \"-1\";\n        }\n    }\n    if(s.back()==\")\"){\n        //cout<<depth<<\",\"<<exist<<endl;\n        if((exist&(1<<depth))==0) return \"-1\";\n    }\n    int t=s.size()-1;\n    if(s[0]==\")\" || s[0]==\"+\" || s[0]==\"-\" || s[0]==\"*\") return \"-1\";\n    if(s[t]==\"(\" || s[t]==\"+\" || s[t]==\"-\" || s[t]==\"*\") return \"-1\";\n    //ここまでで除去ができているはず\n    //for(auto c:s)cout<<c<<\"    \";cout<<endl;\n    return calc(s);\n}\n\nint bur(string s){\n    int ans=-1;\n    if(count(all(s),'.')==0) {\n        //cout<<s<<endl;\n        return stoi(solve(s));\n    }\n    for(auto d:\"01+-*()\"s){\n        string os=s;\n        os[s.find('.')]=d;\n        ans=max(ans,bur(os));\n    }\n    return ans;\n}\n\nint main(){\n    string o;\n    cin>>o;\n    cout<<bur(o)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n\n  return true;\n}\n\nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n\n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n\n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true; \n  }\n  return false;\n}\n\nbool isvalid(string s){\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n\nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n\nint get(string s){\n  //  cout << \"S \" << s << endl;\n \n  if(isnum(s)) return tob(s);\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return get(s.substr(0,i))+get(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return get(s.substr(0,i))-get(s.substr(i+1));\n    }\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return get(s.substr(0,i))*get(s.substr(i+1));\n    }\n  }\n}\n\nvoid solve(int n){\n\n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n    if(isvalid(in)) ans = max(ans,get(in));\n    \n  }\n}\n\nint main(){\n\n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n\n  solve(0);\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')')return false;\n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    assert(s[i] != '.');\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(!(0<= p && p < 1024))return FAILED;\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' == parse[pos] || parse[pos] == '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(p);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(s[p]=='*') res*=calc();\n  }\n  if(res<0||res>=1024) flg=0;\n  return res;\n}\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(p+1);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n    if(res<0||res>=1024) flg=0;\n  }\n  if(!flg)res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nstring s;\nconst int limit = (1 << 10);\n\nint expr(int&);\n\ninline bool out_range(int x) {\n\treturn x < 0 || x >= limit;\n}\n\nint number(int& idx) {\n\tint res = 0;\n\twhile(isdigit(s[idx])) {\n\t\tres <<= 1;\n\t\tif(s[idx] == '1')\n\t\t\tres += 1;\n\n\t\t++idx;\n\t}\n\n\tif(out_range(res))\n\t\tthrow 0;\n\n\treturn res;\n}\n\nint factor(int& idx) {\n\tif(isdigit(s[idx])) {\n\t\treturn number(idx);\n\t}\n\telse if(s[idx] == '(') {\n\t\tint end = ++idx;\n\t\tconst int res = expr(end);\n\t\tif(s[end] != ')')\n\t\t\tthrow 0;\n\n\t\tbool ok = false;\n\t\tint cnt = 0;\n\t\tfor(int i = idx; i < end; ++i) {\n\t\t\tif(s[i] == '(')\n\t\t\t\t++cnt;\n\n\t\t\telse if(s[i] == ')')\n\t\t\t\t--cnt;\n\n\t\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-' || s[i] == '*')) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)\n\t\t\tthrow 0;\n\n\t\tidx = end + 1;\n\t\treturn res;\n\t}\n\telse\n\t\tthrow 0;\n}\n\n\nint term(int& idx) {\n\tint res = factor(idx);\n\twhile(s[idx] == '*') {\n\t\t++idx;\n\t\tres *= factor(idx);\n\t\tif(out_range(res))\n\t\t\tthrow 0;\n\t}\n\n\treturn res;\n}\n\nint expr(int& idx) {\n\tint res = term(idx);\n\twhile(s[idx] == '+' || s[idx] == '-') {\n\t\tif(s[idx++] == '+') {\n\t\t\tres += term(idx);\n\t\t\tif(out_range(res))\n\t\t\t\tthrow 0;\n\t\t}\n\t\telse {\n\t\t\tres -= term(idx);\n\t\t\tif(out_range(res))\n\t\t\t\tthrow 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvector<int> cant_read;\nconst string candidate = \"01+-*()\";\n\nint dfs(int depth = 0) {\n\tif(cant_read.size() == depth) {\n\t\ttry {\n\t\t\tint idx = 0;\n\t\t\tconst int res = expr(idx);\n\t\t\tif(idx != s.size())\n\t\t\t\tthrow 0;\n\n\t\t\treturn res;\n\t\t} catch(...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tint res = -1;\n\tconst int next_depth = depth + 1;\n\n\tfor(int i = 0; i < (int)candidate.size(); ++i) {\n\t\ts[cant_read[depth]] = candidate[i];\n\t\tchmax(res, dfs(next_depth));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < (int)s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tcant_read.push_back(i);\n\n\tcout << dfs(0) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nchar ln[7]={'0','1','+','-','*','(',')'};\nint n=0,ans=-1;\nint p[5]={};\nint ind[5]={};\nstring s,t;\nmap<int,int> mp;\n\nstring f(string a){\n  if(a==\"+\" || a==\"-\" || a==\"*\" || a==\"(\" || a==\")\")return a;\n  reverse(a.begin(),a.end());\n  int res=0;\n  for(int i=0;i<a.length();i++)res+=(pow(2,i)*(a[i]-'0'));\n  ostringstream os;\n  os<<res;\n  return os.str();\n}\n\nint cal(vector<string> v){\n  if(v.empty())return -1;\n  vector<string> vs1,vs2,vs3;\n  for(int i=0;i<v.size();i++){\n    if(v[i]==\"(\"){\n      vector<string> tmp;\n      int l=1,r=0;\n      for(int j=i+1;j<v.size();j++){\n\tif(v[j]==\"(\")l++;\n\tif(v[j]==\")\")r++;\n\tif(r==l){\n\t  i=j;\n\t  break;\n\t}\n\ttmp.push_back(v[j]);\n      }\n      int res=cal(tmp);\n      if(res==-1 || 1024<=res)return -1;\n      ostringstream os;\n      os<<res;\n      vs1.push_back(os.str());\n    }\n    else vs1.push_back(v[i]);\n  }\n  if(vs1[0]==\"+\" || vs1[0]==\"*\" || vs1[0]==\"-\")return -1;\n  int size=vs1.size()-1;\n  if(vs1[size]==\"+\" || vs1[size]==\"*\" || vs1[size]==\"-\")return -1;\n  for(int i=0;i<vs1.size();i++){\n    if(vs1[i]==\"*\"){\n      if('0'<=vs1[i+1][0] && vs1[i+1][0]<='9' && '0'<=vs2.back()[0] && vs2.back()[0]<='9' ){\n\tint tmp1=atoi(vs2.back().c_str()),tmp2=atoi(vs1[i+1].c_str());\n\tvs2.pop_back();\n\tostringstream os;\n\tos<<(tmp1*tmp2);\n\tif(1024<=tmp1*tmp2)return -1;\n\tvs2.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs2.push_back(vs1[i]);\n  }\n  for(int i=0;i<vs2.size();i++){\n    if(vs2[i]==\"+\" || vs2[i]==\"-\"){\n      string tmp=vs3.back();\n      if('0'<=vs2[i+1][0] && vs2[i+1][0]<='9' && '0'<=tmp[0] && tmp[0]<='9' ){\n\tint tmp1=atoi(tmp.c_str()),tmp2=atoi(vs2[i+1].c_str());\n\tvs3.pop_back();\n\tostringstream os;\n\tint res;\n\tif(vs2[i]==\"+\")res=(tmp1+tmp2);\n\tif(vs2[i]==\"-\")res=(tmp1-tmp2);\n\tif(res<0 || 1024<=res)return -1;\n\tos<<res;\n\tvs3.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs3.push_back(vs2[i]);\n  }\n  if(vs3.size()==1 && '0'<=vs3[0][0] && vs3[0][0]<='9')return atoi(vs3[0].c_str());\n  return -1;\n}\n\nvoid rec(int v){\n  if(v==n){\n    t=s;\n    for(int i=0;i<n;i++)t[ind[i]]=ln[p[i]];\n    string tmp=\"\";\n    vector<string> vs;\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='0' || t[i]=='1')tmp+=t[i];\n      else {\n\tif(tmp!=\"\")vs.push_back(tmp);\n\ttmp=\"\";\n\tstring st=\"\";\n\tst+=t[i];\n\tvs.push_back(st);\n      }\n    }\n    if(tmp!=\"\")vs.push_back(tmp);\n    stack<int> st;\n    for(int i=0;i<vs.size();i++){\n      if(vs[i]==\"(\")st.push(i);\n      if(vs[i]==\")\"){\n        if(st.empty())return;\n        st.pop();\n      }\n    }\n    if(!st.empty())return;\n    for(int i=1;i<vs.size()-1;i++){\n      if((vs[i][0]=='0' || vs[i][0]=='1') && vs[i-1]==\"(\" && vs[i+1]==\")\")return;\n    }\n    for(int i=0;i<vs.size();i++)vs[i]=f(vs[i]);\n    int res=cal(vs);\n    ans=max(ans,res);\n  }\n  else {\n    for(int i=0;i<7;i++){\n      rec(v+1);\n      p[v]++;\n    }\n    p[v]=0;\n  }\n}\n\nint main()\n{\n  cin>>s;\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='.'){\n      ind[n]=i;\n      n++;\n    }\n  }\n  rec(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\nll N;\nchar S[111];\n\n#define INF (-(1<<20))\n\nll number(ll l,ll r){\n  ll ret = 0;\n  if( r - l + 1 > 10 ) return INF;\n  for(ll i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n  }\n \n  return ret;\n}\n\n\nll check(ll x){\n  if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  return INF;\n}\n\nll check(ll a,ll b,char op){\n  if( 0LL <= a && a < (1LL<<10LL) && 0LL <= b && b < (1LL<<10LL)){ \n    ll x;\n    if( op == '+' )\n      x = a+b;\n    if( op == '-' )\n      x = a-b;\n    if( op == '*' )\n      x = a * b;\n    if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  }\n  return INF;\n}\n\nbool check_n(ll l,ll r){\n  for(ll i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return false;\n  }\n  return true;\n}\nbool check_k2(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt > 0 ) return false;\n  }\n  if( cnt == 0 ) return true;\n  return false;\n}\n\n\nbool check_k(ll l,ll r){\n  ll cnt =0;\n  if( l==r ) return false;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n\nbool check_m(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n\nbool check_w(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n\n\nvoid view(ll l,ll r){\n  for(ll i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n\nbool check_h(ll l,ll r){\n  if( S[l] == '+' || S[r] == '+' || S[l] == '-' || S[r] == '-' || S[l] == '*' || S[r] == '*' ||  S[l] == ')' || S[r] == '(' ) return true;\n  if( l > r ) return true;\n  return false;\n}\n\nll exp(ll l,ll r){\n  //view(l,r);\n  if( check_h(l,r) ) return INF;\n  if( !check_k2(l,r) ) return INF;\n  if( check_k(l,r) ) {\n    if( check_n(l+1,r-1) ) return INF;\n    return check(exp(l+1,r-1));\n  }\n  if( check_w(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return check(exp(l,i-1), exp(i+1,r),'+');\n      if( cnt == 0 && S[i] == '-' ) return check(exp(l,i-1), exp(i+1,r),'-');\n    }\n  }\n  if( check_m(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return check(exp(l,i-1), exp(i+1,r),'*');\n    }\n  }\n  if( check_n(l,r) )\n    return check(number(l,r));\n  return INF;\n}\n\nint main(){\n  cin >> S;\n  N  = strlen(S);\n  ll M = 0;\n  for(ll i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  ll res = -1;\n  ll K=1;\n  for(ll i=0;i<M;i++) K*=7;\n  for(ll i=0;i<K;i++){\n    ll c = i;\n    strcpy( S, buf );\n    for(ll j=0;j<N;j++){\n      if( S[j] == '.' ){\n\tif( c%7 == 0 ) S[j] = '0';\n\tif( c%7 == 1 ) S[j] = '1';\n\tif( c%7 == 2 ) S[j] = '+';\n\tif( c%7 == 3 ) S[j] = '-';\n\tif( c%7 == 4 ) S[j] = '*';\n\tif( c%7 == 5 ) S[j] = '(';\n\tif( c%7 == 6 ) S[j] = ')';\t\t\n\tc/=7;\n      }    \n    }\n   \n    res = max( res, exp(0,N-1) );\n    \n  }\n  cout << res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool is_num(char x){return x=='0' || x=='1';}\n\nbool valid_num(int x){\n  const int SUP=1024;\n  return 0<=x && x<SUP;\n}\n\nint calc(int lhs,int rhs,char op){\n  int res;\n  if(op=='+'){\n    res=lhs+rhs;\n  }else if(op=='-'){\n    res=lhs-rhs;\n  }else if(op=='*'){\n    res=lhs*rhs;\n  }else{\n    throw \"calc\";\n  }\n  if(!valid_num(res)) throw \"invalid\";\n  return res;\n}\n\nint formula(int &p);\nint formulap(int &p);\nint term1(int &p);\npair<int,bool> term1p(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint formula(int &p){\n  int res=term1(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formula\";\n    int rhs=term1(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\nint formulap(int &p){\n  bool isok=false;\n  auto ret=term1p(p);\n  isok|=ret.second;\n  int res=ret.first;\n  if(p>=s.size()) throw \"AHO\";\n  while(s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formulap_op\";\n    isok=true;\n    int rhs=term1p(p).first;\n    res=calc(res,rhs,op);\n      if(p>=s.size()) throw \"AHO\";\n  }\n\n  if(!isok) throw \"formulap_isok\";\n  return res;\n}\n\nint term1(int& p){\n  int res=term2(p);\n  while(p<s.size() && (s[p]!='+' && s[p]!='-')){\n    char op=s[p];\n    p++;\n    if(op!='*') throw \"term1_op\";\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\npair<int,bool> term1p(int &p){\n  int res=term2(p);\n  bool isop=false;\n  if(p>=s.size()) throw \"AHO\";\n  while(s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;    \n    if(op!='*') throw \"term1p\";\n    isop=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n    if(p>=s.size()) throw \"AHO\";\n  }\n  return {res,isop};\n}\n\nint term2(int& p){\n  if(s[p]=='('){\n    p++;\n    int res=formulap(p);\n    if(p>=s.size() || s[p]!=')') throw \"term2\";\n    p++;\n    return res;\n  }else if(is_num(s[p])){\n    int res=get_num(p);\n    return res;\n  }else throw \"term2\";\n}\n\nint get_num(int& p){\n  int res=0;\n  while(p<s.size() && is_num(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nint dfs(int i){\n  if(i==s.size()){\n    int res=-1;\n     try{\n       int p=0;\n       res=formula(p);\n     }catch(const char* &e){\n       return -1;\n     }\n     return res;\n  }\n  else if(s[i]=='.'){\n    const string ch=\"01+-*()\";\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      int ret=dfs(i+1);\n      res=max(ret,res);\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstring s;\nint n;\nchar c[7] = {'0','1','+','-','*','(',')'};\nconst int up = 1<<10;\n\nint parse(int l,int r,int p){\n  if(r<=l)return -1;\n  int k=0,a,b;\n  for(int i=r-1;i>=l;i--){\n    if(s[i]=='(')k++;\n    else if(s[i] == ')')k--;\n    if(k>0)return -1;\n    if(!k){\n      if(s[i] == '+'){\n\ta = parse(l,i,0); b = parse(i+1,r,0);\n\tif(a<0 || b<0 || up<=a || up<=b || a+b<0 || up<=a+b)return -1;\n\treturn a+b;\n      }else if(s[i] == '-'){\n\ta = parse(l,i,0); b = parse(i+1,r,0);\n\tif(a<0 || b<0 || up<=a || up<=b || a-b<0 || up<=a-b)return -1;\n\treturn a-b;\n      }\n    }\n  }\n  if(k)return -1;\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i]=='(')k++;\n    else if(s[i] == ')')k--;\n    if(!k && s[i] == '*'){\n      a = parse(l,i,0); b = parse(i+1,r,0);\n      if(a<0 || b<0 || up<=a || up<=b || a*b<0 || up<=a*b)return -1;\n      return a*b;Darsein\n    }\n  }\n\n  if(p)return -1;\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1,1);\n\n  int res = 0;\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '1'){\n      if(r-1-i>=10)return -1;\n      else res += 1 << (r-1-i);\n    }\n  }\n  return res;\n}\n\nint rec(int pos){\n  int i,res = -1;\n  for(i=pos;i<n;i++){\n    if(s[i] == '.'){\n      for(int j=0;j<7;j++){\n\ts[i] = c[j];\n\tres = max(res,rec(i+1));\n      }\n      s[i] = '.'; break;\n    }\n  }\n  \n  if(i==n)return parse(0,n,0);\n  else return res;\n}\n\nint main(){\n  cin >> s; n = s.size();\n  cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, char *> P;\n\nint cs[] = {'0', '1', '+', '-', '*', '(', ')'};\n\nP fact(char *p);\nP term(char *p);\nP expr(char *p);\n\nP fact(char *p){\n  if(isdigit(*p)){\n    int t = *(p++) - '0';\n    while(isdigit(*p)) t = t * 2 + *(p++) - '0';\n    return P(t, p);\n  } else if(*p == '('){\n    P r = expr(p + 1);\n    if(*r.second != ')') exit(0); //閉じ括弧が無いエラー\n    return P(r.first, r.second + 1);\n  } else{\n    exit(0); //括弧でも数字でもないエラー\n  }\n}\n\nP term(char *p){\n  P r = fact(p);\n  while(*r.second == '*' || *r.second == '/'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = fact(r.second + 1);\n    if(op == '*') r.first *= tmp;\n    else r.first /= tmp;\n  }\n  return r;\n}\n\nP expr(char *p){\n  P r = term(p);\n  while(*r.second == '+' || *r.second == '-'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = term(r.second + 1);\n    if(op == '+') r.first = tmp + r.first;\n    else r.first = tmp - r.first;\n  }\n  return r;\n}\n\nbool is_digit(string s){\n  if(s == \"0\" || s == \"1\") return true;\n  return false;\n}\n\nbool is_operation(string s){\n  if(s == \"+\" || s == \"-\" || s == \"*\") return true;\n  return false;\n}\n\nbool is_number(string s){\n  if(is_digit(s) || ((int)s.length() >= 2 && is_number(s.substr(0, (int)s.length() - 1)) && is_digit(s.substr(s.length() - 1)))) return true;\n  return false;\n}\n\nbool is_expression(string s);\n\nbool is_inner_expression(string s){\n  FOR(i, 1, (int)s.length() - 1) if(is_operation(s.substr(i, i)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))) return true;\n  return false;\n}\n\nbool is_expression(string s){\n  if((int)s.length() >= 2 && s[0] == '(' && s[(int)s.length() - 1] == ')') return is_inner_expression(s.substr(1, (int)s.length() - 2));\n  if(is_number(s)) return true;\n  FOR(i, 1, (int)s.length() - 1) if(is_operation(s.substr(i, i)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))) return true;\n  return false;\n}\n\nint solve(int cnt, vector<int> &v, char *s){\n  if(cnt >= (int)v.size()){\n    //cout <<s <<\", \" <<is_expression(s) <<endl;\n    if(!is_expression(s)) return -1;\n    int res = expr(s).first;\n    return res >= 0 && res <= 1024 ? res : -1;\n  }\n  int res = -1;\n  REP(i, 7){\n    s[v[cnt]] = cs[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  return res;\n}\n\nint main() {\n  char s[110];\n  cin >>s;\n  int sl = strlen(s);\n  vector<int> v;\n  REP(i, sl) if(s[i] == '.') v.push_back(i);\n  cout <<solve(0, v, s) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res -= term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nbool h;\nint out=-1;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*2+*(i++)-'0';\n\tif(out<0||out>=1024)h=false;\n\treturn out;\n}\nint valid(string s){\n\tint n=s.size();\n\tvi co(100);\n\tint cnt=0;\n\trep(t,s.size()){\n\t\tif(s[t]=='('){\n\t\t\tcnt++;\n\t\t\tco[cnt]=0;\n\t\t}else if(s[t]==')'){\n\t\t\tif(!co[cnt])return 0;\n\t\t\tcnt--;\n\t\t\tif(cnt<0)return 0;\n\t\t}else if(s[t]=='+'||s[t]=='-'||s[t]=='*'){\n\t\t\tco[cnt]++;\n\t\t\tif(t==0||t==n-1)return 0;\n\t\t\tif(!isdigit(s[t-1])&&s[t-1]!=')'||!isdigit(s[t+1])&&s[t+1]!='(')return 0;\n\t\t}\n\t}\n\treturn !cnt;\n}\nstring w=\"01+-*()\";\nstring s;\nvoid dfs(){\n\trep(i,s.size())if(s[i]=='.'){\n\t\trep(j,w.size()){\n\t\t\ts[i]=w[j];\n\t\t\tdfs();\n\t\t\ts[i]='.';\n\t\t}\n\t\treturn;\n\t}\n\tif(!valid(s))return;\n\tState begin=s.begin();\n\th=true;\n\tint a=expr(begin);\n\tif(h)out=max(out,a);\n}\nint main(){\n\tcin>>s;\n\tdfs();\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 9999999\n\n\nvector<string> toRPN(string s){\n    stack<string> ope;\n    vector<string> ret;\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ){\n            string tmp=\"\";\n            for(int j=i;j<len;j++){\n                if( isdigit(s[j]) )tmp+=s[j];\n                else break;\n            }\n            ret.push_back(tmp);\n            i+=tmp.size()-1;\n            \n        }else{\n            if( s[i]=='(' )ope.push(\"(\");\n            \n            else if( s[i]==')' ){\n                if( ope.empty() )return {\"invalid\"};\n                if( ope.top()==\"(\" )return {\"invalid\"};\n                \n                while( ope.top()!=\"(\" ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                    \n                    if( ope.empty() )return {\"invalid\"};\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" || ope.top()==\"+\" || ope.top()==\"-\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n            }\n        }\n    }\n    while( ope.size() ){\n        ret.push_back( ope.top() );\n        ope.pop();\n    }\n    \n    return ret;\n}\n\n\nint toDeci(string s){\n    int ret=0;\n    for(int i=0;i<s.size();i++){\n        if( s[ s.size()-i-1 ]=='1' ){\n            ret+=1<<i;\n        }\n        if(ret>=1024)return 9999;\n    }\n    return ret;\n}\n\n\n\nint solveRPN(vector<string> s){\n    stack<int> stk;\n    \n    \n    for(int i=0;i<s.size();i++){\n        if( (s[i]!=\"+\" && s[i]!=\"-\" && s[i]!=\"*\" && s[i]!=\"/\") )stk.push( toDeci(s[i])  );\n        else{\n            if(stk.size()<2)return -1;\n\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            if(s[i]==\"+\")stk.push(a+b);\n            if(s[i]==\"-\")stk.push(a-b);\n            if(s[i]==\"*\")stk.push(a*b);\n            if(s[i]==\"/\")stk.push(a/b);\n        }\n        if( stk.top() <0 || 1024<=stk.top() )return -1;\n    }\n    \n    if( stk.size()>1 )return -1;\n    return stk.top();\n}\n\n\nvi dot;\nint maxi=-INF;\n\n\nint solve(string s){\n    vector<string> poland=toRPN(s);\n    \n    if(poland[0]==\"invalid\")return -INF;\n    \n    int result=solveRPN(poland);\n    \n    if(result==-1)return -INF;\n    else return result;\n}\n\n\nvoid dfs(string s,int flor){\n    if(flor>=dot.size()){\n        cout<<s<<endl;\n        maxi=max( maxi , solve(s) );\n        return ;\n    }\n    \n    char ch[]={'0','1','+','-','*','(',')'};\n    rep(i,7){\n        s[ dot[flor] ] = ch[i];\n        dfs(s,flor+1);\n        s[ dot[flor] ] = '.';\n    }\n}\n\n\nint main(){\n    string s;\n    cin>>s;\n    \n    rep(i,s.size()) if(s[i]=='.')dot.pb(i);\n    \n    dfs(s,0);\n    \n    if( maxi==-INF )cout<<\"-1\"<<endl;\n    else cout<<maxi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\nll N;\nchar S[111];\n\n#define INF (-(1<<20))\n\nll number(ll l,ll r){\n  ll ret = 0;\n  for(ll i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n  }\n \n  return ret;\n}\n\n\nll check(ll x){\n  if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  return INF;\n}\n\nll check(ll a,ll b,char op){\n  if( 0LL <= a && a < (1LL<<10LL) && 0LL <= b && b < (1LL<<10LL)){ \n    ll x;\n    if( op == '+' )\n      x = a+b;\n    if( op == '-' )\n      x = a-b;\n    if( op == '*' )\n      x = a * b;\n    if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  }\n  return INF;\n}\n\nbool check_n(ll l,ll r){\n  for(ll i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return false;\n  }\n  return true;\n}\nbool check_k2(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt > 0 ) return false;\n  }\n  if( cnt == 0 ) return true;\n  return false;\n}\n\n\nbool check_k(ll l,ll r){\n  ll cnt =0;\n  if( l==r ) return false;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n\nbool check_m(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n\nbool check_w(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n\n\nvoid view(ll l,ll r){\n  for(ll i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n\nbool check_h(ll l,ll r){\n  if( S[l] == '+' || S[r] == '+' || S[l] == '-' || S[r] == '-' || S[l] == '*' || S[r] == '*' ||  S[l] == ')' || S[r] == '(' ) return true;\n  if( l > r ) return true;\n  return false;\n}\n\nll exp(ll l,ll r){\n  //view(l,r);\n  if( check_h(l,r) ) return INF;\n  if( !check_k2(l,r) ) return INF;\n  if( check_k(l,r) ) {\n    if( check_n(l+1,r-1) ) return INF;\n    return check(exp(l+1,r-1));\n  }\n  if( check_w(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return check(exp(l,i-1), exp(i+1,r),'+');\n      if( cnt == 0 && S[i] == '-' ) return check(exp(l,i-1), exp(i+1,r),'-');\n    }\n  }\n  if( check_m(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return check(exp(l,i-1), exp(i+1,r),'*');\n    }\n  }\n  if( check_n(l,r) )\n    return check(number(l,r));\n  return INF;\n}\n\nint main(){\n  cin >> S;\n  N  = strlen(S);\n  ll M = 0;\n  for(ll i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  ll res = -1;\n  ll K=1;\n  for(ll i=0;i<M;i++) K*=7;\n  bool f = false;\n  for(ll i=0;i<K;i++){\n    ll c = i;\n    strcpy( S, buf );\n    for(ll j=0;j<N;j++){\n      if( S[j] == '.' ){\n\tif( c%7 == 0 ) S[j] = '0';\n\tif( c%7 == 1 ) S[j] = '1';\n\tif( c%7 == 2 ) S[j] = '+';\n\tif( c%7 == 3 ) S[j] = '-';\n\tif( c%7 == 4 ) S[j] = '*';\n\tif( c%7 == 5 ) S[j] = '(';\n\tif( c%7 == 6 ) S[j] = ')';\t\t\n\tc/=7;\n      }    \n    }\n   \n    res = max( res, exp(0,N-1) );\n    if( res >=0&&!f ){f=true;\n    cout << S<< endl;\n    cout << res << endl;\n    }\n  }\n  cout << res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\nstring s;\nint p;\n\nint err = 0;\n\nint number();\nvoid chk(int v){\n\tif( v < 0 || v >= 1024 ) throw(3);\n}\n\nint isop(char c){\n\treturn c == '+'||c == '-'||c == '*';\n}\n\nint expression(int needOp){\n\tif( s[p] == '(' ){\n\t\tp++; \n\t\tint l = expression(1);\n\t\tif( p < s.size() && s[p] != ')' ) throw(0);\n\t\tp++;\n\t\treturn l;\n\t}else{\n\t\tint l = number();\n\t\tif( isop(s[p]) ){\n\t\t\tif( s[p] == '+' ){p++; l += expression(0); }\n\t\t\telse if( s[p] == '-' ){p++; l -= expression(0);}\n\t\t\telse if( s[p] == '*' ){p++; l *= expression(0);}\t\n\t\t}else if( needOp ) throw(1);\n\t\tchk(l);\n\t\treturn l;\n\t}\n}\n\nint number(){\n\tint ans = 0;\n\tif( s[p] != '0' && s[p] != '1' ) throw(4);\n\t\n\twhile( s[p] >= '0' && s[p] <= '1' ){\n\t\tans = ans * 2 + s[p++] - '0';\n\t\tchk(ans);\n\t}\n\treturn ans;\n}\n\nvector<int> pos;\n\nint ans = -1;\n\nvoid dfs(int x){\n\tif( x >= pos.size()){\n\t\tp = 0;\n\t\ttry{\n\t\t\tint get = expression(0);\n\t\t\tif( p != s.size() ) throw(0);\n\t\t\t//cout << s << endl;\n\t\t\t\n\t\t\tans = max(ans,get);\n\t\t}catch(int x){\n\t\t\t//cout << s << \" \" << x << endl;\n\t\t}\n\t}else{\n\t\tfor(int i = 0 ; i < 7 ; i++){\n\t\t\ts[pos[x]] = \"01+-*()\"[i];\n\t\t\tdfs(x+1);\n\t\t}\n\t}\n\t\n}\n\nint main(){\n\tcin >> s;\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif(s[i] =='.')pos.push_back(i);\n\t}\n\tdfs(0);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 10;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(temp==it) return false;\n  \n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    *result *= rv;\n    if(*result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstring ch = \"01+-*()\";\nint ans = -1;\n\nint expression(const string& s, int& k, bool& op);\nint factor(const string& s, int& k, bool& op);\nint term(const string& s, int& k, bool& op);\n\n// 数字が [0,1023] かチェック\nbool valid(const int n){\n\treturn (0 <= n && n < 1024);\n}\n\n// <number> ::= <digit> | <number> <digit>\nint number(const string& s, int& k){\n\tint r = 0;\n\twhile( s[k] == '0' || s[k] == '1' ){\n\t\tr = r * 2 + (s[k] - '0');\n\t\t++k;\n\t}\n\treturn r;\n}\n\nint expression(const string& s, int& k, bool& op){\n\tint r1 = term(s, k, op);\n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k, op);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\top = true;\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k, op);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\top = true;\n\t\t\tr1 = r1 - r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r1;\n}\n\nint factor(const string& s, int& k, bool& op){\n\tif( s[k] == '(' ){ // 括弧のはじまりのとき\n\t\t++k; // '(' の 1つ先に進める.\n\t\tbool op_ = false;\n\t\tint r = expression(s, k, op_);\n\t\t// 数字が [0,1023] の範囲にない or ')' がないとき\n\t\tif( !valid(r) || s[k] != ')' || !op_ ) return -1;\n\t\t\n\t\t++k; // ')' の 1つ先に進める.\n\t\treturn r;\n\t}else if( s[k] == '0' || s[k] == '1' ){ // 数字のとき\n\t\treturn number(s, k);\n\t}else{\n\t\treturn -1;\n\t}\n}\n\nint term(const string& s, int& k, bool& op){\n\tint r1 = factor(s, k, op);\n\t// 数字が [0,1023] の範囲にないとき \n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '*' ){\n\t\t\t++k;\n\t\t\tint r2 = factor(s, k, op);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\t\top = true;\n\t\t\tr1 = r1 * r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r1;\n}\n\n// 式が正しいかどうか.\n/*bool check(const string& s){\n\tint par = 0;\n\tchar prev = '\\0';\n\tdeque<bool> op(100, false);\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( prev == '\\0' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '(' ){\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '0' || prev == '1' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}\n\t\t\tprev = s[i];\n\t\t}else if( prev == '+' || prev == '-' || prev == '*' ){\n\t\t\tif( par > 0 ){\n\t\t\t\top[par] = true;\n\t\t\t}\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == ')' ){\n\t\t\tif( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}*/\n\nbool check(const string& s){\n\tstack<int> st;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '(' ){\n\t\t\tst.push(0);\n\t\t}else if( s[i] == ')' ){\n\t\t\tif( st.empty() ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tint cnt = st.top();\n\t\t\t\tif( cnt == 0 ){\n\t\t\t\t\treturn false;\n\t\t\t\t}else{\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\tif( !st.empty() ){\n\t\t\t\tint cnt = st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push( cnt + 1 );\n\t\t\t}\n\t\t}\n\t}\n\treturn st.empty();\n}\nint idx2;\n/*bool check(const string& s, bool first=true){\n  bool flg = false;\n \n  while(idx2 < s.size()){\n    if(s[idx2] == ')'){\n      return flg;\n    }\n \n    if(s[idx2] == '('){\n      idx2++;\n      if(!check(s,false)) return false;\n    }\n \n    if(s[idx2] == '+' || s[idx2] == '-' || s[idx2] == '*'){\n      flg = true;\n    }\n \n    idx2++;\n  }\n \n  if(first){\n    return true;\n  }\n \n  return flg;\n}*/\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tint t=0;\n\t\tbool op = false;\n\t\t// 式が正しいときだけ解を更新.\n\t\t//if( check(s) ){\n\t\t\tint res = expression(s, t, op);\n\t\t\tif( t == s.size() )\n\t\t\t\tans = max( ans , res );\n\t\t//}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\ntypedef string::const_iterator State;\nint number(State&);\npair<int,bool> factor(State&);\npair<int,bool> term(State&);\npair<int,bool> expression(State&);\n\nbool invalid;\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\tif(not isdigit(*begin)){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 2;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\tif(ret >= 1024){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\npair<int,bool> factor(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tpair<int,bool> ret = expression(begin);\n\t\tif(not ret.second) {\n\t\t\tinvalid = true;\n\t\t}\n\t\tbegin++; // ')'を飛ばす。\n\t\tret.second = 0;\n\t\treturn ret;\n\t} else {\n\t\treturn make_pair(number(begin), 0);\n\t}\n\treturn make_pair(0, 0);\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\npair<int,bool> term(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first *= factor(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\npair<int,bool> expression(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first += term(begin).first;\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first -= term(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n//beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\t//throw ParseError();\n\t}\n}\n\nconst string c = \"01+-*()\";\n\nbool check(string& s){\n\tint cnt = 0;\n\tbool op = false, st = false;\n\tshow(s)\n\trep(i,s.size()){\n\t\tcout << i << endl;\n\t\tif(s[i] == '('){\n\t\t\tif(st) return false;\n\t\t\tcnt++;\n\t\t\top = true;\n\t\t}else if(s[i] == ')'){\n\t\t\tif(op or st) return false;\n\t\t\tcnt--;\n\t\t\top = false;\n\t\t\tst = true;\n\t\t}else if(s[i] == '+' or s[i] == '-'){\n\t\t\top = false;\n\t\t\tst = false;\n\t\t}\n\t}\n\tshow(cnt)\n\treturn cnt == 0;\n}\n\nint dfs(string s, int i){\n\tif(i == s.size()){\n\t\t//if(not check(s)) return -1e5;\n\n\t\tinvalid = false;\n\t\tState tmp = s.begin();\n\n\t\tpair<int,bool> ans = expression(tmp);\n\t\tif(ans.first >= 1024 or ans.first < 0) return -1e5;\n\t\tif(tmp != s.end()) return -1e5;\n\t\t//cout << ans.first << ' ' << s << endl;\n\t\treturn invalid ? -1e5 : ans.first;\n\t}\n\n\twhile(s[i] != '.' and i < s.size()){\n\t\ti++;\n\t}\n\n\tif(s[i] == '.'){\n\t\tint res = -1e5;\n\t\trep(j,c.size()){\n\t\t\ts[i] = c[j];\n\t\t\tres = max(res, dfs(s, i));\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn dfs(s, i);\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\n\tint ans = dfs(s, 0);\n\tcout << (ans == -1e5 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  \n\n  for(int i=0;i<s.length();i++){\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*')return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif(s[j] == '+' || s[j] == '-' || s[j] == '*'){\n\t  exist = true;\n\t  break;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' <= parse[pos] && parse[pos] <= '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\n\t\tif (val >= 1024)return -1;\n\t\tif (val < 0)return -1;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t\tif (val >= 1024)return - 1;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num])){\n\t\tn = n * 2 + s[num++] - '0';\n\t\tif (n>=1024)return -1;\n\t}\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\tsc.push('0');\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.empty()||sc.top() == '0'){\n\t\t\tans = expr(s, num);\n\t\t\tif (s.length() == num){\n\t\t\t\tma = max(ma, ans);\n\t\t\t\t//cout << s << ' ' << ans << endl;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n  \nusing namespace std;\n  \nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\nbool OVER;\n  \nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n  \n  return true;\n}\n  \nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n  \n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n  \n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true;\n  }\n  return false;\n}\n  \nbool parapos(string s){\n  int p = 0;\n  \n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n  }\n  return p == 0;\n}\n  \nbool isvalid(string s){\n  \n  if(!parapos(s)) return false;\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n  \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n  \nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n\nbool inside(int num){\n  return (0<=num && num<1024); \n}\n  \nint get(string s){\n  //  cout << \"S \" << s << endl;\n   \n  if(isnum(s)){\n    int tmp = tob(s);\n    if(!inside(tmp)) OVER = true;\n    return tmp;\n  }\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n    \n    for(int i = s.length(); i >= 0; i--){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+'){\n\tint tmp = get(s.substr(0,i))+get(s.substr(i+1));\n\tif(!inside(tmp)) OVER = true;\n\treturn tmp;\n      }\n      if(p == 0 && s[i] == '-'){\n\tint tmp = get(s.substr(0,i))-get(s.substr(i+1));\n\tif(!inside(tmp)) OVER = true; \n\treturn tmp;\n      }\n    }\n    \n    for(int i = s.length(); i >= 0; i--){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*'){\n\tint tmp =  get(s.substr(0,i))*get(s.substr(i+1));\n\tif(!inside(tmp)) OVER = true;\n\treturn tmp;\n      }\n    }\n  }\n}\n  \nvoid solve(int n){\n  \n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n \n    if(isvalid(in)){\n      OVER = false;\n      int num = get(in);\n      if(inside(num) && !OVER) ans = max(ans,num);\n    }\n  }\n}\n  \nint main(){\n\n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n  \n  solve(0);\n  \n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint expression(State &begin, State &end);\nint term(State &begin, State &end);\nint number(State &begin, State &end);\nint factor(State &begin, State &end);\n\nint number(State &begin, State &end) {\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret = ret << 1;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin, State &end) {\n\tint ret = factor(begin, end);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin, end);\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin, end);\n\t\t//} else if(begin == end){\n\t\t//\treturn -1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin, State &end) {\n\tint ret = term(begin, end);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin, end);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin, end);\n\t\t//} else if(begin == end){\n\t\t//\treturn -1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin, State &end) {\n\tif (*begin == '(') {\n\t\tbegin++; // '('テ」ツつ津ゥツ」ツ崚」ツ?ーテ」ツ?凖」ツ??\n\t\tint ret = expression(begin, end);\n\t\tbegin++; // ')'テ」ツつ津ゥツ」ツ崚」ツ?ーテ」ツ?凖」ツ??\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin, end);\n\t}\n}\n\nvector<int> v;\n\nint f(int idx, string s){\n\tint ret = -1;\n\tif(idx == v.size() || v.size() == 0){\n\t\tint brackets = 0, op = 0;\n\t\tbool possible = true;\n\t\trep(i, s.size()){\n\t\t\tif(s[i] == '(') brackets++;\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*') op++;\n\t\t\tif(s[i] == ')' && op != brackets){possible = false; break;}\n\t\t}\n\t\tint c = 0;\n\t\twhile(c < s.size()){\n\t\t\twhile(isdigit(s[c])) c++;\n\t\t\tif(!(c < s.size())) break;\n\t\t\tif(s[c] == '+' || s[c] == '-' || s[c] == '*') c++;\n\t\t\telse {possible = false; break;}\n\t\t\tif(!(c < s.size())){possible = false; break;}\n\t\t}\n\t\tif(!possible) return -1;\n\t\tState begin = s.begin();\n\t\tState end = s.end();\n\t\treturn expression(begin, end);\n\t}\n\telse {\n\t\tstring t = \"01+-*()\";\n\t\tfor(int i=0; i< t.size(); i++){\n\t\t\ts = s.replace(v[idx], 1, t.substr(i, 1));\n\t\t\tint n = f(idx+1, s);\n\t\t\tif(0 <= n && n < pow(2, 10)) ret = max(ret, n);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tstring s;\n\tgetline(cin, s);\n\trep(i, s.size()) if(s[i] == '.') v.push_back(i);\n\tcout << f(0, s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n        }else{\n            res -= term(++pos);\n            if(res<0||res>=1023){\n                ppppp = 1;\n            }\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nchar s[110];\nint n;\nint dd[5];\nchar u[] = \"01+-*()\";\nbool err;\nint ec;\nint expr(char **begin);\n\nvoid erce(int i) {\n    err |= (i  < 0 || 1024 <= i);\n}\n\nint numb(char **begin) {\n    int r = 0;\n    if (!isdigit(**begin)) err = true;\n    while (isdigit(**begin)) {\n        r *= 2;\n        r += **begin - '0';\n        *begin += 1;\n    }\n    if (1024 <= r) err = true;\n    return r;\n}\n\nint fact(char **begin) {\n    if (**begin == '(') {\n        *begin += 1;\n        int ec2 = ec;\n        int r = expr(begin);\n        if (ec2 == ec) err = true;\n        if (**begin != ')') err = true;\n        *begin += 1;\n        return r;\n    } else {\n        return numb(begin);\n    }\n}\n\nint term(char **begin) {\n    int r = fact(begin);\n    while (true) {\n        if (**begin == '*') {\n            ec++;\n            *begin += 1;\n            r *= fact(begin);\n            erce(r);\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\nint expr(char **begin) {\n    int r = term(begin);\n    while (true) {\n        if (**begin == '+') {\n            ec++;\n            *begin += 1;\n            r += term(begin);\n            erce(r);\n        } else if (**begin == '-') {\n            ec++;\n            *begin += 1;\n            r -= term(begin);\n            erce(r);\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\n\nint main() {\n    string ss;\n    cin >> ss;\n    n = ss.size();\n    int cc = 1;\n    int c = 0;\n    for (int i = 0; i < n; i++) {\n        s[i] = ss[i];\n        if (s[i] == '.') {\n            dd[c] = i;\n            c++;\n            cc *= 7;\n        }\n    }\n    s[n] = '$';\n    int res = -1;\n    for (int i = 0; i < cc; i++) {\n        int ii = i;\n        for (int j = 0; j < c; j++) {\n            s[dd[j]] = u[ii%7];\n            ii /= 7;\n        }\n        err = false;\n        ec = 0;\n        char *p = s;\n        int r = expr(&p);\n        if (*p != '$') err = true; \n        if (!err) res = max(res, r);\n        //printf(\"%5s %d %d %d\\n\", s, ec, r, err);\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 10;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseVaule(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(temp==it) return false;\n  \n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseVaule(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseVaule(it, &rv)) return false;\n    *result *= rv;\n    if(*result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint p,flag,ans=-1;\nstring s;\nmap<int,char>cc;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])){\n    while(isdigit(s[p]))res=res*2+(s[p++]-'0');\n  }\n  else flag++;\n  if(res>=1024)flag++;\n  if(res<0)flag++;\n  return res;\n}\nint bnf2(){\n  int res=get_A();\n  while(s[p]=='*'){\n    int t=p++;\n    if(s[t]=='*')res*=get_A();\n  }\n  if(res>=1024)flag++;\n  if(res<0)flag++;\n  return res;\n}\nint bnf1(){\n  int res=bnf2();\n  while(s[p]=='+'||s[p]=='-'){\n    int t=p++;\n    if(s[t]=='+')res+=bnf2();\n    if(s[t]=='-')res-=bnf2();\n  }\n  if(res>=1024)flag++;\n  if(res<0)flag++;\n  return res;\n}\nbool ch(){\n  int t=0;\n  stack<int>st;\n  r(i,s.size()){\n    if(s[i]=='(')t++;\n    if(s[i]==')'){\n      int tt=0;\n      if(!st.empty()&&st.top()!=t)return 0;\n      while(!st.empty()&&st.top()==t)st.pop(),tt++;\n      if(!tt)return 0;\n      t--;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*')st.push(t);\n  }\n  if(t)return 0;\n  return 1;\n}\nvoid dfs(int d){\n  if(d==s.size()){\n    p=0;\n    if(ch()){\n      p=flag=0;\n      int res=bnf1();\n      if(!flag&&p==s.size())ans=max(ans,res);\n    }\n  }\n  else if(s[d]=='.'){\n    r(i,7){\n      s[d]=cc[i];\n      dfs(d+1);\n    }\n    s[d]='.';\n  }\n  else dfs(d+1);\n}\nmain(){\n  cin>>s;\n  cc[0]='0';\n  cc[1]='1';\n  cc[2]='+';\n  cc[3]='-';\n  cc[4]='*';\n  cc[5]='(';\n  cc[6]=')';\n  dfs(0);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef string::iterator State;\nconst int MA=1023,MI=0;\n\nstring str;\n\nint number(State &begin);\nint term(State &begin);\nint expr(State &begin);\nint term(State &begin);\nint expr2(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tint d=*begin-'0';\n\t\tret*=2;\n\t\tret+=d;\n\t\tbegin++;\n\t\tif(ret>MA) return -1;\n\t}\n\tif(ret>MA||ret<MI) return -1;\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\tif(ret==-1) return -1;\n\twhile(true){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else break;\n\t}\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\nint expr(State &begin){\n\tint ret=term(begin);\n\tif(ret<MI||ret>MA) return -1;\n\tint c=0;\n\twhile(true){\n\t\tif(*begin=='+'){\n\t\t\tc++;\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret+=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else if(*begin=='-'){\n\t\t\tc++;\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}\n\t\telse break;\n\t}\n//\tif(c==0){\n//\t\tprintf(\"c==0---------------\\n\");\n//\t\treturn -1;\n//\t}\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\n\nint expr2(State &begin){\n\tint ret=term(begin);\n\tif(ret<MI||ret>MA) return -1;\n\twhile(true){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret+=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}\n\t\telse break;\n\t}\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expr(begin);\n//\t\tif(ret==-1) printf(\"expr -1\\n\");\n\t\tbegin++;\n\t\treturn ret;\n\t}else if(!isdigit(*begin)){\n\t\treturn -1;\n\t}\n\telse return number(begin);\n}\n\nint ans=-1;\nvector<int> dots;\n\nstring chars=\"01()+-*\";\n\nstack<int> ops;\nint a[1010],b[1010];\nbool check(){\n\tint c=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='('){\n\t\t\tops.push(i);\n\t\t}else if(str[i]==')'){\n\t\t\tif(ops.empty()) return false;\n\t\t\tint x=ops.top();\n\t\t\tops.pop();\n\t\t\ta[c]=x;\n\t\t\tb[c]=i;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tint in=0;\n\t\tint cnt=0;\n\t\tfor(int j=a[i]+1;j<b[i];j++){\n\t\t\tif(str[j]=='(') in++;\n\t\t\telse if(str[j]==')') in--;\n\t\t\telse if(in==0&&!isdigit(str[j])) cnt++;\n\t\t}\n\t\tif(cnt==0) return false;\n\t}\n\treturn true;\n}\n\nvoid dfs(int id){\n\tif(id==dots.size()){\n\t\tState s=str.begin();\n\t\tint a=expr2(s);\n\t\tif(s!=str.end()){\n\t\t\tprintf(\"aaa---------------------\\n\");\n\t\t\treturn;\n\t\t}\n\t\tans=max(ans,a);\n\t}\n\telse{\n\t\tfor(int i=0;i<7;i++){\n\t\t\tstr[dots[id]]=chars[i];\n\t\t\tdfs(id+1);\n\t\t}\n\t\tstr[dots[id]]='.';\n\t}\n}\n\nint main(){\n\tcin>>str;\n\tfor(int i=0;i<str.size();i++) if(str[i]=='.') dots.push_back(i);\n\tdfs(0);\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, char *> P;\n\nint cs[] = {'0', '1', '+', '-', '*', '(', ')'};\n\nP fact(char *p);\nP term(char *p);\nP expr(char *p);\n\nP fact(char *p){\n  if(isdigit(*p)){\n    int t = *(p++) - '0';\n    while(isdigit(*p)) t = t * 2 + *(p++) - '0';\n    return P(t, p);\n  } else if(*p == '('){\n    P r = expr(p + 1);\n    if(*r.second != ')') exit(0); //閉じ括弧が無いエラー\n    return P(r.first, r.second + 1);\n  } else{\n    exit(0); //括弧でも数字でもないエラー\n  }\n}\n\nP term(char *p){\n  P r = fact(p);\n  while(*r.second == '*' || *r.second == '/'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = fact(r.second + 1);\n    if(op == '*') r.first *= tmp;\n    else r.first /= tmp;\n  }\n  return r;\n}\n\nP expr(char *p){\n  P r = term(p);\n  while(*r.second == '+' || *r.second == '-'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = term(r.second + 1);\n    if(op == '+') r.first = tmp + r.first;\n    else r.first = tmp - r.first;\n  }\n  return r;\n}\n\nbool is_digit(string s){\n  if(s == \"0\" || s == \"1\") return true;\n  return false;\n}\n\nbool is_operation(string s){\n  if(s == \"+\" || s == \"-\" || s == \"*\") return true;\n  return false;\n}\n\nbool is_number(string s){\n  if(is_digit(s) || ((int)s.length() >= 2 && is_number(s.substr(0, (int)s.length() - 1)) && is_digit(s.substr(s.length() - 1)))) return true;\n  return false;\n}\n\nbool check(string s){\n  int cnt = 0;\n  REP(i, s.length()){\n    if(s[i] == '(') ++cnt;\n    if(s[i] == ')') --cnt;\n    if(cnt < 0) return false;\n  }\n  return cnt == 0;\n}\n\nbool is_expression(string s);\n\nbool is_inner_expression(string s){\n  //cout <<\"inner_exp \" <<s <<endl;\n  FOR(i, 1, (int)s.length() - 1){\n    //cout <<\"left \" <<s.substr(0, i) <<\", right \" <<s.substr(i + 1) <<endl;\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nbool is_expression(string s){\n  //cout <<\"exp \" <<s <<endl;\n  if((int)s.length() >= 2 && s[0] == '(' && s[(int)s.length() - 1] == ')' && check(s.substr(1, (int)s.length() - 2))){\n    bool res = is_inner_expression(s.substr(1, (int)s.length() - 2));\n    //cout <<(res ? \"true\" : \"false\") <<endl;\n    return res;\n  }\n  if(is_number(s)){\n    //cout <<\"true\" <<endl;\n    return true;\n  }\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nint solve(int cnt, vector<int> &v, char *s){\n  if(cnt >= (int)v.size()){\n    //cout <<\"! \" <<s <<\", \" <<is_expression(s) <<endl;\n    if(!is_expression(s)) return -1;\n    int res = expr(s).first;\n    return res >= 0 && res <= 1024 ? res : -1;\n  }\n  int res = -1;\n  REP(i, 7){\n    s[v[cnt]] = cs[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  return res;\n}\n\nint main() {\n  char s[110];\n  cin >>s;\n  int sl = strlen(s);\n  vector<int> v;\n  REP(i, sl) if(s[i] == '.') v.push_back(i);\n  cout <<solve(0, v, s) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstring s;\nint n;\nvector<int> dot;\nint D;\n\nll ans = -1;\nconst ll LIM = 1<<10;\n\nbool err;\n\nll E(int l, int r);\n\nll N(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    ll ret = 0;\n    for(int i=l; i<=r; ++i){\n        if(ret>=LIM || (s[i]!='0' && s[i]!='1')){\n            err = true;\n            return 0;\n        }\n        ret = ret*2 + s[i]-'0';\n    }\n    return ret;\n}\n\n// <expression> <operation> <expression>\nll O(int l, int r){\n    char op = '?';\n    int pos = -1;\n\n    int b = 0;\n    for(int i=r; i>=l; --i){\n        b += (s[i]=='(');\n        b -= (s[i]==')');\n\n        if(b==0){\n            if(s[i]=='+' || s[i]=='-'){\n                op = s[i];\n                pos = i;\n                break;\n            }\n        }\n    }\n\n    if(pos == -1){\n        b = 0;\n        for(int i=r; i>=l; --i){\n            b += (s[i]=='(');\n            b -= (s[i]==')');\n\n            if(b==0){\n                if(s[i]=='*'){\n                    op = s[i];\n                    pos = i;\n                    break;\n                }\n            }\n        }\n    }\n\n    if(op == '?'){\n        err = true;\n        return 0;\n    }\n\n    ll x = E(l,pos-1), y = E(pos+1,r);\n    ll ret;\n    if(op == '+') ret = x+y;\n    else if(op == '-') ret = x-y;\n    else if(op == '*') ret = x*y;\n\n    if(ret<0 || ret>=LIM) err = true;\n    return ret;\n\n}\n\nll E(int l, int r){\n    // printf(\" E %d %d\\n\", l, r);\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    if(s[l]=='('){\n        int b = 0;\n        for(int i=l; i<=r; ++i){\n            b += (s[i]=='(');\n            b -= (s[i]==')');\n\n            if(b==0){\n                if(s[i]=='+' || s[i]=='-' || s[i]=='*') return O(l,r);\n            }\n        }\n\n        if(s[r]!=')'){\n            err = true;\n            return 0;\n        }\n        return O(l+1, r-1);\n    }\n\n    bool found = false;\n    for(int i=l; i<=r; ++i){\n        if(s[i]=='+' || s[i]=='-' || s[i]=='*') found = true;\n    }\n\n    ll ret;\n    if(found) ret = O(l,r);\n    else ret = N(l,r);\n    if(ret<0 || ret>=LIM) err = true;\n    return ret;\n}\n\nconst string cand = \"01+-*()\";\nvoid dfs(int dep){\n    if(dep == D){\n        err = false;\n        ll res = E(0,n-1);\n        if(!err) ans = max(ans, res);\n        return;\n    }\n\n    int idx = dot[dep];\n    rep(i,cand.size()){\n        s[idx] = cand[i];\n        dfs(dep+1);\n        s[idx] = '.';\n    }\n}\n\nint main(){\n    cin >>s;\n    n = s.size();\n\n    rep(i,n)if(s[i] == '.') dot.pb(i);\n    D = dot.size();\n\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nstring st;\nint a = 0;\nvoid check(const int num) {\n\tif (num < 0 || num >= 1024)throw(false);\n}\nint getnum() {\n\tint num = 0;\n\twhile (isdigit(st[a])) {\n\t\tnum = num * 2 + st[a] - '0';\n\t\ta++;\n\t}\n\tcheck(num);\n\treturn num;\n}\nint getexpr(const int isstart);\nint getkakko();\nint getka() {\n\tif (st[a] == '(') {\n\t\tint num=getkakko();\n\t\treturn num;\n\t}\n\telse if(isdigit(st[a])){\n\t\treturn getnum();\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\npair<int,int> getso() {\n\tint num = getka();\n\tbool fst = false;\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')'||st[a]=='+'||st[a]=='-') {\n\t\t\treturn make_pair(fst,num);\n\t\t}\n\t\telse if (st[a] == '*') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getka();\n\t\t\tnum *= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\npair<int, int> getexpr() {\n\tauto p(getso());\n\tbool fst = p.first;\n\tint num = p.second;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\treturn make_pair(fst,num);\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\nint getkakko() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n\tauto p(getso());\n\tint num = p.second;\n\n\tint fst = p.first;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\tthrow(false);\n\t\t}else if( st[a] == ')') {\n\t\t\tif (!fst) throw(false);\n\t\t\telse break;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n\tif (st[a] == ')') {\n\t\ta++;\n\t\treturn num;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\nint main() {\n\tstring base; cin >> base;\n\tst = base;\n\tstring aa = \"01+-*()\";\n\tvector<int>unknowns;\n\tfor (int i = 0; i < base.size(); ++i) {\n\t\tif (base[i] == '.') {\n\t\t\tunknowns.emplace_back(i);\n\t\t}\n\t}\n\tint ans = -1;\n\tfor (int i = 0; i < powint(7, unknowns.size()); ++i) {\n\t\tint num(i);\n\t\ta = 0;\n\t\tfor (int j = 0; j < unknowns.size(); ++j) {\n\t\t\tst[unknowns[j]] = aa[num % 7];\n\t\t\tnum /= 7;\n\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tint num = getexpr().second;\n\t\t\tans=max(ans,num);\n\t\t}\n\t\tcatch (...) {\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 110;\n\nint N;\nstring s;\n\nbool is_num(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (!isdigit(s[i])) return 0;\n    }\n    return 1;\n}\n\nint num(int L, int R)\n{\n    int res = 0;\n    for (int i = R; i >= L; i--) {\n        if (R - L > 10 && s[i] == '1') {\n            return -1;\n        }\n        res += (s[i] - '0') * pow(2, R - i);\n    }\n    return res;\n}\n\nbool is_op(char c)\n{\n    return (c == '+' || c == '-' || c == '*');\n}\n\nbool check_op(int L, int R)\n{\n    int p = 0;\n    for (int i = L; i <= R; i++) {\n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p == 0 && is_op(s[i])) return 1; \n    }\n    return 0;\n}\n\nint mem[MAX][MAX];\n\nint expr(int L, int R)\n{\n    int& res = mem[L][R];\n    if (res != -1) return res;\n\n    if (is_num(L, R)) return num(L, R);\n    \n    for (int i = L + 1; i <= R - 1; i++) {\n        if (!is_op(s[i])) continue;\n        \n        int l = expr(L, i - 1), r = expr(i + 1, R);\n        int v = -1;\n\n        if (l == -1 || r == -1) continue;\n        \n        switch (s[i]) {            \n            case '+':\n                v = l + r;\n                break;\n            case '-':\n                v = l - r;\n                break;\n            case '*':\n                v = l * r;\n                break;                \n        }\n        \n        if (v < 0 || v >= (1 << 10)) continue;\n        \n        res = max(res, v);\n    }\n\n        \n    if (s[L] == '(' && s[R] == ')') {\n        if (check_op(L + 1, R - 1)) {\n            res = max(res, expr(L + 1, R - 1));\n        } \n    }\n\n    return res;\n}\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid()\n{\n    int p = 0;\n    for (int i = 0; i < N; i++) {\n        if (is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n    }\n    return (p == 0);\n}\n\nint solve()\n{\n    N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        memset(mem, -1, sizeof(mem));\n        return expr(0, N - 1);\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid()) {\n            memset(mem, -1, sizeof(mem));\n            res = max(res, expr(0, N - 1));\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    cin >> s;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nstring s;\n\nstring op[2] = {\"+-\", \"*\"};\n\nint parse(int& i, int d)\n{\n\tif (d == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tint ret = parse(i, 0);\n\t\t\ti++;\n\t\t\tif (ret < 0) return -1;\n\t\t\tif (1024 <= ret) return -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ('0' <= s[i] && s[i] <= '1')\n\t\t{\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '1')\n\t\t\t{\n\t\t\t\tret = ret * 2 + s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (1024 <= ret) return -1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ret = parse(i, d + 1);\n\n\t\twhile (op[d].find(s[i]) != string::npos)\n\t\t{\n\t\t\tint _ret = parse(i, d + 1);\n\t\t\tif (_ret < 0) return -1;\n\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '+': i++; ret += _ret; break;\n\t\t\tcase '*': i++; ret *= _ret; break;\n\t\t\tcase '-': i++; ret -= _ret; break;\n\t\t\t}\n\n\t\t\tif (1024 <= ret) return -1;\n\t\t\tif (ret < 0) return -1;\n\t\t}\n\n\t\treturn ret;\n\t}\n}\n\nbool isvalid()\n{\n\tint cnt = 0;\n\tint flag[101010];\n\tflag[0] = 0;\n\trep(j, 0, s.length())\n\t{\n\t\tif (s[j] == '(')\n\t\t{\n\t\t\tcnt++;\n\t\t\tflag[cnt] = 1;\n\t\t}\n\t\telse if (s[j] == ')')\n\t\t{\n\t\t\tif (cnt == 0) return false;\n\t\t\tif (flag[cnt] == 1) return false;\n\t\t\tcnt--;\n\t\t}\n\t\telse if (s[j] == '0' || s[j] == '1')\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag[cnt] = 0;\n\t\t}\n\t}\n\tif (cnt != 0) return false;\n\n\trep(j, 0, s.length() - 1)\n\t{\n\t\tif (s[j] == '+' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '+' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '-' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '*' && s[j + 1] == ')') return false;\n\n\t\tif (s[j] == ')' && s[j + 1] == '(') return false;\n\n\t\tif (s[j] == '0' && s[j + 1] == '(') return false;\n\t\tif (s[j] == '1' && s[j + 1] == '(') return false;\n\n\t\tif (s[j] == ')' && s[j + 1] == '0') return false;\n\t\tif (s[j] == ')' && s[j + 1] == '1') return false;\n\t\t\n\t}\n\n\tif (s[0] == '+') return false;\n\tif (s[0] == '-') return false;\n\tif (s[0] == '*') return false;\n\n\tif (s[s.length() - 2] == '+') return false;\n\tif (s[s.length() - 2] == '-') return false;\n\tif (s[s.length() - 2] == '*') return false;\n\n\treturn true;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t/*\n\ts = \"(1+1)=\";\n\tif (isvalid())\n\t\tcout << \"valid\" << endl;\n\telse\n\t\tcout << \"invalid\" << endl;\n\n\treturn 0;\n\t*/\n\n\tcin >> s; s += \"=\";\n\n\tvector<int> dots;\n\trep(j, 0, s.length()) if (s[j] == '.') dots.push_back(j);\n\n\tint nums[5];\n\tstring opes = \"01+-*()\";\n\tint ans = -1;\n\trep(j, 0, 100000)\n\t{\n\t\tint jj = j;\n\t\trep(k, 0, 5)\n\t\t{\n\t\t\tnums[k] = jj % 10;\n\t\t\tjj /= 10;\n\t\t}\n\t\tbool ok = false;\n\t\trep(k, 0, dots.size()) if (7 <= nums[k]) ok = true;\n\t\tif (ok) continue;\n\n\t\trep(k, 0, dots.size()) s[dots[k]] = opes[nums[k]];\n\n\t\tif (!isvalid()) continue;\n\n\t\tint i = 0;\n\t\tint ret = parse(i, 0);\n\t\tif (ans < ret)\n\t\t{\n\t\t\tans = ret;\n\t\t\t//cout << s << ret << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\npi expr(), term();\nstring s;\nint p;\npi digit(){\n\tint d = 0;\n\twhile(p < s.size() && isdigit(s[p])){\n\t\td *= 2; d += s[p++] - '0';\n\t\tif(d >= 1 << 10) throw \"bigdigit\";\n\t}\n\treturn mp(d, 0);\n}\npi expr(){\n\tpi a = term();\n\twhile(p < s.size() && (s[p] == '+' || s[p] == '-')){\n\t\tbool pr = s[p++] == '+';\n\t\tpi b = term();\n\t\ta.first = a.first + (pr ? b.first : -b.first);\n\t\ta.second = 1;\n\t\tif(a.first < 0 || a.first >= 1 << 10) throw \"overflow\";\n\t}\n\treturn a;\n}\npi term(){\n\tpi a = mp(1, 0);\n\tint fac = 0;\n\tp--;\n\tdo{\n\t\tif(++p >= s.size()) throw \"syntaxerorr\";\n\t\t\n\t\tpi b;\n\t\tif(isdigit(s[p])) b = digit();\n\t\telse if(s[p] == '('){\n\t\t\tp++;\n\t\t\tb = expr();\n\t\t\tif(!b.second) throw \"(())\";\n\t\t\tif(s[p++] != ')') throw \"closep\";\n\t\t}\n\t\telse throw \"syntaxerror\";\n\t\ta.first *= b.first;\n\t\tif(a.first >= 1 << 10) throw \"overflow\";\n\t\tfac++;\n\t}while(p < s.size() && s[p] == '*');\n\treturn mp(a.first, fac > 1);\n}\n\nint main(){\n\tcin >> s;\n\tvi v;\n\trep(i, s.size()) if(s[i] == '.') v.pb(i);\n\tint pw[10], ans = -1;\n\tpw[0] = 1;\n\trep(i, 9) pw[i + 1] = pw[i] * 7;\n\t\n\trep(i, pw[v.size()]){\n\t\trep(j, v.size()) s[v[j]] = \"01+-*()\"[i / pw[j] % 7];\n\t\tp = 0;\n\t\ttry{\n\t\t\tpi res = expr();\n\t\t\tif(p < s.size()) throw \"syntaxerror\";\n\t\t\tans = max(ans, res.first);\n\t\t}catch(const char *e){\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p;\nbool flg;\nint Num(){\n  int res=0;\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  return s[i]!=')';\n}\n\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='('){\n      flg&=check2();\n      p++;\n      res+=bnf(),flg&=s[p++]==')';\n    }\n    else {\n      if(s[p]==')')break;\n      flg&=check(p+1);\n      if(s[p]=='+')p++,flg&=check2(),res+=bnf();\n      else if(s[p]=='-')p++,flg&=check2(),res-=bnf();\n      else if(s[p]=='*'){\n\tif(s[p++]=='(')flg&=check2(),res*=bnf();\n\telse res*=Num();\n      }\n      else break;\n    }\n  }\n  if(!flg)return -INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool is_num(char x){return x=='0' || x=='1';}\n\nbool valid_num(int x){\n  const int SUP=1024;\n  return 0<=x && x<SUP;\n}\n\nint calc(int lhs,int rhs,char op){\n  int res;\n  if(op=='+'){\n    res=lhs+rhs;\n  }else if(op=='-'){\n    res=lhs-rhs;\n  }else if(op=='*'){\n    res=lhs*rhs;\n  }else{\n    throw \"calc\";\n  }\n\n  if(!valid_num(res)) throw \"valid\";\n  return res;\n}\n\nint formula(int &p);\nint formulap(int &p);\nint term1(int &p);\npair<int,bool> term1p(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint formula(int &p){\n  int res=term1(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formula\";\n    int rhs=term1(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\nint formulap(int &p){\n  bool isok=false;\n  auto ret=term1p(p);\n  isok|=ret.second;\n  int res=ret.first;\n\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formulap_op\";\n    isok=true;\n    int rhs=term1p(p).first;\n    res=calc(res,rhs,op);\n  }\n  if(!isok) throw \"formulap_isok\";\n  return res;\n}\n\nint term1(int& p){\n  int res=term2(p);\n  while(p<s.size() && (s[p]!='+' && s[p]!='-')){\n    char op=s[p];\n    p++;\n    if(op!='*') throw \"term1_op\";\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\npair<int,bool> term1p(int &p){\n  int res=term2(p);\n  bool isop=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;    \n    if(op!='*') throw \"term1p\";\n    isop=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,isop};\n}\n\nint term2(int& p){\n  if(s[p]=='('){\n    p++;\n    int res=formulap(p);\n    if(s[p]!=')') throw \"term2\";\n    p++;\n    return res;\n  }else if(is_num(s[p])){\n    int res=get_num(p);\n    return res;\n  }else throw \"term2\";\n}\n\nint get_num(int& p){\n  int res=0;\n  while(p<s.size() && is_num(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nint dfs(int i){\n  if(i==s.size()){\n    int res;\n     try{\n       int p=0;\n       res=formula(p);\n     }catch(const char* &e){\n       res=-1;\n      }\n    return res;\n  }\n  else if(s[i]=='.'){\n    const string ch=\"01+-*()\";\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      int ret=dfs(i+1);\n      res=max(ret,res);\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(char ch){return ch&&ch!='+'&&ch!='-'&&ch!='*'&&ch!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\nbool check3(int a){return 0<=a&&a<1024;}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  flg&=check3(res);\n  return res;\n}\n\nint calc(){\n  int res;\n  flg&=check(s[++p])&check2();\n  if(s[p]=='(')res=bnf();\n  else res=Num()*((s[p]=='*')? calc():1);\n  flg&=check3(res);\n  return res;\n}\n\nint bnf(){\n  flg&=check(s[p]);\n  int res=Num();\n  while(p<s.size()&&flg&&s[p]!=')'){\n    flg&=check3(res)&&s[p]!='('&&check(s[p+1]);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n  } \n  if(!flg||!check3(res))res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n  \n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Node{\npublic:\n    char ope;\n    string s;\n    Node *left, *right;\n    Node(){\n        ope = '\\0';\n        left = right = NULL;\n    }\n    ~Node(){\n        delete left;\n        delete right;\n    }\n};\n\n// 数式の構文木を作成する\nclass syntacticAnalysis\n{\n    vector<int> binaryPriority;       // 二項演算子の優先順位（数値が小さいほど優先順位が高い。-1ならば二項演算子ではない）\n    vector<bool> binaryAssociativity; // 二項演算子の結合規則（trueならば左から右に結合）\n    vector<bool> isUnaryOpe;          // 単項演算子\n    stack<pair<Node*, bool> > stk;\n    void deleteAllNodes()\n    {\n        while(!stk.empty()){\n            delete stk.top().first;\n            stk.pop();\n        }\n    }\n    bool calc(int maxPriority)\n    {\n        if(!stk.top().second)\n            return false;\n        pair<Node*, bool> right = stk.top();\n        stk.pop();\n        while(stk.top().first != NULL){\n            pair<Node*, bool> ope = stk.top();\n            if(ope.second)\n                break;\n            stk.pop();\n            if(binaryPriority[ope.first->ope] != -1 && stk.top().second){\n                if(binaryPriority[ope.first->ope] > maxPriority ||\n                        binaryPriority[ope.first->ope] == maxPriority && !binaryAssociativity[ope.first->ope]){\n                    stk.push(ope);\n                    break;\n                }\n                ope.first->right = right.first;\n                ope.first->left = stk.top().first;\n                ope.second = true;\n                right = ope;\n                stk.pop();\n            }else if(isUnaryOpe[ope.first->ope]){\n                ope.first->right = right.first;\n                ope.second = true;\n                right = ope;\n            }else{\n                stk.push(ope);\n                break;\n            }\n        }\n        bool ret = (stk.top().first == NULL);\n        stk.push(right);\n        return ret;\n    }\npublic:\n    // binaryOpe : 二項演算子（優先順位の高い順に並べる。secondは結合規則を表し、trueならば左から右に結合）\n    // unaryOpe  : 単項演算子（前置演算子のみ対応）\n    syntacticAnalysis(const vector<pair<string, bool> >& binaryOpe, const string& unaryOpe)\n    {\n        binaryPriority.assign(128, -1);\n        binaryAssociativity.resize(128);\n        isUnaryOpe.assign(128, false);\n        for(unsigned i=0; i<binaryOpe.size(); ++i){\n            for(unsigned j=0; j<binaryOpe[i].first.size(); ++j){\n                binaryPriority[binaryOpe[i].first[j]] = i;\n                binaryAssociativity[binaryOpe[i].first[j]] = binaryOpe[i].second;\n            }\n        }\n        for(unsigned i=0; i<unaryOpe.size(); ++i)\n            isUnaryOpe[unaryOpe[i]] = true;\n    }\n    Node* makeTree(const string& s)\n    {\n        int n = s.size();\n        int i = 0;\n        stk.push(make_pair((Node*)NULL, false));\n        while(i < n){\n            if(s[i] == '('){\n                stk.push(make_pair((Node*)NULL, false));\n                ++ i;\n            }else if(s[i] == ')'){\n                if(!calc(INT_MAX) || stk.size() == 2 || stk.top().first->ope == '\\0'){\n                    deleteAllNodes();\n                    return NULL;\n                }\n                pair<Node*, bool> node = stk.top();\n                stk.pop();\n                stk.pop();\n                stk.push(node);\n                ++ i;\n            }else if(binaryPriority[s[i]] != -1 || isUnaryOpe[s[i]]){\n                calc(binaryPriority[s[i]]);\n                Node* node = new Node;\n                node->ope = s[i];\n                stk.push(make_pair(node, false));\n                ++ i;\n            }else{\n                Node* node = new Node;\n                while(i < n && s[i] != '(' && s[i] != ')' && binaryPriority[s[i]] == -1 && !isUnaryOpe[s[i]]){\n                    node->s += s[i];\n                    ++ i;\n                }\n                stk.push(make_pair(node, true));\n            }\n        }\n\n        if(!calc(INT_MAX) || stk.size() != 2){\n            deleteAllNodes();\n            return NULL;\n        }else{\n            Node* ret = stk.top().first;\n            stk.pop();\n            stk.pop();\n            return ret;\n        }\n    }\n};\n\nint solve(const Node* node)\n{\n    if(node->ope == '\\0'){\n        int ret = 0;\n        for(unsigned i=0; i<node->s.size(); ++i){\n            ret *= 2;\n            if(node->s[i] == '1')\n                ++ ret;\n            if(ret >= 1024)\n                return -1;\n        }\n        return ret;\n    }\n\n    int left = solve(node->left);\n    int right = solve(node->right);\n    if(left == -1 || right == -1)\n        return -1;\n\n    int ret;\n    if(node->ope == '+')\n        ret = solve(node->left) + solve(node->right);\n    else if(node->ope == '-')\n        ret = solve(node->left) - solve(node->right);\n    else\n        ret = solve(node->left) * solve(node->right);\n\n    if(ret < 0 || ret >= 1024)\n        return -1;\n    else\n        return ret;\n}\n\nconst string c = \"01+-*()\";\n\nint main()\n{\n    vector<pair<string, bool> > binaryOpe(2);\n    binaryOpe[0] = make_pair(\"*\", true);\n    binaryOpe[1] = make_pair(\"+-\", true);\n    syntacticAnalysis sa(binaryOpe, \"\");\n\n    string s;\n    cin >> s;\n    int n = s.size();\n\n    int m = 0;\n    vector<int> index;\n    for(int i=0; i<n; ++i){\n        if(s[i] == '.'){\n            index.push_back(i);\n            ++ m;\n        }\n    }\n\n    int ret = -1;\n    if(m == 0){\n        Node* node = sa.makeTree(s);\n        if(node != NULL){\n            ret = max(ret, solve(node));\n            delete node;\n        }\n    }else{\n        for(int i=0; ; ++i){\n            int a = i;\n            for(int j=0; j<m; ++j){\n                s[index[j]] = c[a%8];\n                a /= 8;\n            }\n            if(a > 0)\n                break;\n\n            bool ng = false;\n            int j = -1;\n            for(;;){\n                j = s.find(\"((\", j+1);\n                if(j == string::npos)\n                    break;\n                int k = j+2;\n                int bracket = 0;\n                while(k < n){\n                    if(s[k] == '(')\n                        ++ bracket;\n                    else if(s[k] == ')')\n                        -- bracket;\n                    if(bracket == -1)\n                        break;\n                    ++ k;\n                }\n                if(k < n && s.substr(k, 2) == \"))\")\n                    ng = true;\n            }\n            if(ng)\n                continue;\n\n            Node* node = sa.makeTree(s);\n            if(node != NULL){\n                ret = max(ret, solve(node));\n                delete node;\n            }\n        }\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p;\nbool flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  if(s[p]=='('){\n    flg&=check2();\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\n\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    else {\n      if(s[p]==')')break;\n      flg&=check(p+1);\n      if(s[p]=='+')p++,flg&=check2(),res+=bnf();\n      else if(s[p]=='-')p++,flg&=check2(),res-=bnf();\n      else if(s[p]=='*'){\n\tif(s[p++]=='(')flg&=check2(),res*=bnf();\n\telse res*=Num();\n      }\n      else break;\n    }\n  }\n  if(!flg||res>=1024||res<0)return -INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstdlib>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\nbool deb;\n\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\n  bool safe,mul;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n    safe = mul = false;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      safe = true;\n      int p = expression();\n      safe = false;\n      mul = false;\n      //cout << \"in fact, p = \" << p << endl;\n      pos++;\n      return p;\n    }else{\n      int ru = 0;\n      string p; p.clear();\n      \n      while('0' <= parse[pos] && parse[pos] <= '1'){\n\tp += parse[pos];\n\tpos++;\n      }\n      reverse(p.begin(),p.end());\n      int ip = 0;\n      bool ook = false;\n      for(int i=0;i<p.length();i++){\n\tif(p[i] == '1'){\n\t  ip += pow((double)2,(double)ru);\n\t}\n\took = true;\n\tru++;\n      }\n      if(!ook)ip = -1;\n      //cout << \"in fact, ip = \" << ip << endl;\n      return ip;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p < 0 || p >=1024){\n      //cout << \"error! in term, limit over error\" << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tmul = true;\n\tint fac= fact();\n       \n\tif(fac < 0 || fac >= 1024){\n\t  //cout << \"error! in term(while *), BNF error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n\tp *= fac;\n\t//cout << \"in term(while *), fact =  \" << fac << endl;\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(p < 0 || p >= 1024){\n      //cout << \"error! in expression, limit over error\" << endl;\n      deb = true;\n      return -1;\n    }\n    if(!(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*' || pos == parse.length() || (safe && mul && parse[pos] == ')'))){\n      //cout << \"error! in expression, not operator. parse[pos] = \" << parse[pos] << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tp+=term();\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else if(parse[pos] == '-'){\n\tpos++;\n\tp-=term();\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else {\n\t//cout << \"error! in expression, not operator Ver2.\" << endl;\n\t//assert(true);\n\tdeb = true;\n\treturn -1;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\n\nint Fans;\nchar perm[7] = {'0','1','+','-','*','(',')'};\nvoid all_permutation(string s){\n\n  for(int i=0;i<s.length();i++){\n    if(s[i] == '.'){\n      for(int j=0;j<7;j++){\n\tstring pre = s;\n\ts[i] = perm[j];\n\tall_permutation(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      deb = false;\n      //cout << \"s = \" << s << endl;\n      Parsing par = Parsing(s);\n      int ans = par.expression();\n      //cout <<\"ans = \" << ans  << \",deb = \" << deb << \",true =\" << true<< endl;\n      if(!deb) Fans = max(Fans,ans); \n    }\n  }\n\n}\n\nint main(){\n  string s;\n  while(cin >> s){\n  Fans = -1;\n \n  all_permutation(s);\n  cout << Fans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool err;\n\nvoid valid(int n)\n{\n\tif (n<0 || 1023<n)\n\t\terr = true;\n}\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\tvalid(res);\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else if (isdigit(s[p])) {\n\t\treturn number(s);\n\t} else {\n\t\terr = true;\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\tvalid(ret);\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\tfor(;;) {\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += term(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= term(s);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvalid(res);\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\tvalid(res);\n\treturn res;\n}\n\nbool isOpe(char c)\n{\n\treturn (c=='+'||c=='-'||c=='*');\n}\n\nbool check(string s)\n{\n\tvector<int> ope;\n\t\n\tif (s[N-1]=='+' || s[N-1]=='-' || s[N-1]=='*' || s[N-1]=='(')\n\t\treturn false;\n\t\n\trep(i, s.size()-1) {\n\t\tif (isOpe(s[i])&&isOpe(s[i+1]))\n\t\t\treturn false;\n\t}\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tope.push_back(0);\n\t\t} else if (s[i]==')') {\n\t\t\tif (d<0 || !ope[d]) return false;\n\t\t\tope.erase(ope.begin()+d);\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), 0);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>=1024) res=-1;\n\t\t\n\t\t\t//cerr << \"Persing : \" << s << endl;\n\t\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\t\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint p,flag,ans=-1;\nstring s;\nmap<int,char>cc;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])){\n    while(isdigit(s[p]))res=res*2+(s[p++]-'0');\n  }\n  else flag++;\n  if(res>=1024)flag++;\n  return res;\n}\nint bnf2(){\n  int res=get_A();\n  while(s[p]=='*'){\n    int t=p++;\n    if(s[t]=='*')res*=get_A();\n  }\n  if(res>=1024)flag++;\n  return res;\n}\nint bnf1(){\n  int res=bnf2();\n  while(s[p]=='+'||s[p]=='-'){\n    int t=p++;\n    if(s[t]=='+')res+=bnf2();\n    if(s[t]=='-')res-=bnf2();\n  }\n  if(res>=1024)flag++;\n  return res;\n}\nbool ch(int t){\n  int res=0;\n  while(s[p]!=')'){\n    if(s[p]=='('){\n      p++;\n      if(!ch(1))return 0;\n    }\n    if(p>=s.size())break;\n    if(s[p]=='+'||s[p]=='-'||s[p]=='*')res++;\n    if(p>=s.size())return 0;\n    p++;\n  }\n  p++;\n  return (!t)||res;\n}\nvoid dfs(int d){\n  if(d==s.size()){\n    p=0;\n    if(ch(0)){\n      p=flag=0;\n      int res=bnf1();\n      if(!flag&&p==s.size())ans=max(ans,res);\n    }\n  }\n  else if(s[d]=='.'){\n    r(i,7){\n      s[d]=cc[i];\n      dfs(d+1);\n    }\n    s[d]='.';\n  }\n  else dfs(d+1);\n}\nmain(){\n  cin>>s;\n  cc[0]='0';\n  cc[1]='1';\n  cc[2]='+';\n  cc[3]='-';\n  cc[4]='*';\n  cc[5]='(';\n  cc[6]=')';\n  dfs(0);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<int,int> expr(const string &s, int i, bool top = false);\n\npair<int,int> num(const string &s, int i) {\n  if (i >= s.size()) throw \"invalid expr\";\n  int v = 0;\n  while(i < s.size() && '0' <= s[i] && s[i] <= '9') {\n    v *= 2;\n    v += s[i] - '0';\n    if (v < 0 || v >= 1024) throw \"invalid number\";\n    ++i;\n  }\n  return make_pair(v, i);\n}\n\npair<int,int> factor(const string &s, int i) {\n  if (i >= s.size()) throw \"invalid expr\";\n  if (s[i] == '(') {\n    auto p = expr(s, i+1);\n    if (p.second >= s.size() || s[p.second] != ')') throw \"invalid expr\";\n    ++p.second;\n    return p;\n  }\n  if (s[i] < '0' || '9' < s[i]) throw \"invalid expr\";\n  return num(s, i);\n}\n\ntuple<int,int,bool> term(const string &s, int i, bool top) {\n  if (i >= s.size()) throw \"invalid expr\";\n  int v;\n  tie(v, i) = factor(s, i);\n  while(i < s.size() && s[i] == '*') {\n    top = true;\n    auto p = factor(s, i+1);\n    v *= p.first;\n    if (v < 0 || v >= 1024) throw \"invalid number\";\n    i = p.second;\n  }\n  return make_tuple(v, i, top);\n}\n\npair<int,int> expr(const string &s, int i, bool top) {\n  if (i >= s.size()) throw \"invalid expr\";\n  int v;\n  tie(v, i, top) = term(s, i, top);\n  while(i < s.size() && (s[i] == '+' || s[i] == '-')) {\n    top = true;\n    auto p = term(s, i+1, true);\n    if (s[i] == '+') v += get<0>(p);\n    else v -= get<0>(p);\n    if (v < 0 || v >= 1024) throw \"invalid number\";\n    i = get<1>(p);\n  }\n  if (i < s.size() && s[i] != ')') throw \"invalid expr\";\n  if (!top) throw \"invalid expr\";\n  return make_pair(v, i);\n}\n\nint maxv(string &s, int i) {\n  if (i == s.size()) {\n    try {\n      auto p = expr(s, 0, true);\n      if (p.second != s.size()) return -1;\n      return p.first;\n    } catch(...) {\n      return -1;\n    }\n  }\n  if (s[i] == '.') {\n    string chars = \"01+-*()\";\n    int mx = -1;\n    REP(j,7) {\n      s[i] = chars[j];\n      mx = max(mx, maxv(s, i+1));\n    }\n    s[i] = '.';\n    return mx;\n  } else {\n    return maxv(s, i+1);\n  }\n}\n\nint main() {\n  string s;\n  cin>>s;\n  cout << maxv(s, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1<<10)\nusing namespace std;\n\nstring s;\nvector<int> idx;\nvector<char> c;\nchar lis[7]={'0','1','+','-','*','(',')'};\n\nint ans=-1, p;\n\nint bnf();\n\nint bnf3(){\n\n  int res=0;\n  \n  if(s[p]=='('){\n    p++;\n    res=bnf();\n    p++;\n    return res;\n  }\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0', p++;\n  \n  return res;\n}\n\nint bnf2(){\n  \n  int res=bnf3();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='*'){\n      p++;\n      res=res*bnf3();\n      if(res>=INF) res=INF;\n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n      p++;\n      res=res+bnf2();\n      if(res>=INF) res=INF;\n    }\n    if(s[p]=='-'){\n      p++;\n      res=res-bnf2();\n    }else break;\n    \n  }\n  \n  return res;\n}\n\nbool check(){\n\n  int r=0;\n  \n  for(int i=0;i<s.size();i++){\n    \n    if(s[i]=='*'||s[i]=='+'||s[i]=='-'){\n      if(!i||i==s.size()-1) return false;\n      if(s[i-1]=='*'||s[i-1]=='+'||s[i-1]=='-'||s[i-1]=='(') return false;\n      if(s[i+1]=='*'||s[i+1]=='+'||s[i+1]=='-'||s[i+1]==')') return false;\n    }\n    \n    if(s[i]=='('){\n      int f=0;\n      for(int j=i+1;j<s.size();j++){\n\tif(s[j]==')') break;\n\tif(s[j]!='0'&&s[j]!='1') f=1;\n      }\n      if(!f) return false;\n      r++;\n    }\n    if(s[i]==')'){\n      if(!r) return false;\n      r--;\n    }\n    \n  }\n  \n  if(r!=0) return false;\n\n  return true;\n}\n\nvoid dfs(int x){\n  \n  if(x==idx.size()){\n    \n    for(int i=0;i<idx.size();i++)\n      s[idx[i]]=c[i];\n\n    if(!check()) return ;\n    \n    p=0;\n    \n    ans=max(ans,bnf());\n    \n    return ;\n  }\n  \n  for(int i=0;i<7;i++){\n    \n    c[x]=lis[i];\n    \n    dfs(x+1);\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>s;\n  \n  for(int i=0;i<s.size();i++)\n    if(s[i]=='.') idx.push_back(i);\n\n  c.resize(idx.size());\n\n  dfs(0);\n  \n  if(ans>=(1<<10)) ans=-1;\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p;\nbool flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  if(s[p]=='('){\n    flg&=check2();\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\nint calc(){\n  p++;\n  flg&=check2()&check(p);\n  if(s[p]=='(') return bnf();\n  int a=Num();\n  if(s[p]=='*') return a*calc();\n  return a;\n}\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(p+1);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n  }\n  if(!flg||res>=1024||res<0)return -INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint is_digit(char c) {\n  return c == '0' || c == '1';\n}\n\nint is_valid(int n) {\n  return 0 <= n && n < 1024;\n}\n\nint number(string &line, size_t &i) {\n  int n = 0;\n  while (i < line.size()) {\n    if (is_digit(line[i])) {\n      n = 2 * n + (line[i] - '0');\n      if (!is_valid(n)) {\n        i = line.size() + 1;\n      }\n    } else {\n      return n;\n    }\n    ++i;\n  }\n  return n;\n}\n\nint expr(string &, size_t &);\n\nint fact(string &line, size_t &i) {\n  int n;\n  if (line[i] == '(') {\n    ++i;\n    n = expr(line, i);\n    ++i;\n  } else if (is_digit(line[i])) {\n    n = number(line, i);\n  } else {\n    i = line.size() + 1;\n    return -1;\n  }\n  return n;\n}\n\nint term(string &line, size_t &i) {\n  int n = fact(line, i);\n  int out_num = line.size() + 1;\n  while (i < line.size()) {\n    if (line[i] == '*') {\n      ++i;\n      n *= fact(line, i);\n      if (!is_valid(n)) {\n        i = out_num;\n      }\n    } else {\n      return n;\n    }\n  }\n  return n;\n}\n\nint expr(string &line, size_t &i) {\n  int m;\n  int n = term(line, i);\n  int out_num = line.size() + 1;\n  while (i < line.size()) {\n    if (line[i] == '+' || line[i] == '-') {\n      char op = line[i];\n      ++i;\n      m = term(line, i);\n      if (op == '+') {\n        n += m;\n      } else {\n        n -= m;\n      }\n      if (!is_valid(n)) {\n        i = out_num;\n      }\n    } else if (line[i] == ')') {\n      return n;\n    } else {\n      i = out_num;\n    }\n  }\n  return n;\n}\n\nbool is_balanced(const string &line) {\n  int depth = 0;\n  int count[100];\n  for (int i = 0; i < 100; ++i) {\n    count[i] = 0;\n  }\n  for (size_t i = 0; i < line.size(); ++i) {\n    if (line[i] == '(') {\n      ++depth;\n    } else if (line[i] == ')') {\n      if (depth == 0 || count[depth] == 0) {\n        return false;\n      }\n      count[depth] = 0;\n      --depth;\n    } else if (line[i] == '+' || line[i] == '-' || line[i] == '*') {\n      ++count[depth];\n    }\n  }\n  return depth == 0;\n}\n\nint eval(string &line) {\n  if (is_balanced(line)) {\n    size_t i = 0;\n    int n = expr(line, i);\n    if (i == line.size()) {\n      return n;\n    }\n  }\n  return -1;\n}\n\nint solve(string &line, size_t i = 0) {\n  const char *chars = \"01+-*()\";\n  while (i < line.size()) {\n    if (line[i] == '.') {\n      int retval = -1;\n      for (size_t j = 0; chars[j]; ++j) {\n        line[i] = chars[j];\n        retval = max(retval, solve(line, i + 1));\n      }\n      line[i] = '.';\n      return retval;\n    }\n    ++i;\n  }\n  return eval(line);\n}\n\nint main() {\n  string line;\n  cin >> line;\n  cout << solve(line) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstring ch = \"01+-*()\";\nint ans = -1;\n\nint expression(const string& s, int& k);\nint factor(const string& s, int& k);\nint term(const string& s, int& k);\n\n// 数字が [0,1023] かチェック\nbool valid(const int n){\n\treturn (0 <= n && n < 1024);\n}\n\n// <number> ::= <digit> | <number> <digit>\nint number(const string& s, int& k){\n\tint r = 0;\n\twhile( s[k] == '0' || s[k] == '1' ){\n\t\tr = r * 2 + (s[k] - '0');\n\t\t++k;\n\t}\n\treturn r;\n}\n\nint expression(const string& s, int& k){\n\tint r1 = term(s, k);\n\tif( !valid(r1) ) return -1;\n\t\n\t/*while( k < s.size() ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}*/\n\twhile( s[k] == '+' || s[k] == '-' ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}\n\t}\n\treturn r1;\n}\n\nint factor(const string& s, int& k){\n\tif( s[k] == '(' ){ // 括弧のはじまりのとき\n\t\t++k; // '(' の 1つ先に進める.\n\t\tint r = expression(s, k);\n\t\t// 数字が [0,1023] の範囲にない or ')' がないとき\n\t\tif( !valid(r) || s[k] != ')' ) return -1;\n\t\t\n\t\t++k; // ')' の 1つ先に進める.\n\t\treturn r;\n\t}else if( s[k] == '0' || s[k] == '1' ){ // 数字のとき\n\t\treturn number(s, k);\n\t}else{\n\t\treturn -1;\n\t}\n}\n\nint term(const string& s, int& k){\n\tint r1 = factor(s, k);\n\t// 数字が [0,1023] の範囲にないとき \n\tif( !valid(r1) ) return -1;\n\t\n\t/*while( k < s.size() ){\n\t\tif( s[k] == '*' ){\n\t\t\t++k;\n\t\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 * r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}*/\n\twhile( s[k] == '*' ){\n\t\t++k;\n\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t// 数字が [0,1023] の範囲にないとき\n\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\tr1 = r1 * r2;\n\t}\n\treturn r1;\n}\n\n// 式が正しいかどうか.\n/*bool check(const string& s){\n\tint par = 0;\n\tchar prev = '\\0';\n\tdeque<bool> op(100, false);\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( prev == '\\0' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '(' ){\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '0' || prev == '1' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}\n\t\t\tprev = s[i];\n\t\t}else if( prev == '+' || prev == '-' || prev == '*' ){\n\t\t\tif( par > 0 ){\n\t\t\t\top[par] = true;\n\t\t\t}\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == ')' ){\n\t\t\tif( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}*/\n\nbool check(const string& s){\n\tstack<int> st;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '(' ){\n\t\t\tst.push(0);\n\t\t}else if( s[i] == ')' ){\n\t\t\tif( st.empty() ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tint cnt = st.top();\n\t\t\t\tif( cnt == 0 ){\n\t\t\t\t\treturn false;\n\t\t\t\t}else{\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\tif( !st.empty() ){\n\t\t\t\tint cnt = st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push( cnt + 1 );\n\t\t\t}\n\t\t}\n\t}\n\treturn st.empty();\n}\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tint t=0;\n\t\t// 式が正しいときだけ解を更新.\n\t\tif( check(s) ){\n\t\t\tint res = expression(s, t);\n\t\t\tans = max( ans , res );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n\nconst int MAX = 1023;\nconst int MIN = 0;\nchar ch[] = {\n  '0', '1', '+', '-', '*', '(', ')',\n};\nsize_t cur;\nstring str;\n\nint E(int &op_cnt);\n\nint number(){\n  int res = 0;\n  while(cur < str.size() && isdigit(str[cur])){\n    res = res * 2 + str[cur++] - '0';\n    if(res > MAX) return -1;\n  }\n  return res;\n}\n\nint T(){\n  int res;\n  if(isdigit(str[cur])){\n    res = number();\n  }else if(str[cur] == '('){\n    int cnt = 0;\n    cur++;\n    if(cur == str.size()) return -1;\n    res = E(cnt);\n    if(cur == str.size() || str[cur] != ')' || cnt == 0) res = -1;\n    cur++;\n  }else{\n    res = -1;\n  }\n  return res;\n}\n\nint F(int &op_cnt){\n  int res = 1;\n  vector<int> v;\n  v.push_back(T());\n  \n  while(cur < str.size() && str[cur] == '*'){\n    cur++;\n    op_cnt++;\n    if(cur == str.size()) return -1;\n    int tmp = T();\n    if(tmp < 0) return -1;\n    v.push_back(tmp);\n  }\n  \n  rep(i, v.size()){\n    res *= v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  return res;\n}\n\nint E(int &op_cnt){\n  int res = 0, tmp;\n  vector<int> v;\n  tmp = F(op_cnt);\n  \n  if(tmp < 0) return -1;\n  else v.push_back(tmp);\n  \n  while(cur < str.size() && (str[cur] == '+' || str[cur] == '-')){\n    char op = str[cur];\n    op_cnt++;\n    cur++;\n    if(cur == str.size()) return -1;\n    tmp = F(op_cnt);\n    if(tmp < 0) return -1;\n    else v.push_back(op == '+' ? tmp : -tmp);\n  }\n  \n  cout << str << \" \" << cur << \" \" << op_cnt << endl;\n  if(cur < str.size() && str[cur] != ')') return -1;\n  \n  rep(i, v.size()){\n    res += v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  cout << res << endl;\n  return res;\n}\n\nint calc(string s){\n  int cnt = 0;\n  str = s;\n  cur = 0;\n  return E(cnt);\n}\n\nint dfs(string s, int c){\n  if(c == 0) return calc(s);\n  \n  int res = -1;\n  int pos = find(s.begin(), s.end(), '.') - s.begin();\n  \n  rep(i, 7){\n    s[pos] = ch[i];\n    res = max(res, dfs(s, c - 1));\n    s[pos] = '.';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  cout << dfs(s, count(s.begin(), s.end(), '.')) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\n \nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\nbool OVER;\n \nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n \n  return true;\n}\n \nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n \n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n \n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true;\n  }\n  return false;\n}\n \nbool parapos(string s){\n  int p = 0;\n \n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n  }\n  return p == 0;\n}\n \nbool isvalid(string s){\n \n  if(!parapos(s)) return false;\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n \nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n \nint get(string s){\n  //  cout << \"S \" << s << endl;\n  \n  if(isnum(s)){\n    int tmp = tob(s);\n    if(tmp > 1023) OVER = true;\n    return tmp;\n  }\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+'){\n\tint tmp = get(s.substr(0,i))+get(s.substr(i+1));\n\tif(tmp > 1023) OVER = true;\n\treturn tmp;\n      }\n      if(p == 0 && s[i] == '-'){\n\tint tmp = get(s.substr(0,i))-get(s.substr(i+1));\n\tif(tmp < 0) OVER = true;\n\treturn tmp;\n      }\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*'){\n\tint tmp =  get(s.substr(0,i))*get(s.substr(i+1));\n\tif(tmp > 1023) OVER = true;\n\treturn tmp;\n      }\n    }\n  }\n}\n \nvoid solve(int n){\n \n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n\n    if(isvalid(in)){\n      OVER = false;\n      int num = get(in);\n      if(0 <= num && num < 1024 && !OVER) ans = max(ans,num);\n    }\n  }\n}\n \nint main(){\n \n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n \n  solve(0);\n \n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;Cursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(int& opc){\n\t\t\tll l=term(opc);\n\t\t\twhile(*c=='+' || *c=='-'){\n\t\t\t\tif(*c=='+'){\n\t\t\t\t\tc++;\n\t\t\t\t\tll r=term(opc);l+=r;\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tc++;\n\t\t\t\t\tll r=term(opc);l-=r;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\topc++;\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll term(int& opc){\n\t\t\tll l=factor();\n\t\t\twhile(*c=='*'){\n\t\t\t\tc++;ll r=factor();\n\t\t\t\tl*=r;\n\t\t\t\topc++;\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll factor(){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;\n\t\t\t\tint opc=0;\n\t\t\t\tll v=expression(opc);\t\n\t\t\t\tif(*c!=')' || opc==0)  throw ParseError();\n\t\t\t\tc++;\n\t\t\t\treturn v;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\treturn number();\n\t\t\t}else{\n\t\t\t\tthrow ParseError();\n\t\t\t}\n\t\t}\n\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t\t\tss << *c;c++;\n\t\t    }\n\t\t    string str;ss>>str;\n\t\t    ll res=0;\n\t\t    REP(i,str.size()){\n\t\t\t\tres*=2;if(str[i]=='1')res++;\n\t\t\t\tif(!IN(0,res,1<<10)) throw ParseError();\n\t\t    }\n\t\t    if(!IN(0,res,1<<10)) throw ParseError();\n\t\t\treturn res;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nchar symb[7]={'0','1','+','-','*','(',')'};\n\nclass Main{\npublic:\n\tstring s;\t\t\n\tbool input(){\n\t\tgetline(cin,s);\n\t\treturn true;\n\t}\n\n\tll dfs(int i){\n\t\tll Mv=-1;\n\t\tif(i==s.size()){\n\t\t\ttry{\n\t\t\t\tCursor c=s.begin();Syntax sy(s,c);int opc=0;\n\t\t\t\tll res=sy.expression(opc);\n\t\t\t\t\n\t\t\t\tif(c!=s.end())throw ParseError();\n\t\t\t\treturn res;\n\t\t\t}catch(ParseError e){return -1;}\n\t\t}\n\t\tif(s[i]=='.'){\n\t\t\tREP(j,7){\n\t\t\t\ts[i]=symb[j];\n\t\t\t\tMv=max(Mv,dfs(i+1));\n\t\t\t\ts[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tMv=max(Mv,dfs(i+1));\n\t\t}\n\t\treturn Mv;\n\t}\n\n\tvoid run(){\n\t\tinput();\n\t\tcout << dfs(0)<<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstring ch = \"01+-*()\";\nint ans = -1;\n\nint expression(const string& s, int& k);\nint factor(const string& s, int& k);\nint term(const string& s, int& k);\n\n// 数字が [0,1023] かチェック\nbool valid(const int n){\n\treturn (0 <= n && n < 1024);\n}\n\n// <number> ::= <digit> | <number> <digit>\nint number(const string& s, int& k){\n\tint r = 0;\n\twhile( s[k] == '0' || s[k] == '1' ){\n\t\tr = r * 2 + (s[k] - '0');\n\t\t++k;\n\t}\n\treturn r;\n}\n\nint expression(const string& s, int& k){\n\tint r1 = term(s, k);\n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*while( s[k] == '+' || s[k] == '-' ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}\n\t}*/\n\treturn r1;\n}\n\nint factor(const string& s, int& k){\n\tif( s[k] == '(' ){ // 括弧のはじまりのとき\n\t\t++k; // '(' の 1つ先に進める.\n\t\tint r = expression(s, k);\n\t\t// 数字が [0,1023] の範囲にない or ')' がないとき\n\t\tif( !valid(r) || s[k] != ')' ) return -1;\n\t\t\n\t\t++k; // ')' の 1つ先に進める.\n\t\treturn r;\n\t}else if( s[k] == '0' || s[k] == '1' ){ // 数字のとき\n\t\treturn number(s, k);\n\t}else{\n\t\treturn -1;\n\t}\n}\n\nint term(const string& s, int& k){\n\tint r1 = factor(s, k);\n\t// 数字が [0,1023] の範囲にないとき \n\tif( !valid(r1) ) return -1;\n\t\n\twhile( k < s.size() ){\n\t\tif( s[k] == '*' ){\n\t\t\t++k;\n\t\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 * r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*while( s[k] == '*' ){\n\t\t++k;\n\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t// 数字が [0,1023] の範囲にないとき\n\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\tr1 = r1 * r2;\n\t}*/\n\treturn r1;\n}\n\n// 式が正しいかどうか.\n/*bool check(const string& s){\n\tint par = 0;\n\tchar prev = '\\0';\n\tdeque<bool> op(100, false);\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( prev == '\\0' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '(' ){\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '0' || prev == '1' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}\n\t\t\tprev = s[i];\n\t\t}else if( prev == '+' || prev == '-' || prev == '*' ){\n\t\t\tif( par > 0 ){\n\t\t\t\top[par] = true;\n\t\t\t}\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == ')' ){\n\t\t\tif( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}*/\n\nbool check(const string& s){\n\tstack<int> st;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '(' ){\n\t\t\tst.push(0);\n\t\t}else if( s[i] == ')' ){\n\t\t\tif( st.empty() ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tint cnt = st.top();\n\t\t\t\tif( cnt == 0 ){\n\t\t\t\t\treturn false;\n\t\t\t\t}else{\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\tif( !st.empty() ){\n\t\t\t\tint cnt = st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push( cnt + 1 );\n\t\t\t}\n\t\t}\n\t}\n\treturn st.empty();\n}\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tint t=0;\n\t\t// 式が正しいときだけ解を更新.\n\t\tif( check(s) ){\n\t\t\tint res = expression(s, t);\n\t\t\tans = max( ans , res );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(p);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(s[p]=='*') res*=calc();\n  }\n  if(res<0||res>=1024) flg=0;\n  return res;\n}\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(p+1);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n    if(res<0||res>=1024) flg=0;\n  }\n  if(res<0||res>=1024) flg=0;\n  if(!flg)res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 10;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    *result *= rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 9;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseVaule(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  if(find(temp, it, '+')==it && find(temp, it, '*')==it && find(temp, it, '-')==it ){\n    return false;\n  }\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseVaule(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseVaule(it, &rv)) return false;\n    *result *= rv;\n    if(*result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p;\nbool flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n\n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  if(s[p]=='('){\n    flg&=check2();\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\n\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    else {\n      if(s[p]==')')break;\n      flg&=check(p+1);\n      if(s[p]=='+')p++,flg&=check2(),res+=bnf();\n      else if(s[p]=='-')p++,flg&=check2(),res-=bnf();\n      else if(s[p]=='*'){\n\tif(s[p++]=='(')flg&=check2(),res*=bnf();\n\telse res*=Num();\n      }\n      else break;\n    }\n  }\n  if(!flg)return -INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <stack>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef string::const_iterator State;\nint expr(State &be);\nint num(State &be){\n\tif(!isdigit(*be)) return -1;\n\tint ret=0;\n\twhile(isdigit(*be)){\n\t\tret*=2;\n\t\tret+=(*be-'0');\n\t\tbe++;\n\t}\n\treturn ret;\n}\nint factor(State& be){\n\tint ret;\n\tif(*be=='('){\n\t\tbe++;\n\t\tret=expr(be);\n\t\tif(*be!=')') return -1;\n\t\tbe++;\n\t\treturn ret;\n/*\t\tcout << ret << endl;\n\t\tif(ret==-1) return -1;\n\t\tint k=-1;\n\t\tcout << *be << endl;\n\t\tif(*be=='+') k=0;\n\t\tif(*be=='-') k=1;\n\t\tif(*be=='*') k=2;\n\t\tif(k==-1) return -1;\n\t\tbe++;\n\t\tint ret1=expr(be);\n\t\tif(ret1==-1) return -1;\n\t\tbe++;\n\t\tif(k==0) return ret+ret1;\n\t\tif(k==1) return max(-1,ret-ret1);\n\t\tif(k==2) return ret*ret1;\n\t\tcout << \"hoge\";*/\n\t}\n\treturn num(be);\n}\nint term(State& be){\n\tint ret=factor(be);\n\tif(ret==-1) return -1;\n\twhile(*be=='*'){\n\t\tbe++;\n\t\tint a=factor(be);\n\t\tif(a<0) return -1;\n\t\tret*=a;\n\t}\n\treturn ret;\n}\nint expr(State& be){\n\tint ret=term(be);\n\tif(ret==-1) return -1;\n\twhile(true){\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret+=a;\n\t\t}else if(*be=='-'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<0) return -1;\n\t\t}else break;\n\t}\n\treturn ret;\n}\nint main(){\n\tstring s,ch=\"01+-*()\";\n\tvector<int> vc;\n\tcin >> s;\n\tState be=s.begin();\n\trep(i,s.size()) if(s[i]=='.') vc.push_back(i);\n\tint n=vc.size(),p7=1,ans=-1;\n\trep(i,n) p7*=7;\n\trep(i,p7){\n\t\tstring t=s;\n\t\tint tmp=i;\n\t\trep(j,n){\n\t\t\tt[vc[j]]=ch[tmp%7];\n\t\t\ttmp/=7;\n\t\t}\n//\t\tcout << t << \"  \";\n\t\tstack<int> id;\n\t\tint cal[101]={};\n\t\tbool ok=true;\n\t\trep(i,t.size()){\n\t\t\tif(t[i]=='('){\n\t\t\t\tid.push(i);\n\t\t\t\tcal[i]=-1;\n\t\t\t}\n\t\t\tif(t[i]==')'){\n\t\t\t\tif(id.empty()){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tid.pop();\n\t\t\t}\n\t\t\tif(t[i]=='+' || t[i]=='-' || t[i]=='*'){\n\t\t\t\tif(!id.empty()) cal[id.top()]++;\n\t\t\t}\n\t\t}\n\t\tif(!id.empty()) ok=false;\n\t\trep(i,t.size()) if(cal[i]<0) ok=false;\n//\t\tcout << (ok ? \"valid\" : \"invalid\\n\");\n\t\tif(!ok) continue;\n\t\tState be=t.begin();\n\t\tint h=expr(be);\n\t\tif(be!=t.end()){\n//\t\t\tcout << endl;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout << \"     \" << h << endl;\n\t\tans=max(ans,h);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nstring s;\nstring u = \"01+-*()\";\nbool isnum(char t) {\n\treturn '0' <= t && t <= '9';\n}\n\nvector<int> v;\n\n\nll ans = -INF;\n\nstack<int> st; int tmp;\nll expr(string &s, int &i);\nll term(string &s, int &i);\nll factor(string &s, int &i);\nll number(string &s, int &i);\n\nbool  valid = true;\nll expr(string &s, int &i) {\n\tll x = term(s, i);\n\twhile (i < s.size()&&(s[i]=='+'||s[i]=='-')) {\n\t\ttmp++;\n\t\tchar ope = s[i];\n\t\ti++;\n\t\tll x2 = term(s, i);\n\t\tif (ope == '-')x -= x2;\n\t\telse x += x2;\n\t\tif (x < 0 || x >= 1024)valid = false;\n\t}\n\treturn x;\n}\nll term(string &s, int &i) {\n\tll x = factor(s, i);\n\twhile (i < s.size() && s[i] == '*') {\n\t\ttmp++;\n\t\ti++;\n\t\tll x2 = factor(s, i);\n\t\tx *= x2;\n\t\tif (x < 0 || x >= 1024)valid = false;\n\t}\n\treturn x;\n}\nll factor(string &s, int &i) {\n\tif (i == s.size()) {\n\t\tvalid = false; return 0;\n\t}\n\tif (isnum(s[i])) {\n\t\treturn number(s, i);\n\t}\n\telse if (s[i] == '(') {\n\t\tst.push(tmp); tmp = 0;\n\t\ti++;\n\t\tll x = expr(s, i);\n\t\tif (i == s.size() || s[i] != ')') {\n\t\t\tvalid = false; return 0;\n\t\t}\n\t\ti++;\n\t\tif (tmp == 0) {\n\t\t\tvalid = false; return 0;\n\t\t}\n\t\ttmp = st.top(); st.pop();\n\t\treturn x;\n\t}\n\telse {\n\t\tvalid = false; return 0;\n\t}\n}\nll number(string &s, int &i) {\n\tint res = s[i] - '0';\n\ti++;\n\twhile (i < s.size() && isnum(s[i])) {\n\t\tres = 2 * res + (s[i] - '0'); i++;\n\t\tif (res < 0 || res >= 1024)valid = false;\n\t}\n\treturn res;\n}\nvoid calc() {\n\tint i = 0; valid = true;\n\tll num = expr(s, i);\n\tif (i != s.size())valid = false;\n\tif (num < 0 || num >= 1024)valid = false;\n\tif (valid) {\n\t\tans = max(ans, num);\n\t}\n}\nvoid dfs(int id) {\n\tif (id == v.size()) {\n\t\tcalc(); return;\n\t}\n\trep(j, 7) {\n\t\ts[v[id]] = u[j];\n\t\tdfs(id + 1);\n\t}\n}\n\nvoid solve() {\n\tcin >> s;\n\trep(i, s.size()) {\n\t\tif (s[i] == '.')v.push_back(i);\n\t}\n\tdfs(0);\n\tif (ans == -INF)ans = -1;\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//init();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nclass ParseError {};\nstruct Result{\n  int value, p;\n  Result(int v, int p) : value(v), p(p) {}\n};\nvoid skip(const string& s, Result& r, char expected){\n  if(!(0 <= r.p && r.p < s.size())){\n    //cerr << r.p << \" is out range of \" << s << endl;\n    throw ParseError();\n  }else if(s[r.p] != expected){\n    //cerr << \"Expected '\" << expected << \"' but got '\" << s[r.p] << \"'\" << endl;\n    //cerr << \"String is '\" << s.substr(0, r.p) << \"*\" << s.substr(r.p + 1) << \"'\" << endl;;\n    throw ParseError();\n  }else {\n    r.p ++;\n  }\n}\nvoid checkvalue(int x){\n  if(x < 0 || x >= 1<<10) throw ParseError();\n}\nint checkpara(const string& s, int p){\n  bool invalid = true;\n  while(p < s.size()){\n    if(s[p] == '('){\n      p = checkpara(s, p + 1);\n    }else if(s[p] == ')'){\n      break;\n    }else if(!isdigit(s[p])){\n      invalid = false;\n    }\n    p++;\n  }\n  if(invalid) throw ParseError();\n  return p;\n}\nResult equation(const string& s, int p);\nResult factor(const string& s, int p);\nResult term(const string& s, int p);\nResult equation(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (s[r.p] == '+' || s[r.p] == '-')){\n    char c = s[r.p];\n    Result r2 = factor(s, r.p + 1);\n    r.value += (c == '+') ? r2.value : -r2.value;\n    r.p = r2.p;\n    checkvalue(r.value);\n  }\n  checkvalue(r.value);\n  return r;\n}\nResult factor(const string& s, int p){\n  Result r = term(s, p);\n  while(r.p < s.size() && s[r.p] == '*'){\n    Result r2 = term(s, r.p + 1);\n    r.value *= r2.value;\n    r.p = r2.p;\n    checkvalue(r.value);\n  }\n  checkvalue(r.value);\n  return r;\n}\nResult term(const string& s, int p){\n  if(s[p] == '('){\n    checkpara(s, p + 1);\n    Result r = equation(s, p + 1);\n    skip(s, r, ')');\n    checkvalue(r.value);\n    return r;\n  }else if(isdigit(s[p])){\n    int value = 0;\n    while(isdigit(s[p]) && p < s.size()){\n      value = (value << 1) + (s[p++] - '0');\n    }\n    checkvalue(value);\n    return Result(value, p);\n  }else {\n    throw ParseError();\n  }\n}\nstring cand = \"01+-*()\";\nint dfs(int k, vector<int>& index, string& s){\n  if(k == index.size()){\n    try{\n      Result r = equation(s, 0);\n      if(r.p != s.size()) r.value = -INF;\n      //cout<<s<<\" is \"<<r.value<<endl;\n      return r.value;\n    }catch(...){\n      //cout<<s<<\" is invalid.\"<<endl;\n      return -INF;\n    }\n  }else{\n    int res = -INF;\n    REP(i, cand.size()){\n      s[index[k]] = cand[i];\n      res = max(res, dfs(k + 1, index, s));\n    }\n    return res;\n  }\n}\n\nint main(){\n  string s;\n  while(cin>>s){\n    vector<int> index;\n    REP(i, s.size()) if(s[i] == '.') index.push_back(i);\n    int ans = dfs(0, index, s);\n    if(ans == -INF) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint p,len,flg;\n\nint calc();\n\nint getNum(){\n  if(flg)return 0;\n  \n  if(s[p]=='('){\n    p++;\n    int res=calc();\n    if(s[p]!=')')flg=1;\n    p++;\n    return res;\n  }else if('0'<=s[p]&&s[p]<='1'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='1'){\n      res=res*2+(s[p]-'0');\n      if(res>=1024){\n        flg=1;\n        return 0;\n      }\n      p++;\n    }\n    return res;\n  }else{\n    flg=1;\n    return 0;\n  }\n}\n\nint calc(){\n  int cnt=0;\n  int res=0;\n  int num=getNum();\n  while(p<len){\n    if(flg)return 0;\n    \n    char ch=s[p++];\n    if(ch=='+'){\n      res+=num;\n      num=getNum();\n      if(res<0||1024<=res)flg=1;\n    }else if(ch=='-'){\n      res+=num;\n      num=-getNum();\n      if(res<0||1024<=res)flg=1;\n    }else if(ch=='*'){\n      num*=getNum();\n      if(1024<=num)flg=1;\n    }else if(ch==')'){\n      p--;\n      if(cnt==0)flg=1;\n      break;\n    }else{\n      flg=1;\n    }\n    cnt++;\n  }\n  res+=num;\n  if(res<0)flg=1;\n  return res;\n}\n\nstring tmp=\"01+-*()\";\n\nstring str;\nint ans;\n\nvoid dfs(int pos){\n  if((int)str.size()==pos){\n    s=str;\n    len=str.size();\n    p=flg=0;\n    int k=calc();\n    if(flg==0&&p==(int)s.size())ans=max(ans,k);\n    return;\n  }\n\n  if(str[pos]=='.'){\n    for(int i=0;i<(int)tmp.size();i++){\n      str[pos]=tmp[i];\n      dfs(pos+1);\n      str[pos]='.';\n    }\n  }else{\n    dfs(pos+1);\n  }\n}\n\nint main(){\n  cin>>str;\n  ans=-1;\n  dfs(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool err;\n\nvoid valid(int n)\n{\n\tif (n<0 || 1023<n)\n\t\terr = true;\n}\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\tvalid(res);\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else if (isdigit(s[p])) {\n\t\treturn number(s);\n\t} else {\n\t\terr = true;\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tp++;\n\t\tret *= factor(s);\n\t\tvalid(ret);\n\t}\n\t\n\tvalid(ret);\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\tfor(;;) {\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += term(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= term(s);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tvalid(res);\n\t}\n\t\n\tvalid(res);\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\tvalid(res);\n\treturn res;\n}\n\nbool isOpe(char c)\n{\n\treturn (c=='+'||c=='-'||c=='*');\n}\n\nbool check(string s)\n{\n\tvector<int> ope;\n\t\n\tif (s[N-1]=='+' || s[N-1]=='-' || s[N-1]=='*' || s[N-1]=='(')\n\t\treturn false;\n\t\n\trep(i, s.size()-1) {\n\t\tif (isOpe(s[i])&&isOpe(s[i+1]))\n\t\t\treturn false;\n\t}\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tif (i!=0 && !isOpe(s[i-1]) && s[i-1]!='(')\n\t\t\t\treturn false;\n\t\t\tope.push_back(0);\n\t\t} else if (s[i]==')') {\n\t\t\tif (d<0 || !ope[d]) return false;\n\t\t\tope.erase(ope.begin()+d);\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), 0);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>=1024) res=-1;\n\t\t\n\t\t//cerr << \"Persing : \" << s << endl;\n\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\t\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s)\n{ \n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')')return false;\n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n  \n  for(int i=0;i<s.length();i++)\n    {\n      assert(s[i] != '.');\n      if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n      if(s[i] == '(' || s[i] == ')')\n\t{\n\t  if(s[i] == ')' && s[i+1] == '(')return false;\n\t  if(s[i] == '(' && s[i+1] == ')')return false;\n\t  if(s[i] == ')' && i+1 < s.length())\n\t    {\n\t      if(!(s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n\t    }\n\t  if(s[i] == '(' && i-1 >= 0)\n\t    {\n\t      if(s[i-1] == '0' || s[i-1] == '1' || s[i-1] == ')')return false;\n\t    }\n\t  \n\t}\n      if(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t{\n\t  if(i == s.length()-1)return false;\n\t  if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n\t  if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n\t}\n    }\n  \n  \n  for(int i=0;i < s.length();i++)\n    {\n      if(s[i] == '(')\n\t{\n\t  stk.push(s[i]);\n\t  pos.push(i);\n\t}\n      else if(s[i] == ')')\n\t{\n\t  if((int)stk.size() <= 0)return false;\n\t  int here = pos.top();\n\t  bool exist = false;\n\t  for(int j=here;j<i;j++)\n\t    {\n\t      if((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j])\n\t\t{\n\t\t  used[j] = exist = true;\n\t\t}\n\t    }\n\t  if(!exist)return false;\n\t  stk.pop();\n\t  pos.pop();\n\t}\n    }  \n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\npublic:\n  \n  Parsing(string s)\n  {\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '(')\n      {\n      pos++;\n      int p = expression();\n      if(!(0<= p && p < 1024))return FAILED;\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n      }else\n      {\n\tint p=0,ru = 0;\n\tstring nes;\n\tnes.clear();\n\twhile('0' == parse[pos] || parse[pos] == '1')\n\t  {\n\t    nes += parse[pos];\n\t    pos++;\n\t  }\n\treverse(all(nes));\n\trep(i,nes.length())\n\t  {\n\t    if(nes[i] == '1')p += (1<<ru);\n\t    ru++;\n\t  }      \n\tif(!(0<=p && p<1024))return FAILED;\n\treturn p;\n      }\n  }\n  \n  int term()\n  {\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*')\n      {\n\tif(parse[pos] == '*')\n\t  {\n\t    pos++;\n\t    int pre;\n\t    pre = fact();\n\t    if(pre == FAILED)return FAILED;\n\t    p*=pre;\n\t    if(!(0<=p && p<1024))return FAILED;\n\t  }\n      }\n    return p;\n  }\n  \n  int expression()\n  {\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-')\n      {\n\tif(parse[pos] == '+')\n\t  {\n\t    pos++;\n\t    int pre;\n\t    pre = term();\n\t    if(!(0<=pre && pre<1024))return FAILED;\n\t    if(pre == FAILED)return FAILED;\n\t    p += pre;\t    \n\t    if(!(0<=p && p<1024))return FAILED;\n\t  }\n\telse \n\t  {\n\t    pos++;\n\t    int pre;\n\t    pre =term();\n\t    if(!(0<=pre && pre<1024))return FAILED;\n\t    if(pre == FAILED)return FAILED;\n\t    p-=pre;\n\t    if(!(0<=p && p<1024))return FAILED;\n\t  }\n      }\n    return p;\n  }\n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\nint Max = -1;\nvoid solve(string s)\n{\n  rep(i,s.length())\n    {\n      if(s[i] == '.')\n\t{\n\t  rep(j,7){\n\t    s[i] = key[j];\n\t    solve(s);\n\t    s[i] = '.';\n\t  }\n\t  break;\n\t}\n      if(i == s.length()-1)\n\t{\n\t  //cout << \"s = \" << s;\n\t  if(!check(s)){\n\t    //cout << \" is Ver.1 FAILED\" << endl;\n\t    continue;\n\t  }\n\t  Parsing par = Parsing(s);\n\t  int men = par.expression();\n\t  if(men == FAILED)\n\t    {\n\t      //cout << \" is Ver.2 FAILED\" << endl;\n\t      continue;\n\t    }\n\t  //cout << \"is OK\" << endl;\n\t  Max = max(Max,men);\n\t  if(Max == 1023)return;\n\t}\n    }\n}\n\nint main()\n{\n  string s;\n  cin >> s;\n  solve(s);\n  cout << Max << endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nchar ln[7]={'0','1','+','-','*','(',')'};\nint n=0,ans=-1;\nint p[5]={};\nint ind[5]={};\nstring s,t;\nmap<int,int> mp;\n\nstring f(string a){\n  if(a==\"+\" || a==\"-\" || a==\"*\" || a==\"(\" || a==\")\")return a;\n  reverse(a.begin(),a.end());\n  int res=0;\n  for(int i=0;i<a.length();i++)res+=(pow(2,i)*(a[i]-'0'));\n  ostringstream os;\n  os<<res;\n  return os.str();\n}\n\nint cal(vector<string> v){\n  if(v.empty())return -1;\n  //if(v.size()==3 && (v[1][0]=='0' || v[1][0]=='1') && v[0]==\"(\" && v[2]==\")\")return -1; \n  vector<string> vs1,vs2,vs3;\n  for(int i=0;i<v.size();i++){\n    if(v[i]==\"(\"){\n      vector<string> tmp;\n      int l=1,r=0,count=0;\n      for(int j=i+1;j<v.size();j++){\n\tif(v[j]==\"(\")l++;\n\tif(v[j]==\")\")r++;\n\tif((l-r)==1 && (v[j]==\"+\" || v[j]==\"*\" || v[j]==\"-\"))count++;\n\tif(r==l){\n\t  if(count==0)return -1;\n\t  i=j;\n\t  break;\n\t}\n\ttmp.push_back(v[j]);\n      }\n      int res=cal(tmp);\n      if(res==-1 || 1024<=res)return -1;\n      ostringstream os;\n      os<<res;\n      vs1.push_back(os.str());\n    }\n    else vs1.push_back(v[i]);\n  }\n  //if((vs1[1][0]=='0' || vs1[1][0]=='1') && vs1[0]==\"(\" && vs1[2]==\")\")return -1;\n  if(vs1[0]==\"+\" || vs1[0]==\"*\" || vs1[0]==\"-\")return -1;\n  int size=vs1.size()-1;\n  if(vs1[size]==\"+\" || vs1[size]==\"*\" || vs1[size]==\"-\")return -1;\n  for(int i=0;i<vs1.size();i++){\n    if(vs1[i]==\"*\"){\n      if('0'<=vs1[i+1][0] && vs1[i+1][0]<='9' && '0'<=vs2.back()[0] && vs2.back()[0]<='9' ){\n\tint tmp1=atoi(vs2.back().c_str()),tmp2=atoi(vs1[i+1].c_str());\n\tvs2.pop_back();\n\tostringstream os;\n\tos<<(tmp1*tmp2);\n\tif(1024<=tmp1*tmp2)return -1;\n\tvs2.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs2.push_back(vs1[i]);\n  }\n  for(int i=0;i<vs2.size();i++){\n    if(vs2[i]==\"+\" || vs2[i]==\"-\"){\n      string tmp=vs3.back();\n      if('0'<=vs2[i+1][0] && vs2[i+1][0]<='9' && '0'<=tmp[0] && tmp[0]<='9' ){\n\tint tmp1=atoi(tmp.c_str()),tmp2=atoi(vs2[i+1].c_str());\n\tvs3.pop_back();\n\tostringstream os;\n\tint res;\n\tif(vs2[i]==\"+\")res=(tmp1+tmp2);\n\tif(vs2[i]==\"-\")res=(tmp1-tmp2);\n\tif(res<0 || 1024<=res)return -1;\n\tos<<res;\n\tvs3.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs3.push_back(vs2[i]);\n  }\n  if(vs3.size()==1 && '0'<=vs3[0][0] && vs3[0][0]<='9')return atoi(vs3[0].c_str());\n  return -1;\n}\n\nvoid rec(int v){\n  if(v==n){\n    t=s;\n    for(int i=0;i<n;i++)t[ind[i]]=ln[p[i]];\n    string tmp=\"\";\n    vector<string> vs;\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='0' || t[i]=='1')tmp+=t[i];\n      else {\n\tif(tmp!=\"\")vs.push_back(tmp);\n\ttmp=\"\";\n\tstring st=\"\";\n\tst+=t[i];\n\tvs.push_back(st);\n      }\n    }\n    if(tmp!=\"\")vs.push_back(tmp);\n    stack<int> st;\n    for(int i=0;i<vs.size();i++){\n      if(vs[i]==\"(\")st.push(i);\n      if(vs[i]==\")\"){\n        if(st.empty())return;\n        st.pop();\n      }\n    }\n    if(!st.empty())return;\n    /*\n    for(int i=1;i<vs.size()-1;i++){\n      if((vs[i][0]=='0' || vs[i][0]=='1') && vs[i-1]==\"(\" && vs[i+1]==\")\")return;\n    }\n    for(int i=1;i<vs.size();i++){\n      if(vs[i]==\")\" && !('0'<=vs[i-1][0] && vs[i-1][0]<='9'))return;\n    }\n    for(int i=0;i<vs.size()-1;i++){\n      if(vs[i]==\"(\" && !('0'<=vs[i+1][0] && vs[i+1][0]<='9'))return;\n      }*/\n    for(int i=0;i<vs.size();i++)vs[i]=f(vs[i]);\n    int res=cal(vs);\n    ans=max(ans,res);\n  }\n  else {\n    for(int i=0;i<7;i++){\n      rec(v+1);\n      p[v]++;\n    }\n    p[v]=0;\n  }\n}\n\nint main()\n{\n  cin>>s;\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='.'){\n      ind[n]=i;\n      n++;\n    }\n  }\n  rec(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nchar rp[]={'0','1','+','-','*','(',')'};\n \nvector<string> check(vector<string> ss){\n    vector<string> ans;\n    for(string x:ss){\n        bool sw=true;\n        int c=0;\n        for(int i=0;i<x.size()&&sw;i++){\n            if(x[i]=='(')c++;\n            if(x[i]==')')c--;\n            if(c<0)sw=false;\n        }\n        if(!c){\n            ans.push_back(x);\n        }\n    }\n    return ans;\n}\n \nvector<string> rek(vector<string> ss){\n    vector<string> ans;\n    int t;\n    if(ss[0].find(\".\")!=string::npos){\n        bool sw=true;\n        for(int i=0;i<ss[0].size()&&sw;i++){\n            if(ss[0][i]=='.'){\n                t=i;\n                sw=false;\n            }\n        }\n        for(string s:ss){\n            for(int i=0;i<7;i++){\n                s[t]=rp[i];\n                ans.push_back(s);\n            }\n        }\n        ans=rek(ans);\n        return ans;\n    }\n    else{\n        return ss;\n    }\n}\n \nint ana(string s){\n    if(s.size()==0)return -1;\n    int res;\n    int c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n            if(!c&&s[i]=='*'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a*b;\n                return(res>=0&&res<1024?res:-1);\n            }\n    }\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n        if(!c&&s[i]=='+'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a+b;\n            return(res>=0&&res<1024?res:-1);\n        }\n        if(!c&&s[i]=='-'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a-b;\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    if(*s.begin()=='('&&*(s.end()-1)==')'){\n        if(s.find(\"+\")==string::npos&&s.find(\"-\")==string::npos&&s.find(\"*\")==string::npos)return -1;\n        res=ana(s.substr(1,s.size()-2));\n        return (res>=0&&res<1024?res:-1);\n    }\n    else if(s.find(\"(\")!=string::npos)return -1;\n    else{\n        res=stoi(s,nullptr,2);\n        return(res>=0&&res<1024?res:-1);\n    }\n    return -1;\n}\n \n \nvoid solve(string s){\n    int ans=-1,anssub=0;\n    vector<string> ss;\n    ss.push_back(s);\n    ss=rek(ss);\n    ss=check(ss);\n    for(string x:ss){\n        anssub=ana(x);\n        if(anssub<1024&&anssub>=0)ans=max(ans,anssub);\n    }\n    cout<<ans<<endl;\n     \n     \n     \n}\n \nint main(){\n    string s;\n    cin>>s;\n    solve(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')')return false;\n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    assert(s[i] != '.');\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '(' || s[i] == ')'){\n      if(s[i] == ')' && s[i+1] == '(')return false;\n      if(s[i] == '(' && s[i+1] == ')')return false;\n      if(s[i] == ')' && i+1 < s.length()){\n\tif(!(s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      }\n      \n    }\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(!(0<= p && p < 1024))return FAILED;\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' == parse[pos] || parse[pos] == '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n\ntypedef long long ll;\nusing namespace std;\n\nll MAX = 1<<10;\n\nint chs[] = {'1','0','+','-','*','(',')'};\nint dotpoint[6],dotnum;\n\nint idx=0,pos=0;\nchar str[101];\nchar dot[101];\nint p7[6];\n\nchar peekc(){\n  if(str[pos]=='.')\n    return dot[pos];\n  else \n    return str[pos];\n}\n\nchar readc(){\n  char c=peekc();\n  pos++;\n  return c;\n}\n\nint opcall(char op,int a,int b){\n  if(a==-1||b==-1){\n    return -1;\n  }\n\n  int c;\n  switch(op){\n  case '+':\n    c = a+b;\n    break;\n  case '-':\n    c = a-b;\n    break;\n  case '*':\n    c = a*b;\n  }\n  if(c<0||c>=1024)\n    return -1;\n  else\n    return c;\n}\n\nint read1();\nint read2();\nint read3();\nint readparen();\nint readnum();\nbool flag=false;\n\nint read1(){\n  int l=read2();\n  while(1){\n    char op=peekc();\n    if(op=='+'||op=='-'){\n      flag=true;\n      readc();\n      l=opcall(op,l,read2());\n    }else{\n      break;\n    }\n  }\n  return l;\n}\n\nint read2(){\n  int l=read3();\n  while(1){\n    char op=peekc();\n    if(op=='*'){\n      flag=true;\n      readc();\n      l=opcall(op,l,read2());\n    }else{\n      break;\n    }\n  }\n  return l;\n}\n\nint read3(){\n  if(peekc()=='('){\n    return readparen();\n  }else if(peekc()=='0'||peekc()=='1'){\n    return readnum();\n  }else{\n    return -1;\n  }\n}\n\nint readparen(){\n  readc(); // '('\n  flag=false;\n  int l=read1();;\n  if(flag&&readc()==')'){\n    return l;\n  }else{\n    return -1;\n  }\n}\n\nint readnum(){\n  int i=0;\n  for(;peekc()=='0'||peekc()=='1';)\n    i=i*2+(readc()-'0');\n  if(i<0||i>=1024)\n    return -1;\n  else\n    return i;\n}\n\nint main(){\n  p7[0]=1;\n  for(int i=1; i<6; i++)\n    p7[i]=7*p7[i-1];\n\n  scanf(\"%s\",str);\n\n  dotnum=0;\n  for(int i=0; str[i]; i++){\n    if(str[i]=='.'){\n      dotpoint[dotnum++]=i;\n    }\n  }\n\n  int ans=-1;\n  for(int stat=0; stat<p7[dotnum]; stat++){\n    for(int j=0; j<dotnum; j++){\n      dot[dotpoint[j]]=chs[(stat/p7[j])%7];\n    }\n    pos=0;\n    int ret=read1();\n    if(str[pos]==0)\n      ans=(ans<ret)?ret:ans;\n  }\n\n  printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nint formula(int, int);\nstring s;\nvector<int> idx;\n\nint binary_to_int(const string& binary) {\n\tint res = 0, x = 1, n = binary.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(binary[n - 1 - i] == '1')\n\t\t\tres += x;\n\n\t\telse if(binary[n - 1 - i] != '0')\n\t\t\treturn -1;\n\n\t\tx <<= 1;\n\t}\n\n\treturn res;\n}\n\nint factor(int l, int r) {\n\tif(l == r)\n\t\treturn -1;\n\n\tif(s[l] == '(' && s[r - 1] == ')') {\n\t\tfor(int i = l + 1; i < r - 1; ++i)\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\treturn formula(l + 1, r - 1);\n\t}\n\n\treturn binary_to_int(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && s[i] == '*') {\n\t\t\tint vl = term(l, i), vr = factor(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\treturn vl * vr;\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\tint vl = formula(l, i), vr = term(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn vl + vr;\n\n\t\t\telse\n\t\t\t\treturn vl - vr;\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nint dfs(int d = 0) {\n\tif(d == idx.size()) {\n\t\tconst int res = formula(0, s.size());\n\t\treturn res >= 1024 ? -1 : res;\n\t}\n\n\tint res = -1;\n\tstatic const char c[7] = {'0', '1', '*', '+', '-', '(', ')'};\n\tfor(int i = 0; i < 7; ++i) {\n\t\ts[idx[d]] = c[i];\n\t\tchmax(res, dfs(d + 1));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tidx.push_back(i);\n\n\tcout << dfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(!(0<= p && p < 1024))return FAILED;\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' == parse[pos] || parse[pos] == '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  while(*it=='0') ++it;\n\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 10;\n  *result = (*it - '0') << max_length;\n  \n  int length = 1;\n  while(true){\n    if(it+length==end || (*(it+length)!='0' && *(it+length)!='1')) break;\n    *result += (*(it+length) - '0') << (max_length-length);\n    ++length;\n  }\n  *result >>= max_length-length + 1;\n  if(*result >= 1024) return false;\n  \n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  \n  unsigned long long lv = *result;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    lv *= rv;\n    if(lv >= 1024) return false;\n  }\n  *result = lv;\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  \n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define LOG(...) fprintf(stderr,__VA_ARGS__)\n#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst char cs[] = {'0', '1', '+', '-', '*', '(', ')'};\nconst int MAX_VAL = 1024;\n\nint LEN;\nint UNKNOWN;\n\nint expr(string s, int& idx, bool& op);\nint term(string s, int& idx, bool& op);\nint factor(string s, int& idx, bool& op);\nint number(string s, int& idx);\n\nvoid ASSERT(bool cond, string err) {\n    if (!cond) throw err;\n}\n\nvoid NEXT(int& idx) {\n    idx++;\n    ASSERT(idx < LEN, \"index out of range\");\n}\n\nint expr(string s, int& idx, bool& op) {\n    int ret = term(s, idx, op);\n    for (;;) {\n        if (s[idx] == '+') {\n            NEXT(idx);\n            ASSERT(idx < LEN, \"end of line: +\");\n            op = true;\n            ret += term(s, idx, op);\n            ASSERT(0 <= ret && ret < MAX_VAL, \"number out of range\");\n        } else if (s[idx] == '-') {\n            NEXT(idx);\n            ASSERT(idx < LEN, \"end of line: -\");\n            op = true;\n            ret -= term(s, idx, op);\n            ASSERT(0 <= ret && ret < MAX_VAL, \"number out of range\");\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint term(string s, int& idx, bool& op) {\n    int ret = factor(s, idx, op);\n    for (;;) {\n        if (s[idx] == '*') {\n            NEXT(idx);\n            ASSERT(idx < LEN, \"end of line: *\");\n            op = true;\n            ret *= factor(s, idx, op);\n            ASSERT(0 <= ret && ret < MAX_VAL, \"number out of range\");\n        } else if (s[idx] == '(') {\n            ASSERT(0, \"invalid open parenthese\");\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(string s, int& idx, bool& op) {\n    // ()?????????operator???????????????????????????????????????\n    if (s[idx] == '(') {\n        NEXT(idx);\n        bool copy = op;\n        op = false;\n        int ret = expr(s, idx, op);\n        ASSERT(op, \"no operator\");\n        ASSERT(s[idx] == ')', \"no close parenthese\");\n        op = copy;\n        idx++;\n        return ret;\n    } else {\n        return number(s, idx);\n    }\n}\n\nint number(string s, int& idx) {\n    int ret = 0;\n    ASSERT(isdigit(s[idx]), \"must be a number\");\n    while (isdigit(s[idx]) && idx < LEN) {\n        ret <<= 1;\n        ret |= s[idx] == '1' ? 1 : 0;\n        idx++;\n    }\n    ASSERT(0 <= ret && ret < MAX_VAL, \"number out of range\");\n    return ret;\n\n}\n\nint dfs(string s, int idx, int n) {\n    if (n == UNKNOWN) {\n        try {\n            int idx = 0;\n            bool op = false;\n            LOG(\"%s \", s.c_str());\n            int ret = expr(s, idx, op);\n            LOG(\"= %d (idx=%d)\\n\", ret, idx);\n            if (idx == LEN) {\n                return ret;\n            } else {\n                return -1;\n            }\n            return ret;\n        } catch (string e) {\n            LOG(\"--> %s\\n\", e.c_str());\n            return -1;\n        }\n    }\n    int ma = -1;\n    for (; idx < LEN; idx++) {\n        if (s[idx] == '.') {\n            for (char c : cs) {\n                s[idx] = c;\n                ma = max(ma, dfs(s, idx+1, n+1));\n            }\n        }\n    }\n    return ma;\n}\n\nvoid test(string s) {\n    LEN = SZ(s);\n    UNKNOWN = 0;\n    REP(i, SZ(s)) if (s[i] == '.') UNKNOWN++;\n\n    LOG(\"==> %s = %d\\n\", s.c_str(), dfs(s, 0, 0));\n}\n\nint main() {\n//    test(\"1(\");\n//    test(\"1)\");\n//    test(\"(1.1)\");\n//    test(\"(1+(.))\");\n\n    string s;\n    cin >> s;\n    LEN = SZ(s);\n    UNKNOWN = 0;\n    REP(i, SZ(s)) if (s[i] == '.') UNKNOWN++;\n\n    cout << dfs(s, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\nbool isd(string s){return isdigit(s[0]);}\n\nstring calc(vs s){\n    stack<int> p;\n    for(int i=0;i<s.size();i++){\n        if(s[i]==\"(\")p.push(i);\n        else if(s[i]==\")\"){\n            int f=p.top(); p.pop();\n            vs tmp;\n            s[f]=s[i]=\"-1\";\n            for(int j=f+1;j<i;j++){\n                tmp.pb(s[j]);\n                s[j]=\"-1\";\n            }\n            s[f]=calc(tmp);\n            //cout<<\"ans\"<<s[f]<<endl;\n        }\n    }\n    //for(auto c:s)cout<<setw(3)<<c;cout<<endl;\n    auto itr=remove(all(s),\"-1\");\n    s.erase(itr,s.end());\n    if(s.size()==0)return \"-1\";\n    //for(auto c:s)cout<<c<<\"      \";\n    \n    deque<int> oper;\n    deque<string> opec;\n    for(int i=0;i<s.size();i++){\n        if(isd(s[i])){\n            oper.pb(stoi(s[i]));\n        }else{\n            if(s[i]==\"*\"){\n                oper.back()*=stoi(s[++i]);\n                if(oper.back()<0 || oper.back()>1023) return \"-1\";\n            }else opec.pb(s[i]);\n        }\n    }\n    while(!opec.empty()){\n        int d=oper[0];\n        string c=opec[0];\n        oper.pop_front();\n        opec.pop_front();\n        oper.front()=(c==\"+\" ? d+oper.front() : d-oper.front());\n        if(oper.front()<0 || oper.front()>1023) return \"-1\";\n    }\n    //cout<<\"ans:\"<<to_string(oper[0])<<endl;\n    return to_string(oper[0]);\n}\n\n\nstring solve(string in){\n    vector<string> s;\n    bool ren=false;\n    for(auto c:in){\n        if(c=='0' || c=='1'){\n            if(ren){\n                s.back()+=c;\n            }else s.pb(\"\"s+c);\n            ren=true;\n        } else {\n            s.pb(\"\"s+c);\n            ren=false;\n        }\n    }\n    int dep=0;\n    for(int i=0;i<s.size();i++){\n        string &c=s[i];\n        if(c.length()>30){\n            return \"-1\";\n        }else{\n            try{\n                int p=stoi(c,nullptr,2);\n                c=to_string(p);\n            }catch(...){\n                if(c==\"(\")dep++;\n                else if(c==\")\")dep--;\n                if(dep<0 || dep>25)return \"-1\";\n            }\n        }\n    }\n    if(dep)return \"-1\";\n    //for(auto c:s)cout<<c;cout<<endl;\n    int exist=0,depth=0;\n    for(int i=0;i<s.size()-1;i++){\n        if(isd(s[i])){\n            if(s[i+1]==\"(\" || isd(s[i+1])) return \"-1\";\n        }else if(s[i]==\"(\"){\n            depth++;\n            if(s[i+1]==\"+\" || s[i+1]==\"-\" || s[i+1]==\"*\" || s[i+1]==\")\") return \"-1\";\n        }else if(s[i]==\")\"){\n            //cout<<depth<<\",\"<<exist<<endl;\n            if((exist&(1<<depth))==0) return \"-1\";\n            //cout<<\"OK\"<<endl;\n            exist&=~(1<<depth);\n            depth--;\n            if(isd(s[i+1]) || s[i+1]==\"(\") return \"-1\";\n        }else{\n            exist|=(1<<depth);\n            if(s[i+1]!=\"(\" && !isd(s[i+1])) return \"-1\";\n        }\n    }\n    if(s.back()==\")\"){\n        if((exist&(1<<depth))==0) return \"-1\";\n    }\n    int t=s.size()-1;\n    if(s[0]==\")\" || s[0]==\"+\" || s[0]==\"-\" || s[0]==\"*\") return \"-1\";\n    if(s[t]==\"(\" || s[t]==\"+\" || s[t]==\"-\" || s[t]==\"*\") return \"-1\";\n    //ここまでで除去ができているはず\n    //for(auto c:s)cout<<c;\n    string ans=calc(s);\n    //cout<<\"=\"<<ans<<endl;\n    return ans;\n}\n\nint bur(string s){\n    int ans=-1;\n    if(count(all(s),'.')==0) {\n        return stoi(solve(s));\n    }\n    for(auto d:\"01+-*()\"s){\n        string os=s;\n        os[s.find('.')]=d;\n        ans=max(ans,bur(os));\n    }\n    return ans;\n}\n\nint main(){\n    string o;\n    cin>>o;\n    cout<<bur(o)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s, tmp, let = \"01+-*()\";\nvi v;\nint n, p, ans;\n\nbool range(int t)\n{\n\treturn t >= 0 && t < (1 << 10);\n}\n\nint num()\n{\n\tint res = 0;\n\twhile (p < n && isdigit(tmp[p]))\n\t{\n\t\tres *= 2;\n\t\tres += tmp[p] - '0';\n\t\tp++;\n\t}\n\tif (!range(res)) return -1;\n\treturn res;\n}\n\npair<int, bool> plu();\n\nint unit()\n{\n\tint res;\n\tif (tmp[p] == '(')\n\t{\n\t\tp++;\n\t\tauto a = plu();\n\t\tif (a.second == false || tmp[p] != ')') return -1;\n\t\tres = a.first;\n\t\tp++;\n\t}\n\telse \n\t{ \n\t\tif (!isdigit(tmp[p])) return -1;\n\t\tres = num();\n\t}\n\tif (!range(res)) return -1;\n\telse return res;\n}\n\npair<int, bool> mul()\n{\n\tbool f = false;\n\tint res = unit();\n\twhile (tmp[p] == '*')\n\t{\n\t\tf = true;\n\t\tp++;\n\t\tint rhs = unit();\n\t\tif (rhs == -1) return make_pair(-1, f);\n\t\tres *= rhs;\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\npair<int, bool> plu()\n{\n\tauto a = mul();\n\tint res = a.first;\n\tbool f = a.second;\n\tif (res == -1) return make_pair(-1, f);\n\twhile (tmp[p] == '+' || tmp[p] == '-')\n\t{\n\t\tf = true;\n\t\tif (tmp[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres += rhs;\n\t\t}\n\t\telse if (tmp[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres -= rhs;\n\t\t}\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\nint parse()\n{\n\tp = 0;\n\tint res = plu().first;\n\tif (p != tmp.size()) return -1;\n\telse return res;\n}\n\nbool check1()\n{\n\tbool res = true;\n\tREP(i, tmp.size()) if (!isdigit(tmp[i])) res = false;\n\treturn res;\n}\n\nbool check2()\n{\n\tbool res;\n\tstring elem; //0 = number, 1 = operator, 2 = '('\n\tREP(i, tmp.size())\n\t{\n\t\tif (isdigit(tmp[i]))\n\t\t{\n\t\t\twhile (isdigit(tmp[i])) i++;\n\t\t\ti--;\n\t\t\telem.push_back('0');\n\t\t}\n\t\telse if (tmp[i] == '+' || tmp[i] == '-' || tmp[i] == '*')\n\t\t{\n\t\t\telem.push_back('1');\n\t\t}\n\t\telse if (tmp[i] == '(') elem.push_back('(');\n\t\telse if (tmp[i] == ')') elem.push_back(')');\n\t\telse assert(false);\n\t}\n\tif (elem.size() > 2)\n\t{\n\t\tREP(i, elem.size() - 2)\n\t\t{\n\t\t\tif (elem[i] == '('&&elem[i + 1] == '0'&&elem[i + 2] == ')') return false;\n\t\t}\n\t}\n\tif (elem.size() > 1)\n\t{\n\t\tREP(i, elem.size() - 1)\n\t\t{\n\t\t\tif (elem[i] == '('&&elem[i + 1] == ')') return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\nvoid solve(int i, vi w)\n{\n\tif (i == v.size())\n\t{\n\t\ttmp = s;\n\t\tREP(i, v.size())\n\t\t{\n\t\t\ttmp[v[i]] = let[w[i]];\n\t\t}\n\t\tp = 0;\n\t\tif (check1())\n\t\t{\n\t\t\tint res = num();\n\t\t\tchmax(ans, res);\n\t\t}\n\t\telse if (check2())\n\t\t{\n\t\t\tint res = parse();\n\t\t\tchmax(ans, res);\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, 7)\n\t\t{\n\t\t\tvi tmp = w;\n\t\t\ttmp.push_back(j);\n\t\t\tsolve(i + 1, tmp);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tans = -1;\n\tcin >> s;\n\tn = s.size();\n\tREP(i, n)\n\t{\n\t\tif (s[i] == '.') v.push_back(i);\n\t}\n\tvi emp;\n\tsolve(0, emp);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(e.first<0||!e.second||s[x]!=')')return fail;\n    x++;\n    return e;\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      x++;\n    }\n    if(n>=1<<10)return fail;\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(f.first<0)return f;\n  if(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(l.first<0)return l;\n    return make_pair(f.first*l.first,true);\n  }else{\n    return f;\n  }\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(f.first<0)return f;\n  if(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(l.first<0)return l;\n    return make_pair(f.first+sign*l.first,true);\n  }else{\n    return f;\n  }\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tm=max(m,dfs());\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntypedef string::iterator state;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstring _S, S;\nint ans = -1;\nstring moji = \"01+-*()\";\nbool ok = true;\nbool valid(string S) {\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] != '(') continue;\n        bool nowok = false;\n        int nownum = 0;\n        for(int j = i + 1; j < S.size(); j++) {\n            if(S[j] == '(') {\n                nownum++;\n                continue;\n            }\n            if(S[j] == ')') {\n                nownum--;\n                if(nownum < 0) break;\n                continue;\n            }\n            if(S[j] != '0' && S[j] != '1' && nownum == 0) nowok = true;\n        }\n        if(!nowok) return false;\n    }\n    return true;\n}\nint expression(state &itr);\nint factor(state &itr);\nint number(state &itr);\n\nint expression (state &itr) {\n    //cerr << \"e: \" << *itr << endl;\n    if(!ok) return -1;\n    int now = factor(itr);\n    if(now < 0 || now >= (1<<10)) ok = false;\n    while(ok) {\n    //cerr << \"E: \" << *itr << endl;\n        if(now < 0 || now >= (1<<10)) ok = false;\n        if(*itr == ')' || *itr == '=') return now;\n        if(*itr == '+') {\n            itr++;\n            now += factor(itr);\n            continue;\n        }\n        if(*itr == '-') {\n            itr++;\n            now -= factor(itr);\n            continue;\n        }\n        ok = false;\n    }\n}\n\nint factor (state &itr) {\n    if(!ok) return -1;\n    int now = number(itr);\n    if(now < 0 || now >= (1<<10)) ok = false;\n    while(ok) {\n        if(now < 0 || now >= (1<<10)) ok = false;\n        if(*itr == ')') return now;\n        if(*itr == '=') return now;\n        if(*itr == '+' || *itr == '-') {\n            return now;\n        }\n        if(*itr == '*') {\n            itr++;\n            now *= number(itr);\n            continue;\n        }\n        ok = false;\n    }\n}\n\nint number(state &itr) {\n    if(!ok) return -1;\n    if(*itr == '+' || *itr == '-' || *itr == '*' || *itr == '=' || *itr == ')') {\n        ok = false;\n        return -1;\n    }\n    int now;\n    if(*itr == '(') {\n        itr++;\n        now = expression(itr);\n        if(*itr != ')') {\n            ok = false;\n            return -1;\n        }\n        itr++;\n        if(now < 0 || now >= (1<<10)) ok = false;\n        return now;\n    }\n    now = 0;\n    while(*itr == '0' || *itr == '1') {\n        now *= 2;\n        now += *itr - '0';\n        itr++;\n    }\n    if(now < 0 || now >= (1<<10)) ok = false;\n    return now;\n}\n\nvoid g() {\n    ok = true;\n    state itr = S.begin(); \n    //cerr << S << endl;\n    if(!valid(S)) return;\n    int val = expression(itr);\n    //if(ok) cerr << \"result: \" << val << endl;\n    if(*itr != '=') return;\n    if(ok) ans = max(ans, val);\n}\n\nvoid f(int index) {\n    if(index == S.size()) {\n        g();\n        return;\n    }\n    if(_S[index] != '.') {\n        f(index + 1);\n        return;\n    }\n    for(int i = 0; i < moji.size(); i++) {\n        S[index] = moji[i];\n        f(index + 1);\n    }\n    return;\n}\n\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> _S;\n    _S += \"=\";\n    S = _S;\n    f(0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nll MOD=1000000007;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;Cursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(bool blacket){\n\t\t\tll l=term();int opc=0;\n\t\t\twhile(*c=='+' || *c=='-'){\n\t\t\t\topc++;\n\t\t\t\tif(*c=='+'){\n\t\t\t\t\tc++;l+=term();\n\t\t\t\t}else{\n\t\t\t\t\tc++;l-=term();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(blacket && opc==0)throw ParseError();\n\n\t\t\treturn l;\n\t\t}\n\n\t\tll term(){\n\t\t\tll l=factor();\n\t\t\twhile(*c=='*'){\n\t\t\t\tc++;l*=factor();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll factor(){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;\n\t\t\t\tll v=expression(true);\n\t\t\t\tif(*c!=')') throw ParseError();\n\t\t\t\tc++;\n\t\t\t\treturn v;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\treturn number();\n\t\t\t}else{\n\t\t\t\tthrow ParseError();\n\t\t\t}\n\t\t}\n\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t        ss << *c;c++;\n\t\t    }\n\t\t    string str;ss>>str;\n\t\t    ll res=0;\n\t\t    REP(i,str.size()){\n\t\t    \tres*=2;\n\t\t    \tif(str[i]=='1')res++;\n\t\t    }\n\t\t\treturn res;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nclass Main{\npublic:\n\tchar symb[5]={'0','1','+','-','*'};\n\tstring s;\t\t\n\tbool input(){\n\t\tgetline(cin,s);\n\t\ts.erase(remove(ALL(s), ' '), s.end());//空白除去\n\t\treturn true;\n\t}\n\n\tll dfs(int i){\n\t\tll Mv=-1;\n\t\tif(i==s.size()){\n\t\t\ttry{\n\t\t\t\tCursor c=s.begin();\n\t\t\t\tSyntax sy(s,c);\n\t\t\t\treturn sy.expression(false);\n\t\t\t}catch(ParseError e){return -1;}\n\t\t}\n\t\tif(s[i]=='.'){\n\t\t\tREP(j,5){\n\t\t\t\ts[i]=symb[j];\n\t\t\t\tMv=max(Mv,dfs(i+1));\n\t\t\t\ts[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tMv=max(Mv,dfs(i+1));\n\t\t}\n\t\treturn Mv;\n\t}\n\n\tvoid run(){\n\t\tinput();\n\t\tcout << dfs(0)<<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nclass SyntaxAnalysis\n{\npublic:\n    using T = pair<bool, int>;\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '*';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '(';\n    static T plus(const T& n, const T& k) { return {n.first and k.first and prop(n.second + k.second), n.second + k.second}; }\n    static T minus(const T& n, const T& k) { return {n.first and k.first and prop(n.second - k.second), n.second - k.second}; }\n    static T product(const T& n, const T& k) { return {n.first and k.first and prop(n.second * k.second), n.second * k.second}; }\n    static T divide(const T& n, const T& k) { return n; }\n    static T brace(const T& n) { return n; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '1'; }\n    static int encode(const char c) { return c - '0'; }\n    static bool prop(const int l) { return l >= 0 and l < (1 << 10); }\n    T number()\n    {\n        int ans = 0, start = S.size();\n        for (; pos < S.size() and is_digit(S[pos]); pos++) {\n            if (S[pos] == '1') { start = min(start, pos); }\n            ans = ans * 2 + encode(S[pos]);\n        }\n        return {pos - start <= 10, ans};\n    }\n    T factor()\n    {\n        if (S[pos] == BRACE) {\n            T ans;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    T term()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, f = factor(), ans = product(ans, f);\n            } else if (S[pos] == DIVIDE) {\n                pos++, f = factor(), ans = divide(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    T expression()\n    {\n        T ans = term();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = term(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = term(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\ntemplate <typename S, typename T>\ninline ostream& operator<<(ostream& os, const pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\n\nint main()\n{\n    constexpr char C[7] = {'0', '1', '+', '-', '*', '(', ')'};\n    string s;\n    cin >> s;\n    vector<int> p;\n    int NUM = 1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '.') { p.push_back(i), NUM *= 7; }\n    }\n    const int sz = p.size();\n    int ans = -1;\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0, num = i; j < sz; j++, num /= 7) { s[p[j]] = C[num % 7]; }\n        stack<int> st;\n        st.push(0);\n        bool ok = true, num = false;\n        for (const char c : s) {\n            if (c == '(') {\n                if (num) {\n                    ok = false;\n                    break;\n                }\n                st.push(0);\n            } else if (c == ')') {\n                if (st.size() <= 1 or st.top() == 0) {\n                    ok = false;\n                    break;\n                }\n                num = true;\n                st.pop();\n            } else if (c == '+' or c == '-' or c == '*') {\n                if (not num) {\n                    ok = false;\n                    break;\n                }\n                num = false;\n                const int n = st.top() + 1;\n                st.pop(), st.push(n);\n            } else {\n                num = true;\n            }\n        }\n        if (not ok or st.size() != 1 or not num) { continue; }\n        //show(s);\n        const auto sub = SyntaxAnalysis{s}.Expression();\n        //show(sub);\n        if (sub.first) { ans = max(ans, sub.second); }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 9;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseVaule(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  if(find(temp, it, '+')==it && find(temp, it, '*')==it && find(temp, it, '-')==it ){\n    return false;\n  }\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseVaule(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseVaule(it, &rv)) return false;\n    *result *= rv;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[5] = {\"0\", \"1\", \"+\", \"-\", \"*\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+5; ++l1){\n    for(string * l2=list; l2!=list+5; ++l2){\n      for(string * l3=list; l3!=list+5; ++l3){\n        for(string * l4=list; l4!=list+5; ++l4){\n          for(string * l5=list; l5!=list+5; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc();\nint expr();\nint number();\nstring tmp;\nint pos;\nchar c[]=\"()+-*01\";\nint ans=-1;\nbool f=0,ff;\nint calc(){\n  int res=expr();\n  while(1){\n    if(tmp[pos]=='*') {pos++;res*=expr();}\n    else break;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint expr(){\n  int res=number();\n  while(1){\n    if(tmp[pos]=='+') {pos++;res+=number();}\n    else if(tmp[pos]=='-') {pos++;res-=number();}\n    else break;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint number(){\n  int res=0;\n  if(tmp[pos]=='(') {\n    pos++;res=calc();pos++;\n  }else{\n    while(pos<(int)tmp.size()&&isdigit(tmp[pos])) {res=res*2+tmp[pos]-'0';pos++;}\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\n \nbool check(string s){\n  int o=0;\n  bool op[100]={};\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') {\n      o++;\n      op[o]=1;\n      if(i+1>=(int)s.size()) return 0;\n      if(!isdigit(s[i+1])&&s[i+1]!='(') return 0;\n    }    \n    if(s[i]==')') {\n      if(op[o]) return 0;\n      o--;\n      if(i-1<0) return 0;\n      if(!isdigit(s[i-1])&&s[i-1]!=')') return 0;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*') {\n      op[o]=0;\n      if(i-1<0||i+1>=(int)s.size()) return 0;\n      if((!isdigit(s[i-1])&&s[i-1]!=')')||(!isdigit(s[i+1])&&s[i+1]!='(')) return 0;\n    }\n    if(o<0) return 0;\n  }\n  if(o) return 0;\n  return 1;\n}\nvoid rec(string s){\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]!='.') continue;\n    for(int j=0;j<8;j++){\n      s[i]=c[j];\n      rec(s);\n    }\n    return;\n  }\n  if(!check(s)) return;\n  tmp=s;pos=0;ff=1;\n  int k=calc();\n  //cout<<k<<\":\"<<tmp<<endl;\n  if(pos==(int)tmp.size()&&ff) ans=max(ans,k);\n}\nint main(){\n  string s;\n  cin>>s;\n  rec(s);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nstring tract(string s){\n  // cout << s << \" \";\n  rep(i,s.size()){\n    if(s[i]=='k')return \"k\";\n  }\n  // まず数字を全てfに変える\n  string s_tmp(s);\n  while(1){\n    // 数字あるかチェック\n    // cout << \"he\" << endl;\n    // cout << s_tmp << endl;\n    int index = 0,flag=0;\n    while(index<s_tmp.size()){\n      if(s_tmp[index]=='0'||s_tmp[index]=='1'){flag=1;break;}\n      index++;\n    }\n    if(!flag)break;\n    int index_e=index;\n    while(index_e<s_tmp.size()){\n      if(s_tmp[index_e]=='0'||s_tmp[index_e]=='1')index_e++;\n      else break;\n    }\n    // cout << index<<\" \"<<index_e<<endl;\n    // cout << s_tmp.substr(0,index)<<endl;\n    s_tmp = s_tmp.substr(0,index)+\"f\"+s_tmp.substr(index_e,s_tmp.size()-index_e);\n    // cout << s_tmp << endl;\n  }\n  // cout << s_tmp<<endl;\n\n\n  while(1){\n  // cout <<s_tmp<<endl;\n\n    stack<int> left,right;\n    int index=0;\n    rep(i,s_tmp.size()){\n      if(s_tmp[i]=='(')left.push(i);\n      else if(s_tmp[i]==')')right.push(i);\n    }\n    if(left.size()!=right.size())return \"k\";\n    if(left.size()>0){\n      int il = left.top();\n      int ir = il;\n      while(ir<s_tmp.size()){\n        if(s_tmp[ir]==')')break;\n        ir++;\n      }\n      // cout << il << \" \" << ir << endl;\n      string tmp = tract(s_tmp.substr(il+1,ir-il-1));\n      // cout << \"rec \" << tmp << endl;\n      if (tmp==\"k\"||tmp==\"f\")return \"k\";\n      else if(tmp==\"e\"){\n        // cout << il << \" \" << ir << endl;\n        s_tmp = s_tmp.substr(0,il)+\"f\"+s_tmp.substr(ir+1,s_tmp.size()-ir-1);\n        continue;\n      } \n    } else {\n      // ()がない場合\n      int flag = 0;\n      // cout << \"no \"<<s_tmp<<endl;\n      rep(i,s_tmp.size()){\n        if(s_tmp[i]=='+'||s_tmp[i]=='-'||s_tmp[i]=='*'){\n          if(s_tmp[i+1]!='f'&&s_tmp[i+1]!='e'){\n            flag = 1; // ダメ\n            break;\n          } else if(s_tmp[i-1]!='f'&&s_tmp[i-1]!='e'){\n            flag = 1;\n            break;\n          }\n        } else { // s_tmp[i]=='f' or 'e'\n          if(i+1<s_tmp.size()&&(s_tmp[i+1]=='f'||s_tmp[i+1]=='e')){\n            flag = 1;\n          } else if(i-1>0&&(s_tmp[i-1]=='f'||s_tmp[i-1]=='e')){\n            flag = 1;\n          }\n        }\n      }\n      if (flag)return \"k\";\n      if(s_tmp==\"f\")return \"f\";\n      else return \"e\";\n    }\n  }\n}\n\n\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint  expression(State &begin);\nint factor(State &begin);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\nint term(State &begin){\n  int ret = factor(begin);\n  int flag = 0;\n  if(!inner(ret))return -INF;\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin);\n      if(!inner(tmp))return -INF;\n      ret *= tmp;\n      if(!inner(ret))return -INF;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// 式のパース\nint expression(State &begin){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin);\n  // cout << \"in expr \"<<ret << endl;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return -INF;\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin);\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      if(!inner(ret))ret=-INF;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin);\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      if(!inner(ret))ret=-INF;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  // if(!flag)return -INF;\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// ()のパース\nint factor(State &begin){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    begin++;\n    int ret = expression(begin);\n    // cout << \"from expr \"<<ret<<endl;\n    if(!inner(ret))return -INF;\n    begin++;\n    return ret;\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return -INF;\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    if(!inner(k))return -INF;\n    // cout << k << endl;\n    return k;\n  }\n}\n\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    // cout << \"~~~~\"<<endl;\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    // 括弧の対応をチェック\n    int sum = 0,flag=0;\n    rep(i,sc.size()){\n      if(sc[i]=='(')sum++;\n      if(sc[i]==')')sum--;\n      if(sum<0)flag=1;\n    }\n    if(sum!=0)flag=1;\n    string tm;\n    if(!flag){\n      tm = tract(sc);\n    } else {\n      tm = \"k\";\n    }\n    // cout <<\"now here \"<< tm << endl;\n    if(tm==\"k\")flag=1;\n    // tmp = calculate(sc);\n    State begin = sc.begin();\n    tmp = expression(begin);\n    // cout << tmp << endl;\n    // cout << sc << endl;\n    // tmp=-1;\n    if(tmp==331){\n      cout << sc << endl;\n    }\n    if(!flag&&tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <stdexcept>\n\n#define fprintf(...) void(0)\n\nstruct Tsurai: public std::out_of_range {\n  Tsurai(int d): std::out_of_range(std::string(\"L: \")+std::to_string(d)) {}\n};\n\nvoid apply(int &lhs, char op, int rhs) {\n  switch (op) {\n  case '+':\n    lhs += rhs;\n    break;\n  case '-':\n    lhs -= rhs;\n    break;\n  case '*':\n    lhs *= rhs;\n    break;\n  }\n  if (!(0 <= lhs && lhs < 1024))\n    throw Tsurai(__LINE__);\n}\n\nint parse_bin(const std::string &s, size_t &i) {\n  int res=0;\n  while (i < s.length() && isdigit(s[i])) {\n    res = res*2+s[i]-'0';\n    ++i;\n    if (res >= 1024) throw Tsurai(__LINE__);\n  }\n  assert(res < 1024);\n  return res;\n}\n\nstd::pair<int, int> parse(\n    const std::string &s, size_t &i, int &balance,\n    const std::vector<std::string> &ops={\"+-\", \"*\", \"\"}, size_t prec=0) {\n\n  // <calculates, num of terms/factors>\n  fprintf(stderr, \"C%zu\\n\", i);\n  fprintf(stderr, \"S: %s\\n\", s.c_str());\n  if (prec == ops.size()) {\n    if (s.at(i) == '(') {\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      ++i;\n      ++balance;\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (s.at(i) == ')') throw Tsurai(__LINE__);\n      size_t j=i;\n      (void)parse_bin(s, j);\n      if (s.at(j) == ')') throw Tsurai(__LINE__);\n\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      std::pair<int, int> res=parse(s, i, balance, ops, 0);\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (s.at(i) != ')')\n        throw Tsurai(__LINE__);\n      ++i;\n      --balance;\n      if (balance < 0)\n        throw Tsurai(__LINE__);\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (res.second <= 1)\n        throw Tsurai(__LINE__);\n      return {res.first, 1};\n    }\n    fprintf(stderr, \"%d\\n\", __LINE__);\n    if (isdigit(s.at(i))) {\n      fprintf(stderr, \"%d\\n\", __LINE__);\n      return {parse_bin(s, i), 1};\n    }\n    throw Tsurai(__LINE__);\n  }\n\n  std::pair<int, int> lhs(parse(s, i, balance, ops, prec+1).first, 1);\n  fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n\n  while (i < s.length()) {\n    char op=s.at(i);\n    if (op == ')') {\n      break;\n    }\n    if (!(op == '+' || op == '-' || op == '*'))\n      throw Tsurai(__LINE__);\n    if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n      break;\n\n    int rhs=parse(s, ++i, balance, ops, prec+1).first;\n    apply(lhs.first, op, rhs);\n    ++lhs.second;\n  }\n  return lhs;\n}\n\nint rec(std::string &s, std::vector<size_t> &dot) {\n  if (dot.empty()) {\n    try {\n      size_t i=0;\n      int b=0;\n      int res=parse(s, i, b).first;\n      if (i != s.length() || b < 0) return -1;\n      return res;\n    } catch (std::out_of_range x) {\n      fprintf(stderr, \"Tsurai on %s\\n\", x.what());\n      return -1;\n    }\n  }\n\n  size_t x=dot.back();\n  dot.pop_back();\n  int res=-1;\n  for (char ch: {'0', '1', '+', '-', '*', '(', ')'}) {\n    s[x] = ch;\n    res = std::max(res, rec(s, dot));\n  }\n  s[x] = '.';\n  dot.push_back(x);\n  return res;\n}\n\nint main() {\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  std::vector<size_t> dot;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '.')\n      dot.push_back(i);\n  }\n\n  printf(\"%d\\n\", rec(s, dot));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nll MOD=1000000007;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;Cursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(bool blacket){\n\t\t\tll l=term();int opc=0;\n\t\t\twhile(*c=='+' || *c=='-'){\n\t\t\t\topc++;\n\t\t\t\tif(*c=='+'){\n\t\t\t\t\tc++;l+=term();\n\t\t\t\t}else{\n\t\t\t\t\tc++;l-=term();\n\t\t\t\t}\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\tif(blacket && opc==0)throw ParseError();\n\t\t\treturn l;\n\t\t}\n\n\t\tll term(){\n\t\t\tll l=factor();\n\t\t\twhile(*c=='*'){\n\t\t\t\tc++;l*=factor();\n\t\t\t    if(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll factor(){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;\n\t\t\t\tll v=expression(true);\n\t\t\t\tif(*c!=')') throw ParseError();\n\t\t\t\tc++;\n\t\t\t\treturn v;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\treturn number();\n\t\t\t}else{\n\t\t\t\tthrow ParseError();\n\t\t\t}\n\t\t}\n\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t\t\tss << *c;c++;\n\t\t    }\n\t\t    string str;ss>>str;\n\t\t    ll res=0;\n\t\t    REP(i,str.size()){\n\t\t\t\tres*=2;\n\t\t\t\tif(str[i]=='1')res++;\n\t\t    }\n\t\t    if(!IN(0,res,1<<10)) throw ParseError();\n\t\t\treturn res;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nchar symb[7]={'0','1','+','-','*','(',')'};\n\nclass Main{\npublic:\n\tstring s;\t\t\n\tbool input(){\n\t\tgetline(cin,s);\n\t\ts.erase(remove(ALL(s), ' '), s.end());//空白除去\n\t\treturn true;\n\t}\n\n\tll dfs(int i){\n\t\tll Mv=-1;\n\t\tif(i==s.size()){\n\t\t\ttry{\n\t\t\t\tCursor c=s.begin();\n\t\t\t\tSyntax sy(s,c);\n\t\t\t\tll res=sy.expression(false);\n\t\t\t\tif(c!=s.end())throw ParseError();\n\t\t\t\treturn res;\n\t\t\t}catch(ParseError e){return -1;}\n\t\t}\n\t\tif(s[i]=='.'){\n\t\t\tREP(j,7){\n\t\t\t\ts[i]=symb[j];\n\t\t\t\tMv=max(Mv,dfs(i+1));\n\t\t\t\ts[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tMv=max(Mv,dfs(i+1));\n\t\t}\n\t\treturn Mv;\n\t}\n\n\tvoid run(){\n\t\tinput();\n\t\tcout << dfs(0)<<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <iostream>\n\nusing namespace std;\n\nint n, cl[5], cnum;\nchar str[101], cc[] = {\"01+-*\"};\n\nint eq(char c1,char c2,char c3,char c4){\n\treturn c1 == c3 && c2 == c4;\n}\n\nint calc(int p){\n\tint i, j, c1, c2;\n\tchar tmp;\n\tif(isdigit(str[p])){\n\t\tc1 = 0, c2 = 0;\n\t\tfor(i = p + 1;isdigit(str[i]) && i < n;i++);\n\t\tif(str[i] == '+' || str[i] == '-' || str[i] == '*'){\n\t\t\ttmp = str[i];\n\t\t\tif(isdigit(str[i + 1])){\n\t\t\t\tfor(j = i + 1;isdigit(str[j]) && j < n;j++);\n\t\t\t\tj--;\n\t\t\t\twhile(j > i)\n\t\t\t\t\tc2 = (c2 << 1) + str[j--] - '0';\n\t\t\t\ti--;\n\t\t\t\twhile(i >= p)\n\t\t\t\t\tc1 = (c1 << 1) + str[i--] - '0';\n\t\t\t\tif(tmp == '+')\n\t\t\t\t\treturn c1 + c2;\n\t\t\t\telse if(tmp == '-')\n\t\t\t\t\treturn c1 - c2;\n\t\t\t\telse if(tmp == '*')\n\t\t\t\t\treturn c1 * c2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc2 = calc(i + 2);\n\t\t\t\ti--;\n\t\t\t\twhile(i >= p)\n\t\t\t\t\tc1 = (c1 << 1) + str[i] - '0';\n\t\t\t\tif(tmp == '+')\n\t\t\t\t\treturn c1 + c2;\n\t\t\t\telse if(tmp == '-')\n\t\t\t\t\treturn c1 - c2;\n\t\t\t\telse if(tmp == '*')\n\t\t\t\t\treturn c1 * c2;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\ti--;\n\t\t\twhile(i >= p)\n\t\t\t\tc1 = (c1 << 1) + str[i--] - '0';\n\t\t\treturn c1;\n\t\t}\n\t}\n\telse if(str[p] == '('){\n\t\treturn calc(p + 1);\n\t}\n}\n\n\nint judge(void){\n\tint i, j, k = 0, c, a[50];\n\tchar c1, c2;\n\tfor(i = 0;i < n;i++){\n\t\tif((str[i] == '+' || str[i] == '-' || str[i] == '*') && k++ == 1) return 0;\n\t\tif(str[i] == '('){\n\t\t\tc = 0;\n\t\t\tfor(j = i + 1;str[j] != ')';j++)\n\t\t\t\tif((str[j] == '+' || str[j] == '-' || str[j] == '*') && c++ == 1) return 0;\n\t\t\ti = j;\n\t\t}\n\t}\n\tfor(i = 0;i < n - 1;i++){\n\t\tc1 = str[i],c2 = str[i + 1];\n\t\tif(eq(c1,c2,'(','+') || eq(c1,c2,'(','-') || eq(c1,c2,'(','*') || eq(c1,c2,'+',')') || eq(c1,c2,'-',')') || eq(c1,c2,'*',')') || eq(c1,c2,'0','(') || eq(c1,c2,'1','(') || eq(c1,c2,')','0') || eq(c1,c2,')','1'))\n\t\t\treturn 0;\n\t}\n\tif(str[0] == '+' || str[0] == '-' || str[0] == '*' || str[n - 1] == '+' || str[n - 1] == '-' || str[n - 1] == '*')\n\t\treturn 0;\n\tc = 0;\n\tmemset(a,0,sizeof(a));\n\tfor(i = 0;i < n;i++){\n\t\tif(a[c] == 0 && str[i] == ')') return 0;\n\t\tif(str[i] == '(') c++;\n\t\telse if(str[i] == ')'){\n\t\t\ta[c]--;\n\t\t\tc--;\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '-' || str[i] == '*') a[c]++;\n\t}\n\treturn 1;\n}\n\nint dfs(int c){\n\tint ret = 0x80000000,i;\n\tif(c == cnum){\n\t\tif(judge()){\n\t\t\tret = max(ret,calc(0));\n\t\t}\n\t\t\treturn ret;\n\t}\n\tfor(i = 0;i < 5;i++){\n\t\tstr[cl[c]] = cc[i];\n\t\tret = max(ret,dfs(c + 1));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint i = 0;\n\tchar c;\n\twhile((c = getchar()) != '\\n')\n\t\tstr[i++] = c;\n\tstr[i] = '\\0';\n\tn = strlen(str);\n\tcnum = 0;\n\tfor(i = 0;i < n;i++)\n\t\tif(str[i] == '.') cl[cnum++] = i;\n\tprintf(\"%d\\n\",dfs(0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nstring st;\nint a = 0;\nvoid check(const int num) {\n\tif (num < 0 || num >= 1024)throw(false);\n}\nint getnum() {\n\tint num = 0;\n\twhile (isdigit(st[a])) {\n\t\tnum = num * 2 + st[a] - '0';\n\t\ta++;\n\t}\n\tcheck(num);\n\treturn num;\n}\nint getexpr(const int isstart);\nint getkakko();\nint getka() {\n\tif (st[a] == '(') {\n\t\tint num=getkakko();\n\t\treturn num;\n\t}\n\telse if(isdigit(st[a])){\n\t\treturn getnum();\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\npair<int,int> getso() {\n\tint num = getka();\n\tbool fst = false;\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')'||st[a]=='+'||st[a]=='-') {\n\t\t\treturn make_pair(fst,num);\n\t\t}\n\t\telse if (st[a] == '*') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getka();\n\t\t\tnum *= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\npair<int, int> getexpr() {\n\tauto p(getso());\n\tbool fst = p.first;\n\tint num = p.second;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\treturn make_pair(fst,num);\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\nint getkakko() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n\tauto p(getso());\n\tint num = p.second;\n\n\tint fst = p.first;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\tthrow(false);\n\t\t}else if( st[a] == ')') {\n\t\t\tif (!fst) throw(false);\n\t\t\telse break;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t\tfst = false;\n\t}\n\tif (st[a] == ')') {\n\t\ta++;\n\t\treturn num;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\nint main() {\n\tstring base; cin >> base;\n\tst = base;\n\tstring aa = \"01+-*()\";\n\tvector<int>unknowns;\n\tfor (int i = 0; i < base.size(); ++i) {\n\t\tif (base[i] == '.') {\n\t\t\tunknowns.emplace_back(i);\n\t\t}\n\t}\n\tint ans = -1;\n\tfor (int i = 0; i < powint(7, unknowns.size()); ++i) {\n\t\tint num(i);\n\t\ta = 0;\n\t\tfor (int j = 0; j < unknowns.size(); ++j) {\n\t\t\tst[unknowns[j]] = aa[num % 7];\n\t\t\tnum /= 7;\n\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tint num = getexpr().second;\n\t\t\tans=max(ans,num);\n\t\t}\n\t\tcatch (...) {\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\ntypedef string::const_iterator State;\nint number(State&);\npair<int,bool> factor(State&);\npair<int,bool> term(State&);\npair<int,bool> expression(State&);\n\nbool invalid;\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\tif(not isdigit(*begin)){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 2;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\npair<int,bool> factor(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tpair<int,bool> ret = expression(begin);\n\t\tif(not ret.second) {\n\t\t\tinvalid = true;\n\t\t}\n\t\tbegin++; // ')'を飛ばす。\n\t\tret.second = 0;\n\t\treturn ret;\n\t} else {\n\t\treturn make_pair(number(begin), 0);\n\t}\n\treturn make_pair(0, 0);\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\npair<int,bool> term(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first *= factor(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\npair<int,bool> expression(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first += term(begin).first;\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first -= term(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n//beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\t//throw ParseError();\n\t}\n}\n\nconst string c = \"01+-*()\";\n\nbool check(string& s){\n\tint cnt = 0;\n\tbool op = false, st = false;\n\tshow(s)\n\trep(i,s.size()){\n\t\tcout << i << endl;\n\t\tif(s[i] == '('){\n\t\t\tif(st) return false;\n\t\t\tcnt++;\n\t\t\top = true;\n\t\t}else if(s[i] == ')'){\n\t\t\tif(op or st) return false;\n\t\t\tcnt--;\n\t\t\top = false;\n\t\t\tst = true;\n\t\t}else if(s[i] == '+' or s[i] == '-'){\n\t\t\top = false;\n\t\t\tst = false;\n\t\t}\n\t}\n\tshow(cnt)\n\treturn cnt == 0;\n}\n\nint dfs(string s, int i){\n\tif(i == s.size()){\n\t\t//if(not check(s)) return -1e5;\n\n\t\tinvalid = false;\n\t\tState tmp = s.begin();\n\n\t\tpair<int,bool> ans = expression(tmp);\n\t\tif(ans.first >= 1024) return -1e5;\n\t\tif(tmp != s.end()) return -1e5;\n\t\t//cout << ans << ' ' << s << endl;\n\t\treturn invalid ? -1e5 : ans.first;\n\t}\n\n\twhile(s[i] != '.' and i < s.size()){\n\t\ti++;\n\t}\n\n\tif(s[i] == '.'){\n\t\tint res = -1e5;\n\t\trep(j,c.size()){\n\t\t\ts[i] = c[j];\n\t\t\tres = max(res, dfs(s, i));\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn dfs(s, i);\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\n\tcout << dfs(s, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//内積、 dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積、cross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//線分と点の距離\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//線分の交差判定\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\n//線分の交点\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//線分と線分の距離\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//円と円の交点\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const{\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init):vertexs(init){\n        \n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const{\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if(bo == 3){\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first,goa.second,center,7 - goa.second,7-center,7 - goa.first}), \n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A,typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost){\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n){\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0&&level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s,int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nint num(State& now) {\n    int ans = 0;\n    while (*now == '0' || *now == '1') {\n        ans *= 2LL;\n        ans += *now - '0';\n        if (ans >= (1 << 10)) {\n            return -1;\n        }\n        now++;\n    }\n    return ans;\n}\n\nint calc(State& now) {\n    int ans = 0;\n    int next_req = 1;\n    if (*now == '0' || *now == '1') {\n        ans = num(now);\n        if (ans == -1) return -1;\n    }\n    else if (*now == '(') {\n        now++;\n        ans = calc(now);\n        if (ans == -1) return -1;\n        now++;\n    }\n    else return -1;\n    vector<pair<int, int>> nexter;\n    nexter.push_back(mp(ans, -1));\n    while (*now != ')') {\n        next_req = 0;\n        if (*now == '+') {\n            now++;\n            int hoge = 0;\n            if (*now == '(') {\n                now++;\n                hoge = calc(now);\n                if (hoge == -1) return -1;\n                now++;\n            }\n            else if (*now == '0' || *now == '1') {\n                hoge = num(now);\n                if (hoge == -1) return -1;\n            }\n            else return -1;\n            nexter.push_back(mp(hoge, 0));\n        }\n        else if (*now == '-') {\n            now++;\n            int hoge = 0;\n            if (*now == '(') {\n                now++;\n                hoge = calc(now);\n                if (hoge == -1) return -1;\n                now++;\n            }\n            else if (*now == '0' || *now == '1') {\n                hoge = num(now);\n                if (hoge == -1) return -1;\n            }\n            else return -1;\n            nexter.push_back(mp(hoge, 1));\n        }\n        else if (*now == '*') {\n            now++;\n            int hoge = 0;\n            if (*now == '(') {\n                now++;\n                hoge = calc(now);\n                if (hoge == -1) return -1;\n                now++;\n            }\n            else if (*now == '0' || *now == '1') {\n                hoge = num(now);\n                if (hoge == -1) return -1;\n            }\n            else return -1;\n            nexter.push_back(mp(hoge, 2));\n        }\n        else if (*now == '0') {\n            return -1;\n        }\n        else if (*now == '1') {\n            return -1;\n        }\n        else if (*now == '(') {\n            return -1;\n        }\n        else break;\n    }\n    if (next_req == 1) {\n        return -1;\n    }\n    for (int q = 1; q < nexter.size(); ++q) {\n        if (nexter[q].second == 2) {\n            nexter[q - 1].first *= nexter[q].first;\n            if (nexter[q - 1].first >= (1 << 10) || nexter[q - 1].first < 0) return -1;\n            nexter.erase(nexter.begin() + q);\n            q--;\n        }\n    }\n    for (int q = 1; q < nexter.size(); ++q) {\n        if (nexter[q].second == 0) {\n            nexter[q - 1].first += nexter[q].first;\n            if (nexter[q - 1].first >= (1 << 10) || nexter[q - 1].first < 0) return -1;\n            nexter.erase(nexter.begin() + q);\n            q--;\n        }\n        else {\n            nexter[q - 1].first -= nexter[q].first;\n            if (nexter[q - 1].first >= (1 << 10) || nexter[q - 1].first < 0) return -1;\n            nexter.erase(nexter.begin() + q);\n            q--;\n        }\n    }\n    return nexter[0].first;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    s = \"0+\" + s;\n    s.push_back(')');\n    int ans = -1;\n    REP(i, 7 * 7 * 7 * 7 * 7) {\n        string b;\n        int now = i;\n        string c = \"01+-*()\";\n        REP(q, s.length()) {\n            if (s[q] == '.') {\n                b.push_back(c[now % 7]);\n                now /= 7;\n            }\n            else {\n                b.push_back(s[q]);\n            }\n        }\n        int ng = 0;\n        for (int q = 0; q < b.length() - 1; ++q) {\n            if (b[q] == '(') {\n                ng++;\n            }\n            else if (b[q] == ')') {\n                ng--;\n            }\n            if (ng < 0) {\n                b.clear();\n                break;\n            }\n        }\n        if (ng != 0) b.clear();\n        if (b.size() == 0) continue;\n        State hoge = b.begin();\n\n        int nya = calc(hoge);\n        if (nya > ans) {\n            ans = max(ans, nya);\n        }\n    }\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring cs=\"01+-*()\";\nstring s;\nint n;\n\nint f(int l,int r){\n  if(r<=l)return -1;\n  bool isn=true;\n  repl(i,l,r)if(!isdigit(s[i]))isn=false;\n  if(isn){\n    int res=0;\n    repl(i,l,r){\n      res*=2;\n      res+=s[i]-'0';\n    }\n    if(res>=pow(2,10))return -1;\n    else return res;\n  }\n\n  bool ok=false;\n  {\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(lev==0)ok=true;\n      if(s[i]==')')lev--;\n    }\n  }\n\n  if(!ok){\n    if(s[r-1]!=')')return -1;\n    int lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&(s[i]=='+'||s[i]=='-')){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1)return -1;\n        int res=-1;\n        if(s[i]=='+')res=vl+vr;\n        else res=vl-vr;\n        if(res<0||res>=pow(2,10))return -1;\n        else return res;\n      }\n    }\n    lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1||vl*vr>=pow(2,10))return -1;\n        else return vl*vr;\n      }\n    }\n  }else{\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&(s[i]=='+'||s[i]=='-')){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1)return -1;\n        int res=-1;\n        if(s[i]=='+')res=vl+vr;\n        else res=vl-vr;\n        if(res<0||res>=pow(2,10))return -1;\n        else return res;\n      }\n    }\n    lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1||vl*vr>=pow(2,10))return -1;\n        else return vl*vr;\n      }\n    }\n  }\n  return -1;\n}\n\nint dfs(int i){\n  if(i==n){\n    return f(0,n);\n  }else{\n    if(s[i]=='.'){\n      int res=-1;\n      rep(j,7){\n        s[i]=cs[j];\n        int tmp=dfs(i+1);\n        maxch(res,tmp);\n      }\n      s[i]='.';\n      return res;\n    }else{\n      return dfs(i+1);\n    }\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nchar rp[]={'0','1','+','-','*','(',')'};\n \nvector<string> check(vector<string> ss){\n    vector<string> ans;\n    for(string x:ss){\n        bool sw=true;\n        int c=0;\n        for(int i=0;i<x.size()&&sw;i++){\n            if(x[i]=='(')c++;\n            if(x[i]==')')c--;\n            if(c<0)sw=false;\n        }\n        if(!c){\n            ans.push_back(x);\n        }\n    }\n    return ans;\n}\n \nvector<string> rek(vector<string> ss){\n    vector<string> ans;\n    int t;\n    if(ss[0].find(\".\")!=string::npos){\n        bool sw=true;\n        for(int i=0;i<ss[0].size()&&sw;i++){\n            if(ss[0][i]=='.'){\n                t=i;\n                sw=false;\n            }\n        }\n        for(string s:ss){\n            for(int i=0;i<7;i++){\n                s[t]=rp[i];\n                ans.push_back(s);\n            }\n        }\n        ans=rek(ans);\n        return ans;\n    }\n    else{\n        return ss;\n    }\n}\n \nint ana(string s){\n    int c=0;\n    if(s.size()==0)return -1;\n    bool sw=false;\n    int res;\n    if(s[0]=='('){\n        for(int i=0;i<s.size()-1;i++){\n            if(s[i]=='(')c++;\n            if(s[i]==')')c--;\n            if(!c)sw=true;\n        }\n        if(!sw){\n            s=s.substr(1,s.size()-2);\n            c=0;\n            for(int i=0;i<s.size();i++){\n                if(s[i]=='(')c++;\n                if(s[i]==')')c--;\n                if(!c&&s[i]=='*'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a*b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n            }\n            c=0;\n            for(int i=0;i<s.size();i++){\n                if(s[i]=='(')c++;\n                if(s[i]==')')c--;\n                if(!c&&s[i]=='+'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a+b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n                if(!c&&s[i]=='-'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a-b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n            }\n            return -1;\n        }\n    }\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n            if(!c&&s[i]=='*'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a*b;\n                return(res>=0&&res<1024?res:-1);\n            }\n    }\n    c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n        if(!c&&s[i]=='+'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a+b;\n            return(res>=0&&res<1024?res:-1);\n        }\n        if(!c&&s[i]=='-'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a-b;\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    if(s.find(\"(\")!=string::npos)return -1;\n    else{\n        try{\n            res=stoi(s,nullptr,2);\n        }catch(...){\n            return -1;\n        }\n        return(res>=0&&res<1024?res:-1);\n    }\n}\n \n \nvoid solve(string s){\n    int ans=-1,anssub=0;\n    vector<string> ss;\n    ss.push_back(s);\n    ss=rek(ss);\n    ss=check(ss);\n    for(string x:ss){\n        anssub=ana(x);\n        if(anssub<1024&&anssub>=0)ans=max(ans,anssub);\n    }\n    cout<<ans<<endl;\n}\n \nint main(){\n    string s;\n    cin>>s;\n    solve(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool err;\n\nvoid valid(int n)\n{\n\tif (n<0 || 1023<n)\n\t\terr = true;\n}\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\tvalid(res);\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else if (isdigit(s[p])) {\n\t\treturn number(s);\n\t} else {\n\t\terr = true;\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\tvalid(ret);\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\tfor(;;) {\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += term(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= term(s);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvalid(res);\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\tvalid(res);\n\treturn res;\n}\n\nbool isOpe(char c)\n{\n\treturn (c=='+'||c=='-'||c=='*');\n}\n\nbool check(string s)\n{\n\tvector<int> ope;\n\t\n\tif (s[N-1]=='+' || s[N-1]=='-' || s[N-1]=='*' || s[N-1]=='(')\n\t\treturn false;\n\t\n\trep(i, s.size()-1) {\n\t\tif (isOpe(s[i])&&isOpe(s[i+1]))\n\t\t\treturn false;\n\t}\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tif (i!=0 && !isOpe(s[i-1]) && s[i-1]!='(')\n\t\t\t\treturn false;\n\t\t\tope.push_back(0);\n\t\t} else if (s[i]==')') {\n\t\t\tif (d<0 || !ope[d]) return false;\n\t\t\tope.erase(ope.begin()+d);\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), 0);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>=1024) res=-1;\n\t\t\n\t\t\t//cerr << \"Persing : \" << s << endl;\n\t\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\t\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n/*\nBNFの\n<expression> ::= ( <expression> <operation> <expression> )\nの部分がやっかいで()のなかに必ず演算子が必要なので\n(1) => -1 (Not Number, 1は間違い) \nとしなければならないので注意.\n\n// 演算子が足りない\n((1+1)) => -1 \n// 構文解析が最後の文字まで読んでない.\n1() => -1\n// 途中の計算結果が負になる\n0-1+1+1 => -1\n(1+(0-1)) => -1\n// 問題なし\n((1+1)+1) => 3\n((1+1)+(1+1)+(1+1)) => 6\n */\n\nstring ch = \"01+-*()\";\nint ans = -1;\nbool flag = false;\n\n// 括弧の対応がとれているか\nbool check(const string& s){\n\tmap<int,int> m;\n\tstack<int> st;\n\tvector<int> v;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '(' ){\n\t\t\tv.push_back(i);\n\t\t\tst.push( i );\n\t\t}else if( s[i] == ')' ){\n\t\t\tif( st.empty() ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tm[st.top()] = i;\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn st.empty();\n}\n\n// 構文解析は Spaghetti Source 再帰下降型構文解析 ( LL(1) ) を参照.\n// http://www.prefield.com/algorithm/string/parser.html\ntypedef pair<int, int> result;\n#define value first\n#define p second\n\nresult eq(const string &s, int p, int& op);\nresult fact(const string &s, int p, int& op);\nresult term(const string &s, int p);\n\nresult eq(const string &s, int p, int& op){ \n\tresult r = fact(s, p, op);\n\t\n\t// 計算途中で負の値のとき\n\tif( r.value < 0 ) flag = true;\n\t\n\t// 演算子のチェック\n\twhile( s[r.p] == '+' || s[r.p] == '-' ){\n\t\top++;\n\t\tresult r_ = fact(s, r.p+1, op);\n\t\t// 計算途中で負の値のとき\n\t\tif( r_.value < 0 ) flag = true;\n\t\t\n\t\t// (r.value + r_.value) or (r.value - r_value) \n\t\tr.value += (s[r.p] == '+')? r_.value : -r_.value ;\n\t\t\n\t\t// 計算途中で負の値のとき\n\t\tif( r.value < 0 ) flag = true;\n\t\t\n\t\tr.p = r_.p;\n\t}\n\treturn r;\n}\n\nresult fact(const string &s, int p, int& op) {\n\tresult r = term(s, p);\n\t\n\t// 計算途中で負の値のとき\n\tif( r.value < 0 ) flag = true;\n\t\n\twhile( s[r.p] == '*' ){\n\t\top++;\n\t\tresult r_ = term(s, r.p+1);\n\t\t\n\t\t// 計算途中で負の値のとき\n\t\tif( r_.value < 0 ) flag = true;\n\t\t\n\t\tr.value *= r_.value;\n\t\tr.p      = r_.p;\n\t}\n\treturn r;\n}\nresult term(const string &s, int p) {\n\tif( s[p] == '(' ){\n\t\tint op=0;\n\t\tresult r = eq(s, p+1, op);\n\t\t// 計算途中で負の値のとき\n\t\tif( r.value < 0 ) flag = true;\n\t\t// (演算子が1個あるかチェック)\n\t\tif( op < 1 ){\n\t\t\tflag = true;\n\t\t}\n\t\t// ')' がないとき\n\t\tif( s[r.p] != ')' ){\n\t\t\tflag = true;\n\t\t}\n\t\tr.p += 1; // skip ')'\n\t\treturn r;\n\t}else{\n\t\tint value = 0;\n\t\t\n\t\t// 数字が来るところなのに数字がない\n\t\tif( !isdigit(s[p]) ){\n\t\t\tflag = true;\n\t\t}\n\t\t\n\t\t// 2進数なので注意!\n\t\twhile( isdigit(s[p]) )\n\t\t\tvalue = value * 2 + (s[p++] - '0');\n\t\treturn result(value, p);\n\t}\n}\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tflag = false;\n\t\tif( check(s) ){ // 括弧の対応がとれているかどうか\n\t\t\tint op=0;\n\t\t\tresult r = eq(s,0,op);\n\t\t\tint res = r.value; // 式の値\n\t\t\tint pos = r.p; // 読み終えた時の位置\n\t\t\t\n\t\t\tif( flag || pos != s.size() ){ // 式が正しくないとき\n\t\t\t\t// cout << \"NA\" << endl;\n\t\t\t}else{ // 式が正しいときだけ解を更新\n\t\t\t\t// cout << res << endl;\n\t\t\t\tans = max( ans , res );\n\t\t\t}\n\t\t}else{\n\t\t\t// cout << \"NA\" << endl;\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nchar rp[]={'0','1','+','-','*','(',')'};\n \nvector<string> check(vector<string> ss){\n    vector<string> ans;\n    for(string x:ss){\n        bool sw=true;\n        int c=0;\n        for(int i=0;i<x.size()&&sw;i++){\n            if(x[i]=='(')c++;\n            if(x[i]==')')c--;\n            if(c<0)sw=false;\n        }\n        if(!c){\n            ans.push_back(x);\n        }\n    }\n    return ans;\n}\n \nvector<string> rek(vector<string> ss){\n    vector<string> ans;\n    int t;\n    if(ss[0].find(\".\")!=string::npos){\n        bool sw=true;\n        for(int i=0;i<ss[0].size()&&sw;i++){\n            if(ss[0][i]=='.'){\n                t=i;\n                sw=false;\n            }\n        }\n        for(string s:ss){\n            for(int i=0;i<7;i++){\n                s[t]=rp[i];\n                ans.push_back(s);\n            }\n        }\n        ans=rek(ans);\n        return ans;\n    }\n    else{\n        return ss;\n    }\n}\n \nint ana(string s){\n    int c=0;\n    if(s.size()==0)return -1;\n    bool sw=false;\n    int res;\n    if(s[0]=='('){\n        for(int i=0;i<s.size()-1;i++){\n            if(s[i]=='(')c++;\n            if(s[i]==')')c--;\n            if(!c)sw=true;\n        }\n        if(!sw){\n            s=s.substr(1,s.size()-2);\n            c=0;\n            for(int i=0;i<s.size();i++){\n                if(s[i]=='(')c++;\n                if(s[i]==')')c--;\n                if(!c&&s[i]=='+'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a+b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n            }\n            c=0;\n            for(int i=0;i<s.size();i++){\n                if(s[i]=='(')c++;\n                if(s[i]==')')c--;\n                if(!c&&s[i]=='-'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a-b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n            }\n            c=0;\n            for(int i=0;i<s.size();i++){\n                if(s[i]=='(')c++;\n                if(s[i]==')')c--;\n                if(!c&&s[i]=='*'){\n                    int a=ana(s.substr(0,i));\n                    int b=ana(s.substr(i+1,s.size()-i-1));\n                    if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                    res=a*b;\n                    return(res>=0&&res<1024?res:-1);\n                }\n            }\n            return -1;\n        }\n    }\n    c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n        if(!c&&s[i]=='+'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a+b;\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n        if(!c&&s[i]=='-'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a-b;\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n            if(!c&&s[i]=='*'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a*b;\n                return(res>=0&&res<1024?res:-1);\n            }\n    }\n    if(s.find(\"(\")!=string::npos)return -1;\n    else{\n        try{\n            res=stoi(s,nullptr,2);\n        }catch(...){\n            return -1;\n        }\n        return(res>=0&&res<1024?res:-1);\n    }\n}\n \n \nvoid solve(string s){\n    int ans=-1,anssub=0;\n    vector<string> ss;\n    ss.push_back(s);\n    ss=rek(ss);\n    ss=check(ss);\n    for(string x:ss){\n        anssub=ana(x);\n        if(anssub<1024&&anssub>=0)ans=max(ans,anssub);\n    }\n    cout<<ans<<endl;\n}\n \nint main(){\n    string s;\n    cin>>s;\n    solve(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 10;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    *result *= rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef string::const_iterator State;\nint res=-5000;\nstring str;\nbool over;\n\nint expression(State &begin);\n\nint ope[101];\n\nbool ex_good(){\n\tint cc=0;\n\tmemset(ope,0,sizeof(ope));\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]==')'){\n\t\t\tif(cc==0)return false;\n\t\t\tif(!isdigit(str[i-1]))return false;\n\t\t\tif(ope[cc]==0)return false;\n\t\t\tope[cc]=0;\n\t\t\tcc--;\n\t\t}\n\t\tif(str[i]=='('){\n\t\t\tcc++;\n\t\t\tif(i==0)continue;\n\t\t\tif(isdigit(str[i-1]) || str[i-1]==')')return false;\n\t\t}\n\t\tif(isdigit(str[i])){\n\t\t\tif(i==0)continue;\n\t\t\tif(str[i-1]==')')return false;\n\t\t}\n\t\tif(str[i]=='+' || str[i]=='-' || str[i]=='*'){\n\t\t\tif(i==0 || i==str.size()-1)return false;\n\t\t\tif(!(isdigit(str[i-1]) || str[i-1]==')'))return false;\n\t\t\tif(!(isdigit(str[i+1]) || str[i+1]=='('))return false;\n\t\t\tope[cc]++;\n\t\t}\n\t}\n\tif(cc>0)return false;\n\treturn true;\n}\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t\tif(ret>=1024)over=true;\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t\tif(ret>=1024)over=true;\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret=term(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t\tif(ret>=1024)over=true;\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t\tif(ret<0)over=true;\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nvoid dfs(int v){\n\tif(v==str.size()){\n\t\tState s=str.begin();\n\t\tif(!ex_good())return;\n\t\tover=false;\n\t\tint val=expression(s);\n\t\tif(!over && v<1024)res=max(res,val);\n\t}else{\n\t\tif(str[v]!='.'){\n\t\t\tdfs(v+1);\n\t\t}else{\n\t\t\tstr[v]='0';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='1';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='+';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='-';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='*';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='(';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]=')';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='.';\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> str;\n\tdfs(0);\n\tprintf(\"%d\\n\",res==-5000?-1:res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint formula(int &p,bool inper);\npair<int,bool> term1(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint calc(int lhs,int rhs,char op){\n  int res=-1;\n  if(lhs==-1 || rhs==-1) return -1;\n  if(op=='+') res=lhs+rhs;\n  if(op=='-') res= lhs-rhs;\n  if(op=='*') res= lhs*rhs;\n  return (0<=res && res<1024) ? res : -1;\n}\n\nstring s;\nint formula(int &p,bool inper=false){\n  bool isok=!inper;\n  pair<int,bool> ret=term1(p);\n  int res=ret.first;\n  isok|=ret.second;\n  while(p<s.size() && s[p]!=')'){\n    inper=false;\n    char op=s[p];\n    if(op!='+' && op!='-'){\n      return -1;\n    }\n    isok=true;\n    p++;\n    int rhs=term1(p).first;\n    res=calc(res,rhs,op);\n  }\n  return isok ? res : -1;\n}\n\npair<int,bool> term1(int &p){\n  int res=term2(p);\n  bool res2=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;\n    if(op!='*'){\n      return {-1,0};\n    }\n    res2=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,res2};\n}\n\nint term2(int &p){\n  int res=-1;\n  if(s[p]=='('){\n    p++;\n    res=formula(p,true);\n    if(s[p]!=')') return -1;\n\n  }\n  else if(isdigit(s[p])){\n    res=get_num(p);\n  }\n  else{\n    return -1;\n  }\n  return res;\n}\n\nint get_num(int &p){\n  int res=-1;\n  while(isdigit(s[p])){\n    if(res==-1) res=0;\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  //cout<<res<<endl;\n  if(res>=1024) return -1;\n  return res;\n}\n\nstring ch=\"01+-*()\";\n\nint dfs(int i){\n  if(i==s.size()){\n    int p=0;\n    //cout<<s<<endl;\n    int res=formula(p);\n    //cout<<res<<endl;\n    return res;\n  }\n  if(s[i]=='.'){\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      res=max(res,dfs(i+1));\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint is_digit(char c) {\n  return c == '0' || c == '1';\n}\n\nint is_valid(int n) {\n  return 0 <= n && n < 1024;\n}\n\nint number(string &line, size_t &i) {\n  int n = 0;\n  while (is_digit(line[i])) {\n    n = 2 * n + (line[i] - '0');\n    ++i;\n  }\n  return n;\n}\n\nint expr(string &, size_t &);\n\nint fact(string &line, size_t &i) {\n  int n;\n  if (line[i] == '(') {\n    ++i;\n    n = expr(line, i);\n    ++i;\n  } else if (is_digit(line[i])) {\n    n = number(line, i);\n  } else {\n    i = line.size() + 1;\n    return -1;\n  }\n  return n;\n}\n\nint term(string &line, size_t &i) {\n  int n = fact(line, i);\n  int out_num = line.size() + 1;\n  while (i < line.size()) {\n    if (line[i] == '*') {\n      ++i;\n      n *= fact(line, i);\n      if (!is_valid(n)) {\n        i = out_num;\n      }\n    } else {\n      return n;\n    }\n  }\n  return n;\n}\n\nint expr(string &line, size_t &i) {\n  int m;\n  int n = term(line, i);\n  int out_num = line.size() + 1;\n  while (i < line.size()) {\n    if (line[i] == '+' || line[i] == '-') {\n      char op = line[i];\n      ++i;\n      m = term(line, i);\n      if (op == '+') {\n        n += m;\n      } else {\n        n -= m;\n      }\n      if (!is_valid(n)) {\n        i = out_num;\n      }\n    } else if (line[i] == ')') {\n      return n;\n    } else {\n      i = out_num;\n    }\n  }\n  return n;\n}\n\nbool is_balanced(const string &line) {\n  int depth = 0;\n  int count[100];\n  for (int i = 0; i < 100; ++i) {\n    count[i] = 0;\n  }\n  for (size_t i = 0; i < line.size(); ++i) {\n    if (line[i] == '(') {\n      ++depth;\n    } else if (line[i] == ')') {\n      if (depth == 0 || count[depth] == 0) {\n        return false;\n      }\n      count[depth] = 0;\n      --depth;\n    } else if (line[i] == '+' || line[i] == '-' || line[i] == '*') {\n      ++count[depth];\n    }\n  }\n  return depth == 0;\n}\n\nint eval(string &line) {\n  if (is_balanced(line)) {\n    size_t i = 0;\n    int n = expr(line, i);\n    if (i == line.size()) {\n      return n;\n    }\n  }\n  return -1;\n}\n\nint solve(string &line, size_t i = 0) {\n  const char *chars = \"01+-*()\";\n  while (i < line.size()) {\n    if (line[i] == '.') {\n      int retval = -1;\n      for (size_t j = 0; chars[j]; ++j) {\n        line[i] = chars[j];\n        retval = max(retval, solve(line, i + 1));\n      }\n      line[i] = '.';\n      return retval;\n    }\n    ++i;\n  }\n  return eval(line);\n}\n\nint main() {\n  string line;\n  cin >> line;\n  cout << solve(line) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n        }else{\n            res -= term(++pos);\n            if(res<0){\n                ppppp = 1;\n            }\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    bool ok = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n        }\n    }\n    if(flag){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n        pos = 0;\n        cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool onlynum;\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tonlynum = false;\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tonlynum = false;\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tonlynum = true;\n\tint ret = expr(s, num);\n\tif (onlynum)return -1;\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num]))n = n * 2 + s[num++] - '0';\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tonlynum=false;\n\t\tint ans = expr(s, num);\n\t\tif (s.length()==num)\n\t\tma = max(ma,ans );\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nclass Calc {\n  private:\n    int N, idx;\n    string s;\n    \n  public:\n    Calc (const string& s) : s{s} {\n        idx = 0;\n        N = s.size();\n    }\n\n    static bool is_op(char c)\n    {\n        return (c == '+' || c == '-' || c == '*');   \n    }\n\n    bool check_range(int x)\n    {\n        return (0 <= x && x < 1024);\n    }\n    \n    int num()\n    {\n        int res = 0, p = 0;\n        while (isdigit(s[idx])) {\n            if (p > 10 && s[idx] == '1') return -1;\n            res *= 2;\n            res += (s[idx] - '0');\n            p++;\n            ++idx;\n        }        \n        return (check_range(res) ? res : -1);\n    }\n\n    bool check_op(int cur)\n    {\n        int p = 0;\n        for (int i = cur + 1; i < N; i++) {\n            if (s[i] == '(') p++;\n            if (s[i] == ')') p--;\n            if (p == 0 && is_op(s[i])) return 1;\n            if (p < 0) break;\n        }\n        return 0;\n    }\n    \n    int fact()\n    {\n        int ret = -1;\n        if (s[idx] == '(') {\n            if (!check_op(idx)) throw 0;\n            ++idx;\n            ret = expr();\n            ++idx;\n        } else {\n            ret = num();\n        }\n        if (!check_range(ret)) throw 0;         \n        return ret;\n    }\n\n    int term()\n    {\n        int ret = fact();\n        while (s[idx] == '*') {\n            ++idx;\n            ret *= fact();\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n\n    int expr()\n    {\n        int ret = term();\n\n        while (s[idx] == '+' || s[idx] == '-') {\n            if (s[idx] == '+') {\n                ++idx;\n                ret += term();\n            } else {\n                ++idx;\n                ret -= term();\n            }\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n};\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid(const string& s)\n{\n    int p = 0, N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (Calc::is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || Calc::is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || Calc::is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n\n        if (s[i] == '(') {\n            if (i == N - 1) return 0;\n            if (i > 0 && (isdigit(s[i - 1]) || s[i - 1] == ')')) {\n                return 0;\n            }\n        }\n        \n        if (s[i] == ')') {\n            if (i == 0) return 0;\n            if (i < N - 1 && (isdigit(s[i + 1]) || s[i + 1] == '(')) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n\n        for (int j = i + 1; j < N; j++) {\n            if (s[i] == '(' && s[j] == ')' && j - i < 4) {\n                return 0;\n            }\n        }\n    }\n    return (p == 0);\n}\n\nint solve(string& s)\n{\n    int N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        if (!valid(s)) return -1;\n        Calc calc(s);\n        int res = -1;\n        \n        try {\n            res = calc.expr();\n        } catch (...) {}\n        \n        return res;\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid(s)) {\n            Calc calc(s);\n            try {\n                res = max(res, calc.expr());\n            } catch (...) {}\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    cout << solve(s) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')')return false;\n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    assert(s[i] != '.');\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '(' || s[i] == ')'){\n      if(s[i] == ')' && s[i+1] == '(')return false;\n      if(s[i] == '(' && s[i+1] == ')')return false;\n      if(s[i] == ')'){\n\t//if(i+1 < s.length() && !(s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*'))return false;\n      }\n      \n    }\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(!(0<= p && p < 1024))return FAILED;\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' == parse[pos] || parse[pos] == '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nstring tract(string s){\n  rep(i,s.size()){\n    if(s[i]=='k')return \"k\";\n  }\n  // まず数字を全てfに変える\n  string s_tmp(s);\n  while(1){\n    // 数字あるかチェック\n    int index = 0,flag=0;\n    while(index<s_tmp.size()){\n      if(s_tmp[index]=='0'||s_tmp[index]=='1'){flag=1;break;}\n      index++;\n    }\n    if(!flag)break;\n    int index_e=index;\n    while(index_e<s_tmp.size()){\n      if(s_tmp[index_e]=='0'||s_tmp[index_e]=='1')index_e++;\n      else break;\n    }\n    s_tmp = s_tmp.substr(0,index)+\"f\"+s_tmp.substr(index_e,s_tmp.size()-index_e);\n  }\n  while(1){\n\n    stack<int> left,right;\n    int index=0;\n    rep(i,s_tmp.size()){\n      if(s_tmp[i]=='(')left.push(i);\n      else if(s_tmp[i]==')')right.push(i);\n    }\n    if(left.size()!=right.size())return \"k\";\n    if(left.size()>0){\n      int il = left.top();\n      int ir = il;\n      while(ir<s_tmp.size()){\n        if(s_tmp[ir]==')')break;\n        ir++;\n      }\n      string tmp = tract(s_tmp.substr(il+1,ir-il-1));\n      if (tmp==\"k\"||tmp==\"f\")return \"k\";\n      else if(tmp==\"e\"){\n        s_tmp = s_tmp.substr(0,il)+\"f\"+s_tmp.substr(ir+1,s_tmp.size()-ir-1);\n        continue;\n      } \n    } else {\n      // ()がない場合\n      int flag = 0;\n      rep(i,s_tmp.size()){\n        if(s_tmp[i]=='+'||s_tmp[i]=='-'||s_tmp[i]=='*'){\n          if(s_tmp[i+1]!='f'&&s_tmp[i+1]!='e'){\n            flag = 1; // ダメ\n            break;\n          } else if(s_tmp[i-1]!='f'&&s_tmp[i-1]!='e'){\n            flag = 1;\n            break;\n          }\n        } else { // s_tmp[i]=='f' or 'e'\n          if(s_tmp[i+1]=='f'||s_tmp[i+1]=='e'){\n            flag = 1;\n          } else if(s_tmp[i-1]=='f'||s_tmp[i-1]=='e'){\n            flag = 1;\n          }\n        }\n      }\n      if (flag)return \"k\";\n      else return \"e\";\n    }\n  }\n}\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint  expression(State &begin);\nint factor(State &begin);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\nint term(State &begin){\n  int ret = factor(begin);\n  int flag = 0;\n  if(!inner(ret))return -INF;\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin);\n      if(!inner(tmp))return -INF;\n      ret *= tmp;\n      flag = 1;\n    } else {\n      break;\n    }\n  }\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// 式のパース\nint expression(State &begin){\n  int ret = term(begin);\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return -INF;\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin);\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin);\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    } else {\n      break;\n    }\n  }\n  if(!flag)return -INF;\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// ()のパース\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return -INF;\n  } else {\n    int k = number(begin);\n    return k;\n  }\n}\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    // 括弧の対応をチェック\n    int sum = 0,flag=0;\n    rep(i,sc.size()){\n      if(sc[i]=='(')sum++;\n      if(sc[i]==')')sum--;\n      if(sum<0)flag=1;\n    }\n    if(sum!=0)flag=1;\n    string tm;\n    if(!flag){\n      tm = tract(sc);\n    } else {\n      tm = \"k\";\n    }\n    if(tm==\"k\")flag=1;\n    State begin = sc.begin();\n    tmp = expression(begin);\n    if(!flag&&tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  while(*it=='0') ++it;\n\n  *result = 0;\n  int max_length = 10;\n  int length = 0;\n  while(true){\n    if(it+length==end || (*(it+length)!='0' && *(it+length)!='1')) break;\n    *result += (*(it+length) - '0') << (max_length-length);\n    ++length;\n  }\n  *result >>= max_length-length + 1;\n  if(*result >= 1024) return false;\n  \n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  \n  unsigned long long lv = *result;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    lv *= rv;\n    if(lv >= 1024) return false;\n  }\n  *result = lv;\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  \n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define LOG(...) fprintf(stderr,__VA_ARGS__)\n#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef string::const_iterator State;\nState SEnd;\nclass ParseError {};\n\nvoid consume(State &begin, char expected);\nint factor(State &begin);\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\n\nstack<bool> hasOperator;\n\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        LOG(\"ASDFASDFASDFADFASD\");\n        throw ParseError();\n    }\n}\n\n// ()?????????operation???????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        if (begin == SEnd) {\n            LOG(\"WTF\");\n            throw ParseError();\n        }\n        hasOperator.push(false);\n        int ret = expression(begin);\n        consume(begin, ')');\n        if (hasOperator.empty()) throw ParseError();\n        if (!hasOperator.top()) {\n            LOG(\"no op\\n\");\n            throw ParseError();\n        }\n        hasOperator.pop();\n        return ret;\n    } else if (*begin == ')') {\n        throw ParseError();\n    } else {\n        return number(begin);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            if (hasOperator.empty()) throw ParseError();\n            hasOperator.pop();\n            hasOperator.push(true);\n            begin++;\n            if (begin == SEnd) {\n                LOG(\"no +\\n\");\n                throw ParseError();\n            }\n            ret += term(begin);\n        } else if (*begin == '-') {\n            if (hasOperator.empty()) throw ParseError();\n            hasOperator.pop();\n            hasOperator.push(true);\n            begin++;\n            if (begin == SEnd) {\n                LOG(\"no -\\n\");\n                throw ParseError();\n            }\n            ret -= term(begin);\n        } else {\n            if (*begin == ')' || begin == SEnd) {\n                LOG(\"ddj\");\n                break;\n            }\n            throw ParseError();\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    int ret = factor(begin);\n    LOG(\"YOYO: %d\\n\", ret);\n\n    for (;;) {\n        if (*begin == '*') {\n            if (hasOperator.empty()) throw ParseError();\n            hasOperator.pop();\n            hasOperator.push(true);\n            begin++;\n            if (begin == SEnd) {\n                LOG(\"no *\\n\");\n                throw ParseError();\n            }\n            int a = factor(begin);\n            ret *= a;\n        } else {\n            if (hasOperator.empty() && *begin == ')') {\n                throw ParseError();\n            }\n            if (*begin == ')' || *begin == '+' || *begin == '-' || begin == SEnd) {\n                break;\n            }\n            throw ParseError();\n        }\n    }\n\n    return ret;\n}\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    if (!isdigit(*begin)) {\n        LOG(\"no dig\\n\");\n        throw ParseError();\n    }\n    int ret = 0;\n    while (isdigit(*begin)) {\n        ret <<= 1;\n        if (*begin == '1') {\n            ret |= 1;\n        }\n        begin++;\n    }\n\n    return ret;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int ma = -1;\n    const char cs[] = {'0', '1', '+', '-', '*', '(', ')'};\n    vi dots;\n    REP(i, SZ(s)) if (s[i] == '.') dots.push_back(i);\n    int n = SZ(dots);\n    if (n == 0) {\n        while (!hasOperator.empty()) hasOperator.pop();\n        State begin = s.begin();\n        SEnd = s.end();\n        try { ma = max(ma, expression(begin)); }\n        catch (ParseError e) { ma = max(ma, -1); }\n    } else if (n == 1) {\n        REP(i, 7) {\n            s[dots[0]] = cs[i];\n            while (!hasOperator.empty()) hasOperator.pop();\n            State begin = s.begin();\n            SEnd = s.end();\n            LOG(\"%s\\n\", s.c_str());\n            try { ma = max(ma, expression(begin));\n                LOG(\"%s = %d\\n\", s.c_str(), expression(begin));\n            }\n\n            catch (ParseError e) { ma = max(ma, -1); }\n            s[dots[0]] = '.';\n        }\n    } else if (n == 2) {\n        REP(i, 7)\n        REP(j, 7) {\n            s[dots[0]] = cs[i];\n            s[dots[1]] = cs[j];\n            while (!hasOperator.empty()) hasOperator.pop();\n            State begin = s.begin();\n            SEnd = s.end();\n            try { ma = max(ma, expression(begin)); }\n            catch (ParseError e) { ma = max(ma, -1); }\n            s[dots[0]] = '.';\n            s[dots[1]] = '.';\n        }\n    } else if (n == 3) {\n        REP(i, 7)\n        REP(j, 7)\n        REP(k, 7) {\n            s[dots[0]] = cs[i];\n            s[dots[1]] = cs[j];\n            s[dots[2]] = cs[k];\n            while (!hasOperator.empty()) hasOperator.pop();\n            State begin = s.begin();\n            SEnd = s.end();\n            try { ma = max(ma, expression(begin)); }\n            catch (ParseError e) { ma = max(ma, -1); }\n            s[dots[0]] = '.';\n            s[dots[1]] = '.';\n            s[dots[2]] = '.';\n        }\n    } else if (n == 4) {\n        REP(i, 7)\n        REP(j, 7)\n        REP(k, 7)\n        REP(l, 7) {\n            s[dots[0]] = cs[i];\n            s[dots[1]] = cs[j];\n            s[dots[2]] = cs[k];\n            s[dots[3]] = cs[l];\n            while (!hasOperator.empty()) hasOperator.pop();\n            State begin = s.begin();\n            SEnd = s.end();\n            try { ma = max(ma, expression(begin)); }\n            catch (ParseError e) { ma = max(ma, -1); }\n            s[dots[0]] = '.';\n            s[dots[1]] = '.';\n            s[dots[2]] = '.';\n            s[dots[3]] = '.';\n        }\n    } else if (n == 5) {\n        REP(i, 7)\n        REP(j, 7)\n        REP(k, 7)\n        REP(l, 7)\n        REP(m, 7) {\n            s[dots[0]] = cs[i];\n            s[dots[1]] = cs[j];\n            s[dots[2]] = cs[k];\n            s[dots[3]] = cs[l];\n            s[dots[4]] = cs[m];\n            while (!hasOperator.empty()) hasOperator.pop();\n            State begin = s.begin();\n            SEnd = s.end();\n            try { ma = max(ma, expression(begin)); }\n            catch (ParseError e) { ma = max(ma, -1); }\n            s[dots[0]] = '.';\n            s[dots[1]] = '.';\n            s[dots[2]] = '.';\n            s[dots[3]] = '.';\n            s[dots[4]] = '.';\n        }\n    }\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstring s;\nint n;\nchar c[7] = {'0','1','+','-','*','(',')'};\nconst int up = 1<<10;\n\nint parse(int l,int r,int p){\n  if(r<=l)return -1;\n  int k=0,a,b,e=0;\n  for(int i=r-1;i>=l;i--){\n    if(s[i]=='('){k++;e=1;}\n    else if(s[i] == ')'){k--;e=1;}\n    if(k>0)return -1;\n    if(!k){\n      if(s[i] == '+'){\n\ta = parse(l,i,0); b = parse(i+1,r,0);\n\tif(a<0 || b<0 || up<=a || up<=b || a+b<0 || up<=a+b)return -1;\n\treturn a+b;\n      }else if(s[i] == '-'){\n\ta = parse(l,i,0); b = parse(i+1,r,0);\n\tif(a<0 || b<0 || up<=a || up<=b || a-b<0 || up<=a-b)return -1;\n\treturn a-b;\n      }\n    }\n  }\n  if(k)return -1;\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i]=='(')k++;\n    else if(s[i] == ')')k--;\n    if(!k && s[i] == '*'){\n      a = parse(l,i,0); b = parse(i+1,r,0);\n      if(a<0 || b<0 || up<=a || up<=b || a*b<0 || up<=a*b)return -1;\n      return a*b;\n    }\n  }\n\n  if(p)return -1;\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1,1);\n  if(e)return -1;\n  int res = 0;\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '1'){\n      if(r-1-i>=10)return -1;\n      else res += 1 << (r-1-i);\n    }\n  }\n  return res;\n}\n\nint rec(int pos){\n  int i,res = -1;\n  for(i=pos;i<n;i++){\n    if(s[i] == '.'){\n      for(int j=0;j<7;j++){\n\ts[i] = c[j];\n\tres = max(res,rec(i+1));\n      }\n      s[i] = '.'; break;\n    }\n  }\n  \n  if(i==n)return parse(0,n,0);\n  else return res;\n}\n\nint main(){\n  cin >> s; n = s.size();\n  cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f1(int&, bool&);\n\nint f2(int&, bool&);\n\nint f3(int&, bool&);\n\nvector< int > undefined;\nstring S;\n\nbool isout(int val)\n{\n  return(val < 0 || val >= 1024);\n}\nint f1(int& idx, bool& f)\n{\n  int val = f2(idx, f);\n\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') {\n      ++idx;\n      val += f2(idx, f);\n    } else {\n      ++idx;\n      val -= f2(idx, f);\n    }\n    if(isout(val)) throw(1);\n    f = true;\n  }\n  return (val);\n}\n\nint f2(int& idx, bool& f)\n{\n  int val = f3(idx, f);\n\n  while(S[idx] == '*') {\n    idx++;\n    val *= f3(idx, f);\n    if(isout(val)) throw(1);\n    f = true;\n  }\n  return (val);\n}\n\nint f3(int& idx, bool& f)\n{\n  int val = 0;\n  if(S[idx] == '(') {\n    ++idx;\n    int now = idx;\n    bool flag = false;\n    val = f1(idx, flag);\n    if(!flag) throw(1);\n    ++idx;\n    return (val);\n  } else if(isdigit(S[idx])) {\n    while(isdigit(S[idx])) {\n      val = val * 2 + S[idx] - '0';\n      ++idx;\n      if(isout(val)) throw(1);\n    }\n  } else {\n    throw (1);\n  }\n  return (val);\n}\n\nint make(int idx)\n{\n  int ret = -1;\n  if(idx == undefined.size()) {\n    try {\n      int pos = 0;\n      bool f = false;\n      int val = f1(pos, f);\n      if(pos + 1 != S.size()) throw (1);\n\n      cout << S << \" \" << val << endl;\n\n      ret = max(ret, val);\n    } catch(int e) {}\n  } else {\n    string s = \"01+-*()\";\n    for(char c : s) {\n      S[undefined[idx]] = c;\n      ret = max(ret, make(idx + 1));\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> S;\n  S += \"~\";\n  for(int i = 0; i < S.size(); i++) {\n    if(S[i] == '.') undefined.push_back(i);\n  }\n  cout << make(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\nconst int LIM = 1<<10;\n\nint number(Iterator &it, const Iterator &end) {\n    int res = 0;\n    while(it != end && isdigit(*it)) {\n        res *= 2;\n        res += *it - '0';\n        if(res >= LIM) throw \"overflow\";\n        ++it;\n    }\n    return res;\n}\n\npair<int,bool> expr(Iterator &it, const Iterator &end);\nint fact(Iterator &it, const Iterator &end) {\n    if(*it == '(') {\n        ++it;\n        const auto res = expr(it, end);\n        if(!res.second) {\n            throw \"no operator in paren\";\n        }\n        if(*it != ')') {\n            throw \"unmatched paren\";\n        }\n        ++it;\n        return res.first;\n    } else if(isdigit(*it)) {\n        return number(it, end);\n    } else {\n        throw \"paren or digit required\";\n    }\n}\n\npair<int,bool> term(Iterator &it, const Iterator &end) {\n    int lhs = fact(it, end);\n    bool op_seen = false;\n    while(it != end) {\n        char op = *it;\n        if(op != '*') break;\n        ++it;\n        const int rhs = fact(it, end);\n        lhs *= rhs;\n        op_seen = true;\n        if(lhs < 0 || lhs >= LIM) throw \"overflow\";\n    }\n    return make_pair(lhs, op_seen);\n}\n\npair<int,bool> expr(Iterator &it, const Iterator &end) {\n    auto lhs_ = term(it, end);\n    int lhs = lhs_.first;\n    bool op_seen = lhs_.second;\n    while(it != end) {\n        char op = *it;\n        if(op != '+' && op != '-') {\n            break;\n        }\n        ++it;\n        const auto rhs = term(it, end);\n        op_seen = op_seen || rhs.second;\n        switch(op) {\n            case '+':\n                lhs += rhs.first;\n                break;\n            case '-':\n                lhs -= rhs.first;\n                break;\n        }\n        op_seen = true;\n        if(lhs < 0 || lhs >= LIM) throw \"overflow\";\n    }\n    return make_pair(lhs, op_seen);\n}\n\nbool solve() {\n    string str;\n    if(!(cin >> str)) return false;\n\n    vector<int> dot_pos;\n    for(int i = 0; i < str.size(); ++i) {\n        if(str[i] == '.') dot_pos.push_back(i);\n    }\n    const string chars = \"01+-*()\";\n    int lim = 1;\n    for(int i = 0; i < dot_pos.size(); ++i) lim *= chars.size();\n    int ans = -1;\n    for(int pat = 0; pat < lim; ++pat) {\n        int tmp = pat;\n        string s = str;\n        for(int pos : dot_pos) {\n            s[pos] = chars[tmp % chars.size()];\n            tmp /= chars.size();\n        }\n        try {\n            Iterator it = s.begin();\n            const auto res = expr(it, s.end());\n            if(it != s.end()) {\n                throw \"premature end\";\n            }\n            //cout << s << ' ' << res.first << endl;\n            ans = max(ans, res.first);\n        } catch(const char *msg) {\n            //cout << s << ' ' << msg << endl;\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 9;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseVaule(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  if(find(temp, it, '+')==it && find(temp, it, '*')==it && find(temp, it, '-')==it ){\n    return false;\n  }\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseVaule(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseVaule(it, &rv)) return false;\n    *result *= rv;\n    if(*result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar component_array[7] = {'0','1','+','-','*','(',')',};\nint table[16807][7];\nint num_of_blank,table_index;\n\nint calc_E(char line[101],int left,int right);\nint calc_T(char line[101],int left,int right);\nint calc_F(char line[101],int left,int right);\nint calc_NUM(char line[101],int left,int right);\n\nbool rangeCheck(int number){\n\tif(number >= 0 && number <= 1023)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid makeTable(int change_list[5],int index){\n\n\tif(index == num_of_blank){\n\t\tfor(int i = 0; i < num_of_blank; i++){\n\t\t\ttable[table_index][i] = change_list[i];\n\t\t}\n\t\ttable_index++;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 7; i++){\n\t\tint next_change_list[5];\n\t\tfor(int k = 0; k < index; k++)next_change_list[k] = change_list[k];\n\t\tnext_change_list[index] = i;\n\t\tmakeTable(next_change_list,index+1);\n\t}\n}\n\nbool is_OK(char work[101],int length){\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '(' && work[i+1] == ')')return false;\n\t\tif(work[i] == ')' && work[i+1] == '(')return false;\n\t}\n\n\tstack<int> S;\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\tif(work[0] == '+' || work[0] == '*' || work[0] == '-')return false;\n\n\tfor(int i = 0; i < length; i++){\n\t\tif((work[i] == '0' || work[i] == '1') && work[i+1] == '(')return false;\n\t\tif((work[i] == '(') && (work[i+1] == '*' || work[i+1] == '+'))return false;\n\t}\n\n\n\tint num;\n\tfor(int i = 0; work[i] != '\\0';){\n\t\tif(work[i] != '0' && work[i] != '1')i++;\n\t\telse{\n\t\t\tnum = 0;\n\t\t\tfor(; (i < length) && (work[i] == '0' || work[i] == '1'); i++){\n\t\t\t\tnum = 2*num+work[i]-'0';\n\t\t\t\tif(!rangeCheck(num))return false;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif((work[i] == '+' || work[i] == '*' || work[i] == '-') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '-'|| work[i+1] == ')' || work[i+1] == '\\0'))return false;\n\t}\n\n\treturn true;\n}\n\nint calc_E(char line[101],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tif(line[i] == '+'){\n\t\t\t\tQ.push(i);\n\t\t\t\ti++;\n\t\t\t}else{ //line[i] == '-'\n\t\t\t\tif((i != left) && (line[i-1] == '0' || line[i-1] == '1' || line[i-1] == ')')){\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\treturn calc_T(line,left,right);\n\t}\n\n\tint tmp = calc_E(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM || rangeCheck(tmp) == false)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_T(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM || rangeCheck(tmp_right) == false){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '+'){\n\t\t\ttmp += tmp_right;\n\t\t}else{\n\t\t\ttmp -= tmp_right;\n\t\t}\n\t\tif(rangeCheck(tmp) == false){\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nint calc_T(char line[101],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '*'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tQ.push(i);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\treturn calc_F(line,left,right);\n\t}\n\n\tint tmp = calc_T(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM || rangeCheck(tmp) == false)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_F(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM || rangeCheck(tmp_right) == false){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\ttmp *= tmp_right;\n\t\tif(rangeCheck(tmp) == false){\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\treturn tmp;\n}\n\nint calc_F(char line[101],int left,int right){\n\n\tif(line[left] == '1' || line[left] == '0'){\n\t\treturn calc_NUM(line,left,right);\n\t}else if(line[left] == '('){\n\n\t\tint depth = 0;\n\t\tint close_pos = BIG_NUM;\n\t\tbool is_op_exist = false;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tclose_pos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(line[i] == '+' || line[i] == '-' || line[i] == '*'){\n\t\t\t\tif(depth == 1){\n\t\t\t\t\tis_op_exist = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(close_pos == BIG_NUM || close_pos != right || is_op_exist == false)return BIG_NUM;\n\n\t\treturn calc_E(line,left+1,close_pos-1);\n\t}else{\n\t\treturn BIG_NUM;\n\t}\n}\n\nint calc_NUM(char line[101],int left,int right){\n\n\tfor(int i = left; i <= right; i++){\n\t\tif(line[i] != '0' && line[i] != '1')return BIG_NUM;\n\t}\n\n\tint ret = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tret = 2*ret+line[i]-'0';\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tchar buf[101];\n\tscanf(\"%s\",buf);\n\n\tvector<int> REPLACE_LOC;\n\tnum_of_blank = 0;\n\n\tint length = 0;\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tlength++;\n\t\tif(buf[i] == '.'){\n\t\t\tnum_of_blank++;\n\t\t\tREPLACE_LOC.push_back(i);\n\t\t}\n\t}\n\n\tint result,ans = -BIG_NUM;\n\n\tif(num_of_blank == 0){\n\n\t\tif(!is_OK(buf,length)){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult = calc_E(buf,0,length-1);\n\n\t\tif(result == BIG_NUM){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",result);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint first_change_list[5];\n\ttable_index = 0;\n\tmakeTable(first_change_list,0);\n\n\tchar work[101];\n\n\tfor(int i = 0; i < table_index; i++){\n\t\tfor(int k = 0; k < length; k++)work[k] = buf[k];\n\t\twork[length] = '\\0';\n\n\t\tfor(int k = 0; k < num_of_blank; k++){\n\t\t\twork[REPLACE_LOC[k]] = component_array[table[i][k]];\n\t\t}\n\n\t\tif(!is_OK(work,length))continue;\n\n\t\tresult = calc_E(work,0,length-1);\n\t\tif(result == BIG_NUM)continue;\n\n\t\tans = max(ans,result);\n\t}\n\n\tif(ans == -BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nbool valid(int n) {return 0 <= n && n < 1024;}\nbool valid(string str) {\n  int t = 0;\n  rep (i, str.size()) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) return false;\n    }\n  }\n  return t == 0;\n}\n\nint num(string str) {\n  int n = 0;\n  rep (i, str.size()) {\n    n = n * 2 + str[i] - '0';\n    if (n >= 1024) throw 1;\n  }\n  return n;\n}\n\nint exp1(string str);\nint exp2(string str);\nint exp3(string str);\n\nint exp1(string str) {\n  if (str.size() == 0u) throw 1;\n  int t = 0, n = str.size(), s = 0;\n  vector<int> v;\n  rep (i, n) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) throw 1;\n    }\n    if (t == 0 && (str[i] == '+' || str[i] == '-')) {\n      v.push_back((s == 0 || str[s - 1] == '+' ? 1 : -1) * exp1(str.substr(s, i - s)));\n      s = i + 1;\n    }\n  }\n  if (t != 0) throw 1;\n  if (v.size() == 0u) return exp2(str);\n  v.push_back((s == 0 || str[s - 1] == '+' ? 1 : -1) * exp1(str.substr(s, n - s)));\n  int res = 0;\n  rep (i, v.size()) {\n    res += v[i];\n    if (!valid(res)) throw 1;\n  }\n  return res;\n}\n\nint exp2(string str) {\n  if (str.size() == 0u) throw 1;\n  int t = 0, n = str.size(), s = 0;\n  vector<int> v;\n  rep (i, n) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) throw 1;\n    }\n    if (t == 0 && str[i] == '*') {\n      v.push_back(exp1(str.substr(s, i - s)));\n      s = i + 1;\n    }\n  }\n  if (t != 0) throw 1;\n  if (v.size() == 0u) return exp3(str);\n  v.push_back(exp1(str.substr(s, n - s)));\n  int res = 1;\n  rep (i, v.size()) {\n    res *= v[i];\n    if (!valid(res)) throw 1;\n  }\n  return res;\n}\n\nint exp3(string str) {\n  if (str.size() == 0u) throw 1;\n  int t = 0, n = str.size();\n  bool f = true;\n  rep (i, n) if (!isdigit(str[i])) f = false;\n  if (f) return num(str);\n  if (str[0] != '(' || str[n - 1] != ')') throw 1;\n  str = str.substr(1, n - 2);\n  vector<int> v;\n  rep (i, n) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) throw 1;\n    }\n    if (t == 0 && (str[i] == '+' || str[i] == '-' || str[i] == '*')) {\n      return exp1(str);\n    }\n  }\n  throw 1;\n}\n\nconst char c[] = {'0', '1', '+', '-', '*', '(', ')'};\nint solve0(string str, vector<int> dot) {\n  if (dot.size() == 0u) {\n    try {\n      //cout << str << \" \" << exp1(str) << endl;\n      return exp1(str);\n    } catch(int n) {\n      return -1;\n    }\n  }\n  int n = dot.back();\n  dot.pop_back();\n  int res = -1;\n  rep (i, 7) {\n    str[n] = c[i];\n    res = max(res, solve0(str, dot));\n  }\n  return res;\n}\n\nint main() {\n  string str;\n  cin >> str;\n  vector<int> dot;\n  rep (i, str.size()) if (str[i] == '.') dot.push_back(i);\n  cout << solve0(str, dot) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef string::iterator State;\nclass ParseError {};\nint op_cnt;\n\nint ParseExpression(State &itr);\n\nint ParseNumber(State &itr) {\n  int ret = 0;\n  if (*itr != '0' && *itr != '1') throw ParseError();\n\n  while (*itr == '0' || *itr == '1') {\n    ret = ret*2 + (*itr-'0');\n    if (ret >= 1024) throw ParseError();\n    itr++;\n  }\n  return ret;\n}\n\nint ParseFactor(State &itr) {\n  if (*itr == '(') {\n    itr++;\n    int op_cnt_ = op_cnt;\n    int ret = ParseExpression(itr);\n    if (op_cnt_ == op_cnt) throw ParseError();\n    if (*itr != ')') throw ParseError();\n    itr++;\n    return ret;\n  }\n  \n  //op_cnt++;\n  return ParseNumber(itr);\n}\n\nint ParseTerm(State &itr) {\n  int ret = ParseFactor(itr);\n  \n  if (*itr == '*') {\n    itr++;\n    ret *= ParseFactor(itr);\n    if (ret >= 1024) throw ParseError();\n    op_cnt++;\n  } \n\n  return ret;\n}\n\nint ParseExpression(State &itr) {\n  int ret = ParseTerm(itr);\n  if (*itr == '+') {\n    itr++;\n    ret += ParseTerm(itr);\n    if (ret >= 1024) throw ParseError();\n    op_cnt++;\n  } else if (*itr == '-' ) {\n    itr++;\n    ret -= ParseTerm(itr);\n    if (ret < 0) throw ParseError();\n    op_cnt++;\n  }\n  return ret;\n}\n\nint n;\nint ans = -1;\nchar cs[] = \"01+-*().\";\nchar buf[114514];\nstring s;\nvector<int> pos;\n\nvoid rec(int idx) {\n  if (n <= idx) {\n    auto itr = s.begin();\n    try {\n      int ret = ParseExpression(itr);\n      if (itr != s.end()) throw ParseError();\n      ans = max(ans, ret);\n    } catch (const ParseError &e) {}\n    return;\n  }\n\n  for (int i=0; i<8; i++) {\n    s[pos[idx]] = cs[i];\n    rec(idx+1);\n  }\n}\n\nint main() {\n  scanf(\"%s\", buf);\n  s = buf;\n  while (1) {\n    int idx = s.find('.');\n    if (idx == string::npos) break;\n    pos.emplace_back(idx);\n    s[idx] = '$';\n    n++;\n  }\n\n  ans = -1;\n  rec(0);\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nll MOD=1000000007;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;Cursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(bool blacket){\n\t\t\tll l=term();int opc=0;\n\t\t\twhile(*c=='+' || *c=='-'){\n\t\t\t\topc++;\n\t\t\t\tif(*c=='+'){\n\t\t\t\t\tc++;l+=term();\n\t\t\t\t}else{\n\t\t\t\t\tc++;l-=term();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(blacket && opc==0)throw ParseError();\n\n\t\t\treturn l;\n\t\t}\n\n\t\tll term(){\n\t\t\tll l=factor();\n\t\t\twhile(*c=='*'){\n\t\t\t\tc++;l*=factor();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll factor(){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;\n\t\t\t\tll v=expression(true);\n\t\t\t\tif(*c!=')') throw ParseError();\n\t\t\t\tc++;\n\t\t\t\treturn v;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\treturn number();\n\t\t\t}else{\n\t\t\t\tthrow ParseError();\n\t\t\t}\n\t\t}\n\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t        ss << *c;c++;\n\t\t    }\n\t\t    string str;ss>>str;\n\t\t    ll res=0;\n\t\t    REP(i,str.size()){\n\t\t    \tres*=2;\n\t\t    \tif(str[i]=='1')res++;\n\t\t    }\n\t\t\treturn res;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nchar symb[5]={'0','1','+','-','*'};\n\nclass Main{\npublic:\n\tstring s;\t\t\n\tbool input(){\n\t\tgetline(cin,s);\n\t\ts.erase(remove(ALL(s), ' '), s.end());//空白除去\n\t\treturn true;\n\t}\n\n\tll dfs(int i){\n\t\tll Mv=-1;\n\t\tif(i==s.size()){\n\t\t\ttry{\n\t\t\t\tCursor c=s.begin();\n\t\t\t\tSyntax sy(s,c);\n\t\t\t\treturn sy.expression(false);\n\t\t\t}catch(ParseError e){return -1;}\n\t\t}\n\t\tif(s[i]=='.'){\n\t\t\tREP(j,5){\n\t\t\t\ts[i]=symb[j];\n\t\t\t\tMv=max(Mv,dfs(i+1));\n\t\t\t\ts[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tMv=max(Mv,dfs(i+1));\n\t\t}\n\t\treturn Mv;\n\t}\n\n\tvoid run(){\n\t\tinput();\n\t\tcout << dfs(0)<<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc {\n  private:\n    int N, idx;\n    string s;\n    \n  public:\n    Calc (const string& s) : s{s} {\n        idx = 0;\n        N = s.size();\n    }\n\n    static bool is_op(char c)\n    {\n        return (c == '+' || c == '-' || c == '*');   \n    }\n\n    bool check_range(int x)\n    {\n        return (0 <= x && x < 1024);\n    }\n    \n    int num()\n    {\n        int res = 0, p = 0;\n        while (isdigit(s[idx])) {\n            if (p > 10 && s[idx] == '1') return -1;\n            res *= 2;\n            res += (s[idx] - '0');\n            p++;\n            ++idx;\n        }        \n        return (check_range(res) ? res : -1);\n    }\n\n    bool check_op(int cur)\n    {\n        int p = 0;\n        for (int i = cur + 1; i < N; i++) {\n            if (s[i] == '(') p++;\n            if (s[i] == ')') p--;\n            if (p == 0 && is_op(s[i])) return 1;\n            if (p < 0) break;\n        }\n        return 0;\n    }\n    \n    int fact()\n    {\n        int ret = -1;\n        if (s[idx] == '(') {\n            if (!check_op(idx)) throw 0;\n            ++idx;\n            ret = expr();\n            ++idx;\n        } else {\n            ret = num();\n        }\n        return ret;\n    }\n\n    int term()\n    {\n        int ret = fact();\n        while (s[idx] == '*') {\n            ++idx;\n            ret *= fact();\n        }\n        return ret;\n    }\n\n    int expr()\n    {\n        int ret = term();\n\n        while (s[idx] == '+' || s[idx] == '-') {\n            if (s[idx] == '+') {\n                ++idx;\n                ret += term();\n            } else {\n                ++idx;\n                ret -= term();\n            }\n        }\n        return ret;\n    }\n};\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid(const string& s)\n{\n    int p = 0, N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (Calc::is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || Calc::is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || Calc::is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n    }\n    return (p == 0);\n}\n\nint solve(string& s)\n{\n    int N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        Calc calc(s);\n        int res = -1;\n        \n        try {\n            res = calc.expr();\n        } catch (...) {}\n        \n        return res;\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid(s)) {\n            Calc calc(s);\n            try {\n                res = max(res, calc.expr());\n            } catch (...) {}\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    cout << solve(s) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <valarray>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)n; ++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\nconst char ZERO = '0';\nconst char ONE = '1';\nconst int MAX_VAL = (1<<10) - 1;\nconst int MIN_VAL = 0;\n\ninline bool isOp(char c) {\n  return c == '*' || c == '-' || c == '+';\n}\n\ntypedef pair<int, int> value;\nconst value ERROR = make_pair(-1,-1);\n\nvalue mult_exp(const string &s,int idx=0);\nvalue number(const string &s,int idx =0);\nvalue prim_exp(const string &s,int idx=0);\n\nvalue add_exp(const string &s,int idx) {\n  if(s[idx] != ONE && s[idx] != ZERO && s[idx] != '(') return ERROR;\n  value left = mult_exp(s, idx);\n  idx = left.second;\n  int v = left.first;\n  while(true) {\n    if (idx < s.length() && (s[idx] == '+' || s[idx] == '-')) {\n      char op = s[idx];\n      value right = mult_exp(s,idx+1);\n      if (right == ERROR) return ERROR;\n      switch(op) {\n      case '+':\n\tv += right.first;\n\tbreak;\n      case '-':\n\tv -= right.first;\n\tbreak;\n      }\n      if (v < MIN_VAL || v > MAX_VAL) return ERROR;\n      idx = right.second;\n    }else break;\n  }  \n  return make_pair(v, idx);\n}\n\nvalue mult_exp(const string &s,int idx) {\n  if(s[idx] != ONE && s[idx] != ZERO && s[idx] != '(') return ERROR;\n\n  value left = prim_exp(s,idx);\n  if (left == ERROR) return ERROR;\n  idx = left.second;\n  int v = left.first;\n  while(true) {\n    if (idx < s.length() && s[idx] == '*') {\n      value right = prim_exp(s, idx+1);\n      if (right == ERROR) return ERROR;\n      v *= right.first;\n      if (v < MIN_VAL || v > MAX_VAL) return ERROR;\n      idx = right.second;\n    } else break;\n  }\n\n  return make_pair(v, idx);\n}\n\nvalue prim_exp (const string &s, int idx) {\n  if (s[idx] == ONE || s[idx] == ZERO) return number(s,idx);\n  if (s[idx] != '(') return ERROR;\n  value v = add_exp(s, idx+1);\n  if (v.second >= s.length() || s[v.second] != ')' || v == ERROR) return ERROR;\n  if (v.first < MIN_VAL || v.second > MAX_VAL) return ERROR;\n\n  bool onlynum = true;\n  for (int i=idx+1; i<v.second; ++i) {\n    if(s[i] != ONE && s[i] != ZERO) onlynum = false;\n  }\n  if(onlynum) return ERROR;\n  return make_pair(v.first, v.second+1);\n}\n\nvalue number(const string &s, int idx) {\n  if (s[idx] != ONE && s[idx] != ZERO) return ERROR;\n  int ret = 0;\n  while(s[idx] == ONE || s[idx] == ZERO) {\n    ret <<= 1;\n    ret += s[idx] - ZERO;\n    if (ret < MIN_VAL || ret > MAX_VAL) return ERROR;\n    idx++;\n    if(idx == s.length()) break;\n  }\n  //cout<<\"number:\"<<ret<<endl;\n  if (ret < MIN_VAL || ret > MAX_VAL) return ERROR;\n  return make_pair(ret, idx);\n}\n\nchar letter[7] = {'0', '1', '+', '-', '*', '(', ')'};\n\nbool check(const string &in) {\n  bool ok = true;\n  for (int i=0; i<in.length(); ++i) {\n    if(in[i] != '(') continue;\n    int depth = 1, nop = 0;\n    for (int j=i+1; j<in.length(); ++j) {\n      if(in[j] == '(') depth++;\n      if(in[j] == ')') depth--;\n      if(depth == 0) break;\n      if(depth == 1 && (in[j] == '+' || in[j] == '-' || in[j] == '*')) {\n\tnop++;\n      }\n    }\n    if(nop == 0) ok = false;\n  }\n  return ok;\n}\n\nint main() {\n  string input;\n  cin>>input;\n  char cnt = '2';\n  for (int i=0; i<input.length(); ++i) {\n    if (input[i] == '.') input[i] = cnt++;\n  }\n\n  int num = cnt - '2';\n\n  if(num == 0) {\n    value v = add_exp(input, 0);\n    if(v == ERROR || !check(input) || v.second != input.length()) cout<<-1<<endl;\n    else cout<<v.first<<endl;\n    return 0;\n  }\n\n  vector<int> pattern(num, 0);\n  int ans = -1;\n  while(true) {\n    string in = input;\n    for (int i=0; i<in.length(); ++i) {\n      if(in[i] >= '2' && in[i] <= '9') in[i] = letter[pattern[in[i]-'2']];\n    }\n\n    value v = add_exp(in,0);\n    if(v != ERROR && v.second == in.length() && check(in)) {\n      if(ans < v.first) cout<<in<<endl;\n      ans = max(ans, v.first);\n    }\n\n    bool end = true;\n    for (int i=0; i<num; ++i)\n      if(pattern[i] != 6) end = false;\n    if(end) break;\n\n    for (int i=0; i<num; ++i) {\n      if(pattern[i] == 6) pattern[i] = 0;\n      else {\n\tpattern[i]++;\n\tbreak;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool ope, err;\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\t\n\t\tp++;\n\t\tope=false;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\tif (!ope) err=true;\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else {\n\t\treturn number(s);\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tope = true;\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\twhile (s[p] == '+' || s[p] == '-') {\n\t\tope = true;\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += expression(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= expression(s);\n\t\t}\n\t}\n\t\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\treturn res;\n}\n\nbool check(string s)\n{\n\tint l=0, r=0;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') l++;\n\t\telse if (s[i] == ')') r++;\n\t}\n\treturn l==r;\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>1024) res=-1;\n\t\t\n\t\tcerr << \"Persing : \" << s << endl;\n\t\tcerr << \"    res : \" << (err?-1:res) << endl;\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 110;\n\nint N;\nstring s;\n\nbool is_num(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (!isdigit(s[i])) return 0;\n    }\n    return 1;\n}\n\nbool check_range(int x)\n{\n    return (0 <= x && x < 1024);\n}\n\nint num(int L, int R)\n{\n    int res = 0;\n    for (int i = R; i >= L; i--) {\n        if (R - i > 10 && s[i] == '1') {\n            return -1;\n        }\n        res += (s[i] - '0') * pow(2, R - i);\n    }\n    return (check_range(res) ? res : -1);\n}\n\nbool is_op(char c)\n{\n    return (c == '+' || c == '-' || c == '*');\n}\n\nbool check_op(int L, int R)\n{\n    int p = 0;\n    for (int i = L; i <= R; i++) {\n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p == 0 && is_op(s[i])) return 1; \n    }\n    return 0;\n}\n\nint mem[MAX][MAX];\n\nint expr(int L, int R)\n{\n    int& res = mem[L][R];\n    if (res != -1) return res;\n\n    if (is_num(L, R)) return num(L, R);\n    \n    for (int i = L + 1; i <= R - 1; i++) {\n        if (!is_op(s[i])) continue;\n        \n        int l = expr(L, i - 1), r = expr(i + 1, R);\n        int v = -1;\n\n        if (l == -1 || r == -1) continue;\n        \n        switch (s[i]) {            \n            case '+':\n                v = l + r;\n                break;\n            case '-':\n                v = l - r;\n                break;\n            case '*':\n                v = l * r;\n                break;                \n        }\n        \n        if (!check_range(v)) continue;\n        \n        res = max(res, v);\n    }\n\n        \n    if (s[L] == '(' && s[R] == ')') {\n        if (check_op(L + 1, R - 1)) {\n            res = max(res, expr(L + 1, R - 1));\n        } \n    }\n\n    return res;\n}\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid()\n{\n    int p = 0;\n    for (int i = 0; i < N; i++) {\n        if (is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n    }\n    return (p == 0);\n}\n\nint solve()\n{\n    N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        memset(mem, -1, sizeof(mem));\n        return expr(0, N - 1);\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid()) {\n            memset(mem, -1, sizeof(mem));            \n            res = max(res, expr(0, N - 1));\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    cin >> s;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\n\t\tif (val >= 1024)return -1;\n\t\tif (val < 0)return -1;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t\tif (val >= 1024)return - 1;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num]))n = n * 2 + s[num++] - '0';\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\tsc.push('0');\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.empty()||sc.top() == '0'){\n\t\t\tans = expr(s, num);\n\t\t\tma = max(ma, ans);\n\t\t}\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nchar S[111];\n\n#define INF (-(1<<20))\n\nint number(int l,int r){\n  int ret = 0;\n  for(int i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n  }\n \n  return ret;\n}\n\n\nint check(int x){\n  if( 0 <= x && x < (1<<10) ) return x;\n  return INF;\n}\n\nbool check_n(int l,int r){\n  for(int i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return false;\n  }\n  return true;\n}\nbool check_k2(int l,int r){\n  int cnt =0;\n  for(int i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt > 0 ) return false;\n  }\n  if( cnt == 0 ) return true;\n  return false;\n}\n\n\nbool check_k(int l,int r){\n  int cnt =0;\n  if( l==r ) return false;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n\nbool check_m(int l,int r){\n  int cnt =0;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n\nbool check_w(int l,int r){\n  int cnt =0;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n\n\nvoid view(int l,int r){\n  for(int i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n\nbool check_h(int l,int r){\n  if( S[l] == '+' || S[r] == '+' || S[l] == '-' || S[r] == '-' || S[l] == '*' || S[r] == '*' ||  S[l] == ')' || S[r] == '(' ) return true;\n  return false;\n}\n\nint exp(int l,int r){\n  //view(l,r);\n  if( check_h(l,r) ) return INF;\n  if( !check_k2(l,r) ) return INF;\n  if( check_k(l,r) ) {\n    if( check_n(l+1,r-1) ) return INF;\n    return check(exp(l+1,r-1));\n  }\n  if( check_w(l,r) ) {\n    int cnt = 0;\n    for(int i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return check(exp(l,i-1) + exp(i+1,r));\n      if( cnt == 0 && S[i] == '-' ) return check(exp(l,i-1) - exp(i+1,r));\n    }\n  }\n  if( check_m(l,r) ) {\n    int cnt = 0;\n    for(int i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return check(exp(l,i-1) * exp(i+1,r));\n    }\n  }\n  if( check_n(l,r) )\n    return check(number(l,r));\n  return INF;\n}\n\nint  main(){\n  cin >> S;\n  N  = strlen(S);\n  int M = 0;\n  for(int i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  int res = -1;\n  int K=1;\n  for(int i=0;i<M;i++) K*=7;\n  for(int i=0;i<K;i++){\n    int c = i;\n    strcpy( S, buf );\n    for(int j=0;j<N;j++){\n      if( S[j] == '.' ){\n\tif( c%7 == 0 ) S[j] = '0';\n\tif( c%7 == 1 ) S[j] = '1';\n\tif( c%7 == 2 ) S[j] = '+';\n\tif( c%7 == 3 ) S[j] = '-';\n\tif( c%7 == 4 ) S[j] = '*';\n\tif( c%7 == 5 ) S[j] = '(';\n\tif( c%7 == 6 ) S[j] = ')';\t\t\n\tc/=7;\n      }    \n    }\n    //cout << S<< endl;\n    res = max( res, exp(0,N-1) );\n    //  cout << res << endl;\n  }\n  cout << res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc();\nint expr();\nint number();\nstring tmp;\nint pos;\nchar c[]=\"()+-*01\";\nint ans=-1;\nbool f=0,ff;\nint calc(){\n  int res=expr();\n  while(1){\n    if(tmp[pos]=='*') {pos++;res*=expr();}\n    else break;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint expr(){\n  int res=number();\n  while(1){\n    if(tmp[pos]=='+') {pos++;res+=number();}\n    else if(tmp[pos]=='-') {pos++;res-=number();}\n    else break;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint number(){\n  int res=0;\n  if(tmp[pos]=='(') {\n    pos++;res=calc();pos++;\n  }else{\n    while(pos<(int)tmp.size()&&isdigit(tmp[pos])) res=res*2+tmp[pos]-'0',pos++;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\n \nbool check(string s){\n  int o=0;\n  bool op[100]={};\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') {\n      o++;\n      op[o]=1;\n      if(i+1>=(int)s.size()) return 0;\n      if(!isdigit(s[i+1])&&s[i+1]!='(') return 0;\n    }    \n    if(s[i]==')') {\n      if(op[o]) return 0;\n      o--;\n      if(i-1<0) return 0;\n      if(!isdigit(s[i-1])&&s[i-1]!=')') return 0;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*') {\n      op[o]=0;\n      if(i-1<0||i+1>=(int)s.size()) return 0;\n      if((!isdigit(s[i-1])&&s[i-1]!=')')||(!isdigit(s[i+1])&&s[i+1]!='(')) return 0;\n    }\n    if(o<0) return 0;\n  }\n  if(o) return 0;\n  return 1;\n}\nvoid rec(string s){\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]!='.') continue;\n    for(int j=0;j<8;j++){\n      s[i]=c[j];\n      rec(s);\n    }\n    return;\n  }\n  if(!check(s)) return;\n  tmp=s;pos=0;ff=1;\n  int k=calc();\n  if(ff) ans=max(ans,k);//,cout<<k<<\":\"<<tmp<<endl;\n}\nint main(){\n  string s;\n  cin>>s;\n  rec(s);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(e==fail||!e.second||s[x]!=')')return fail;\n    x++;\n    return e;\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(f==fail)return f;\n  if(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(l==fail)return l;\n    return make_pair(f.first*l.first,true);\n  }else{\n    return f;\n  }\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(f==fail)return f;\n  if(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(l==fail)return l;\n    return make_pair(f.first+sign*l.first,true);\n  }else{\n    return f;\n  }\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tm=max(m,dfs());\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1<<10)\nusing namespace std;\n\nstring s;\nvector<int> idx;\nvector<char> c;\nchar lis[7]={'0','1','+','-','*','(',')'};\nint ans=-1, p, flag;\n\nbool check(){\n\n  int r=0, f=0;\n\n  for(int i=p;i<s.size();i++){\n    if(r==1&&(s[i]=='+'||s[i]=='-'||s[i]=='*')) f=1;\n    if(s[i]=='(') r++;\n    if(s[i]==')') r--;\n    if(r==0) break;\n  }\n  \n  return f==1;\n}\n\nint bnf();\n\nint bnf3(){\n\n  int res=0;\n  \n  if(s[p]=='('){\n    \n    bool r=check();\n    \n    p++;\n    res=bnf();\n    p++;\n   \n    if(!r) flag=1;\n    \n    return res;\n  }\n\n  if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0', p++;\n\n  return res;\n}\n\nint bnf2(){\n  \n  int res=bnf3();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='*'){\n      p++;\n      res=res*bnf3();\n      if(res>=INF) res=INF;\n    }else{\n      if(p<s.size()&&s[p]!=')'&&s[p]!='+'&&s[p]!='-') flag=1;\n      break;\n    }\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n      p++;\n      res=res+bnf2();\n      if(res>=INF) res=INF;\n    }\n    else if(s[p]=='-'){\n      p++;\n      res=res-bnf2();\n    }else{\n      if(p<s.size()&&s[p]!=')') flag=1;\n      break;\n    }\n  }\n  \n  return res;\n}\n\nbool check2(){\n  \n  int r=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') r++;\n    if(s[i]==')'){\n      if(!r) return false;\n      r--;\n    }\n  }\n\n  if(r) return false;\n\n  return true;\n}\n\nvoid dfs(int x){\n  \n  if(x==idx.size()){\n    \n    for(int i=0;i<idx.size();i++)\n      s[idx[i]]=c[i];\n    \n    p=0, flag=0;\n    \n    if(!check2()) return ;\n    \n    int r=bnf();\n    \n    if(flag) return ;\n\n    ans=max(ans,r);\n    \n    return ;\n  }\n  \n  for(int i=0;i<7;i++){\n    \n    c[x]=lis[i];\n    \n    dfs(x+1);\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>s;\n  \n  for(int i=0;i<s.size();i++)\n    if(s[i]=='.') idx.push_back(i);\n\n  c.resize(idx.size());\n\n  dfs(0);\n  \n  if(ans>=(1<<10)) ans=-1;\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(e.first<0||!e.second||s[x]!=')')return fail;\n    x++;\n    return e;\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(f.first<0)return f;\n  if(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(l.first<0)return l;\n    return make_pair(f.first*l.first,true);\n  }else{\n    return f;\n  }\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(f.first<0)return f;\n  if(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(l.first<0)return l;\n    return make_pair(f.first+sign*l.first,true);\n  }else{\n    return f;\n  }\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tm=max(m,dfs());\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\n\nstruct Parser{\n\tstring s;\n\tint N;\n\tint c;\n\n\tll parse(string s){\n\t\tthis->s = s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\ttry{\n\t\t\tll ret = expr();\n\t\t\tif(c != N) throw \"\";\n\t\t\treturn ret;\n\t\t}\n\t\tcatch(...){\n\t\t\treturn INF;\n\t\t}\n\t}\n\n\tbool check(ll n){\n\t\treturn 0 <= n && n < 1024;\n\t}\n\n\tvoid debug(string text){\n\t\treturn;\n\t\tcout << text + \" \";\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\t\telse cout << s[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tll expr(){\n\t\tdebug(\"expr\");\n\t\tll x = term();\n\t\tif(!check(x)) throw \"\";\n\t\twhile(c < N){\n\t\t\tif(s[c] == '+'){\n\t\t\t\tc++;\n\t\t\t\tx += term();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse if(s[c] == '-'){\n\t\t\t\tc++;\n\t\t\t\tx -= term();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll term(){\n\t\tdebug(\"term\");\n\t\tll x = factor();\n\t\twhile(c < N){\n\t\t\tif(s[c] == '*'){\n\t\t\t\tc++;\n\t\t\t\tx *= factor();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll factor(){\n\t\tdebug(\"factor\");\n\t\tif(s[c] == '('){\n\t\t\tc++;\n\t\t\tint start = c;\n\t\t\tll ret = expr();\n\t\t\tif(s[c] != ')') throw \"\";\n\t\t\t//assert(s[c] == ')');\n\t\t\tint cnt = 0;\n\t\t\tbool op = 0;\n\t\t\tfor(int i = start; i < c; i++){\n\t\t\t\tif(s[i] == '(') cnt++;\n\t\t\t\tif(s[i] == ')') cnt--;\n\t\t\t\tif(cnt == 0 && (s[i] == '+' || s[i] == '*')) op = 1;\n\t\t\t}\n\t\t\tif(!op) throw \"\";\n\t\t\tc++;\n\t\t\treturn ret;\n\t\t}\n\t\treturn num();\n\t}\n\n\tll num(){\n\t\tdebug(\"num\");\n\t\tif(!isdigit(s[c])) throw \"\";\n\t\tll ret = 0;\n\t\twhile(c < N && isdigit(s[c])){\n\t\t\tret = ret * 2 + s[c] - '0';\n\t\t\tc++;\n\t\t}\n\t\treturn ret;\n\t}\n} parser;\n\nstring t = \"01+*-()\";\nll ans = -1;\n\nvoid dfs(int n, string s){\n\tif(n == s.size()){\n\t\tll res = parser.parse(s);\n\t\tif(res != INF) ans = max(ans, res);\n\t\treturn;\n\t}\n\tif(s[n] != '.'){\n\t\treturn dfs(n + 1, s);\n\t}\n\tfor(int i = 0; i < t.size(); i++){\n\t\ts[n] = t[i];\n\t\tdfs(n + 1, s);\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tstring s;\n\tcin >> s;\n\tdfs(0, s);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring cs=\"01+-*()\";\nstring s;\nint n;\n\nint f(int l,int r){\n  bool isn=true;\n  repl(i,l,r)if(!isdigit(s[i]))isn=false;\n  if(isn){\n    int res=0;\n    repl(i,l,r){\n      res*=2;\n      res+=s[i]-'0';\n    }\n    if(res>=pow(2,10))return -1;\n    else return res;\n  }\n\n  if(s[l]=='('){\n    if(s[r-1]!=')')return -1;\n    int lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1)return -1;\n        else return vl+vr;\n      }\n    }\n    lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1)return -1;\n        else return vl*vr;\n      }\n    }\n  }else{\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1)return -1;\n        else return vl+vr;\n      }\n    }\n    lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1)return -1;\n        else return vl*vr;\n      }\n    }\n  }\n  return -1;\n}\n\nint dfs(int i){\n  if(i==n){\n    return f(0,n);\n  }else{\n    if(s[i]=='.'){\n      int res=-1;\n      rep(j,7){\n        s[i]=cs[j];\n        int tmp=dfs(i+1);\n        maxch(res,tmp);\n      }\n      s[i]='.';\n      return res;\n    }else{\n      return dfs(i+1);\n    }\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1<<10)\nusing namespace std;\n\nstring s;\nvector<int> idx;\nvector<char> c;\nchar lis[7]={'0','1','+','-','*','(',')'};\n\nint ans=-1, p;\n\nint bnf();\n\nint bnf3(){\n\n  int res=0;\n  \n  if(s[p]=='('){\n    p++;\n    res=bnf();\n    p++;\n    return res;\n  }\n\n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0', p++;\n\n  return res;\n}\n\nint bnf2(){\n  \n  int res=bnf3();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='*'){\n      p++;\n      res=res*bnf3();\n      if(res>=INF) res=INF;\n    }else break;\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n      p++;\n      res=res+bnf2();\n      if(res>=INF) res=INF;\n    }\n    else if(s[p]=='-'){\n      p++;\n      res=res-bnf2();\n    }else break;\n    \n  }\n  \n  return res;\n}\n\nbool check(){\n\n  int r=0;\n  \n  for(int i=0;i<s.size();i++){\n    \n    if(s[i]=='*'||s[i]=='+'||s[i]=='-'){\n      if(!i||i==s.size()-1) return false;\n      if(s[i-1]=='*'||s[i-1]=='+'||s[i-1]=='-'||s[i-1]=='(') return false;\n      if(s[i+1]=='*'||s[i+1]=='+'||s[i+1]=='-'||s[i+1]==')') return false;\n    }\n    \n    if(s[i]=='('){\n      int f=0;\n      for(int j=i+1;j<s.size();j++){\n\tif(s[j]==')') break;\n\tif(s[j]!='0'&&s[j]!='1') f=1;\n      }\n      if(!f) return false;\n      r++;\n    }\n    if(s[i]==')'){\n      if(!r) return false;\n      r--;\n    }\n    \n  }\n  \n  if(r!=0) return false;\n\n  return true;\n}\n\nvoid dfs(int x){\n  \n  if(x==idx.size()){\n    \n    for(int i=0;i<idx.size();i++)\n      s[idx[i]]=c[i];\n    \n    if(!check()) return ;\n    \n    p=0;\n    int r=bnf();\n\n    ans=max(ans,r);\n    \n    return ;\n  }\n  \n  for(int i=0;i<7;i++){\n    \n    c[x]=lis[i];\n    \n    dfs(x+1);\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>s;\n  \n  for(int i=0;i<s.size();i++)\n    if(s[i]=='.') idx.push_back(i);\n\n  c.resize(idx.size());\n\n  dfs(0);\n  \n  if(ans>=(1<<10)) ans=-1;\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nstruct parse_error {};\n\nvoid check_range(int n)\n{\n  if (n < 0 || 1024 <= n) {\n    throw parse_error();\n  }\n}\n\nint expr(Iterator& it, const Iterator& last);\nint term(Iterator& it, const Iterator& last);\n\nint number(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw parse_error();\n  }\n  int n = 0;\n  while (it != last && isdigit(*it)) {\n    n = 2*n + (*it - '0');\n    ++it;\n    check_range(n);\n  }\n  return n;\n}\n\nint factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw parse_error();\n  }\n  if (*it == '(') {\n    ++it;\n\n    int n = factor(it, last);\n    if (it == last) {\n      throw parse_error();\n    }\n    if (*it == '*') {\n      while (it != last && *it == '*') {\n        ++it;\n        n *= factor(it, last);\n        check_range(n);\n      }\n      while (it != last && (*it == '+' || *it == '-')) {\n        const char op = *it;\n        ++it;\n        int m = term(it, last);\n        if (op == '+') {\n          n += m;\n        } else {\n          n -= m;\n        }\n        check_range(n);\n      }\n    } else if (*it == '+' || *it == '-') {\n      while (it != last && (*it == '+' || *it == '-')) {\n        const char op = *it;\n        ++it;\n        int m = term(it, last);\n        if (op == '+') {\n          n += m;\n        } else {\n          n -= m;\n        }\n        check_range(n);\n      }\n    } else {\n      throw parse_error();\n    }\n\n    if (it == last || *it != ')') {\n      throw parse_error();\n    }\n    ++it;\n    return n;\n  } else if (isdigit(*it)) {\n    return number(it, last);\n  } else {\n    throw parse_error();\n  }\n}\n\nint term(Iterator& it, const Iterator& last)\n{\n  int n = factor(it, last);\n  while (it != last && *it == '*') {\n    ++it;\n    n *= factor(it, last);\n    check_range(n);\n  }\n  return n;\n}\n\nint expr(Iterator& it, const Iterator& last)\n{\n  int n = term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    int m = term(it, last);\n    if (op == '+') {\n      n += m;\n    } else {\n      n -= m;\n    }\n    check_range(n);\n  }\n  return n;\n}\n\nint main()\n{\n  string s;\n  getline(cin, s);\n  int a[5];\n  static const char tbl[] = \"01+-*()\";\n  int ans = -1;\n  for (a[0] = 0; a[0] < 7; a[0]++) {\n    for (a[1] = 0; a[1] < 7; a[1]++) {\n      for (a[2] = 0; a[2] < 7; a[2]++) {\n        for (a[3] = 0; a[3] < 7; a[3]++) {\n          for (a[4] = 0; a[4] < 7; a[4]++) {\n            string t = s;\n            for (int i = 0; i < 5; i++) {\n              string::size_type n = t.find('.');\n              if (n != string::npos) {\n                t[n] = tbl[a[i]];\n              }\n            }\n            try {\n              Iterator it = t.begin(), last = t.end();\n              int n = expr(it, last);\n              if (it == last) {\n                ans = max(ans, n);\n              }\n            } catch (const parse_error&) {\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc {\n  private:\n    int N, idx;\n    string s;\n    \n  public:\n    Calc (const string& s) : s{s} {\n        idx = 0;\n        N = s.size();\n    }\n\n    static bool is_op(char c)\n    {\n        return (c == '+' || c == '-' || c == '*');   \n    }\n\n    bool check_range(int x)\n    {\n        return (0 <= x && x < 1024);\n    }\n    \n    int num()\n    {\n        int res = 0, p = 0;\n        while (isdigit(s[idx])) {\n            if (p > 10 && s[idx] == '1') return -1;\n            res *= 2;\n            res += (s[idx] - '0');\n            p++;\n            ++idx;\n        }        \n        return (check_range(res) ? res : -1);\n    }\n\n    bool check_op(int cur)\n    {\n        int p = 0;\n        for (int i = cur + 1; i < N; i++) {\n            if (s[i] == '(') p++;\n            if (s[i] == ')') p--;\n            if (p == 0 && is_op(s[i])) return 1;\n            if (p < 0) break;\n        }\n        return 0;\n    }\n    \n    int fact()\n    {\n        int ret = -1;\n        if (s[idx] == '(') {\n            if (!check_op(idx)) throw 0;\n            ++idx;\n            ret = expr();\n            if (!check_range(ret)) throw 0; \n            ++idx;\n        } else {\n            ret = num();\n        }\n        return ret;\n    }\n\n    int term()\n    {\n        int ret = fact();\n        while (s[idx] == '*') {\n            ++idx;\n            ret *= fact();\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n\n    int expr()\n    {\n        int ret = term();\n\n        while (s[idx] == '+' || s[idx] == '-') {\n            if (s[idx] == '+') {\n                ++idx;\n                ret += term();\n            } else {\n                ++idx;\n                ret -= term();\n            }\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n};\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid(const string& s)\n{\n    int p = 0, N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (Calc::is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || Calc::is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || Calc::is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n\n        for (int j = i + 1; j < N; j++) {\n            if (s[i] == '(' && s[j] == ')' && j - i < 4) {\n                return 0;\n            }\n        }\n    }\n    return (p == 0);\n}\n\nint solve(string& s)\n{\n    int N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        Calc calc(s);\n        int res = -1;\n        \n        try {\n            res = calc.expr();\n        } catch (...) {}\n        \n        return res;\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid(s)) {\n            Calc calc(s);\n            try {\n                res = max(res, calc.expr());\n            } catch (...) {}\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    cout << solve(s) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nstring st;\nint a = 0;\nvoid check(const int num) {\n\tif (num < 0 || num >= 1024)throw(false);\n}\nint getnum() {\n\tint num = 0;\n\twhile (isdigit(st[a])) {\n\t\tnum = num * 2 + st[a] - '0';\n\t\ta++;\n\t}\n\tcheck(num);\n\treturn num;\n}\nint getexpr(const int isstart);\nint getkakko();\nint getka() {\n\tif (st[a] == '(') {\n\t\tint num=getkakko();\n\t\treturn num;\n\t}\n\telse if(isdigit(st[a])){\n\t\treturn getnum();\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\nint getso() {\n\tint num = getka();\n\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')'||st[a]=='+'||st[a]=='-') {\n\t\t\treturn num;\n\t\t}\n\t\telse if (st[a] == '*') {\n\t\t\ta++;\n\t\t\tint n_num = getka();\n\t\t\tnum *= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\nint getexpr() {\n\tint num = getso();\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\treturn num;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\ta++;\n\t\t\tint n_num = getso();\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\ta++;\n\t\t\tint n_num = getso();\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\nint getkakko() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n\tint num = getso();\n\n\tint fst = true;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\tthrow(false);\n\t\t}else if( st[a] == ')') {\n\t\t\tif (!fst)break;\n\t\t\telse throw(false);\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\ta++;\n\t\t\tint n_num = getso();\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\ta++;\n\t\t\tint n_num = getso();\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t\tfst = false;\n\t}\n\tif (st[a] == ')') {\n\t\ta++;\n\t\treturn num;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\nint main() {\n\tstring base; cin >> base;\n\tst = base;\n\tstring aa = \"01+-*()\";\n\tvector<int>unknowns;\n\tfor (int i = 0; i < base.size(); ++i) {\n\t\tif (base[i] == '.') {\n\t\t\tunknowns.emplace_back(i);\n\t\t}\n\t}\n\tint ans = -1;\n\tfor (int i = 0; i < powint(7, unknowns.size()); ++i) {\n\t\tint num(i);\n\t\ta = 0;\n\t\tfor (int j = 0; j < unknowns.size(); ++j) {\n\t\t\tst[unknowns[j]] = aa[num % 7];\n\t\t\tnum /= 7;\n\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tint num = getexpr();\n\t\t\tans=max(ans,num);\n\t\t}\n\t\tcatch (...) {\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nchar ch[] = {\n  '0', '1', '+', '-', '(', ')',\n};\nsize_t cur;\nstring str;\n\nint E(int &op_cnt);\n\nint number(){\n  int res = 0;\n  while(cur < str.size() && isdigit(str[cur])) res = res * 2 + str[cur++] - '0';\n  return res;\n}\n\nint T(){\n  int res;\n  if(isdigit(str[cur])){\n    res = number();\n  }else if(str[cur] == '('){\n    int cnt = 0;\n    cur++;\n    res = E(cnt);\n    if(cur == str.size()) return -1;\n    cur++;\n    if(cnt == 0) res = -1;\n  }else{\n    res = -1;\n    cur++;\n  }\n  return res;\n}\n\nint F(int &op_cnt){\n  int res = 1;\n  vector<int> v;\n  \n  v.push_back(T());\n  \n  while(cur < str.size() && str[cur] == '*'){\n    cur++;\n    op_cnt++;\n    if(cur == str.size()) return -1;\n    int tmp = T();\n    if(tmp < 0) return -1;\n    v.push_back(tmp);\n  }\n  \n  rep(i, v.size()){\n    res *= v[i];\n  }\n  return res;\n}\n\nint E(int &op_cnt){\n  \n  int res = 0;\n  int tmp;\n  vector<int> v;\n  \n  tmp = F(op_cnt);\n  if(tmp < 0) return -1;\n  else v.push_back(tmp);\n  \n  if(res == -1) return -1;\n  \n  while(cur < str.size() && (str[cur] == '+' || str[cur] == '-')){\n    char op = str[cur];\n    op_cnt++;\n    cur++;\n    if(cur == str.size()) return -1;\n      \n    tmp = F(op_cnt);\n    if(tmp < 0) return -1;\n    else v.push_back(op == '+' ? tmp : -tmp);\n  }\n  \n  if(cur < str.size() && str[cur] != ')') return -1;\n  rep(i, v.size()){\n    res += v[i];\n  }\n  return res;\n}\n\nint calc(string s){\n  int cnt;\n  str = s;\n  cur = 0;\n  //  cout << s << endl;\n  int res = E(cnt);\n  //cout << res << endl;\n  return res;\n  \n}\n\nint dfs(string s, int c){\n  if(c == 0){\n    return calc(s);\n  }\n  \n  int res = -1;\n  int pos = 0;\n  while(s[pos] != '.') pos++;\n  \n  rep(i, 6){\n    s[pos] = ch[i];\n    res = max(res, dfs(s, c - 1));\n    s[pos] = '.';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  int c = count(s.begin(), s.end(), '.');\n  cout << dfs(s, c) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tconst int kind = 7;\n\tStage(){\n\t}\n\t\n\tvoid action(){\n\t\tstring text;\n\t\tcin >> text;\n\n\t\tint res = -1;\n\t\tREP(transWay, pow(kind, count_dot(text))) {\n\t\t\tstring transedText = trans(transWay, text);\n\t\t\tlist<char> ls;\n\t\t\tfor (char c : transedText)ls.push_back(c);\n\t\t\tauto grams = trans_gram(ls);\n\t\t\tif (grams.empty())continue;\n\t\t\tint score = read(grams);\n\n\t\t\tres = max(res, score);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tchar data;\n\t\tint num;\n\t};\n\t\n\tint count_dot(const string& text) {\n\t\tint res = 0;\n\t\tfor (char c : text)if (c == '.')res++;\n\t\treturn res;\n\t}\n\tstring trans(int n, string text) {\n\t\tfor (char& c : text)if (c == '.') {\n\t\t\tswitch (n % kind) {\n\t\t\tcase 0:c = '0'; break;\n\t\t\tcase 1:c = '1'; break;\n\t\t\tcase 2:c = '+'; break;\n\t\t\tcase 3:c = '-'; break;\n\t\t\tcase 4:c = '*'; break;\n\t\t\tcase 5:c = '('; break;\n\t\t\tcase 6:c = ')'; break;\n\t\t\t}\n\t\t\tn /= kind;\n\t\t}\n\t\treturn text;\n\t}\n\n\tlist<Gram> trans_gram(const list<char>& ls) {\n\t\tlist<Gram> grams;\n\t\tfor (auto itr = ls.begin(); itr != ls.end(); ++itr) {\n\t\t\tGram gram;\n\t\t\tswitch (*itr) {\n\t\t\tcase '+':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '+';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '-';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '*';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = '(';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = ')';\n\t\t\t\t//gram.num = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgram.kind = 'n';\n\t\t\t\tgram.data = 't';\n\t\t\t\tgram.num = 0;\n\t\t\t\tdo {\n\t\t\t\t\tgram.num *= 2;\n\t\t\t\t\tgram.num += *itr - '0';\n\t\t\t\t\t++itr;\n\t\t\t\t} while (itr != ls.end() && isDigit(*itr));\n\t\t\t\tif (!isvalid(gram.num))return list<Gram>();\n\t\t\t\t--itr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tint read(list<Gram> grams){\n\t\ttry {\n\t\t\t// ( , ) delete\n\t\t\tfor (auto right = grams.begin(); right != grams.end(); ++right)\n\t\t\t{\n\t\t\t\tif (right->data == ')') {\n\t\t\t\t\tlist<Gram> subset;\n\t\t\t\t\tauto left = right;\n\n\t\t\t\t\t//move: (expression)\n\t\t\t\t\twhile (left != grams.begin() && left->data != '(') --left;\n\t\t\t\t\tif (left->data != '(')throw - 1;\n\t\t\t\t\t++right;\n\t\t\t\t\tsubset.splice(subset.begin(), move(grams), left, right);\n\n\t\t\t\t\t// delete: ( , )\n\t\t\t\t\tsubset.pop_front();\n\t\t\t\t\tsubset.pop_back();\n\n\t\t\t\t\tif (subset.size() == 1)throw - 1;\n\n\t\t\t\t\tint res = read(subset);\n\t\t\t\t\tif (res < 0)throw - 1;\n\t\t\t\t\tif (1024 <= res)throw - 1;\n\n\t\t\t\t\tGram gram;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = res;\n\t\t\t\t\tgrams.insert(right, gram);\n\t\t\t\t\tright = grams.begin();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperator_erase(grams, '*', '*');\n\t\t\toperator_erase(grams, '+', '-');\n\t\t\tif (grams.size() != 1) {\n\t\t\t\t//cerr << \"size is too much\" << endl;\n\t\t\t\tthrow - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (grams.front().kind != 'n')throw - 1;\n\n\t\t\t\tint res = grams.front().num;\n\t\t\t\tif (!isvalid(res))throw -1;\n\t\t\t\telse return res;\n\t\t\t}\n\t\t}\n\t\tcatch (...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbool isvalid(int num) {\n\t\treturn 0 <= num && num < 1024;\n\t}\n\n\tbool isDigit(char c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tbool isnumber(const list<char>& ls){\n\t\tfor (char c : ls) {\n\t\t\tif (!isDigit(c)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isoperator(const char& c) {\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tvoid operator_erase(\n\t\tlist<Gram>& grams,\n\t\tchar ope1,\n\t\tchar ope2\n\t){\n\t\tfor (auto center = grams.begin(); center != grams.end(); ++center) {\n\t\t\tif (center->data == ope1 || center->data == ope2) {\n\t\t\t\tauto left = center; if (distance(grams.begin(), left) == 0)break; left--;\n\t\t\t\tauto right = center; if (distance(right, grams.end()) == 1)break; right++;\n\t\t\t\tif (left->kind != 'n' || right->kind != 'n')continue;\n\n\t\t\t\tswitch (center->data) {\n\t\t\t\tcase '+':left->num += right->num; break;\n\t\t\t\tcase '-':left->num -= right->num; break;\n\t\t\t\tcase '*':left->num *= right->num; break;\n\t\t\t\t}\n\n\t\t\t\tif (!isvalid(left->num))throw - 1;\n\t\t\t\tgrams.erase(center);\n\t\t\t\tgrams.erase(right);\n\t\t\t\tcenter = left;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tStage stage;\n\tstage.action();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f1(int&, bool&);\n\nint f2(int&, bool&);\n\nint f3(int&, bool&);\n\nvector< int > undefined;\nstring S;\n\nbool isout(int val)\n{\n  return(val < 0 || val >= 1024);\n}\nint f1(int& idx, bool& f)\n{\n  int val = f2(idx, f);\n\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') {\n      ++idx;\n      val += f2(idx, f);\n    } else {\n      ++idx;\n      val -= f2(idx, f);\n    }\n    if(isout(val)) throw(1);\n    f = true;\n  }\n  return (val);\n}\n\nint f2(int& idx, bool& f)\n{\n  int val = f3(idx, f);\n\n  while(S[idx] == '*') {\n    idx++;\n    val *= f3(idx, f);\n    if(isout(val)) throw(1);\n    f = true;\n  }\n  return (val);\n}\n\nint f3(int& idx, bool& f)\n{\n  int val = 0;\n  if(S[idx] == '(') {\n    ++idx;\n    int now = idx;\n    bool flag = false;\n    val = f1(idx, flag);\n    if(!flag) throw(1);\n    ++idx;\n    return (val);\n  } else if(isdigit(S[idx])) {\n    while(isdigit(S[idx])) {\n      val = val * 2 + S[idx] - '0';\n      ++idx;\n      if(isout(val)) throw(1);\n    }\n  } else {\n    throw (1);\n  }\n  return (val);\n}\n\nint make(int idx)\n{\n  int ret = -1;\n  if(idx == undefined.size()) {\n    try {\n      int pos = 0;\n      bool f = false;\n      int val = f1(pos, f);\n      if(pos + 1 != S.size()) throw (1);\n\n      //cout << S << \" \" << val << endl;\n\n      ret = max(ret, val);\n    } catch(int e) {}\n  } else {\n    string s = \"01+-*()\";\n    for(char c : s) {\n      S[undefined[idx]] = c;\n      ret = max(ret, make(idx + 1));\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> S;\n  S += \"~\";\n  for(int i = 0; i < S.size(); i++) {\n    if(S[i] == '.') undefined.push_back(i);\n  }\n  cout << make(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n        }else{\n            res -= term(++pos);\n            if(res<0){\n                ppppp = 1;\n            }\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 9;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseVaule(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  if(find(temp, it, '+')==it && find(temp, it, '*')==it && find(temp, it, '-')==it ){\n    return false;\n  }\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseVaule(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseVaule(it, &rv)) return false;\n    *result *= rv;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(e.first<0||!e.second||s[x]!=')')return fail;\n    x++;\n    return make_pair(e.first,false);\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      if(n>=1<<10)return fail;\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(f.first<0)return f;\n  if(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(l.first<0)return l;\n    return make_pair(f.first*l.first,true);\n  }else{\n    return f;\n  }\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(f.first<0)return f;\n  if(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(l.first<0)return l;\n    return make_pair(f.first+sign*l.first,true);\n  }else{\n    return f;\n  }\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tm=max(m,dfs());\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring cs=\"01+-*()\";\nstring s;\nint n;\n\nint f(int l,int r){\n  bool isn=true;\n  repl(i,l,r)if(!isdigit(s[i]))isn=false;\n  if(isn){\n    int res=0;\n    repl(i,l,r){\n      res*=2;\n      res+=s[i]-'0';\n    }\n    if(res>=pow(2,10))return -1;\n    else return res;\n  }\n\n  bool ok=false;\n  {\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(lev==0)ok=true;\n      if(s[i]==')')lev--;\n    }\n  }\n\n  if(!ok){\n    if(s[r-1]!=')')return -1;\n    int lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1)return -1;\n        else return vl+vr;\n      }\n    }\n    lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1)return -1;\n        else return vl*vr;\n      }\n    }\n  }else{\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1)return -1;\n        else return vl+vr;\n      }\n    }\n    lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1)return -1;\n        else return vl*vr;\n      }\n    }\n  }\n  return -1;\n}\n\nint dfs(int i){\n  if(i==n){\n    return f(0,n);\n  }else{\n    if(s[i]=='.'){\n      int res=-1;\n      rep(j,7){\n        s[i]=cs[j];\n        int tmp=dfs(i+1);\n        maxch(res,tmp);\n      }\n      s[i]='.';\n      return res;\n    }else{\n      return dfs(i+1);\n    }\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <iostream>\n\nusing namespace std;\n\nint n, cl[5], cnum, num, p;\nchar str[101], cc[] = {\"01+-*()\"}, t[501];\n\nint eq(char c1,char c2,char c3,char c4){\n\treturn c1 == c3 && c2 == c4;\n}\n\nint calc(){\n\tint ret = 0, i, c;\n\tchar e = '+';\n\tfor(;p < num;p++){\n\t\tif(t[p] == '('){\n\t\t\tp++;\n\t\t\tc = calc();\n\t\t\tif(e == '+')\n\t\t\t\tret += c;\n\t\t\telse if(e == '-')\n\t\t\t\tret -= c;\n\t\t\telse if(e == '*')\n\t\t\t\tret *= c;\n\t\t}\n\t\telse if(isdigit(t[p])){\n\t\t\tc = 0;\n\t\t\tfor(i = p;isdigit(t[i]);i++) c = (c << 1) + t[i] - '0';\n\t\t\tp = i - 1;\n\t\t\tif(e == '+')\n\t\t\t\tret += c;\n\t\t\telse if(e == '-')\n\t\t\t\tret -= c;\n\t\t\telse if(e == '*')\n\t\t\t\tret *= c;\n\t\t}\n\t\telse if(t[p] == '+' || t[p] == '-' || t[p] == '*'){\n\t\t\te = t[p];\n\t\t}\n\t\telse if(t[p] == ')')\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n\nvoid priority(void){\n\tint i, j, k, c;\n\tnum = n;\n\tmemcpy(t,str,sizeof(str));\n\tfor(i = 0;i < num;i++){\n\t\tif(t[i] == '*'){\n\t\t\tc = 0;\n\t\t\tfor(j = i - 1;j > 0;j--){\n\t\t\t\tif(t[j] == ')') c++;\n\t\t\t\telse if(t[j] == '(') c--;\n\t\t\t\tif(c == 0 && !isdigit(t[j])) break;\n\t\t\t}\n\t\t\tif(j != 0) j--;\n\t\t\tfor(k = num;k >= j;k--) t[k + 1] = t[k];\n\t\t\tnum++,i++;\n\t\t\tt[j] = '(';\n\t\t\tc = 0;\n\t\t\tfor(j = i + 1;j < num;j++){\n\t\t\t\tif(t[j] == '(') c++;\n\t\t\t\telse if(t[j] == ')') c--;\n\t\t\t\tif(c == 0 && !isdigit(t[j])) break;\n\t\t\t}\n\t\t\tfor(k = num;k >= j;k--) t[k + 1] = t[k];\n\t\t\tnum++;\n\t\t\tt[j] = ')';\n\t\t}\n\t}\n}\n\t\t\t\t\n\n\nint judge(void){\n\tint i, j, k = 0, c;\n\tchar c1, c2;\n\n\t// 式が成り立たないもの\n\tfor(i = 0;i < n - 1;i++){\n\t\tc1 = str[i],c2 = str[i + 1];\n\t\tif(eq(c1,c2,'(','+') || eq(c1,c2,'(','-') || eq(c1,c2,'(','*') || eq(c1,c2,'+',')') || eq(c1,c2,'-',')') || eq(c1,c2,'*',')') || eq(c1,c2,'0','(') || eq(c1,c2,'1','(') || eq(c1,c2,')','0') || eq(c1,c2,')','1') || eq(c1,c2,'+','+') || eq(c1,c2,'-','-') || eq(c1,c2,'*','*') || eq(c1,c2,'+','-') || eq(c1,c2,'+','*') || eq(c1,c2,'-','+') || eq(c1,c2,'-','*') || eq(c1,c2,'*','+') || eq(c1,c2,'*','-') || eq(c1,c2,'(',')') || eq(c1,c2,')','('))\n\t\t\treturn 0;\n\t}\n\tif(str[0] == '+' || str[0] == '-' || str[0] == '*' || str[n - 1] == '+' || str[n - 1] == '-' || str[n - 1] == '*')\n\t\treturn 0;\n\t// 括弧の位置が誤っていないか\n\tc = 0;\n\tfor(i = 0;i < n;i++){\n\t\tif(str[i] == ')' && c == 0) return 0;\n\t\tif(str[i] == '(') c++;\n\t\telse if(str[i] == ')') c--;\n\t}\n\tif(c != 0) return 0;\n\n\t//括弧の中に式があるかどうか\n\tfor(i = 0;i < n;i++){\n\t\tif(str[i] == '('){\n\t\t\tc = 0, k = 1;\n\t\t\tfor(j = i;str[j] != ')' || c != 1;j++){\n\t\t\t\tif((str[j] == '+' || str[j] == '-' || str[j] == '*') && c == 1) k = 0; \n\t\t\t\tif(str[j] == ')') c--;\n\t\t\t\telse if(str[j] == '(') c++;\n\t\t\t}\n\t\t\tif(k) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint dfs(int c){\n\tint ret = 0x80000000,i, e;\n\tif(c == cnum){\n\t\tif(judge()){\n\t\t\tpriority();\n\t\t\tp = 0;\n\t\t\tret = max(ret,e = calc());\n//\t\t\tprintf(\"%s = %3d   \",str,e);\n//\t\t\tprintf(\"%s\\n\",t);\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(i = 0;i < 7;i++){\n\t\tstr[cl[c]] = cc[i];\n\t\tret = max(ret,dfs(c + 1));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint i = 0,ans;\n\tchar c;\n\twhile((c = getchar()) != '\\n')\n\t\tstr[i++] = c;\n\tstr[i] = '\\0';\n\tn = strlen(str);\n\tcnum = 0;\n\tfor(i = 0;i < n;i++)\n\t\tif(str[i] == '.') cl[cnum++] = i;\n\tans = dfs(0);\n\tprintf(\"%d\\n\",ans!=0x80000000?ans:-1);\n//\twhile(getchar() != 'E');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nchar rp[]={'0','1','+','-','*','(',')'};\n \nvector<string> check(vector<string> ss){\n    vector<string> ans;\n    for(string x:ss){\n        bool sw=true;\n        int c=0;\n        for(int i=0;i<x.size()&&sw;i++){\n            if(x[i]=='(')c++;\n            if(x[i]==')')c--;\n            if(c<0)sw=false;\n        }\n        if(!c){\n            ans.push_back(x);\n        }\n    }\n    return ans;\n}\n \nvector<string> rek(vector<string> ss){\n    vector<string> ans;\n    int t;\n    if(ss[0].find(\".\")!=string::npos){\n        bool sw=true;\n        for(int i=0;i<ss[0].size()&&sw;i++){\n            if(ss[0][i]=='.'){\n                t=i;\n                sw=false;\n            }\n        }\n        for(string s:ss){\n            for(int i=0;i<7;i++){\n                s[t]=rp[i];\n                ans.push_back(s);\n            }\n        }\n        ans=rek(ans);\n        return ans;\n    }\n    else{\n        return ss;\n    }\n}\n \nint ana(string s){\n    int c=0;\n    if(s.size()==0)return -1;\n    bool sw=false;\n    if(s[0]=='('){\n        for(int i=0;i<s.size()-1;i++){\n            if(s[i]=='(')c++;\n            if(s[i]==')')c--;\n            if(!c)sw=true;\n        }\n        if(!sw){\n            s=s.substr(1,s.size()-2);\n        }\n    }\n    int res;\n    c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n            if(!c&&s[i]=='*'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a*b;\n                return(res>=0&&res<1024?res:-1);\n            }\n    }\n    c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n        if(!c&&s[i]=='+'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a+b;\n            return(res>=0&&res<1024?res:-1);\n        }\n        if(!c&&s[i]=='-'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a-b;\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    res=stoi(s,nullptr,2);\n    return(res>=0&&res<1024?res:-1);\n}\n \n \nvoid solve(string s){\n    int ans=-1,anssub=0;\n    vector<string> ss;\n    ss.push_back(s);\n    ss=rek(ss);\n    ss=check(ss);\n    for(string x:ss){\n        anssub=ana(x);\n        if(anssub<1024&&anssub>=0)ans=max(ans,anssub);\n        //cout<<x<<\"  \"<<anssub<<endl;\n    }\n    cout<<ans<<endl;\n     \n     \n     \n}\n \nint main(){\n    string s;\n    cin>>s;\n    solve(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,bool> pib;\n\nstring str;\nconst char *ptr;\nint ans = -1;\nvector<int> dots;\n\n\npib expr();\npib term();\npib fact();\n\npib expr(){\n\tpib a = term();\n\n\twhile(true){\n\t\tif( *ptr == '+' ){\n\t\t\t++ptr;\n\t\t\t\n\t\t\tpib p = term();\n\t\t\ta.first += p.first;\n\t\t\tif( a.first > 1023 ) throw 1;\n\t\t\t\n\t\t\ta.second = true;\n\t\t}\n\t\telse if( *ptr == '-' ){\n\t\t\t++ptr;\n\t\t\t\n\t\t\tpib p = term();\n\t\t\ta.first -= p.first;\n\t\t\tif( a.first < 0 ) throw 2;\n\t\t\t\n\t\t\ta.second = true;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}\n\npib term(){\n\tpib a = fact();\n\twhile(*ptr == '*'){\n\t\t++ptr;\n\t\tpib p = fact();\n\t\ta.first *= p.first;\n\t\ta.second = true;\n\n\t\tif( a.first > 1023 ) throw 3;\n\t}\n\treturn a;\n}\n\npib fact(){\n\tif( *ptr == '(' ){\n\t\t++ptr;\n\t\tpib x = expr();\n\t\tif( *ptr++ != ')' ) throw 4;\n\t\tif( !x.second ) throw 5;\n\n\t\tx.second = false;\n\t\treturn x;\n\t}\n\t\n\tif( isdigit(*ptr) ){\n\t\tchar *endp;\n\t\tint x = strtol(ptr, &endp, 2);\n\t\tptr = endp;\n\n\t\tif( x < 0 || x > 1023 ) throw 6;\n\t\treturn make_pair(x, false);\n\t}\n\t\n\tthrow 7;\n}\n\n\nvoid func(int x){\n\tif( x == dots.size() ){\n\t\tptr = str.c_str();\n\t\t\n\t\ttry{\n\t\t\tint a = expr().first;\n\t\t\tif( *ptr == '\\0' && a < 1024 ) ans = max(ans, a);\n\t\t}\n\t\tcatch(int){}\n\t}\n\telse{\n\t\tfor(int i = 0; i < 7; ++i){\n\t\t\tstr[dots[x]] = \"01+-*()\"[i];\n\t\t\tfunc(x + 1);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> str;\n\tfor(int i = 0; i < str.size(); ++i){\n\t\tif( str[i] == '.' ) dots.push_back(i);\n\t}\n\t\n\tfunc(0);\n\t\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\npi expr(), term();\nstring s;\nint p;\npi digit(){\n\tint d = 0;\n\twhile(p < s.size() && isdigit(s[p])){\n\t\td *= 2; d += s[p++] - '0';\n\t\tif(d >= 1 << 10) throw \"bigdigit\";\n\t}\n\treturn mp(d, 0);\n}\npi expr(){\n\tpi a = term();\n\twhile(p < s.size() && (s[p] == '+' || s[p] == '-')){\n\t\tbool pr = s[p++] == '+';\n\t\tpi b = term();\n\t\ta.first = a.first + (pr ? b.first : -b.first);\n\t\ta.second = 1;\n\t\tif(a.first < 0 || a.first >= 1 << 10) throw \"overflow\";\n\t}\n\treturn a;\n}\npi term(){\n\tpi a = mp(1, 0);\n\tint fac = 0;\n\tp--;\n\tdo{\n\t\tif(++p >= s.size()) throw \"syntaxerorr\";\n\t\t\n\t\tpi b;\n\t\tif(isdigit(s[p])) b = digit();\n\t\telse if(s[p] == '('){\n\t\t\tp++;\n\t\t\tb = expr();\n\t\t\tif(!b.second) throw \"(())\";\n\t\t\tif(s[p++] != ')') throw \"closep\";\n\t\t}\n\t\telse throw \"syntaxerror\";\n\t\ta.first *= b.first;\n\t\tfac++;\n\t}while(p < s.size() && s[p] == '*');\n\treturn mp(a.first, fac > 1);\n}\n\nint main(){\n\tcin >> s;\n\tvi v;\n\trep(i, s.size()) if(s[i] == '.') v.pb(i);\n\tint pw[10], ans = -1;\n\tpw[0] = 1;\n\trep(i, 9) pw[i + 1] = pw[i] * 7;\n\t\n\trep(i, pw[v.size()]){\n\t\trep(j, v.size()) s[v[j]] = \"01+-*()\"[i / pw[j] % 7];\n\t\tp = 0;\n\t\ttry{\n\t\t\tpi res = expr();\n\t\t\tif(p < s.size()) throw \"syntaxerror\";\n\t\t\tans = max(ans, res.first);\n\t\t}catch(const char *e){\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nchar ln[7]={'0','1','+','-','*','(',')'};\nint n=0,ans=-1;\nint p[5]={};\nint ind[5]={};\nstring s,t;\nmap<int,int> mp;\n\nstring f(string a){\n  if(a==\"+\" || a==\"-\" || a==\"*\" || a==\"(\" || a==\")\")return a;\n  reverse(a.begin(),a.end());\n  int res=0;\n  for(int i=0;i<a.length();i++)res+=(pow(2,i)*(a[i]-'0'));\n  ostringstream os;\n  os<<res;\n  return os.str();\n}\n\nint cal(vector<string> v){\n  if(v.empty())return -1;\n  vector<string> vs1,vs2,vs3;\n  for(int i=0;i<v.size();i++){\n    if(v[i]==\"(\"){\n      vector<string> tmp;\n      for(int j=i+1;j<mp[i];j++)tmp.push_back(v[j]);\n      int res=cal(tmp);\n      if(res==-1 || 1024<=res)return -1;\n      ostringstream os;\n      os<<res;\n      vs1.push_back(os.str());\n      i=mp[i];\n    }\n    else vs1.push_back(v[i]);\n  }\n  if(vs1[0]==\"+\" || vs1[0]==\"*\" || vs1[0]==\"-\")return -1;\n  int size=vs1.size()-1;\n  if(vs1[size]==\"+\" || vs1[size]==\"*\" || vs1[size]==\"-\")return -1;\n  for(int i=0;i<vs1.size();i++){\n    if(vs1[i]==\"*\"){\n      if('0'<=vs1[i+1][0] && vs1[i+1][0]<='9' && '0'<=vs2.back()[0] && vs2.back()[0]<='9' ){\n\tint tmp1=atoi(vs2.back().c_str()),tmp2=atoi(vs1[i+1].c_str());\n\tvs2.pop_back();\n\tostringstream os;\n\tos<<(tmp1*tmp2);\n\tif(1024<=tmp1*tmp2)return -1;\n\tvs2.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs2.push_back(vs1[i]);\n  }\n  for(int i=0;i<vs2.size();i++){\n    if(vs2[i]==\"+\" || vs2[i]==\"-\"){\n      if('0'<=vs2[i+1][0] && vs2[i+1][0]<='9' && '0'<=vs3.back()[0] && vs3.back()[0]<='9' ){\n\tint tmp1=atoi(vs3.back().c_str()),tmp2=atoi(vs2[i+1].c_str());\n\tvs3.pop_back();\n\tostringstream os;\n\tint res;\n\tif(vs2[i]==\"+\")res=(tmp1+tmp2);\n\tif(vs2[i]==\"-\")res=(tmp1-tmp2);\n\tif(res<0 || 1024<=res)return -1;\n\tvs3.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs3.push_back(vs2[i]);\n  }\n  if(vs3.size()==1 && '0'<=vs3[0][0] && vs3[0][0]<='9')return atoi(vs3[0].c_str());\n  return -1;\n}\n\nvoid rec(int v){\n  if(v==n){\n    t=s;\n    for(int i=0;i<n;i++)t[ind[i]]=ln[p[i]];\n    string tmp=\"\";\n    vector<string> vs;\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='0' || t[i]=='1')tmp+=t[i];\n      else {\n\tif(tmp!=\"\")vs.push_back(tmp);\n\ttmp=\"\";\n\tstring st=\"\";\n\tst+=t[i];\n\tvs.push_back(st);\n      }\n    }\n    if(tmp!=\"\")vs.push_back(tmp);\n    stack<int> st;\n    mp.clear();\n    for(int i=0;i<vs.size();i++){\n      if(vs[i]==\"(\")st.push(i);\n      if(vs[i]==\")\"){\n        if(st.empty())return;\n        mp[st.top()]=i;\n        st.pop();\n      }\n    }\n    if(!st.empty())return;\n    for(int i=1;i<vs.size()-1;i++){\n      if((vs[i][0]=='0' || vs[i][0]=='1') && vs[i-1]==\"(\" && vs[i+1]==\")\")return;\n    }\n    for(int i=0;i<vs.size();i++)vs[i]=f(vs[i]);\n    int res=cal(vs);\n    ans=max(ans,res);\n  }\n  else {\n    for(int i=0;i<7;i++){\n      rec(v+1);\n      p[v]++;\n    }\n    p[v]=0;\n  }\n}\n\nint main()\n{\n  cin>>s;\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='.'){\n      ind[n]=i;\n      n++;\n    }\n  }\n  rec(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n\n  return true;\n}\n\nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n\n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n\n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true; \n  }\n  return false;\n}\n\nbool isvalid(string s){\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n\nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n\nint get(string s){\n  //  cout << \"S \" << s << endl;\n \n  if(isnum(s)) return tob(s);\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return get(s.substr(0,i))+get(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return get(s.substr(0,i))-get(s.substr(i+1));\n    }\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return get(s.substr(0,i))*get(s.substr(i+1));\n    }\n  }\n}\n\nvoid solve(int n){\n\n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n    if(isvalid(in)) ans = max(ans,get(in));\n    \n  }\n}\n\nint main(){\n\n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n\n  solve(0);\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2428.cc: Lost Number\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 5;\nconst int MIN_D = 0;\nconst int MAX_D = (1 << 10) - 1;\n\nconst int CN = 7;\nconst char chs[CN] = { '0', '1', '+', '-', '*', '(', ')' };\n\n/* typedef */\n\n/* global variables */\n\nint ps[MAX_N], cnts[MAX_N];\n\n/* subroutines */\n\nint num(string &s, int &pos);\nint coef(string &s, int &pos);\nint term(string &s, int &pos, bool &opf);\nint expr(string &s, int &pos, bool &opf);\n\nint num(string &s, int &pos) {\n  if (pos >= s.size() || (s[pos] != '0' && s[pos] != '1')) return -1;\n  int num = 0;\n  while (pos < s.size() && s[pos] >= '0' && s[pos] <= '1') {\n    num = 2 * num + s[pos++] - '0';\n    if (num > MAX_D) return -1;\n  }\n  return num;\n}\n\nint coef(string &s, int &pos) {\n  if (pos >= s.size()) return -1;\n\n  if (s[pos] == '(') {\n    pos++; // '('\n\n    bool ok = false;\n    for (int i = pos; i < s.size() && s[i] != ')'; i++)\n      if (s[i] != '0' && s[i] != '1') {\n\tok = true;\n\tbreak;\n      }\n    if (! ok) return -1;\n\n    bool opf = false;\n    int e = expr(s, pos, opf);\n    if (pos >= s.size() || s[pos] != ')' || ! opf) return -1;\n    pos++; // ')'\n    return e;\n  }\n\n  return num(s, pos);\n}\n\nint term(string &s, int &pos, bool &opf) {\n  if (pos >= s.size()) return -1;\n  int c0 = coef(s, pos);\n  if (c0 < 0) return -1;\n\n  while (pos < s.size() && s[pos] == '*') {\n    pos++; // '*'\n    int c1 = coef(s, pos);\n    opf = true;\n    if (c1 < 0) return -1;\n\n    c0 *= c1;\n    if (c0 < MIN_D || c1 > MAX_D) return -1;\n  }\n\n  return c0;\n}\n\nint expr(string &s, int &pos, bool &opf) {\n  if (pos >= s.size()) return -1;\n  int t0 = term(s, pos, opf);\n  if (t0 < 0) return -1;\n\n  while (pos < s.size() && (s[pos] == '+' || s[pos] == '-')) {\n    char opc = s[pos++]; // '+' || '-'\n    int t1 = term(s, pos, opf);\n    opf = true;\n    if (t1 < 0) return -1;\n\n    t0 = (opc == '+') ? t0 + t1 : t0 - t1;\n    if (t0 < MIN_D || t0 > MAX_D) return -1;\n  }\n\n  return t0;\n}\n\n/* main */\n\nint main() {\n  string s;\n  cin >> s;\n  int l = s.size();\n\n  int n = 0;\n  for (int i = 0; i < l; i++)\n    if (s[i] == '.') ps[n++] = i;\n  //printf(\"n=%d\\n\", n);\n\n  int maxd = -1;\n\n  for (;;) {\n    for (int i = 0; i < n; i++)\n      s[ps[i]] = chs[cnts[i]];\n    //cout << s << endl;\n\n    int pos = 0;\n    bool opf;\n    int d = expr(s, pos, opf);\n    if (pos == l && maxd < d) {\n      maxd = d;\n      //cout << s; printf(\" = %d\\n\", d);\n    }\n    \n    int k = 0;\n    while (k < n) {\n      if (++cnts[k] < CN) break;\n      cnts[k++] = 0;\n    }\n    if (k >= n) break;\n  }\n\n  printf(\"%d\\n\", maxd);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s, tmp, let = \"01+-*()\";\nvi v;\nint n, p, ans;\n\nbool range(int t)\n{\n\treturn t >= 0 && t < (1 << 10);\n}\n\nint num()\n{\n\tint res = 0;\n\twhile (p < n && isdigit(tmp[p]))\n\t{\n\t\tres *= 2;\n\t\tres += tmp[p] - '0';\n\t\tp++;\n\t}\n\tif (!range(res)) return -1;\n\treturn res;\n}\n\npair<int, bool> plu();\n\nint unit()\n{\n\tint res;\n\tif (tmp[p] == '(')\n\t{\n\t\tp++;\n\t\tauto a = plu();\n\t\tif (a.first == -1 || a.second == false || tmp[p] != ')') return -1;\n\t\tres = a.first;\n\t\tp++;\n\t}\n\telse \n\t{ \n\t\tif (!isdigit(tmp[p])) return -1;\n\t\tres = num();\n\t}\n\tif (!range(res)) return -1;\n\telse return res;\n}\n\npair<int, bool> mul()\n{\n\tbool f = false;\n\tint res = unit();\n\tif (res == -1) return make_pair(-1, f);\n\twhile (tmp[p] == '*')\n\t{\n\t\tf = true;\n\t\tp++;\n\t\tint rhs = unit();\n\t\tif (rhs == -1) return make_pair(-1, f);\n\t\tres *= rhs;\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\npair<int, bool> plu()\n{\n\tauto a = mul();\n\tint res = a.first;\n\tbool f = a.second;\n\tif (res == -1) return make_pair(-1, f);\n\twhile (tmp[p] == '+' || tmp[p] == '-')\n\t{\n\t\tf = true;\n\t\tif (tmp[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres += rhs;\n\t\t}\n\t\telse if (tmp[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres -= rhs;\n\t\t}\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\nint parse()\n{\n\tp = 0;\n\tint res = plu().first;\n\tif (p != tmp.size()) return -1;\n\telse return res;\n}\n\nbool check1()\n{\n\tbool res = true;\n\tREP(i, tmp.size()) if (!isdigit(tmp[i])) res = false;\n\treturn res;\n}\n\nbool check2()\n{\n\tbool res;\n\tstring elem; //0 = number, 1 = operator, 2 = '('\n\tREP(i, tmp.size())\n\t{\n\t\tif (isdigit(tmp[i]))\n\t\t{\n\t\t\twhile (isdigit(tmp[i])) i++;\n\t\t\ti--;\n\t\t\telem.push_back('0');\n\t\t}\n\t\telse if (tmp[i] == '+' || tmp[i] == '-' || tmp[i] == '*')\n\t\t{\n\t\t\telem.push_back('1');\n\t\t}\n\t\telse if (tmp[i] == '(') elem.push_back('(');\n\t\telse if (tmp[i] == ')') elem.push_back(')');\n\t\telse assert(false);\n\t}\n\tif (elem.size() > 2)\n\t{\n\t\tREP(i, elem.size() - 2)\n\t\t{\n\t\t\tif (elem[i] == '('&&elem[i + 1] == '0'&&elem[i + 2] == ')') return false;\n\t\t}\n\t}\n\tif (elem.size() > 1)\n\t{\n\t\tREP(i, elem.size() - 1)\n\t\t{\n\t\t\tif (elem[i] == '('&&elem[i + 1] == ')') return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\nvoid solve(int i, vi w)\n{\n\tif (i == v.size())\n\t{\n\t\ttmp = s;\n\t\tREP(i, v.size())\n\t\t{\n\t\t\ttmp[v[i]] = let[w[i]];\n\t\t}\n\t\tp = 0;\n\t\tif (check1())\n\t\t{\n\t\t\tint res = num();\n\t\t\tchmax(ans, res);\n\t\t}\n\t\telse if (check2())\n\t\t{\n\t\t\tint res = parse();\n\t\t\tchmax(ans, res);\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, 7)\n\t\t{\n\t\t\tvi tmp = w;\n\t\t\ttmp.push_back(j);\n\t\t\tsolve(i + 1, tmp);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tans = -1;\n\tcin >> s;\n\tn = s.size();\n\tREP(i, n)\n\t{\n\t\tif (s[i] == '.') v.push_back(i);\n\t}\n\tvi emp;\n\tsolve(0, emp);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    int N;\n    void input() {\n        cin >> s;\n        N = s.size();\n    }\n\n    int valid(int x) {\n        return 0 <= x && x < 1024;\n    }\n\n    int number(int& index) {\n        int x = 0;\n        while (isdigit(s[index])) {\n            int c = s[index] - '0';\n            x = x * 2 + c;\n            index++;\n        }\n        if (not valid(x)) return -1;\n        return x;\n    }\n    int oper(int x, int y, char op) {\n        int ret = 0;\n        if (op == '+') {\n            ret = x + y;\n        } else if (op == '-') {\n            ret = x - y;\n        } else if (op == '*') {\n            ret = x * y;\n        } else {\n            return -1;\n        }\n        if (not valid(ret)) return -1;\n        return ret;\n    }\n    int term(int& index, bool flag = false) {\n        if (index == N || not isdigit(s[index])) return -1;\n        int x = number(index);\n        if (index == N || (!flag && s[index] == ')')) return x;\n        if (not valid(x)) return -1;\n        char op = s[index];\n        if (op == '*') {\n            index++;\n            int y = term(index);\n            if (not valid(y)) return -1;\n            return oper(x, y, op);\n        } else {\n            return x;\n        }\n    }\n    int expr(int& index, bool flag = false) {\n        if (isdigit(s[index])) {\n            int i = index;\n            int p = number(i);\n            int x = term(index);\n            if (index == N || ((!flag || i != index) && s[index] == ')')) return x;\n            if (not valid(x)) return -1;\n            char op = s[index]; index++;\n            int y = expr(index);\n            if (not valid(y)) return -1;\n            /*\n            cout << \"x: \" << x << endl;\n            cout << \"y: \" << y << endl;\n            cout << \"op: \" << op << endl;\n            cout << \"res: \" << oper(x, y, op) << endl;\n            */\n            return oper(x, y, op);\n        }\n        if (s[index] == '(') {\n            index++;\n            int ret = expr(index, true);\n            if (s[index] != ')') return -1;\n            index++;\n            if (not valid(ret)) return -1;\n            return ret;\n        }\n        return -1;\n    }\n\n    int calc(int index) {\n        const string C = \"01+-*()\";\n        if (index == N) {\n            int i = 0;\n            //cout << s << \" -> \" << expr(i) << endl;\n            i = 0;\n            return expr(i);\n        }\n        if (s[index] == '.') {\n            int ret = -1;\n            for (int i = 0; i < C.size(); i++) {\n                s[index] = C[i];\n                ret = max(ret, calc(index + 1));\n            }\n            s[index] = '.';\n            return ret;\n        } else {\n            return calc(index + 1);\n        }\n    }\n\n    void solve() {\n        cout << calc(0) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\nconst int LIM = 1<<10;\n\nint number(Iterator &it, const Iterator &end) {\n    int res = 0;\n    while(it != end && isdigit(*it)) {\n        res *= 2;\n        res += *it - '0';\n        if(res >= LIM) throw \"overflow\";\n        ++it;\n    }\n    return res;\n}\n\npair<int,bool> expr(Iterator &it, const Iterator &end);\nint fact(Iterator &it, const Iterator &end) {\n    if(*it == '(') {\n        ++it;\n        const auto res = expr(it, end);\n        if(!res.second) {\n            throw \"no operator in paren\";\n        }\n        if(*it != ')') {\n            throw \"unmatched paren\";\n        }\n        ++it;\n        return res.first;\n    } else if(isdigit(*it)) {\n        return number(it, end);\n    } else {\n        throw \"paren or digit required\";\n    }\n}\n\npair<int,bool> term(Iterator &it, const Iterator &end) {\n    int lhs = fact(it, end);\n    bool op_seen = false;\n    while(it != end) {\n        char op = *it;\n        if(op != '*') break;\n        ++it;\n        const int rhs = fact(it, end);\n        lhs *= rhs;\n        op_seen = true;\n        if(lhs < 0 || lhs >= LIM) throw \"overflow\";\n    }\n    return make_pair(lhs, op_seen);\n}\n\npair<int,bool> expr(Iterator &it, const Iterator &end) {\n    auto lhs_ = term(it, end);\n    int lhs = lhs_.first;\n    bool op_seen = lhs_.second;\n    while(it != end) {\n        char op = *it;\n        if(op != '+' && op != '-') {\n            break;\n        }\n        ++it;\n        const auto rhs = term(it, end);\n        op_seen = op_seen || rhs.second;\n        switch(op) {\n            case '+':\n                lhs += rhs.first;\n                break;\n            case '-':\n                lhs -= rhs.first;\n                break;\n        }\n        op_seen = true;\n        if(lhs < 0 || lhs >= LIM) throw \"overflow\";\n    }\n    return make_pair(lhs, op_seen);\n}\n\nbool solve() {\n    string str;\n    if(!(cin >> str)) return false;\n\n    vector<int> dot_pos;\n    for(int i = 0; i < str.size(); ++i) {\n        if(str[i] == '.') dot_pos.push_back(i);\n    }\n    const string chars = \"01+-*()\";\n    int lim = 1;\n    for(int i = 0; i < dot_pos.size(); ++i) lim *= chars.size();\n    int ans = -1;\n    for(int pat = 0; pat < lim; ++pat) {\n        int tmp = pat;\n        string s = str;\n        for(int pos : dot_pos) {\n            s[pos] = chars[tmp % chars.size()];\n            tmp /= chars.size();\n        }\n        try {\n            Iterator it = s.begin();\n            const auto res = expr(it, s.end());\n            if(it != s.end()) {\n                throw \"premature end\";\n            }\n            //cout << s << ' ' << res.first << endl;\n            ans = max(ans, res.first);\n        } catch(const char *msg) {\n            //cout << s << ' ' << msg << endl;\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, char *> P;\n\nint ops[] = {'+', '-', '*'};\nint bs[] = {'(', ')'};\nint ds[] = {'0', '1'};\n\nP fact(char *p);\nP term(char *p);\nP expr(char *p);\n\nP fact(char *p){\n  if(isdigit(*p)){\n    int t = *(p++) - '0';\n    while(isdigit(*p)) t = t * 2 + *(p++) - '0';\n    return P(t, p);\n  } else if(*p == '('){\n    P r = expr(p + 1);\n    if(*r.second != ')') exit(0); //閉じ括弧が無いエラー\n    return P(r.first, r.second + 1);\n  } else{\n    exit(0); //括弧でも数字でもないエラー\n  }\n}\n\nP term(char *p){\n  P r = fact(p);\n  while(*r.second == '*' || *r.second == '/'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = fact(r.second + 1);\n    if(op == '*') r.first *= tmp;\n    else r.first /= tmp;\n  }\n  return r;\n}\n\nP expr(char *p){\n  P r = term(p);\n  while(*r.second == '+' || *r.second == '-'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = term(r.second + 1);\n    if(op == '+') r.first = tmp + r.first;\n    else r.first = tmp - r.first;\n  }\n  return r;\n}\n\nbool is_digit(string s){\n  if(s == \"0\" || s == \"1\") return true;\n  return false;\n}\n\nbool is_operation(string s){\n  if(s == \"+\" || s == \"-\" || s == \"*\") return true;\n  return false;\n}\n\nbool is_number(string s){\n  if(is_digit(s) || ((int)s.length() >= 2 && is_number(s.substr(0, (int)s.length() - 1)) && is_digit(s.substr(s.length() - 1)))) return true;\n  return false;\n}\n\nbool check(string s){\n  int cnt = 0;\n  REP(i, s.length()){\n    if(s[i] == '(') ++cnt;\n    if(s[i] == ')') --cnt;\n    if(cnt < 0) return false;\n  }\n  return cnt == 0;\n}\n\nbool is_expression(string s);\n\nbool is_inner_expression(string s){\n  //cout <<\"inner_exp \" <<s <<endl;\n  FOR(i, 1, (int)s.length() - 1){\n    //cout <<\"left \" <<s.substr(0, i) <<\", right \" <<s.substr(i + 1) <<endl;\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nbool is_expression(string s){\n  //cout <<\"exp \" <<s <<endl;\n  if((int)s.length() >= 2 && s[0] == '(' && s[(int)s.length() - 1] == ')' && check(s.substr(1, (int)s.length() - 2))){\n    bool res = is_inner_expression(s.substr(1, (int)s.length() - 2));\n    //cout <<(res ? \"true\" : \"false\") <<endl;\n    return res;\n  }\n  if(is_number(s)){\n    //cout <<\"true\" <<endl;\n    return true;\n  }\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nbool is_invalid(char *s){\n  int sl = strlen(s);\n  FOR(i, 1, sl - 1){ \n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(s[i - 1] != '.' && s[i - 1] != ')' && !isdigit(s[i - 1])) return true;\n      if(s[i + 1] != '.' && s[i + 1] != '(' && !isdigit(s[i + 1])) return true;\n    }\n    if(s[i] == ')'){\n      if(s[i - 1] != '.' && !isdigit(s[i - 1]) && s[i - 1] != ')') return true;\n      if(s[i + 1] != '.' && s[i + 1] != ')' && s[i + 1] != '+' && s[i + 1] != '-' && s[i + 1] != '*') return true;\n    }\n    if(s[i] == '('){\n      if(s[i + 1] != '.' && !isdigit(s[i + 1]) && s[i + 1] != '(') return true;\n      if(s[i - 1] != '.' && s[i - 1] != '(' && s[i - 1] != '+' && s[i - 1] != '-' && s[i - 1] != '*') return true;\n    }\n  }\n  return false;\n}\n\nint solve(int cnt, vector<int> &v, char *s){\n  if(is_invalid(s)) return -1;\n  if(cnt >= (int)v.size()){\n    if(!is_expression(s)) return -1;\n    int res = expr(s).first;\n    return res >= 0 && res < 1024 ? res : -1;\n  }\n  if(is_invalid(s)) return -1;\n  int res = -1, sl = strlen(s);\n  if(v[cnt] != 0 && v[cnt] != sl - 1){\n    REP(i, 3){ \n      s[v[cnt]] = ops[i];\n      res = max(res, solve(cnt + 1, v, s));\n      s[v[cnt]] = '.';\n    }\n  }\n  REP(i, 2){\n    s[v[cnt]] = bs[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  REP(i, 2){\n    s[v[cnt]] = ds[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  return res;\n}\n\nint main() {\n  char s[110];\n  cin >>s;\n  int sl = strlen(s);\n  vector<int> v;\n  REP(i, sl) if(s[i] == '.') v.push_back(i);\n  cout <<solve(0, v, s) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nint formula(int, int);\nstring s;\nvector<int> idx;\n\nint binary_to_int(const string& binary) {\n\tint res = 0, x = 1, n = binary.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(binary[n - 1 - i] == '1')\n\t\t\tres += x;\n\n\t\telse if(binary[n - 1 - i] != '0')\n\t\t\treturn -1;\n\n\t\tx <<= 1;\n\t}\n\n\treturn res;\n}\n\nint factor(int l, int r) {\n\tif(l >= r)\n\t\treturn -1;\n\n\tif(s[l] == '(' && s[r - 1] == ')') {\n\t\tfor(int i = l + 1; i < r - 1; ++i)\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\treturn formula(l + 1, r - 1);\n\t}\n\n\treturn binary_to_int(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && s[i] == '*') {\n\t\t\tint vl = term(l, i), vr = factor(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\treturn vl * vr;\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\tint vl = formula(l, i), vr = term(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn vl + vr;\n\n\t\t\telse\n\t\t\t\treturn vl - vr;\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nint dfs(int d = 0) {\n\tif(d == idx.size()) {\n\t\tconst int res = formula(0, s.size());\n\t\treturn res >= 1024 ? -1 : res;\n\t}\n\n\tint res = -1;\n\tstatic const char c[7] = {'0', '1', '*', '+', '-', '(', ')'};\n\tfor(int i = 0; i < 7; ++i) {\n\t\ts[idx[d]] = c[i];\n\t\tchmax(res, dfs(d + 1));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tidx.push_back(i);\n\n\tcout << dfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nchar s[110];\nint n;\nint dd[5];\nchar u[] = \"01+-*()\";\nbool err;\nint ec;\n\nint expr(char **begin);\n\nvoid erce(int i) {\n    err |= (i  < 0 || 1024 <= i);\n}\n\nint numb(char **begin) {\n    int r = 0;\n    if (!isdigit(**begin)) err = true;\n    while (isdigit(**begin)) {\n        r *= 2;\n        r += **begin - '0';\n        *begin += 1;\n    }\n    erce(r);\n    return r;\n}\n\nint fact(char **begin) {\n    if (**begin == '(') {\n        *begin += 1;\n        int ec2 = ec;\n        int r = expr(begin);\n        if (ec2 == ec) err = true;\n        if (**begin != ')') err = true;\n        *begin += 1;\n        erce(r);\n        return r;\n    } else {\n        return numb(begin);\n    }\n}\n\nint term(char **begin) {\n    int r = fact(begin);\n    while (true) {\n        if (**begin == '*') {\n            ec++;\n            *begin += 1;\n            r *= fact(begin);\n            erce(r);\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\nint expr(char **begin) {\n    int r = term(begin);\n    while (true) {\n        if (**begin == '+') {\n            ec++;\n            *begin += 1;\n            r += term(begin);\n            erce(r);\n        } else if (**begin == '-') {\n            ec++;\n            *begin += 1;\n            r -= term(begin);\n            erce(r);\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\n\nint main() {\n    string ss;\n    cin >> ss;\n    n = ss.size();\n    int cc = 1;\n    int c = 0;\n    for (int i = 0; i < n; i++) {\n        s[i] = ss[i];\n        if (s[i] == '.') {\n            dd[c] = i;\n            c++;\n            cc *= 7;\n        }\n    }\n    s[n] = '$';\n    int res = -1;\n    for (int i = 0; i < cc; i++) {\n        int ii = i;\n        for (int j = 0; j < c; j++) {\n            s[dd[j]] = u[ii%7];\n            ii /= 7;\n        }\n        err = false;\n        ec = 0;\n        char *p = s;\n        int r = expr(&p);\n        if (*p != '$') err = true; \n        if (!err) res = max(res, r);\n        //printf(\"%5s %d %d %d\\n\", s, ec, r, err);\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n#define int long long \n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res -= term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }\n    }\n    if(res<0||res>=1024){\n        ppppp = 1;\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    if(ans>=1024)ppppp=1;\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nsigned main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nclass ParseError {};\nstruct Result{\n  int value, p, ex;\n  Result(int v, int p) : value(v), p(p), ex(0) {}\n};\nvoid skip(const string& s, Result& r, char expected){\n  if(!(0 <= r.p && r.p < s.size())){\n    throw ParseError();\n  }else if(s[r.p] != expected){\n    throw ParseError();\n  }else {\n    r.p ++;\n  }\n}\nvoid checkvalue(int x){\n  if(x < 0 || x >= 1<<10) throw ParseError();\n}\nResult equation(const string& s, int p);\nResult equation_in(const string& s, int p);\nResult factor(const string& s, int p);\nResult term(const string& s, int p);\nResult equation(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (s[r.p] == '+' || s[r.p] == '-')){\n    Result r2 = factor(s, r.p + 1);\n    if(s[r.p] == '+'){\n      r.value += r2.value;\n    }else if(s[r.p] == '-'){\n      r.value -= r2.value;\n    }\n    r.p = r2.p;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult equation_in(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (s[r.p] == '+' || s[r.p] == '-')){\n    Result r2 = factor(s, r.p + 1);\n    if(s[r.p] == '+'){\n      r.value += r2.value;\n    }else if(s[r.p] == '-'){\n      r.value -= r2.value;\n    }\n    r.p = r2.p;\n    r.ex = 1;\n    checkvalue(r.value);\n  }\n  if(r.ex == 0) throw ParseError();\n  return r;\n}\nResult factor(const string& s, int p){\n  Result r = term(s, p);\n  while(r.p < s.size() && s[r.p] == '*'){\n    Result r2 = term(s, r.p + 1);\n    r.value *= r2.value;\n    r.p = r2.p;\n    r.ex = 1;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  if(s[p] == '('){\n    Result r = equation_in(s, p + 1);\n    skip(s, r, ')');\n    checkvalue(r.value);\n    return r;\n  }else if(isdigit(s[p])){\n    int value = 0;\n    while(isdigit(s[p]) && p < s.size()){\n      value = (value << 1) + (s[p++] - '0');\n    }\n    checkvalue(value);\n    return Result(value, p);\n  }else {\n    throw ParseError();\n  }\n}\nstring SYMBOLS = \"01+-*()\";\nint dfs(int k, vector<int>& index, string& s){\n  if(k == index.size()){\n    try{\n      Result r = equation(s, 0);\n      if(r.p != s.size()) throw ParseError();\n      //cout<<s<<\" is \"<<r.value<<endl;\n      return r.value;\n    }catch(...){\n      //cout<<s<<\" is invalid.\"<<endl;\n      return -1;\n    }\n  }else{\n    int res = -INF;\n    REP(i, SYMBOLS.size()){\n      s[index[k]] = SYMBOLS[i];\n      res = max(res, dfs(k + 1, index, s));\n    }\n    return res;\n  }\n}\n\nint main(){\n  string s;\n  while(cin>>s){\n    vector<int> index;\n    REP(i, s.size()) if(s[i] == '.') index.push_back(i);\n    int ans = dfs(0, index, s);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nbool h;\nint out=-1;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*2+*(i++)-'0';\n\treturn out;\n}\nint valid(string s){\n\tint n=s.size();\n\tvi co(100);\n\tint cnt=0;\n\trep(t,s.size()){\n\t\tif(s[t]=='('){\n\t\t\tcnt++;\n\t\t\tco[cnt]=0;\n\t\t}else if(s[t]==')'){\n\t\t\tif(!co[cnt])return 0;\n\t\t\tcnt--;\n\t\t\tif(cnt<0)return 0;\n\t\t}else if(s[t]=='+'||s[t]=='-'||s[t]=='*'){\n\t\t\tco[cnt]++;\n\t\t\tif(t==0||t==n-1)return 0;\n\t\t\tif(!isdigit(s[t-1])&&s[t-1]!=')'||!isdigit(s[t+1])&&s[t+1]!='(')return 0;\n\t\t}\n\t}\n\treturn !cnt;\n}\nstring w=\"01+-*()\";\nstring s;\nvoid dfs(){\n\trep(i,s.size())if(s[i]=='.'){\n\t\trep(j,w.size()){\n\t\t\ts[i]=w[j];\n\t\t\tdfs();\n\t\t\ts[i]='.';\n\t\t}\n\t\treturn;\n\t}\n\tif(!valid(s))return;\n\tState begin=s.begin();\n\th=true;\n\tint a=expr(begin);\n\tif(h)out=max(out,a);\n}\nint main(){\n\tcin>>s;\n\tdfs();\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\n \nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\n \nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n \n  return true;\n}\n \nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n \n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n \n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true;\n  }\n  return false;\n}\n \nbool parapos(string s){\n  int p = 0;\n \n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n  }\n  return p == 0;\n}\n \nbool isvalid(string s){\n \n  if(!parapos(s)) return false;\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n \nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n \nint get(string s){\n  //  cout << \"S \" << s << endl;\n  \n  if(isnum(s)) return tob(s);\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return get(s.substr(0,i))+get(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return get(s.substr(0,i))-get(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return get(s.substr(0,i))*get(s.substr(i+1));\n    }\n  }\n}\n \nvoid solve(int n){\n \n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n\n    if(isvalid(in)){\n      int num = get(in);\n      if(0 <= num && num < 1024) ans = max(ans,num);\n    }\n  }\n}\n \nint main(){\n \n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n \n  solve(0);\n \n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, char *> P;\n\nint ops[] = {'+', '-', '*'};\nint bs[] = {'(', ')'};\nint ds[] = {'0', '1'};\n\nP fact(char *p);\nP term(char *p);\nP expr(char *p);\n\nP fact(char *p){\n  if(isdigit(*p)){\n    int t = *(p++) - '0';\n    while(isdigit(*p)) t = t * 2 + *(p++) - '0';\n    return P(t, p);\n  } else if(*p == '('){\n    P r = expr(p + 1);\n    if(*r.second != ')') exit(0); //閉じ括弧が無いエラー\n    return P(r.first, r.second + 1);\n  } else{\n    exit(0); //括弧でも数字でもないエラー\n  }\n}\n\nP term(char *p){\n  P r = fact(p);\n  while(*r.second == '*' || *r.second == '/'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = fact(r.second + 1);\n    if(op == '*') r.first *= tmp;\n    else r.first /= tmp;\n  }\n  return r;\n}\n\nP expr(char *p){\n  P r = term(p);\n  while(*r.second == '+' || *r.second == '-'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = term(r.second + 1);\n    if(op == '+') r.first = tmp + r.first;\n    else r.first = tmp - r.first;\n  }\n  return r;\n}\n\nbool is_digit(string s){\n  if(s == \"0\" || s == \"1\") return true;\n  return false;\n}\n\nbool is_operation(string s){\n  if(s == \"+\" || s == \"-\" || s == \"*\") return true;\n  return false;\n}\n\nbool is_number(string s){\n  if(is_digit(s) || ((int)s.length() >= 2 && is_number(s.substr(0, (int)s.length() - 1)) && is_digit(s.substr(s.length() - 1)))) return true;\n  return false;\n}\n\nbool check(string s){\n  int cnt = 0;\n  REP(i, s.length()){\n    if(s[i] == '(') ++cnt;\n    if(s[i] == ')') --cnt;\n    if(cnt < 0) return false;\n  }\n  return cnt == 0;\n}\n\nbool is_expression(string s);\n\nbool is_inner_expression(string s){\n  //cout <<\"inner_exp \" <<s <<endl;\n  FOR(i, 1, (int)s.length() - 1){\n    //cout <<\"left \" <<s.substr(0, i) <<\", right \" <<s.substr(i + 1) <<endl;\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nbool is_expression(string s){\n  //cout <<\"exp \" <<s <<endl;\n  if((int)s.length() >= 2 && s[0] == '(' && s[(int)s.length() - 1] == ')' && check(s.substr(1, (int)s.length() - 2))){\n    bool res = is_inner_expression(s.substr(1, (int)s.length() - 2));\n    //cout <<(res ? \"true\" : \"false\") <<endl;\n    return res;\n  }\n  if(is_number(s)){\n    //cout <<\"true\" <<endl;\n    return true;\n  }\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nint solve(int cnt, vector<int> &v, char *s){\n  //cout <<s <<endl;\n  if(cnt >= (int)v.size()){\n    //cout <<\"! \" <<s <<\", \" <<is_expression(s) <<endl;\n    if(!is_expression(s)) return -1;\n    int res = expr(s).first;\n    return res >= 0 && res < 1024 ? res : -1;\n  }\n  int res = -1, sl = strlen(s);\n  REP(i, 3){\n    if(v[cnt] != 0 && v[cnt] != sl - 1 && isdigit(s[v[cnt] - 1]) && isdigit(s[v[cnt] + 1])){\n      s[v[cnt]] = ops[i];\n      res = max(res, solve(cnt + 1, v, s));\n      s[v[cnt]] = '.';\n    }\n  }\n  REP(i, 2){\n    s[v[cnt]] = bs[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  REP(i, 2){\n    s[v[cnt]] = ds[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  return res;\n}\n\nint main() {\n  char s[110];\n  cin >>s;\n  int sl = strlen(s);\n  vector<int> v;\n  REP(i, sl) if(s[i] == '.') v.push_back(i);\n  cout <<solve(0, v, s) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint len;\nchar s[101];\n\nint idx;\n\nint number(){\n\tint res=0;\n\twhile(idx<len && (s[idx]=='0' || s[idx]=='1')){\n\t\tres=(res<<1)+(s[idx]-'0');\n\t\tidx++;\n\t}\n\tif(res<0 || 1024<=res) return -1;\n\treturn res;\n}\n\nint expr(){\n\tvector<int> nums;\n\tvector<char> ops;\n\twhile(1){\n\t\tif(s[idx]=='0' || s[idx]=='1'){\n\t\t\tint a=number();\n\t\t\tif(a==-1) return -1;\n\t\t\tnums.push_back(a);\n\t\t}\n\t\telse if(s[idx]=='('){\n\t\t\t// ( ) の中にはネストしてない演算子が必要\n\t\t\tbool ok=false;\n\t\t\tint dep=0;\n\t\t\tfor(int i=idx+1;i<len;i++){\n\t\t\t\tif(dep<0) break;\n\t\t\t\tif     (s[i]=='(') dep++;\n\t\t\t\telse if(s[i]==')') dep--;\n\t\t\t\tif(dep==0){\n\t\t\t\t\tif(s[i]=='+' || s[i]=='-' || s[i]=='*') ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) return -1;\n\n\t\t\tidx++;\n\t\t\tint a=expr();\n\t\t\tif(a==-1 || idx==len || s[idx]!=')') return -1;\n\t\t\tnums.push_back(a);\n\t\t\tidx++;\n\t\t}\n\t\telse return -1;\n\n\t\tif(idx<len && (s[idx]=='+' || s[idx]=='-' || s[idx]=='*')) ops.push_back(s[idx++]);\n\t\telse break;\n\t}\n\n\t// 掛け算を先にやる\n\twhile(1){\n\t\tint i=find(ops.begin(),ops.end(),'*')-ops.begin();\n\t\tif(i==ops.size()) break;\n\t\tnums[i]*=nums[i+1];\n\t\tnums.erase(nums.begin()+i+1);\n\t\tops.erase(ops.begin()+i);\n\t\tif(nums[i]<0 || 1024<=nums[i]) return -1;\n\t}\n\t// 足し算と引き算をやる\n\tint res=nums[0];\n\trep(i,ops.size()){\n\t\tif     (ops[i]=='+'){ res+=nums[i+1]; if(res<0 || 1024<=res) return -1; }\n\t\telse if(ops[i]=='-'){ res-=nums[i+1]; if(res<0 || 1024<=res) return -1; }\n\t}\n\treturn res;\n}\n\nint gao(int i,const vector<int> &pos){\n\tif(i==pos.size()){\n\t\tidx=0;\n\t\treturn expr();\n\t}\n\n\tint res=-1;\n\trep(j,7){\n\t\ts[pos[i]]=\"01+-*()\"[j];\n\t\tres=max(res,gao(i+1,pos));\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%s\",s);\n\tlen=strlen(s);\n\n\tvector<int> pos;\n\trep(i,len) if(s[i]=='.') pos.push_back(i);\n\n\tprintf(\"%d\\n\",gao(0,pos));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nbool h;\nint out=-1;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t\tif(out1<0||out1>=1024)h=false;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t\tif(out1<0||out1>=1024)h=false;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*2+*(i++)-'0';\n\treturn out;\n}\nint valid(string s){\n\tint n=s.size();\n\tvi co(100);\n\tint cnt=0;\n\trep(t,s.size()){\n\t\tif(s[t]=='('){\n\t\t\tcnt++;\n\t\t\tco[cnt]=0;\n\t\t}else if(s[t]==')'){\n\t\t\tif(!co[cnt])return 0;\n\t\t\tcnt--;\n\t\t\tif(cnt<0)return 0;\n\t\t}else if(s[t]=='+'||s[t]=='-'||s[t]=='*'){\n\t\t\tco[cnt]++;\n\t\t\tif(t==0||t==n-1)return 0;\n\t\t\tif(!isdigit(s[t-1])||!isdigit(s[t+1]))return 0;\n\t\t}\n\t}\n\treturn !cnt;\n}\nstring w=\"01+-*()\";\nstring s;\nvoid dfs(){\n\trep(i,s.size())if(s[i]=='.'){\n\t\trep(j,w.size()){\n\t\t\ts[i]=w[j];\n\t\t\tdfs();\n\t\t\ts[i]='.';\n\t\t}\n\t\treturn;\n\t}\n\tif(!valid(s))return;\n\tState begin=s.begin();\n\th=true;\n\tint a=expr(begin);\n\tif(h)out=max(out,a);\n}\nint main(){\n\tcin>>s;\n\tdfs();\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  while(*it=='0') ++it;\n\n  *result = 0;\n  int max_length = 10;\n  int length = 0;\n  while(true){\n    if(it+length==end || (*(it+length)!='0' && *(it+length)!='1')) break;\n    *result += (*(it+length) - '0') << (max_length-length);\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length + 1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  \n  unsigned long long lv = *result;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    lv *= rv;\n    if(lv >= 1024) return false;\n  }\n  *result = lv;\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  \n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 9999999\n\n\nvector<string> toRPN(string s){\n    stack<string> ope;\n    vector<string> ret;\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ){\n            string tmp=\"\";\n            for(int j=i;j<len;j++){\n                if( isdigit(s[j]) )tmp+=s[j];\n                else break;\n            }\n            ret.push_back(tmp);\n            i+=tmp.size()-1;\n            \n        }else{\n            if( s[i]=='(' )ope.push(\"(\");\n            \n            else if( s[i]==')' ){\n                if( ope.empty() )return {\"invalid\"};\n                if( ope.top()==\"(\" )return {\"invalid\"};\n                \n                while( ope.top()!=\"(\" ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                    \n                    if( ope.empty() )return {\"invalid\"};\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" || ope.top()==\"+\" || ope.top()==\"-\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n            }\n        }\n    }\n    while( ope.size() ){\n        ret.push_back( ope.top() );\n        ope.pop();\n    }\n    \n    return ret;\n}\n\n\nint toDeci(string s){\n    int ret=0;\n    for(int i=0;i<s.size();i++){\n        if( s[ s.size()-i-1 ]=='1' ){\n            ret+=1<<i;\n        }\n        if(ret>=1024)return 9999;\n    }\n    return ret;\n}\n\n\n\nint solveRPN(vector<string> s){\n    stack<int> stk;\n    \n    \n    for(int i=0;i<s.size();i++){\n        if( (s[i]!=\"+\" && s[i]!=\"-\" && s[i]!=\"*\" && s[i]!=\"/\") )stk.push( toDeci(s[i])  );\n        else{\n            if(stk.size()<2)return -1;\n\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            if(s[i]==\"+\")stk.push(a+b);\n            if(s[i]==\"-\")stk.push(a-b);\n            if(s[i]==\"*\")stk.push(a*b);\n            if(s[i]==\"/\")stk.push(a/b);\n        }\n        if( stk.top() <0 || 1024<=stk.top() )return -1;\n    }\n    \n    if( stk.size()>1 )return -1;\n    return stk.top();\n}\n\n\nvi dot;\nint maxi=-INF;\n\n\nint solve(string s){\n    vector<string> poland=toRPN(s);\n    \n    if(poland[0]==\"invalid\")return -INF;\n    \n    int result=solveRPN(poland);\n    \n    if(result==-1)return -INF;\n    else return result;\n}\n\n\nvoid dfs(string s,int flor){\n    if(flor>=dot.size()){\n        maxi=max( maxi , solve(s) );\n        return ;\n    }\n    \n    char ch[]={'0','1','+','-','(',')'};\n    rep(i,6){\n        s[ dot[flor] ] = ch[i];\n        dfs(s,flor+1);\n        s[ dot[flor] ] = '.';\n    }\n}\n\n\nint main(){\n    string s;\n    cin>>s;\n    \n    rep(i,s.size()) if(s[i]=='.')dot.pb(i);\n    \n    dfs(s,0);\n    \n    if( maxi==-INF )cout<<\"-1\"<<endl;\n    else cout<<maxi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc();\nint expr();\nint number();\nstring tmp;\nint pos;\nchar c[]=\"()+-*01\";\nint ans=-1;\nbool f=0,ff;\nint calc(){\n  int res=expr();\n  while(1){\n    if(tmp[pos]=='+') {pos++;res+=expr();}\n    else if(tmp[pos]=='-') {pos++;res-=expr();}\n    else break;\n    if(res<0||res>=(1<<10)) ff=0;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint expr(){\n  int res=number();\n  while(1){\n    if(tmp[pos]=='*') {pos++;res*=number();}\n    else break;\n    if(res<0||res>=(1<<10)) ff=0;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint number(){\n  int res=0;\n  if(tmp[pos]=='(') {\n    pos++;res=calc();pos++;\n  }else{\n    while(pos<(int)tmp.size()&&isdigit(tmp[pos])) {\n      res=res*2+tmp[pos]-'0';\n      pos++;\n      if(res<0||res>=(1<<10)) ff=0;\n    }\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\n \nbool check(string s){\n  int o=0;\n  bool op[100]={};\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') {\n      o++;\n      op[o]=1;\n      if(i+1>=(int)s.size()) return 0;\n      if(!isdigit(s[i+1])&&s[i+1]!='(') return 0;\n    }    \n    if(s[i]==')') {\n      if(op[o]) return 0;\n      o--;\n      if(i-1<0) return 0;\n      if(!isdigit(s[i-1])&&s[i-1]!=')') return 0;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*') {\n      op[o]=0;\n      if(i-1<0||i+1>=(int)s.size()) return 0;\n      if((!isdigit(s[i-1])&&s[i-1]!=')')||(!isdigit(s[i+1])&&s[i+1]!='(')) return 0;\n    }\n    if(o<0) return 0;\n  }\n  if(o) return 0;\n  return 1;\n}\nvoid rec(string s){\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]!='.') continue;\n    for(int j=0;j<8;j++){\n      s[i]=c[j];\n      rec(s);\n    }\n    return;\n  }\n  if(!check(s)) return;\n  tmp=s;pos=0;ff=1;\n  int k=calc();\n  //cout<<k<<\":\"<<tmp<<endl;\n  if(pos==(int)tmp.size()&&ff) ans=max(ans,k);\n}\nint main(){\n  string s;\n  cin>>s;\n  rec(s);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\ntypedef string::const_iterator State;\nint number(State&);\npair<int,bool> factor(State&);\npair<int,bool> term(State&);\npair<int,bool> expression(State&);\n\nbool invalid;\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\tif(not isdigit(*begin)){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 2;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\npair<int,bool> factor(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tpair<int,bool> ret = expression(begin);\n\t\tif(not ret.second) {\n\t\t\tinvalid = true;\n\t\t}\n\t\tbegin++; // ')'を飛ばす。\n\t\tret.second = 0;\n\t\treturn ret;\n\t} else {\n\t\treturn make_pair(number(begin), 0);\n\t}\n\treturn make_pair(0, 0);\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\npair<int,bool> term(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first *= factor(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\npair<int,bool> expression(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first += term(begin).first;\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first -= term(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n//beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\t//throw ParseError();\n\t}\n}\n\nconst string c = \"01+-*()\";\n\nbool check(string& s){\n\tint cnt = 0;\n\tbool op = false, st = false;\n\tshow(s)\n\trep(i,s.size()){\n\t\tcout << i << endl;\n\t\tif(s[i] == '('){\n\t\t\tif(st) return false;\n\t\t\tcnt++;\n\t\t\top = true;\n\t\t}else if(s[i] == ')'){\n\t\t\tif(op or st) return false;\n\t\t\tcnt--;\n\t\t\top = false;\n\t\t\tst = true;\n\t\t}else if(s[i] == '+' or s[i] == '-'){\n\t\t\top = false;\n\t\t\tst = false;\n\t\t}\n\t}\n\tshow(cnt)\n\treturn cnt == 0;\n}\n\nint dfs(string s, int i){\n\tif(i == s.size()){\n\t\t//if(not check(s)) return -1e5;\n\n\t\tinvalid = false;\n\t\tState tmp = s.begin();\n\n\t\tpair<int,bool> ans = expression(tmp);\n\t\tif(tmp != s.end()) return -1e5;\n\t\t//cout << ans << ' ' << s << endl;\n\t\treturn invalid ? -1e5 : ans.first;\n\t}\n\n\twhile(s[i] != '.' and i < s.size()){\n\t\ti++;\n\t}\n\n\tif(s[i] == '.'){\n\t\tint res = -1e5;\n\t\trep(j,c.size()){\n\t\t\ts[i] = c[j];\n\t\t\tres = max(res, dfs(s, i));\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn dfs(s, i);\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\n\tcout << dfs(s, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\npii expr(const string& s,int i);\n\npii fact(const string& s,int i)\n{\n\t//dump(mp(__func__,i));\n\tconst int n=s.size();\n\tif(i==n) throw \"fact: out of range\";\n\tif(s[i]=='('){\n\t\tint x,j; tie(x,j)=expr(s,++i);\n\t\tint c=0,ok=false;\n\t\trepi(k,i,j){\n\t\t\tif(s[k]=='(') c++;\n\t\t\tif(s[k]==')') c--;\n\t\t\tif(c==0 && strchr(\"+-*\",s[k])) ok=true;\n\t\t}\n\t\tif(!ok) throw \"fact: '(' number ')' is invalid\";\n\t\treturn mp(x,j+1);\n\t}\n\tif(!isdigit(s[i])) throw \"fact: invalid char\";\n\tint x=0;\n\tfor(;i<n && isdigit(s[i]);i++){\n\t\t(x<<=1)+=s[i]-'0';\n\t\tif(x<0 || 1024<=x) throw \"fact: overflow\";\n\t}\n\treturn mp(x,i);\n}\n\npii term(const string& s,int i)\n{\n\t//dump(mp(__func__,i));\n\tconst int n=s.size();\n\tif(i==n) throw \"term: out of range\";\n\tint x; tie(x,i)=fact(s,i);\n\twhile(i<n && strchr(\"*\",s[i])){\n\t\tchar op=s[i++];\n\t\tint y; tie(y,i)=fact(s,i);\n\t\tx*=y;\n\t\tif(x<0 || 1024<=x) throw \"term: overflow\";\n\t}\n\treturn mp(x,i);\n}\n\npii expr(const string& s,int i)\n{\n\t//dump(mp(__func__,i));\n\tconst int n=s.size();\n\tif(i==n) throw \"expr: out of range\";\n\tint x; tie(x,i)=term(s,i);\n\twhile(i<n && strchr(\"+-\",s[i])){\n\t\tchar op=s[i++];\n\t\tint y; tie(y,i)=term(s,i);\n\t\tif(op=='+') x+=y;\n\t\telse        x-=y;\n\t\tif(x<0 || 1024<=x) throw \"expr: overflow\";\n\t}\n\treturn mp(x,i);\n}\n\nint main()\n{\n\tfor(string s;cin>>s && s!=\"#\";){\n\t\tvi ds;\n\t\trep(i,s.size()) if(s[i]=='.') ds.push_back(i);\n\t\t\n\t\tint pat=1;\n\t\trep(i,ds.size()) pat*=7;\n\t\t\n\t\tint res=-1;\n\t\trep(i,pat){\n\t\t\tfor(int j=0,k=i;j<ds.size();j++,k/=7)\n\t\t\t\ts[ds[j]]=\"01+-*()\"[k%7];\n\t\t\ttry{\n\t\t\t\tint x,i; tie(x,i)=expr(s,0);\n\t\t\t\tif(i==s.size()){\n\t\t\t\t\tres=max(res,x);\n\t\t\t\t\t//cout<<s<<\": \"<<x<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(const char* msg){\n\t\t\t\t//dump(msg);\n\t\t\t\t//cout<<s<<\": \"<<msg<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstdlib>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\nbool deb;\n\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\n  bool safe,mul;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n    safe = mul = false;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      safe = true;\n      int p = expression();\n      safe = false;\n      mul = false;\n      //cout << \"in fact, p = \" << p << endl;\n      pos++;\n      return p;\n    }else{\n      int ru = 0;\n      string p; p.clear();\n      \n      while('0' <= parse[pos] && parse[pos] <= '1'){\n\tp += parse[pos];\n\tpos++;\n      }\n      reverse(p.begin(),p.end());\n      int ip = 0;\n      bool ook = false;\n      for(int i=0;i<p.length();i++){\n\tif(p[i] == '1'){\n\t  ip += pow((double)2,(double)ru);\n\t}\n\took = true;\n\tru++;\n      }\n      if(!ook)ip = -1;\n      //cout << \"in fact, ip = \" << ip << endl;\n      return ip;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p < 0 || p >=1024){\n      //cout << \"error! in term, limit over error\" << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tmul = true;\n\tint fac= fact();\n       \n\tif(fac < 0 || fac >= 1024){\n\t  //cout << \"error! in term(while *), BNF error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n\tp *= fac;\n\t//cout << \"in term(while *), fact =  \" << fac << endl;\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(p < 0 || p >= 1024){\n      //cout << \"error! in expression, limit over error\" << endl;\n      deb = true;\n      return -1;\n    }\n    if(!(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*' || pos == parse.length() || (safe && mul && parse[pos] == ')'))){\n      //cout << \"error! in expression, not operator. parse[pos] = \" << parse[pos] << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tp+=term();\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else if(parse[pos] == '-'){\n\tpos++;\n\tp-=term();\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, limit over error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else {\n\t//cout << \"error! in expression, not operator Ver2.\" << endl;\n\t//assert(true);\n\tdeb = true;\n\treturn -1;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\n\nint Fans;\nchar perm[5] = {'0','1','+','-','*'};\nvoid all_permutation(string s){\n\n  for(int i=0;i<s.length();i++){\n    if(s[i] == '.'){\n      for(int j=0;j<5;j++){\n\tstring pre = s;\n\ts[i] = perm[j];\n\tall_permutation(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      deb = false;\n      //cout << \"s = \" << s << endl;\n      Parsing par = Parsing(s);\n      int ans = par.expression();\n      //cout <<\"ans = \" << ans  << \",deb = \" << deb << \",true =\" << true<< endl;\n      if(!deb) Fans = max(Fans,ans); \n    }\n  }\n\n}\n\nint main(){\n  string s;\n  while(cin >> s){\n  Fans = -1;\n \n  all_permutation(s);\n  cout << Fans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nclass SyntaxAnalysis\n{\npublic:\n    using T = pair<bool, int>;\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '*';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '(';\n    static T plus(const T& n, const T& k) { return {n.first and k.first and prop(n.second + k.second), n.second + k.second}; }\n    static T minus(const T& n, const T& k) { return {n.first and k.first and prop(n.second - k.second), n.second - k.second}; }\n    static T product(const T& n, const T& k) { return {n.first and k.first and prop(n.second * k.second), n.second * k.second}; }\n    static T divide(const T& n, const T& k) { return n; }\n    static T brace(const T& n) { return n; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '1'; }\n    static int encode(const char c) { return c - '0'; }\n    static bool prop(const int l) { return l >= 0 and l < (1 << 10); }\n    T number()\n    {\n        int ans = 0, start = S.size();\n        for (; pos < S.size() and is_digit(S[pos]); pos++) {\n            if (S[pos] == '1') { start = min(start, pos); }\n            ans = ans * 2 + encode(S[pos]);\n        }\n        return {pos - start <= 10, ans};\n    }\n    T factor()\n    {\n        if (S[pos] == BRACE) {\n            T ans;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    T term()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, f = factor(), ans = product(ans, f);\n            } else if (S[pos] == DIVIDE) {\n                pos++, f = factor(), ans = divide(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    T expression()\n    {\n        T ans = term();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = term(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = term(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\ntemplate <typename S, typename T>\ninline ostream& operator<<(ostream& os, const pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\n\nint main()\n{\n    constexpr char C[7] = {'0', '1', '+', '-', '*', '(', ')'};\n    string s;\n    cin >> s;\n    vector<int> p;\n    int NUM = 1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '.') { p.push_back(i), NUM *= 7; }\n    }\n    const int sz = p.size();\n    int ans = -1;\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0, num = i; j < sz; j++, num /= 7) { s[p[j]] = C[num % 7]; }\n        stack<int> st;\n        st.push(0);\n        bool ok = true, num = false;\n        for (const char c : s) {\n            if (c == '(') {\n                if (num) {\n                    ok = false;\n                    break;\n                }\n                st.push(0);\n            } else if (c == ')') {\n                if (st.size() <= 1 or st.top() == 0 or not num) {\n                    ok = false;\n                    break;\n                }\n                num = true;\n                st.pop();\n            } else if (c == '+' or c == '-' or c == '*') {\n                if (not num) {\n                    ok = false;\n                    break;\n                }\n                num = false;\n                const int n = st.top() + 1;\n                st.pop(), st.push(n);\n            } else {\n                num = true;\n            }\n        }\n        if (not ok or st.size() != 1 or not num) { continue; }\n        const auto sub = SyntaxAnalysis{s}.Expression();\n        // show(s);\n        // show(sub);\n        if (sub.first) { ans = max(ans, sub.second); }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <valarray>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)n; ++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\nconst char ZERO = '0';\nconst char ONE = '1';\nconst int MAX_VAL = (1<<10) - 1;\nconst int MIN_VAL = 0;\n\ninline bool isOp(char c) {\n  return c == '*' || c == '-' || c == '+';\n}\n\ntypedef pair<int, int> value;\nconst value ERROR = make_pair(-1,-1);\n\nvalue mult_exp(const string &s,int idx=0);\nvalue number(const string &s,int idx =0);\nvalue prim_exp(const string &s,int idx=0);\n\nvalue add_exp(const string &s,int idx) {\n  if(s[idx] != ONE && s[idx] != ZERO && s[idx] != '(') return ERROR;\n  value left = mult_exp(s, idx);\n  idx = left.second;\n  int v = left.first;\n  while(true) {\n    if (idx < s.length() && (s[idx] == '+' || s[idx] == '-')) {\n      char op = s[idx];\n      value right = mult_exp(s,idx+1);\n      if (right == ERROR) return ERROR;\n      switch(op) {\n      case '+':\n\tv += right.first;\n\tbreak;\n      case '-':\n\tv -= right.first;\n\tbreak;\n      }\n      if (v < MIN_VAL || v > MAX_VAL) return ERROR;\n      idx = right.second;\n    }else break;\n  }\n  return make_pair(v, idx);\n}\n\nvalue mult_exp(const string &s,int idx) {\n  if(s[idx] != ONE && s[idx] != ZERO && s[idx] != '(') return ERROR;\n\n  value left = prim_exp(s,idx);\n  if (left == ERROR) return ERROR;\n  idx = left.second;\n  int v = left.first;\n  while(true) {\n    if (idx < s.length() && s[idx] == '*') {\n      value right = prim_exp(s, idx+1);\n      if (right == ERROR) return ERROR;\n      v *= right.first;\n      if (v < MIN_VAL || v > MAX_VAL) return ERROR;\n      idx = right.second;\n    } else break;\n  }\n\n  return make_pair(v, idx);\n}\n\nvalue prim_exp (const string &s, int idx) {\n  if (s[idx] == ONE || s[idx] == ZERO) return number(s,idx);\n  if (s[idx] != '(') return ERROR;\n  value v = add_exp(s, idx+1);\n  if (v.second >= s.length() || s[v.second] != ')' || v == ERROR) return ERROR;\n  if (v.first < MIN_VAL || v.second > MAX_VAL) return ERROR;\n\n  bool onlynum = true;\n  for (int i=idx+1; i<v.second; ++i) {\n    if(s[i] != ONE && s[i] != ZERO) onlynum = false;\n  }\n  if(onlynum) return ERROR;\n  return make_pair(v.first, v.second+1);\n}\n\nvalue number(const string &s, int idx) {\n  if (s[idx] != ONE && s[idx] != ZERO) return ERROR;\n  int ret = 0;\n  while(s[idx] == ONE || s[idx] == ZERO) {\n    ret <<= 1;\n    ret += s[idx] - ZERO;\n    if (ret < MIN_VAL || ret > MAX_VAL) return ERROR;\n    idx++;\n    if(idx == s.length()) break;\n  }\n  //cout<<\"number:\"<<ret<<endl;\n  if (ret < MIN_VAL || ret > MAX_VAL) return ERROR;\n  return make_pair(ret, idx);\n}\n\nchar letter[7] = {'0', '1', '+', '-', '*', '(', ')'};\n\nbool check(const string &in) {\n  bool ok = true;\n  for (int i=0; i<in.length(); ++i) {\n    if(in[i] != '(') continue;\n    int depth = 1, nop = 0;\n    for (int j=i+1; j<in.length(); ++j) {\n      if(in[j] == '(') depth++;\n      if(in[j] == ')') depth--;\n      if(depth == 0) break;\n      if(depth == 1 && (in[j] == '+' || in[j] == '-' || in[j] == '*')) {\n\tnop++;\n      }\n    }\n    if(nop == 0) ok = false;\n  }\n  return ok;\n}\n\nint main() {\n  string input;\n  cin>>input;\n  char cnt = '2';\n  for (int i=0; i<input.length(); ++i) {\n    if (input[i] == '.') input[i] = cnt++;\n  }\n\n  int num = cnt - '2';\n\n  if(num == 0) {\n    value v = add_exp(input, 0);\n    if(v == ERROR\n       || !check(input)\n       || v.second != input.length()) cout<<-1<<endl;\n    else cout<<v.first<<endl;\n    return 0;\n  }\n\n  vector<int> pattern(num, 0);\n  int ans = -1;\n  while(true) {\n    string in = input;\n    for (int i=0; i<in.length(); ++i) {\n      if(in[i] >= '2' && in[i] <= '9') in[i] = letter[pattern[in[i]-'2']];\n    }\n\n    value v = add_exp(in,0);\n    if(v != ERROR && v.second == in.length() && check(in)) {\n        //if(ans < v.first) cout<<in<<endl;\n      ans = max(ans, v.first);\n    }\n\n    bool end = true;\n    for (int i=0; i<num; ++i)\n      if(pattern[i] != 6) end = false;\n    if(end) break;\n\n    for (int i=0; i<num; ++i) {\n      if(pattern[i] == 6) pattern[i] = 0;\n      else {\n\tpattern[i]++;\n\tbreak;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\n\t\tif (val >= 1024)return -1;\n\t\tif (val < 0)return -1;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t\tif (val >= 1024)return - 1;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num])){\n\t\tn = n * 2 + s[num++] - '0';\n\t\tif (n >= 1024)return -1;\n\t}\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tbool op = false;\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t\tif (sc.top() == '0')op = true;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t\t\tif (!op)return;\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*'){\n\t\t\t\tif (sc.empty() || sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\tsc.push('0');\n\t\t\t}\n\t\t\tif (s[i] == '1' || s[i] == '0' )\n\t\t\t\tsc.push('1');\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.empty()||sc.top() == '1'){\n\t\t\tans = expr(s, num);\n\t\t\tma = max(ma, ans);\n\t\t}\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    int N;\n    void input() {\n        cin >> s;\n        N = s.size();\n    }\n\n    int valid(int x) {\n        return 0 <= x && x < 1024;\n    }\n\n    int number(int& index) {\n        int x = 0;\n        while (isdigit(s[index])) {\n            int c = s[index] - '0';\n            x = x * 2 + c;\n            index++;\n        }\n        if (not valid(x)) return -1;\n        return x;\n    }\n    int oper(int x, int y, char op) {\n        int ret = 0;\n        if (op == '+') {\n            ret = x + y;\n        } else if (op == '-') {\n            ret = x - y;\n        } else if (op == '*') {\n            ret = x * y;\n        } else {\n            return -1;\n        }\n        if (not valid(ret)) return -1;\n        return ret;\n    }\n    int term(int& index, bool flag = false) {\n        if (index == N || not isdigit(s[index])) return -1;\n        int x = number(index);\n        if (index == N || (!flag && s[index] == ')')) return x;\n        if (not valid(x)) return -1;\n        char op = s[index];\n        if (op == '*') {\n            index++;\n            int y = term(index);\n            if (not valid(y)) return -1;\n            return oper(x, y, op);\n        } else {\n            return x;\n        }\n    }\n    int expr(int& index, bool flag = false) {\n        if (isdigit(s[index])) {\n            int x = term(index);\n            if (index == N || (!flag && s[index] == ')')) return x;\n            if (not valid(x)) return -1;\n            char op = s[index]; index++;\n            int y = expr(index);\n            if (not valid(y)) return -1;\n            /*\n            cout << \"x: \" << x << endl;\n            cout << \"y: \" << y << endl;\n            cout << \"op: \" << op << endl;\n            cout << \"res: \" << oper(x, y, op) << endl;\n            */\n            return oper(x, y, op);\n        }\n        if (s[index] == '(') {\n            index++;\n            int ret = expr(index, true);\n            if (s[index] != ')') return -1;\n            index++;\n            if (not valid(ret)) return -1;\n            return ret;\n        }\n        return -1;\n    }\n\n    int calc(int index) {\n        const string C = \"01+-*()\";\n        if (index == N) {\n            int i = 0;\n            //cout << s << \" -> \" << expr(i) << endl;\n            i = 0;\n            return expr(i);\n        }\n        if (s[index] == '.') {\n            int ret = -1;\n            for (int i = 0; i < C.size(); i++) {\n                s[index] = C[i];\n                ret = max(ret, calc(index + 1));\n            }\n            s[index] = '.';\n            return ret;\n        } else {\n            return calc(index + 1);\n        }\n    }\n\n    void solve() {\n        cout << calc(0) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool err;\n\nvoid valid(int n)\n{\n\tif (n<0 || 1023<n)\n\t\terr = true;\n}\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\tvalid(res);\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else if (isdigit(s[p])) {\n\t\treturn number(s);\n\t} else {\n\t\terr = true;\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\tvalid(ret);\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\twhile (s[p] == '+' || s[p] == '-') {\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += expression(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= expression(s);\n\t\t}\n\t}\n\t\n\tvalid(res);\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\tvalid(res);\n\treturn res;\n}\n\nbool check(string s)\n{\n\tvector<int> ope;\n\t\n\tif (s[N-1]=='+' || s[N-1]=='-' || s[N-1]=='*' || s[N-1]=='(')\n\t\treturn false;\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tope.push_back(0);\n\t\t} else if (s[i]==')') {\n\t\t\tif (d<0 || !ope[d]) return false;\n\t\t\tope.erase(ope.begin()+d);\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), 0);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>=1024) res=-1;\n\t\t\n\t\t//cerr << \"Persing : \" << s << endl;\n\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tconst int kind = 7;\n\tStage(){\n\t}\n\t\n\tvoid action(){\n\t\tstring text;\n\t\tcin >> text;\n\n\t\tint res = -1;\n\t\tREP(transWay, pow(kind, count_dot(text))) {\n\t\t\tstring transedText = trans(transWay, text);\n\t\t\tif (transWay == 265) {\n\t\t\t\tint a;\n\t\t\t\ta = 5;\n\t\t\t}\n\t\t\tlist<char> ls;\n\t\t\tfor (char c : transedText)ls.push_back(c);\n\t\t\tauto grams = trans_gram(ls);\n\t\t\tint score = read(grams);\n\n\t\t\tres = max(res, score);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tchar data;\n\t\tint num;\n\t};\n\t\n\tint count_dot(const string& text) {\n\t\tint res = 0;\n\t\tfor (char c : text)if (c == '.')res++;\n\t\treturn res;\n\t}\n\tstring trans(int n, string text) {\n\t\tfor (char& c : text)if (c == '.') {\n\t\t\tswitch (n % kind) {\n\t\t\tcase 0:c = '0'; break;\n\t\t\tcase 1:c = '1'; break;\n\t\t\tcase 2:c = '+'; break;\n\t\t\tcase 3:c = '-'; break;\n\t\t\tcase 4:c = '*'; break;\n\t\t\tcase 5:c = '('; break;\n\t\t\tcase 6:c = ')'; break;\n\t\t\t}\n\t\t\tn /= kind;\n\t\t}\n\t\treturn text;\n\t}\n\n\tlist<Gram> trans_gram(const list<char>& ls) {\n\t\tlist<Gram> grams;\n\t\tfor (auto itr = ls.begin(); itr != ls.end(); ++itr) {\n\t\t\tGram gram;\n\t\t\tswitch (*itr) {\n\t\t\tcase '+':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '+';\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '-';\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '*';\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = ')';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgram.kind = 'n';\n\t\t\t\tgram.data = '.';\n\t\t\t\tgram.num = 0;\n\t\t\t\tdo {\n\t\t\t\t\tgram.num *= 2;\n\t\t\t\t\tgram.num += *itr - '0';\n\t\t\t\t\t++itr;\n\t\t\t\t} while (itr != ls.end() && isdigit(*itr));\n\t\t\t\t--itr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tint read(list<Gram> grams){\n\t\ttry {\n\t\t\t// ( , ) delete\n\t\t\tfor (auto right = grams.begin(); right != grams.end(); ++right)\n\t\t\t{\n\t\t\t\tif (right->data == ')') {\n\t\t\t\t\tlist<Gram> subset;\n\t\t\t\t\tauto left = right;\n\n\t\t\t\t\t//move: (expression)\n\t\t\t\t\twhile (left != grams.begin() && left->data != '(') --left;\n\t\t\t\t\tif (left->data != '(')throw - 1;\n\t\t\t\t\t++right;\n\t\t\t\t\tsubset.splice(subset.begin(), move(grams), left, right);\n\n\t\t\t\t\t// delete: ( , )\n\t\t\t\t\tsubset.pop_front();\n\t\t\t\t\tsubset.pop_back();\n\n\t\t\t\t\tif (subset.size() == 1)throw - 1;\n\n\t\t\t\t\tint res = read(subset);\n\t\t\t\t\tif (res < 0)throw - 1;\n\t\t\t\t\tif (1024 <= res)throw - 1;\n\n\t\t\t\t\tGram gram;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = res;\n\t\t\t\t\tgrams.insert(right, gram);\n\t\t\t\t\tright = grams.begin();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperator_erase(grams, '*');\n\t\t\toperator_erase(grams, '+', '-');\n\t\t\tif (grams.size() != 1) {\n\t\t\t\t//cerr << \"size is too much\" << endl;\n\t\t\t\tthrow - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint res = grams.front().num;\n\t\t\t\tif (res < 0 || 1024 <= res)return -1;\n\t\t\t\telse return res;\n\t\t\t}\n\t\t}\n\t\tcatch (...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbool isnumber(const list<char>& ls){\n\t\tfor (char c : ls) {\n\t\t\tif (c < '0' || '9' < c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isoperator(const char& c) {\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tlist<char> n2b(int num) {\n\t\tlist<char> b;\n\t\twhile (num > 0) {\n\t\t\tint tmp = num % 2;\n\t\t\tnum /= 2;\n\t\t\tb.push_front(tmp + '0');\n\t\t}\n\t\treturn b;\n\t}\n\n\tint b2n(const list<char>& ls) {\n\t\tint res = 0;\n\t\tfor (char c: ls) {\n\t\t\tres *= 2;\n\t\t\tres += c - '0';\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid operator_erase(\n\t\tlist<Gram>& grams,\n\t\tconst char& ope1,\n\t\tconst char& ope2 = 'i'\n\t){\n\t\tfor (auto center = grams.begin(); center != grams.end(); ++center) {\n\t\t\tif (center->data == ope1 || (ope2 != 'i' && center->data == ope2)) {\n\t\t\t\tauto left = center; if (distance(grams.begin(), left) == 0)break; left--;\n\t\t\t\tauto right = center; if (distance(right, grams.end()) == 1)break; right++;\n\n\t\t\t\tswitch (center->data) {\n\t\t\t\tcase '+':left->num += right->num; break;\n\t\t\t\tcase '-':left->num -= right->num; break;\n\t\t\t\tcase '*':left->num *= right->num; break;\n\t\t\t\t}\n\n\t\t\t\tif (left->num < 0 || 1024 <= left->num)throw - 1;\n\t\t\t\tgrams.erase(center);\n\t\t\t\tgrams.erase(right);\n\t\t\t\tcenter = left;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tStage stage;\n\tstage.action();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 63;\n  unsigned long long sum_bin = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(it+length==end || *(it+length)!='0' && *(it+length)!='1') break;\n    sum_bin += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  sum_bin >>= max_length-length+1;\n  if(sum_bin >= 1024) return false;\n  \n  *result = sum_bin;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  \n  unsigned long long lv = *result;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    lv *= rv;\n    if(lv >= 1024) return false;\n  }\n  *result = lv;\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  \n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2428.cc: Lost Number\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 5;\nconst int MIN_D = 0;\nconst int MAX_D = (1 << 10) - 1;\n\nconst int CN = 7;\nconst char chs[CN] = { '0', '1', '+', '-', '*', '(', ')' };\n\n/* typedef */\n\n/* global variables */\n\nint ps[MAX_N], cnts[MAX_N];\n\n/* subroutines */\n\nint num(string &s, int &pos);\nint coef(string &s, int &pos);\nint term(string &s, int &pos);\nint expr(string &s, int &pos);\n\nint num(string &s, int &pos) {\n  if (pos >= s.size() || (s[pos] != '0' && s[pos] != '1')) return -1;\n  int num = 0;\n  while (pos < s.size() && s[pos] >= '0' && s[pos] <= '1') {\n    num = 2 * num + s[pos++] - '0';\n    if (num > MAX_D) return -1;\n  }\n  return num;\n}\n\nint coef(string &s, int &pos) {\n  if (pos >= s.size()) return -1;\n\n  if (s[pos] == '(') {\n    pos++; // '('\n\n    bool ok = false;\n    for (int i = pos; i < s.size() && s[i] != ')'; i++)\n      if (s[i] != '0' && s[i] != '1') {\n\tok = true;\n\tbreak;\n      }\n    if (! ok) return -1;\n\n    int e = expr(s, pos);\n    if (pos >= s.size() || s[pos] != ')') return -1;\n    pos++; // ')'\n    return e;\n  }\n\n  return num(s, pos);\n}\n\nint term(string &s, int &pos) {\n  if (pos >= s.size()) return -1;\n  int c0 = coef(s, pos);\n  if (c0 < 0) return -1;\n\n  while (pos < s.size() && s[pos] == '*') {\n    pos++; // '*'\n    int c1 = coef(s, pos);\n    if (c1 < 0) return -1;\n\n    c0 *= c1;\n    if (c0 < MIN_D || c1 > MAX_D) return -1;\n  }\n\n  return c0;\n}\n\nint expr(string &s, int &pos) {\n  if (pos >= s.size()) return -1;\n  int t0 = term(s, pos);\n  if (t0 < 0) return -1;\n\n  while (pos < s.size() && (s[pos] == '+' || s[pos] == '-')) {\n    char op = s[pos++]; // '+' || '-'\n    int t1 = term(s, pos);\n    if (t1 < 0) return -1;\n\n    t0 = (op == '+') ? t0 + t1 : t0 - t1;\n    if (t0 < MIN_D || t0 > MAX_D) return -1;\n  }\n\n  return t0;\n}\n\n/* main */\n\nint main() {\n  string s;\n  cin >> s;\n  int l = s.size();\n\n  int n = 0;\n  for (int i = 0; i < l; i++)\n    if (s[i] == '.') ps[n++] = i;\n  //printf(\"n=%d\\n\", n);\n\n  int maxd = -1;\n\n  for (;;) {\n    for (int i = 0; i < n; i++)\n      s[ps[i]] = chs[cnts[i]];\n    //cout << s << endl;\n\n    int pos = 0;\n    int d = expr(s, pos);\n    if (pos == l && maxd < d) maxd = d;\n    \n    int k = 0;\n    while (k < n) {\n      if (++cnts[k] < CN) break;\n      cnts[k++] = 0;\n    }\n    if (k >= n) break;\n  }\n\n  printf(\"%d\\n\", maxd);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\ntypedef string::const_iterator State;\nint number(State&);\npair<int,bool> factor(State&);\npair<int,bool> term(State&);\npair<int,bool> expression(State&);\n\nbool invalid;\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\tif(not isdigit(*begin)){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 2;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\tif(ret >= 1024){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\npair<int,bool> factor(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tpair<int,bool> ret = expression(begin);\n\t\tif(not ret.second) {\n\t\t\tinvalid = true;\n\t\t}\n\t\tbegin++; // ')'を飛ばす。\n\t\tret.second = 0;\n\t\treturn ret;\n\t} else {\n\t\treturn make_pair(number(begin), 0);\n\t}\n\treturn make_pair(0, 0);\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\npair<int,bool> term(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first *= factor(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\npair<int,bool> expression(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first += term(begin).first;\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first -= term(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nconst string c = \"01+-*()\";\n\nint dfs(string s, int i){\n\tif(i == s.size()){\n\t\tinvalid = false;\n\t\tState tmp = s.begin();\n\n\t\tpair<int,bool> ans = expression(tmp);\n\t\tif(ans.first >= 1024 or ans.first < 0 or tmp != s.end()) return -1e5;\n\t\treturn invalid ? -1e5 : ans.first;\n\t}\n\n\twhile(s[i] != '.' and i < s.size()){\n\t\ti++;\n\t}\n\n\tif(s[i] == '.'){\n\t\tint res = -1e5;\n\t\trep(j,c.size()){\n\t\t\ts[i] = c[j];\n\t\t\tres = max(res, dfs(s, i));\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn dfs(s, i);\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\n\tint ans = dfs(s, 0);\n\tcout << (ans == -1e5 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*')return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' <= parse[pos] && parse[pos] <= '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool is_num(char x){return x=='0' || x=='1';}\n\nbool valid_num(int x){\n  const int SUP=1024;\n  return 0<=x && x<SUP;\n}\n\nint calc(int lhs,int rhs,char op){\n  int res;\n  if(op=='+'){\n    res=lhs+rhs;\n  }else if(op=='-'){\n    res=lhs-rhs;\n  }else if(op=='*'){\n    res=lhs*rhs;\n  }else{\n    throw -1;\n  }\n  if(!valid_num(res)) throw -1;\n  return res;\n}\n\nint formula(int &p);\nint formulap(int &p);\nint term1(int &p);\npair<int,bool> term1p(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint formula(int &p){\n  int res=term1(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='|') throw -1;\n    int rhs=term1(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\nint formulap(int &p){\n  bool isok=false;\n  auto ret=term1p(p);\n  isok|=ret.second;\n  int res=ret.first;\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw -1;\n    int rhs=term1(p);\n    return res;\n  }\n  if(!isok) throw -1;\n  return res;\n}\n\nint term1(int& p){\n  int res=term2(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='*') throw -1;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\npair<int,bool> term1p(int &p){\n  int res=term2(p);\n  bool isop=false;\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='*') throw -1;\n    isop=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,isop};\n}\n\nint term2(int& p){\n  if(s[p]=='('){\n    p++;\n    int res=formulap(p);\n    if(s[p]!=')') throw -1;\n    p++;\n    return res;\n  }else if(is_num(s[p])){\n    int res=get_num(p);\n    return res;\n  }else throw -1;\n}\n\nint get_num(int& p){\n  int res=0;\n  while(p<s.size() && is_num(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nint dfs(int i){\n  if(i==s.size()){\n    int res;\n    try{\n      int p=0;\n      res=formula(p);\n    }catch(const int &e){\n      res=-1;\n    }\n    return res;\n  }\n  else if(s[i]=='.'){\n    const string ch=\"01+-*()\";\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      int ret=dfs(i+1);\n      res=max(ret,res);\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(e.first<0||!e.second||s[x]!=')')return fail;\n    x++;\n    return make_pair(e.first,false);\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      if(n>=1<<10)return fail;\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(f.first<0)return f;\n  while(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(l.first<0)return l;\n    f.first+=l.first;\n    f.second=true;\n  }\n  return f;\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(f.first<0)return f;\n  while(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(l.first<0)return l;\n    f.first+=sign*l.first;\n    f.second=true;\n  }\n  return f;\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tm=max(m,dfs());\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, char *> P;\n\nint ops[] = {'+', '-', '*'};\nint bs[] = {'(', ')'};\nint ds[] = {'0', '1'};\nbool f;\n\nP fact(char *p);\nP term(char *p);\nP expr(char *p);\n\nP fact(char *p){\n  if(isdigit(*p)){\n    int t = *(p++) - '0';\n    while(isdigit(*p)) t = t * 2 + *(p++) - '0';\n    if(t < 0 || t >= 1024) f = false;\n    return P(t, p);\n  } else if(*p == '('){\n    P r = expr(p + 1);\n    if(*r.second != ')') exit(0); //閉じ括弧が無いエラー\n    if(r.first < 0 || r.first >= 1024) f = false;\n    return P(r.first, r.second + 1);\n  } else{\n    exit(0); //括弧でも数字でもないエラー\n  }\n}\n\nP term(char *p){\n  P r = fact(p);\n  while(*r.second == '*' || *r.second == '/'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = fact(r.second + 1);\n    if(op == '*') r.first *= tmp;\n    else r.first /= tmp;\n    if(r.first < 0 || r.first >= 1024) f = false;\n  }\n  return r;\n}\n\nP expr(char *p){\n  P r = term(p);\n  while(*r.second == '+' || *r.second == '-'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = term(r.second + 1);\n    if(op == '+') r.first = tmp + r.first;\n    else r.first = tmp - r.first;\n    if(r.first < 0 || r.first >= 1024) f = false;\n  }  \n  return r;\n}\n\nbool is_digit(string s){\n  if(s == \"0\" || s == \"1\") return true;\n  return false;\n}\n\nbool is_operation(string s){\n  if(s == \"+\" || s == \"-\" || s == \"*\") return true;\n  return false;\n}\n\nbool is_number(string s){\n  if(is_digit(s) || ((int)s.length() >= 2 && is_number(s.substr(0, (int)s.length() - 1)) && is_digit(s.substr(s.length() - 1)))) return true;\n  return false;\n}\n\nbool check(string s){\n  int cnt = 0;\n  REP(i, s.length()){\n    if(s[i] == '(') ++cnt;\n    if(s[i] == ')') --cnt;\n    if(cnt < 0) return false;\n  }\n  return cnt == 0;\n}\n\nbool is_expression(string s);\n\nbool is_inner_expression(string s){\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      return true;\n    }\n  }\n  return false;\n}\n\nbool is_expression(string s){\n  if((int)s.length() >= 2 && s[0] == '(' && s[(int)s.length() - 1] == ')' && check(s.substr(1, (int)s.length() - 2))){\n    bool res = is_inner_expression(s.substr(1, (int)s.length() - 2));\n    return res;\n  }\n  if(is_number(s)){\n    return true;\n  }\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      return true;\n    }\n  }\n  return false;\n}\n\nbool is_invalid(char *s){\n  int sl = strlen(s);\n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')') return true;\n  if(s[sl - 1] == '+' || s[sl - 1] == '-' || s[sl - 1] == '*' || s[sl - 1] == '(') return true;\n  FOR(i, 1, sl - 1){ \n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(s[i - 1] != '.' && s[i - 1] != ')' && !isdigit(s[i - 1])) return true;\n      if(s[i + 1] != '.' && s[i + 1] != '(' && !isdigit(s[i + 1])) return true;\n    }\n    if(s[i] == ')'){\n      if(s[i - 1] != '.' && !isdigit(s[i - 1]) && s[i - 1] != ')') return true;\n      if(s[i + 1] != '.' && s[i + 1] != ')' && s[i + 1] != '+' && s[i + 1] != '-' && s[i + 1] != '*') return true;\n    }\n    if(s[i] == '('){\n      if(s[i + 1] != '.' && !isdigit(s[i + 1]) && s[i + 1] != '(') return true;\n      if(s[i - 1] != '.' && s[i - 1] != '(' && s[i - 1] != '+' && s[i - 1] != '-' && s[i - 1] != '*') return true;\n    }\n  }\n  return false;\n}\n\nint solve(int cnt, vector<int> &v, char *s){\n  //cout <<\"! \" <<s <<\", \" <<is_invalid(s) <<endl;\n  if(is_invalid(s)) return -1;\n  if(cnt >= (int)v.size()){\n    if(!is_expression(s)) return -1;\n    f = true;\n    int res = expr(s).first;\n    //cout <<\"!! \" <<res <<\", \" <<f <<endl;\n    return f && res >= 0 && res < 1024 ? res : -1;\n  }\n  if(is_invalid(s)) return -1;\n  int res = -1, sl = strlen(s);\n  if(v[cnt] != 0 && v[cnt] != sl - 1){\n    REP(i, 3){ \n      s[v[cnt]] = ops[i];\n      res = max(res, solve(cnt + 1, v, s));\n      s[v[cnt]] = '.';\n    }\n  }\n  REP(i, 2){\n    s[v[cnt]] = bs[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  REP(i, 2){\n    s[v[cnt]] = ds[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  return res;\n}\n\nint main() {\n  char s[110];\n  cin >>s;\n  int sl = strlen(s);\n  vector<int> v;\n  REP(i, sl) if(s[i] == '.') v.push_back(i);\n  cout <<solve(0, v, s) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint p,len,flg;\n\nint calc();\n\nint getNum(){\n  if(flg)return 0;\n  \n  if(s[p]=='('){\n    p++;\n    int res=calc();\n    if(s[p]!=')')flg=1;\n    p++;\n    return res;\n  }else if('0'<=s[p]&&s[p]<='1'){\n    int res=0;\n    while('0'<=s[p]&&s[p]<='1'){\n      res=res*2+(s[p]-'0');\n      p++;\n    }\n    return res;\n  }else{\n    flg=1;\n    return 0;\n  }\n}\n\nint calc(){\n  int cnt=0;\n  int res=0;\n  int num=getNum();\n  while(p<len){\n    if(flg)return 0;\n    \n    char ch=s[p++];\n    if(ch=='+'){\n      res+=num;\n      num=getNum();\n      if(res<0)flg=1;\n    }else if(ch=='-'){\n      res+=num;\n      num=-getNum();\n      if(res<0)flg=1;\n    }else if(ch=='*'){\n      num*=getNum();\n    }else if(ch==')'){\n      p--;\n      if(cnt==0)flg=1;\n      break;\n    }else{\n      flg=1;\n    }\n    cnt++;\n  }\n  res+=num;\n  if(res<0)flg=1;\n  return res;\n}\n\nstring tmp=\"01+-*()\";\n\nstring str;\nint ans;\n\nvoid dfs(int pos){\n  if((int)str.size()==pos){\n    s=str;\n    len=str.size();\n    p=flg=0;\n    int k=calc();\n    if(flg==0&&p==(int)s.size())ans=max(ans,k);\n    return;\n  }\n\n  if(str[pos]=='.'){\n    for(int i=0;i<(int)tmp.size();i++){\n      str[pos]=tmp[i];\n      dfs(pos+1);\n      str[pos]='.';\n    }\n  }else{\n    dfs(pos+1);\n  }\n}\n\nint main(){\n  cin>>str;\n  ans=-1;\n  dfs(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc();\nint expr();\nint number();\nstring tmp;\nint pos;\nchar c[]=\"()+-*01\";\nint ans=-1;\nbool f=0,ff;\nint calc(){\n  int res=expr();\n  while(1){\n    if(tmp[pos]=='*') {pos++;res*=expr();}\n    else break;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint expr(){\n  int res=number();\n  while(1){\n    if(tmp[pos]=='+') {pos++;res+=number();}\n    else if(tmp[pos]=='-') {pos++;res-=number();}\n    else break;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint number(){\n  int res=0;\n  if(tmp[pos]=='(') {\n    pos++;res=calc();pos++;\n  }else{\n    while(pos<(int)tmp.size()&&isdigit(tmp[pos])) res=res*2+tmp[pos]-'0',pos++;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\n\nbool check(string s){\n  int o=0;\n  bool op[100]={};\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') {\n      o++;\n      op[o]=1;\n      if(i+1>=(int)s.size()) return 0;\n      if(!isdigit(s[i+1])&&s[i+1]!='(') return 0;\n    }    \n    if(s[i]==')') {\n      if(op[o]) return 0;\n      o--;\n      if(i-1<0) return 0;\n      if(!isdigit(s[i-1])&&s[i-1]!=')') return 0;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*') {\n      op[o]=0;\n      if(i-1<0||i+1>=(int)s.size()) return 0;\n      if((!isdigit(s[i-1])&&s[i-1]!=')')||(!isdigit(s[i+1])&&s[i+1]!='(')) return 0;\n    }\n    if(o<0) return 0;\n  }\n  if(o) return 0;\n  return 1;\n}\nvoid rec(string s){\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]!='.') continue;\n    for(int j=0;j<8;j++){\n      s[i]=c[j];\n      rec(s);\n    }\n    return;\n  }\n  if(!check(s)) return;\n  tmp=s;pos=0;ff=1;\n  int k=calc();\n  if(ff) ans=max(ans,k);//,cout<<k<<\":\"<<tmp<<endl;\n}\nint main(){\n  string s;\n  cin>>s;\n  rec(s);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tconst int kind = 7;\n\tStage(){\n\t}\n\t\n\tvoid action(){\n\t\tstring text;\n\t\tcin >> text;\n\n\t\tint res = -1;\n\t\tREP(transWay, pow(kind, count_dot(text))) {\n\t\t\tstring transedText = trans(transWay, text);\n\t\t\tlist<char> ls;\n\t\t\tfor (char c : transedText)ls.push_back(c);\n\t\t\tint score = read(ls);\n\t\t\tres = max(res, score);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tchar data;\n\t\tint num;\n\t};\n\t\n\tint count_dot(const string& text) {\n\t\tint res = 0;\n\t\tfor (char c : text)if (c == '.')res++;\n\t\treturn res;\n\t}\n\tstring trans(int n, string text) {\n\t\tfor (char& c : text)if (c == '.') {\n\t\t\tswitch (n % kind) {\n\t\t\tcase 0:c = '0'; break;\n\t\t\tcase 1:c = '1'; break;\n\t\t\tcase 2:c = '+'; break;\n\t\t\tcase 3:c = '-'; break;\n\t\t\tcase 4:c = '*'; break;\n\t\t\tcase 5:c = '('; break;\n\t\t\tcase 6:c = ')'; break;\n\t\t\t}\n\t\t\tn /= kind;\n\t\t}\n\t\treturn text;\n\t}\n\n\tlist<Gram> trans_gram(const list<char>& ls) {\n\t\tlist<Gram> grams;\n\t\tfor (auto itr = ls.begin(); itr != ls.end(); ++itr) {\n\t\t\tGram gram;\n\t\t\tswitch (*itr) {\n\t\t\tcase '+':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '+';\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '-';\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '*';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgram.kind = 'n';\n\t\t\t\tgram.num = 0;\n\t\t\t\tdo {\n\t\t\t\t\tgram.num *= 2;\n\t\t\t\t\tgram.num += *itr - '0';\n\t\t\t\t\t++itr;\n\t\t\t\t} while (itr != ls.end() && isdigit(*itr));\n\t\t\t\t--itr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tint read(list<char> ls) {\n\t\ttry {\n\t\t\t// ( , ) delete\n\t\t\tfor (auto right = ls.begin(); right != ls.end(); ++right)\n\t\t\t{\n\t\t\t\tif (*right == ')') {\n\t\t\t\t\tlist<char> subset;\n\t\t\t\t\tauto left = right;\n\n\t\t\t\t\t//move: (expression)\n\t\t\t\t\twhile (left!=ls.begin() && *left != '(') --left;\n\t\t\t\t\tif (*left != '(')throw - 1;\n\t\t\t\t\t++right;\n\t\t\t\t\tsubset.splice(subset.begin(), move(ls), left, right);\n\n\t\t\t\t\t// delete: ( , )\n\t\t\t\t\tsubset.pop_front();\n\t\t\t\t\tsubset.pop_back(); \n\t\t\t\t\tif (isnumber(subset))throw - 1;\n\n\t\t\t\t\tint res = read(subset);\n\t\t\t\t\tif (res < 0)throw - 1;\n\t\t\t\t\tsubset = n2b(res);\n\t\t\t\t\tif (ls.empty()) {\n\t\t\t\t\t\tfor (auto num : subset)ls.push_back(num);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tls.splice(left, move(subset));\n\t\t\t\t\t}\n\t\t\t\t\tright = ls.begin();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tauto grams = trans_gram(ls);\n\t\t\toperator_erase(grams, '*');\n\t\t\toperator_erase(grams, '+', '-');\n\t\t\tif (grams.size() != 1) {\n\t\t\t\t//cerr << \"size is too much\" << endl;\n\t\t\t\tthrow - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn grams.front().num;\n\t\t\t}\n\t\t}\n\t\tcatch (...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbool isnumber(const list<char>& ls){\n\t\tfor (char c : ls) {\n\t\t\tif (c < '0' || '9' < c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isoperator(const char& c) {\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tlist<char> n2b(int num) {\n\t\tlist<char> b;\n\t\twhile (num > 0) {\n\t\t\tint tmp = num % 2;\n\t\t\tnum /= 2;\n\t\t\tb.push_front(tmp + '0');\n\t\t}\n\t\treturn b;\n\t}\n\n\tint b2n(const list<char>& ls) {\n\t\tint res = 0;\n\t\tfor (char c: ls) {\n\t\t\tres *= 2;\n\t\t\tres += c - '0';\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid operator_erase(\n\t\tlist<Gram>& grams,\n\t\tconst char& ope1,\n\t\tconst char& ope2 = '.'\n\t){\n\t\tfor (auto center = grams.begin(); center != grams.end(); ++center) {\n\t\t\tif (center->data == ope1 || center->data == ope2) {\n\t\t\t\tauto left = center; if (distance(grams.begin(), left) == 0)break; left--;\n\t\t\t\tauto right = center; if (distance(right, grams.end()) == 1)break; right++;\n\n\t\t\t\tswitch (center->data) {\n\t\t\t\tcase '+':left->num += right->num; break;\n\t\t\t\tcase '-':left->num -= right->num; break;\n\t\t\t\tcase '*':left->num *= right->num; break;\n\t\t\t\t}\n\n\t\t\t\tif (left->num < 0 || 1024 <= left->num)throw - 1;\n\t\t\t\tgrams.erase(center);\n\t\t\t\tgrams.erase(right);\n\t\t\t\tcenter = left;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tStage stage;\n\tstage.action();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\nll N;\nchar S[111];\n\n#define INF (-(1<<20))\n\nll number(ll l,ll r){\n  ll ret = 0;\n  if( r - l + 1 > 10 ) return INF;\n  for(ll i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n  }\n \n  return ret;\n}\n\n\nll check(ll x){\n  if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  return INF;\n}\n\nll check(ll a,ll b,char op){\n  if( 0LL <= a && a < (1LL<<10LL) && 0LL <= b && b < (1LL<<10LL)){ \n    ll x;\n    if( op == '+' )\n      x = a+b;\n    if( op == '-' )\n      x = a-b;\n    if( op == '*' )\n      x = a * b;\n    if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  }\n  return INF;\n}\n\nbool check_n(ll l,ll r){\n  for(ll i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return false;\n  }\n  return true;\n}\nbool check_k2(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt > 0 ) return false;\n  }\n  if( cnt == 0 ) return true;\n  return false;\n}\n\nbool check_k3(ll l,ll r){\n  int cnt = 0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt ++ ;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 &&!( S[i] == '(' || S[i] == ')') ) return true; \n  }\n  return false;\n}\n\n\nbool check_k(ll l,ll r){\n  ll cnt =0;\n  if( l==r ) return false;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n\nbool check_m(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n\nbool check_w(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n\n\nvoid view(ll l,ll r){\n  for(ll i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n\nbool check_h(ll l,ll r){\n  if( S[l] == '+' || S[r] == '+' || S[l] == '-' || S[r] == '-' || S[l] == '*' || S[r] == '*' ||  S[l] == ')' || S[r] == '(' ) return true;\n  if( l > r ) return true;\n  return false;\n}\n\nll exp(ll l,ll r){\n  //view(l,r);\n  if( check_h(l,r) ) return INF;\n  if( !check_k2(l,r) ) return INF;\n  if( check_k(l,r) ) {\n    if( check_n(l+1,r-1) ) return INF;\n    if( !check_k3(l+1,r-1) ) return INF;\n    return check(exp(l+1,r-1));\n  }\n  if( check_w(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return check(exp(l,i-1), exp(i+1,r),'+');\n      if( cnt == 0 && S[i] == '-' ) return check(exp(l,i-1), exp(i+1,r),'-');\n    }\n  }\n  if( check_m(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return check(exp(l,i-1), exp(i+1,r),'*');\n    }\n  }\n  if( check_n(l,r) )\n    return check(number(l,r));\n  return INF;\n}\n\nint main(){\n  cin >> S;\n  N  = strlen(S);\n  ll M = 0;\n  for(ll i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  ll res = -1;\n  ll K=1;\n  for(ll i=0;i<M;i++) K*=7;\n  for(ll i=0;i<K;i++){\n    ll c = i;\n    strcpy( S, buf );\n    for(ll j=0;j<N;j++){\n      if( S[j] == '.' ){\n\tif( c%7 == 0 ) S[j] = '0';\n\tif( c%7 == 1 ) S[j] = '1';\n\tif( c%7 == 2 ) S[j] = '+';\n\tif( c%7 == 3 ) S[j] = '-';\n\tif( c%7 == 4 ) S[j] = '*';\n\tif( c%7 == 5 ) S[j] = '(';\n\tif( c%7 == 6 ) S[j] = ')';\t\t\n\tc/=7;\n      }    \n    }\n   \n    res = max( res, exp(0,N-1) );\n    \n  }\n  cout << res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\npi expr(), factor();\nstring s;\nint p;\npi digit(){\n\tint d = 0;\n\twhile(p < s.size() && isdigit(s[p])){\n\t\td *= 2; d += s[p++] - '0';\n\t\tif(d >= 1 << 10) throw \"bigdigit\";\n\t}\n\treturn mp(d, 0);\n}\npi expr(){\n\tpi a = factor();\n\tbool op = 0;\n\twhile(p < s.size() && (s[p] == '+' || s[p] == '-')){\n\t\top = 1;\n\t\tbool pr = s[p++] == '+';\n\t\tpi b = factor();\n\t\ta.first = a.first + (pr ? b.first : -b.first);\n\t\tif(a.first < 0 || a.first >= 1 << 10) throw \"overflow\";\n\t}\n\treturn mp(a.first, op);\n}\npi factor(){\n\tpi a = mp(1, 0);\n\tint op = 0;\n\tp--;\n\tdo{\n\t\tif(++p >= s.size()) throw \"syntaxerorr\";\n\t\t\n\t\tpi b;\n\t\tif(isdigit(s[p])) b = digit();\n\t\telse if(s[p] == '('){\n\t\t\tp++;\n\t\t\tb = expr();\n\t\t\tif(!b.second) throw \"(())\";\n\t\t\tif(s[p++] != ')') throw \"closep\";\n\t\t}\n\t\ta.first *= b.first;\n\t\top++;\n\t}while(p < s.size() && s[p] == '*');\n\treturn mp(a.first, op > 1);\n}\n\nint main(){\n\tcin >> s;\n\tvi v;\n\trep(i, s.size()) if(s[i] == '.') v.pb(i);\n\tint pw[10], ans = -1;\n\tpw[0] = 1;\n\trep(i, 9) pw[i + 1] = pw[i] * 7;\n\t\n\trep(i, pw[v.size()]){\n\t\trep(j, v.size()) s[v[j]] = \"01+-*()\"[i / pw[j] % 7];\n\t\tp = 0;\n\t\ttry{\n\t\t\tpi res = expr();\n\t\t\tif(p < s.size()) throw \"syntaxerror\";\n\t\t\tans = max(ans, res.first);\n\t\t}catch(const char *e){\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <iostream>\n\nusing namespace std;\n\nint n, cl[5], cnum, num, p;\nchar str[101], cc[] = {\"01+-*\"}, t[501];\n\nint eq(char c1,char c2,char c3,char c4){\n\treturn c1 == c3 && c2 == c4;\n}\n\nint calc(){\n\tint ret = 0, i, c;\n\tchar e = '+';\n\tfor(;p < num;p++){\n\t\tif(t[p] == '('){\n\t\t\tp++;\n\t\t\tc = calc();\n\t\t\tif(e == '+')\n\t\t\t\tret += c;\n\t\t\telse if(e == '-')\n\t\t\t\tret -= c;\n\t\t\telse if(e == '*')\n\t\t\t\tret *= c;\n\t\t}\n\t\telse if(isdigit(t[p])){\n\t\t\tc = 0;\n\t\t\tfor(i = p;isdigit(t[i]);i++) c = (c << 1) + t[i] - '0';\n\t\t\tp = i - 1;\n\t\t\tif(e == '+')\n\t\t\t\tret += c;\n\t\t\telse if(e == '-')\n\t\t\t\tret -= c;\n\t\t\telse if(e == '*')\n\t\t\t\tret *= c;\n\t\t}\n\t\telse if(t[p] == '+' || t[p] == '-' || t[p] == '*')\n\t\t\te = t[p];\n\t\telse if(t[p] == ')'){\n\t\t\tp++;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nvoid priority(void){\n\tint i, j, k, c;\n\tnum = n;\n\tmemcpy(t,str,sizeof(str));\n\tfor(i = 0;i < num;i++){\n\t\tif(str[i] == '*'){\n\t\t\tc = 0;\n\t\t\tfor(j = i - 1;j > 0;j--){\n\t\t\t\tif(str[j] == ')') c++;\n\t\t\t\telse if(str[j] == '(') c--;\n\t\t\t\tif(c == 0 && !isdigit(str[j])) break;\n\t\t\t}\n\t\t\tif(j != 0) j--;\n\t\t\tfor(k = num;k >= j;k--) t[k + 1] = t[k];\n\t\t\tnum++;\n\t\t\tt[j] = '(';\n\t\t\tfor(j = i + 1;j < num;j++){\n\t\t\t\tif(str[j] == '(') c++;\n\t\t\t\telse if(str[j] == ')') c--;\n\t\t\t\tif(c == 0 && !isdigit(str[j])) break;\n\t\t\t}\n\t\t\tj++;\n\t\t\tfor(k = num;k >= j;k--) t[k + 1] = t[k];\n\t\t\tnum++;\n\t\t\tt[j] = ')';\n\t\t}\n\t}\n}\n\t\t\t\t\n\n\nint judge(void){\n\tint i, j, k = 0, c;\n\tchar c1, c2;\n\tfor(i = 0;i < n - 1;i++){\n\t\tc1 = str[i],c2 = str[i + 1];\n\t\tif(eq(c1,c2,'(','+') || eq(c1,c2,'(','-') || eq(c1,c2,'(','*') || eq(c1,c2,'+',')') || eq(c1,c2,'-',')') || eq(c1,c2,'*',')') || eq(c1,c2,'0','(') || eq(c1,c2,'1','(') || eq(c1,c2,')','0') || eq(c1,c2,')','1') || eq(c1,c2,'+','+') || eq(c1,c2,'-','-') || eq(c1,c2,'*','*') || eq(c1,c2,'+','-') || eq(c1,c2,'+','*') || eq(c1,c2,'-','+') || eq(c1,c2,'-','*') || eq(c1,c2,'*','+') || eq(c1,c2,'*','-'))\n\t\t\treturn 0;\n\t}\n\tif(str[0] == '+' || str[0] == '-' || str[0] == '*' || str[n - 1] == '+' || str[n - 1] == '-' || str[n - 1] == '*')\n\t\treturn 0;\n\tfor(i = 0;i < n;i++){\n\t\tif(str[i] == '('){\n\t\t\tfor(j = i;str[j] != ')';j++);\n\t\t\tc = 1;\n\t\t\tfor(k = i + 1;k < j;k++){\n\t\t\t\tif(str[k] == '+' || str[k] == '-' || str[k] == '*'){\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c) return 0;;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint dfs(int c){\n\tint ret = 0x80000000,i, e;\n\tif(c == cnum){\n\t\tif(judge()){\n\t\t\tpriority();\n\t\t\tp = 0;\n\t\t\tret = max(ret,e = calc());\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(i = 0;i < 5;i++){\n\t\tstr[cl[c]] = cc[i];\n\t\tret = max(ret,dfs(c + 1));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint i = 0,ans;\n\tchar c;\n\twhile((c = getchar()) != '\\n')\n\t\tstr[i++] = c;\n\tstr[i] = '\\0';\n\tn = strlen(str);\n\tcnum = 0;\n\tfor(i = 0;i < n;i++)\n\t\tif(str[i] == '.') cl[cnum++] = i;\n\tans = dfs(0);\n\tprintf(\"%d\\n\",ans!=0x80000000?ans:-1);\n\twhile(getchar() != 'E');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n#define int long long \n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res -= term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }\n    }\n    if(res<0||res>=1024){\n        ppppp = 1;\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    if(ans<0||ans>=1024){\n        ppppp = 1;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            \n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nsigned main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                cout << -1<< endl;\n            }else{\n                cout << xxx << endl;\n            }\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n\n  return true;\n}\n\nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n\n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\n\nbool containope(string s){\n \n  for(int i = 0; i < s.length(); i++)\n    if(s[i] == '-' || s[i] == '+' || s[i] == '*') return true;\n  return false;\n}\nbool isope(string s){\n\n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true; \n  }\n  return false;\n}\n\nbool parapos(string s){\n  int p = 0;\n\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n  }\n  return p == 0;\n}\n\nbool isvalid(string s){\n\n  if(!parapos(s)) return false;\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return containope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n\nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n\nint get(string s){\n  //cout << \"S \" << s << endl;\n \n  if(isnum(s)) return tob(s);\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return get(s.substr(0,i))+get(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return get(s.substr(0,i))-get(s.substr(i+1));\n    }\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return get(s.substr(0,i))*get(s.substr(i+1));\n    }\n  }\n}\n\nvoid solve(int n){\n\n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n    if(isvalid(in)) ans = max(ans,get(in));\n  }\n}\n\nint main(){\n\n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n\n  solve(0);\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    int N;\n    void input() {\n        cin >> s;\n        N = s.size();\n    }\n\n    int valid(int x) {\n        return 0 <= x && x < 1024;\n    }\n\n    int number(int& index) {\n        int x = 0;\n        while (isdigit(s[index])) {\n            int c = s[index] - '0';\n            x = x * 2 + c;\n            index++;\n        }\n        if (not valid(x)) return -1;\n        return x;\n    }\n    int oper(int x, int y, char op) {\n        int ret = 0;\n        if (op == '+') {\n            ret = x + y;\n        } else if (op == '-') {\n            ret = x - y;\n        } else if (op == '*') {\n            ret = x * y;\n        } else {\n            return -1;\n        }\n        if (not valid(ret)) return -1;\n        return ret;\n    }\n    int term(int& index, bool flag = false) {\n        if (index == N || not isdigit(s[index])) return -1;\n        int x = number(index);\n        if (index == N || (!flag && s[index] == ')')) return x;\n        if (not valid(x)) return -1;\n        char op = s[index];\n        if (op == '*') {\n            index++;\n            int y = term(index);\n            if (not valid(y)) return -1;\n            return oper(x, y, op);\n        } else {\n            return x;\n        }\n    }\n    int expr(int& index, bool flag = false) {\n        if (isdigit(s[index])) {\n            int i = index;\n            int p = number(i);\n            int x = term(index);\n            if (index == N || ((!flag || i != index) && s[index] == ')')) return x;\n            if (not valid(x)) return -1;\n            char op = s[index]; index++;\n            int y = expr(index);\n            if (not valid(y)) return -1;\n            /*\n            cout << \"x: \" << x << endl;\n            cout << \"y: \" << y << endl;\n            cout << \"op: \" << op << endl;\n            cout << \"res: \" << oper(x, y, op) << endl;\n            */\n            return oper(x, y, op);\n        }\n        if (s[index] == '(') {\n            index++;\n            int ret = expr(index, true);\n            if (s[index] != ')') return -1;\n            index++;\n            if (not valid(ret)) return -1;\n            return ret;\n        }\n        return -1;\n    }\n\n    int calc(int index) {\n        const string C = \"01+-*()\";\n        if (index == N) {\n            int i = 0;\n            int r = expr(i);\n            if (i != N) r = -1;\n            //cout << s << \" -> \" << r << endl;\n            return r;\n        }\n        if (s[index] == '.') {\n            int ret = -1;\n            for (int i = 0; i < C.size(); i++) {\n                s[index] = C[i];\n                ret = max(ret, calc(index + 1));\n            }\n            s[index] = '.';\n            return ret;\n        } else {\n            return calc(index + 1);\n        }\n    }\n\n    void solve() {\n        cout << calc(0) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n/*\nBNFの\n<expression> ::= ( <expression> <operation> <expression> )\nの部分がやっかいで()のなかに必ず演算子が必要なので\n(1) => -1 (Not Number, 1は間違い) \nとしなければならないので注意.\n((1+1)) => -1 // 演算子が足りない\n((1+1)+1) => 3\n((1+1)+(1+1)+(1+1)) => 6\n1() => -1 // 構文解析が最後の文字まで読んでない.\n */\n\nstring ch = \"01+-*()\";\nint ans = -1;\nbool flag = false;\n\n// 括弧の対応がとれているか\nbool check(const string& s){\n\tmap<int,int> m;\n\tstack<int> st;\n\tvector<int> v;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '(' ){\n\t\t\tv.push_back(i);\n\t\t\tst.push( i );\n\t\t}else if( s[i] == ')' ){\n\t\t\tif( st.empty() ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tm[st.top()] = i;\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn st.empty();\n}\n\n// 構文解析は Spaghetti Source 再帰下降型構文解析 ( LL(1) ) を参照.\n// http://www.prefield.com/algorithm/string/parser.html\ntypedef pair<int, int> result;\n#define value first\n#define p second\n\nresult eq(const string &s, int p, int& op);\nresult fact(const string &s, int p, int& op);\nresult term(const string &s, int p);\n\nresult eq(const string &s, int p, int& op){ \n\tresult r = fact(s, p, op);\n\t\n\t// 計算途中で負の値のとき\n\tif( r.value < 0 ) flag = true;\n\t\n\t// 演算子のチェック\n\twhile( s[r.p] == '+' || s[r.p] == '-' ){\n\t\top++;\n\t\tresult r_ = fact(s, r.p+1, op);\n\t\t// 計算途中で負の値のとき\n\t\tif( r_.value < 0 ) flag = true;\n\t\t\n\t\t// (r.value + r_.value) or (r.value - r_value) \n\t\tr.value += (s[r.p] == '+')? r_.value : -r_.value ;\n\t\tr.p = r_.p;\n\t}\n\treturn r;\n}\n\nresult fact(const string &s, int p, int& op) {\n\tresult r = term(s, p);\n\t\n\t// 計算途中で負の値のとき\n\tif( r.value < 0 ) flag = true;\n\t\n\twhile( s[r.p] == '*' ){\n\t\top++;\n\t\tresult r_ = term(s, r.p+1);\n\t\t\n\t\t// 計算途中で負の値のとき\n\t\tif( r_.value < 0 ) flag = true;\n\t\t\n\t\tr.value *= r_.value;\n\t\tr.p      = r_.p;\n\t}\n\treturn r;\n}\nresult term(const string &s, int p) {\n\tif( s[p] == '(' ){\n\t\tint op=0;\n\t\tresult r = eq(s, p+1, op);\n\t\t// (演算子が1個あるかチェック)\n\t\tif( op < 1 ){\n\t\t\tflag = true;\n\t\t}\n\t\tif( s[r.p] != ')' ){\n\t\t\tflag = true;\n\t\t}\n\t\tr.p += 1; // skip ')'\n\t\treturn r;\n\t}else{\n\t\tint value = 0;\n\t\t\n\t\t// 数字が来るところなのに数字がない\n\t\tif( !isdigit(s[p]) ){\n\t\t\tflag = true;\n\t\t}\n\t\t\n\t\t// 2進数なので注意!\n\t\twhile( isdigit(s[p]) )\n\t\t\tvalue = value * 2 + (s[p++] - '0');\n\t\treturn result(value, p);\n\t}\n}\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tflag = false;\n\t\tif( check(s) ){ // 括弧の対応がとれているかどうか\n\t\t\tint op=0;\n\t\t\tresult r = eq(s,0,op);\n\t\t\tint res = r.value; // 式の値\n\t\t\tint pos = r.p; // 読み終えた時の位置\n\t\t\t\n\t\t\tif( flag || pos != s.size() ){ // 式が正しくないとき\n\t\t\t\t// cout << \"NA\" << endl;\n\t\t\t}else{ // 式が正しいときだけ解を更新\n\t\t\t\t// cout << res << endl;\n\t\t\t\tans = max( ans , res );\n\t\t\t}\n\t\t}else{\n\t\t\t// cout << \"NA\" << endl;\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <stdexcept>\n\nstruct ParseError: public std::logic_error {\n  ParseError(const std::string &what_arg): std::logic_error(what_arg) {}\n};\n\nvoid apply(int &lhs, char op, int rhs) {\n  switch (op) {\n  case '+':\n    lhs += rhs;\n    break;\n  case '-':\n    lhs -= rhs;\n    break;\n  case '*':\n    lhs *= rhs;\n    break;\n  }\n  if (!(0 <= lhs && lhs < 1024))\n    throw std::out_of_range(\"value must be in [0, 1023]\");\n}\n\nint parse_bin(const std::string &s, size_t &i) {\n  int res=0;\n  while (i < s.length() && isdigit(s[i])) {\n    res = res*2+s[i]-'0';\n    ++i;\n    if (res >= 1024)\n      throw std::out_of_range(\"value must be in [0, 1023]\");\n  }\n  assert(res < 1024);\n  return res;\n}\n\nstd::pair<int, int> parse(\n    const std::string &s, size_t &i, int &balance,\n    const std::vector<std::string> &ops={\"+-\", \"*\", \"\"}, size_t prec=0) {\n\n  // <calculates, num of operators>\n  if (prec == ops.size()) {\n    if (s.at(i) == '(') {\n      ++i;\n      ++balance;\n      if (s.at(i) == ')')\n        throw ParseError(\"empty parentheses\");\n\n      std::pair<int, int> res=parse(s, i, balance, ops, 0);\n      if (s.at(i) != ')')\n        throw ParseError(\"mismatch parentheses\");\n\n      ++i;\n      --balance;\n      if (balance < 0)\n        throw ParseError(\"mismatch parentheses\");\n      if (res.second < 1)\n        throw ParseError(\"singleton parentheses\");\n      return {res.first, 0};\n    }\n    if (isdigit(s.at(i))) {\n      return {parse_bin(s, i), 0};\n    }\n    throw ParseError(\"unexpected token\");\n  }\n\n  std::pair<int, int> lhs=parse(s, i, balance, ops, prec+1);\n  while (i < s.length()) {\n    char op=s.at(i);\n    if (op == ')')\n      break;\n    if (!(op == '+' || op == '-' || op == '*'))\n      throw ParseError(\"unexpected token\");\n    if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n      break;\n\n    std::pair<int, int> rhs=parse(s, ++i, balance, ops, prec+1);\n    apply(lhs.first, op, rhs.first);\n    lhs.second += rhs.second+1;\n  }\n  return lhs;\n}\n\nint rec(std::string &s, std::vector<size_t> &dot) {\n  if (dot.empty()) {\n    try {\n      size_t i=0;\n      int b=0;\n      int res=parse(s, i, b).first;\n      if (i != s.length()) throw ParseError(\"garbage found\");\n      if (b < 0) throw ParseError(\"mismatch parentheses\");\n\n      return res;\n    } catch (const std::logic_error &x) {\n      // fprintf(stderr, \"Parse failed: %s\\n\", x.what());\n      return -1;\n    }\n  }\n\n  size_t x=dot.back();\n  dot.pop_back();\n  int res=-1;\n  for (char ch: {'0', '1', '+', '-', '*', '(', ')'}) {\n    s[x] = ch;\n    res = std::max(res, rec(s, dot));\n  }\n  s[x] = '.';\n  dot.push_back(x);\n  return res;\n}\n\nint main() {\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  std::vector<size_t> dot;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '.')\n      dot.push_back(i);\n  }\n\n  printf(\"%d\\n\", rec(s, dot));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  rep(i,s.size()){\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n      if(i==s.size()-1){\n        return -INF;\n      } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n        return -INF;\n      }\n    }\n  }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1)return calculate(s.substr(1,s.size()-2),true);\n    if(s[index+1]=='+'){\n      ret = calculate(s.substr(0,index+1))+calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='-'){\n      ret = calculate(s.substr(0,index+1))-calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = ret1*ret2;\n        if(inner(ret)){\n          return ret;\n        } else {\n          return -INF;\n        }\n      } else {\n        return -INF;\n      }\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    tmp = calculate(sc);\n    if(tmp>maxn)maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\nbool isd(string s){return isdigit(s[0]);}\n\nstring calc(vs s){\n    stack<int> p;\n    for(int i=0;i<s.size();i++){\n        if(s[i]==\"(\")p.push(i);\n        else if(s[i]==\")\"){\n            int f=p.top(); p.pop();\n            vs tmp;\n            s[f]=s[i]=\"-1\";\n            for(int j=f+1;j<i;j++){\n                tmp.pb(s[j]);\n                s[j]=\"-1\";\n            }\n            s[f]=calc(tmp);\n            if(s[f]==\"-1\") return \"-1\";\n            //cout<<\"ans\"<<s[f]<<endl;\n        }\n    }\n    //for(auto c:s)cout<<setw(3)<<c;cout<<endl;\n    auto itr=remove(all(s),\"-1\");\n    s.erase(itr,s.end());\n    if(s.size()==0)return \"-1\";\n    //for(auto c:s)cout<<c<<\"      \";\n    \n    deque<int> oper;\n    deque<string> opec;\n    for(int i=0;i<s.size();i++){\n        if(isd(s[i])){\n            oper.pb(stoi(s[i]));\n        }else{\n            if(s[i]==\"*\"){\n                oper.back()*=stoi(s[++i]);\n                if(oper.back()<0 || oper.back()>1023) return \"-1\";\n            }else opec.pb(s[i]);\n        }\n    }\n    while(!opec.empty()){\n        int d=oper[0];\n        string c=opec[0];\n        oper.pop_front();\n        opec.pop_front();\n        oper.front()=(c==\"+\" ? d+oper.front() : d-oper.front());\n        if(oper.front()<0 || oper.front()>1023) return \"-1\";\n    }\n    return to_string(oper[0]);\n}\n\n\nstring solve(string in){\n    vector<string> s;\n    bool ren=false;\n    for(auto c:in){\n        if(c=='0' || c=='1'){\n            if(ren){\n                s.back()+=c;\n            }else s.pb(\"\"s+c);\n            ren=true;\n        } else {\n            s.pb(\"\"s+c);\n            ren=false;\n        }\n    }\n\n    int dep=0;\n    for(int i=0;i<s.size();i++){\n        string &c=s[i];\n        try{\n            int p=stoi(c,nullptr,2);\n            if(p>1023) return \"-1\";\n            c=to_string(p);\n        }catch(std::invalid_argument){\n            if(c==\"(\")dep++;\n            else if(c==\")\")dep--;\n            if(dep<0 || dep>25)return \"-1\";\n        }catch(...){\n            return \"-1\";\n        }\n    }\n    if(dep)return \"-1\";\n\n    //for(auto c:s)cout<<c;cout<<endl;\n    int exist=0,depth=0;\n    for(int i=0;i<s.size()-1;i++){\n        if(isd(s[i])){\n            if(s[i+1]==\"(\" || isd(s[i+1])) return \"-1\";\n        }else if(s[i]==\"(\"){\n            depth++;\n            if(s[i+1]==\"+\" || s[i+1]==\"-\" || s[i+1]==\"*\" || s[i+1]==\")\") return \"-1\";\n        }else if(s[i]==\")\"){\n            //cout<<depth<<\",\"<<exist<<endl;\n            if((exist&(1<<depth))==0) return \"-1\";\n            //cout<<\"OK\"<<endl;\n            exist&=~(1<<depth);\n            depth--;\n            if(isd(s[i+1]) || s[i+1]==\"(\") return \"-1\";\n        }else{\n            exist|=(1<<depth);\n            if(s[i+1]!=\"(\" && !isd(s[i+1])) return \"-1\";\n        }\n    }\n\n    if(s.back()==\")\"){\n        if((exist&(1<<depth))==0) return \"-1\";\n    }\n    int t=s.size()-1;\n    if(s[0]==\")\" || s[0]==\"+\" || s[0]==\"-\" || s[0]==\"*\") return \"-1\";\n    if(s[t]==\"(\" || s[t]==\"+\" || s[t]==\"-\" || s[t]==\"*\") return \"-1\";\n\n    //ここまでで除去ができているはず\n    //for(auto c:s)cout<<c;cout<<endl;\n    string ans=calc(s);\n    //cout<<\"=\"<<ans<<endl;\n    return ans;\n}\n\nint bur(string s){\n    int ans=-1;\n    if(count(all(s),'.')==0) {\n        return stoi(solve(s));\n    }\n    for(auto d:\"01+-*()\"s){\n        string os=s;\n        os[s.find('.')]=d;\n        ans=max(ans,bur(os));\n    }\n    return ans;\n}\n\nint main(){\n    string o;\n    cin>>o;\n    cout<<bur(o)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nbool h;\nint out=-1;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*2+*(i++)-'0';\n\tif(out<0||out>=1024)h=false;\n\treturn out;\n}\nmap<char,int>op;\nint valid(string s){\n\tint n=s.size();\n\tvi co(100);\n\tint cnt=0;\n\trep(t,s.size()){\n\t\tif(s[t]=='('){\n\t\t\tif(t&&!op[s[t-1]])return 0;\n\t\t\tcnt++;\n\t\t\tco[cnt]=0;\n\t\t}else if(s[t]==')'){\n\t\t\tif(t!=n-1&&!op[s[t+1]])return 0;\n\t\t\tif(!co[cnt])return 0;\n\t\t\tcnt--;\n\t\t\tif(cnt<0)return 0;\n\t\t}else if(op[s[t]]){\n\t\t\tco[cnt]++;\n\t\t\tif(t==0||t==n-1)return 0;\n\t\t\tif(!isdigit(s[t-1])&&s[t-1]!=')'||!isdigit(s[t+1])&&s[t+1]!='(')return 0;\n\t\t}\n\t}\n\treturn !cnt;\n}\nstring w=\"01+-*()\";\nstring s;\nvoid dfs(){\n\trep(i,s.size())if(s[i]=='.'){\n\t\trep(j,w.size()){\n\t\t\ts[i]=w[j];\n\t\t\tdfs();\n\t\t\ts[i]='.';\n\t\t}\n\t\treturn;\n\t}\n\tif(!valid(s))return;\n\tState begin=s.begin();\n\th=true;\n\tint a=expr(begin);\n\tif(h)out=max(out,a);\n}\nint main(){\n\top['+']=op['-']=op['*']=op[')']=op['(']=true;\n\tcin>>s;\n\tdfs();\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <exception>\n#include <cctype>\n\nusing namespace std;\n\nstruct Result {\n\tint v, p, ex;\n};\n\n#define PARSER_DECL(name) \\\n\tResult name (const string &s, int p)\n\nPARSER_DECL(expr);\nPARSER_DECL(term);\nPARSER_DECL(factor);\nPARSER_DECL(expr_in);\n\nvoid range_check(int x){\n\tif(x < 0 || x >= 1024){ throw exception(); }\n}\n\nPARSER_DECL(expr){\n\tResult r;\n\tr = term(s, p);\n\twhile(s[r.p] == '+' || s[r.p] == '-'){\n\t\tResult q = term(s, r.p + 1);\n\t\tif(s[r.p] == '+'){\n\t\t\tr.v += q.v;\n\t\t}else{\n\t\t\tr.v -= q.v;\n\t\t}\n\t\trange_check(r.v);\n\t\tr.p = q.p;\n\t}\n\trange_check(r.v);\n\treturn r;\n}\nPARSER_DECL(term){\n\tResult r;\n\tr = factor(s, p);\n\tr.ex = 0;\n\twhile(s[r.p] == '*'){\n\t\tResult q = factor(s, r.p + 1);\n\t\tr.ex = 1;\n\t\tr.v *= q.v;\n\t\tr.p = q.p;\n\t\trange_check(r.v);\n\t}\n\trange_check(r.v);\n\treturn r;\n}\nPARSER_DECL(factor){\n\tResult r;\n\tif(s[p] == '('){\n\t\tr = expr_in(s, p + 1);\n\t\tif(s[r.p] != ')'){ throw exception(); }\n\t\trange_check(r.v);\n\t\t++r.p;\n\t}else if(isdigit(s[p])){\n\t\tr.v = 0;\n\t\twhile(isdigit(s[p])){\n\t\t\tr.v = (r.v * 2) + (s[p] - '0');\n\t\t\trange_check(r.v);\n\t\t\t++p;\n\t\t}\n\t\tr.p = p;\n\t}else{\n\t\tthrow exception();\n\t}\n\treturn r;\n}\n\nPARSER_DECL(expr_in){\n\tResult r;\n\tr = term(s, p);\n\twhile(s[r.p] == '+' || s[r.p] == '-'){\n\t\tResult q = term(s, r.p + 1);\n\t\tr.ex = 1;\n\t\tif(s[r.p] == '+'){\n\t\t\tr.v += q.v;\n\t\t}else{\n\t\t\tr.v -= q.v;\n\t\t}\n\t\trange_check(r.v);\n\t\tr.p = q.p;\n\t}\n\tif(r.ex == 0){ throw exception(); }\n\trange_check(r.v);\n\treturn r;\n}\n\nconst char SYMBOLS[] = \"01+-*()\";\n\nint recur(string &s, int p){\n\tint answer = -1;\n\tbool parse_req = true;\n\tfor(int i = p; i < s.size(); ++i){\n\t\tif(s[i] == '.'){\n\t\t\tparse_req = false;\n\t\t\tfor(int j = 0; SYMBOLS[j] != '\\0'; ++j){\n\t\t\t\ts[i] = SYMBOLS[j];\n\t\t\t\tanswer = max(answer, recur(s, i + 1));\n\t\t\t}\n\t\t\ts[i] = '.';\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(parse_req){\n\t\ttry {\n\t\t\tResult r = expr(s, 0);\n\t\t\tif(s[r.p] != '\\0'){ throw exception(); }\n\t\t\tanswer = r.v;\n\t\t}catch(exception e){\n\t\t}\n\t}\n\treturn answer;\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tcout << recur(s, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p;\nbool flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(p);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(s[p]=='*') res*=calc();\n  }\n  if(res<0||res>=1024) flg=0;\n  return res;\n}\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(p+1);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n    if(res<0||res>=1024) flg=0;\n  }\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\n\nusing ll = long long;\nusing pll = pair<ll, ll>;\n \nconstexpr ll M = 1e9+7;\n\nconst string w = \"01+-*()\";\n\nconstexpr int mi = 0;\nconstexpr int ma = (1 << 10) - 1;\n\nbool isrange(int n) {\n    return mi <= n && n <= ma;\n}\n\nint expr(string const& s, int& p);\nint term(string const& s, int& p);\nint factor(string const& s, int& p);\nint number(string const& s, int& p);\n\nint expr(string const& s, int& p) {\n    int res = term(s, p);\n    while(p < s.size() && s[p] == '+') {\n        res += factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    }\n    return res;\n}\n\nint term(string const& s, int& p) {\n    int res = factor(s, p);\n    while(p < s.size() && s[p] == '*') {\n        res *= factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    }\n    return res;\n}\n\nint factor(string const& s, int& p) {\n    if(isdigit(s[p])) {\n        return number(s, p);\n    }\n    if(s[p] == '-') {\n        int res = -factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    } else if(s[p] == '(') {\n        int res = expr(s, ++p);\n        ++p;\n        return res;\n    } else {\n        throw runtime_error(\"\");\n    }\n}\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(isdigit(s[p])) {\n        res <<= 1;\n        res |= s[p] == '1';\n        ++p;\n    }\n    if(!isrange(res)) {\n        throw runtime_error(\"\");\n    }\n    return res;\n}\n\nbool check(string const& s) {\n    stack<int> st;\n    vector<vector<bool>> par(s.size(), vector<bool>(s.size()));\n    bool ok = true;\n    for(int i=0; i<s.size(); ++i) {\n        if(s[i] == '(') {\n            st.push(i);\n        }\n        if(s[i] == ')') {\n            if(st.empty()) {\n                ok = false;\n                break;\n            }\n            if(s[st.top()+1] == '(' && s[i-1] == ')' && par[st.top()+1][i-1]) {\n                ok = false;\n                break;\n            }\n            par[st.top()][i] = true;\n            bool f = false;\n            for(int j=st.top()+1; j<i; ++j) {\n                f |= !isdigit(s[j]);\n            }\n            st.pop();\n            ok &= f;\n        }\n    }\n    return st.empty() && ok;\n}\n\nint solve(int i, string& s, vector<int> const& lost) {\n    int res = -1;\n    if(i == lost.size()) {\n        try {\n            int p = 0;\n            if(check(s)) {\n                res = expr(s, p);\n            }\n            return (p == s.size() ? res : -1);\n        } catch(...) {\n            return -1;\n        }\n    }\n    for(int j=0; j<w.size(); ++j) {\n        s[lost[i]] = w[j];\n        res = max(res, solve(i+1, s, lost));\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    vector<int> pos;\n    for(int i=0; i<s.size(); ++i) {\n        if(s[i] == '.') {\n            pos.push_back(i);\n        }\n    }\n    cout << solve(0, s, pos) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool is_num(char x){return x=='0' || x=='1';}\n\nbool valid_num(int x){\n  const int SUP=1024;\n  return 0<=x && x<SUP;\n}\n\nint calc(int lhs,int rhs,char op){\n  int res;\n  if(op=='+'){\n    res=lhs+rhs;\n  }else if(op=='-'){\n    res=lhs-rhs;\n  }else if(op=='*'){\n    res=lhs*rhs;\n  }else{\n    throw \"calc\";\n  }\n\n  if(!valid_num(res)) throw \"valid\";\n  return res;\n}\n\nint formula(int &p);\nint formulap(int &p);\nint term1(int &p);\npair<int,bool> term1p(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint formula(int &p){\n  int res=term1(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='|') throw \"formula\";\n    int rhs=term1(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\nint formulap(int &p){\n  bool isok=false;\n  auto ret=term1p(p);\n  isok|=ret.second;\n  int res=ret.first;\n\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formulap_op\";\n    isok=true;\n    int rhs=term1p(p).first;\n    res=calc(res,rhs,op);\n  }\n  if(!isok) throw \"formulap_isok\";\n  return res;\n}\n\nint term1(int& p){\n  int res=term2(p);\n  while(p<s.size() && (s[p]!='+' && s[p]!='-')){\n    char op=s[p];\n    p++;\n    if(op!='*') throw \"term1_op\";\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\npair<int,bool> term1p(int &p){\n  int res=term2(p);\n  bool isop=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;    \n    if(op!='*') throw \"term1p\";\n    isop=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,isop};\n}\n\nint term2(int& p){\n  if(s[p]=='('){\n    p++;\n    int res=formulap(p);\n    if(s[p]!=')') throw \"term2\";\n    p++;\n    return res;\n  }else if(is_num(s[p])){\n    int res=get_num(p);\n    return res;\n  }else throw \"term2\";\n}\n\nint get_num(int& p){\n  int res=0;\n  while(p<s.size() && is_num(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nint dfs(int i){\n  if(i==s.size()){\n    int res;\n     try{\n       int p=0;\n       res=formula(p);\n     }catch(const char* &e){\n       res=-1;\n      }\n    return res;\n  }\n  else if(s[i]=='.'){\n    const string ch=\"01+-*()\";\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      int ret=dfs(i+1);\n      res=max(ret,res);\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\n\t\tif (val >= 1024)return -1;\n\t\tif (val < 0)return -1;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t\tif (val >= 1024)return - 1;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num])){\n\t\tn = n * 2 + s[num++] - '0';\n\t\tif (n >= 1024)return -1;\n\t}\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tbool op = false;\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t\tif (sc.top() == '0')op = true;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t\t\tif (!op)return;\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*'){\n\t\t\t\tif (sc.empty() || sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\tsc.push('0');\n\t\t\t}\n\t\t\tif (s[i] == '1' || s[i] == '0' )\n\t\t\t\tsc.push('1');\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.empty()||sc.top() == '1'){\n\t\t\tans = expr(s, num);\n\t\t\tma = max(ma, ans);\n\t\t}\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint formula(int &p,bool inper);\npair<int,bool> term1(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint calc(int lhs,int rhs,char op){\n  if(lhs==-1 || rhs==-1) return -1;\n  if(op=='+') return lhs+rhs;\n  if(op=='-') return lhs-rhs;\n  if(op=='*') return lhs*rhs; \n}\n\nstring s;\nint formula(int &p,bool inper=false){\n  bool isok=!inper;\n  pair<int,bool> ret=term1(p);\n  int res=ret.first;\n  isok|=ret.second;\n  while(p<s.size() && s[p]!=')'){\n    inper=false;\n    char op=s[p];\n    if(op!='+' && op!='-'){\n      return -1;\n    }\n    isok=true;\n    p++;\n    int rhs=term1(p).first;\n    res=calc(res,rhs,op);\n  }\n  return isok ? res : -1;\n}\n\npair<int,bool> term1(int &p){\n  int res=term2(p);\n  bool res2=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;\n    if(op!='*'){\n      return {-1,0};\n    }\n    res2=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,res2};\n}\n\nint term2(int &p){\n int res=1;\n  if(s[p]=='('){\n    p++;\n    res=formula(p,true);\n    p++;\n  }\n  else if(isdigit(s[p])){\n    res=get_num(p);\n  }\n  else{\n    return -1;\n  }\n  return res;\n}\n\nint get_num(int &p){\n  int res=0;\n  while(isdigit(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  //cout<<res<<endl;\n  return res;\n}\n\nstring ch=\"01+-*()\";\n\nint dfs(int i){\n  if(i==s.size()){\n    int p=0;\n    //cout<<s<<endl;\n    int res=formula(p);\n    //cout<<res<<endl;\n    return res;\n  }\n  if(s[i]=='.'){\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      res=max(res,dfs(i+1));\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  vector<int> sec;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nint formula(int, int);\nstring s;\nvector<int> idx;\n\nint binary_to_int(const string& binary) {\n\tint res = 0, x = 1, n = binary.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(binary[n - 1 - i] == '1')\n\t\t\tres += x;\n\n\t\telse if(binary[n - 1 - i] != '0')\n\t\t\treturn -1;\n\n\t\tx <<= 1;\n\t}\n\n\treturn res;\n}\n\nint factor(int l, int r) {\n\tif(l == r)\n\t\treturn -1;\n\n\tif(s[l] == '(' && s[r - 1] == ')') {\n\t\tfor(int i = l + 1; i < r - 1; ++i)\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\treturn formula(l + 1, r - 1);\n\t}\n\n\treturn binary_to_int(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && s[i] == '*') {\n\t\t\tint vl = factor(l, i), vr = factor(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\treturn vl * vr;\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\tint vl = term(l, i), vr = term(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn vl + vr;\n\n\t\t\telse\n\t\t\t\treturn vl - vr;\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nint dfs(int d = 0) {\n\tif(d == idx.size()) {\n\t\tconst int res = formula(0, s.size());\n\t\treturn res >= 1024 ? -1 : res;\n\t}\n\n\tint res = -1;\n\tstatic const char c[7] = {'0', '1', '*', '+', '-', '(', ')'};\n\tfor(int i = 0; i < 7; ++i) {\n\t\ts[idx[d]] = c[i];\n\t\tchmax(res, dfs(d + 1));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tidx.push_back(i);\n\n\tcout << dfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s, tmp, let = \"01+-*()\";\nvi v;\nint n, p, ans;\n\nbool range(int t)\n{\n\treturn t >= 0 && t < (1 << 10);\n}\n\nint num()\n{\n\tint res = 0;\n\twhile (p < n && isdigit(tmp[p]))\n\t{\n\t\tres *= 2;\n\t\tres += tmp[p] - '0';\n\t\tp++;\n\t}\n\tif (!range(res)) return -1;\n\treturn res;\n}\n\npair<int, bool> plu();\n\nint unit()\n{\n\tint res;\n\tif (tmp[p] == '(')\n\t{\n\t\tp++;\n\t\tauto a = plu();\n\t\tif (a.first == -1 || a.second == false || tmp[p] != ')') return -1;\n\t\tres = a.first;\n\t\tp++;\n\t}\n\telse \n\t{ \n\t\tif (!isdigit(tmp[p])) return -1;\n\t\tres = num();\n\t}\n\tif (!range(res)) return -1;\n\telse return res;\n}\n\npair<int, bool> mul()\n{\n\tbool f = false;\n\tint res = unit();\n\tif (res == -1) return make_pair(-1, f);\n\twhile (tmp[p] == '*')\n\t{\n\t\tif (!range(res)) return make_pair(-1, f);\n\t\tf = true;\n\t\tp++;\n\t\tint rhs = unit();\n\t\tif (rhs == -1) return make_pair(-1, f);\n\t\tres *= rhs;\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\npair<int, bool> plu()\n{\n\tauto a = mul();\n\tint res = a.first;\n\tbool f = a.second;\n\tif (res == -1) return make_pair(-1, f);\n\twhile (tmp[p] == '+' || tmp[p] == '-')\n\t{\n\t\tif (!range(res)) return make_pair(-1, f);\n\t\tf = true;\n\t\tif (tmp[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres += rhs;\n\t\t}\n\t\telse if (tmp[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres -= rhs;\n\t\t}\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\nint parse()\n{\n\tp = 0;\n\tint res = plu().first;\n\tif (p != tmp.size()) return -1;\n\telse return res;\n}\n\nbool check1()\n{\n\tbool res = true;\n\tREP(i, tmp.size()) if (!isdigit(tmp[i])) res = false;\n\treturn res;\n}\n\nbool check2()\n{\n\tbool res;\n\tstring elem; //0 = number, 1 = operator, 2 = '('\n\tREP(i, tmp.size())\n\t{\n\t\tif (isdigit(tmp[i]))\n\t\t{\n\t\t\twhile (isdigit(tmp[i])) i++;\n\t\t\ti--;\n\t\t\telem.push_back('0');\n\t\t}\n\t\telse if (tmp[i] == '+' || tmp[i] == '-' || tmp[i] == '*')\n\t\t{\n\t\t\telem.push_back('1');\n\t\t}\n\t\telse if (tmp[i] == '(') elem.push_back('(');\n\t\telse if (tmp[i] == ')') elem.push_back(')');\n\t\telse assert(false);\n\t}\n\tif (elem.size() > 2)\n\t{\n\t\tREP(i, elem.size() - 2)\n\t\t{\n\t\t\tif (elem[i] == '('&&elem[i + 1] == '0'&&elem[i + 2] == ')') return false;\n\t\t}\n\t}\n\tif (elem.size() > 1)\n\t{\n\t\tREP(i, elem.size() - 1)\n\t\t{\n\t\t\tif (elem[i] == '('&&elem[i + 1] == ')') return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\nvoid solve(int i, vi w)\n{\n\tif (i == v.size())\n\t{\n\t\ttmp = s;\n\t\tREP(i, v.size())\n\t\t{\n\t\t\ttmp[v[i]] = let[w[i]];\n\t\t}\n\t\tp = 0;\n\t\tif (check1())\n\t\t{\n\t\t\tint res = num();\n\t\t\t//if (res >= 0) cout << tmp << endl;\n\t\t\tchmax(ans, res);\n\t\t}\n\t\telse if (check2())\n\t\t{\n\t\t\tint res = parse();\n\t\t\t//if (res >= 0) cout << tmp << endl;\n\t\t\tchmax(ans, res);\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, 7)\n\t\t{\n\t\t\tvi tmp = w;\n\t\t\ttmp.push_back(j);\n\t\t\tsolve(i + 1, tmp);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tans = -1;\n\tcin >> s;\n\tn = s.size();\n\tREP(i, n)\n\t{\n\t\tif (s[i] == '.') v.push_back(i);\n\t}\n\tvi emp;\n\tsolve(0, emp);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2428.cc: Lost Number\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 5;\nconst int MIN_D = 0;\nconst int MAX_D = (1 << 10) - 1;\n\nconst int CN = 7;\nconst char chs[CN] = { '0', '1', '+', '-', '*', '(', ')' };\n\n/* typedef */\n\n/* global variables */\n\nint ps[MAX_N], cnts[MAX_N];\n\n/* subroutines */\n\nint num(string &s, int &pos);\nint coef(string &s, int &pos);\nint term(string &s, int &pos);\nint expr(string &s, int &pos);\n\nint num(string &s, int &pos) {\n  if (pos >= s.size() || (s[pos] != '0' && s[pos] != '1')) return -1;\n  int num = 0;\n  while (pos < s.size() && s[pos] >= '0' && s[pos] <= '1') {\n    num = 2 * num + s[pos++] - '0';\n    if (num > MAX_D) return -1;\n  }\n  return num;\n}\n\nint coef(string &s, int &pos) {\n  if (pos >= s.size()) return -1;\n\n  if (s[pos] == '(') {\n    pos++; // '('\n\n    bool ok = false;\n    for (int i = pos; i < s.size() && s[i] != ')'; i++)\n      if (s[i] != '0' && s[i] != '1') {\n\tok = true;\n\tbreak;\n      }\n    if (! ok) return -1;\n\n    int e = expr(s, pos);\n    if (pos >= s.size() || s[pos] != ')') return -1;\n    pos++; // ')'\n    return e;\n  }\n\n  return num(s, pos);\n}\n\nint term(string &s, int &pos) {\n  if (pos >= s.size()) return -1;\n  int c0 = coef(s, pos);\n  if (c0 < 0) return -1;\n\n  while (pos < s.size() && s[pos] == '*') {\n    pos++; // '*'\n    int c1 = coef(s, pos);\n    if (c1 < 0) return -1;\n\n    c0 *= c1;\n    if (c0 < MIN_D || c1 > MAX_D) return -1;\n  }\n\n  return c0;\n}\n\nint expr(string &s, int &pos) {\n  if (pos >= s.size()) return -1;\n  int t0 = term(s, pos);\n  if (t0 < 0) return -1;\n\n  while (pos < s.size() && (s[pos] == '+' || s[pos] == '-')) {\n    char op = s[pos++]; // '+' || '-'\n    int t1 = term(s, pos);\n    if (t1 < 0) return -1;\n\n    t0 = (op == '+') ? t0 + t1 : t0 - t1;\n    if (t0 < MIN_D || t0 > MAX_D) return -1;\n  }\n\n  return t0;\n}\n\n/* main */\n\nint main() {\n  string s;\n  cin >> s;\n  int l = s.size();\n\n  int n = 0;\n  for (int i = 0; i < l; i++)\n    if (s[i] == '.') ps[n++] = i;\n  //printf(\"n=%d\\n\", n);\n\n  int maxd = -1;\n\n  for (;;) {\n    for (int i = 0; i < n; i++)\n      s[ps[i]] = chs[cnts[i]];\n    //cout << s << endl;\n\n    int pos = 0;\n    int d = expr(s, pos);\n    if (maxd < d) maxd = d;\n    \n    int k = 0;\n    while (k < n) {\n      if (++cnts[k] < CN) break;\n      cnts[k++] = 0;\n    }\n    if (k >= n) break;\n  }\n\n  printf(\"%d\\n\", maxd);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define IS_OPE(c) (c == '+' || c == '-' || c == '*')\n#define IS_NUM(c) (c == '0' || c == '1')\n\nstring s;\nint cur;\nvector<int> comm;\n\nconst char* code = \"01+-*()\";\n\nint num() {\n  int res = 0;\n  while(cur < s.size()) {\n    char c = s[cur];\n    if(!IS_NUM(c)) break;\n    res = 2*res + (c - '0');\n    ++cur;\n  }\n  return res;\n}\n\nint exp(bool *f_op);\n\nint ident() {\n  char c = s[cur];\n  if(IS_NUM(c)) {\n    return num();\n  } else if(c == '('){\n    ++cur;\n    bool d = true;\n    int res = exp(&d);\n    if(s[cur++] != ')') {\n      return -1;\n    }\n    return res;\n  } else {\n    return -1;\n  }\n}\n\nint prod(bool *f_op) {\n  char c;\n  int res = 1;\n  while(1) {\n    int v = ident();\n    if(v < 0) return -1;\n    res *= v;\n    if(res < 0 || (1<<10) <= res) return -1;\n    if(cur >= s.size() || (c=s[cur]) != '*') {\n      break;\n    }\n    *f_op = false;\n    ++cur;\n    if(cur >= s.size()) {\n      return -1;\n    }\n  }\n  return res;\n}\n\nint exp(bool *f_op) {\n  char c = '+';\n  int res = 0;\n  while(1) {\n    int v = prod(f_op);\n    if(v < 0) return -1;\n    res += (c == '+' ? v : -v);\n    if(res < 0 || (1<<10) <= res) return -1;\n    if(cur >= s.size() || !(c = s[cur]) || (c != '+' && c != '-')) {\n      break;\n    }\n    *f_op = false;\n    ++cur;\n    if(cur >= s.size()) {\n      return -1;\n    }\n  }\n  if(*f_op) {\n    return -1;\n  }\n\n  return res;\n}\n\nint parse() {\n  // check\n  int pa = 0;\n  rep(i, s.size()) {\n    if(s[i] == '(') ++pa;\n    if(s[i] == ')') --pa;\n  }\n  if(pa != 0) return -1;\n\n  rep(i, s.size()-1) {\n    if(IS_OPE(s[i]) && IS_OPE(s[i+1])) return -1;\n  }\n  cur = 0;\n\n  bool d = false;\n\n  return exp(&d);\n}\n\nint dfs(int c) {\n  if(comm.size() == c) {\n    return parse();\n  }\n  int res = -1;\n  rep(i, 7) {\n    s[comm[c]] = code[i];\n    int r = dfs(c + 1);\n    res = maxd(r, res);\n  }\n  return res;\n}\n\nint main() {\n  cin >> s;\n  rep(i, s.length()) {\n    if(s[i] == '.') {\n      comm.push_back(i);\n    }\n  }\n  cout << dfs(0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n#define int long long \n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res -= term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }\n    }\n    if(res<0||res>=1024){\n        ppppp = 1;\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            \n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nsigned main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                cout << -1<< endl;\n            }else{\n                cout << expr(pos) << endl;\n            }\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\n\t\tif (val >= 1024)return -1;\n\t\tif (val < 0)return -1;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t\tif (val >= 1024)return - 1;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num])){\n\t\tn = n * 2 + s[num++] - '0';\n\t\tif (n>=1024)return -1;\n\t}\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\tsc.push('0');\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.empty()||sc.top() == '0'){\n\t\t\tans = expr(s, num);\n\t\t\tma = max(ma, ans);\n\t\t}\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(e.first<0||!e.second||s[x]!=')')return fail;\n    x++;\n    return make_pair(e.first,false);\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      if(n>=1<<10)return fail;\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(f.first<0)return f;\n  while(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(l.first<0)return l;\n    f.first*=l.first;\n    f.second=true;\n  }\n  return f;\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(f.first<0)return f;\n  while(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(l.first<0)return l;\n    f.first+=sign*l.first;\n    f.second=true;\n  }\n  return f;\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tm=max(m,dfs());\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nchar S[111];\n\nint number(int l,int r){\n  int ret = 0;\n  for(int i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n  }\n \n  return ret;\n}\n\n\nint check(int x){\n  if( 0 <= x && x < (1<<10) ) return x;\n  return -1;\n}\n\nbool check_k(int l,int r){\n  int cnt =0;\n  if( l==r ) return false;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n\nbool check_m(int l,int r){\n  int cnt =0;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n\nbool check_w(int l,int r){\n  int cnt =0;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n\n\nvoid view(int l,int r){\n  for(int i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n\nint exp(int l,int r){\n  //view(l,r);\n  if( check_k(l,r) ) return check(exp(l+1,r-1));\n  if( check_w(l,r) ) {\n    int cnt = 0;\n    for(int i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return check(exp(l,i-1) + exp(i+1,r));\n      if( cnt == 0 && S[i] == '-' ) return check(exp(l,i-1) - exp(i+1,r));\n    }\n  }\n  if( check_m(l,r) ) {\n    int cnt = 0;\n    for(int i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return check(exp(l,i-1) * exp(i+1,r));\n    }\n  }\n\n  return check(number(l,r));\n}\n\nint  main(){\n  cin >> S;\n  N  = strlen(S);\n  int M = 0;\n  for(int i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  int res = -1;\n  for(int i=0;i<(1<<M);i++){\n    int c = 0;\n    strcpy( S, buf );\n    for(int j=0;j<N;j++){\n      if( S[j] == '.' ){\n\tif( i & (1<<c) )\n\t  S[j] = '1';\n\telse\n\t  S[j] = '0';\n      }    \n    }\n    //cout << S<< endl;\n    res = max( res, exp(0,N-1) );\n  }\n  cout << res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 9;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  if(*result >= 1024) return false;\n  \n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseVaule(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  if(find(temp, it, '+')==it && find(temp, it, '*')==it && find(temp, it, '-')==it ){\n    return false;\n  }\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseVaule(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseVaule(it, &rv)) return false;\n    *result *= rv;\n    if(*result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool ope, err;\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\tope=false;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\tp++;\n\t\t\n\t\tif (!ope) err=true;\n\t\treturn res;\n\t} else {\n\t\treturn number(s);\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tope = true;\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\t\n\twhile (s[p] == '+' || s[p] == '-') {\n\t\tope = true;\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += expression(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= expression(s);\n\t\t}\n\t}\n\t\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\treturn res;\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tint res = expression(s);\n\t\tif (res>1024) res=-1;\n\t\t//cerr << \"Persing : \" << s << endl;\n\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nll MOD=1000000007;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;Cursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(bool blacket){\n\t\t\tll l=term();int opc=0;\n\t\t\twhile(*c=='+' || *c=='-'){\n\t\t\t\topc++;\n\t\t\t\tif(*c=='+'){\n\t\t\t\t\tc++;l+=term();\n\t\t\t\t}else{\n\t\t\t\t\tc++;l-=term();\n\t\t\t\t}\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\tif(blacket && opc==0)throw ParseError();\n\t\t\treturn l;\n\t\t}\n\t\tll term(){\n\t\t\tll l=factor();\n\t\t\twhile(*c=='*'){\n\t\t\t\tc++;l*=factor();\n\t\t\t    if(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll factor(){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;\n\t\t\t\tll v=expression(true);\n\t\t\t\tif(*c!=')') throw ParseError();\n\t\t\t\tc++;\n\t\t\t\treturn v;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\treturn number();\n\t\t\t}else{\n\t\t\t\tthrow ParseError();\n\t\t\t}\n\t\t}\n\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t\t\tss << *c;c++;\n\t\t    }\n\t\t    string str;ss>>str;\n\t\t    ll res=0;\n\t\t    REP(i,str.size()){\n\t\t\t\tres*=2;if(str[i]=='1')res++;\n\t\t\t\tif(!IN(0,res,1<<10)) throw ParseError();\n\t\t    }\n\t\t    if(!IN(0,res,1<<10)) throw ParseError();\n\t\t\treturn res;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nchar symb[7]={'0','1','+','-','*','(',')'};\n\nclass Main{\npublic:\n\tstring s;\t\t\n\tbool input(){\n\t\tgetline(cin,s);\n\t\ts.erase(remove(ALL(s), ' '), s.end());//空白除去\n\t\treturn true;\n\t}\n\n\tll dfs(int i){\n\t\tll Mv=-1;\n\t\tif(i==s.size()){\n\t\t\ttry{\n\t\t\t\tCursor c=s.begin();\n\t\t\t\tSyntax sy(s,c);\n\t\t\t\tll res=sy.expression(false);\n\t\t\t\tif(c!=s.end())throw ParseError();\n\t\t\t\treturn res;\n\t\t\t}catch(ParseError e){return -1;}\n\t\t}\n\t\tif(s[i]=='.'){\n\t\t\tREP(j,7){\n\t\t\t\ts[i]=symb[j];\n\t\t\t\tMv=max(Mv,dfs(i+1));\n\t\t\t\ts[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tMv=max(Mv,dfs(i+1));\n\t\t}\n\t\treturn Mv;\n\t}\n\n\tvoid run(){\n\t\tinput();\n\t\tcout << dfs(0)<<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 30;\n  unsigned long long sum_bin = (*it - '0') << max_length;\n  \n  int length = 1;\n  while(true){\n    if(it+length==end || (*(it+length)!='0' && *(it+length)!='1')) break;\n    sum_bin += (*(it+length) - '0') << (max_length-length);\n    ++length;\n  }\n  sum_bin >>= max_length-length + 1;\n  if(sum_bin >= 1024) return false;\n  \n  *result = sum_bin;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  \n  unsigned long long lv = *result;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    lv *= rv;\n    if(lv >= 1024) return false;\n  }\n  *result = lv;\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  \n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring cs=\"01+-*()\";\nstring s;\nint n;\n\nint f(int l,int r){\n  if(r<=l)return -1;\n  bool isn=true;\n  repl(i,l,r)if(!isdigit(s[i]))isn=false;\n  if(isn){\n    int res=0;\n    repl(i,l,r){\n      res*=2;\n      res+=s[i]-'0';\n    }\n    if(res>=pow(2,10)) return -1;\n    else return res;\n  }\n\n  bool ok=false;\n  int lev=0;\n  {\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(lev==0)ok=true;\n      if(s[i]==')')lev--;\n    }\n  }\n  if(lev!=0)return -1;\n  if(!ok){\n    bool dame=true;\n    lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&(s[i]=='+'||s[i]=='-'||s[i]=='*'))dame=false;\n    }\n    if(dame)return -1;\n    else return f(l+1,r-1);\n  }\n\n  lev=0;\n  int res=0;\n  int pre=l,preop=0;\n  repl(i,l,r){\n    if(s[i]=='(')lev++;\n    if(s[i]==')')lev--;\n    if(lev==0&&(s[i]=='+'||s[i]=='-')){\n      int v=f(pre,i);\n      if(v==-1)return -1;\n      if(preop==0)res+=v;\n      else res-=v;\n      if(res<0||res>=pow(2,10))return -1;\n      pre=i+1;\n      preop=(s[i]=='+'?0:1);\n    }\n  }\n  if(pre!=l){\n    int v=f(pre,r);\n    if(v==-1)return -1;\n    if(preop==0)res+=v;\n    else res-=v;\n    if(res<0||res>=pow(2,10))return -1;\n    else return res;\n  }\n\n  lev=0;\n  res=1;\n  repl(i,l,r){\n    if(s[i]=='(')lev++;\n    if(s[i]==')')lev--;\n    if(lev==0&&s[i]=='*'){\n      int v=f(pre,i);\n      res*=v;\n      if(v==-1||res>=pow(2,10))return -1;\n      pre=i+1;\n    }\n  }\n  if(pre!=l){\n    int v=f(pre,r);\n    res*=v;\n    if(v==-1||res>=pow(2,10))return -1;\n    return res;\n  }\n  return -1;\n}\n\nint dfs(int i){\n  if(i==n){\n    return f(0,n);\n  }else{\n    if(s[i]=='.'){\n      int res=-1;\n      rep(j,7){\n        s[i]=cs[j];\n        int tmp=dfs(i+1);\n        maxch(res,tmp);\n      }\n      s[i]='.';\n      return res;\n    }else{\n      return dfs(i+1);\n    }\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc {\n  private:\n    int N, idx;\n    string s;\n    \n  public:\n    Calc (const string& s) : s{s} {\n        idx = 0;\n        N = s.size();\n    }\n\n    static bool is_op(char c)\n    {\n        return (c == '+' || c == '-' || c == '*');   \n    }\n\n    bool check_range(int x)\n    {\n        return (0 <= x && x < 1024);\n    }\n    \n    int num()\n    {\n        int res = 0, p = 0;\n        while (isdigit(s[idx])) {\n            if (p > 10 && s[idx] == '1') return -1;\n            res *= 2;\n            res += (s[idx] - '0');\n            p++;\n            ++idx;\n        }        \n        return (check_range(res) ? res : -1);\n    }\n\n    bool check_op(int cur)\n    {\n        int p = 0;\n        for (int i = cur + 1; i < N; i++) {\n            if (s[i] == '(') p++;\n            if (s[i] == ')') p--;\n            if (p == 0 && is_op(s[i])) return 1;\n            if (p < 0) break;\n        }\n        return 0;\n    }\n    \n    int fact()\n    {\n        int ret = -1;\n        if (s[idx] == '(') {\n            if (!check_op(idx)) throw 0;\n            ++idx;\n            ret = expr();\n            if (!check_range(ret)) throw 0; \n            ++idx;\n        } else {\n            ret = num();\n        }\n        return ret;\n    }\n\n    int term()\n    {\n        int ret = fact();\n        while (s[idx] == '*') {\n            ++idx;\n            ret *= fact();\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n\n    int expr()\n    {\n        int ret = term();\n\n        while (s[idx] == '+' || s[idx] == '-') {\n            if (s[idx] == '+') {\n                ++idx;\n                ret += term();\n            } else {\n                ++idx;\n                ret -= term();\n            }\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n};\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid(const string& s)\n{\n    int p = 0, N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (Calc::is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || Calc::is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || Calc::is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n\n        if (s[i] == '(') {\n            if (i == N - 1) return 0;\n            if (i > 0 && isdigit(s[i - 1])) {\n                return 0;\n            }\n        }\n        \n        if (s[i] == ')') {\n            if (i == 0) return 0;\n            if (i < N - 1 && isdigit(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n\n        for (int j = i + 1; j < N; j++) {\n            if (s[i] == '(' && s[j] == ')' && j - i < 4) {\n                return 0;\n            }\n        }\n    }\n    return (p == 0);\n}\n\nint solve(string& s)\n{\n    int N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        Calc calc(s);\n        int res = -1;\n        \n        try {\n            res = calc.expr();\n        } catch (...) {}\n        \n        return res;\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid(s)) {\n            Calc calc(s);\n            try {\n                res = max(res, calc.expr());\n            } catch (...) {}\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    cout << solve(s) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef string::iterator State;\nclass ParseError {};\nint op_cnt;\n\nint ParseExpression(State &itr);\n\nint ParseNumber(State &itr) {\n  int ret = 0;\n  if (*itr != '0' && *itr != '1') throw ParseError();\n\n  while (*itr == '0' || *itr == '1') {\n    ret = ret*2 + (*itr-'0');\n    if (ret >= 1024) throw ParseError();\n    itr++;\n  }\n  return ret;\n}\n\nint ParseFactor(State &itr) {\n  if (*itr == '(') {\n    itr++;\n    int op_cnt_ = op_cnt;\n    int ret = ParseExpression(itr);\n    if (op_cnt_ == op_cnt) throw ParseError();\n    if (*itr != ')') throw ParseError();\n    itr++;\n    return ret;\n  }\n  \n  //op_cnt++;\n  return ParseNumber(itr);\n}\n\nint ParseTerm(State &itr) {\n  int ret = ParseFactor(itr);\n  \n  if (*itr == '*') {\n    itr++;\n    ret *= ParseFactor(itr);\n    if (ret >= 1024) throw ParseError();\n    op_cnt++;\n  } \n\n  return ret;\n}\n\nint ParseExpression(State &itr) {\n  int ret = ParseTerm(itr);\n  if (*itr == '+') {\n    itr++;\n    ret += ParseTerm(itr);\n    if (ret >= 1024) throw ParseError();\n    op_cnt++;\n  } else if (*itr == '-' ) {\n    itr++;\n    ret -= ParseTerm(itr);\n    if (ret < 0) throw ParseError();\n    op_cnt++;\n  }\n  return ret;\n}\n\nint n;\nint ans = -1;\nchar cs[] = \"01+-*().\";\nchar buf[114514];\nstring s;\nvector<int> pos;\n\nvoid rec(int idx) {\n  if (n <= idx) {\n    auto itr = s.begin();\n    try {\n      int ret = ParseExpression(itr);\n      if (itr != s.end()) throw ParseError();\n      ans = max(ans, ret);\n    } catch (const ParseError &e) {}\n    return;\n  }\n\n  for (int i=0; i<8; i++) {\n    s[pos[idx]] = cs[i];\n    rec(idx+1);\n  }\n}\n\nint main() {\n  scanf(\"%s\", buf);\n  s = buf;\n  while (1) {\n    int idx = s.find('.');\n    if (idx == string::npos) break;\n    pos.emplace_back(idx);\n    s[idx] = '$';\n    n++;\n  }\n\n  ans = -1;\n  rec(0);\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nclass ParseError {};\nstruct Result{\n  int value, p;\n  Result(int v, int p) : value(v), p(p) {}\n};\nvoid skip(const string& s, Result& r, char expected){\n  if(!(0 <= r.p && r.p < s.size())){\n    //cerr << r.p << \" is out range of \" << s << endl;\n    throw ParseError();\n  }else if(s[r.p] != expected){\n    //cerr << \"Expected '\" << expected << \"' but got '\" << s[r.p] << \"'\" << endl;\n    //cerr << \"String is '\" << s.substr(0, r.p) << \"*\" << s.substr(r.p + 1) << \"'\" << endl;;\n    throw ParseError();\n  }else {\n    r.p ++;\n  }\n}\nvoid checkvalue(int x){\n  if(x < 0 || x > 1<<10) throw ParseError();\n}\nint checkpara(const string& s, int p){\n  bool invalid = true;\n  while(p < s.size()){\n    if(s[p] == '('){\n      p = checkpara(s, p + 1);\n    }else if(s[p] == ')'){\n      break;\n    }else if(!isdigit(s[p])){\n      invalid = false;\n    }\n    p++;\n  }\n  if(invalid) throw ParseError();\n  return p;\n}\nResult equation(const string& s, int p);\nResult factor(const string& s, int p);\nResult term(const string& s, int p);\nResult equation(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (s[r.p] == '+' || s[r.p] == '-')){\n    char c = s[r.p];\n    Result r2 = factor(s, r.p + 1);\n    r.value += (c == '+') ? r2.value : -r2.value;\n    r.p = r2.p;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  Result r = term(s, p);\n  while(r.p < s.size() && s[r.p] == '*'){\n    Result r2 = term(s, r.p + 1);\n    r.value *= r2.value;\n    r.p = r2.p;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  if(s[p] == '('){\n    checkpara(s, p + 1);\n    Result r = equation(s, p + 1);\n    skip(s, r, ')');\n    checkvalue(r.value);\n    return r;\n  }else if(isdigit(s[p])){\n    int value = 0;\n    while(isdigit(s[p]) && p < s.size()){\n      value = (value << 1) + (s[p++] - '0');\n    }\n    checkvalue(value);\n    return Result(value, p);\n  }else {\n    throw ParseError();\n  }\n}\nstring cand = \"01+-*()\";\nint dfs(int k, vector<int>& index, string& s){\n  if(k == index.size()){\n    try{\n      Result r = equation(s, 0);\n      if(r.p != s.size()) r.value = -INF;\n      //cout<<s<<\" is \"<<r.value<<endl;\n      return r.value;\n    }catch(...){\n      //cout<<s<<\" is invalid.\"<<endl;\n      return -INF;\n    }\n  }else{\n    int res = -INF;\n    REP(i, cand.size()){\n      s[index[k]] = cand[i];\n      res = max(res, dfs(k + 1, index, s));\n    }\n    return res;\n  }\n}\n\nint main(){\n  string s;\n  while(cin>>s){\n    vector<int> index;\n    REP(i, s.size()) if(s[i] == '.') index.push_back(i);\n    int ans = dfs(0, index, s);\n    if(ans == -INF) ans = -1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n\nconst int MAX = 1023;\nconst int MIN = 0;\nchar ch[] = {\n  '0', '1', '+', '-', '*', '(', ')',\n};\nsize_t cur;\nstring str;\n\nint E(int &op_cnt);\n\nint number(){\n  int res = 0;\n  while(cur < str.size() && isdigit(str[cur])){\n    res = res * 2 + str[cur++] - '0';\n    if(res > MAX) return -1;\n  }\n  return res;\n}\n\nint T(){\n  int res;\n  if(isdigit(str[cur])){\n    res = number();\n  }else if(str[cur] == '('){\n    int cnt = 0;\n    cur++;\n    if(cur == str.size()) return -1;\n    res = E(cnt);\n    if(cur == str.size() || str[cur] != ')' || cnt == 0) res = -1;\n    cur++;\n  }else{\n    res = -1;\n  }\n  return res;\n}\n\nint F(int &op_cnt){\n  int res = 1;\n  vector<int> v;\n  v.push_back(T());\n  \n  while(cur < str.size() && str[cur] == '*'){\n    cur++;\n    op_cnt++;\n    if(cur == str.size()) return -1;\n    int tmp = T();\n    if(tmp < 0) return -1;\n    v.push_back(tmp);\n  }\n  \n  rep(i, v.size()){\n    res *= v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  return res;\n}\n\nint E(int &op_cnt){\n  int res = 0, tmp;\n  vector<int> v;\n  tmp = F(op_cnt);\n  \n  if(tmp < 0) return -1;\n  else v.push_back(tmp);\n  \n  while(cur < str.size() && (str[cur] == '+' || str[cur] == '-')){\n    char op = str[cur];\n    op_cnt++;\n    cur++;\n    if(cur == str.size()) return -1;\n    tmp = F(op_cnt);\n    if(tmp < 0) return -1;\n    else v.push_back(op == '+' ? tmp : -tmp);\n  }\n  \n  //cout << str << \" \" << cur << \" \" << op_cnt << endl;\n  if(cur < str.size() && str[cur] != ')') return -1;\n  \n  rep(i, v.size()){\n    res += v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  //cout << res << endl;\n  return res;\n}\n\nint calc(string s){\n  int cnt = 0;\n  str = s;\n  cur = 0;\n  return E(cnt);\n}\n\nint dfs(string s, int c){\n  if(c == 0) return calc(s);\n  \n  int res = -1;\n  int pos = find(s.begin(), s.end(), '.') - s.begin();\n  \n  rep(i, 7){\n    s[pos] = ch[i];\n    res = max(res, dfs(s, c - 1));\n    s[pos] = '.';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  cout << dfs(s, count(s.begin(), s.end(), '.')) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstring s;\nint n;\nvector<int> dot;\nint D;\n\nll ans = -1;\nconst ll LIM = 1<<10;\n\nbool err;\n\nll E(int l, int r);\n\nll N(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    ll ret = 0;\n    for(int i=l; i<=r; ++i){\n        if(ret>=LIM || (s[i]!='0' && s[i]!='1')){\n            err = true;\n            return 0;\n        }\n        ret = ret*2 + s[i]-'0';\n    }\n    return ret;\n}\n\n// <expression> <operation> <expression>\nll O(int l, int r){\n    char op = '?';\n    int pos = -1;\n\n    int b = 0;\n    for(int i=r; i>=l; --i){\n        b += (s[i]=='(');\n        b -= (s[i]==')');\n\n        if(b==0){\n            if(s[i]=='+' || s[i]=='-'){\n                op = s[i];\n                pos = i;\n                break;\n            }\n        }\n    }\n\n    if(pos == -1){\n        b = 0;\n        for(int i=r; i>=l; --i){\n            b += (s[i]=='(');\n            b -= (s[i]==')');\n\n            if(b==0){\n                if(s[i]=='*'){\n                    op = s[i];\n                    pos = i;\n                    break;\n                }\n            }\n        }\n    }\n\n    if(op == '?'){\n        err = true;\n        return 0;\n    }\n\n    ll x = E(l,pos-1), y = E(pos+1,r);\n    ll ret;\n    if(op == '+') ret = x+y;\n    else if(op == '-') ret = x-y;\n    else if(op == '*') ret = x*y;\n\n    if(ret<0 || ret>=LIM) err = true;\n    return ret;\n\n}\n\nll E(int l, int r){\n    if(l>r){\n        err = true;\n        return 0;\n    }\n\n    if(s[l]=='('){\n        if(s[r]!=')'){\n            err = true;\n            return 0;\n        }\n\n        return O(l+1, r-1);\n    }\n\n    bool found = false;\n    for(int i=l; i<=r; ++i){\n        if(s[i]=='+' || s[i]=='-' || s[i]=='*') found = true;\n    }\n\n    ll ret;\n    if(found) ret = O(l,r);\n    else ret = N(l,r);\n    if(ret<0 || ret>=LIM) err = true;\n    return ret;\n}\n\nconst string cand = \"01+-*()\";\nvoid dfs(int dep){\n    if(dep == D){\n        err = false;\n        ll res = E(0,n-1);\n        if(!err) ans = max(ans, res);\n        return;\n    }\n\n    int idx = dot[dep];\n    rep(i,cand.size()){\n        s[idx] = cand[i];\n        dfs(dep+1);\n        s[idx] = '.';\n    }\n}\n\nint main(){\n    cin >>s;\n    n = s.size();\n\n    rep(i,n)if(s[i] == '.') dot.pb(i);\n    D = dot.size();\n\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc {\n  private:\n    int N, idx;\n    string s;\n    \n  public:\n    Calc (const string& s) : s{s} {\n        idx = 0;\n        N = s.size();\n    }\n\n    static bool is_op(char c)\n    {\n        return (c == '+' || c == '-' || c == '*');   \n    }\n\n    bool check_range(int x)\n    {\n        return (0 <= x && x < 1024);\n    }\n    \n    int num()\n    {\n        int res = 0, p = 0;\n        while (isdigit(s[idx])) {\n            if (p > 10 && s[idx] == '1') return -1;\n            res *= 2;\n            res += (s[idx] - '0');\n            p++;\n            ++idx;\n        }        \n        return (check_range(res) ? res : -1);\n    }\n\n    bool check_op(int cur)\n    {\n        int p = 0;\n        for (int i = cur + 1; i < N; i++) {\n            if (s[i] == '(') p++;\n            if (s[i] == ')') p--;\n            if (p == 0 && is_op(s[i])) return 1;\n            if (p < 0) break;\n        }\n        return 0;\n    }\n    \n    int fact()\n    {\n        int ret = -1;\n        if (s[idx] == '(') {\n            if (!check_op(idx)) throw 0;\n            ++idx;\n            ret = expr();\n            ++idx;\n        } else {\n            ret = num();\n        }\n        return ret;\n    }\n\n    int term()\n    {\n        int ret = fact();\n        while (s[idx] == '*') {\n            ++idx;\n            ret *= fact();\n        }\n        return ret;\n    }\n\n    int expr()\n    {\n        int ret = term();\n\n        while (s[idx] == '+' || s[idx] == '-') {\n            if (s[idx] == '+') {\n                ++idx;\n                ret += term();\n            } else {\n                ++idx;\n                ret -= term();\n            }\n        }\n        return ret;\n    }\n};\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid(const string& s)\n{\n    int p = 0, N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (Calc::is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || Calc::is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || Calc::is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n\n        for (int j = i + 1; j < N; j++) {\n            if (s[i] == '(' && s[j] == ')' && j - i < 4) {\n                return 0;\n            }\n        }\n    }\n    return (p == 0);\n}\n\nint solve(string& s)\n{\n    int N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        Calc calc(s);\n        int res = -1;\n        \n        try {\n            res = calc.expr();\n        } catch (...) {}\n        \n        return res;\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid(s)) {\n            Calc calc(s);\n            try {\n                res = max(res, calc.expr());\n            } catch (...) {}\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    cout << solve(s) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nstring s;\n\nstring op[2] = {\"*\", \"+-\"};\n\nint parse(int& i, int d)\n{\n\tif (d == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tint ret = parse(i, 0);\n\t\t\ti++;\n\t\t\tif (ret < 0) return -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ('0' <= s[i] && s[i] <= '1')\n\t\t{\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '1')\n\t\t\t{\n\t\t\t\tret = ret * 2 + s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ret = parse(i, d + 1);\n\n\t\twhile (op[d].find(s[i]) != string::npos)\n\t\t{\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '+': i++; ret += parse(i, d + 1); break;\n\t\t\tcase '*': i++; ret *= parse(i, d + 1); break;\n\t\t\tcase '-':\n\t\t\t\ti++;\n\t\t\t\tret -= parse(i, d + 1);\n\t\t\t\tif (ret < 0) return -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n}\n\nbool isvalid()\n{\n\tint cnt = 0;\n\tint flag = 0;\n\trep(j, 0, s.length())\n\t{\n\t\tif (s[j] == '(')\n\t\t{\n\t\t\tcnt++;\n\t\t\tflag = 1;\n\t\t}\n\t\telse if (s[j] == ')')\n\t\t{\n\t\t\tif (cnt == 0) return false;\n\t\t\tif (flag == 1) return false;\n\t\t\tcnt--;\n\t\t}\n\t\telse if (s[j] == '0' || s[j] == '1')\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag = 0;\n\t\t}\n\t}\n\tif (cnt != 0) return false;\n\n\trep(j, 0, s.length() - 1)\n\t{\n\t\tif (s[j] == '+' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '+' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '*') return false;\n\t\t\n\t}\n\n\tif (s[0] == '+') return false;\n\tif (s[0] == '-') return false;\n\tif (s[0] == '*') return false;\n\n\tif (s[s.length() - 2] == '+') return false;\n\tif (s[s.length() - 2] == '-') return false;\n\tif (s[s.length() - 2] == '*') return false;\n\n\treturn true;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t/*\n\ts = \"(1+1)=\";\n\tif (isvalid())\n\t\tcout << \"valid\" << endl;\n\telse\n\t\tcout << \"invalid\" << endl;\n\n\treturn 0;\n\t*/\n\n\tcin >> s; s += \"=\";\n\n\tvector<int> dots;\n\trep(j, 0, s.length()) if (s[j] == '.') dots.push_back(j);\n\n\tint nums[5];\n\tstring opes = \"01+-*()\";\n\tint ans = -1;\n\trep(j, 0, 100000)\n\t{\n\t\tint jj = j;\n\t\trep(k, 0, 5)\n\t\t{\n\t\t\tnums[k] = jj % 10;\n\t\t\tjj /= 10;\n\t\t}\n\t\tbool ok = false;\n\t\trep(k, 0, dots.size()) if (7 <= nums[k]) ok = true;\n\t\tif (ok) continue;\n\n\t\trep(k, 0, dots.size()) s[dots[k]] = opes[nums[k]];\n\n\t\tif (!isvalid()) continue;\n\n\t\tint i = 0;\n\t\tint ret = parse(i, 0);\n\t\tif (ans < ret)\n\t\t{\n\t\t\tans = ret;\n\t\t\t//cout << s << ret << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;Cursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(int& opc){\n\t\t\tll l=term(opc);\n\t\t\twhile(*c=='+' || *c=='-'){\n\t\t\t\topc++;\n\t\t\t\tif(*c=='+'){\n\t\t\t\t\tc++;l+=term(opc);\n\t\t\t\t}else{\n\t\t\t\t\tc++;l-=term(opc);\n\t\t\t\t}\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll term(int opc){\n\t\t\tll l=factor();\n\t\t\twhile(*c=='*'){\n\t\t\t\topc++;\n\t\t\t\tc++;l*=factor();\n\t\t\t    if(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll factor(){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;\n\t\t\t\tint opc=0;\n\t\t\t\tll v=expression(opc);\n\t\t\t\tif(*c!=')') throw ParseError();\n\t\t\t\tif(opc==0)throw ParseError();\n\t\t\t\tc++;\n\t\t\t\treturn v;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\treturn number();\n\t\t\t}else{\n\t\t\t\tthrow ParseError();\n\t\t\t}\n\t\t}\n\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t\t\tss << *c;c++;\n\t\t    }\n\t\t    string str;ss>>str;\n\t\t    ll res=0;\n\t\t    REP(i,str.size()){\n\t\t\t\tres*=2;if(str[i]=='1')res++;\n\t\t\t\tif(!IN(0,res,1<<10)) throw ParseError();\n\t\t    }\n\t\t    if(!IN(0,res,1<<10)) throw ParseError();\n\t\t\treturn res;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nchar symb[7]={'0','1','+','-','*','(',')'};\n\nclass Main{\npublic:\n\tstring s;\t\t\n\tbool input(){\n\t\tgetline(cin,s);\n\t\ts.erase(remove(ALL(s), ' '), s.end());//空白除去\n\t\treturn true;\n\t}\n\n\tll dfs(int i){\n\t\tll Mv=-1;\n\t\tif(i==s.size()){\n\t\t\ttry{\n\t\t\t\tCursor c=s.begin();Syntax sy(s,c);int opc=0;\n\t\t\t\tll res=sy.expression(opc);\n\t\t\t\t\n\t\t\t\tif(c!=s.end())throw ParseError();\n\t\t\t\treturn res;\n\t\t\t}catch(ParseError e){return -1;}\n\t\t}\n\t\tif(s[i]=='.'){\n\t\t\tREP(j,7){\n\t\t\t\ts[i]=symb[j];\n\t\t\t\tMv=max(Mv,dfs(i+1));\n\t\t\t\ts[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tMv=max(Mv,dfs(i+1));\n\t\t}\n\t\treturn Mv;\n\t}\n\n\tvoid run(){\n\t\tinput();\n\t\tcout << dfs(0)<<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int MAX = 1023;\nconst int MIN = 0;\nchar ch[] = {\n  '0', '1', '+', '-', '(', ')',\n};\nsize_t cur;\nstring str;\n\nint E(int &op_cnt);\n\nint number(){\n  int res = 0;\n  while(cur < str.size() && isdigit(str[cur])){\n    res = res * 2 + str[cur++] - '0';\n    if(res > MAX) return -1;\n  }\n  \n  return res;\n}\n\nint T(){\n  int res;\n  if(isdigit(str[cur])){\n    res = number();\n  }else if(str[cur] == '('){\n    int cnt = 0;\n    cur++;\n    res = E(cnt);\n    if(cur == str.size() || str[cur] != ')') return -1;\n    cur++;\n    if(cnt == 0) res = -1;\n  }else{\n    res = -1;\n    cur++;\n  }\n  return res;\n}\n\nint F(int &op_cnt){\n  int res = 1;\n  vector<int> v;\n  \n  v.push_back(T());\n  \n  while(cur < str.size() && str[cur] == '*'){\n    cur++;\n    op_cnt++;\n    if(cur == str.size()) return -1;\n    int tmp = T();\n    if(tmp < 0) return -1;\n    v.push_back(tmp);\n  }\n  \n  rep(i, v.size()){\n    res *= v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  return res;\n}\n\nint E(int &op_cnt){\n  \n  int res = 0;\n  int tmp;\n  vector<int> v;\n  \n  tmp = F(op_cnt);\n  if(tmp < 0) return -1;\n  else v.push_back(tmp);\n  \n  if(res == -1) return -1;\n  \n  while(cur < str.size() && (str[cur] == '+' || str[cur] == '-')){\n    char op = str[cur];\n    op_cnt++;\n    cur++;\n    if(cur == str.size()) return -1;\n      \n    tmp = F(op_cnt);\n    if(tmp < 0) return -1;\n    else v.push_back(op == '+' ? tmp : -tmp);\n  }\n  \n  cout << str << \" \" << cur << \" \" << op_cnt << endl;\n  if(cur < str.size() && str[cur] != ')') return -1;\n  cout << \"HOGE\" << endl;\n\n  rep(i, v.size()){\n    res += v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  cout << res << endl;\n  return res;\n}\n\nint calc(string s){\n  int cnt;\n  str = s;\n  cur = 0;\n  int res = E(cnt);\n  //cout << res << endl;\n  return res;\n  \n}\n\nint dfs(string s, int c){\n  if(c == 0){\n    return calc(s);\n  }\n  \n  int res = -1;\n  int pos = 0;\n  while(s[pos] != '.') pos++;\n  \n  rep(i, 6){\n    s[pos] = ch[i];\n    res = max(res, dfs(s, c - 1));\n    s[pos] = '.';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  int c = count(s.begin(), s.end(), '.');\n  cout << dfs(s, c) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nstring::iterator p;\nll fact();\nll term();\nll exp();\nll M=1LL<<10,l;\nbool f,ff[111];\n\nll fact() {\n  if(!f) return 1;\n  ll x;string num;\n  while(isdigit(*p)){num+=*p;++p;}\n  if(num.size()) {\n    int k=1;\n    x=0;\n    if(num.size()>20) f=0;\n    for(int i=num.size()-1; i>=0; i--) {\n      x+=(num[i]-'0')*k;\n      k*=2;\n    }\n    if(*p=='('||x<0||x>=M) f=0;\n  } else if(*p=='(') {\n    ++l;\n    ff[l]=0;\n    ++p;x=exp();\n    if(!ff[l])f=0;\n    ++p;--l;\n  } else f=0;\n  if(x<0||x>=M) f=0;\n  return x;\n}\n \nll term() {\n  if(!f) return 1;\n  ll x=fact();\n  if(*p=='+'&&*p=='-') f=0;\n  while(*p=='*'||*p=='/') {\n    ff[l]=1;\n    if(*p=='*') {\n      ++p;\n      x*=fact();\n      if(x<0||x>=M) f=0;\n    } else {\n      ++p;\n      x/=fact();\n      if(x<0||x>=M) f=0;\n    }\n  }\n  return x;\n}\n\nll exp() {\n  if(!f) return 1;\n  int x=term();\n  if(*p=='*'||*p=='/') f=0;\n  while(*p=='+'||*p=='-') {\n    ff[l]=1;\n    if(*p=='+') {\n      ++p;\n      x+=term();\n      if(x<0||x>=M) f=0;\n    } else {\n      ++p;\n      x-=term();\n      if(x<0||x>=M) f=0;\n    }\n  }\n  return x;\n}\n\nbool ck() {\n  int x=0;\n  for(int i=0; i<s.size(); i++) {\n    if(s[i]=='(') x++;\n    if(s[i]==')') x--;\n    if(x<0) return 0;\n  }\n  return !x;\n}\n\nll ans;\nstring t;\nvoid dfs(int k) {\n  if(k==t.size()) {\n    memset(ff,0,sizeof(ff));\n    l=0;\n    f=ck();\n    p=s.begin();\n    ll x=exp();\n    if(p==s.end()&&f) ans=max(ans,x);\n    return;\n  }\n  if(t[k]=='.') {\n    string r=\"01+-*()\";\n    for(int i=0;i<r.size();i++) {\n      s[k]=r[i];\n      dfs(k+1);\n    }\n  } else dfs(k+1);\n}\n\nint main() {\n  cin >> t;\n  s=t;\n  ans=-1;\n  dfs(0);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f1(int&);\n\nint f2(int&);\n\nint f3(int&);\n\nvector< int > undefined;\nstring S;\n\nbool isout(int val)\n{\n  return(val < 0 || val >= 1024);\n}\nint f1(int& idx)\n{\n  int val = f2(idx);\n\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') {\n      ++idx;\n      val += f2(idx);\n    } else {\n      ++idx;\n      val -= f2(idx);\n    }\n    if(isout(val)) throw(1);\n  }\n  return (val);\n}\n\nint f2(int& idx)\n{\n  int val = f3(idx);\n\n  while(S[idx] == '*') {\n    idx++;\n    val *= f3(idx);\n    if(isout(val)) throw(1);\n  }\n  return (val);\n}\n\nint f3(int& idx)\n{\n  int val = 0;\n  if(S[idx] == '(') {\n    ++idx;\n    int now = idx;\n    while(isdigit(S[now])) ++now;\n    if(S[now] == ')') throw(1);\n    val = f1(idx);\n    ++idx;\n    return (val);\n  } else if(isdigit(S[idx])) {\n    while(isdigit(S[idx])) {\n      val = val * 2 + S[idx] - '0';\n      ++idx;\n      if(isout(val)) throw(1);\n    }\n  } else {\n    throw (1);\n  }\n  return (val);\n}\n\nint make(int idx)\n{\n  int ret = -1;\n  if(idx == undefined.size()) {\n    try {\n      int pos = 0;\n      int val = f1(pos);\n      if(pos + 1 != S.size()) throw (1);\n      ret = max(ret, val);\n    } catch(int e) {}\n  } else {\n    string s = \"01+-*()\";\n    for(char c : s) {\n      S[undefined[idx]] = c;\n      ret = max(ret, make(idx + 1));\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> S;\n  S += \"~\";\n  for(int i = 0; i < S.size(); i++) {\n    if(S[i] == '.') undefined.push_back(i);\n  }\n  cout << make(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nchar ln[7]={'0','1','+','-','*','(',')'};\nint n=0,ans=-1;\nint p[5]={};\nint ind[5]={};\nstring s,t;\nmap<int,int> mp;\n\nstring f(string a){\n  if(a==\"+\" || a==\"-\" || a==\"*\" || a==\"(\" || a==\")\")return a;\n  reverse(a.begin(),a.end());\n  int res=0;\n  for(int i=0;i<a.length();i++)res+=(pow(2,i)*(a[i]-'0'));\n  ostringstream os;\n  os<<res;\n  return os.str();\n}\n\nint cal(vector<string> v){\n  if(v.empty())return -1;\n  //if(v.size()==3 && (v[1][0]=='0' || v[1][0]=='1') && v[0]==\"(\" && v[2]==\")\")return -1; \n  vector<string> vs1,vs2,vs3;\n  for(int i=0;i<v.size();i++){\n    if(v[i]==\"(\"){\n      vector<string> tmp;\n      int l=1,r=0,count=0;\n      for(int j=i+1;j<v.size();j++){\n\tif(v[j]==\"(\")l++;\n\tif(v[j]==\")\")r++;\n\tif((l-r)==1 && (v[j]==\"+\" || v[j]==\"*\" || v[j]==\"-\"))count++;\n\tif(r==l){\n\t  if(count==0)return -1;\n\t  i=j;\n\t  break;\n\t}\n\ttmp.push_back(v[j]);\n      }\n      int res=cal(tmp);\n      if(res==-1 || 1024<=res)return -1;\n      ostringstream os;\n      os<<res;\n      vs1.push_back(os.str());\n    }\n    else vs1.push_back(v[i]);\n  }\n  //if((vs1[1][0]=='0' || vs1[1][0]=='1') && vs1[0]==\"(\" && vs1[2]==\")\")return -1;\n  if(vs1[0]==\"+\" || vs1[0]==\"*\" || vs1[0]==\"-\")return -1;\n  int size=vs1.size()-1;\n  if(vs1[size]==\"+\" || vs1[size]==\"*\" || vs1[size]==\"-\")return -1;\n  for(int i=0;i<vs1.size();i++){\n    if(vs1[i]==\"*\"){\n      if('0'<=vs1[i+1][0] && vs1[i+1][0]<='9' && '0'<=vs2.back()[0] && vs2.back()[0]<='9' ){\n\tint tmp1=atoi(vs2.back().c_str()),tmp2=atoi(vs1[i+1].c_str());\n\tif(tmp1<0 || 2014<=tmp1)return -1;\n        if(tmp2<0 || 2014<=tmp2)return -1;\n\tvs2.pop_back();\n\tostringstream os;\n\tos<<(tmp1*tmp2);\n\tif(1024<=tmp1*tmp2)return -1;\n\tvs2.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs2.push_back(vs1[i]);\n  }\n  for(int i=0;i<vs2.size();i++){\n    if(vs2[i]==\"+\" || vs2[i]==\"-\"){\n      string tmp=vs3.back();\n      if('0'<=vs2[i+1][0] && vs2[i+1][0]<='9' && '0'<=tmp[0] && tmp[0]<='9' ){\n\tint tmp1=atoi(tmp.c_str()),tmp2=atoi(vs2[i+1].c_str());\n        if(tmp1<0 || 2014<=tmp1)return -1;\n        if(tmp2<0 || 2014<=tmp2)return -1;\n\tvs3.pop_back();\n\tostringstream os;\n\tint res;\n\tif(vs2[i]==\"+\")res=(tmp1+tmp2);\n\tif(vs2[i]==\"-\")res=(tmp1-tmp2);\n\tif(res<0 || 1024<=res)return -1;\n\tos<<res;\n\tvs3.push_back(os.str());\n\ti++;\n      }\n      else return -1;\n    }\n    else vs3.push_back(vs2[i]);\n  }\n  int res=-1;\n  if(vs3.size()==1 && '0'<=vs3[0][0] && vs3[0][0]<='9')res=atoi(vs3[0].c_str());\n  if(res<0 || 1024<=res)res=-1;\n  return res;\n}\n\nvoid rec(int v){\n  if(v==n){\n    t=s;\n    for(int i=0;i<n;i++)t[ind[i]]=ln[p[i]];\n    string tmp=\"\";\n    vector<string> vs;\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='0' || t[i]=='1')tmp+=t[i];\n      else {\n\tif(tmp!=\"\")vs.push_back(tmp);\n\ttmp=\"\";\n\tstring st=\"\";\n\tst+=t[i];\n\tvs.push_back(st);\n      }\n    }\n    if(tmp!=\"\")vs.push_back(tmp);\n    stack<int> st;\n    for(int i=0;i<vs.size();i++){\n      if(vs[i]==\"(\")st.push(i);\n      if(vs[i]==\")\"){\n        if(st.empty())return;\n        st.pop();\n      }\n    }\n    if(!st.empty())return;\n    /*\n    for(int i=1;i<vs.size()-1;i++){\n      if((vs[i][0]=='0' || vs[i][0]=='1') && vs[i-1]==\"(\" && vs[i+1]==\")\")return;\n    }\n    for(int i=1;i<vs.size();i++){\n      if(vs[i]==\")\" && !('0'<=vs[i-1][0] && vs[i-1][0]<='9'))return;\n    }\n    for(int i=0;i<vs.size()-1;i++){\n      if(vs[i]==\"(\" && !('0'<=vs[i+1][0] && vs[i+1][0]<='9'))return;\n      }*/\n    for(int i=0;i<vs.size();i++)vs[i]=f(vs[i]);\n    int res=cal(vs);\n    ans=max(ans,res);\n  }\n  else {\n    for(int i=0;i<7;i++){\n      rec(v+1);\n      p[v]++;\n    }\n    p[v]=0;\n  }\n}\n\nint main()\n{\n  cin>>s;\n  for(int i=0;i<s.length();i++){\n    if(s[i]=='.'){\n      ind[n]=i;\n      n++;\n    }\n  }\n  rec(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <stack>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef string::const_iterator State;\nint expr(State &be);\nint num(State &be){\n\tif(!isdigit(*be)) return -1;\n\tint ret=0;\n\twhile(isdigit(*be)){\n\t\tret*=2;\n\t\tret+=(*be-'0');\n\t\tbe++;\n\t}\n\treturn ret;\n}\nint factor(State& be){\n\tint ret;\n\tif(*be=='('){\n\t\tbe++;\n\t\tret=expr(be);\n\t\tif(*be!=')') return -1;\n\t\tbe++;\n\t\treturn ret;\n/*\t\tcout << ret << endl;\n\t\tif(ret==-1) return -1;\n\t\tint k=-1;\n\t\tcout << *be << endl;\n\t\tif(*be=='+') k=0;\n\t\tif(*be=='-') k=1;\n\t\tif(*be=='*') k=2;\n\t\tif(k==-1) return -1;\n\t\tbe++;\n\t\tint ret1=expr(be);\n\t\tif(ret1==-1) return -1;\n\t\tbe++;\n\t\tif(k==0) return ret+ret1;\n\t\tif(k==1) return max(-1,ret-ret1);\n\t\tif(k==2) return ret*ret1;\n\t\tcout << \"hoge\";*/\n\t}\n\treturn num(be);\n}\nint term(State& be){\n\tint ret=factor(be);\n\tif(ret==-1) return -1;\n\twhile(*be=='*'){\n\t\tbe++;\n\t\tint a=factor(be);\n\t\tif(a<0) return -1;\n\t\tret*=a;\n\t}\n\treturn ret;\n}\nint expr(State& be){\n\tint ret=term(be);\n\tif(ret==-1) return -1;\n\twhile(true){\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret+=a;\n\t\t}else if(*be=='-'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<0) return -1;\n\t\t}else break;\n\t}\n\treturn ret;\n}\nint main(){\n\tstring s,ch=\"01+-*()\";\n\tvector<int> vc;\n\tcin >> s;\n\tState be=s.begin();\n\trep(i,s.size()) if(s[i]=='.') vc.push_back(i);\n\tint n=vc.size(),p7=1,ans=-1;\n\trep(i,n) p7*=7;\n\trep(i,p7){\n\t\tstring t=s;\n\t\tint tmp=i;\n\t\trep(j,n){\n\t\t\tt[vc[j]]=ch[tmp%7];\n\t\t\ttmp/=7;\n\t\t}\n//\t\tcout << t << \"  \";\n\t\tstack<int> id;\n\t\tint cal[101]={};\n\t\tbool ok=true;\n\t\trep(i,t.size()){\n\t\t\tif(t[i]=='('){\n\t\t\t\tid.push(i);\n\t\t\t\tcal[i]=-1;\n\t\t\t}\n\t\t\tif(t[i]==')'){\n\t\t\t\tif(id.empty()){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tid.pop();\n\t\t\t}\n\t\t\tif(t[i]=='+' || t[i]=='-' || t[i]=='*'){\n\t\t\t\tif(!id.empty()) cal[id.top()]++;\n\t\t\t}\n\t\t}\n\t\trep(i,t.size()) if(cal[i]<0) ok=false;\n//\t\tcout << (ok ? \"valid\" : \"invalid\\n\");\n\t\tif(!ok) continue;\n\t\tState be=t.begin();\n\t\tint h=expr(be);\n\t\tif(be!=t.end()){\n//\t\t\tcout << endl;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout << \"     \" << h << endl;\n\t\tans=max(ans,h);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nint formula(int, int);\nstring s;\nvector<int> idx;\n\nint binary_to_int(const string& binary) {\n\tint res = 0, x = 1, n = binary.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(binary[n - 1 - i] == '1')\n\t\t\tres += x;\n\n\t\telse if(binary[n - 1 - i] != '0')\n\t\t\treturn -1;\n\n\t\tx <<= 1;\n\t}\n\n\treturn res;\n}\n\nint factor(int l, int r) {\n\tif(s[l] == '(' && s[r - 1] == ')') {\n\t\tfor(int i = l + 1; i < r - 1; ++i)\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\treturn formula(l + 1, r - 1);\n\t}\n\n\treturn binary_to_int(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && s[i] == '*') {\n\t\t\tint vl = factor(l, i), vr = factor(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\treturn vl * vr;\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\tint vl = term(l, i), vr = term(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn vl + vr;\n\n\t\t\telse\n\t\t\t\treturn vl - vr;\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nint dfs(int d = 0) {\n\tif(d == idx.size()) {\n\t\tconst int res = formula(0, s.size());\n\t\treturn res >= 1024 ? -1 : res;\n\t}\n\n\tint res = -1;\n\tstatic const char c[7] = {'0', '1', '*', '+', '-', '(', ')'};\n\tfor(int i = 0; i < 7; ++i) {\n\t\ts[idx[d]] = c[i];\n\t\tchmax(res, dfs(d + 1));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tidx.push_back(i);\n\n\tcout << dfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  rep(i,s.size()){\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n      if(i==s.size()-1){\n        return -INF;\n      } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n        return -INF;\n      }\n    }\n  }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1)return calculate(s.substr(1,s.size()-2),true);\n    if(s[index+1]=='+'){\n      ret = calculate(s.substr(0,index+1))+calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='-'){\n      ret = calculate(s.substr(0,index+1))-calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = ret1*ret2;\n        if(inner(ret)){\n          return ret;\n        } else {\n          return -INF;\n        }\n      } else {\n        return -INF;\n      }\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    tmp = calculate(sc);\n    if(tmp>maxn)maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint formula(int &p,bool inper);\npair<int,bool> term1(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint calc(int lhs,int rhs,char op){\n  int res=-1;\n  if(lhs==-1 || rhs==-1) return -1;\n  if(op=='+') res=lhs+rhs;\n  if(op=='-') res= lhs-rhs;\n  if(op=='*') res= lhs*rhs;\n  return 0<=res && res<1024 ? res : -1;\n}\n\nstring s;\nint formula(int &p,bool inper=false){\n  bool isok=!inper;\n  pair<int,bool> ret=term1(p);\n  int res=ret.first;\n  isok|=ret.second;\n  while(p<s.size() && s[p]!=')'){\n    inper=false;\n    char op=s[p];\n    if(op!='+' && op!='-'){\n      return -1;\n    }\n    isok=true;\n    p++;\n    int rhs=term1(p).first;\n    res=calc(res,rhs,op);\n  }\n  return isok ? res : -1;\n}\n\npair<int,bool> term1(int &p){\n  int res=term2(p);\n  bool res2=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;\n    if(op!='*'){\n      return {-1,0};\n    }\n    res2=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,res2};\n}\n\nint term2(int &p){\n int res=1;\n  if(s[p]=='('){\n    p++;\n    res=formula(p,true);\n    p++;\n  }\n  else if(isdigit(s[p])){\n    res=get_num(p);\n  }\n  else{\n    return -1;\n  }\n  return res;\n}\n\nint get_num(int &p){\n  int res=0;\n  while(isdigit(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  //cout<<res<<endl;\n  if(res>=1024) return -1;\n  return res;\n}\n\nstring ch=\"01+-*()\";\n\nint dfs(int i){\n  if(i==s.size()){\n    int p=0;\n    //cout<<s<<endl;\n    int res=formula(p);\n    //cout<<res<<endl;\n    return res;\n  }\n  if(s[i]=='.'){\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      res=max(res,dfs(i+1));\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  vector<int> sec;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, char *> P;\n\nint cs[] = {'0', '1', '+', '-', '*', '(', ')'};\n\nP fact(char *p);\nP term(char *p);\nP expr(char *p);\n\nP fact(char *p){\n  if(isdigit(*p)){\n    int t = *(p++) - '0';\n    while(isdigit(*p)) t = t * 2 + *(p++) - '0';\n    return P(t, p);\n  } else if(*p == '('){\n    P r = expr(p + 1);\n    if(*r.second != ')') exit(0); //閉じ括弧が無いエラー\n    return P(r.first, r.second + 1);\n  } else{\n    exit(0); //括弧でも数字でもないエラー\n  }\n}\n\nP term(char *p){\n  P r = fact(p);\n  while(*r.second == '*' || *r.second == '/'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = fact(r.second + 1);\n    if(op == '*') r.first *= tmp;\n    else r.first /= tmp;\n  }\n  return r;\n}\n\nP expr(char *p){\n  P r = term(p);\n  while(*r.second == '+' || *r.second == '-'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = term(r.second + 1);\n    if(op == '+') r.first = tmp + r.first;\n    else r.first = tmp - r.first;\n  }\n  return r;\n}\n\nbool is_digit(string s){\n  if(s == \"0\" || s == \"1\") return true;\n  return false;\n}\n\nbool is_operation(string s){\n  if(s == \"+\" || s == \"-\" || s == \"*\") return true;\n  return false;\n}\n\nbool is_number(string s){\n  if(is_digit(s) || ((int)s.length() >= 2 && is_number(s.substr(0, (int)s.length() - 1)) && is_digit(s.substr(s.length() - 1)))) return true;\n  return false;\n}\n\nbool check(string s){\n  int cnt = 0;\n  REP(i, s.length()){\n    if(s[i] == '(') ++cnt;\n    if(s[i] == ')') --cnt;\n    if(cnt < 0) return false;\n  }\n  return cnt == 0;\n}\n\nbool is_expression(string s);\n\nbool is_inner_expression(string s){\n  //cout <<\"inner_exp \" <<s <<endl;\n  FOR(i, 1, (int)s.length() - 1){\n    //cout <<\"left \" <<s.substr(0, i) <<\", right \" <<s.substr(i + 1) <<endl;\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nbool is_expression(string s){\n  //cout <<\"exp \" <<s <<endl;\n  if((int)s.length() >= 2 && s[0] == '(' && s[(int)s.length() - 1] == ')' && check(s.substr(1, (int)s.length() - 2))){\n    bool res = is_inner_expression(s.substr(1, (int)s.length() - 2));\n    //cout <<(res ? \"true\" : \"false\") <<endl;\n    return res;\n  }\n  if(is_number(s)){\n    //cout <<\"true\" <<endl;\n    return true;\n  }\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nint solve(int cnt, vector<int> &v, char *s){\n  if(cnt >= (int)v.size()){\n    //cout <<\"! \" <<s <<\", \" <<is_expression(s) <<endl;\n    if(!is_expression(s)) return -1;\n    int res = expr(s).first;\n    return res >= 0 && res < 1024 ? res : -1;\n  }\n  int res = -1;\n  REP(i, 7){\n    s[v[cnt]] = cs[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  return res;\n}\n\nint main() {\n  char s[110];\n  cin >>s;\n  int sl = strlen(s);\n  vector<int> v;\n  REP(i, sl) if(s[i] == '.') v.push_back(i);\n  cout <<solve(0, v, s) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define LOG(...) fprintf(stderr,__VA_ARGS__)\n#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst char cs[] = {'0', '1', '+', '-', '*', '(', ')'};\nconst int MAX_VAL = 1024;\n\nint LEN;\nint UNKNOWN;\n\nint expr(string s, int& idx, bool& op);\nint term(string s, int& idx, bool& op);\nint factor(string s, int& idx, bool& op);\nint number(string s, int& idx);\n\nvoid ASSERT(bool cond, string err) {\n    if (!cond) throw err;\n}\n\nvoid NEXT(int& idx) {\n    idx++;\n    ASSERT(idx < LEN, \"index out of range\");\n}\n\nint expr(string s, int& idx, bool& op) {\n    int ret = term(s, idx, op);\n    for (;;) {\n        if (s[idx] == '+') {\n            NEXT(idx);\n            ASSERT(idx < LEN, \"end of line: +\");\n            op = true;\n            ret += term(s, idx, op);\n            ASSERT(0 <= ret && ret < MAX_VAL, \"number out of range\");\n        } else if (s[idx] == '-') {\n            NEXT(idx);\n            ASSERT(idx < LEN, \"end of line: -\");\n            op = true;\n            ret -= term(s, idx, op);\n            ASSERT(0 <= ret && ret < MAX_VAL, \"number out of range\");\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint term(string s, int& idx, bool& op) {\n    int ret = factor(s, idx, op);\n    for (;;) {\n        if (s[idx] == '*') {\n            NEXT(idx);\n            ASSERT(idx < LEN, \"end of line: *\");\n            op = true;\n            ret *= factor(s, idx, op);\n            ASSERT(0 <= ret && ret < MAX_VAL, \"out of range\");\n        } else if (s[idx] == '(') {\n            ASSERT(0, \"invalid open parenthese\");\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(string s, int& idx, bool& op) {\n    // ()?????????operator???????????????????????????????????????\n    if (s[idx] == '(') {\n        NEXT(idx);\n        bool copy = op;\n        op = false;\n        int ret = expr(s, idx, op);\n        ASSERT(op, \"no operator\");\n        ASSERT(s[idx] == ')', \"no close parenthese\");\n        op = copy;\n        idx++;\n        return ret;\n    } else {\n        return number(s, idx);\n    }\n}\n\nint number(string s, int& idx) {\n    int ret = 0;\n    ASSERT(isdigit(s[idx]), \"must be a number\");\n    while (isdigit(s[idx]) && idx < LEN) {\n        ret <<= 1;\n        ret |= s[idx] == '1' ? 1 : 0;\n        idx++;\n    }\n    return ret;\n\n}\n\nint dfs(string s, int idx, int n) {\n    if (n == UNKNOWN) {\n        try {\n            int idx = 0;\n            bool op = false;\n            LOG(\"%s \", s.c_str());\n            int ret = expr(s, idx, op);\n            LOG(\"= %d (idx=%d)\\n\", ret, idx);\n            if (idx == LEN) {\n                return ret;\n            } else {\n                return -1;\n            }\n            return ret;\n        } catch (string e) {\n            LOG(\"--> %s\\n\", e.c_str());\n            return -1;\n        }\n    }\n    int ma = -1;\n    for (; idx < LEN; idx++) {\n        if (s[idx] == '.') {\n            for (char c : cs) {\n                s[idx] = c;\n                ma = max(ma, dfs(s, idx+1, n+1));\n            }\n        }\n    }\n    return ma;\n}\n\nvoid test(string s) {\n    LEN = SZ(s);\n    UNKNOWN = 0;\n    REP(i, SZ(s)) if (s[i] == '.') UNKNOWN++;\n\n    LOG(\"==> %s = %d\\n\", s.c_str(), dfs(s, 0, 0));\n}\n\nint main() {\n//    test(\"1(\");\n//    test(\"1)\");\n//    test(\"(1.1)\");\n//    test(\"(1+(.))\");\n\n    string s;\n    cin >> s;\n    LEN = SZ(s);\n    UNKNOWN = 0;\n    REP(i, SZ(s)) if (s[i] == '.') UNKNOWN++;\n\n    cout << dfs(s, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nstring s;\n\nstring op[2] = {\"+-\", \"*\"};\n\nint parse(int& i, int d)\n{\n\tif (d == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tint ret = parse(i, 0);\n\t\t\ti++;\n\t\t\tif (ret < 0) return -1;\n\t\t\tif (1024 <= ret) return -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ('0' <= s[i] && s[i] <= '1')\n\t\t{\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '1')\n\t\t\t{\n\t\t\t\tret = ret * 2 + s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (1024 <= ret) return -1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ret = parse(i, d + 1);\n\n\t\twhile (op[d].find(s[i]) != string::npos)\n\t\t{\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '+': i++; ret += parse(i, d + 1); break;\n\t\t\tcase '*': i++; ret *= parse(i, d + 1); break;\n\t\t\tcase '-': i++; ret -= parse(i, d + 1); break;\n\t\t\t}\n\n\t\t\tif (1024 <= ret) return -1;\n\t\t\tif (ret < 0) return -1;\n\t\t}\n\n\t\treturn ret;\n\t}\n}\n\nbool isvalid()\n{\n\tint cnt = 0;\n\tint flag[101010];\n\tflag[0] = 0;\n\trep(j, 0, s.length())\n\t{\n\t\tif (s[j] == '(')\n\t\t{\n\t\t\tcnt++;\n\t\t\tflag[cnt] = 1;\n\t\t}\n\t\telse if (s[j] == ')')\n\t\t{\n\t\t\tif (cnt == 0) return false;\n\t\t\tif (flag[cnt] == 1) return false;\n\t\t\tcnt--;\n\t\t}\n\t\telse if (s[j] == '0' || s[j] == '1')\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag[cnt] = 0;\n\t\t}\n\t}\n\tif (cnt != 0) return false;\n\n\trep(j, 0, s.length() - 1)\n\t{\n\t\tif (s[j] == '+' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '+' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '-' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '*' && s[j + 1] == ')') return false;\n\n\t\tif (s[j] == ')' && s[j + 1] == '(') return false;\n\n\t\tif (s[j] == '0' && s[j + 1] == '(') return false;\n\t\tif (s[j] == '1' && s[j + 1] == '(') return false;\n\n\t\tif (s[j] == ')' && s[j + 1] == '0') return false;\n\t\tif (s[j] == ')' && s[j + 1] == '1') return false;\n\t\t\n\t}\n\n\tif (s[0] == '+') return false;\n\tif (s[0] == '-') return false;\n\tif (s[0] == '*') return false;\n\n\tif (s[s.length() - 2] == '+') return false;\n\tif (s[s.length() - 2] == '-') return false;\n\tif (s[s.length() - 2] == '*') return false;\n\n\treturn true;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t/*\n\ts = \"(1+1)=\";\n\tif (isvalid())\n\t\tcout << \"valid\" << endl;\n\telse\n\t\tcout << \"invalid\" << endl;\n\n\treturn 0;\n\t*/\n\n\tcin >> s; s += \"=\";\n\n\tvector<int> dots;\n\trep(j, 0, s.length()) if (s[j] == '.') dots.push_back(j);\n\n\tint nums[5];\n\tstring opes = \"01+-*()\";\n\tint ans = -1;\n\trep(j, 0, 100000)\n\t{\n\t\tint jj = j;\n\t\trep(k, 0, 5)\n\t\t{\n\t\t\tnums[k] = jj % 10;\n\t\t\tjj /= 10;\n\t\t}\n\t\tbool ok = false;\n\t\trep(k, 0, dots.size()) if (7 <= nums[k]) ok = true;\n\t\tif (ok) continue;\n\n\t\trep(k, 0, dots.size()) s[dots[k]] = opes[nums[k]];\n\n\t\tif (!isvalid()) continue;\n\n\t\tint i = 0;\n\t\tint ret = parse(i, 0);\n\t\tif (ans < ret)\n\t\t{\n\t\t\tans = ret;\n\t\t\t//cout << s << ret << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint formula(int &p,bool inper);\npair<int,bool> term1(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint calc(int lhs,int rhs,char op){\n  int res=-1;\n  if(lhs==-1 || rhs==-1) return -1;\n  if(op=='+') res=lhs+rhs;\n  if(op=='-') res= lhs-rhs;\n  if(op=='*') res= lhs*rhs;\n  return 0<=res && res<1024 ? res : -1;\n}\n\nstring s;\nint formula(int &p,bool inper=false){\n  bool isok=!inper;\n  pair<int,bool> ret=term1(p);\n  int res=ret.first;\n  isok|=ret.second;\n  while(p<s.size() && s[p]!=')'){\n    inper=false;\n    char op=s[p];\n    if(op!='+' && op!='-'){\n      return -1;\n    }\n    isok=true;\n    p++;\n    int rhs=term1(p).first;\n    res=calc(res,rhs,op);\n  }\n  return isok ? res : -1;\n}\n\npair<int,bool> term1(int &p){\n  int res=term2(p);\n  bool res2=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;\n    if(op!='*'){\n      return {-1,0};\n    }\n    res2=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,res2};\n}\n\nint term2(int &p){\n int res=1;\n  if(s[p]=='('){\n    p++;\n    res=formula(p,true);\n    p++;\n  }\n  else if(isdigit(s[p])){\n    res=get_num(p);\n  }\n  else{\n    return -1;\n  }\n  return res;\n}\n\nint get_num(int &p){\n  int res=0;\n  while(isdigit(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  //cout<<res<<endl;\n  return res;\n}\n\nstring ch=\"01+-*()\";\n\nint dfs(int i){\n  if(i==s.size()){\n    int p=0;\n    //cout<<s<<endl;\n    int res=formula(p);\n    //cout<<res<<endl;\n    return res;\n  }\n  if(s[i]=='.'){\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      res=max(res,dfs(i+1));\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  vector<int> sec;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;Cursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(int& opc){\n\t\t\tll l=term(opc);\n\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t\n\t\t\twhile(*c=='+' || *c=='-'){\n\t\t\t\tif(*c=='+'){\n\t\t\t\t\tc++;ll r=term(opc);\n\t\t\t\t\tif(!IN(0,r,1<<10)) throw ParseError();\n\t\t\t\t\tl+=r;\n\t\t\t\t}else{\n\t\t\t\t\tc++;ll r=term(opc);\n\t\t\t\t\tif(!IN(0,r,1<<10)) throw ParseError();\n\t\t\t\t\tl-=r;\n\t\t\t\t}\n\t\t\t\topc++;\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll term(int opc){\n\t\t\tll l=factor();\n\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\n\t\t\twhile(*c=='*'){\n\t\t\t\tc++;ll r=factor();\n\t\t\t\tif(!IN(0,r,1<<10)) throw ParseError();\n\t\t\t\tl*=r;\n\t\t\t\topc++;\n\t\t\t\tif(!IN(0,l,1<<10)) throw ParseError();\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tll factor(){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;\n\t\t\t\tint opc=0;\n\t\t\t\tll v=expression(opc);\n\t\t\t\tif(!IN(0,v,1<<10)) throw ParseError();\n\t\t\t\tif(*c!=')' || opc==0)  throw ParseError();\n\t\t\t\tc++;\n\t\t\t\treturn v;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\treturn number();\n\t\t\t}else{\n\t\t\t\tthrow ParseError();\n\t\t\t}\n\t\t}\n\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t\t\tss << *c;c++;\n\t\t    }\n\t\t    string str;ss>>str;\n\t\t    ll res=0;\n\t\t    REP(i,str.size()){\n\t\t\t\tres*=2;if(str[i]=='1')res++;\n\t\t\t\tif(!IN(0,res,1<<10)) throw ParseError();\n\t\t    }\n\t\t    if(!IN(0,res,1<<10)) throw ParseError();\n\t\t\treturn res;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nchar symb[7]={'0','1','+','-','*','(',')'};\n\nclass Main{\npublic:\n\tstring s;\t\t\n\tbool input(){\n\t\tgetline(cin,s);\n\t\ts.erase(remove(ALL(s), ' '), s.end());//空白除去\n\t\treturn true;\n\t}\n\n\tll dfs(int i){\n\t\tll Mv=-1;\n\t\tif(i==s.size()){\n\t\t\ttry{\n\t\t\t\tCursor c=s.begin();Syntax sy(s,c);int opc=0;\n\t\t\t\tll res=sy.expression(opc);\n\t\t\t\t\n\t\t\t\tif(c!=s.end())throw ParseError();\n\t\t\t\treturn res;\n\t\t\t}catch(ParseError e){return -1;}\n\t\t}\n\t\tif(s[i]=='.'){\n\t\t\tREP(j,7){\n\t\t\t\ts[i]=symb[j];\n\t\t\t\tMv=max(Mv,dfs(i+1));\n\t\t\t\ts[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tMv=max(Mv,dfs(i+1));\n\t\t}\n\t\treturn Mv;\n\t}\n\n\tvoid run(){\n\t\tinput();\n\t\tcout << dfs(0)<<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstdlib>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<cmath>\n\nusing namespace std;\nbool deb;\n\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\n  bool safe,mul;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n    safe = mul = false;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      safe = true;\n      int p = expression();\n      safe = false;\n      mul = false;\n      //cout << \"in fact, p = \" << p << endl;\n      pos++;\n      return p;\n    }else{\n      int ru = 0;\n      string p; p.clear();\n      \n      while('0' <= parse[pos] && parse[pos] <= '1'){\n\tp += parse[pos];\n\tpos++;\n      }\n      reverse(p.begin(),p.end());\n      int ip = 0;\n      bool ook = false;\n      for(int i=0;i<p.length();i++){\n\tif(p[i] == '1'){\n\t  ip += pow((double)2,(double)ru);\n\t}\n\took = true;\n\tru++;\n      }\n      if(!ook)ip = -1;\n      //cout << \"in fact, ip = \" << ip << endl;\n      return ip;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p < 0){\n      //cout << \"error! in term, negative number error\" << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tmul = true;\n\tint fac= fact();\n       \n\tif(fac < 0){\n\t  //cout << \"error! in term(while *), BNF error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n\tp *= fac;\n\t//cout << \"in term(while *), fact =  \" << fac << endl;\n\tif(p < 0){\n\t  //cout << \"error! in term, negative number error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(p < 0){\n      //cout << \"error! in expression, negative number error\" << endl;\n      deb = true;\n      return -1;\n    }\n    if(!(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*' || pos == parse.length() || (safe && mul && parse[pos] == ')'))){\n      //cout << \"error! in expression, not operator. parse[pos] = \" << parse[pos] << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tp+=term();\n\tif(p < 0){\n\t  //cout << \"error! in term, negative number error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else if(parse[pos] == '-'){\n\tpos++;\n\tp-=term();\n\tif(p < 0){\n\t  //cout << \"error! in term, negative number error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else {\n\t//cout << \"error! in expression, not operator Ver2.\" << endl;\n\tdeb = true;\n\treturn -1;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\n\n\n/*\nclass Parsing{\nprivate:\n  bool oh,plus;\n  int  pos;\n  string parse;\npublic:\n  Parsing(string s){\n    pos = 0,parse = s,oh = false,plus = false;\n  }\n\n \n\n  \n  int expression(){\n    if(parse[pos] == '('){\n      ++pos;\n      oh = true;\n      int A = expression();\n      cout << \"in expression, A = \" << A << endl;\n      ++pos;\n      oh = false;\n      return A;\n    }\n    else{\n    int p = number();\n    cout << \"in expression, p = \" << p << endl;\n    \n    if(parse[pos]=='+' || parse[pos] == '-' || parse[pos] == '*'){\n\n      char op = operation();\n      cout << \"in expression, op = \" << op  << \",parse[pos] = \" << parse[pos]<< endl;\n      ++pos;\n      if(oh)plus = true;\n      int B = expression();\n      plus = false;\n      cout << \"in expression, B = \" << B << \",parse[pos] = \" << parse[pos] << endl;\n      ++pos;\n      cout << \"p = \" << p <<\",op = \" << op <<\", B = \" << B << endl;\n      if(op == '+')return p+B;\n      else if(op == '-')return p-B;\n      else if(op == '*')return p*B;\n      else{\n\tdeb = true;\n\tcout << \"in expression, not operation error\" << endl;\n      }\n    }  \n    return p;\n    }\n  }\n\n\n\n  char operation(){\n    if(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*'){\n      return parse[pos];\n    }\n    else{\n      deb = true;\n      cout << \"in operation, not operation error. parse[pos] = \" << parse[pos] << endl;\n      return 'E';\n    }\n  }\n\n  int number(){\n    if(parse[pos] == '('){\n      ++pos;\n      int A = number();      \nchar op\n\n    }\n    else{\n      string p; p.clear();\n      while(parse[pos] == '0' || parse[pos] == '1')p += parse[pos],pos++;\n      cout << \"in number, p = \" << p << endl;\n      if(plus)pos++;\n      if(!(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*' || pos == parse.length())){\n\tdeb = true;    \n\tcout << \"in number,not digit error. parse[pos] = \" << parse[pos] << endl;\n      }\n      \n      reverse(p.begin(),p.end());\n      int ip = 0,ru = 0;\n      for(int i=0;i<p.length();i++){\n\tif(p[i] == '1'){\n\t  ip += pow(2.0,(double)ru);\n\t}\n\tru++;\n      }\n      \n      return ip;\n    }\n  }\n  \n\n\n};\n*/\n\n\nint Fans;\nchar perm[5] = {'0','1','+','-','*'};\nvoid all_permutation(string s){\n\n  for(int i=0;i<s.length();i++){\n    if(s[i] == '.'){\n      for(int j=0;j<5;j++){\n\tstring pre = s;\n\ts[i] = perm[j];\n\tall_permutation(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      deb = false;\n      //cout << \"s = \" << s << endl;\n      Parsing par = Parsing(s);\n      int ans = par.expression();\n      //cout <<\"ans = \" << ans  << \",deb = \" << deb << \",true =\" << true<< endl;\n      if(!deb) Fans = max(Fans,ans); \n    }\n  }\n\n}\n\nint main(){\n  string s;\n  Fans = -1;\n  cin >> s;\n  all_permutation(s);\n  cout << Fans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool ope, err;\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else {\n\t\treturn number(s);\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tope = true;\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\twhile (s[p] == '+' || s[p] == '-') {\n\t\tope = true;\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += expression(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= expression(s);\n\t\t}\n\t}\n\t\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\treturn res;\n}\n\nbool check(string s)\n{\n\tvector<bool> ope;\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tope.push_back(false);\n\t\t} else if (s[i]==')') {\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = true;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), false);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>1024) res=-1;\n\t\t\n\t\t//cerr << \"Persing : \" << s << endl;\n\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nstring tract(string s){\n  // cout << s << \" \";\n  rep(i,s.size()){\n    if(s[i]=='k')return \"k\";\n  }\n  // まず数字を全てfに変える\n  string s_tmp(s);\n  while(1){\n    // 数字あるかチェック\n    // cout << \"he\" << endl;\n    // cout << s_tmp << endl;\n    int index = 0,flag=0;\n    while(index<s_tmp.size()){\n      if(s_tmp[index]=='0'||s_tmp[index]=='1'){flag=1;break;}\n      index++;\n    }\n    if(!flag)break;\n    int index_e=index;\n    while(index_e<s_tmp.size()){\n      if(s_tmp[index_e]=='0'||s_tmp[index_e]=='1')index_e++;\n      else break;\n    }\n    // cout << index<<\" \"<<index_e<<endl;\n    // cout << s_tmp.substr(0,index)<<endl;\n    s_tmp = s_tmp.substr(0,index)+\"f\"+s_tmp.substr(index_e,s_tmp.size()-index_e);\n    // cout << s_tmp << endl;\n  }\n  // cout << s_tmp<<endl;\n\n\n  while(1){\n  // cout <<s_tmp<<endl;\n\n    stack<int> left,right;\n    int index=0;\n    rep(i,s_tmp.size()){\n      if(s_tmp[i]=='(')left.push(i);\n      else if(s_tmp[i]==')')right.push(i);\n    }\n    if(left.size()!=right.size())return \"k\";\n    if(left.size()>0){\n      int il = left.top();\n      int ir = il;\n      while(ir<s_tmp.size()){\n        if(s_tmp[ir]==')')break;\n        ir++;\n      }\n      // cout << il << \" \" << ir << endl;\n      string tmp = tract(s_tmp.substr(il+1,ir-il-1));\n      // cout << \"rec \" << tmp << endl;\n      if (tmp==\"k\"||tmp==\"f\")return \"k\";\n      else if(tmp==\"e\"){\n        // cout << il << \" \" << ir << endl;\n        s_tmp = s_tmp.substr(0,il)+\"f\"+s_tmp.substr(ir+1,s_tmp.size()-ir-1);\n        continue;\n      } \n    } else {\n      // ()がない場合\n      int flag = 0;\n      // cout << \"no \"<<s_tmp<<endl;\n      rep(i,s_tmp.size()){\n        if(s_tmp[i]=='+'||s_tmp[i]=='-'||s_tmp[i]=='*'){\n          if(s_tmp[i+1]!='f'&&s_tmp[i+1]!='e'){\n            flag = 1; // ダメ\n            break;\n          } else if(s_tmp[i-1]!='f'&&s_tmp[i-1]!='e'){\n            flag = 1;\n            break;\n          }\n        } else { // s_tmp[i]=='f' or 'e'\n          if(i+1<s_tmp.size()&&(s_tmp[i+1]=='f'||s_tmp[i+1]=='e')){\n            flag = 1;\n          } else if(i-1>0&&(s_tmp[i-1]=='f'||s_tmp[i-1]=='e')){\n            flag = 1;\n          }\n        }\n      }\n      if (flag)return \"k\";\n      else return \"e\";\n    }\n  }\n}\n\n\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint  expression(State &begin);\nint factor(State &begin);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\nint term(State &begin){\n  int ret = factor(begin);\n  int flag = 0;\n  if(!inner(ret))return -INF;\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin);\n      if(!inner(tmp))return -INF;\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// 式のパース\nint expression(State &begin){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin);\n  // cout << \"in expr \"<<ret << endl;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return -INF;\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin);\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin);\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  // if(!flag)return -INF;\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// ()のパース\nint factor(State &begin){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    begin++;\n    int ret = expression(begin);\n    // cout << \"from expr \"<<ret<<endl;\n    begin++;\n    return ret;\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return -INF;\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return k;\n  }\n}\n\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    // cout << \"~~~~\"<<endl;\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    // 括弧の対応をチェック\n    int sum = 0,flag=0;\n    rep(i,sc.size()){\n      if(sc[i]=='(')sum++;\n      if(sc[i]==')')sum--;\n      if(sum<0)flag=1;\n    }\n    if(sum!=0)flag=1;\n    string tm;\n    if(!flag){\n      tm = tract(sc);\n    } else {\n      tm = \"k\";\n    }\n    // cout <<\"now here \"<< tm << endl;\n    if(tm==\"k\")flag=1;\n    // tmp = calculate(sc);\n    State begin = sc.begin();\n    tmp = expression(begin);\n    // cout << tmp << endl;\n    // cout << sc << endl;\n    // tmp=-1;\n    if(!flag&&tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint p,flag,ans=-1;\nstring s;\nmap<int,char>cc;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])){\n    while(isdigit(s[p]))res=res*2+(s[p++]-'0');\n  }\n  else flag++;\n  return res;\n}\nint bnf2(){\n  int res=get_A();\n  while(s[p]=='*'){\n    int t=p++;\n    if(s[t]=='*')res*=get_A();\n  }\n  return res;\n}\nint bnf1(){\n  int res=bnf2();\n  while(s[p]=='+'||s[p]=='-'){\n    int t=p++;\n    if(s[t]=='+')res+=bnf2();\n    if(s[t]=='-')res-=bnf2();\n  }\n  return res;\n}\nbool ch(int t){\n  int res=0;\n  while(s[p]!=')'){\n    if(s[p]=='('){\n      p++;\n      if(!ch(1))return 0;\n    }\n    if(p>=s.size())break;\n    if(s[p]=='+'||s[p]=='-'||s[p]=='*')res++;\n    if(p>=s.size())return 0;\n    p++;\n  }\n  p++;\n  return (!t)||res;\n}\nvoid dfs(int d){\n  if(d==s.size()){\n    p=0;\n    if(ch(0)){\n      p=flag=0;\n      int res=bnf1();\n      if(!flag&&p==s.size())ans=max(ans,res);\n    }\n  }\n  else if(s[d]=='.'){\n    r(i,7){\n      s[d]=cc[i];\n      dfs(d+1);\n    }\n    s[d]='.';\n  }\n  else dfs(d+1);\n}\nmain(){\n  cin>>s;\n  cc[0]='0';\n  cc[1]='1';\n  cc[2]='+';\n  cc[3]='-';\n  cc[4]='*';\n  cc[5]='(';\n  cc[6]=')';\n  dfs(0);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> id;\nstring s, lst = \"01+-*()\";\n\nint solve();\nint dfs(int x);\nint expression(int &x);\nint term(int &x);\nint number(int &x);\nbool check();\n\nint main() {\n  cin >> s;\n  n = s.size();\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  for(int i = 0; i < n; ++i)\n    if(s[i] == '.') id.push_back(i);\n  return dfs(0);\n}\n\nint dfs(int x) {\n  int res = -1;\n  if(x == (int)id.size()) {\n    if(!check()) return -1;\n    x = 0;\n    return expression(x);\n  }\n  for(int i = 0; i < 7; ++i) {\n    s[id[x]] = lst[i];\n    res = max(res, dfs(x + 1));\n  }\n  return res;\n}\n\nint expression(int &x) {\n  int res = term(x);\n  if(res < 0) return res;\n  while(x < n) {\n    if(s[x] == '+') {\n      int righ = term(++x);\n      if(righ < 0) return -1;\n      res += righ;\n    }\n    else if(s[x] == '-') {\n      int righ = term(++x);\n      if(righ < 0) return -1;\n      res -= righ;\n    }\n    else\n      break;\n    if(res < 0 || res >= (1 << 10)) return -1;\n  }\n  return res;\n}\n\nint term(int &x) {\n  int res = number(x);\n  if(res < 0) return res;\n  while(x < n) {\n    if(s[x] == '*') {\n      int righ = number(++x);\n      if(righ < 0) return -1;\n      res *= righ;\n    }\n    else\n      break;\n    if(res < 0 || res >= (1 << 10)) return -1;\n  }\n  return res;\n}\n\nint number(int &x) {\n  int res = 0;\n  if(s[x] == '(') {\n    res = expression(++x);\n    if(res < 0) return res;\n    assert(s[x] == ')');\n    ++x;\n    return res;\n  }\n  if(x == n || !isdigit(s[x])) return -1;\n  while(x < n && isdigit(s[x])) {\n    res <<= 1;\n    res += s[x++] & 1;\n    if(res >= 1 << 10) return -1;\n  }\n  return res;\n}\n\nbool check() {\n  vector<bool> ch;\n  for(int i = 0; i < n; ++i) {\n    if(s[i] == '(')\n      ch.push_back(0);\n    else if(s[i] == ')') {\n      if(ch.empty() || !ch.back()) return 0;\n      ch.pop_back();\n    }\n    if(ch.size() &&\n       (s[i] == '+' || s[i] == '-' || s[i] == '*'))\n      ch.back() = 1;\n    if(i != 0 && s[i - 1] == '(' && !isdigit(s[i]) &&\n       s[i] != '(')\n      return 0;\n    if(i != 0 && s[i - 1] == ')' &&\n       (isdigit(s[i]) || s[i] == '('))\n      return 0;\n    if(i != 0 &&\n       (s[i - 1] == '+' || s[i - 1] == '-' ||\n        s[i - 1] == '*') &&\n       !isdigit(s[i]) && s[i] != '(')\n      return 0;\n    if(i != 0 && isdigit(s[i - 1]) && s[i] == '(') return 0;\n  }\n  return ch.empty();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef string::const_iterator State;\nint res=-5000;\nstring str;\nbool over;\n\nint expression(State &begin);\n\nint ope[101];\n\nbool ex_good(){\n\tint cc=0;\n\tmemset(ope,0,sizeof(ope));\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]==')'){\n\t\t\tif(cc==0)return false;\n\t\t\tif(!(isdigit(str[i-1]) || str[i-1]==')'))return false;\n\t\t\tif(ope[cc]==0)return false;\n\t\t\tope[cc]=0;\n\t\t\tcc--;\n\t\t}\n\t\tif(str[i]=='('){\n\t\t\tcc++;\n\t\t\tif(i==0)continue;\n\t\t\tif(isdigit(str[i-1]) || str[i-1]==')')return false;\n\t\t}\n\t\tif(isdigit(str[i])){\n\t\t\tif(i==0)continue;\n\t\t\tif(str[i-1]==')')return false;\n\t\t}\n\t\tif(str[i]=='+' || str[i]=='-' || str[i]=='*'){\n\t\t\tif(i==0 || i==str.size()-1)return false;\n\t\t\tif(!(isdigit(str[i-1]) || str[i-1]==')'))return false;\n\t\t\tif(!(isdigit(str[i+1]) || str[i+1]=='('))return false;\n\t\t\tope[cc]++;\n\t\t}\n\t}\n\tif(cc>0)return false;\n\treturn true;\n}\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=2;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t\tif(ret>=1024)over=true;\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t\tif(ret>=1024)over=true;\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret=term(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t\tif(ret>=1024)over=true;\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t\tif(ret<0)over=true;\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nvoid dfs(int v){\n\tif(v==str.size()){\n\t\tState s=str.begin();\n\t\tif(!ex_good())return;\n\t\tover=false;\n\t\tint val=expression(s);\n\t\tif(!over && v<1024)res=max(res,val);\n\t}else{\n\t\tif(str[v]!='.'){\n\t\t\tdfs(v+1);\n\t\t}else{\n\t\t\tstr[v]='0';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='1';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='+';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='-';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='*';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='(';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]=')';\n\t\t\tdfs(v+1);\n\t\t\tstr[v]='.';\n\t\t}\n\t}\n}\n\nint main(void){\n\tcin >> str;\n\tdfs(0);\n\tprintf(\"%d\\n\",res==-5000?-1:res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nstruct parse_error {};\n\nvoid check_range(int n)\n{\n  if (n < 0 || 1024 <= n) {\n    throw parse_error();\n  }\n}\n\nint expr(Iterator& it, const Iterator& last);\n\nint number(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw parse_error();\n  }\n  int n = 0;\n  while (it != last && isdigit(*it)) {\n    n = 2*n + (*it - '0');\n    ++it;\n  }\n  check_range(n);\n  return n;\n}\n\nint seen_ops = 0;\n\nint factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw parse_error();\n  }\n  if (*it == '(') {\n    ++it;\n    int prev = seen_ops;\n    int n = expr(it, last);\n    if (seen_ops == prev) {\n      throw parse_error();\n    }\n    if (it == last || *it != ')') {\n      throw parse_error();\n    }\n    ++it;\n    return n;\n  } else if (isdigit(*it)) {\n    return number(it, last);\n  } else {\n    throw parse_error();\n  }\n}\n\nint term(Iterator& it, const Iterator& last)\n{\n  int n = factor(it, last);\n  while (it != last && *it == '*') {\n    ++it;\n    ++seen_ops;\n    n *= factor(it, last);\n    check_range(n);\n  }\n  return n;\n}\n\nint expr(Iterator& it, const Iterator& last)\n{\n  int n = term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    ++seen_ops;\n    int m = term(it, last);\n    if (op == '+') {\n      n += m;\n    } else {\n      n -= m;\n    }\n    check_range(n);\n  }\n  return n;\n}\n\nint main()\n{\n  string s;\n  getline(cin, s);\n  int a[5];\n  static const char tbl[] = \"01+-*()\";\n  int ans = -1;\n  for (a[0] = 0; a[0] < 7; a[0]++) {\n    for (a[1] = 0; a[1] < 7; a[1]++) {\n      for (a[2] = 0; a[2] < 7; a[2]++) {\n        for (a[3] = 0; a[3] < 7; a[3]++) {\n          for (a[4] = 0; a[4] < 7; a[4]++) {\n            string t = s;\n            for (int i = 0; i < 5; i++) {\n              string::size_type n = t.find('.');\n              if (n != string::npos) {\n                t[n] = tbl[a[i]];\n              }\n            }\n            try {\n              Iterator it = t.begin(), last = t.end();\n              seen_ops = 0;\n              ans = max(ans, expr(it, last));\n            } catch (const parse_error&) {\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nstring tract(string s){\n  // cout << s << \" \";\n  rep(i,s.size()){\n    if(s[i]=='k')return \"k\";\n  }\n  // まず数字を全てfに変える\n  string s_tmp(s);\n  while(1){\n    // 数字あるかチェック\n    // cout << \"he\" << endl;\n    // cout << s_tmp << endl;\n    int index = 0,flag=0;\n    while(index<s_tmp.size()){\n      if(s_tmp[index]=='0'||s_tmp[index]=='1'){flag=1;break;}\n      index++;\n    }\n    if(!flag)break;\n    int index_e=index;\n    while(index_e<s_tmp.size()){\n      if(s_tmp[index_e]=='0'||s_tmp[index_e]=='1')index_e++;\n      else break;\n    }\n    // cout << index<<\" \"<<index_e<<endl;\n    // cout << s_tmp.substr(0,index)<<endl;\n    s_tmp = s_tmp.substr(0,index)+\"f\"+s_tmp.substr(index_e,s_tmp.size()-index_e);\n    // cout << s_tmp << endl;\n  }\n  // cout << s_tmp<<endl;\n\n\n  while(1){\n  // cout <<s_tmp<<endl;\n\n    stack<int> left,right;\n    int index=0;\n    rep(i,s_tmp.size()){\n      if(s_tmp[i]=='(')left.push(i);\n      else if(s_tmp[i]==')')right.push(i);\n    }\n    if(left.size()!=right.size())return \"k\";\n    if(left.size()>0){\n      int il = left.top();\n      int ir = il;\n      while(ir<s_tmp.size()){\n        if(s_tmp[ir]==')')break;\n        ir++;\n      }\n      // cout << il << \" \" << ir << endl;\n      string tmp = tract(s_tmp.substr(il+1,ir-il-1));\n      // cout << \"rec \" << tmp << endl;\n      if (tmp==\"k\"||tmp==\"f\")return \"k\";\n      else if(tmp==\"e\"){\n        // cout << il << \" \" << ir << endl;\n        s_tmp = s_tmp.substr(0,il)+\"f\"+s_tmp.substr(ir+1,s_tmp.size()-ir-1);\n        continue;\n      } \n    } else {\n      // ()がない場合\n      int flag = 0;\n      // cout << \"no \"<<s_tmp<<endl;\n      rep(i,s_tmp.size()){\n        if(s_tmp[i]=='+'||s_tmp[i]=='-'||s_tmp[i]=='*'){\n          if(s_tmp[i+1]!='f'&&s_tmp[i+1]!='e'){\n            flag = 1; // ダメ\n            break;\n          } else if(s_tmp[i-1]!='f'&&s_tmp[i-1]!='e'){\n            flag = 1;\n            break;\n          }\n        } else { // s_tmp[i]=='f' or 'e'\n          if(i+1<s_tmp.size()&&(s_tmp[i+1]=='f'||s_tmp[i+1]=='e')){\n            flag = 1;\n          } else if(i-1>0&&(s_tmp[i-1]=='f'||s_tmp[i-1]=='e')){\n            flag = 1;\n          }\n        }\n      }\n      if (flag)return \"k\";\n      if(s_tmp==\"f\")return \"f\";\n      else return \"e\";\n    }\n  }\n}\n\n\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint  expression(State &begin);\nint factor(State &begin);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\nint term(State &begin){\n  int ret = factor(begin);\n  int flag = 0;\n  if(!inner(ret))return -INF;\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin);\n      if(!inner(tmp))return -INF;\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// 式のパース\nint expression(State &begin){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin);\n  // cout << \"in expr \"<<ret << endl;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return -INF;\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin);\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin);\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  // if(!flag)return -INF;\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// ()のパース\nint factor(State &begin){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    begin++;\n    int ret = expression(begin);\n    // cout << \"from expr \"<<ret<<endl;\n    begin++;\n    return ret;\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return -INF;\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return k;\n  }\n}\n\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    // cout << \"~~~~\"<<endl;\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    // 括弧の対応をチェック\n    int sum = 0,flag=0;\n    rep(i,sc.size()){\n      if(sc[i]=='(')sum++;\n      if(sc[i]==')')sum--;\n      if(sum<0)flag=1;\n    }\n    if(sum!=0)flag=1;\n    string tm;\n    if(!flag){\n      tm = tract(sc);\n    } else {\n      tm = \"k\";\n    }\n    // cout <<\"now here \"<< tm << endl;\n    if(tm==\"k\")flag=1;\n    // tmp = calculate(sc);\n    State begin = sc.begin();\n    tmp = expression(begin);\n    // cout << tmp << endl;\n    // cout << sc << endl;\n    // tmp=-1;\n    if(!flag&&tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\nbool valid(int x){\n  return 0<=x&&x<1<<10;\n}\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(!valid(e.first)||!e.second||s[x]!=')')return fail;\n    x++;\n    return make_pair(e.first,false);\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      if(!valid(n))return fail;\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(!valid(f.first))return fail;\n  while(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(!valid(l.first))return fail;\n    f.first*=l.first;\n    if(!valid(f.first))return fail;\n    f.second=true;\n  }\n  return f;\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(!valid(f.first))return fail;\n  while(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(!valid(l.first))return fail;\n    f.first+=sign*l.first;\n    if(!valid(f.first))return fail;\n    f.second=true;\n  }\n  return f;\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tint r=dfs();\n\tif(valid(r)){\n\t  m=max(m,r);\n\t}\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint formula(int &p,bool inper);\npair<int,bool> term1(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint calc(int lhs,int rhs,char op){\n  int res=-1;\n  if(lhs==-1 || rhs==-1) return -1;\n  if(op=='+') res=lhs+rhs;\n  if(op=='-') res= lhs-rhs;\n  if(op=='*') res= lhs*rhs;\n  return (0<=res && res<1024) ? res : -1;\n}\n\nstring s;\nint formula(int &p,bool inper=false){\n  bool isok=!inper;\n  pair<int,bool> ret=term1(p);\n  int res=ret.first;\n  isok|=ret.second;\n  while(p<s.size() && s[p]!=')'){\n    inper=false;\n    char op=s[p];\n    if(op!='+' && op!='-'){\n      return -1;\n    }\n    isok=true;\n    p++;\n    int rhs=term1(p).first;\n    res=calc(res,rhs,op);\n  }\n  return isok ? res : -1;\n}\n\npair<int,bool> term1(int &p){\n  int res=term2(p);\n  bool res2=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;\n    if(op!='*'){\n      return {-1,0};\n    }\n    res2=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,res2};\n}\n\nint term2(int &p){\n  int res=-1;\n  if(s[p]=='('){\n    p++;\n    res=formula(p,true);\n    if(s[p]!=')') return -1;\n    p++;\n  }\n  else if(isdigit(s[p])){\n    res=get_num(p);\n  }\n  else{\n    return -1;\n  }\n  return res;\n}\n\nint get_num(int &p){\n  int res=-1;\n  while(isdigit(s[p])){\n    if(res==-1) res=0;\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  //cout<<res<<endl;\n  if(res>=1024) return -1;\n  return res;\n}\n\nstring ch=\"01+-*()\";\n\nint dfs(int i){\n  if(i==s.size()){\n    int p=0;\n    //cout<<s<<endl;\n    int res=formula(p);\n    //cout<<res<<endl;\n    return res;\n  }\n  if(s[i]=='.'){\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      res=max(res,dfs(i+1));\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\n\t\tif (val >= 1024)return -1;\n\t\tif (val < 0)return -1;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t\tif (val >= 1024)return - 1;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num])){\n\t\tn = n * 2 + s[num++] - '0';\n\t\tif (n >= 1024)return -1;\n\t}\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\tsc.push('0');\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.empty()||sc.top() == '0'){\n\t\t\tans = expr(s, num);\n\t\t\tma = max(ma, ans);\n\t\t}\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ninline bool valid(int x){ return 0<=x && x<1024; }\n\nchar e[128];\n\ninline bool ispm(char c){\n    return c=='+' || c=='-';\n}\ninline bool ispd(char c){\n    return c=='*' || c=='/';\n}\n\nint num(char* &p);\nint fac(char* &p);\nint term(char* &p);\nint expr(char* &p);\n\nint num(char* &p){\n    int res = 0;\n    if(isdigit(*p)){\n        ;\n    }else{\n        throw \"num begin\";\n    }\n    while (isdigit(*p)){\n        res<<=1;\n        res+=*p-'0';\n        p++;\n    }\n\n    if(*p=='\\0' || *p==')' || ispm(*p) || ispd(*p)){\n        ;\n    }else{\n        throw \"num end\";\n    }\n\n    if(!valid(res)) throw \"overflow\";\n    return res;\n}\n\nint fac(char* & p){\n    int res = 0;\n    if(*p=='(' || isdigit(*p)){\n        ;\n    }else{\n        throw \"fac begin\";\n    }\n\n    if(*p=='('){\n        p++;\n        res += expr(p);\n        p++;\n    }else if(isdigit(*p)){\n        res += num(p);\n    }\n    if(*p=='\\0' || *p==')' || ispm(*p) || ispd(*p)){\n        ;\n    }else{\n        throw \"fac end\";\n    }\n\n    if(!valid(res)) throw \"overflow\";\n    return res;\n}\n\nint term(char* & p){\n    int res;\n    if(*p=='(' || isdigit(*p)){\n        res = fac(p);\n    }else{\n        throw \"term begin\";\n    }\n    while(1){\n        if(*p=='*'){\n            p++;\n            res *= fac(p);\n        }else if(*p=='/'){\n            p++;\n            res /= fac(p);\n        }else if(*p=='\\0' || *p==')' || *p=='+' || *p=='-'){\n            break;\n        }else{\n            throw \"term end\";\n        }\n    }\n\n    if(!valid(res)) throw \"overflow\";\n    return res;\n}\n\nint expr(char* & p){\n    int res;\n    if(*p=='(' || isdigit(*p)){\n        res=term(p);\n    }else{\n        throw \"exp begin\";\n    }\n\n    while(1){\n        if(*p=='+'){\n            p++;\n            res += term(p);\n        }else if(*p=='-'){\n            p++;\n            res -= term(p);\n        }else if(*p=='\\0' || *p==')' || ispm(*p) || ispd(*p)){\n            break;\n        }else{\n            throw \"exp end\";\n        }\n        if(!valid(res)) throw \"overflow\";\n    }\n\n    return res;\n}\n\nbool check(char* e){\n    stack<int> s;\n    for(int i=0;e[i];i++){\n        if(e[i]=='(')s.push(i);\n        else if(e[i]==')'){\n            if(s.size()){\n                int j=s.top();\n                s.pop();\n                int depth=0;\n                bool ok=false;\n                loop(k,j,i+1){\n                    if((ispm(e[k]) || ispd(e[k])) && depth==1) ok=true;\n                    else if(e[k]=='(') depth++;\n                    else if(e[k]==')') depth--;\n                }\n                if(!ok) return false;\n            }else{\n                return false;\n            }\n        }\n    }\n    return s.size()==0;\n}\n\nint solve(){\n    int ps[10];\n    int c=0;\n    for(int i=0;e[i];i++){\n        if(e[i]=='.'){\n            ps[c++]=i;\n        }\n    }\n    int fine=1;\n    rep(i,c)fine*=7;\n    int ans=-1;\n    rep(mask,fine){\n        int k=mask;\n        rep(i,c){\n            int p=k%7;\n            static const char cs[]=\"1-(*0+)\";\n            e[ps[i]]=cs[p];\n            k/=7;\n        }\n        if(!check(e)) continue;\n        try{\n            auto it=e;\n            ans=max(ans,expr(it));\n            // cout << e << \" : \" << \"ok\" << endl;\n        }catch(const char* c){\n            // cout << e << \" : \" << c << endl;\n        }\n    }\n    return ans;\n}\n\nint main(){\n    scanf(\"%s\",e);\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 9;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseVaule(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  if(find(temp, it, '+')==it && find(temp, it, '*')==it && find(temp, it, '-')==it ){\n    return false;\n  }\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseVaule(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseVaule(it, &rv)) return false;\n    *result *= rv;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res -= term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }\n    }\n    if(res<0||res>=1024){\n        ppppp = 1;\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 32;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(it+length==end || *(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  *result >>= max_length-length+1;\n  if(*result >= 1024) return false;\n  \n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    *result *= rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[200];\nchar *p;\nint n;\n\nbool ok(int n){\n    return 0<=n && n<=(1<<10);\n}\n\nint E();\nint F();\nint T();\nint N();\n\nint E(){\n    int res = F();\n    while(*p=='+' || *p=='-'){\n        if(*p=='+') p++, res += F();\n        else if(*p=='-') p++, res -= F();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint F(){\n    int res = T();\n    while(*p=='*' || *p=='/'){\n        if(!ok(res)) throw \"\";\n        if(*p=='*') p++, res *= T();\n        else if(*p=='/') p++, res /= T();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint T(){\n    int res;\n    if(*p=='(') p++, res = E(), p++;\n    else res = N();\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nint N(){\n    int res = 0;\n    if(!isdigit(*p)) throw \"\";\n    while(isdigit(*p)){\n        res = res*2 + *p - '0';\n        p++;\n    }\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nbool chk(){\n    for(int i=0;i<n;i++){\n        if(s[i]!='(') continue;\n        int j = i;\n        int d = 0;\n        int cnt = 0;\n        while(s[j]){\n            if(s[j]=='(') d++;\n            else if(s[j]==')') d--;\n            if(d==1) if(s[j]=='+' || s[j]=='-') cnt++;\n            if(d==0) break;\n            j++;\n        }\n        dump(cnt);\n        dump(d);\n        if(d!=0 || cnt==0) return false;\n    }\n    return true;\n}\n\nint main(){\n    cin >> s;\n    n = strlen(s);\n    int x[6], k = 0;\n    char cand[] = \"01+-*())\";\n    for(int i=0;i<n;i++){\n        if(s[i]=='.') x[k++] = i;\n    }\n    int ans = -1;\n    for(int mask=0;mask<1<<(3*k);mask++){\n        p = s;\n        int t = mask;\n        for(int i=0;i<k;i++) s[x[i]] = cand[t>>(3*i)&7];\n        dump(s);\n        if(!chk()) continue;\n        try {\n            int t = E();\n            if(p-s!=n) continue;\n            dump(t);\n            ans = max(ans,t);\n        } catch(...){}\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  rep(i,s.size()){\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n      if(i==s.size()-1){\n        return -INF;\n      } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n        return -INF;\n      }\n    }\n  }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'){\n      ret = calculate(s.substr(0,index+1))+calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='-'){\n      ret = calculate(s.substr(0,index+1))-calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = ret1*ret2;\n        if(inner(ret)){\n          return ret;\n        } else {\n          return -INF;\n        }\n      } else {\n        return -INF;\n      }\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    tmp = calculate(sc);\n    if(tmp>maxn)maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Node{\npublic:\n    char ope;\n    string s;\n    Node *left, *right;\n    Node(){\n        ope = '\\0';\n        left = right = NULL;\n    }\n    ~Node(){\n        delete left;\n        delete right;\n    }\n};\n\n// 数式の構文木を作成する\nclass syntacticAnalysis\n{\n    vector<int> binaryPriority;       // 二項演算子の優先順位（数値が小さいほど優先順位が高い。-1ならば二項演算子ではない）\n    vector<bool> binaryAssociativity; // 二項演算子の結合規則（trueならば左から右に結合）\n    vector<bool> isUnaryOpe;          // 単項演算子\n    stack<pair<Node*, bool> > stk;\n    void deleteAllNodes()\n    {\n        while(!stk.empty()){\n            delete stk.top().first;\n            stk.pop();\n        }\n    }\n    bool calc(int maxPriority)\n    {\n        if(!stk.top().second)\n            return false;\n        pair<Node*, bool> right = stk.top();\n        stk.pop();\n        while(stk.top().first != NULL){\n            pair<Node*, bool> ope = stk.top();\n            if(ope.second)\n                break;\n            stk.pop();\n            if(binaryPriority[ope.first->ope] != -1 && stk.top().second){\n                if(binaryPriority[ope.first->ope] > maxPriority ||\n                        binaryPriority[ope.first->ope] == maxPriority && !binaryAssociativity[ope.first->ope]){\n                    stk.push(ope);\n                    break;\n                }\n                ope.first->right = right.first;\n                ope.first->left = stk.top().first;\n                ope.second = true;\n                right = ope;\n                stk.pop();\n            }else if(isUnaryOpe[ope.first->ope]){\n                ope.first->right = right.first;\n                ope.second = true;\n                right = ope;\n            }else{\n                stk.push(ope);\n                break;\n            }\n        }\n        bool ret = (stk.top().first == NULL);\n        stk.push(right);\n        return ret;\n    }\npublic:\n    // binaryOpe : 二項演算子（優先順位の高い順に並べる。secondは結合規則を表し、trueならば左から右に結合）\n    // unaryOpe  : 単項演算子（前置演算子のみ対応）\n    syntacticAnalysis(const vector<pair<string, bool> >& binaryOpe, const string& unaryOpe)\n    {\n        binaryPriority.assign(128, -1);\n        binaryAssociativity.resize(128);\n        isUnaryOpe.assign(128, false);\n        for(unsigned i=0; i<binaryOpe.size(); ++i){\n            for(unsigned j=0; j<binaryOpe[i].first.size(); ++j){\n                binaryPriority[binaryOpe[i].first[j]] = i;\n                binaryAssociativity[binaryOpe[i].first[j]] = binaryOpe[i].second;\n            }\n        }\n        for(unsigned i=0; i<unaryOpe.size(); ++i)\n            isUnaryOpe[unaryOpe[i]] = true;\n    }\n    Node* makeTree(const string& s)\n    {\n        int n = s.size();\n        int i = 0;\n        stk.push(make_pair((Node*)NULL, false));\n        while(i < n){\n            if(s[i] == '('){\n                stk.push(make_pair((Node*)NULL, false));\n                ++ i;\n            }else if(s[i] == ')'){\n                if(!calc(INT_MAX) || stk.size() == 2 || stk.top().first->ope == '\\0'){\n                    deleteAllNodes();\n                    return NULL;\n                }\n                pair<Node*, bool> node = stk.top();\n                stk.pop();\n                stk.pop();\n                stk.push(node);\n                ++ i;\n            }else if(binaryPriority[s[i]] != -1 || isUnaryOpe[s[i]]){\n                calc(binaryPriority[s[i]]);\n                Node* node = new Node;\n                node->ope = s[i];\n                stk.push(make_pair(node, false));\n                ++ i;\n            }else{\n                Node* node = new Node;\n                while(i < n && s[i] != '(' && s[i] != ')' && binaryPriority[s[i]] == -1 && !isUnaryOpe[s[i]]){\n                    node->s += s[i];\n                    ++ i;\n                }\n                stk.push(make_pair(node, true));\n            }\n        }\n\n        if(!calc(INT_MAX) || stk.size() != 2){\n            deleteAllNodes();\n            return NULL;\n        }else{\n            Node* ret = stk.top().first;\n            stk.pop();\n            stk.pop();\n            return ret;\n        }\n    }\n};\n\nint solve(const Node* node)\n{\n    if(node->ope == '\\0'){\n        int ret = 0;\n        for(unsigned i=0; i<node->s.size(); ++i){\n            ret *= 2;\n            if(node->s[i] == '1')\n                ++ ret;\n            if(ret >= 1024)\n                return -1;\n        }\n        return ret;\n    }\n\n    int left = solve(node->left);\n    int right = solve(node->right);\n    if(left == -1 || right == -1)\n        return -1;\n\n    int ret;\n    if(node->ope == '+')\n        ret = solve(node->left) + solve(node->right);\n    else if(node->ope == '-')\n        ret = solve(node->left) - solve(node->right);\n    else\n        ret = solve(node->left) * solve(node->right);\n\n    if(ret < 0 || ret >= 1024)\n        return -1;\n    else\n        return ret;\n}\n\nconst string c = \"01+-*()\";\n\nint main()\n{\n    vector<pair<string, bool> > binaryOpe(2);\n    binaryOpe[0] = make_pair(\"*\", true);\n    binaryOpe[1] = make_pair(\"+-\", true);\n    syntacticAnalysis sa(binaryOpe, \"\");\n\n    string s;\n    cin >> s;\n    int n = s.size();\n\n    int m = 0;\n    vector<int> index;\n    for(int i=0; i<n; ++i){\n        if(s[i] == '.'){\n            index.push_back(i);\n            ++ m;\n        }\n    }\n\n    int ret = -1;\n    if(m == 0){\n        Node* node = sa.makeTree(s);\n        ret = max(ret, solve(node));\n    }else{\n        for(int i=0; ; ++i){\n            int a = i;\n            for(int j=0; j<m; ++j){\n                s[index[j]] = c[a%8];\n                a /= 8;\n            }\n            if(a > 0)\n                break;\n\n            Node* node = sa.makeTree(s);\n            if(node != NULL)\n                ret = max(ret, solve(node));\n            delete node;\n        }\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint ans=-1;\n\nint ex(string::iterator &it,int r){\n    if(r==0){\n        int res=ex(it,r+1);\n        if(res==-1)return -1;\n        while(true){\n            if(*it=='+'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res+=x;\n            }\n            else if(*it=='-'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res-=x;\n            }\n            else break;\n            if(res<0||res>=1024)return -1;\n        }\n        return res;\n    }\n    if(r==1){\n        int res=ex(it,r+1);\n        if(res==-1)return -1;\n        while(true){\n            if(*it=='*'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res*=x;\n            }\n            else break;\n            if(res<0||res>=1024)return -1;\n        }\n        return res;\n    }\n    if(r==2){\n        if(*it=='('){\n            it++;\n            int res=ex(it,0);\n            it++;\n            return res;\n        }\n        return ex(it,r+1);\n    }\n    if(r==3){\n        if(!isdigit(*it))return -1;\n        int res=0;\n        while(isdigit(*it)){\n            res=res*2+*it-'0';\n            it++;\n            if(res>=1024)return -1;\n        }\n        return res;\n    }\n}\n\nvoid solve(string s){\n    stack<int>st;\n    vint beet(s.size(),-1);\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='('){\n            st.push(i);\n        }\n        else if(s[i]==')'){\n            if(st.size()==0)return;\n            int t=st.top();\n            beet[t]=i;\n            st.pop();\n            if(s[t+1]=='('&&beet[t+1]==i-1)return;\n            bool ok=false;\n            for(int j=t+1;j<i;j++)if(s[j]=='+'||s[j]=='-'||s[j]=='*')ok=true;\n            if(!ok)return;\n        }\n    }\n    if(st.size())return;\n    s+=\"=\";\n    auto it=s.begin();\n    int tmp=ex(it,0);\n    if(*it!='=')return;\n    if(tmp==56)cout<<s<<endl;\n    chmax(ans,tmp);\n}\n\nvoid dfs(int n,string &S){\n    if(n==S.size()){\n        solve(S);\n        return;\n    }\n    if(S[n]=='.'){\n        rep(i,7){\n            S[n]=\"01+-*()\"[i];\n            dfs(n+1,S);\n        }\n        S[n]='.';\n    }\n    else{\n        dfs(n+1,S);\n    }\n}\n\nsigned main(){\n    string S;\n    cin>>S;\n    dfs(0,S);\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nstruct parse_error {};\n\nvoid check_range(int n)\n{\n  if (n < 0 || 1024 <= n) {\n    throw parse_error();\n  }\n}\n\nint expr(Iterator& it, const Iterator& last);\nint term(Iterator& it, const Iterator& last);\n\nint number(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw parse_error();\n  }\n  int n = 0;\n  while (it != last && isdigit(*it)) {\n    n = 2*n + (*it - '0');\n    ++it;\n    check_range(n);\n  }\n  return n;\n}\n\nint factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw parse_error();\n  }\n  if (*it == '(') {\n    ++it;\n\n    int n = factor(it, last);\n    if (it == last) {\n      throw parse_error();\n    }\n    if (*it == '*') {\n      while (it != last && *it == '*') {\n        ++it;\n        n *= factor(it, last);\n        check_range(n);\n      }\n      while (it != last && (*it == '+' || *it == '-')) {\n        const char op = *it;\n        ++it;\n        int m = term(it, last);\n        if (op == '+') {\n          n += m;\n        } else {\n          n -= m;\n        }\n        check_range(n);\n      }\n    } else if (*it == '+' || *it == '-') {\n      while (it != last && (*it == '+' || *it == '-')) {\n        const char op = *it;\n        ++it;\n        int m = term(it, last);\n        if (op == '+') {\n          n += m;\n        } else {\n          n -= m;\n        }\n        check_range(n);\n      }\n    } else {\n      throw parse_error();\n    }\n\n    if (it == last || *it != ')') {\n      throw parse_error();\n    }\n    ++it;\n    return n;\n  } else if (isdigit(*it)) {\n    return number(it, last);\n  } else {\n    throw parse_error();\n  }\n}\n\nint term(Iterator& it, const Iterator& last)\n{\n  int n = factor(it, last);\n  while (it != last && *it == '*') {\n    ++it;\n    n *= factor(it, last);\n    check_range(n);\n  }\n  return n;\n}\n\nint expr(Iterator& it, const Iterator& last)\n{\n  int n = term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    int m = term(it, last);\n    if (op == '+') {\n      n += m;\n    } else {\n      n -= m;\n    }\n    check_range(n);\n  }\n  return n;\n}\n\nint main()\n{\n  string s;\n  getline(cin, s);\n  int a[5];\n  static const char tbl[] = \"01+-*()\";\n  int ans = -1;\n  for (a[0] = 0; a[0] < 7; a[0]++) {\n    for (a[1] = 0; a[1] < 7; a[1]++) {\n      for (a[2] = 0; a[2] < 7; a[2]++) {\n        for (a[3] = 0; a[3] < 7; a[3]++) {\n          for (a[4] = 0; a[4] < 7; a[4]++) {\n            string t = s;\n            for (int i = 0; i < 5; i++) {\n              string::size_type n = t.find('.');\n              if (n != string::npos) {\n                t[n] = tbl[a[i]];\n              }\n            }\n            try {\n              Iterator it = t.begin(), last = t.end();\n              int n = expr(it, last);\n              //cerr << \"got \" << n << endl;\n              ans = max(ans, n);\n            } catch (const parse_error&) {\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nstring tract(string s){\n  // cout << s << \" \";\n  rep(i,s.size()){\n    if(s[i]=='k')return \"k\";\n  }\n  // まず数字を全てfに変える\n  string s_tmp(s);\n  while(1){\n    // 数字あるかチェック\n    // cout << \"he\" << endl;\n    // cout << s_tmp << endl;\n    int index = 0,flag=0;\n    while(index<s_tmp.size()){\n      if(s_tmp[index]=='0'||s_tmp[index]=='1'){flag=1;break;}\n      index++;\n    }\n    if(!flag)break;\n    int index_e=index;\n    while(index_e<s_tmp.size()){\n      if(s_tmp[index_e]=='0'||s_tmp[index_e]=='1')index_e++;\n      else break;\n    }\n    // cout << index<<\" \"<<index_e<<endl;\n    // cout << s_tmp.substr(0,index)<<endl;\n    s_tmp = s_tmp.substr(0,index)+\"f\"+s_tmp.substr(index_e,s_tmp.size()-index_e);\n    // cout << s_tmp << endl;\n  }\n  // cout << s_tmp<<endl;\n\n\n  while(1){\n  // cout <<s_tmp<<endl;\n\n    stack<int> left,right;\n    int index=0;\n    rep(i,s_tmp.size()){\n      if(s_tmp[i]=='(')left.push(i);\n      else if(s_tmp[i]==')')right.push(i);\n    }\n    if(left.size()!=right.size())return \"k\";\n    if(left.size()>0){\n      int il = left.top();\n      int ir = il;\n      while(ir<s_tmp.size()){\n        if(s_tmp[ir]==')')break;\n        ir++;\n      }\n      // cout << il << \" \" << ir << endl;\n      string tmp = tract(s_tmp.substr(il+1,ir-il-1));\n      // cout << \"rec \" << tmp << endl;\n      if (tmp==\"k\"||tmp==\"f\")return \"k\";\n      else if(tmp==\"e\"){\n        // cout << il << \" \" << ir << endl;\n        s_tmp = s_tmp.substr(0,il)+\"f\"+s_tmp.substr(ir+1,s_tmp.size()-ir-1);\n        continue;\n      } \n    } else {\n      // ()がない場合\n      int flag = 0;\n      // cout << \"no \"<<s_tmp<<endl;\n      rep(i,s_tmp.size()){\n        if(s_tmp[i]=='+'||s_tmp[i]=='-'||s_tmp[i]=='*'){\n          if(s_tmp[i+1]!='f'&&s_tmp[i+1]!='e'){\n            flag = 1; // ダメ\n            break;\n          } else if(s_tmp[i-1]!='f'&&s_tmp[i-1]!='e'){\n            flag = 1;\n            break;\n          }\n        } else { // s_tmp[i]=='f' or 'e'\n          if(i+1<s_tmp.size()&&(s_tmp[i+1]=='f'||s_tmp[i+1]=='e')){\n            flag = 1;\n          } else if(i-1>0&&(s_tmp[i-1]=='f'||s_tmp[i-1]=='e')){\n            flag = 1;\n          }\n        }\n      }\n      if (flag)return \"k\";\n      if(s_tmp==\"f\")return \"f\";\n      else return \"e\";\n    }\n  }\n}\n\n\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint  expression(State &begin);\nint factor(State &begin);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\nint term(State &begin){\n  int ret = factor(begin);\n  int flag = 0;\n  if(!inner(ret))return -INF;\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin);\n      if(!inner(tmp))return -INF;\n      ret *= tmp;\n      if(!inner(ret))return -INF;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// 式のパース\nint expression(State &begin){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin);\n  // cout << \"in expr \"<<ret << endl;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return -INF;\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin);\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      if(!inner(ret))ret=-INF;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin);\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      if(!inner(ret))ret=-INF;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  // if(!flag)return -INF;\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// ()のパース\nint factor(State &begin){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    begin++;\n    int ret = expression(begin);\n    // cout << \"from expr \"<<ret<<endl;\n    if(!inner(ret))return -INF;\n    begin++;\n    return ret;\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return -INF;\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    if(!inner(k))return -INF;\n    // cout << k << endl;\n    return k;\n  }\n}\n\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    // cout << \"~~~~\"<<endl;\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    // 括弧の対応をチェック\n    int sum = 0,flag=0;\n    rep(i,sc.size()){\n      if(sc[i]=='(')sum++;\n      if(sc[i]==')')sum--;\n      if(sum<0)flag=1;\n    }\n    if(sum!=0)flag=1;\n    string tm;\n    if(!flag){\n      tm = tract(sc);\n    } else {\n      tm = \"k\";\n    }\n    // cout <<\"now here \"<< tm << endl;\n    if(tm==\"k\")flag=1;\n    // tmp = calculate(sc);\n    State begin = sc.begin();\n    tmp = expression(begin);\n    // cout << tmp << endl;\n    // cout << sc << endl;\n    // tmp=-1;\n    if(!flag&&tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1<<10)\nusing namespace std;\n\nstring s;\nvector<int> idx;\nvector<char> c;\nchar lis[7]={'0','1','+','-','*','(',')'};\nint ans=-1, p, flag;\n\nbool check(){\n\n  int r=0, f=0;\n\n  for(int i=p;i<s.size();i++){\n    if(r==1&&(s[i]=='+'||s[i]=='-'||s[i]=='*')) f=1;\n    if(s[i]=='(') r++;\n    if(s[i]==')') r--;\n    if(r==0) break;\n  }\n  \n  return f==1;\n}\n\nint bnf();\n\nint bnf3(){\n\n  int res=0;\n  \n  if(s[p]=='('){\n    \n    bool r=check();\n    \n    p++;\n    res=bnf();\n    p++;\n   \n    if(!r) flag=1;\n    \n    return res;\n  }\n\n  if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1'){\n    res=res*2+s[p]-'0', p++;\n    if(res>=INF||res<0) flag=1;\n  }\n\n  return res;\n}\n\nint bnf2(){\n  \n  int res=bnf3();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='*'){\n      p++;\n      res=res*bnf3();\n      if(res>=INF) flag=1;\n    }else{\n      if(p<s.size()&&s[p]!=')'&&s[p]!='+'&&s[p]!='-') flag=1;\n      break;\n    }\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n      p++;\n      res=res+bnf2();\n      if(res>=INF) flag=1;\n    }\n    else if(s[p]=='-'){\n      p++;\n      res=res-bnf2();\n      if(res<0) flag=1;\n    }else{\n      if(p<s.size()&&s[p]!=')') flag=1;\n      break;\n    }\n  }\n  \n  return res;\n}\n\nbool check2(){\n  \n  int r=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') r++;\n    if(s[i]==')'){\n      if(!r) return false;\n      r--;\n    }\n  }\n\n  if(r) return false;\n\n  return true;\n}\n\nvoid dfs(int x){\n  \n  if(x==idx.size()){\n    \n    for(int i=0;i<idx.size();i++)\n      s[idx[i]]=c[i];\n    \n    p=0, flag=0;\n    \n    if(!check2()) return ;\n    \n    int r=bnf();\n    \n    if(r>=INF||flag) return ;\n\n    ans=max(ans,r);\n    \n    return ;\n  }\n  \n  for(int i=0;i<7;i++){\n    \n    c[x]=lis[i];\n    \n    dfs(x+1);\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>s;\n  \n  for(int i=0;i<s.size();i++)\n    if(s[i]=='.') idx.push_back(i);\n\n  c.resize(idx.size());\n\n  dfs(0);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n        }else{\n            res -= term(++pos);\n            if(res<0){\n                ppppp = 1;\n            }\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    bool ok = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n        }\n    }\n    if(flag){\n        return 0;\n    }\n    if(tmp2==b){\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp-1,1)&check(tmp2+2,b,0);\n        }\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n        pos = 0;\n        cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tconst int kind = 7;\n\tStage(){\n\t}\n\t\n\tvoid action(){\n\t\tstring text;\n\t\tcin >> text;\n\n\t\tint res = -1;\n\t\tREP(transWay, pow(kind, count_dot(text))) {\n\t\t\tstring transedText = trans(transWay, text);\n\t\t\tif (transWay == 265) {\n\t\t\t\tint a;\n\t\t\t\ta = 5;\n\t\t\t}\n\t\t\tlist<char> ls;\n\t\t\tfor (char c : transedText)ls.push_back(c);\n\t\t\tauto grams = trans_gram(ls);\n\t\t\tint score = read(grams);\n\n\t\t\tres = max(res, score);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tchar data;\n\t\tint num;\n\t};\n\t\n\tint count_dot(const string& text) {\n\t\tint res = 0;\n\t\tfor (char c : text)if (c == '.')res++;\n\t\treturn res;\n\t}\n\tstring trans(int n, string text) {\n\t\tfor (char& c : text)if (c == '.') {\n\t\t\tswitch (n % kind) {\n\t\t\tcase 0:c = '0'; break;\n\t\t\tcase 1:c = '1'; break;\n\t\t\tcase 2:c = '+'; break;\n\t\t\tcase 3:c = '-'; break;\n\t\t\tcase 4:c = '*'; break;\n\t\t\tcase 5:c = '('; break;\n\t\t\tcase 6:c = ')'; break;\n\t\t\t}\n\t\t\tn /= kind;\n\t\t}\n\t\treturn text;\n\t}\n\n\tlist<Gram> trans_gram(const list<char>& ls) {\n\t\tlist<Gram> grams;\n\t\tfor (auto itr = ls.begin(); itr != ls.end(); ++itr) {\n\t\t\tGram gram;\n\t\t\tswitch (*itr) {\n\t\t\tcase '+':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '+';\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '-';\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '*';\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = ')';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgram.kind = 'n';\n\t\t\t\tgram.data = '.';\n\t\t\t\tgram.num = 0;\n\t\t\t\tdo {\n\t\t\t\t\tgram.num *= 2;\n\t\t\t\t\tgram.num += *itr - '0';\n\t\t\t\t\t++itr;\n\t\t\t\t} while (itr != ls.end() && isdigit(*itr));\n\t\t\t\t--itr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tint read(list<Gram> grams){\n\t\ttry {\n\t\t\t// ( , ) delete\n\t\t\tfor (auto right = grams.begin(); right != grams.end(); ++right)\n\t\t\t{\n\t\t\t\tif (right->data == ')') {\n\t\t\t\t\tlist<Gram> subset;\n\t\t\t\t\tauto left = right;\n\n\t\t\t\t\t//move: (expression)\n\t\t\t\t\twhile (left != grams.begin() && left->data != '(') --left;\n\t\t\t\t\tif (left->data != '(')throw - 1;\n\t\t\t\t\t++right;\n\t\t\t\t\tsubset.splice(subset.begin(), move(grams), left, right);\n\n\t\t\t\t\t// delete: ( , )\n\t\t\t\t\tsubset.pop_front();\n\t\t\t\t\tsubset.pop_back();\n\n\t\t\t\t\tif (subset.size() == 1)throw - 1;\n\n\t\t\t\t\tint res = read(subset);\n\t\t\t\t\tif (res < 0)throw - 1;\n\n\t\t\t\t\tGram gram;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = res;\n\t\t\t\t\tgrams.insert(right, gram);\n\t\t\t\t\tright = grams.begin();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperator_erase(grams, '*');\n\t\t\toperator_erase(grams, '+', '-');\n\t\t\tif (grams.size() != 1) {\n\t\t\t\t//cerr << \"size is too much\" << endl;\n\t\t\t\tthrow - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn grams.front().num;\n\t\t\t}\n\t\t}\n\t\tcatch (...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbool isnumber(const list<char>& ls){\n\t\tfor (char c : ls) {\n\t\t\tif (c < '0' || '9' < c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isoperator(const char& c) {\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tlist<char> n2b(int num) {\n\t\tlist<char> b;\n\t\twhile (num > 0) {\n\t\t\tint tmp = num % 2;\n\t\t\tnum /= 2;\n\t\t\tb.push_front(tmp + '0');\n\t\t}\n\t\treturn b;\n\t}\n\n\tint b2n(const list<char>& ls) {\n\t\tint res = 0;\n\t\tfor (char c: ls) {\n\t\t\tres *= 2;\n\t\t\tres += c - '0';\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid operator_erase(\n\t\tlist<Gram>& grams,\n\t\tconst char& ope1,\n\t\tconst char& ope2 = 'i'\n\t){\n\t\tfor (auto center = grams.begin(); center != grams.end(); ++center) {\n\t\t\tif (center->data == ope1 || center->data == ope2) {\n\t\t\t\tauto left = center; if (distance(grams.begin(), left) == 0)break; left--;\n\t\t\t\tauto right = center; if (distance(right, grams.end()) == 1)break; right++;\n\n\t\t\t\tswitch (center->data) {\n\t\t\t\tcase '+':left->num += right->num; break;\n\t\t\t\tcase '-':left->num -= right->num; break;\n\t\t\t\tcase '*':left->num *= right->num; break;\n\t\t\t\t}\n\n\t\t\t\tif (left->num < 0 || 1024 <= left->num)throw - 1;\n\t\t\t\tgrams.erase(center);\n\t\t\t\tgrams.erase(right);\n\t\t\t\tcenter = left;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tStage stage;\n\tstage.action();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint ans=-1;\n\nint ex(string::iterator &it,int r){\n    if(r==0){\n        int res=ex(it,r+1);\n        if(res==-1)return -1;\n        while(true){\n            if(*it=='*'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res*=x;\n            }\n            else break;\n            if(res<0||res>=1024)return -1;\n        }\n        return res;\n    }\n    if(r==1){\n        int res=ex(it,r+1);\n        if(res==-1)return -1;\n        while(true){\n            if(*it=='+'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res+=x;\n            }\n            else if(*it=='-'){\n                it++;\n                int x=ex(it,r+1);\n                if(x==-1)return -1;\n                res-=x;\n            }\n            else break;\n            if(res<0||res>=1024)return -1;\n        }\n        return res;\n    }\n    if(r==2){\n        if(*it=='('){\n            it++;\n            int res=ex(it,0);\n            it++;\n            return res;\n        }\n        return ex(it,r+1);\n    }\n    if(r==3){\n        if(!isdigit(*it))return -1;\n        int res=0;\n        while(isdigit(*it)){\n            res=res*2+*it-'0';\n            it++;\n            if(res>=1024)return -1;\n        }\n        return res;\n    }\n}\n\nvoid solve(string s){\n    stack<int>st;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='('){\n            st.push(i);\n        }\n        else if(s[i]==')'){\n            if(st.size()==0)return;\n            int t=st.top();\n            st.pop();\n            if(s[t+1]=='('&&s[i-1]==')')return;\n            bool ok=false;\n            for(int j=t+1;j<i;j++)if(s[j]=='+'||s[j]=='-'||s[j]=='*')ok=true;\n            if(!ok)return;\n        }\n    }\n    if(st.size())return;\n    s+=\"=\";\n    auto it=s.begin();\n    int tmp=ex(it,0);\n    if(*it!='=')return;\n    chmax(ans,tmp);\n}\n\nvoid dfs(int n,string &S){\n    if(n==S.size()){\n        solve(S);\n        return;\n    }\n    if(S[n]=='.'){\n        rep(i,7){\n            S[n]=\"01+-*()\"[i];\n            dfs(n+1,S);\n        }\n        S[n]='.';\n    }\n    else{\n        dfs(n+1,S);\n    }\n}\n\nsigned main(){\n    string S;\n    cin>>S;\n    dfs(0,S);\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s, tmp, let = \"01+-*()\";\nvi v;\nint n, p, ans;\n\nbool range(int t)\n{\n\treturn t >= 0 && t < (1 << 10);\n}\n\nint num()\n{\n\tint res = 0;\n\twhile (p < n && isdigit(tmp[p]))\n\t{\n\t\tres *= 2;\n\t\tres += tmp[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\npair<int, bool> plu();\n\nint unit()\n{\n\tint res;\n\tif (tmp[p] == '(')\n\t{\n\t\tp++;\n\t\tauto a = plu();\n\t\tif (a.second == false || tmp[p] != ')') return -1;\n\t\tres = a.first;\n\t\tp++;\n\t}\n\telse \n\t{ \n\t\tif (!isdigit(tmp[p])) return -1;\n\t\tres = num();\n\t}\n\tif (!range(res)) return -1;\n\telse return res;\n}\n\npair<int, bool> mul()\n{\n\tbool f = false;\n\tint res = unit();\n\twhile (tmp[p] == '*')\n\t{\n\t\tf = true;\n\t\tp++;\n\t\tint rhs = unit();\n\t\tif (rhs == -1) return make_pair(-1, f);\n\t\tres *= rhs;\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\npair<int, bool> plu()\n{\n\tauto a = mul();\n\tint res = a.first;\n\tbool f = a.second;\n\tif (res == -1) return make_pair(-1, f);\n\twhile (tmp[p] == '+' || tmp[p] == '-')\n\t{\n\t\tf = true;\n\t\tif (tmp[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres += rhs;\n\t\t}\n\t\telse if (tmp[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres -= rhs;\n\t\t}\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\nint parse()\n{\n\tp = 0;\n\tint res = plu().first;\n\tif (p != tmp.size()) return -1;\n\telse return res;\n}\n\nbool check1()\n{\n\tbool res = true;\n\tREP(i, tmp.size()) if (!isdigit(tmp[i])) res = false;\n\treturn res;\n}\n\nbool check2()\n{\n\tbool res;\n\tstring elem; //0 = number, 1 = operator, 2 = '('\n\tREP(i, tmp.size())\n\t{\n\t\tif (isdigit(tmp[i]))\n\t\t{\n\t\t\twhile (isdigit(tmp[i])) i++;\n\t\t\ti--;\n\t\t\telem.push_back('0');\n\t\t}\n\t\telse if (tmp[i] == '+' || tmp[i] == '-' || tmp[i] == '*')\n\t\t{\n\t\t\telem.push_back('1');\n\t\t}\n\t\telse if (tmp[i] == '(') elem.push_back('(');\n\t\telse if (tmp[i] == ')') elem.push_back(')');\n\t\telse assert(false);\n\t}\n\tREP(i, elem.size() - 2)\n\t{\n\t\tif (elem[i] == '('&&elem[i + 1] == '0'&&elem[i + 2] == ')') return false;\n\t}\n\tREP(i, elem.size() - 1)\n\t{\n\t\tif (elem[i] == '('&&elem[i + 1] == ')') return false;\n\t}\n\treturn true;\n}\n\n\n\nvoid solve(int i, vi w)\n{\n\tif (i == v.size())\n\t{\n\t\ttmp = s;\n\t\tREP(i, v.size())\n\t\t{\n\t\t\ttmp[v[i]] = let[w[i]];\n\t\t}\n\t\tp = 0;\n\t\tif (check1())\n\t\t{\n\t\t\tint res = num();\n\t\t\tchmax(ans, res);\n\t\t}\n\t\telse if (check2())\n\t\t{\n\t\t\tint res = parse();\n\t\t\tchmax(ans, res);\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, 7)\n\t\t{\n\t\t\tvi tmp = w;\n\t\t\ttmp.push_back(j);\n\t\t\tsolve(i + 1, tmp);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tans = -1;\n\tcin >> s;\n\tn = s.size();\n\tREP(i, n)\n\t{\n\t\tif (s[i] == '.') v.push_back(i);\n\t}\n\tvi emp;\n\tsolve(0, emp);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nbool valid(int n) {return 0 <= n && n < 1024;}\nbool valid(string str) {\n  int t = 0;\n  rep (i, str.size()) {\n    if (str[i] == '(') ++t;\n    if (str[i] == ')') {\n      --t;\n      if (t < 0) return false;\n    }\n  }\n  return t == 0;\n}\n\nint num(string str) {\n  int n = 0;\n  rep (i, str.size()) {\n    n = n * 2 + str[i] - '0';\n    if (n >= 1024) throw 1;\n  }\n  return n;\n}\n\nint exp(string str) {\n  int n = str.size();\n  if (str[0] == '(') {\n    int t = 0;\n    rep (i, n - 2) {\n      if (str[i] == '(') ++t;\n      if (str[i] == ')') {\n\t--t;\n\tif (t == 0) {\n\t  if (str[i + 1] == '+') {\n\t    int r = exp(str.substr(0, i + 1)) + exp(str.substr(i + 2));\n\t    if (!valid(r)) throw 1;\n\t    return r;\n\t  }\n\t  if (str[i + 1] == '-') {\n\t    int r = exp(str.substr(0, i + 1)) - exp(str.substr(i + 2));\n\t    if (!valid(r)) throw 1;\n\t    return r;\n\t  }\n\t  if (str[i + 1] == '*') {\n\t    int r = exp(str.substr(0, i + 1)) * exp(str.substr(i + 2));\n\t    if (!valid(r)) throw 1;\n\t    return r;\n\t  }\n\t  throw 1;\n\t}\n      }\n    }\n    if (str[str.size() - 1] != ')') throw 1;\n    if (str[1] == '(' && str[str.size() - 1] == ')') if (valid(str.substr(2, str.size() - 4))) throw 1;\n    rep (i, n - 1) if (i != 0 && !isdigit(str[i])) return exp(str.substr(1, str.size() - 2));\n    throw 1;\n  }\n  int d = str.size();\n  rep (i, str.size()) if (!isdigit(str[i])) {\n    d = i;\n    break;\n  }\n  if (d == n) return num(str);\n  if (d == 0 || d == n - 1) throw 1;\n  if (str[d] == '+') {\n    int r = exp(str.substr(0, d)) + exp(str.substr(d + 1));\n    if (!valid(r)) throw 1;\n    return r;\n  }\n  if (str[d] == '-') {\n    int r = exp(str.substr(0, d)) - exp(str.substr(d + 1));\n    if (!valid(r)) throw 1;\n    return r;\n  }\n  if (str[d] == '*') {\n    int r = exp(str.substr(0, d)) * exp(str.substr(d + 1));\n    if (!valid(r)) throw 1;\n    return r;\n  }\n  throw 1;\n}\n\nconst char c[] = {'0', '1', '+', '-', '*', '(', ')'};\nint solve0(string str, vector<int> dot) {\n  if (dot.size() == 0u) {\n    try {\n      return exp(str);\n    } catch(int n) {\n      return -1;\n    }\n  }\n  int n = dot.back();\n  dot.pop_back();\n  int res = -1;\n  rep (i, 7) {\n    str[n] = c[i];\n    res = max(res, solve0(str, dot));\n  }\n  return res;\n}\n\nint main() {\n  string str;\n  cin >> str;\n  vector<int> dot;\n  rep (i, str.size()) if (str[i] == '.') dot.push_back(i);\n  cout << solve0(str, dot) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nclass ex{\n};\n\nvoid ass(bool cond){\n\tif(!cond){\n\t\tthrow ex();\n\t}\n}\nvoid inrange(int n){\n\tass(0<=n&&n<(1<<10));\n}\n\nint number(string &s,int &p){\n\tass(isdigit(s[p]));\n\tint ret=s[p]-'0';\n\tp++;\n\twhile(isdigit(s[p])){\n\t\tret<<=1;\n\t\tret+=s[p]-'0';\n\t\tp++;\n\t}\n\tinrange(ret);\n\treturn ret;\n}\nint expression(string &s, int &p);\nint term(string &s,int &p);\n\n//factor ::= number | (factor [+-] expression) | (factor * term)\nint factor(string &s,int &p){\n\tif(s[p]=='('){\n\t\tp++;\n\t\tint ret=factor(s,p);\n\t\tchar op=s[p];\n\t\tp++;\n\t\tif(op=='+'){\n\t\t\tret+=expression(s,p);\n\t\t}else if(op=='-'){\n\t\t\tret-=expression(s,p);\n\t\t}else if(op=='*'){\n\t\t\tret*=term(s,p);\n\t\t}else{\n\t\t\tass(0);\n\t\t}\n\t\tinrange(ret);\n\t\tass(s[p]==')');\n\t\tp++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(s,p);\n\t}\n}\n\n//term ::= factor | factor * factor\nint term(string &s,int &p){\n\tint ret=factor(s,p);\n\twhile(s[p]=='*'){\n\t\tp++;\n\t\tret*=factor(s,p);\n\t\tinrange(ret);\n\t}\n\treturn ret;\n}\n\n//expression ::= term | term [+-] expression\nint expression(string &s, int &p){\n\tint ret=term(s,p);\n\tchar op=s[p];\n\twhile(op=='+'||op=='-'){\n\t\tp++;\n\t\tint t=term(s,p);\n\t\tif(op=='+'){\n\t\t\tret+=t;\n\t\t}else if(op=='-'){\n\t\t\tret-=t;\n\t\t}else{\n\t\t\tass(0);\n\t\t}\n\t\tinrange(ret);\n\t\top=s[p];\n\t}\n\treturn ret;\n}\n\nchar chars[]={'0','1','+','-','*','(',')'};\n\nint main(){\n\tstring s;\n\tcin>>s;\n\tvi rpl(5);\n\tint ans=-1;\n\tfor(rpl[0]=0;rpl[0]<7;rpl[0]++)\n\tfor(rpl[1]=0;rpl[1]<7;rpl[1]++)\n\tfor(rpl[2]=0;rpl[2]<7;rpl[2]++)\n\tfor(rpl[3]=0;rpl[3]<7;rpl[3]++)\n\tfor(rpl[4]=0;rpl[4]<7;rpl[4]++){\n\t\tstring ns(s);\n\t\tint pos=0;\n\t\tREP(i,5){\n\t\t\tpos=ns.find('.',pos);\n\t\t\tif(pos!=ns.npos){\n\t\t\t\tns[pos]=chars[rpl[i]];\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttry{\n\t\t\tint p=0;\n\t\t\tint val=expression(ns,p);\n\t\t\tass(p==ns.size());\n\t\t\tans=max(ans,val);\n\t\t}catch(ex){\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110];\nint b[11];\nint sz;\nint expr(int a);\nint cur;\nchar s[10]=\"01+-*().\";\nint u[110];\nint term(){\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tint ret=expr(cur);\n\t\tif(str[cur]!=')')return -1;\n\t\t\n\t\tcur++;\n\t\treturn ret;\n\t}else if('0'<=str[cur]&&str[cur]<='1'){\n\t\tint ret=0;\n\t\twhile(str[cur]=='0'||str[cur]=='1'){\n\t\t\tret*=2;\n\t\t\tret+=str[cur]-'0';\n\t\t\tcur++;\n\t\t\tif(ret>=1024)return -1;\n\t\t}\n\t\treturn ret;\n\t}else return -1;\n}\nint fact(int a){\n\tint ret=term();\n\tif(ret==-1)return -1;\n\twhile(1){\n\t\tif(str[cur]=='0')return -1;\n\t\tif(str[cur]=='1')return -1;\n\t\tif(str[cur]=='(')return -1;\n\t\tif(str[cur]!='*')break;\n\t\tcur++;\n\t\tu[a]++;\n\t\tint tmp=term();\n\t\tif(tmp==-1)return -1;\n\t\tret*=tmp;\n\t\tif(ret<0||ret>=1024)return -1;\n\t}\n\treturn ret;\n}\nint expr(int a){\n\tint ret=fact(a);\n\tif(ret==-1)return -1;\n\twhile(1){\n\t\tif(str[cur]=='0')return -1;\n\t\tif(str[cur]=='1')return -1;\n\t\tif(str[cur]=='(')return -1;\n\t\tif(str[cur]!='+'&&str[cur]!='-')break;\n\t\tchar ch=str[cur];\n\t\tu[a]++;\n\t\tcur++;\n\t\tint tmp=fact(a);\n\t\tif(tmp==-1)return -1;\n\t\tif(ch=='+')ret+=tmp;\n\t\telse ret-=tmp;\n\t\tif(ret<0||ret>=1024)return -1;\n\t}\n\treturn ret;\n}\nint solve(int a){\n\tif(a==sz){\n\t\tcur=0;\n\t\tint left=0;\n\t\tfor(int i=0;str[i];i++)u[i]=0;\n\t\tint ret=expr(0);\n\t\tfor(int i=0;str[i];i++)if(str[i]=='('&&u[i+1]==0)return -1;\n\t\tif(str[cur])return -1;\n\t\treturn ret;\n\t}\n\tint ret=-1;\n\tfor(int i=0;i<7;i++){\n\t\tstr[b[a]]=s[i];\n\t\tret=max(ret,solve(a+1));\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\",str);\n\tfor(int i=0;str[i];i++){\n\t\tif(str[i]=='.')b[sz++]=i;\n\t}\n\tprintf(\"%d\\n\",solve(0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>//\"geometry.cpp\"\n#include<iomanip>//\"cout<<fixed<<setprecision(n)<<sth<<endl;\"\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>//\"greater<T>\" Ex. sort(a,a+n,greater<int>());\n#include<cmath>//\"abs\", \"sqrt\"\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//tentative\ntypedef map<char,int> mci;\n\nconst int PLUS=1024,MINUS=1025,TIMES=1026,LEFT=1027,RIGHT=1028,ERROR=1029;\n\nint calc(vector<int> v){\n\tif(v.size()==1){\n\t\tif(v[0]>=PLUS){\n\t\t\treturn ERROR;\n\t\t}\n\t\treturn v[0];\n\t}\n\tif(v.size()%2==0){\n\t\treturn ERROR;\n\t}\n\tint i;\n\tfor(i=0;i<v.size();++i){\n\t\tif(v[i]==TIMES){\n\t\t\tif(i%2==0){\n\t\t\t\treturn ERROR;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(i<v.size()){\n\t\tif(v[i-1]>=PLUS||v[i+1]>=PLUS){\n\t\t\treturn ERROR;\n\t\t}\n\t\tv[i-1]*=v[i+1];\n\t\tif(v[i-1]>=PLUS){\n\t\t\treturn ERROR;\n\t\t}\n\t\tfor(;i<v.size()-2;++i){\n\t\t\tv[i]=v[i+2];\n\t\t}\n\t\tv.resize(v.size()-2);\n\t\treturn calc(v);\n\t}\n\tif(v[0]>=PLUS){\n\t\treturn ERROR;\n\t}\n\tfor(i=1;i<v.size();i+=2){\n\t\tif(v[i]<PLUS||v[i]>=TIMES||v[i+1]>=PLUS){\n\t\t\treturn ERROR;\n\t\t}\n\t\tif(v[i]==PLUS){\n\t\t\tv[0]+=v[i+1];\n\t\t\tif(v[0]>=PLUS){\n\t\t\t\treturn ERROR;\n\t\t\t}\n\t\t}else{\n\t\t\tv[0]-=v[i+1];\n\t\t\tif(v[0]<0){\n\t\t\t\treturn ERROR;\n\t\t\t}\n\t\t}\n\t}\n\treturn v[0];\n}\n\nint main(){\n\tstring s;\n\tvector<int> x;\n\tint k=1,ans=-1;\n\tchar c[7];\n\tc[0]='0';\n\tc[1]='1';\n\tc[2]='+';\n\tc[3]='-';\n\tc[4]='*';\n\tc[5]='(';\n\tc[6]=')';\n\tmci m;\n\tm.is(mp('+',PLUS));\n\tm.is(mp('-',MINUS));\n\tm.is(mp('*',TIMES));\n\tm.is(mp('(',LEFT));\n\tm.is(mp(')',RIGHT));\n\tcin>>s;\n\tfor(int i=0;i<s.size();++i){\n\t\tif(s[i]=='.'){\n\t\t\tx.pb(i);\n\t\t\tk*=7;\n\t\t}\n\t}\n\tfor(--k;k>=0;--k){\n\t\tint j=k;\n\t\tfor(int i=0;i<x.size();++i){\n\t\t\ts[x[i]]=c[j%7];\n\t\t\tj/=7;\n\t\t}\n\t\tint a=0;\n\t\tvector<int> v,l;\n\t\tfor(int i=0;i<s.size();++i){\n\t\t\tif(s[i]=='0'||s[i]=='1'){\n\t\t\t\ta*=2;\n\t\t\t\ta+=(s[i]-'0');\n\t\t\t\tif(i==s.size()-1){\n\t\t\t\t\tv.pb(a);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(i-1>=0&&(s[i-1]=='0'||s[i-1]=='1')){\n\t\t\t\t\tv.pb(a);\n\t\t\t\t}\n\t\t\t\ta=0;\n\t\t\t\tv.pb(m[s[i]]);\n\t\t\t\tif(m[s[i]]==LEFT){\n\t\t\t\t\tl.pb(v.size()-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!l.empty()){\n\t\t\tfor(j=l[l.size()-1]+1;j<v.size();++j){\n\t\t\t\tif(v[j]==RIGHT){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j==v.size()){\n\t\t\t\ta=ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<int> w(v.begin()+l[l.size()-1]+1,v.begin()+j);\n\t\t\tif(w.size()==1){\n\t\t\t\ta=ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[l[l.size()-1]]=calc(w);\n\t\t\tif(v[l[l.size()-1]]==ERROR){\n\t\t\t\ta=ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=l[l.size()-1]+1;i<v.size()-w.size()-1;++i){\n\t\t\t\tv[i]=v[i+w.size()+1];\n\t\t\t}\n\t\t\tv.resize(v.size()-w.size()-1);\n\t\t\tl.pop_back();\n\t\t}\n\t\tif(a!=ERROR){\n\t\t\ta=calc(v);\n\t\t\tif(a!=ERROR){\n\t\t\t\tans=max(ans,a);\n\t\t\t}else{\n\t\t\t}\n\t\t}else{\n\t\t}\n\t}\n\tif(ans>=0){\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\ntypedef string::iterator Iterator;\nconst int LIMIT = 1<<10;\n\nint number(Iterator &it) {\n    int val = 0;\n    if(!isdigit(*it)) throw \"not a number\";\n    while(isdigit(*it)) {\n        val <<= 1;\n        val += *it - '0';\n        if(val >= LIMIT) throw \"limit over\";\n        ++it;\n    }\n    return val;\n}\n\nint expression(Iterator &it, bool &operated);\nint term(Iterator &it, bool &operated) {\n    int lhs;\n    if(*it == '(') {\n        lhs = expression(it, operated);\n    } else {\n        lhs = number(it);\n    }\n    while(*it == '*') {\n        ++it;\n        int rhs;\n        if(*it == '(') {\n            rhs = expression(it, operated);\n        } else {\n            rhs = number(it);\n        }\n        lhs *= rhs;\n        if(lhs >= LIMIT) throw \"limit over\";\n        operated = true;\n    }\n    return lhs;\n}\n\nint factor(Iterator &it, bool &operated) {\n    int lhs = term(it, operated);\n    while(*it == '+' || *it == '-') {\n        char op = *it;\n        ++it;\n        int rhs = term(it, operated);\n        if(op == '+') {\n            lhs += rhs;\n            if(lhs >= LIMIT) throw \"limit over\";\n            operated = true;\n        } else if(op == '-') {\n            lhs -= rhs;\n            if(lhs < 0) throw \"limit under\";\n            operated = true;\n        } else {\n            throw \"syntax error\";\n        }\n    }\n    return lhs;\n}\n\nint expression(Iterator &it, bool &operated) {\n    if(*it == '(') {\n        ++it;\n        bool operated = false;\n        int val = expression(it, operated);\n        if(val < 0 || val >= LIMIT) throw \"limit over\";\n        if(!operated) throw \"paren without operator\";\n        if(*it != ')') throw \"unmatched paren\";\n        ++it;\n        return val;\n    } else if(isdigit(*it)) {\n        return factor(it, operated);\n    } else {\n        throw \"syntax error\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    string str;\n    cin >> str;\n    vector<int> dotpos;\n    for(int i = 0; i < str.size(); ++i) {\n        if(str[i] == '.') dotpos.push_back(i);\n    }\n    int allpat = 1;\n    for(int i = 0; i < dotpos.size(); ++i) {\n        allpat *= 7;\n    }\n    int ans = -1;\n    for(int pat = 0; pat < allpat; ++pat) {\n        int tmp = pat;\n        string expr(str);\n        for(int i = 0; i < dotpos.size(); ++i) {\n            int n = tmp % 7;\n            tmp /= 7;\n            expr[dotpos[i]] = \"01+-*()\"[n];\n        }\n        try {\n            bool dmy;\n            Iterator it = expr.begin();\n            int val = expression(it, dmy);\n            if(val < 0 || val >= LIMIT) throw \"limit over\";\n            if(it != expr.end()) throw \"premature end\";\n            ans = max(ans, val);\n        } catch (const char *msg) {\n            //cout << expr << ' ' << msg << endl;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nint formula(int, int);\nstring s;\nvector<int> idx;\n\nint binary_to_int(const string& binary) {\n\tint res = 0, x = 1, n = binary.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(binary[n - 1 - i] == '1')\n\t\t\tres += x;\n\n\t\telse if(binary[n - 1 - i] != '0')\n\t\t\treturn -1;\n\n\t\tx <<= 1;\n\t}\n\n\treturn res >= 1024 ? -1 : res;\n}\n\nint factor(int l, int r) {\n\tif(l == r)\n\t\treturn -1;\n\n\tif(s[l] == '(' && s[r - 1] == ')') {\n\t\tfor(int i = l + 1; i < r - 1; ++i)\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\treturn formula(l + 1, r - 1);\n\n\t\treturn -1;\n\t}\n\n\treturn binary_to_int(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == ')')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == '(')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && s[i] == '*') {\n\t\t\tint vl = term(l, i), vr = factor(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0)\n\t\t\t\treturn -1;\n\n\t\t\treturn vl * vr >= 1024 ? -1 : vl * vr;\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == ')')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == '(')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\tint vl = formula(l, i), vr = term(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn vl + vr >= 1024 ? -1 : vl + vr;\n\n\t\t\telse\n\t\t\t\treturn vl - vr;\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nint dfs(int d = 0) {\n\tif(d == idx.size())\n\t\treturn formula(0, s.size());\n\n\tint res = -1;\n\tstatic const char c[7] = {'0', '1', '*', '+', '-', '(', ')'};\n\tfor(int i = 0; i < 7; ++i) {\n\t\ts[idx[d]] = c[i];\n\t\tchmax(res, dfs(d + 1));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tidx.push_back(i);\n\n\tcout << dfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nstring st;\nint a = 0;\nvoid check(const int num) {\n\tif (num < 0 || num >= 1024)throw(false);\n}\nint getnum() {\n\tint num = 0;\n\twhile (isdigit(st[a])) {\n\t\tnum = num * 2 + st[a] - '0';\n\t\ta++;\n\t}\n\tcheck(num);\n\treturn num;\n}\nint getexpr(const int isstart);\nint getkakko();\nint getka() {\n\tif (st[a] == '(') {\n\t\tint num=getkakko();\n\t\treturn num;\n\t}\n\telse if(isdigit(st[a])){\n\t\treturn getnum();\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\npair<int,int> getso() {\n\tint num = getka();\n\tbool fst = false;\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')'||st[a]=='+'||st[a]=='-') {\n\t\t\treturn make_pair(fst,num);\n\t\t}\n\t\telse if (st[a] == '*') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getka();\n\t\t\tnum *= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\npair<int, int> getexpr() {\n\tauto p(getso());\n\tbool fst = p.first;\n\tint num = p.second;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\treturn make_pair(fst,num);\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\nint getkakko() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n\tauto p(getso());\n\tint num = p.second;\n\n\tint fst = p.first;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\tthrow(false);\n\t\t}else if( st[a] == ')') {\n\t\t\tif (!fst) throw(false);\n\t\t\telse break;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t\tfst = false;\n\t}\n\tif (st[a] == ')') {\n\t\ta++;\n\t\treturn num;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\nint main() {\n\tstring base; cin >> base;\n\tst = base;\n\tstring aa = \"01+-*()\";\n\tvector<int>unknowns;\n\tfor (int i = 0; i < base.size(); ++i) {\n\t\tif (base[i] == '.') {\n\t\t\tunknowns.emplace_back(i);\n\t\t}\n\t}\n\tint ans = -1;\n\tfor (int i = 0; i < powint(7, unknowns.size()); ++i) {\n\t\tint num(i);\n\t\ta = 0;\n\t\tfor (int j = 0; j < unknowns.size(); ++j) {\n\t\t\tst[unknowns[j]] = aa[num % 7];\n\t\t\tnum /= 7;\n\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tint num = getexpr().second;\n\t\t\tans=max(ans,num);\n\t\t}\n\t\tcatch (...) {\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tconst int kind = 7;\n\tStage(){\n\t}\n\t\n\tvoid action(){\n\t\tstring text;\n\t\tcin >> text;\n\n\t\tint res = -1;\n\t\tREP(transWay, pow(kind, count_dot(text))) {\n\t\t\tstring transedText = trans(transWay, text);\n\t\t\tlist<char> ls;\n\t\t\tfor (char c : transedText)ls.push_back(c);\n\t\t\tauto grams = trans_gram(ls);\n\t\t\tint score = read(grams);\n\n\t\t\tres = max(res, score);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tchar data;\n\t\tint num;\n\t};\n\t\n\tint count_dot(const string& text) {\n\t\tint res = 0;\n\t\tfor (char c : text)if (c == '.')res++;\n\t\treturn res;\n\t}\n\tstring trans(int n, string text) {\n\t\tfor (char& c : text)if (c == '.') {\n\t\t\tswitch (n % kind) {\n\t\t\tcase 0:c = '0'; break;\n\t\t\tcase 1:c = '1'; break;\n\t\t\tcase 2:c = '+'; break;\n\t\t\tcase 3:c = '-'; break;\n\t\t\tcase 4:c = '*'; break;\n\t\t\tcase 5:c = '('; break;\n\t\t\tcase 6:c = ')'; break;\n\t\t\t}\n\t\t\tn /= kind;\n\t\t}\n\t\treturn text;\n\t}\n\n\tlist<Gram> trans_gram(const list<char>& ls) {\n\t\tlist<Gram> grams;\n\t\tfor (auto itr = ls.begin(); itr != ls.end(); ++itr) {\n\t\t\tGram gram;\n\t\t\tswitch (*itr) {\n\t\t\tcase '+':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '+';\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '-';\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '*';\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = ')';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgram.kind = 'n';\n\t\t\t\tgram.data = '.';\n\t\t\t\tgram.num = 0;\n\t\t\t\tdo {\n\t\t\t\t\tgram.num *= 2;\n\t\t\t\t\tgram.num += *itr - '0';\n\t\t\t\t\t++itr;\n\t\t\t\t} while (itr != ls.end() && isdigit(*itr));\n\t\t\t\t--itr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tint read(list<Gram> grams){\n\t\ttry {\n\t\t\t// ( , ) delete\n\t\t\tfor (auto right = grams.begin(); right != grams.end(); ++right)\n\t\t\t{\n\t\t\t\tif (right->data == ')') {\n\t\t\t\t\tlist<Gram> subset;\n\t\t\t\t\tauto left = right;\n\n\t\t\t\t\t//move: (expression)\n\t\t\t\t\twhile (left != grams.begin() && left->data != '(') --left;\n\t\t\t\t\tif (left->data != '(')throw - 1;\n\t\t\t\t\t++right;\n\t\t\t\t\tsubset.splice(subset.begin(), move(grams), left, right);\n\n\t\t\t\t\t// delete: ( , )\n\t\t\t\t\tsubset.pop_front();\n\t\t\t\t\tsubset.pop_back(); \n\t\t\t\t\tif (subset.size() == 1)throw - 1;\n\n\t\t\t\t\tint res = read(subset);\n\t\t\t\t\tif (res < 0)throw - 1;\n\n\t\t\t\t\tGram gram;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = res;\n\t\t\t\t\tgrams.insert(right, gram);\n\t\t\t\t\tright = grams.begin();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperator_erase(grams, '*');\n\t\t\toperator_erase(grams, '+', '-');\n\t\t\tif (grams.size() != 1) {\n\t\t\t\t//cerr << \"size is too much\" << endl;\n\t\t\t\tthrow - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn grams.front().num;\n\t\t\t}\n\t\t}\n\t\tcatch (...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbool isnumber(const list<char>& ls){\n\t\tfor (char c : ls) {\n\t\t\tif (c < '0' || '9' < c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isoperator(const char& c) {\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tlist<char> n2b(int num) {\n\t\tlist<char> b;\n\t\twhile (num > 0) {\n\t\t\tint tmp = num % 2;\n\t\t\tnum /= 2;\n\t\t\tb.push_front(tmp + '0');\n\t\t}\n\t\treturn b;\n\t}\n\n\tint b2n(const list<char>& ls) {\n\t\tint res = 0;\n\t\tfor (char c: ls) {\n\t\t\tres *= 2;\n\t\t\tres += c - '0';\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid operator_erase(\n\t\tlist<Gram>& grams,\n\t\tconst char& ope1,\n\t\tconst char& ope2 = '.'\n\t){\n\t\tfor (auto center = grams.begin(); center != grams.end(); ++center) {\n\t\t\tif (center->data == ope1 || center->data == ope2) {\n\t\t\t\tauto left = center; if (distance(grams.begin(), left) == 0)break; left--;\n\t\t\t\tauto right = center; if (distance(right, grams.end()) == 1)break; right++;\n\n\t\t\t\tswitch (center->data) {\n\t\t\t\tcase '+':left->num += right->num; break;\n\t\t\t\tcase '-':left->num -= right->num; break;\n\t\t\t\tcase '*':left->num *= right->num; break;\n\t\t\t\t}\n\n\t\t\t\tif (left->num < 0 || 1024 <= left->num)throw - 1;\n\t\t\t\tgrams.erase(center);\n\t\t\t\tgrams.erase(right);\n\t\t\t\tcenter = left;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tStage stage;\n\tstage.action();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nint formula(int, int);\nstring s;\nvector<int> idx;\n\nint binary_to_int(const string& binary) {\n\tint res = 0, x = 1, n = binary.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(binary[n - 1 - i] == '1')\n\t\t\tres += x;\n\n\t\telse if(binary[n - 1 - i] != '0')\n\t\t\treturn -1;\n\n\t\tx <<= 1;\n\t}\n\n\treturn res;\n}\n\nint factor(int l, int r) {\n\tif(s[l] == '(' && s[r - 1] == ')') {\n\t\tfor(int i = l + 1; i < r - 1; ++i)\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\treturn formula(l + 1, r - 1);\n\t}\n\n\treturn binary_to_int(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == ')')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && s[i] == '*') {\n\t\t\tint vl = factor(l, i), vr = factor(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0)\n\t\t\t\treturn -1;\n\n\t\t\treturn vl * vr;\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == ')')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\tint vl = term(l, i), vr = term(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn vl + vr;\n\n\t\t\telse\n\t\t\t\treturn vl - vr;\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nint dfs(int d = 0) {\n\tif(d == idx.size())\n\t\treturn formula(0, s.size());\n\n\tint res = -1;\n\tstatic const char c[7] = {'0', '1', '*', '+', '-', '(', ')'};\n\tfor(int i = 0; i < 7; ++i) {\n\t\ts[idx[d]] = c[i];\n\t\tchmax(res, dfs(d + 1));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tidx.push_back(i);\n\n\tcout << dfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n#define int long long \n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res -= term(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }\n    }\n    if(res<0||res>=1024){\n        ppppp = 1;\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n            if(res<0||res>=1024){\n                ppppp = 1;\n            }\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(a>b)return 0;\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n            \n        }\n    }\n    if(flag||tmp2==-1){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n        return false;\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            \n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nsigned main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n            pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                cout << -1<< endl;\n            }else{\n                cout << xxx << endl;\n            }\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nchar s[110];\nint n;\nint dd[5];\nchar u[] = \"01+-*()\";\nbool err;\nint ec;\n\nint expr(char **begin);\n\nvoid erce(int i) {\n    err |= (i  < 0 || 1024 <= i);\n}\n\nint numb(char **begin) {\n    int r = 0;\n    if (!isdigit(**begin)) err = true;\n    while (isdigit(**begin)) {\n        r *= 2;\n        r += **begin - '0';\n        *begin += 1;\n    }\n    erce(r);\n    return r;\n}\n\nint fact(char **begin) {\n    if (**begin == '(') {\n        *begin += 1;\n        int ec2 = ec;\n        int r = expr(begin);\n        if (ec2 == ec) err = true;\n        ec = ec2;\n        if (**begin != ')') err = true;\n        *begin += 1;\n        erce(r);\n        return r;\n    } else {\n        return numb(begin);\n    }\n}\n\nint term(char **begin) {\n    int r = fact(begin);\n    while (true) {\n        if (**begin == '*') {\n            ec++;\n            *begin += 1;\n            r *= fact(begin);\n            erce(r);\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\nint expr(char **begin) {\n    int r = term(begin);\n    while (true) {\n        if (**begin == '+') {\n            ec++;\n            *begin += 1;\n            r += term(begin);\n            erce(r);\n        } else if (**begin == '-') {\n            ec++;\n            *begin += 1;\n            r -= term(begin);\n            erce(r);\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\n\nint main() {\n    string ss;\n    cin >> ss;\n    n = ss.size();\n    int cc = 1;\n    int c = 0;\n    for (int i = 0; i < n; i++) {\n        s[i] = ss[i];\n        if (s[i] == '.') {\n            dd[c] = i;\n            c++;\n            cc *= 7;\n        }\n    }\n    s[n] = '$';\n    int res = -1;\n    for (int i = 0; i < cc; i++) {\n        int ii = i;\n        for (int j = 0; j < c; j++) {\n            s[dd[j]] = u[ii%7];\n            ii /= 7;\n        }\n        err = false;\n        ec = 0;\n        char *p = s;\n        int r = expr(&p);\n        if (*p != '$') err = true; \n        if (!err) res = max(res, r);\n        //printf(\"%10s %d %d\\n\", s, r, err);\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s, tmp, let = \"01+-*()\";\nvi v;\nint n, p, ans;\n\nbool range(int t)\n{\n\treturn t >= 0 && t < (1 << 10);\n}\n\nint num()\n{\n\tint res = 0;\n\twhile (p < n && isdigit(tmp[p]))\n\t{\n\t\tres *= 2;\n\t\tres += tmp[p] - '0';\n\t\tp++;\n\t}\n\tif (!range(res)) return -1;\n\treturn res;\n}\n\npair<int, bool> plu();\n\nint unit()\n{\n\tint res;\n\tif (tmp[p] == '(')\n\t{\n\t\tp++;\n\t\tauto a = plu();\n\t\tif (a.second == false || tmp[p] != ')') return -1;\n\t\tres = a.first;\n\t\tp++;\n\t}\n\telse \n\t{ \n\t\tif (!isdigit(tmp[p])) return -1;\n\t\tres = num();\n\t}\n\tif (!range(res)) return -1;\n\telse return res;\n}\n\npair<int, bool> mul()\n{\n\tbool f = false;\n\tint res = unit();\n\twhile (tmp[p] == '*')\n\t{\n\t\tf = true;\n\t\tp++;\n\t\tint rhs = unit();\n\t\tif (rhs == -1) return make_pair(-1, f);\n\t\tres *= rhs;\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\npair<int, bool> plu()\n{\n\tauto a = mul();\n\tint res = a.first;\n\tbool f = a.second;\n\tif (res == -1) return make_pair(-1, f);\n\twhile (tmp[p] == '+' || tmp[p] == '-')\n\t{\n\t\tf = true;\n\t\tif (tmp[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres += rhs;\n\t\t}\n\t\telse if (tmp[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tint rhs = mul().first;\n\t\t\tif (rhs == -1) return make_pair(-1, f);\n\t\t\tres -= rhs;\n\t\t}\n\t}\n\tif (!range(res)) return make_pair(-1, f);\n\telse return make_pair(res, f);\n}\n\nint parse()\n{\n\tp = 0;\n\tint res = plu().first;\n\tif (p != tmp.size()) return -1;\n\telse return res;\n}\n\nbool check1()\n{\n\tbool res = true;\n\tREP(i, tmp.size()) if (!isdigit(tmp[i])) res = false;\n\treturn res;\n}\n\nbool check2()\n{\n\tbool res;\n\tstring elem; //0 = number, 1 = operator, 2 = '('\n\tREP(i, tmp.size())\n\t{\n\t\tif (isdigit(tmp[i]))\n\t\t{\n\t\t\twhile (isdigit(tmp[i])) i++;\n\t\t\ti--;\n\t\t\telem.push_back('0');\n\t\t}\n\t\telse if (tmp[i] == '+' || tmp[i] == '-' || tmp[i] == '*')\n\t\t{\n\t\t\telem.push_back('1');\n\t\t}\n\t\telse if (tmp[i] == '(') elem.push_back('(');\n\t\telse if (tmp[i] == ')') elem.push_back(')');\n\t\telse assert(false);\n\t}\n\tREP(i, elem.size() - 2)\n\t{\n\t\tif (elem[i] == '('&&elem[i + 1] == '0'&&elem[i + 2] == ')') return false;\n\t}\n\tREP(i, elem.size() - 1)\n\t{\n\t\tif (elem[i] == '('&&elem[i + 1] == ')') return false;\n\t}\n\treturn true;\n}\n\n\n\nvoid solve(int i, vi w)\n{\n\tif (i == v.size())\n\t{\n\t\ttmp = s;\n\t\tREP(i, v.size())\n\t\t{\n\t\t\ttmp[v[i]] = let[w[i]];\n\t\t}\n\t\tp = 0;\n\t\tif (check1())\n\t\t{\n\t\t\tint res = num();\n\t\t\tchmax(ans, res);\n\t\t}\n\t\telse if (check2())\n\t\t{\n\t\t\tint res = parse();\n\t\t\tchmax(ans, res);\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, 7)\n\t\t{\n\t\t\tvi tmp = w;\n\t\t\ttmp.push_back(j);\n\t\t\tsolve(i + 1, tmp);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tans = -1;\n\tcin >> s;\n\tn = s.size();\n\tREP(i, n)\n\t{\n\t\tif (s[i] == '.') v.push_back(i);\n\t}\n\tvi emp;\n\tsolve(0, emp);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stdexcept>\n\n#define fprintf(...) void(0)\n\nconst std::string chs=\"01+-*()\";\n\nbool next_assignment(std::vector<size_t> &d) {\n  for (size_t i=d.size(); i--;) {\n    if (d[i] < 6) {\n      ++d[i];\n      return true;\n    }\n    d[i] = 0;\n  }\n  return false;\n}\n\nint apply(int lhs, char op, int rhs) {\n  if (op == '+') {\n    lhs += rhs;\n  } else if (op == '-') {\n    lhs -= rhs;\n  } else if (op == '*') {\n    lhs *= rhs;\n  }\n  if (!(0 <= lhs && lhs < 1024))\n    throw std::logic_error(\"overflow\");\n\n  return lhs;\n}\n\nint parse(\n    const std::string &s, size_t &i, size_t preced=0) {\n\n  static const std::vector<std::string> ops={\"+-\", \"*\"};\n\n  if (preced == ops.size()) {\n    if (s[i] == '(') {\n      fprintf(stderr, \"starting from %zu\\n\", i);\n      size_t j=i;\n      parse(s, ++j, preced);\n      int res=parse(s, ++i);\n      if (!(i < s.length() && s[i] == ')'))\n        throw std::logic_error(\"mismatch parentheses\");\n      fprintf(stderr, \"i: %zu, j: %zu\\n\", i, j);\n      if (i == j)\n        throw std::logic_error(\"redundant parentheses\");\n      ++i;\n      return res;\n    }\n    if (isdigit(s[i])) {\n      int res=s[i]-'0';\n      while (++i < s.length() && isdigit(s[i])) {\n        res = res*2+s[i]-'0';\n        if (res >= 1024) throw std::logic_error(\"overflow\");\n      }\n      return res;\n    }\n    throw std::logic_error(\"unexpected\");\n  }\n\n  int res=parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    int tmp=parse(s, ++i, preced+1);\n    res = apply(res, op, tmp);\n  }\n  return res;\n}\n\nint parse(const std::string &s, std::vector<size_t> &d) {\n  std::string t;\n  size_t i=0;\n  for (char ch: s) {\n    if (ch == '.') {\n      t += chs[d[i++]];\n      continue;\n    }\n    t += ch;\n  }\n  i = 0;\n  fprintf(stderr, \"%s\\n\", t.c_str());\n  int res=parse(t, i);\n  fprintf(stderr, \"[%zu]\\n\", i);\n  if (i < t.length())\n    throw std::logic_error(\"garbage\");\n  return res;\n}\n\nint main() {\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  size_t dot=std::count(s.begin(), s.end(), '.');\n  std::vector<size_t> d(dot);\n\n  int res=-1;\n  do {\n    try {\n      res = std::max(res, parse(s, d));\n    } catch (std::logic_error &e) {\n      fprintf(stderr, \"failed: %s\\n\", e.what());\n    }\n  } while (next_assignment(d));\n  printf(\"%d\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc {\n  private:\n    int N, idx;\n    string s;\n    \n  public:\n    Calc (const string& s) : s{s} {\n        idx = 0;\n        N = s.size();\n    }\n\n    static bool is_op(char c)\n    {\n        return (c == '+' || c == '-' || c == '*');   \n    }\n\n    bool check_range(int x)\n    {\n        return (0 <= x && x < 1024);\n    }\n    \n    int num()\n    {\n        int res = 0, p = 0;\n        while (isdigit(s[idx])) {\n            if (p > 10 && s[idx] == '1') return -1;\n            res *= 2;\n            res += (s[idx] - '0');\n            p++;\n            ++idx;\n        }        \n        return (check_range(res) ? res : -1);\n    }\n\n    bool check_op(int cur)\n    {\n        int p = 0;\n        for (int i = cur + 1; i < N; i++) {\n            if (s[i] == '(') p++;\n            if (s[i] == ')') p--;\n            if (p == 0 && is_op(s[i])) return 1;\n            if (p < 0) break;\n        }\n        return 0;\n    }\n    \n    int fact()\n    {\n        int ret = -1;\n        if (s[idx] == '(') {\n            if (!check_op(idx)) throw 0;\n            ++idx;\n            ret = expr();\n            ++idx;\n        } else {\n            ret = num();\n        }\n        if (!check_range(ret)) throw 0;         \n        return ret;\n    }\n\n    int term()\n    {\n        int ret = fact();\n        while (s[idx] == '*') {\n            ++idx;\n            ret *= fact();\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n\n    int expr()\n    {\n        int ret = term();\n\n        while (s[idx] == '+' || s[idx] == '-') {\n            if (s[idx] == '+') {\n                ++idx;\n                ret += term();\n            } else {\n                ++idx;\n                ret -= term();\n            }\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n};\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid(const string& s)\n{\n    int p = 0, N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (Calc::is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || Calc::is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || Calc::is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n\n        if (s[i] == '(') {\n            if (i == N - 1) return 0;\n            if (i > 0 && (isdigit(s[i - 1]) || s[i - 1] == ')')) {\n                return 0;\n            }\n        }\n        \n        if (s[i] == ')') {\n            if (i == 0) return 0;\n            if (i < N - 1 && (isdigit(s[i + 1]) || s[i + 1] == '(')) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n\n        for (int j = i + 1; j < N; j++) {\n            if (s[i] == '(' && s[j] == ')' && j - i < 4) {\n                return 0;\n            }\n        }\n    }\n    return (p == 0);\n}\n\nint solve(string& s)\n{\n    int N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        if (!valid(s)) return -1;\n        Calc calc(s);\n        int res = -1;\n        \n        try {\n            res = calc.expr();\n        } catch (...) {}\n        \n        return res;\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid(s)) {\n            Calc calc(s);\n            try {\n                res = max(res, calc.expr());\n            } catch (...) {}\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    cout << solve(s) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    int N;\n    void input() {\n        cin >> s;\n        N = s.size();\n    }\n\n    int valid(int x) {\n        return 0 <= x && x < 1024;\n    }\n\n    int number(int& index) {\n        int x = 0;\n        while (isdigit(s[index])) {\n            int c = s[index] - '0';\n            x = x * 2 + c;\n            index++;\n        }\n        if (not valid(x)) return -1;\n        return x;\n    }\n    int oper(int x, int y, char op) {\n        int ret = 0;\n        if (op == '+') {\n            ret = x + y;\n        } else if (op == '-') {\n            ret = x - y;\n        } else if (op == '*') {\n            ret = x * y;\n        } else {\n            return -1;\n        }\n        if (not valid(ret)) return -1;\n        return ret;\n    }\n    int expr(int& index, bool flag = false) {\n        if (isdigit(s[index])) {\n            int x = number(index);\n            if (index == N || (!flag && s[index] == ')')) return x;\n            if (not valid(x)) return -1;\n            char op = s[index]; index++;\n            int y = expr(index);\n            if (not valid(y)) return -1;\n            /*\n            cout << \"x: \" << x << endl;\n            cout << \"y: \" << y << endl;\n            cout << \"op: \" << op << endl;\n            cout << \"res: \" << oper(x, y, op) << endl;\n            */\n            return oper(x, y, op);\n        }\n        if (s[index] == '(') {\n            index++;\n            int ret = expr(index, true);\n            if (s[index] != ')') return -1;\n            index++;\n            if (not valid(ret)) return -1;\n            return ret;\n        }\n        return -1;\n    }\n\n    int calc(int index) {\n        const string C = \"01+-*()\";\n        if (index == N) {\n            int i = 0;\n            //cout << s << \" -> \" << expr(i) << endl;\n            i = 0;\n            return expr(i);\n        }\n        if (s[index] == '.') {\n            int ret = -1;\n            for (int i = 0; i < C.size(); i++) {\n                s[index] = C[i];\n                ret = max(ret, calc(index + 1));\n            }\n            s[index] = '.';\n            return ret;\n        } else {\n            return calc(index + 1);\n        }\n    }\n\n    void solve() {\n        cout << calc(0) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(e.first<0||!e.second||s[x]!=')')return fail;\n    x++;\n    return e;\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      if(n>=1<<10)return fail;\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(f.first<0)return f;\n  if(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(l.first<0)return l;\n    return make_pair(f.first*l.first,true);\n  }else{\n    return f;\n  }\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(f.first<0)return f;\n  if(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(l.first<0)return l;\n    return make_pair(f.first+sign*l.first,true);\n  }else{\n    return f;\n  }\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tm=max(m,dfs());\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\t\tif (val >= 1024)return -1;\n\t\tif (val < 0)return -1;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t\tif (val >= 1024)return - 1;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num]))n = n * 2 + s[num++] - '0';\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\tsc.push('0');\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.top() == '0'){\n\t\t\tans = expr(s, num);\n\t\t\tma = max(ma, ans);\n\t\t}\n\t\tcout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint formula(int &p,bool inper);\npair<int,bool> term1(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint calc(int lhs,int rhs,char op){\n  int res=-1;\n  if(lhs==-1 || rhs==-1) return -1;\n  if(op=='+') res=lhs+rhs;\n  if(op=='-') res= lhs-rhs;\n  if(op=='*') res= lhs*rhs;\n  return 0<=res && res<1024 ? res : -1;\n}\n\nstring s;\nint formula(int &p,bool inper=false){\n  bool isok=!inper;\n  pair<int,bool> ret=term1(p);\n  int res=ret.first;\n  isok|=ret.second;\n  while(p<s.size() && s[p]!=')'){\n    inper=false;\n    char op=s[p];\n    if(op!='+' && op!='-'){\n      return -1;\n    }\n    isok=true;\n    p++;\n    int rhs=term1(p).first;\n    res=calc(res,rhs,op);\n  }\n  return isok ? res : -1;\n}\n\npair<int,bool> term1(int &p){\n  int res=term2(p);\n  bool res2=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;\n    if(op!='*'){\n      return {-1,0};\n    }\n    res2=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,res2};\n}\n\nint term2(int &p){\n int res=1;\n  if(s[p]=='('){\n    p++;\n    res=formula(p,true);\n    if(s[p]!=')') return -1;\n    p++;\n  }\n  else if(isdigit(s[p])){\n    res=get_num(p);\n  }\n  else{\n    return -1;\n  }\n  return res;\n}\n\nint get_num(int &p){\n  int res=-1;\n  while(isdigit(s[p])){\n    if(res==-1) res=0;\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  //cout<<res<<endl;\n  if(res>=1024) return -1;\n  return res;\n}\n\nstring ch=\"01+-*()\";\n\nint dfs(int i){\n  if(i==s.size()){\n    int p=0;\n    //cout<<s<<endl;\n    int res=formula(p);\n    //cout<<res<<endl;\n    return res;\n  }\n  if(s[i]=='.'){\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      res=max(res,dfs(i+1));\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  vector<int> sec;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  while(*it=='0') ++it;\n\n  *result = 0;\n  int max_length = 10;\n  int length = 0;\n  while(true){\n    if(it+length==end || (*(it+length)!='0' && *(it+length)!='1')) break;\n    *result += (*(it+length) - '0') << (max_length-length);\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length + 1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseValue(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  \n  int v;\n  perseValue(temp, &v);\n  if(*temp!='*' && *temp!='-' && *temp!='+') return false;\n  \n  if(*it!=')') return false;\n\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseValue(it, result)) return false;\n  \n  unsigned long long lv = *result;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseValue(it, &rv)) return false;\n    lv *= rv;\n    if(lv >= 1024) return false;\n  }\n  *result = lv;\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  \n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            string::iterator it = begin;\n            int val = 0;\n            if(perseExpression(it, &val)){\n              if(it==end) max_val = max(max_val, val);\n            }\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\nstring s;\nint p;\n\nint err = 0;\n\nint number();\npair<int,int> expr(int needOp);\n\nvoid chk(int v){\n\tif( v < 0 || v >= 1024 ) throw(3);\n}\n\nint isop(char c){\n\treturn c == '+'||c == '-'||c == '*';\n}\nint expression(int needOp){\n\tpair<int,int> cc = expr(0);\n\tint l = cc.second;\n\tif( cc.first ) needOp = 0;\n\t\n\tint flag = 0;\n\twhile(s[p] == '+' || s[p] == '-'){\n\t\tif( s[p] == '+' ){p++; l += expr(0).second;chk(l);}\n\t\telse if( s[p] == '-' ){p++; l -= expr(0).second;chk(l);}\n\t\tflag = true;\n\t}\n\tchk(l);\n\tif(needOp && !flag) throw(0);;\n\treturn l;\n}\npair<int,int> expr(int needOp){\n\tint l = number();\n\tint flag = 0;\n\twhile( s[p] == '*' ){\n\t\tflag = true;\n\t\tif( s[p] == '*' ){p++; l *= number();chk(l);}\n\t}\n\tif(needOp && !flag) throw(0);\n\tchk(l);\n\treturn make_pair(flag,l);\n}\n\nint number(){\n\tif( s[p] == '(' ){\n\t\tp++;\n\t\tint l = expression(1);\n\t\tif( p >= s.size() || s[p] != ')' ) throw(1);\n\t\tp++;\n\t\treturn l;\n\t}\n\tint ans = 0;\n\tif( s[p] != '0' && s[p] != '1' ) throw(4);\n\t\n\twhile( s[p] >= '0' && s[p] <= '1' ){\n\t\tans = ans * 2 + s[p++] - '0';\n\t\tchk(ans);\n\t}\n\treturn ans;\n}\n\nvector<int> pos;\n\nint ans = -1;\n\nvoid dfs(int x){\n\tif( x >= pos.size()){\n\t\tp = 0;\n\t\ttry{\n\t\t\tint get = expression(0);\n\t\t\tif( p != s.size() ) throw(0);\n\t\t\t//cout << s << endl;\n\t\t\t\n\t\t\tans = max(ans,get);\n\t\t}catch(int x){\n\t\t\t//cout << s << \" \" << x << endl;\n\t\t}\n\t}else{\n\t\tfor(int i = 0 ; i < 7 ; i++){\n\t\t\ts[pos[x]] = \"01+-*()\"[i];\n\t\t\tdfs(x+1);\n\t\t}\n\t}\n\t\n}\n\nint main(){\n\tcin >> s;\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif(s[i] =='.')pos.push_back(i);\n\t}\n\t\n\tdfs(0);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstdlib>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<cmath>\n\nusing namespace std;\nbool deb;\n\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\n  bool safe,mul;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n    safe = mul = false;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      safe = true;\n      int p = expression();\n      safe = false;\n      mul = false;\n      //cout << \"in fact, p = \" << p << endl;\n      pos++;\n      return p;\n    }else{\n      int ru = 0;\n      string p; p.clear();\n      \n      while('0' <= parse[pos] && parse[pos] <= '1'){\n\tp += parse[pos];\n\tpos++;\n      }\n      reverse(p.begin(),p.end());\n      int ip = 0;\n      bool ook = false;\n      for(int i=0;i<p.length();i++){\n\tif(p[i] == '1'){\n\t  ip += pow((double)2,(double)ru);\n\t}\n\took = true;\n\tru++;\n      }\n      if(!ook)ip = -1;\n      //cout << \"in fact, ip = \" << ip << endl;\n      return ip;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p < 0 || p >=1024){\n      //cout << \"error! in term, negative number error\" << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tmul = true;\n\tint fac= fact();\n       \n\tif(fac < 0 || fac >= 1024){\n\t  //cout << \"error! in term(while *), BNF error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n\tp *= fac;\n\t//cout << \"in term(while *), fact =  \" << fac << endl;\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, negative number error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(p < 0 || p >= 1024){\n      //cout << \"error! in expression, negative number error\" << endl;\n      deb = true;\n      return -1;\n    }\n    if(!(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*' || pos == parse.length() || (safe && mul && parse[pos] == ')'))){\n      //cout << \"error! in expression, not operator. parse[pos] = \" << parse[pos] << endl;\n      deb = true;\n      return -1;\n    }\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tp+=term();\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, negative number error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else if(parse[pos] == '-'){\n\tpos++;\n\tp-=term();\n\tif(p < 0 || p >= 1024){\n\t  //cout << \"error! in term, negative number error\" << endl;\n\t  deb = true;\n\t  return -1;\n\t}\n      }\n      else {\n\t//cout << \"error! in expression, not operator Ver2.\" << endl;\n\tdeb = true;\n\treturn -1;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\n\n\n/*\nclass Parsing{\nprivate:\n  bool oh,plus;\n  int  pos;\n  string parse;\npublic:\n  Parsing(string s){\n    pos = 0,parse = s,oh = false,plus = false;\n  }\n\n \n\n  \n  int expression(){\n    if(parse[pos] == '('){\n      ++pos;\n      oh = true;\n      int A = expression();\n      cout << \"in expression, A = \" << A << endl;\n      ++pos;\n      oh = false;\n      return A;\n    }\n    else{\n    int p = number();\n    cout << \"in expression, p = \" << p << endl;\n    \n    if(parse[pos]=='+' || parse[pos] == '-' || parse[pos] == '*'){\n\n      char op = operation();\n      cout << \"in expression, op = \" << op  << \",parse[pos] = \" << parse[pos]<< endl;\n      ++pos;\n      if(oh)plus = true;\n      int B = expression();\n      plus = false;\n      cout << \"in expression, B = \" << B << \",parse[pos] = \" << parse[pos] << endl;\n      ++pos;\n      cout << \"p = \" << p <<\",op = \" << op <<\", B = \" << B << endl;\n      if(op == '+')return p+B;\n      else if(op == '-')return p-B;\n      else if(op == '*')return p*B;\n      else{\n\tdeb = true;\n\tcout << \"in expression, not operation error\" << endl;\n      }\n    }  \n    return p;\n    }\n  }\n\n\n\n  char operation(){\n    if(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*'){\n      return parse[pos];\n    }\n    else{\n      deb = true;\n      cout << \"in operation, not operation error. parse[pos] = \" << parse[pos] << endl;\n      return 'E';\n    }\n  }\n\n  int number(){\n    if(parse[pos] == '('){\n      ++pos;\n      int A = number();      \nchar op\n\n    }\n    else{\n      string p; p.clear();\n      while(parse[pos] == '0' || parse[pos] == '1')p += parse[pos],pos++;\n      cout << \"in number, p = \" << p << endl;\n      if(plus)pos++;\n      if(!(parse[pos] == '+' || parse[pos] == '-' || parse[pos] == '*' || pos == parse.length())){\n\tdeb = true;    \n\tcout << \"in number,not digit error. parse[pos] = \" << parse[pos] << endl;\n      }\n      \n      reverse(p.begin(),p.end());\n      int ip = 0,ru = 0;\n      for(int i=0;i<p.length();i++){\n\tif(p[i] == '1'){\n\t  ip += pow(2.0,(double)ru);\n\t}\n\tru++;\n      }\n      \n      return ip;\n    }\n  }\n  \n\n\n};\n*/\n\n\nint Fans;\nchar perm[5] = {'0','1','+','-','*'};\nvoid all_permutation(string s){\n\n  for(int i=0;i<s.length();i++){\n    if(s[i] == '.'){\n      for(int j=0;j<5;j++){\n\tstring pre = s;\n\ts[i] = perm[j];\n\tall_permutation(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      deb = false;\n      //cout << \"s = \" << s << endl;\n      Parsing par = Parsing(s);\n      int ans = par.expression();\n      //cout <<\"ans = \" << ans  << \",deb = \" << deb << \",true =\" << true<< endl;\n      if(!deb) Fans = max(Fans,ans); \n    }\n  }\n\n}\n\nint main(){\n  string s;\n  Fans = -1;\n  cin >> s;\n  all_permutation(s);\n  cout << Fans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p;\nbool flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  if(s[p]=='('){\n    flg&=check2();\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\n\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    else {\n      if(s[p]==')')break;\n      flg&=check(p+1);\n      if(s[p]=='+')p++,flg&=check2(),res+=bnf();\n      else if(s[p]=='-')p++,flg&=check2(),res-=bnf();\n      else if(s[p]=='*'){\n\tif(s[p++]=='(')flg&=check2(),res*=bnf();\n\telse res*=Num();\n      }\n      else break;\n    }\n  }\n  if(!flg||res>=1024)return -INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint expression(State &begin, State &end);\nint term(State &begin, State &end);\nint number(State &begin, State &end);\nint factor(State &begin, State &end);\n\nint number(State &begin, State &end) {\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret = ret << 1;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin, State &end) {\n\tint ret = factor(begin, end);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin, end);\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin, end);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin, State &end) {\n\tint ret = term(begin, end);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin, end);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin, end);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin, State &end) {\n\tif (*begin == '(') {\n\t\tbegin++; // '('テ」ツつ津ゥツ」ツ崚」ツ?ーテ」ツ?凖」ツ??\n\t\tint ret = expression(begin, end);\n\t\tbegin++; // ')'テ」ツつ津ゥツ」ツ崚」ツ?ーテ」ツ?凖」ツ??\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin, end);\n\t}\n}\n\nvector<int> v;\n\nint f(int idx, string s){\n\tint ret = -1;\n\tif(idx == v.size() || v.size() == 0){\n\t\tint brackets = 0, op = 0;\n\t\tbool possible = true;\n\t\trep(i, s.size()){\n\t\t\tif(s[i] == '(') brackets++;\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*') op++;\n\t\t\tif(s[i] == ')' && op != brackets){possible = false; break;}\n\t\t}\n\t\tstring t = s;\n\t\trep(i, s.size()){\n\t\t\tif(s[i] == '(' || s[i] == ')'){ s = s.substr(0, i) + s.substr(i+1); i--;}\n\t\t}\n\t\tint c = 0;\n\t\twhile(c < s.size()){\n\t\t\twhile(isdigit(s[c])) c++;\n\t\t\tif(!(c < s.size())) break;\n\t\t\tif(s[c] == '+' || s[c] == '-' || s[c] == '*') c++;\n\t\t\telse {possible = false; break;}\n\t\t\tif(!(c < s.size())){possible = false; break;}\n\t\t}\n\t\tif(!possible) return -1;\n\t\ts = t;\n\t\tState begin = s.begin();\n\t\tState end = s.end();\n\t\treturn expression(begin, end);\n\t}\n\telse {\n\t\tstring t = \"01+-*()\";\n\t\tfor(int i=0; i< t.size(); i++){\n\t\t\ts = s.replace(v[idx], 1, t.substr(i, 1));\n\t\t\tint n = f(idx+1, s);\n\t\t\tif(0 <= n && n < pow(2, 10)) ret = max(ret, n);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tstring s;\n\tgetline(cin, s);\n\trep(i, s.size()) if(s[i] == '.') v.push_back(i);\n\tcout << f(0, s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n\n  return true;\n}\n\nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n\n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n\n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true; \n  }\n  return false;\n}\n\nbool parapos(string s){\n  int p = 0;\n\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n  }\n  return p == 0;\n}\n\nbool isvalid(string s){\n\n  if(!parapos(s)) return false;\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n\nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n\nint get(string s){\n  //  cout << \"S \" << s << endl;\n \n  if(isnum(s)) return tob(s);\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return get(s.substr(0,i))+get(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return get(s.substr(0,i))-get(s.substr(i+1));\n    }\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return get(s.substr(0,i))*get(s.substr(i+1));\n    }\n  }\n}\n\nvoid solve(int n){\n\n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n    if(isvalid(in)) ans = max(ans,get(in));\n    \n  }\n}\n\nint main(){\n\n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n\n  solve(0);\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nint idx, n, ans;\nvector<int> pos;\nchar s[128];\n\nstring op = \"01+-*()\";\n\nint toInt(string tb){\n  int j = tb.find(\"1\");\n  string binary;\n\n  if(j == string::npos){\n    binary = \"0\";\n  }\n  else{\n    binary = tb.substr(j);\n  }\n\n  if(binary.length() > 10){\n    return -1;\n  }\n\n  int res = 0;\n\n  for(int i = 0; i < binary.length(); i++){\n    res <<= 1;\n\n    if(binary[i] == '1'){\n      res++;\n    }\n  }\n\n  return res;\n}\n\nint number(){\n  string binary = \"\";\n\n  while(isdigit(s[idx])){\n    binary += s[idx];\n    idx++;\n  }\n\n  return toInt(binary);\n}\n\nint solve();\n\nint factor(){\n  if(s[idx] == '('){\n    idx++;\n\n    int x = solve();\n    if(x < 0 || 1024 <= x) return -1;\n\n    if(s[idx] != ')'){\n      return -1;\n    }\n    idx++;\n    return x;\n  }\n  else if(s[idx] == '0' || s[idx] == '1'){\n    return number();\n  }\n  else{\n    return -1;\n  }\n}\n\nint term(){\n  int x = factor();\n  if(x < 0 || 1024 <= x) return -1;\n\n  while(idx < n){\n    if(s[idx] == '*'){\n      idx++;\n\n      int y = factor();\n      if(y < 0 || 1024 <= y) return -1;\n\n      x *= y;\n\n      if(x < 0 || 1024 <= x) return -1;\n    }\n    else{\n      break;\n    }\n  }\n\n  return x;\n}\n\nint solve(){\n  int x = term();\n\n  if(x < 0 || 1024 <= x) return -1;\n\n  while(idx < n){\n    if(s[idx] == '+'){\n      idx++;\n\n      int y = term();\n      if(y < 0 || 1024 <= y) return -1;\n\n      x += y;\n      if(x < 0 || 1024 <= x) return -1;\n    }\n    else if(s[idx] == '-'){\n      idx++;\n\n      int y = term();\n      if(y < 0 || 1024 <= y) return -1;\n\n      x -= y;\n      if(x < 0 || 1024 <= x) return -1;\n    }\n    else if(s[idx] == '*'){\n      idx++;\n\n      int y = term();\n      if(y < 0 || 1024 <= y) return -1;\n\n      x *= y;\n      if(x < 0 || 1024 <= x) return -1;\n    }\n    else{\n      break;\n    }\n  }\n\n  return x;\n}\n\nint idx2;\n\nbool check(bool first){\n  bool flg = false;\n\n  while(idx2 < n){\n    if(s[idx2] == ')'){\n      return flg;\n    }\n\n    if(s[idx2] == '('){\n      idx2++;\n      if(!check(false)) return false;\n    }\n\n    if(s[idx2] == '+' || s[idx2] == '-' || s[idx2] == '*'){\n      flg = true;\n    }\n\n    idx2++;\n  }\n\n  if(first){\n    return true;\n  }\n\n  return flg;\n}\n\nvoid dfs(int now){\n  if(now == pos.size()){\n    idx = 0;\n    int cal = solve();\n\n    if(idx != n){\n      cal = -1;\n    }\n\n    idx2 = 0;\n\n    if(cal != -1 && 0 <= cal && cal < (1 << 10) && check(true)){\n      ans = max(ans, cal);\n    }\n\n    return;\n  }\n\n  for(int i = 0; i < op.size(); i++){\n    s[pos[now]] = op[i];\n    dfs(now + 1);\n  }\n}\n\nint main(){\n  memset(s, '?', sizeof(s));\n\n  while(cin >> s){\n    n = strlen(s);\n    pos.clear();\n\n    for(int i = 0; i < n; i++){\n      if(s[i] == '.'){\n        pos.push_back(i);\n      }\n    }\n\n    ans = INT_MIN;\n    dfs(0);\n\n    if(ans == INT_MIN){\n      cout << -1 << endl;\n    }\n    else{\n      cout << ans << endl;\n    }\n\n    memset(s, '?', sizeof(s));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int MAX = 1023;\nconst int MIN = 0;\nchar ch[] = {\n  '0', '1', '+', '-', '(', ')',\n};\nsize_t cur;\nstring str;\n\nint E(int &op_cnt);\n\nint number(){\n  int res = 0;\n  while(cur < str.size() && isdigit(str[cur])){\n    res = res * 2 + str[cur++] - '0';\n    if(res > MAX) return -1;\n  }\n  \n  return res;\n}\n\nint T(){\n  int res;\n  if(isdigit(str[cur])){\n    res = number();\n  }else if(str[cur] == '('){\n    int cnt = 0;\n    cur++;\n    res = E(cnt);\n    if(cur == str.size()) return -1;\n    cur++;\n    if(cnt == 0) res = -1;\n  }else{\n    res = -1;\n    cur++;\n  }\n  return res;\n}\n\nint F(int &op_cnt){\n  int res = 1;\n  vector<int> v;\n  \n  v.push_back(T());\n  \n  while(cur < str.size() && str[cur] == '*'){\n    cur++;\n    op_cnt++;\n    if(cur == str.size()) return -1;\n    int tmp = T();\n    if(tmp < 0) return -1;\n    v.push_back(tmp);\n  }\n  \n  rep(i, v.size()){\n    res *= v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  return res;\n}\n\nint E(int &op_cnt){\n  \n  int res = 0;\n  int tmp;\n  vector<int> v;\n  \n  tmp = F(op_cnt);\n  if(tmp < 0) return -1;\n  else v.push_back(tmp);\n  \n  if(res == -1) return -1;\n  \n  while(cur < str.size() && (str[cur] == '+' || str[cur] == '-')){\n    char op = str[cur];\n    op_cnt++;\n    cur++;\n    if(cur == str.size()) return -1;\n      \n    tmp = F(op_cnt);\n    if(tmp < 0) return -1;\n    else v.push_back(op == '+' ? tmp : -tmp);\n  }\n  \n  if(cur < str.size() && str[cur] != ')') return -1;\n  rep(i, v.size()){\n    res += v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  return res;\n}\n\nint calc(string s){\n  int cnt;\n  str = s;\n  cur = 0;\n  //  cout << s << endl;\n  int res = E(cnt);\n  //cout << res << endl;\n  return res;\n  \n}\n\nint dfs(string s, int c){\n  if(c == 0){\n    return calc(s);\n  }\n  \n  int res = -1;\n  int pos = 0;\n  while(s[pos] != '.') pos++;\n  \n  rep(i, 6){\n    s[pos] = ch[i];\n    res = max(res, dfs(s, c - 1));\n    s[pos] = '.';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  int c = count(s.begin(), s.end(), '.');\n  cout << dfs(s, c) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nclass SyntaxAnalysis\n{\npublic:\n    using T = pair<bool, int>;\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '*';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '(';\n    static T plus(const T& n, const T& k) { return {n.first and k.first and prop(n.second + k.second), n.second + k.second}; }\n    static T minus(const T& n, const T& k) { return {n.first and k.first and prop(n.second - k.second), n.second - k.second}; }\n    static T product(const T& n, const T& k) { return {n.first and k.first and prop(n.second * k.second), n.second * k.second}; }\n    static T divide(const T& n, const T& k) { return n; }\n    static T brace(const T& n) { return n; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '1'; }\n    static int encode(const char c) { return c - '0'; }\n    static bool prop(const int l) { return l >= 0 and l < 1 << 10; }\n    T number()\n    {\n        int ans = 0, start = S.size();\n        for (; pos < S.size() and is_digit(S[pos]); pos++) {\n            if (S[pos] == '1') { start = min(start, pos); }\n            ans = ans * 2 + encode(S[pos]);\n        }\n        return {pos - start <= 10, ans};\n    }\n    T factor()\n    {\n        if (S[pos] == BRACE) {\n            T ans;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    T term()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, f = factor(), ans = product(ans, f);\n            } else if (S[pos] == DIVIDE) {\n                pos++, f = factor(), ans = divide(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    T expression()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = factor(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = factor(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\ntemplate <typename S, typename T>\ninline ostream& operator<<(ostream& os, const pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\n\nint main()\n{\n    constexpr char C[7] = {'0', '1', '+', '-', '*', '(', ')'};\n    string s;\n    cin >> s;\n    vector<int> p;\n    int NUM = 1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '.') { p.push_back(i), NUM *= 7; }\n    }\n    const int sz = p.size();\n    int ans = -1;\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0, num = i; j < sz; j++, num /= 7) { s[p[j]] = C[num % 7]; }\n        stack<int> st;\n        st.push(0);\n        bool ok = true, num = false;\n        for (const char c : s) {\n            if (c == '(') {\n                if (num) {\n                    ok = false;\n                    break;\n                }\n                st.push(0);\n            } else if (c == ')') {\n                if (st.size() <= 1 or st.top() == 0) {\n                    ok = false;\n                    break;\n                }\n                num = true;\n                st.pop();\n            } else if (c == '+' or c == '-' or c == '*') {\n                if (not num) {\n                    ok = false;\n                    break;\n                }\n                num = false;\n                const int n = st.top() + 1;\n                st.pop(), st.push(n);\n            } else {\n                num = true;\n            }\n        }\n        if (not ok) { continue; }\n        const auto sub = SyntaxAnalysis{s}.Expression();\n        // show(sub);\n        if (sub.first) { ans = max(ans, sub.second); }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass SyntaxAnalysis\n{\npublic:\n    using T = pair<bool, int>;\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '*';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '(';\n    static T plus(const T& n, const T& k) { return {n.first and k.first and prop(n.second + k.second), n.second + k.second}; }\n    static T minus(const T& n, const T& k) { return {n.first and k.first and prop(n.second - k.second), n.second - k.second}; }\n    static T product(const T& n, const T& k) { return {n.first and k.first and prop(n.second * k.second), n.second * k.second}; }\n    static T divide(const T& n, const T& k) { return n; }\n    static T brace(const T& n) { return n; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '1'; }\n    static int encode(const char c) { return c - '0'; }\n    static bool prop(const int l) { return l >= 0 and l < 1 << 10; }\n    T number()\n    {\n        int ans = 0, start = S.size();\n        for (; pos < S.size() and is_digit(S[pos]); pos++) {\n            if (S[pos] == '1') { start = min(start, pos); }\n            ans = ans * 2 + encode(S[pos]);\n        }\n        return {pos - start <= 10, ans};\n    }\n    T factor()\n    {\n        if (S[pos] == BRACE) {\n            T ans;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    T term()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, f = factor(), ans = product(ans, f);\n            } else if (S[pos] == DIVIDE) {\n                pos++, f = factor(), ans = divide(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    T expression()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = factor(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = factor(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\nint main()\n{\n    constexpr char C[7] = {'0', '1', '+', '-', '*', '(', ')'};\n    string s;\n    cin >> s;\n    vector<int> p;\n    int NUM = 1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '.') { p.push_back(i), NUM *= 7; }\n    }\n    const int sz = p.size();\n    int ans = -1;\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0, num = i; j < sz; j++, num /= 7) { s[p[j]] = C[num % 7]; }\n        int st = 0;\n        bool op = false, ok = true;\n        for (const char c : s) {\n            if (c == '(') {\n                st++;\n            } else if (c == ')') {\n                if (st <= 0 or not op) { ok = false; }\n                st--, op = false;\n            } else if (c == '+' or c == '-') {\n                op = true;\n            }\n        }\n        if (not ok) { continue; }\n        const auto sub = SyntaxAnalysis{s}.Expression();\n        if (sub.first) { ans = max(ans, sub.second); }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\ntypedef string::iterator Iterator;\nconst int LIMIT = 2<<10;\n\nint number(Iterator &it) {\n    int val = 0;\n    if(!isdigit(*it)) throw \"not a number\";\n    while(isdigit(*it)) {\n        val <<= 1;\n        val += *it - '0';\n        ++it;\n    }\n    if(val >= LIMIT) throw \"limit over\";\n    return val;\n}\n\nint expression(Iterator &it, bool &operated);\nint term(Iterator &it, bool &operated) {\n    int lhs;\n    if(*it == '(') {\n        lhs = expression(it, operated);\n    } else {\n        lhs = number(it);\n    }\n    while(*it == '*') {\n        ++it;\n        int rhs;\n        if(*it == '(') {\n            rhs = expression(it, operated);\n        } else {\n            rhs = number(it);\n        }\n        lhs *= rhs;\n        if(lhs >= LIMIT) throw \"limit over\";\n        operated = true;\n    }\n    return lhs;\n}\n\nint factor(Iterator &it, bool &operated) {\n    int lhs = term(it, operated);\n    while(*it == '+' || *it == '-') {\n        char op = *it;\n        ++it;\n        int rhs = term(it, operated);\n        if(op == '+') {\n            lhs += rhs;\n            if(lhs >= LIMIT) throw \"limit over\";\n            operated = true;\n        } else if(op == '-') {\n            lhs -= rhs;\n            if(lhs < 0) throw \"limit under\";\n            operated = true;\n        } else {\n            throw \"syntax error\";\n        }\n    }\n    return lhs;\n}\n\nint expression(Iterator &it, bool &operated) {\n    if(*it == '(') {\n        ++it;\n        bool operated = false;\n        int val = expression(it, operated);\n        if(val < 0 || val >= LIMIT) throw \"limit over\";\n        if(!operated) throw \"paren without operator\";\n        if(*it != ')') throw \"unmatched paren\";\n        ++it;\n        return val;\n    } else if(isdigit(*it)) {\n        return factor(it, operated);\n    } else {\n        throw \"syntax error\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    string str;\n    cin >> str;\n    vector<int> dotpos;\n    for(int i = 0; i < str.size(); ++i) {\n        if(str[i] == '.') dotpos.push_back(i);\n    }\n    int allpat = 1;\n    for(int i = 0; i < dotpos.size(); ++i) {\n        allpat *= 7;\n    }\n    int ans = -1;\n    for(int pat = 0; pat < allpat; ++pat) {\n        int tmp = pat;\n        string expr(str);\n        for(int i = 0; i < dotpos.size(); ++i) {\n            int n = tmp % 7;\n            tmp /= 7;\n            expr[dotpos[i]] = \"01+-*()\"[n];\n        }\n        try {\n            bool dmy;\n            Iterator it = expr.begin();\n            int val = expression(it, dmy);\n            if(it != expr.end()) throw \"premature end\";\n            ans = max(ans, val);\n        } catch (const char *msg) {\n            //cout << expr << ' ' << msg << endl;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p;\nbool flg;\nint bnf();\nbool check(int i){return i<s.size()&&s[i]!='+'&&s[i]!='-'&&s[i]!='*'&&s[i]!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  if(s[p]=='('){\n    flg&=check2();\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\nint calc(){\n  p++;\n  flg&=check2();\n  flg&=check(p);\n  if(s[p]=='(') return bnf();\n  int a=Num();\n  if(s[p]=='*'||s[p]=='(') return a*calc();\n  return a;\n}\n\nint bnf(){\n  flg&=check(p);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(p+1);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n  }\n\n  if(!flg||res>=1024||res<0)return -INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(char ch){return ch&&ch!='+'&&ch!='-'&&ch!='*'&&ch!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\nbool check3(int a){return 0<=a&&a<1024;}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  flg&=check3(res);\n  return res;\n}\n\nint calc(){\n  int res;\n  flg&=check(s[++p])&check2();\n  if(s[p]=='(')res=bnf();\n  else res=Num()*((s[p]=='*')? calc():1);\n  flg&=check3(res);\n  return res;\n}\n\nint bnf(){\n  flg&=check(s[p]);\n  int res=Num();\n  while(p<s.size()&&flg&&s[p]!=')'){\n    flg&=check3(res)&&s[p]!='('&&check(s[p+1]);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n  } \n  if(!flg||!check3(res))res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n  \n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef string::iterator State;\nconst int MA=1023,MI=0;\n\nstring str;\n\nint number(State &begin);\nint term(State &begin);\nint expr(State &begin);\nint term(State &begin);\nint expr2(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tint d=*begin-'0';\n\t\tret*=2;\n\t\tret+=d;\n\t\tbegin++;\n\t\tif(d>MA) return -1;\n\t}\n\tif(ret>MA||ret<MI) return -1;\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\tif(ret==-1) return -1;\n\twhile(true){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else break;\n\t}\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\nint expr(State &begin){\n\tint ret=term(begin);\n\tif(ret<MI||ret>MA) return -1;\n\tint c=0;\n\twhile(true){\n\t\tif(*begin=='+'){\n\t\t\tc++;\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret+=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else if(*begin=='-'){\n\t\t\tc++;\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}\n\t\telse break;\n\t}\n\tif(c==0) return -1;\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\n\nint expr2(State &begin){\n\tint ret=term(begin);\n\tif(ret<MI||ret>MA) return -1;\n\twhile(true){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret+=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tint a=term(begin);\n\t\t\tif(a<MI||a>MA) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<MI||ret>MA) return -1;\n\t\t}\n\t\telse break;\n\t}\n\tif(ret<MI||ret>MA) return -1;\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expr(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else if(!isdigit(*begin)) return -1;\n\telse return number(begin);\n}\n\nint ans=-1;\nvector<int> dots;\n\nstring chars=\"01()+-*\";\n\nvoid dfs(int id){\n\tif(id==dots.size()){\n\t\tState s=str.begin();\n\t\tint a=expr2(s);\n\t\tif(s!=str.end()) return;\n\t\tans=max(ans,a);\n\t}\n\telse{\n\t\tfor(int i=0;i<7;i++){\n\t\t\tstr[dots[id]]=chars[i];\n\t\t\tdfs(id+1);\n\t\t}\n\t\tstr[dots[id]]='.';\n\t}\n}\n\nint main(){\n\tcin>>str;\n\tfor(int i=0;i<str.size();i++) if(str[i]=='.') dots.push_back(i);\n\tdfs(0);\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n\nconst int MAX = 1023;\nconst int MIN = 0;\nchar ch[] = {\n  '0', '1', '+', '-', '*', '(', ')',\n};\nsize_t cur;\nstring str;\n\nint E(int &op_cnt);\n\nint number(){\n  int res = 0;\n  while(cur < str.size() && isdigit(str[cur])){\n    res = res * 2 + str[cur++] - '0';\n    if(res > MAX) return -1;\n  }\n  return res;\n}\n\nint T(){\n  int res;\n  if(isdigit(str[cur])){\n    res = number();\n  }else if(str[cur] == '('){\n    int cnt = 0;\n    cur++;\n    res = E(cnt);\n    if(cur == str.size() || str[cur] != ')') return -1;\n    cur++;\n    if(cnt == 0) res = -1;\n  }else{\n    res = -1;\n    cur++;\n  }\n  return res;\n}\n\nint F(int &op_cnt){\n  int res = 1;\n  vector<int> v;\n  \n  v.push_back(T());\n  \n  while(cur < str.size() && str[cur] == '*'){\n    cur++;\n    op_cnt++;\n    if(cur == str.size()) return -1;\n    int tmp = T();\n    if(tmp < 0) return -1;\n    v.push_back(tmp);\n  }\n  \n  rep(i, v.size()){\n    res *= v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  return res;\n}\n\nint E(int &op_cnt){\n  int res = 0, tmp;\n  vector<int> v;\n  tmp = F(op_cnt);\n  \n  if(tmp < 0) return -1;\n  else v.push_back(tmp);\n  \n  while(cur < str.size() && (str[cur] == '+' || str[cur] == '-')){\n    char op = str[cur];\n    op_cnt++;\n    cur++;\n    if(cur == str.size()) return -1;\n    tmp = F(op_cnt);\n    if(tmp < 0) return -1;\n    else v.push_back(op == '+' ? tmp : -tmp);\n  }\n  \n  cout << str << \" \" << cur << \" \" << op_cnt << endl;\n  if(cur < str.size() && str[cur] != ')') return -1;\n  \n  rep(i, v.size()){\n    res += v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  cout << res << endl;\n  return res;\n}\n\nint calc(string s){\n  int cnt = 0;\n  str = s;\n  cur = 0;\n  int res = E(cnt);\n  //cout << res << endl;\n  return res;\n  \n}\n\nint dfs(string s, int c){\n  if(c == 0){\n    return calc(s);\n  }\n  \n  int res = -1;\n  int pos = 0;\n  while(s[pos] != '.') pos++;\n  \n  rep(i, 7){\n    s[pos] = ch[i];\n    res = max(res, dfs(s, c - 1));\n    s[pos] = '.';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  int c = count(s.begin(), s.end(), '.');\n  cout << dfs(s, c) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nclass SyntaxAnalysis\n{\npublic:\n    using T = pair<bool, int>;\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '*';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '(';\n    static T plus(const T& n, const T& k) { return {n.first and k.first and prop(n.second + k.second), n.second + k.second}; }\n    static T minus(const T& n, const T& k) { return {n.first and k.first and prop(n.second - k.second), n.second - k.second}; }\n    static T product(const T& n, const T& k) { return {n.first and k.first and prop(n.second * k.second), n.second * k.second}; }\n    static T divide(const T& n, const T& k) { return n; }\n    static T brace(const T& n) { return n; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '1'; }\n    static int encode(const char c) { return c - '0'; }\n    static bool prop(const int l) { return l >= 0 and l < 1 << 10; }\n    T number()\n    {\n        int ans = 0, start = S.size();\n        for (; pos < S.size() and is_digit(S[pos]); pos++) {\n            if (S[pos] == '1') { start = min(start, pos); }\n            ans = ans * 2 + encode(S[pos]);\n        }\n        return {pos - start <= 10, ans};\n    }\n    T factor()\n    {\n        if (S[pos] == BRACE) {\n            T ans;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    T term()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, f = factor(), ans = product(ans, f);\n            } else if (S[pos] == DIVIDE) {\n                pos++, f = factor(), ans = divide(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    T expression()\n    {\n        T ans = factor();\n        for (T f; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = factor(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = factor(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\ntemplate <typename S, typename T>\ninline ostream& operator<<(ostream& os, const pair<S, T>& p) { return (os << \"<\" << p.first << \",\" << p.second << \">\"); }\n\nint main()\n{\n    constexpr char C[7] = {'0', '1', '+', '-', '*', '(', ')'};\n    string s;\n    cin >> s;\n    vector<int> p;\n    int NUM = 1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '.') { p.push_back(i), NUM *= 7; }\n    }\n    const int sz = p.size();\n    int ans = -1;\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0, num = i; j < sz; j++, num /= 7) { s[p[j]] = C[num % 7]; }\n        stack<int> st;\n        bool ok = true, num = false;\n        for (const char c : s) {\n            if (c == '(') {\n                if (num) {\n                    ok = false;\n                    break;\n                }\n                st.push(0);\n            } else if (c == ')') {\n                if (st.empty() or st.top() == 0) {\n                    ok = false;\n                    break;\n                }\n                num = true;\n                st.pop();\n            } else if (c == '+' or c == '-' or c == '*') {\n                if (not num) {\n                    ok = false;\n                    break;\n                }\n                num = false;\n                const int n = st.top() + 1;\n                st.pop(), st.push(n);\n            } else {\n                num = true;\n            }\n        }\n        if (not ok) { continue; }\n        const auto sub = SyntaxAnalysis{s}.Expression();\n        // show(sub);\n        if (sub.first) { ans = max(ans, sub.second); }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\nbool ppppp=0;\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n        }else{\n            res -= term(++pos);\n            if(res<0){\n                ppppp = 1;\n            }\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('をとばす\n    int res = expr(pos);\n    pos++;  //')'をとばす\n    return res;\n}\n\nint number(int& pos){\n    int ans = 0;\n    while(isdigit(s[pos])){\n        ans *=2;\n        ans += (s[pos]-'0');\n        pos++;\n    }\n    return ans;\n}\nchar ch[]={'0','1','+','-','*','(',')'};\n\n\nint ans = -1;\n\nbool check(int a,int b,bool c){\n    if(s[a]=='-'||s[a]=='+'||s[a]=='*'||s[b]=='-'||s[b]=='+'||s[b]=='*'){\n        return 0;\n    }\n    if(s[a]=='0'||s[a]=='1'){\n        for(int i=a;i<=b;i++){\n            if(s[i]!='0'&&s[i]!='1'){\n                if(s[i]=='('||s[i]==')'){\n                    return 0;\n                }else{\n                    return check(i+1,b,0);\n                }\n            }\n        }\n        if(c==0)return 1;\n        return 0;\n    }\n    int tmp =-1;\n    int tmp2 = -1;\n    int dep = 0;\n    bool flag = 0;\n    bool ok = 0;\n    for(int i=a;i<=b;i++){\n        if(s[i]==')'&&tmp==-1){\n            flag = 1;\n            break;\n        }else if(s[i]=='('&&tmp==-1){\n            tmp = i;\n            dep++;\n        }else if(s[i]=='('){\n            dep++;\n        }else if(s[i]==')'){\n            dep--;\n            if(dep==0){\n                tmp2 = i;\n                break;\n            }\n        }\n    }\n    if(flag){\n        return 0;\n    }\n    if(tmp2==b){\n        if(c==1)return 0;\n        return check(a+1,b-1,1);\n    }else{\n        if(s[tmp2+1]=='+'||s[tmp2+1]=='-'||s[tmp2+1]=='*'){\n            return check(a+1,tmp2-1,1)&check(tmp2+2,b,0);\n        }\n    }\n   \n}\n\nvoid dfs(vector<int> &v,int k){\n    if(k==v.size()){\n        if(!check(0,(int)s.size()-1,0)){\n            return;\n        }else{\n            int pos = 0;\n            int xxx = expr(pos);\n            if(ppppp){\n                xxx = -1;\n                ppppp = 0;\n            }\n            ans = max(ans,xxx);\n        }\n    }else{\n        for(int i=0;i<7;i++){\n            s[v[k]] = ch[i];\n            dfs(v,k+1);\n        }\n    }\n}\n\n\nint main(){\n    cin >> s;\n    vector<int> v;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='.')v.push_back(i);\n    }\n    if(v.size()==0){\n        int pos = 0;\n        if(check(0,(int)s.size()-1,0)){\n        pos = 0;\n        cout << expr(pos) << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }else{\n        dfs(v,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\n\nconst string OP = \"01+-*()\";\n\nint expression(const string& s, unsigned int& p);\n\nbool valid(const int n)\n{\n  if (n < 0 || 1024 <= n)\n    return false;\n  return true;\n}\n\nint number(const string& s, unsigned int& p)\n{\n  int ret = 0;\n  while (s[p] == '0' || s[p] == '1') {\n    ret *= 2;\n    ret += (s[p] - '0');\n    ++p;\n  }\n  return ret;\n}\n\nint factor(const string& s, unsigned int& p)\n{\n  if (s[p] == '(') {\n    ++p;\n    int ret = expression(s, p);\n    if (!valid(ret) || s[p] != ')')\n      return -1;\n    ++p;\n    return ret;\n  } else if (s[p] == '0' || s[p] == '1') {\n    return number(s, p);\n  } else {\n    return -1;\n  }\n}\n\nint term(const string& s, unsigned int& p)\n{\n  int lhs = factor(s, p);\n  if (!valid(lhs))\n    return -1;\n\n  while (p < s.size()) {\n    if (s[p] == '*') {\n      ++p;\n      int rhs = factor(s, p);\n      if (!valid(rhs) || !valid(lhs*rhs))\n        return -1;\n      lhs *= rhs;\n    } else {\n      break;\n    }\n  }\n  return lhs;\n}\n\nint expression(const string& s, unsigned int& p)\n{\n  int lhs = term(s, p);\n  if (!valid(lhs))\n    return -1;\n\n  while (p < s.size()) {\n    if (s[p] == '+') {\n      ++p;\n      int rhs = term(s, p);\n      if (!valid(rhs) || !valid(lhs+rhs))\n        return -1;\n      lhs += rhs;\n    } else if (s[p] == '-') {\n      ++p;\n      int rhs = term(s, p);\n      if (!valid(rhs) || !valid(lhs-rhs))\n        return -1;\n      lhs -= rhs;\n    } else {\n      break;\n    }\n  }\n  return lhs;\n}\n\nbool check(const string& s)\n{\n  int par = 0;\n  char prev = '\\0';\n  deque<bool> op(100, false);\n\n  for (unsigned int i = 0; i < s.size(); ++i) {\n    if (prev == '\\0') {\n      if (s[i] == '(') {\n        ++par;\n        prev = s[i];\n      } else if (s[i] == '0' || s[i] == '1') {\n        prev = s[i];\n      } else {\n        return false;\n      }\n    } else if (prev == '(') {\n      if (s[i] == '0' || s[i] == '1') {\n        prev = s[i];\n      } else if (s[i] == '(') {\n        ++par;\n        prev = s[i];\n      } else {\n        return false;\n      }\n    } else if (prev == '0' || prev == '1') {\n      if (s[i] == '(')\n        return false;\n\n      if (s[i] == ')') {\n        if (par < 0 || !op[par])\n          return false;\n        op[par] = false;\n        --par;\n      }\n      prev = s[i];\n    } else if (prev == '+' || prev == '-' || prev == '*') {\n      if (par > 0)\n        op[par] = true;\n      if (s[i] == '0' || s[i] == '1') {\n        prev = s[i];\n      } else if (s[i] == '(') {\n        ++par;\n        prev = s[i];\n      } else {\n        return false;\n      }\n    } else if (prev == ')') {\n      if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n        prev = s[i];\n      } else if (s[i] == ')') {\n        if (par < 0 || !op[par])\n          return false;\n        op[par] = false;\n        --par;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  if (par == 0)\n    return true;\n  return false;\n}\n\nint solve(unsigned int idx, string& s)\n{\n  if (idx >= s.size()) {\n    if (!check(s))\n      return -1;\n    idx = 0;\n    return expression(s, idx);\n  }\n\n  if (s[idx] == '.') {\n    int ret = -INF;\n    for (unsigned int i = 0; i < OP.size(); ++i) {\n      s[idx] = OP[i];\n      ret = max(ret, solve(idx+1, s));\n      s[idx] = '.';\n    }\n    return ret;\n  } else {\n    return solve(idx+1, s);\n  }\n}\n\nint main()\n{\n  string s;\n  while (cin >> s)\n    cout << solve(0, s) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\nbool isd(string s){return isdigit(s[0]);}\n\nstring calc(vs s){\n    stack<int> p;\n    for(int i=0;i<s.size();i++){\n        if(s[i]==\"(\")p.push(i);\n        else if(s[i]==\")\"){\n            int f=p.top(); p.pop();\n            vs tmp;\n            s[f]=s[i]=\"-1\";\n            for(int j=f+1;j<i;j++){\n                tmp.pb(s[j]);\n                s[j]=\"-1\";\n            }\n            s[f]=calc(tmp);\n            if(s[f]==\"-1\") return \"-1\";\n            //cout<<\"ans\"<<s[f]<<endl;\n        }\n    }\n    //for(auto c:s)cout<<setw(3)<<c;cout<<endl;\n    auto itr=remove(all(s),\"-1\");\n    s.erase(itr,s.end());\n    if(s.size()==0)return \"-1\";\n    //for(auto c:s)cout<<c<<\"      \";\n    \n    deque<int> oper;\n    deque<string> opec;\n    for(int i=0;i<s.size();i++){\n        if(isd(s[i])){\n            oper.pb(stoi(s[i]));\n        }else{\n            if(s[i]==\"*\"){\n                oper.back()*=stoi(s[++i]);\n                if(oper.back()<0 || oper.back()>1023) return \"-1\";\n            }else opec.pb(s[i]);\n        }\n    }\n    while(!opec.empty()){\n        int d=oper[0];\n        string c=opec[0];\n        oper.pop_front();\n        opec.pop_front();\n        oper.front()=(c==\"+\" ? d+oper.front() : d-oper.front());\n        if(oper.front()<0 || oper.front()>1023) return \"-1\";\n    }\n    return to_string(oper[0]);\n}\n\n\nstring solve(string in){\n    vector<string> s;\n    bool ren=false;\n    for(auto c:in){\n        if(c=='0' || c=='1'){\n            if(ren){\n                s.back()+=c;\n            }else s.pb(\"\"s+c);\n            ren=true;\n        } else {\n            s.pb(\"\"s+c);\n            ren=false;\n        }\n    }\n\n    int dep=0;\n    for(int i=0;i<s.size();i++){\n        string &c=s[i];\n        if(c.length()>30){\n            return \"-1\";\n        }else{\n            try{\n                int p=stoi(c,nullptr,2);\n                c=to_string(p);\n            }catch(...){\n                if(c==\"(\")dep++;\n                else if(c==\")\")dep--;\n                if(dep<0 || dep>25)return \"-1\";\n            }\n        }\n    }\n    if(dep)return \"-1\";\n\n    //for(auto c:s)cout<<c;cout<<endl;\n    int exist=0,depth=0;\n    for(int i=0;i<s.size()-1;i++){\n        if(isd(s[i])){\n            if(s[i+1]==\"(\" || isd(s[i+1])) return \"-1\";\n        }else if(s[i]==\"(\"){\n            depth++;\n            if(s[i+1]==\"+\" || s[i+1]==\"-\" || s[i+1]==\"*\" || s[i+1]==\")\") return \"-1\";\n        }else if(s[i]==\")\"){\n            //cout<<depth<<\",\"<<exist<<endl;\n            if((exist&(1<<depth))==0) return \"-1\";\n            //cout<<\"OK\"<<endl;\n            exist&=~(1<<depth);\n            depth--;\n            if(isd(s[i+1]) || s[i+1]==\"(\") return \"-1\";\n        }else{\n            exist|=(1<<depth);\n            if(s[i+1]!=\"(\" && !isd(s[i+1])) return \"-1\";\n        }\n    }\n\n    if(s.back()==\")\"){\n        if((exist&(1<<depth))==0) return \"-1\";\n    }\n    int t=s.size()-1;\n    if(s[0]==\")\" || s[0]==\"+\" || s[0]==\"-\" || s[0]==\"*\") return \"-1\";\n    if(s[t]==\"(\" || s[t]==\"+\" || s[t]==\"-\" || s[t]==\"*\") return \"-1\";\n\n    //ここまでで除去ができているはず\n    //for(auto c:s)cout<<c;cout<<endl;\n    string ans=calc(s);\n    //cout<<\"=\"<<ans<<endl;\n    return ans;\n}\n\nint bur(string s){\n    int ans=-1;\n    if(count(all(s),'.')==0) {\n        return stoi(solve(s));\n    }\n    for(auto d:\"01+-*()\"s){\n        string os=s;\n        os[s.find('.')]=d;\n        ans=max(ans,bur(os));\n    }\n    return ans;\n}\n\nint main(){\n    string o;\n    cin>>o;\n    cout<<bur(o)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nstring st;\nint a = 0;\nvoid check(const int num) {\n\tif (num < 0 || num >= 1024)throw(false);\n}\nint getnum() {\n\tint num = 0;\n\twhile (isdigit(st[a])) {\n\t\tnum = num * 2 + st[a] - '0';\n\t\ta++;\n\t}\n\tcheck(num);\n\treturn num;\n}\nint getexpr(const int isstart);\nint getkakko();\nint getka() {\n\tif (st[a] == '(') {\n\t\tint num=getkakko();\n\t\treturn num;\n\t}\n\telse if(isdigit(st[a])){\n\t\treturn getnum();\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\npair<int,int> getso() {\n\tint num = getka();\n\tbool fst = false;\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == ')'||st[a]=='+'||st[a]=='-') {\n\t\t\treturn make_pair(fst,num);\n\t\t}\n\t\telse if (st[a] == '*') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getka();\n\t\t\tnum *= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\npair<int, int> getexpr() {\n\tauto p(getso());\n\tbool fst = p.first;\n\tint num = p.second;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\treturn make_pair(fst,num);\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t}\n}\nint getkakko() {\n\tif (st[a] == '(') {\n\t\ta++;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n\tauto p(getso());\n\tint num = p.second;\n\n\tint fst = p.first;\n\twhile (1) {\n\t\tif (a == st.size()) {\n\t\t\tthrow(false);\n\t\t}else if( st[a] == ')') {\n\t\t\tif (!fst) throw(false);\n\t\t\telse break;\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum += n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\tfst = true;\n\t\t\ta++;\n\t\t\tint n_num = getso().second;\n\t\t\tnum -= n_num;\n\t\t\tcheck(num);\n\t\t}\n\t\telse {\n\t\t\tthrow(false);\n\t\t}\n\t\tfst = false;\n\t}\n\tif (st[a] == ')') {\n\t\ta++;\n\t\treturn num;\n\t}\n\telse {\n\t\tthrow(false);\n\t}\n}\nint main() {\n\tstring base; cin >> base;\n\tst = base;\n\tstring aa = \"01+-*()\";\n\tvector<int>unknowns;\n\tfor (int i = 0; i < base.size(); ++i) {\n\t\tif (base[i] == '.') {\n\t\t\tunknowns.emplace_back(i);\n\t\t}\n\t}\n\tint ans = -1;\n\tfor (int i = 0; i < powint(7, unknowns.size()); ++i) {\n\t\tint num(i);\n\t\ta = 0;\n\t\tfor (int j = 0; j < unknowns.size(); ++j) {\n\t\t\tst[unknowns[j]] = aa[num % 7];\n\t\t\tnum /= 7;\n\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tint num = getexpr().second;\n\t\t\tans=max(ans,num);\n\t\t}\n\t\tcatch (...) {\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nstring s;\nint i;\n\nstruct result{\n\tint value, useope;\n};\n\nresult expr();\n\nint num_ok(int x){\n\treturn 0 <= x && x < (1 << 10);\n}\n\nresult num(){\n\tif (s[i] != '0' && s[i] != '1') throw \"num\";\n\tresult res = { 0, 0 };\n\twhile (s[i] == '0' || s[i] == '1'){\n\t\tres.value = res.value * 2 + s[i] - '0';\n\t\t++i;\n\t}\n\tif (!num_ok(res.value)) throw \"num_overflow\";\n\treturn res;\n}\n\n// (expr) || num\nresult term(){\n\tresult res = { -1, 0 };\n\tif (s[i] == '('){\n\t\t++i;\n\t\tres = expr();\n\t\tif (!res.useope) throw \"term\";\n\t\tif (s[i] != ')') throw \"term\";\n\t\t++i;\n\t}\n\telse if (s[i] == '0' || s[i] == '1'){\n\t\tres = num();\n\t}\n\telse{\n\t\tthrow \"term\";\n\t}\n\tres.useope = false;\n\treturn res;\n}\n\n// term | term * factor\nresult factor(){\n\tresult res = term();\n\twhile (s[i] == '*'){\n\t\ti++;\n\t\tres.value *= term().value;\n\t\tres.useope = true;\n\t\tif (!num_ok(res.value)) throw \"num_overflow\";\n\t}\n\treturn res;\n}\n\n// factor + expr\nresult expr(){\n\tresult res = factor();\n\twhile (s[i] == '+' || s[i] == '-'){\n\t\tif(s[i] == '+'){\n\t\t\ti++;\n\t\t\tres.value += factor().value;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tres.value -= factor().value;\n\t\t}\n\t\tres.useope = 1;\n\t\tif (!num_ok(res.value)) throw \"expr_overflow\";\n\t}\n\tif (s[i] != '$' && s[i] != ')') throw \"expr\";\n\treturn res;\n}\n\nint parse(){\n\ti = 0;\n\tint res = expr().value;\n\tif (s[i] != '$') throw \"parse\";\n\treturn res;\n}\n\nint n;\nint pos[10];\n\nint dfs(int i){\n\tif (i == n){\n\t\tint res = 0;\n\t\ttry{\n\t\t\tres = parse();\n\t\t}\n\t\tcatch ( ... ){\n\t\t\tres = -1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint res = -1;\n\trep(j, 7){\n\t\ts[pos[i]] = \"01+-*()\"[j];\n\t\tres = max(res, dfs(i + 1));\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\n\twhile (cin >> s){\n\t\tn = 0;\n\t\ts += \"$$$\";\n\t\trep(i, s.size()) if (s[i] == '.') pos[n++] = i;\n\n\t\tcout << dfs(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 110;\n\nint N;\nstring s;\n\nbool is_num(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (!isdigit(s[i])) return 0;\n    }\n    return 1;\n}\n\nint num(int L, int R)\n{\n    int res = 0;\n    for (int i = R; i >= L; i--) {\n        if (R - L > 10 && s[i] == '1') {\n            return -1;\n        }\n        res += (s[i] - '0') * pow(2, R - i);\n    }\n    return res;\n}\n\nbool is_op(char c)\n{\n    return (c == '+' || c == '-' || c == '*');\n}\n\nbool check_op(int L, int R)\n{\n    for (int i = L; i <= R; i++) {\n        if (is_op(s[i])) return 1;\n    }\n    return 0;\n}\n\nint mem[MAX][MAX];\n\nint expr(int L, int R)\n{\n    int& res = mem[L][R];\n    if (res != -1) return res;\n\n    if (is_num(L, R)) return num(L, R);\n    \n    for (int i = L + 1; i <= R - 1; i++) {\n        if (!is_op(s[i])) continue;\n        \n        int l = expr(L, i - 1), r = expr(i + 1, R);\n        int v = -1;\n\n        if (l == -1 || r == -1) continue;\n        \n        switch (s[i]) {            \n            case '+':\n                v = l + r;\n                break;\n            case '-':\n                v = l - r;\n                break;\n            case '*':\n                v = l * r;\n                break;                \n        }\n        \n        if (v < 0 || v >= (1 << 10)) continue;\n        \n        res = max(res, v);\n    }\n\n        \n    if (s[L] == '(' && s[R] == ')') {\n        res = max(res, expr(L + 1, R - 1));\n    }\n\n    return res;\n}\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid()\n{\n    int p = 0;\n    for (int i = 0; i < N; i++) {\n        if (is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n        for (int j = i + 1; j < N; j++) {\n            if (s[i] == '(' && s[j] == ')') {\n                if (!check_op(i, j)) {\n                    return 0;\n                }\n            }\n        }\n    }\n    return (p == 0);\n}\n\nint solve()\n{\n    N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        memset(mem, -1, sizeof(mem));\n        return expr(0, N - 1);\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid()) {\n            memset(mem, -1, sizeof(mem));\n            res = max(res, expr(0, N - 1));\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    cin >> s;\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst string temp = \"01+-*()\";\nint f1(int&, bool&);\nint f2(int&, bool&);\nint f3(int&, bool&);\n\nvector< int > undefined;\nstring S;\n\nbool isout(int val)\n{\n  return(val < 0 || val >= 1024);\n}\nint f1(int& idx, bool& f)\n{\n  int val = f2(idx, f);\n\n  while(S[idx] == '+' || S[idx] == '-') {\n    if(S[idx] == '+') {\n      ++idx;\n      val += f2(idx, f);\n    } else {\n      ++idx;\n      val -= f2(idx, f);\n    }\n    if(isout(val)) throw(1);\n    f = true;\n  }\n  return (val);\n}\n\nint f2(int& idx, bool& f)\n{\n  int val = f3(idx, f);\n\n  while(S[idx] == '*') {\n    idx++;\n    val *= f3(idx, f);\n    if(isout(val)) throw(1);\n    f = true;\n  }\n  return (val);\n}\n\nint f3(int& idx, bool& f)\n{\n  int val = 0;\n  if(S[idx] == '(') {\n    ++idx;\n    int now = idx;\n    bool flag = false;\n    val = f1(idx, flag);\n    if(!flag) throw(1);\n    ++idx;\n    return (val);\n  } else if(isdigit(S[idx])) {\n    while(isdigit(S[idx])) {\n      val = val * 2 + S[idx] - '0';\n      ++idx;\n      if(isout(val)) throw(1);\n    }\n  } else {\n    throw (1);\n  }\n  return (val);\n}\n\nint make(int idx)\n{\n  int ret = -1;\n  if(idx == undefined.size()) {\n    try {\n      int pos = 0;\n      bool f = false;\n      int val = f1(pos, f);\n      if(pos + 1 != S.size()) throw (1);\n      ret = max(ret, val);\n    } catch(int e) {}\n  } else {\n    for(char c : temp) {\n      S[undefined[idx]] = c;\n      ret = max(ret, make(idx + 1));\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> S;\n  S += \"~\";\n  for(int i = 0; i < S.size(); i++) {\n    if(S[i] == '.') undefined.push_back(i);\n  }\n  cout << make(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 9999999\n\n\nvector<string> toRPN(string s){\n    stack<string> ope;\n    vector<string> ret;\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ){\n            string tmp=\"\";\n            for(int j=i;j<len;j++){\n                if( isdigit(s[j]) )tmp+=s[j];\n                else break;\n            }\n            ret.push_back(tmp);\n            i+=tmp.size()-1;\n            \n        }else{\n            if( s[i]=='(' ){\n                if( i-1>=0 && isdigit(s[i-1]) )return {\"invalid\"};\n                else ope.push(\"(\");\n            }\n            \n            else if( s[i]==')' ){\n                if( i+1<s.size() && isdigit(s[i+1]) )return {\"invalid\"};\n                if( ope.empty() )return {\"invalid\"};\n                if( ope.top()==\"(\" )return {\"invalid\"};\n                \n                while( ope.top()!=\"(\" ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                    \n                    if( ope.empty() )return {\"invalid\"};\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" || ope.top()==\"+\" || ope.top()==\"-\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n            }\n        }\n    }\n    while( ope.size() ){\n        if(ope.top()==\"(\")return {\"invalid\"};\n        ret.push_back( ope.top() );\n        ope.pop();\n    }\n    \n    return ret;\n}\n\n\nint toDeci(string s){\n    int ret=0;\n    for(int i=0;i<s.size();i++){\n        if( s[ s.size()-i-1 ]=='1' ){\n            ret+=1<<i;\n        }\n        if(ret>=1024)return 9999;\n    }\n    return ret;\n}\n\n\n\nint solveRPN(vector<string> s){\n    stack<int> stk;\n    \n    \n    for(int i=0;i<s.size();i++){\n        if( (s[i]!=\"+\" && s[i]!=\"-\" && s[i]!=\"*\" && s[i]!=\"/\") )stk.push( toDeci(s[i])  );\n        else{\n            if(stk.size()<2)return -1;\n\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            if(s[i]==\"+\")stk.push(a+b);\n            if(s[i]==\"-\")stk.push(a-b);\n            if(s[i]==\"*\")stk.push(a*b);\n            if(s[i]==\"/\")stk.push(a/b);\n        }\n        if( stk.top() <0 || 1024<=stk.top() )return -1;\n    }\n    \n    if( stk.size()>1 )return -1;\n    return stk.top();\n}\n\n\nvi dot;\nint maxi=-INF;\n\n\nint solve(string s){\n    vector<string> poland=toRPN(s);\n    \n    if(poland[0]==\"invalid\")return -INF;\n    \n    int result=solveRPN(poland);\n    \n    if(result==-1)return -INF;\n    else return result;\n}\n\n\nvoid dfs(string s,int flor){\n    if(flor>=dot.size()){\n        maxi=max( maxi , solve(s) );\n        return ;\n    }\n    \n    char ch[]={'0','1','+','-','*','(',')'};\n    rep(i,7){\n        s[ dot[flor] ] = ch[i];\n        dfs(s,flor+1);\n        s[ dot[flor] ] = '.';\n    }\n}\n\n\nint main(){\n    string s;\n    cin>>s;\n    \n    rep(i,s.size()) if(s[i]=='.')dot.pb(i);\n    \n    dfs(s,0);\n    \n    if( maxi==-INF )cout<<\"-1\"<<endl;\n    else cout<<maxi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool onlynum;\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tonlynum = false;\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tonlynum = false;\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tonlynum = true;\n\tint ret = expr(s, num);\n\tif (onlynum)return -1;\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num]))n = n * 2 + s[num++] - '0';\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tonlynum=false;\n\t\tint ans = expr(s, num);\n\t\tif (s.length()==num)\n\t\tma = max(ma,ans );\n\t\tcout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nclass ParseError {};\nstruct Result{\n  int value, p, ex;\n  Result(int v, int p) : value(v), p(p), ex(0) {}\n};\nvoid skip(const string& s, Result& r, char expected){\n  if(!(0 <= r.p && r.p < s.size())){\n    throw ParseError();\n  }else if(s[r.p] != expected){\n    throw ParseError();\n  }else {\n    r.p ++;\n  }\n}\nvoid checkvalue(int x){\n  if(x < 0 || x >= 1<<10) throw ParseError();\n}\nResult equation(const string& s, int p);\nResult equation_in(const string& s, int p);\nResult factor(const string& s, int p);\nResult term(const string& s, int p);\nResult equation(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (s[r.p] == '+' || s[r.p] == '-')){\n    Result r2 = factor(s, r.p + 1);\n    if(s[r.p] == '+'){\n      r.value += r2.value;\n    }else if(s[r.p] == '-'){\n      r.value -= r2.value;\n    }\n    r.p = r2.p;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult equation_in(const string& s, int p){\n  Result r = factor(s, p);\n  while(r.p < s.size() && (s[r.p] == '+' || s[r.p] == '-')){\n    Result r2 = factor(s, r.p + 1);\n    if(s[r.p] == '+'){\n      r.value += r2.value;\n    }else if(s[r.p] == '-'){\n      r.value -= r2.value;\n    }\n    r.p = r2.p;\n    r.ex = 1;\n    checkvalue(r.value);\n  }\n  if(r.ex == 0) throw ParseError();\n  return r;\n}\nResult factor(const string& s, int p){\n  Result r = term(s, p);\n  r.ex = 0;\n  while(r.p < s.size() && s[r.p] == '*'){\n    Result r2 = term(s, r.p + 1);\n    r.value *= r2.value;\n    r.p = r2.p;\n    r.ex = 1;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  if(s[p] == '('){\n    Result r = equation_in(s, p + 1);\n    skip(s, r, ')');\n    checkvalue(r.value);\n    return r;\n  }else if(isdigit(s[p])){\n    int value = 0;\n    while(isdigit(s[p]) && p < s.size()){\n      value = (value << 1) + (s[p++] - '0');\n    }\n    checkvalue(value);\n    return Result(value, p);\n  }else {\n    throw ParseError();\n  }\n}\nstring SYMBOLS = \"01+-*()\";\nint dfs(int k, vector<int>& index, string& s){\n  if(k == index.size()){\n    try{\n      Result r = equation(s, 0);\n      if(r.p != s.size()) throw ParseError();\n      //cout<<s<<\" is \"<<r.value<<endl;\n      return r.value;\n    }catch(...){\n      //cout<<s<<\" is invalid.\"<<endl;\n      return -1;\n    }\n  }else{\n    int res = -INF;\n    REP(i, SYMBOLS.size()){\n      s[index[k]] = SYMBOLS[i];\n      res = max(res, dfs(k + 1, index, s));\n    }\n    return res;\n  }\n}\n\nint main(){\n  string s;\n  while(cin>>s){\n    vector<int> index;\n    REP(i, s.size()) if(s[i] == '.') index.push_back(i);\n    int ans = dfs(0, index, s);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1<<10)\nusing namespace std;\n\nstring s;\nvector<int> idx;\nvector<char> c;\nchar lis[7]={'0','1','+','-','*','(',')'};\nint ans=-1, p, flag;\n\nbool check(){\n\n  int r=0, f=0;\n\n  for(int i=p;i<s.size();i++){\n    if(r==1&&(s[i]=='+'||s[i]=='-'||s[i]=='*')) f=1;\n    if(s[i]=='(') r++;\n    if(s[i]==')') r--;\n    if(r==0) break;\n  }\n  \n  return f==1;\n}\n\nint bnf();\n\nint bnf3(){\n\n  int res=0;\n  \n  if(s[p]=='('){\n    \n    bool r=check();\n    \n    p++;\n    res=bnf();\n    p++;\n   \n    if(!r) flag=1;\n    \n    return res;\n  }\n\n  if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1'){\n    res=res*2+s[p]-'0', p++;\n    if(res>=INF) flag=1;\n  }\n\n  return res;\n}\n\nint bnf2(){\n  \n  int res=bnf3();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='*'){\n      p++;\n      res=res*bnf3();\n      if(res>=INF) res=INF;\n    }else{\n      if(p<s.size()&&s[p]!=')'&&s[p]!='+'&&s[p]!='-') flag=1;\n      break;\n    }\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n      p++;\n      res=res+bnf2();\n      if(res>=INF) res=INF;\n    }\n    else if(s[p]=='-'){\n      p++;\n      res=res-bnf2();\n    }else{\n      if(p<s.size()&&s[p]!=')') flag=1;\n      break;\n    }\n  }\n  \n  return res;\n}\n\nbool check2(){\n  \n  int r=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') r++;\n    if(s[i]==')'){\n      if(!r) return false;\n      r--;\n    }\n  }\n\n  if(r) return false;\n\n  return true;\n}\n\nvoid dfs(int x){\n  \n  if(x==idx.size()){\n    \n    for(int i=0;i<idx.size();i++)\n      s[idx[i]]=c[i];\n    \n    p=0, flag=0;\n    \n    if(!check2()) return ;\n    \n    int r=bnf();\n    \n    if(r>=INF||flag) return ;\n\n    ans=max(ans,r);\n    \n    return ;\n  }\n  \n  for(int i=0;i<7;i++){\n    \n    c[x]=lis[i];\n    \n    dfs(x+1);\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>s;\n  \n  for(int i=0;i<s.size();i++)\n    if(s[i]=='.') idx.push_back(i);\n\n  c.resize(idx.size());\n\n  dfs(0);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstring s;\n\nint parse(int &p, bool& op, int d=1);\n \nint num(int &p){\n\tint res = 0;\n\tif(p>=s.size()) throw 0;\n\tif(s[p] == '('){\n\t\tbool op=false;\n\t\tres = parse(++p, op);\n\t\tif(!op || p>=s.size() || s[p++] != ')') throw 0;\n\t}else{\n\t\tif(!isdigit(s[p])) throw 0;\n\t\tfor(;p<s.size()&&isdigit(s[p]);++p) res = res*2+s[p]-'0';\n\t}\n\treturn res;\n}\n \nint parse(int &p, bool& op, int d){\n\tint res = d?parse(p, op, d-1) : num(p);\n\tif(res < 0 || 1024 <= res) throw 0;\n\twhile(p<s.size()){\n\t\tif(d == 0 && s[p] == '*'){\n\t\t\top = 1;\n\t\t\tres *= num(++p);\n\t\t}else if(d == 1 && s[p] == '+'){\n\t\t \top = 1;\n\t\t   res += parse(++p, op, 0);\n\t\t}else if(d == 1 && s[p] == '-'){\n\t\t\top = 1;\n\t\t\tres -= parse(++p, op, 0);\n\t\t}else break;\n\t\tif(res < 0 || 1024 <= res) throw 0;\n\t}\n\treturn res;\n}\n\nint n;\nstring tbl = \"01+-*()\";\nint solve(string t){\n\tREP(i, t.size()){\n\t\tif(t[i] == '.'){\n\t\t\tint ans = -1;\n\t\t\tREP(j, 7){\n\t\t\t\ttry{\n\t\t\t\t\tt[i] = tbl[j];\n\t\t\t\t\tans = max(ans, solve(t));\n\t\t\t\t}catch(...){}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\ts = t;\n\tint p = 0;\n\tbool op;\n\tint res = parse(p, op);\n\tif(p != s.size()) throw 0;\n\treturn res;\n}\nmain(){\n\tstring t;\n\twhile(cin >> t){\n\t\ttry{\n\t\t\tcout << solve(t) << endl;\n\t\t}catch(...){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool is_num(char x){return x=='0' || x=='1';}\n\nbool valid_num(int x){\n  const int SUP=1024;\n  return 0<=x && x<SUP;\n}\n\nint calc(int lhs,int rhs,char op){\n  int res;\n  if(op=='+'){\n    res=lhs+rhs;\n  }else if(op=='-'){\n    res=lhs-rhs;\n  }else if(op=='*'){\n    res=lhs*rhs;\n  }else{\n    throw \"calc\";\n  }\n  if(!valid_num(res)) throw \"invalid\";\n  return res;\n}\n\nint formula(int &p);\nint formulap(int &p);\nint term1(int &p);\npair<int,bool> term1p(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint formula(int &p){\n  int res=term1(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formula\";\n    int rhs=term1(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\nint formulap(int &p){\n  bool isok=false;\n  auto ret=term1p(p);\n  isok|=ret.second;\n  int res=ret.first;\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formulap_op\";\n    isok=true;\n    int rhs=term1p(p).first;\n    res=calc(res,rhs,op);\n  }\n  if(!isok) throw \"formulap_isok\";\n  return res;\n}\n\nint term1(int& p){\n  int res=term2(p);\n  while(p<s.size() && (s[p]!='+' && s[p]!='-')){\n    char op=s[p];\n    p++;\n    if(op!='*') throw \"term1_op\";\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\npair<int,bool> term1p(int &p){\n  int res=term2(p);\n  bool isop=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;    \n    if(op!='*') throw \"term1p\";\n    isop=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,isop};\n}\n\nint term2(int& p){\n  if(s[p]=='('){\n    p++;\n    int res=formulap(p);\n    if(s[p]!=')') throw \"term2\";\n    p++;\n    return res;\n  }else if(is_num(s[p])){\n    int res=get_num(p);\n    return res;\n  }else throw \"term2\";\n}\n\nint get_num(int& p){\n  int res=0;\n  while(p<s.size() && is_num(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nint dfs(int i){\n  if(i==s.size()){\n    int res=-1;\n     try{\n       int p=0;\n       res=formula(p);\n     }catch(const char* &e){\n       return -1;\n     }\n     return res;\n  }\n  else if(s[i]=='.'){\n    const string ch=\"01+-*()\";\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      int ret=dfs(i+1);\n      res=max(ret,res);\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nstring s;\n\nstring op[2] = {\"*\", \"+-\"};\n\nint parse(int& i, int d)\n{\n\tif (d == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tint ret = parse(i, 0);\n\t\t\ti++;\n\t\t\tif (ret < 0) return -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ('0' <= s[i] && s[i] <= '1')\n\t\t{\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '1')\n\t\t\t{\n\t\t\t\tret = ret * 2 + s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ret = parse(i, d + 1);\n\n\t\twhile (op[d].find(s[i]) != string::npos)\n\t\t{\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '+': i++; ret += parse(i, d + 1); break;\n\t\t\tcase '*': i++; ret *= parse(i, d + 1); break;\n\t\t\tcase '-':\n\t\t\t\ti++;\n\t\t\t\tret -= parse(i, d + 1);\n\t\t\t\tif (ret < 0) return -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n}\n\nbool isvalid()\n{\n\tint cnt = 0;\n\tint flag[101010];\n\tflag[0] = 0;\n\trep(j, 0, s.length())\n\t{\n\t\tif (s[j] == '(')\n\t\t{\n\t\t\tcnt++;\n\t\t\tflag[cnt] = 1;\n\t\t}\n\t\telse if (s[j] == ')')\n\t\t{\n\t\t\tif (cnt == 0) return false;\n\t\t\tif (flag[cnt] == 1) return false;\n\t\t\tcnt--;\n\t\t}\n\t\telse if (s[j] == '0' || s[j] == '1')\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag[cnt] = 0;\n\t\t}\n\t}\n\tif (cnt != 0) return false;\n\n\trep(j, 0, s.length() - 1)\n\t{\n\t\tif (s[j] == '+' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '+' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '-' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '*' && s[j + 1] == ')') return false;\n\n\t\tif (s[j] == ')' && s[j + 1] == '(') return false;\n\t\t\n\t}\n\n\tif (s[0] == '+') return false;\n\tif (s[0] == '-') return false;\n\tif (s[0] == '*') return false;\n\n\tif (s[s.length() - 2] == '+') return false;\n\tif (s[s.length() - 2] == '-') return false;\n\tif (s[s.length() - 2] == '*') return false;\n\n\treturn true;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t/*\n\ts = \"(1+1)=\";\n\tif (isvalid())\n\t\tcout << \"valid\" << endl;\n\telse\n\t\tcout << \"invalid\" << endl;\n\n\treturn 0;\n\t*/\n\n\tcin >> s; s += \"=\";\n\n\tvector<int> dots;\n\trep(j, 0, s.length()) if (s[j] == '.') dots.push_back(j);\n\n\tint nums[5];\n\tstring opes = \"01+-*()\";\n\tint ans = -1;\n\trep(j, 0, 100000)\n\t{\n\t\tint jj = j;\n\t\trep(k, 0, 5)\n\t\t{\n\t\t\tnums[k] = jj % 10;\n\t\t\tjj /= 10;\n\t\t}\n\t\tbool ok = false;\n\t\trep(k, 0, dots.size()) if (7 <= nums[k]) ok = true;\n\t\tif (ok) continue;\n\n\t\trep(k, 0, dots.size()) s[dots[k]] = opes[nums[k]];\n\n\t\tif (!isvalid()) continue;\n\n\t\tint i = 0;\n\t\tint ret = parse(i, 0);\n\t\tif (ans < ret)\n\t\t{\n\t\t\tif (1024 <= ret) continue;\n\t\t\tans = ret;\n\t\t\t//cout << s << ret << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(char ch){return ch&&ch!='+'&&ch!='-'&&ch!='*'&&ch!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(s[p]);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(res<0||res>=1024) flg=0;\n    if(s[p]=='*') res*=calc();\n  }\n  if(res<0||res>=1024) flg=0;\n  return res;\n}\n\nint bnf(){\n  flg&=check(s[p]);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(s[p+1]);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n    if(res<0||res>=1024) flg=0;\n  }\n  if(res<0||res>=1024) flg=0;\n  if(!flg)res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint len;\nchar s[101];\n\nint idx;\n\nint number(){\n\tint res=0;\n\twhile(idx<len && (s[idx]=='0' || s[idx]=='1')){\n\t\tres=(res<<1)+(s[idx]-'0');\n\t\tidx++;\n\t}\n\tif(res<0 || 1024<=res) return -1;\n\treturn res;\n}\n\nint expr(){\n\tvector<int> nums;\n\tvector<char> ops;\n\twhile(1){\n\t\tif(s[idx]=='0' || s[idx]=='1'){\n\t\t\tint a=number();\n\t\t\tif(a==-1) return -1;\n\t\t\tnums.push_back(a);\n\t\t}\n\t\telse if(s[idx]=='('){\n\t\t\t// ( ) の中にはネストしてない演算子が必要\n\t\t\tbool ok=false;\n\t\t\tint dep=0;\n\t\t\tfor(int i=idx+1;i<len;i++){\n\t\t\t\tif(dep<0) break;\n\t\t\t\tif     (s[i]=='(') dep++;\n\t\t\t\telse if(s[i]==')') dep--;\n\t\t\t\tif(dep==0){\n\t\t\t\t\tif(s[i]=='+' || s[i]=='-' || s[i]=='*') ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) return -1;\n\n\t\t\tidx++;\n\t\t\tint a=expr();\n\t\t\tif(a==-1 || idx==len || s[idx]!=')') return -1;\n\t\t\tnums.push_back(a);\n\t\t\tidx++;\n\t\t}\n\t\telse return -1;\n\n\t\tif(s[idx]=='+' || s[idx]=='-' || s[idx]=='*') ops.push_back(s[idx++]);\n\t\telse if(idx==len || s[idx]==')') break;\n\t\telse return -1;\n\t}\n\n\t// 掛け算を先にやる\n\twhile(1){\n\t\tint i=find(ops.begin(),ops.end(),'*')-ops.begin();\n\t\tif(i==ops.size()) break;\n\t\tnums[i]*=nums[i+1];\n\t\tnums.erase(nums.begin()+i+1);\n\t\tops.erase(ops.begin()+i);\n\t\tif(nums[i]<0 || 1024<=nums[i]) return -1;\n\t}\n\t// 足し算と引き算をやる\n\tint res=nums[0];\n\trep(i,ops.size()){\n\t\tif     (ops[i]=='+'){ res+=nums[i+1]; if(res<0 || 1024<=res) return -1; }\n\t\telse if(ops[i]=='-'){ res-=nums[i+1]; if(res<0 || 1024<=res) return -1; }\n\t}\n\treturn res;\n}\n\nint gao(int i,const vector<int> &pos){\n\tif(i==pos.size()){\n\t\tidx=0;\n\t\tint a=expr();\n\t\tif(idx<len) a=-1;\n\t\treturn a;\n\t}\n\n\tint res=-1;\n\trep(j,7){\n\t\ts[pos[i]]=\"01+-*()\"[j];\n\t\tres=max(res,gao(i+1,pos));\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%s\",s);\n\tlen=strlen(s);\n\n\tvector<int> pos;\n\trep(i,len) if(s[i]=='.') pos.push_back(i);\n\n\tprintf(\"%d\\n\",gao(0,pos));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' == parse[pos] || parse[pos] == '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring cs=\"01+-*()\";\nstring s;\nint n;\n\nint f(int l,int r){\n  if(r<=l)return -1;\n  bool isn=true;\n  repl(i,l,r)if(!isdigit(s[i]))isn=false;\n  if(isn){\n    int res=0;\n    repl(i,l,r){\n      res*=2;\n      res+=s[i]-'0';\n    }\n    if(res>=pow(2,10))return -1;\n    else return res;\n  }\n\n  bool ok=false;\n  {\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(lev==0)ok=true;\n      if(s[i]==')')lev--;\n    }\n  }\n\n  if(!ok){\n    if(s[r-1]!=')')return -1;\n    int lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1||vl+vr>=pow(2,10))return -1;\n        else return vl+vr;\n      }\n    }\n    lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1||vl*vr>=pow(2,10))return -1;\n        else return vl*vr;\n      }\n    }\n  }else{\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1||vl+vr>=pow(2,10))return -1;\n        else return vl+vr;\n      }\n    }\n    lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1||vl*vr>=pow(2,10))return -1;\n        else return vl*vr;\n      }\n    }\n  }\n  return -1;\n}\n\nint dfs(int i){\n  if(i==n){\n    if(f(0,n)==3)dbg(s);\n    return f(0,n);\n  }else{\n    if(s[i]=='.'){\n      int res=-1;\n      rep(j,7){\n        s[i]=cs[j];\n        int tmp=dfs(i+1);\n        maxch(res,tmp);\n      }\n      s[i]='.';\n      return res;\n    }else{\n      return dfs(i+1);\n    }\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <iostream>\n\nusing namespace std;\n\nint n, cl[5], cnum, num, p;\nchar str[101], cc[] = {\"01+-*\"}, t[501];\n\nint eq(char c1,char c2,char c3,char c4){\n\treturn c1 == c3 && c2 == c4;\n}\n\nint calc(){\n\tint ret = 0, i, c;\n\tchar e = '+';\n\tfor(;p < num;p++){\n\t\tif(t[p] == '('){\n\t\t\tp++;\n\t\t\tc = calc();\n\t\t\tif(e == '+')\n\t\t\t\tret += c;\n\t\t\telse if(e == '-')\n\t\t\t\tret -= c;\n\t\t\telse if(e == '*')\n\t\t\t\tret *= c;\n\t\t}\n\t\telse if(isdigit(t[p])){\n\t\t\tc = 0;\n\t\t\tfor(i = p;isdigit(t[i]);i++) c = (c << 1) + t[i] - '0';\n\t\t\tp = i - 1;\n\t\t\tif(e == '+')\n\t\t\t\tret += c;\n\t\t\telse if(e == '-')\n\t\t\t\tret -= c;\n\t\t\telse if(e == '*')\n\t\t\t\tret *= c;\n\t\t}\n\t\telse if(t[p] == '+' || t[p] == '-' || t[p] == '*')\n\t\t\te = t[p];\n\t\telse if(t[p] == ')'){\n\t\t\tp++;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nvoid priority(void){\n\tint i, j, k, c;\n\tnum = n;\n\tmemcpy(t,str,sizeof(str));\n\tfor(i = 0;i < num;i++){\n\t\tif(str[i] == '*'){\n\t\t\tc = 0;\n\t\t\tfor(j = i - 1;j > 0;j--){\n\t\t\t\tif(str[j] == ')') c++;\n\t\t\t\telse if(str[j] == '(') c--;\n\t\t\t\tif(c == 0 && !isdigit(str[j])) break;\n\t\t\t}\n\t\t\tif(j != 0) j--;\n\t\t\tfor(k = num;k >= j;k--) t[k + 1] = t[k];\n\t\t\tnum++;\n\t\t\tt[j] = '(';\n\t\t\tfor(j = i + 1;j < num;j++){\n\t\t\t\tif(str[j] == '(') c++;\n\t\t\t\telse if(str[j] == ')') c--;\n\t\t\t\tif(c == 0 && !isdigit(str[j])) break;\n\t\t\t}\n\t\t\tj++;\n\t\t\tfor(k = num;k >= j;k--) t[k + 1] = t[k];\n\t\t\tnum++;\n\t\t\tt[j] = ')';\n\t\t}\n\t}\n}\n\t\t\t\t\n\n\nint judge(void){\n\tint i, j, k = 0, c;\n\tchar c1, c2;\n\tfor(i = 0;i < n - 1;i++){\n\t\tc1 = str[i],c2 = str[i + 1];\n\t\tif(eq(c1,c2,'(','+') || eq(c1,c2,'(','-') || eq(c1,c2,'(','*') || eq(c1,c2,'+',')') || eq(c1,c2,'-',')') || eq(c1,c2,'*',')') || eq(c1,c2,'0','(') || eq(c1,c2,'1','(') || eq(c1,c2,')','0') || eq(c1,c2,')','1') || eq(c1,c2,'+','+') || eq(c1,c2,'-','-') || eq(c1,c2,'*','*') || eq(c1,c2,'+','-') || eq(c1,c2,'+','*') || eq(c1,c2,'-','+') || eq(c1,c2,'-','*') || eq(c1,c2,'*','+') || eq(c1,c2,'*','-'))\n\t\t\treturn 0;\n\t}\n\tif(str[0] == '+' || str[0] == '-' || str[0] == '*' || str[n - 1] == '+' || str[n - 1] == '-' || str[n - 1] == '*')\n\t\treturn 0;\n\tfor(i = 0;i < n;i++){\n\t\tif(str[i] == '('){\n\t\t\tfor(j = i;str[j] != ')';j++);\n\t\t\tc = 1;\n\t\t\tfor(k = i + 1;k < j;k++){\n\t\t\t\tif(str[k] == '+' || str[k] == '-' || str[k] == '*'){\n\t\t\t\t\tc = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c) return 0;;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint dfs(int c){\n\tint ret = 0x80000000,i, e;\n\tif(c == cnum){\n\t\tif(judge()){\n\t\t\tpriority();\n\t\t\tp = 0;\n\t\t\tret = max(ret,e = calc());\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(i = 0;i < 5;i++){\n\t\tstr[cl[c]] = cc[i];\n\t\tret = max(ret,dfs(c + 1));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint i = 0,ans;\n\tchar c;\n\twhile((c = getchar()) != '\\n')\n\t\tstr[i++] = c;\n\tstr[i] = '\\0';\n\tn = strlen(str);\n\tcnum = 0;\n\tfor(i = 0;i < n;i++)\n\t\tif(str[i] == '.') cl[cnum++] = i;\n\tans = dfs(0);\n\tprintf(\"%d\\n\",ans!=0x80000000?ans:-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nstring s;\n\nstring op[2] = {\"+-\", \"*\"};\n\nint parse(int& i, int d)\n{\n\tif (d == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tint ret = parse(i, 0);\n\t\t\ti++;\n\t\t\tif (ret < 0) return -1;\n\t\t\tif (1024 <= ret) return -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ('0' <= s[i] && s[i] <= '1')\n\t\t{\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '1')\n\t\t\t{\n\t\t\t\tret = ret * 2 + s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (1024 <= ret) return -1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ret = parse(i, d + 1);\n\t\tif (ret < 0) return -1;\n\n\t\twhile (op[d].find(s[i]) != string::npos)\n\t\t{\n\t\t\tchar c = s[i];\n\n\t\t\ti++;\n\t\t\tint _ret = parse(i, d + 1);\n\t\t\tif (_ret < 0) return -1;\n\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase '+': ret += _ret; break;\n\t\t\tcase '*': ret *= _ret; break;\n\t\t\tcase '-': ret -= _ret; break;\n\t\t\t}\n\n\t\t\tif (1024 <= ret) return -1;\n\t\t\tif (ret < 0) return -1;\n\t\t}\n\n\t\treturn ret;\n\t}\n}\n\nbool isvalid()\n{\n\tint cnt = 0;\n\tint flag[101010];\n\tflag[0] = 0;\n\trep(j, 0, s.length())\n\t{\n\t\tif (s[j] == '(')\n\t\t{\n\t\t\tcnt++;\n\t\t\tflag[cnt] = 1;\n\t\t}\n\t\telse if (s[j] == ')')\n\t\t{\n\t\t\tif (cnt == 0) return false;\n\t\t\tif (flag[cnt] == 1) return false;\n\t\t\tcnt--;\n\t\t}\n\t\telse if (s[j] == '0' || s[j] == '1')\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag[cnt] = 0;\n\t\t}\n\t}\n\tif (cnt != 0) return false;\n\n\trep(j, 0, s.length() - 1)\n\t{\n\t\tif (s[j] == '+' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '+' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '-' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '*' && s[j + 1] == ')') return false;\n\n\t\tif (s[j] == ')' && s[j + 1] == '(') return false;\n\n\t\tif (s[j] == '0' && s[j + 1] == '(') return false;\n\t\tif (s[j] == '1' && s[j + 1] == '(') return false;\n\n\t\tif (s[j] == ')' && s[j + 1] == '0') return false;\n\t\tif (s[j] == ')' && s[j + 1] == '1') return false;\n\t\t\n\t}\n\n\tif (s[0] == '+') return false;\n\tif (s[0] == '-') return false;\n\tif (s[0] == '*') return false;\n\n\tif (s[s.length() - 2] == '+') return false;\n\tif (s[s.length() - 2] == '-') return false;\n\tif (s[s.length() - 2] == '*') return false;\n\n\treturn true;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t/*\n\ts = \"((1+1)+(1+1)+(1+1))=\";\n\tif (isvalid())\n\t\tcout << \"valid\" << endl;\n\telse\n\t\tcout << \"invalid\" << endl;\n\n\tint i = 0;\n\tcout << parse(i, 0) << endl;\n\n\treturn 0;\n\t*/\n\n\tcin >> s; s += \"=\";\n\n\tvector<int> dots;\n\trep(j, 0, s.length()) if (s[j] == '.') dots.push_back(j);\n\n\tint nums[5];\n\tstring opes = \"01+-*()\";\n\tint ans = -1;\n\trep(j, 0, 100000)\n\t{\n\t\tint jj = j;\n\t\trep(k, 0, 5)\n\t\t{\n\t\t\tnums[k] = jj % 10;\n\t\t\tjj /= 10;\n\t\t}\n\t\tbool ok = false;\n\t\trep(k, 0, dots.size()) if (7 <= nums[k]) ok = true;\n\t\tif (ok) continue;\n\n\t\trep(k, 0, dots.size()) s[dots[k]] = opes[nums[k]];\n\n\t\tif (!isvalid()) continue;\n\n\t\tint i = 0;\n\t\tint ret = parse(i, 0);\n\t\tif (ans < ret)\n\t\t{\n\t\t\tans = ret;\n\t\t\t//cout << s << ret << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n\nconst int MAX = 1023;\nconst int MIN = 0;\nchar ch[] = { '0', '1', '+', '-', '*', '(', ')'};\nsize_t cur;\nstring str;\n\nint E(int &op_cnt);\n\nint number(){\n  int res = 0;\n  while(cur < str.size() && isdigit(str[cur])){\n    res = res * 2 + str[cur++] - '0';\n    if(res > MAX) return -1;\n  }\n  return res;\n}\n\nint T(){\n  int res;\n  if(isdigit(str[cur])){\n    res = number();\n  }else if(str[cur] == '('){\n    int cnt = 0;\n    cur++;\n    if(cur == str.size()) return -1;\n    res = E(cnt);\n    if(cur == str.size() || str[cur] != ')' || cnt == 0) res = -1;\n    cur++;\n  }else{\n    res = -1;\n  }\n  return res;\n}\n\nint F(int &op_cnt){\n  int res = 1;\n  vector<int> v;\n  v.push_back(T());\n  \n  while(cur < str.size() && str[cur] == '*'){\n    cur++;\n    op_cnt++;\n    if(cur == str.size()) return -1;\n    int tmp = T();\n    if(tmp < 0) return -1;\n    v.push_back(tmp);\n  }\n  \n  rep(i, v.size()){\n    res *= v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  return res;\n}\n\nint E(int &op_cnt){\n  int res = 0, tmp;\n  vector<int> v;\n  tmp = F(op_cnt);\n  \n  if(tmp < 0) return -1;\n  else v.push_back(tmp);\n  \n  while(cur < str.size() && (str[cur] == '+' || str[cur] == '-')){\n    char op = str[cur];\n    op_cnt++;\n    cur++;\n    if(cur == str.size()) return -1;\n    tmp = F(op_cnt);\n    if(tmp < 0) return -1;\n    else v.push_back(op == '+' ? tmp : -tmp);\n  }\n  if(cur < str.size() && str[cur] != ')') return -1;\n  rep(i, v.size()){\n    res += v[i];\n    if(res < MIN || MAX < res) return -1;\n  }\n  return res;\n}\n\n\nint dfs(string s, int c){\n  int res = -1;\n  int pos = find(s.begin(), s.end(), '.') - s.begin();\n  \n  if(c == 0){\n    int cnt = 0;\n    str = s;\n    cur = 0;\n    res = E(cnt);\n    //cout << str << \" \" << res << endl;\n    return cur == str.size() ? res : -1;\n  }\n  \n  \n  rep(i, 7){\n    s[pos] = ch[i];\n    res = max(res, dfs(s, c - 1));\n    s[pos] = '.';\n  }\n  return res;\n}\n\nint main(){\n  string s;\n  cin >> s;\n  cout << dfs(s, count(s.begin(), s.end(), '.')) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nstruct parse_error {};\n\nvoid check_range(int n)\n{\n  if (n < 0 || 1024 <= n) {\n    throw parse_error();\n  }\n}\n\nint expr(Iterator& it, const Iterator& last);\nint term(Iterator& it, const Iterator& last);\n\nint number(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw parse_error();\n  }\n  int n = 0;\n  while (it != last && isdigit(*it)) {\n    n = 2*n + (*it - '0');\n    ++it;\n  }\n  check_range(n);\n  return n;\n}\n\nint factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw parse_error();\n  }\n  if (*it == '(') {\n    ++it;\n\n    int n = factor(it, last);\n    if (it == last) {\n      throw parse_error();\n    }\n    if (*it == '*') {\n      while (it != last && *it == '*') {\n        ++it;\n        n *= factor(it, last);\n        check_range(n);\n      }\n      while (it != last && (*it == '+' || *it == '-')) {\n        const char op = *it;\n        ++it;\n        int m = term(it, last);\n        if (op == '+') {\n          n += m;\n        } else {\n          n -= m;\n        }\n        check_range(n);\n      }\n    } else if (*it == '+' || *it == '-') {\n      while (it != last && (*it == '+' || *it == '-')) {\n        const char op = *it;\n        ++it;\n        int m = term(it, last);\n        if (op == '+') {\n          n += m;\n        } else {\n          n -= m;\n        }\n        check_range(n);\n      }\n    } else {\n      throw parse_error();\n    }\n\n    if (it == last || *it != ')') {\n      throw parse_error();\n    }\n    ++it;\n    return n;\n  } else if (isdigit(*it)) {\n    return number(it, last);\n  } else {\n    throw parse_error();\n  }\n}\n\nint term(Iterator& it, const Iterator& last)\n{\n  int n = factor(it, last);\n  while (it != last && *it == '*') {\n    ++it;\n    n *= factor(it, last);\n    check_range(n);\n  }\n  return n;\n}\n\nint expr(Iterator& it, const Iterator& last)\n{\n  int n = term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    int m = term(it, last);\n    if (op == '+') {\n      n += m;\n    } else {\n      n -= m;\n    }\n    check_range(n);\n  }\n  return n;\n}\n\nint main()\n{\n  string s;\n  getline(cin, s);\n  int a[5];\n  static const char tbl[] = \"01+-*()\";\n  int ans = -1;\n  for (a[0] = 0; a[0] < 7; a[0]++) {\n    for (a[1] = 0; a[1] < 7; a[1]++) {\n      for (a[2] = 0; a[2] < 7; a[2]++) {\n        for (a[3] = 0; a[3] < 7; a[3]++) {\n          for (a[4] = 0; a[4] < 7; a[4]++) {\n            string t = s;\n            for (int i = 0; i < 5; i++) {\n              string::size_type n = t.find('.');\n              if (n != string::npos) {\n                t[n] = tbl[a[i]];\n              }\n            }\n            try {\n              Iterator it = t.begin(), last = t.end();\n              int n = expr(it, last);\n              //cerr << \"got \" << n << endl;\n              ans = max(ans, n);\n            } catch (const parse_error&) {\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc();\nint expr();\nint number();\nstring tmp;\nint pos;\nchar c[]=\"()+-*01\";\nint ans=-1;\nbool f=0,ff;\nint calc(){\n  int res=expr();\n  while(1){\n    if(tmp[pos]=='+') {pos++;res+=expr();}\n    else if(tmp[pos]=='-') {pos++;res-=expr();}\n    else break;\n    if(res<0||res>=(1<<10)) ff=0;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint expr(){\n  int res=number();\n  while(1){\n    if(tmp[pos]=='*') {pos++;res*=number();}\n    else break;\n    if(res<0||res>=(1<<10)) ff=0;\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\nint number(){\n  int res=0;\n  if(tmp[pos]=='(') {\n    pos++;res=calc();pos++;\n  }else{\n    while(pos<(int)tmp.size()&&isdigit(tmp[pos])) {\n      res=res*2+tmp[pos]-'0';\n      pos++;\n      if(res<0||res>=(1<<10)) ff=0;\n    }\n  }\n  if(res<0||res>=(1<<10)) ff=0;\n  return res;\n}\n \nbool check(string s){\n  int o=0;\n  bool op[100]={};\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]=='(') {\n      o++;\n      op[o]=1;\n      if(i+1>=(int)s.size()) return 0;\n      if(!isdigit(s[i+1])&&s[i+1]!='(') return 0;\n    }    \n    if(s[i]==')') {\n      if(op[o]) return 0;\n      o--;\n      if(i-1<0) return 0;\n      if(!isdigit(s[i-1])&&s[i-1]!=')') return 0;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*') {\n      op[o]=0;\n      if(i-1<0||i+1>=(int)s.size()) return 0;\n      if((!isdigit(s[i-1])&&s[i-1]!=')')||(!isdigit(s[i+1])&&s[i+1]!='(')) return 0;\n    }\n    if(o<0) return 0;\n  }\n  if(o) return 0;\n  return 1;\n}\nvoid rec(string s){\n  for(int i=0;i<(int)s.size();i++){\n    if(s[i]!='.') continue;\n    for(int j=0;j<8;j++){\n      s[i]=c[j];\n      rec(s);\n    }\n    return;\n  }\n  if(!check(s)) return;\n  tmp=s;pos=0;ff=1;\n  int k=calc();\n  //cout<<k<<\":\"<<tmp<<endl;\n  if(pos==(int)tmp.size()&&ff) ans=max(ans,k);\n}\nint main(){\n  string s;\n  cin>>s;\n  rec(s);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\n \nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\nbool OVER;\n \nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n \n  return true;\n}\n \nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n \n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n \n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true;\n  }\n  return false;\n}\n \nbool parapos(string s){\n  int p = 0;\n \n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n  }\n  return p == 0;\n}\n \nbool isvalid(string s){\n \n  if(!parapos(s)) return false;\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n \nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n \nint get(string s){\n  //  cout << \"S \" << s << endl;\n  \n  if(isnum(s)) return tob(s);\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+'){\n\tint tmp = get(s.substr(0,i))+get(s.substr(i+1));\n\tif(tmp > 1023) OVER = true;\n\treturn tmp;\n      }\n      if(p == 0 && s[i] == '-') return get(s.substr(0,i))-get(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*'){\n\tint tmp =  get(s.substr(0,i))*get(s.substr(i+1));\n\tif(tmp > 1023) OVER = true;\n\treturn tmp;\n      }\n    }\n  }\n}\n \nvoid solve(int n){\n \n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n\n    if(isvalid(in)){\n      OVER = false;\n      int num = get(in);\n      if(0 <= num && num < 1024 && !OVER) ans = max(ans,num);\n    }\n  }\n}\n \nint main(){\n \n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n \n  solve(0);\n \n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\nll N;\nchar S[111];\n\n#define INF (-(1<<20))\n\nll check(ll x){\n  if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  return INF;\n}\n\n\nll number(ll l,ll r){\n  ll ret = 0;\n  for(ll i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n    ret = check(ret);\n    if( ret < 0 ) return INF;\n  }\n \n  return ret;\n}\n\n\n\nll check(ll a,ll b,char op){\n  if( 0LL <= a && a < (1LL<<10LL) && 0LL <= b && b < (1LL<<10LL)){ \n    ll x;\n    if( op == '+' )\n      x = a+b;\n    if( op == '-' )\n      x = a-b;\n    if( op == '*' )\n      x = a * b;\n    if( 0LL <= x && x < (1LL<<10LL) ) return x;   \n  }\n  return INF;\n}\n\nbool check_n(ll l,ll r){\n  for(ll i=l;i<=r;i++){\n    if( !isdigit(S[i]) ) return false;\n  }\n  return true;\n}\nbool check_k2(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt > 0 ) return false;\n  }\n  if( cnt == 0 ) return true;\n  return false;\n}\n\nbool check_k3(ll l,ll r){\n  int cnt = 0;\n  for(ll i=r;i>=l;i--){\n    if( S[i] == '(' ) cnt ++ ;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 &&!( S[i] == '(' || S[i] == ')') ) return true; \n  }\n  return false;\n}\n\n\nbool check_k(ll l,ll r){\n  ll cnt =0;\n  if( l==r ) return false;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n\nbool check_m(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n\nbool check_w(ll l,ll r){\n  ll cnt =0;\n  for(ll i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n\n\nvoid view(ll l,ll r){\n  for(ll i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n\nbool check_h(ll l,ll r){\n  if( S[l] == '+' || S[r] == '+' || S[l] == '-' || S[r] == '-' || S[l] == '*' || S[r] == '*' ||  S[l] == ')' || S[r] == '(' ) return true;\n  if( l > r ) return true;\n  return false;\n}\n\nll exp(ll l,ll r){\n  //view(l,r);\n  if( check_h(l,r) ) return INF;\n  if( !check_k2(l,r) ) return INF;\n  if( check_k(l,r) ) {\n    if( check_n(l+1,r-1) ) return INF;\n    if( !check_k3(l+1,r-1) ) return INF;\n    return check(exp(l+1,r-1));\n  }\n  if( check_w(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return check(exp(l,i-1), exp(i+1,r),'+');\n      if( cnt == 0 && S[i] == '-' ) return check(exp(l,i-1), exp(i+1,r),'-');\n    }\n  }\n  if( check_m(l,r) ) {\n    ll cnt = 0;\n    for(ll i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return check(exp(l,i-1), exp(i+1,r),'*');\n    }\n  }\n  if( check_n(l,r) )\n    return check(number(l,r));\n  return INF;\n}\n\nint main(){\n  cin >> S;\n  N  = strlen(S);\n  ll M = 0;\n  for(ll i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  ll res = -1;\n  ll K=1;\n  for(ll i=0;i<M;i++) K*=7;\n  for(ll i=0;i<K;i++){\n    ll c = i;\n    strcpy( S, buf );\n    for(ll j=0;j<N;j++){\n      if( S[j] == '.' ){\n\tif( c%7 == 0 ) S[j] = '0';\n\tif( c%7 == 1 ) S[j] = '1';\n\tif( c%7 == 2 ) S[j] = '+';\n\tif( c%7 == 3 ) S[j] = '-';\n\tif( c%7 == 4 ) S[j] = '*';\n\tif( c%7 == 5 ) S[j] = '(';\n\tif( c%7 == 6 ) S[j] = ')';\t\t\n\tc/=7;\n      }    \n    }\n   \n    res = max( res, exp(0,N-1) );\n    \n  }\n  cout << res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  if(s[0]=='('&&s[s.size()-1]==')'){\n    return calculate(s.substr(1,s.size()-2),true);\n  }\n  rep(i,s.size()){\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n      if(i==s.size()-1){\n        return -INF;\n      } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n        return -INF;\n      }\n    }\n  }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(s[index+1]=='+'){\n      ret = calculate(s.substr(0,index+1))+calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='-'){\n      ret = calculate(s.substr(0,index+1))-calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = ret1*ret2;\n        if(inner(ret)){\n          return ret;\n        } else {\n          return -INF;\n        }\n      } else {\n        return -INF;\n      }\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    tmp = calculate(sc);\n    if(tmp>maxn)maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\ntypedef complex<lli> P;\n\nlli toDec(string bs) {\n  lli res = 0;\n  if(bs.size() > 10) throw 0;\n  reverse(bs.begin(), bs.end());\n  for(lli i = 0; i < bs.size(); ++i) {\n    res |= ((lli)(bs[i] - '0')) << i;\n  }\n  return res;\n}\n\nlli p;\nstring s;\nP exp();\nP term();\nP fact();\n\nP exp() {\n  P x = term();\n  while(1) {\n    if(s[p] == '+') {\n      ++p;\n      x += term();\n      x.imag() += 1;\n    } else if(s[p] == '-') {\n      ++p;\n      x -= term();\n      x.imag() += 1;\n    } else {\n      break;\n    }\n    if(x.real() < 0 || x.real() >= (1<<10)) {\n      throw 0;\n    }\n  }\n  return x;\n}\n\nP term() {\n  P x = fact();\n  while(1) {\n    if(s[p] == '*') {\n      ++p;\n      P y = fact();\n      x.real() *= y.real();\n      x.imag() += y.imag() + 1;\n      if(x.real() < 0 || x.real() >= (1<<10)) {\n        throw 0;\n      }\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nP fact() {\n  P x;\n  if(s[p] == '(') {\n    ++p;\n    x = exp();\n    if(x.imag() == 0) throw 0;\n    x.imag() = 0;\n    if(s[p] != ')') throw 0;\n    ++p;\n  } else if(isdigit(s[p])) {\n    string num;\n    while(isdigit(s[p])) {\n      num += s[p++];\n    }\n    x = P(toDec(num), 0);\n  } else {\n    throw 0;\n  }\n\n  if(x.real() < 0 || x.real() >= (1<<10)) {\n    throw 0;\n  }\n  return x;\n}\n\nconst string C = \"01+-*().\";\n\nlli rec(int k) {\n  if(k == s.size()) {\n    lli res = -1;\n    try {\n      p = 0;\n      lli tmp = exp().real();\n      if(s[p] != '$') throw 0;\n      res = tmp;\n    } catch(...) {}\n    return res;\n  } else {\n    if(s[k] == '.') {\n      lli res = -1;\n      for(int i = 0; i < C.size(); ++i) {\n        s[k] = C[i];\n        res = max(res, rec(k + 1));\n      }\n      s[k] = '.';\n      return res;\n    } else {\n      return rec(k + 1);\n    }\n  }\n}\n\nint main() {\n  while(cin >> s) {\n    s += \"$\";\n    cout << rec(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <stdexcept>\n\n#define fprintf(...) void(0)\n\nstruct Tsurai: public std::out_of_range {\n  Tsurai(int d): std::out_of_range(std::string(\"L: \")+std::to_string(d)) {}\n};\n\nvoid apply(int &lhs, char op, int rhs) {\n  switch (op) {\n  case '+':\n    lhs += rhs;\n    break;\n  case '-':\n    lhs -= rhs;\n    break;\n  case '*':\n    lhs *= rhs;\n    break;\n  }\n  if (!(0 <= lhs && lhs < 1024))\n    throw Tsurai(__LINE__);\n}\n\nint parse_bin(const std::string &s, size_t &i) {\n  int res=0;\n  while (i < s.length() && isdigit(s[i])) {\n    res = res*2+s[i]-'0';\n    ++i;\n    if (res >= 1024) throw Tsurai(__LINE__);\n  }\n  assert(res < 1024);\n  return res;\n}\n\nint parse(\n    const std::string &s, size_t &i,\n    const std::vector<std::string> &ops={\"+-\", \"*\", \"\"}, size_t prec=0) {\n\n  fprintf(stderr, \"C%zu\\n\", i);\n  fprintf(stderr, \"S: %s\\n\", s.c_str());\n  if (prec == ops.size()) {\n    if (s.at(i) == '(') {\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      ++i;\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (s.at(i) == ')') throw Tsurai(__LINE__);\n      size_t j=i;\n      (void)parse_bin(s, j);\n      if (s.at(j) == ')') throw Tsurai(__LINE__);\n\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      int res=parse(s, i, ops, 0);\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      if (s.at(i) != ')')\n        throw Tsurai(__LINE__);\n      ++i;\n      fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n      return res;\n    }\n    fprintf(stderr, \"%d\\n\", __LINE__);\n    if (isdigit(s.at(i))) {\n      fprintf(stderr, \"%d\\n\", __LINE__);\n      return parse_bin(s, i);\n    }\n    throw Tsurai(__LINE__);\n  }\n\n  int tmp=s.at(i);\n  int lhs=parse(s, i, ops, prec+1);\n  fprintf(stderr, \"\\\"%s\\\"[%zu] on line %d\\n\", s.c_str(), i, __LINE__);\n  if (tmp == '(' && i < s.length() && s[i] == ')')\n    throw Tsurai(__LINE__);\n\n  while (i < s.length()) {\n    char op=s.at(i);\n    if (op == ')')\n      break;\n    if (!(op == '+' || op == '-' || op == '*'))\n      throw Tsurai(__LINE__);\n    if (!std::count(ops[prec].begin(), ops[prec].end(), op))\n      break;\n\n    int rhs=parse(s, ++i, ops, prec+1);\n    apply(lhs, op, rhs);\n  }\n  return lhs;\n}\n\nint rec(std::string &s, std::vector<size_t> &dot) {\n  if (dot.empty()) {\n    try {\n      size_t i=0;\n      return parse(s, i);\n      if (i != s.length()) return -1;\n    } catch (std::out_of_range x) {\n      fprintf(stderr, \"Tsurai on %s\\n\", x.what());\n      return -1;\n    }\n  }\n\n  size_t x=dot.back();\n  dot.pop_back();\n  int res=-1;\n  for (char ch: {'0', '1', '+', '-', '*', '(', ')'}) {\n    s[x] = ch;\n    res = std::max(res, rec(s, dot));\n  }\n  s[x] = '.';\n  dot.push_back(x);\n  return res;\n}\n\nint main() {\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  std::vector<size_t> dot;\n  for (size_t i=0; i<s.length(); ++i) {\n    if (s[i] == '.')\n      dot.push_back(i);\n  }\n\n  printf(\"%d\\n\", rec(s, dot));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\npair<int,ll> sum(string& s, int& i);\npair<int,ll> mul(string& s, int& i);\npair<int,ll> bracket(string& s, int& i);\npair<int,ll> num(string& s,int & i);\npair<int,ll> sum(string& s, int& i){\n    pair<int,ll> ans = mul(s,i);\n    while(i!=s.size()&&(s[i]=='+'||s[i]=='-')){\n        if(s[i]!='+'&&s[i]!='-')return {0,0};\n        if(s[i]=='+'){\n            ++i;\n            auto ret = mul(s,i);\n            ans.first &= ret.first;\n            ans.second += ret.second;\n            ans.first|=2;\n        }\n        else if(s[i]=='-'){\n            ++i;\n            auto ret = mul(s,i);\n            ans.first &= ret.first;\n            ans.second -= ret.second;\n            ans.first|=2;\n        }\n        if(ans.second<0||ans.second>=1024)return {0,0};\n    }\n    return ans;\n}\n\npair<int,ll> mul(string& s, int& i){\n    pair<int,ll> ans = bracket(s,i);\n    while(i!=s.size()&&s[i]=='*'){\n        ++i;\n        auto ret = mul(s,i);\n        ans.first &= ret.first;\n        ans.second *= ret.second;\n        ans.first|=2;\n        if(ans.second<0||ans.second>=1024)return {0,0};\n    }\n    return ans;\n}\n\npair<int,ll> bracket(string& s, int& i){\n    if(i==s.size())return {0,0};\n    if(s[i]=='('){\n        ++i;\n        auto ret = sum(s,i);\n        if(i==s.size()||s[i]!=')'||ret.first<2)return {0,0};\n        ++i;\n        ret.first -= 2;\n        return ret;\n    }\n    if('0'<=s[i]&&s[i]<='1')return num(s,i);\n    return {0,0};\n}\n\npair<int,ll> num(string& s,int& i){\n    ll ret = 0;\n    bool ok=true;\n    while('0'<=s[i]&&s[i]<='1'){\n        if(ret>=512)ok=false;\n        else ret = 2 * ret + (s[i]-'0');\n        ++i;\n    }\n    return {ok,ret};\n}\n\nint main(){\n    string s;\n    cin>>s;\n    vector<int> dot;\n    char c[]{'+','-','*','0','1','(',')'};\n    rep(i,s.size()){\n        if(s[i]=='.')dot.push_back(i);\n    }\n    int m = dot.size();\n    int all = pow(7,m);\n    ll ans=-1;\n    rep(i,all){\n        int mask = i;\n        string t = s;\n        rep(j,m){\n            t[dot[j]]=c[mask%7];\n            mask/=7;\n        }\n        int idx=0;\n        auto ret = sum(t,idx);\n        if((ret.first&1)&&idx==s.size()) ans = max(ans,ret.second);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring cs=\"01+-*()\";\nstring s;\nint n;\n\nint f(int l,int r){\n  if(r<=l)return -1;\n  bool isn=true;\n  repl(i,l,r)if(!isdigit(s[i]))isn=false;\n  if(isn){\n    int res=0;\n    repl(i,l,r){\n      res*=2;\n      res+=s[i]-'0';\n    }\n    if(res>=pow(2,10))return -1;\n    else return res;\n  }\n\n  bool ok=false;\n  {\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(lev==0)ok=true;\n      if(s[i]==')')lev--;\n    }\n  }\n\n  if(!ok){\n    if(s[r-1]!=')')return -1;\n    int lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1||vl+vr>=pow(2,10))return -1;\n        else return vl+vr;\n      }\n    }\n    lev=-1;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l+1,i);\n        int vr=f(i+1,r-1);\n        if(vl==-1||vr==-1||vl*vr>=pow(2,10))return -1;\n        else return vl*vr;\n      }\n    }\n  }else{\n    int lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='+'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1||vl+vr>=pow(2,10))return -1;\n        else return vl+vr;\n      }\n    }\n    lev=0;\n    repl(i,l,r){\n      if(s[i]=='(')lev++;\n      if(s[i]==')')lev--;\n      if(lev==0&&s[i]=='*'){\n        int vl=f(l,i);\n        int vr=f(i+1,r);\n        if(vl==-1||vr==-1||vl*vr>=pow(2,10))return -1;\n        else return vl*vr;\n      }\n    }\n  }\n  return -1;\n}\n\nint dfs(int i){\n  if(i==n){\n    return f(0,n);\n  }else{\n    if(s[i]=='.'){\n      int res=-1;\n      rep(j,7){\n        s[i]=cs[j];\n        int tmp=dfs(i+1);\n        maxch(res,tmp);\n      }\n      s[i]='.';\n      return res;\n    }else{\n      return dfs(i+1);\n    }\n  }\n}\n\nint main(){\n  cin>>s;\n  n=s.size();\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar component_array[7] = {'0','1','+','-','*','(',')',};\nint table[16807][7];\nint num_of_blank,table_index;\n\nint calc_E(char line[101],int left,int right);\nint calc_T(char line[101],int left,int right);\nint calc_F(char line[101],int left,int right);\nint calc_NUM(char line[101],int left,int right);\n\nbool rangeCheck(int number){\n\tif(number >= 0 && number <= 1023)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid makeTable(int change_list[5],int index){\n\n\tif(index == num_of_blank){\n\t\tfor(int i = 0; i < num_of_blank; i++){\n\t\t\ttable[table_index][i] = change_list[i];\n\t\t}\n\t\ttable_index++;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 7; i++){\n\t\tint next_change_list[5];\n\t\tfor(int k = 0; k < index; k++)next_change_list[k] = change_list[k];\n\t\tnext_change_list[index] = i;\n\t\tmakeTable(next_change_list,index+1);\n\t}\n}\n\nbool is_OK(char work[101],int length){\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '(' && work[i+1] == ')')return false;\n\t\tif(work[i] == ')' && work[i+1] == '(')return false;\n\t}\n\n\tstack<int> S;\n\tfor(int i = 0; i < length; i++){\n\t\tif(work[i] == '(')S.push(i);\n\t\telse if(work[i] == ')'){\n\t\t\tif(S.size() == 0)return false;\n\t\t\telse{\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif(S.size() > 0)return false;\n\n\tif(work[0] == '+' || work[0] == '*' || work[0] == '-')return false;\n\n\tfor(int i = 0; i < length; i++){\n\t\tif((work[i] == '0' || work[i] == '1') && work[i+1] == '(')return false;\n\t\tif((work[i] == '(') && (work[i+1] == '*' || work[i+1] == '+'))return false;\n\t}\n\n\n\tint num;\n\tfor(int i = 0; work[i] != '\\0';){\n\t\tif(work[i] != '0' && work[i] != '1')i++;\n\t\telse{\n\t\t\tnum = 0;\n\t\t\tfor(; (i < length) && (work[i] == '0' || work[i] == '1'); i++){\n\t\t\t\tnum = 2*num+work[i]-'0';\n\t\t\t\tif(!rangeCheck(num))return false;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tfor(int i = 0; work[i] != '\\0'; i++){\n\t\tif((work[i] == '+' || work[i] == '*' || work[i] == '-') &&\n\t\t\t\t(work[i+1] == '+' || work[i+1] == '*' || work[i+1] == '-'|| work[i+1] == ')' || work[i+1] == '\\0'))return false;\n\t}\n\n\treturn true;\n}\n\nint calc_E(char line[101],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tif(line[i] == '+'){\n\t\t\t\tQ.push(i);\n\t\t\t\ti++;\n\t\t\t}else{ //line[i] == '-'\n\t\t\t\tif((i != left) && (line[i-1] == '0' || line[i-1] == '1' || line[i-1] == ')')){\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\treturn calc_T(line,left,right);\n\t}\n\n\tint tmp = calc_E(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM || rangeCheck(tmp) == false)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_T(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM || rangeCheck(tmp_right) == false){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '+'){\n\t\t\ttmp += tmp_right;\n\t\t}else{\n\t\t\ttmp -= tmp_right;\n\t\t}\n\t\tif(rangeCheck(tmp) == false){\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nint calc_T(char line[101],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '*'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tQ.push(i);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\treturn calc_F(line,left,right);\n\t}\n\n\tint tmp = calc_T(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM || rangeCheck(tmp) == false)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_F(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM || rangeCheck(tmp_right) == false){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\ttmp *= tmp_right;\n\t\tif(rangeCheck(tmp) == false){\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\treturn tmp;\n}\n\nint calc_F(char line[101],int left,int right){\n\n\tif(line[left] == '1' || line[left] == '0'){\n\t\treturn calc_NUM(line,left,right);\n\t}else if(line[left] == '('){\n\n\t\tint depth = 0;\n\t\tint close_pos = BIG_NUM;\n\t\tbool is_op_exist = false;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tclose_pos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(line[i] == '+' || line[i] == '-' || line[i] == '*'){\n\t\t\t\tif(depth == 1){\n\t\t\t\t\tis_op_exist = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(close_pos == BIG_NUM || close_pos != right || is_op_exist == false)return BIG_NUM;\n\n\t\treturn calc_E(line,left+1,close_pos-1);\n\t}else{\n\t\treturn BIG_NUM;\n\t}\n}\n\nint calc_NUM(char line[101],int left,int right){\n\n\tfor(int i = left; i <= right; i++){\n\t\tif(line[i] != '0' && line[i] != '1')return BIG_NUM;\n\t}\n\n\tint ret = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tret = 2*ret+line[i]-'0';\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tchar buf[101];\n\tscanf(\"%s\",buf);\n\n\tvector<int> REPLACE_LOC;\n\tnum_of_blank = 0;\n\n\tint length = 0;\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tlength++;\n\t\tif(buf[i] == '.'){\n\t\t\tnum_of_blank++;\n\t\t\tREPLACE_LOC.push_back(i);\n\t\t}\n\t}\n\n\tint result,ans = -BIG_NUM;\n\n\tif(num_of_blank == 0){\n\n\t\tresult = calc_E(buf,0,length-1);\n\n\t\tif(result == BIG_NUM){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",result);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint first_change_list[5];\n\ttable_index = 0;\n\tmakeTable(first_change_list,0);\n\n\tchar work[101];\n\n\tfor(int i = 0; i < table_index; i++){\n\t\tfor(int k = 0; k < length; k++)work[k] = buf[k];\n\t\twork[length] = '\\0';\n\n\t\tfor(int k = 0; k < num_of_blank; k++){\n\t\t\twork[REPLACE_LOC[k]] = component_array[table[i][k]];\n\t\t}\n\n\t\tif(!is_OK(work,length))continue;\n\n\t\tresult = calc_E(work,0,length-1);\n\t\tif(result == BIG_NUM)continue;\n\n\t\tans = max(ans,result);\n\t}\n\n\tif(ans == -BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nbool h;\nint out=-1;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i)){\n\t\tout=out*2+*(i++)-'0';\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nmap<char,int>op;\nint valid(string s){\n\tint n=s.size();\n\tvi co(100);\n\tint cnt=0;\n\trep(t,s.size()){\n\t\tif(s[t]=='('){\n\t\t\tif(t&&!op[s[t-1]]&&s[t-1]!='(')return 0;\n\t\t\tcnt++;\n\t\t\tco[cnt]=0;\n\t\t}else if(s[t]==')'){\n\t\t\tif(t!=n-1&&!op[s[t+1]]&&s[t+1]!=')')return 0;\n\t\t\tif(!co[cnt])return 0;\n\t\t\tcnt--;\n\t\t\tif(cnt<0)return 0;\n\t\t}else if(op[s[t]]){\n\t\t\tco[cnt]++;\n\t\t\tif(t==0||t==n-1)return 0;\n\t\t\tif(!isdigit(s[t-1])&&s[t-1]!=')'||!isdigit(s[t+1])&&s[t+1]!='(')return 0;\n\t\t}\n\t}\n\treturn !cnt;\n}\nstring w=\"01+-*()\";\nstring s;\nvoid dfs(){\n\trep(i,s.size())if(s[i]=='.'){\n\t\trep(j,w.size()){\n\t\t\ts[i]=w[j];\n\t\t\tdfs();\n\t\t\ts[i]='.';\n\t\t}\n\t\treturn;\n\t}\n\tif(!valid(s))return;\n\tState begin=s.begin();\n\th=true;\n\tint a=expr(begin);\n\tif(h)out=max(out,a);\n}\nint main(){\n\top['+']=op['-']=op['*']=true;\n\tcin>>s;\n\tdfs();\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\nbool isd(string s){return isdigit(s[0]);}\n\nstring calc(vs s){\n    stack<int> p;\n    for(int i=0;i<s.size();i++){\n        if(s[i]==\"(\")p.push(i);\n        else if(s[i]==\")\"){\n            int f=p.top(); p.pop();\n            vs tmp;\n            s[f]=s[i]=\"-1\";\n            for(int j=f+1;j<i;j++){\n                tmp.pb(s[j]);\n                s[j]=\"-1\";\n            }\n            s[f]=calc(tmp);\n        }\n    }\n    auto itr=remove(all(s),\"-1\");\n    s.erase(itr,s.end());\n    \n    //for(auto c:s)cout<<c<<\"      \";\n    \n    deque<int> oper;\n    deque<string> opec;\n    for(int i=0;i<s.size();i++){\n        if(isd(s[i])){\n            oper.pb(stoi(s[i]));\n        }else{\n            if(s[i]==\"*\"){\n                oper.back()*=stoi(s[++i]);\n                if(oper.back()<0 || oper.back()>1023) return \"-1\";\n            }else opec.pb(s[i]);\n        }\n    }\n    while(!opec.empty()){\n        int d=oper[0];\n        string c=opec[0];\n        oper.pop_front();\n        opec.pop_front();\n        oper.front()=(c==\"+\" ? d+oper.front() : d-oper.front());\n        if(oper.front()<0 || oper.front()>1023) return \"-1\";\n    }\n    //cout<<\"ans:\"<<to_string(oper[0])<<endl;\n    return to_string(oper[0]);\n}\n\n\nstring solve(string in){\n    vector<string> s;\n    bool ren=false;\n    for(auto c:in){\n        if(c=='0' || c=='1'){\n            if(ren){\n                s.back()+=c;\n            }else s.pb(\"\"s+c);\n            ren=true;\n        } else {\n            s.pb(\"\"s+c);\n            ren=false;\n        }\n    }\n    int dep=0;\n    for(int i=0;i<s.size();i++){\n        string &c=s[i];\n        if(c.length()>30){\n            return \"-1\";\n        }else{\n            try{\n                int p=stoi(c,nullptr,2);\n                c=to_string(p);\n            }catch(...){\n                if(c==\"(\")dep++;\n                else if(c==\")\")dep--;\n                if(dep<0 || dep>25)return \"-1\";\n            }\n        }\n    }\n    if(dep)return \"-1\";\n    //for(auto c:s)cout<<c;cout<<endl;\n    int exist=0,depth=0;\n    for(int i=0;i<s.size()-1;i++){\n        if(isd(s[i])){\n            if(s[i+1]==\"(\" || isd(s[i+1])) return \"-1\";\n        }else if(s[i]==\"(\"){\n            depth++;\n            if(s[i+1]==\"+\" || s[i+1]==\"-\" || s[i+1]==\"*\" || s[i+1]==\")\") return \"-1\";\n        }else if(s[i]==\")\"){\n            //cout<<depth<<\",\"<<exist<<endl;\n            if((exist&(1<<depth))==0) return \"-1\";\n            //cout<<\"OK\"<<endl;\n            exist&=~(1<<depth);\n            depth--;\n            if(isd(s[i+1]) || s[i+1]==\"(\") return \"-1\";\n        }else{\n            exist|=(1<<depth);\n            if(s[i+1]!=\"(\" && !isd(s[i+1])) return \"-1\";\n        }\n    }\n    if(s.back()==\")\"){\n        if((exist&(1<<depth))==0) return \"-1\";\n    }\n    int t=s.size()-1;\n    if(s[0]==\")\" || s[0]==\"+\" || s[0]==\"-\" || s[0]==\"*\") return \"-1\";\n    if(s[t]==\"(\" || s[t]==\"+\" || s[t]==\"-\" || s[t]==\"*\") return \"-1\";\n    //ここまでで除去ができているはず\n    //for(auto c:s)cout<<c<<\"    \";cout<<endl;\n    return calc(s);\n}\n\nint bur(string s){\n    int ans=-1;\n    if(count(all(s),'.')==0) {\n        return stoi(solve(s));\n    }\n    for(auto d:\"01+-*()\"s){\n        string os=s;\n        os[s.find('.')]=d;\n        ans=max(ans,bur(os));\n    }\n    return ans;\n}\n\nint main(){\n    string o;\n    cin>>o;\n    cout<<bur(o)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(char ch){return ch&&ch!='+'&&ch!='-'&&ch!='*'&&ch!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  if(res>1024)flg=0;\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(s[p]);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(s[p]=='*') res*=calc();\n  }\n  if(res<0||res>=1024) flg=0;\n  return res;\n}\n\nint bnf(){\n  flg&=check(s[p]);\n  int res=Num();\n  while(p<s.size()&&flg){\n    if(s[p]=='(') flg=0;\n    if(s[p]==')')break;\n    flg&=check(s[p+1]);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n    if(res<0||res>=1024) flg=0;\n  }\n  if(res<0||res>=1024) flg=0;\n  if(!flg)res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\ntypedef string::const_iterator State;\nint number(State&);\npair<int,bool> factor(State&);\npair<int,bool> term(State&);\npair<int,bool> expression(State&);\n\nbool invalid;\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n\tif(not isdigit(*begin)){\n\t\tinvalid = true;\n\t\treturn 0;\n\t}\n\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 2;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\npair<int,bool> factor(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tpair<int,bool> ret = expression(begin);\n\t\tif(not ret.second) {\n\t\t\tinvalid = true;\n\t\t}\n\t\tbegin++; // ')'を飛ばす。\n\t\tret.second = 0;\n\t\treturn ret;\n\t} else {\n\t\treturn make_pair(number(begin), 0);\n\t}\n\treturn make_pair(0, 0);\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\npair<int,bool> term(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first *= factor(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\npair<int,bool> expression(State &begin) {\n\tif(invalid) return make_pair(0,0);\n\tpair<int,bool> ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first += term(begin).first;\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret.second = true;\n\t\t\tret.first -= term(begin).first;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n//beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\t//throw ParseError();\n\t}\n}\n\nconst string c = \"01+-*()\";\n\nbool check(string& s){\n\tint cnt = 0;\n\tbool op = false, st = false;\n\tshow(s)\n\trep(i,s.size()){\n\t\tcout << i << endl;\n\t\tif(s[i] == '('){\n\t\t\tif(st) return false;\n\t\t\tcnt++;\n\t\t\top = true;\n\t\t}else if(s[i] == ')'){\n\t\t\tif(op or st) return false;\n\t\t\tcnt--;\n\t\t\top = false;\n\t\t\tst = true;\n\t\t}else if(s[i] == '+' or s[i] == '-'){\n\t\t\top = false;\n\t\t\tst = false;\n\t\t}\n\t}\n\tshow(cnt)\n\treturn cnt == 0;\n}\n\nint dfs(string s, int i){\n\tif(i == s.size()){\n\t\t//if(not check(s)) return -1e5;\n\n\t\tinvalid = false;\n\t\tState tmp = s.begin();\n\n\t\tpair<int,bool> ans = expression(tmp);\n\t\tif(ans.first >= 1024 or ans.first < 0) return -1e5;\n\t\tif(tmp != s.end()) return -1e5;\n\t\t//cout << ans.first << ' ' << s << endl;\n\t\treturn invalid ? -1e5 : ans.first;\n\t}\n\n\twhile(s[i] != '.' and i < s.size()){\n\t\ti++;\n\t}\n\n\tif(s[i] == '.'){\n\t\tint res = -1e5;\n\t\trep(j,c.size()){\n\t\t\ts[i] = c[j];\n\t\t\tres = max(res, dfs(s, i));\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn dfs(s, i);\n\t}\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\n\tint ans = dfs(s, 0);\n\tcout << (ans == -1e5 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nclass ParseError {};\nstruct Result{\n  int value, p, ex;\n  Result(int v, int p) : value(v), p(p), ex(0) {}\n};\nvoid skip(const string& s, Result& r, char expected){\n  if(!(0 <= r.p && r.p < s.size())){\n    throw ParseError();\n  }else if(s[r.p] != expected){\n    throw ParseError();\n  }else {\n    r.p ++;\n  }\n}\nvoid checkvalue(int x){\n  if(x < 0 || x >= 1<<10) throw ParseError();\n}\nResult equation(const string& s, int p);\nResult equation_in(const string& s, int p);\nResult factor(const string& s, int p);\nResult term(const string& s, int p);\nResult equation(const string& s, int p){\n  Result r = factor(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result r2 = factor(s, r.p + 1);\n    if(s[r.p] == '+'){\n      r.value += r2.value;\n    }else if(s[r.p] == '-'){\n      r.value -= r2.value;\n    }\n    r.p = r2.p;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult equation_in(const string& s, int p){\n  Result r = factor(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result r2 = factor(s, r.p + 1);\n    if(s[r.p] == '+'){\n      r.value += r2.value;\n    }else if(s[r.p] == '-'){\n      r.value -= r2.value;\n    }\n    r.p = r2.p;\n    r.ex = 1;\n    checkvalue(r.value);\n  }\n  if(r.ex == 0) throw ParseError();\n  return r;\n}\nResult factor(const string& s, int p){\n  Result r = term(s, p);\n  r.ex = 0;\n  while(s[r.p] == '*'){\n    Result r2 = term(s, r.p + 1);\n    r.value *= r2.value;\n    r.p = r2.p;\n    r.ex = 1;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  if(s[p] == '('){\n    Result r = equation_in(s, p + 1);\n    skip(s, r, ')');\n    checkvalue(r.value);\n    return r;\n  }else if(isdigit(s[p])){\n    int value = 0;\n    while(isdigit(s[p]) && p < s.size()){\n      value = (value << 1) + (s[p++] - '0');\n    }\n    checkvalue(value);\n    return Result(value, p);\n  }else {\n    throw ParseError();\n  }\n}\nstring SYMBOLS = \"01+-*()\";\nint dfs(int k, vector<int>& index, string& s){\n  if(k == index.size()){\n    try{\n      Result r = equation(s, 0);\n      if(r.p != s.size()) throw ParseError();\n      //cout<<s<<\" is \"<<r.value<<endl;\n      return r.value;\n    }catch(...){\n      //cout<<s<<\" is invalid.\"<<endl;\n      return -1;\n    }\n  }else{\n    int res = -INF;\n    REP(i, SYMBOLS.size()){\n      s[index[k]] = SYMBOLS[i];\n      res = max(res, dfs(k + 1, index, s));\n    }\n    return res;\n  }\n}\n\nint main(){\n  string s;\n  while(cin>>s){\n    vector<int> index;\n    REP(i, s.size()) if(s[i] == '.') index.push_back(i);\n    int ans = dfs(0, index, s);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\n\nusing ll = long long;\nusing pll = pair<ll, ll>;\n \nconstexpr ll M = 1e9+7;\n\nconst string w = \"01+-*()\";\n\nconstexpr int mi = 0;\nconstexpr int ma = 1023;\n\nbool isrange(int n) {\n    return mi <= n && n <= ma;\n}\n\nint expr(string const& s, int& p);\nint term(string const& s, int& p);\nint factor(string const& s, int& p);\nint number(string const& s, int& p);\n\nint expr(string const& s, int& p) {\n    int res = term(s, p);\n    while(p < s.size() && (s[p] == '+' || s[p] == '-')) {\n        if(s[p] == '+') {\n            res += term(s, ++p);\n        } else if(s[p] == '-') {\n            res -= term(s, ++p);\n        }\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    }\n    return res;\n}\n\nint term(string const& s, int& p) {\n    int res = factor(s, p);\n    while(p < s.size() && s[p] == '*') {\n        res *= factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n    }\n    return res;\n}\n\nint factor(string const& s, int& p) {\n    if(isdigit(s[p])) {\n        return number(s, p);\n    }\n    if(s[p] == '-') {\n        int res = -factor(s, ++p);\n        if(!isrange(res)) {\n            throw runtime_error(\"\");\n        }\n        return res;\n    } else if(s[p] == '(') {\n        int res = expr(s, ++p);\n        if(p < s.size() && s[p] != ')') {\n            throw runtime_error(\"\");\n        }\n        ++p;\n        return res;\n    } else {\n        throw runtime_error(\"\");\n    }\n}\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(p < s.size() && isdigit(s[p])) {\n        res <<= 1;\n        res |= s[p] == '1';\n        ++p;\n    }\n    if(!isrange(res)) {\n        throw runtime_error(\"\");\n    }\n    return res;\n}\n\nbool check(string const& s) {\n    stack<int> st;\n    vector<vector<bool>> par(s.size(), vector<bool>(s.size()));\n    bool ok = true;\n    for(int i=0; i<s.size(); ++i) {\n        if(s[i] == '(') {\n            st.push(i);\n        }\n        if(s[i] == ')') {\n            if(st.empty()) {\n                ok = false;\n                break;\n            }\n            if(s[st.top()+1] == '(' && s[i-1] == ')' && par[st.top()+1][i-1]) {\n                ok = false;\n                break;\n            }\n            par[st.top()][i] = true;\n            bool f = false;\n            for(int j=st.top()+1; j<i; ++j) {\n                f |= !isdigit(s[j]);\n            }\n            st.pop();\n            ok &= f;\n        }\n    }\n    return st.empty() && ok;\n}\n\nint solve(int i, string& s, vector<int> const& lost) {\n    int res = -1;\n    if(i == lost.size()) {\n        try {\n            int p = 0;\n            if(check(s)) {\n                res = expr(s, p);\n            }\n            return (p == s.size() ? res : -1);\n        } catch(...) {\n            return -1;\n        }\n    }\n    for(int j=0; j<w.size(); ++j) {\n        s[lost[i]] = w[j];\n        res = max(res, solve(i+1, s, lost));\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    vector<int> pos;\n    for(int i=0; i<s.size(); ++i) {\n        if(s[i] == '.') {\n            pos.push_back(i);\n        }\n    }\n    cout << solve(0, s, pos) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2428.cc: Lost Number\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 5;\nconst int MIN_D = 0;\nconst int MAX_D = (1 << 10) - 1;\n\nconst int CN = 7;\nconst char chs[CN] = { '0', '1', '+', '-', '*', '(', ')' };\n\n/* typedef */\n\n/* global variables */\n\nint ps[MAX_N], cnts[MAX_N];\n\n/* subroutines */\n\nint num(string &s, int &pos);\nint coef(string &s, int &pos);\nint term(string &s, int &pos, bool &opf);\nint expr(string &s, int &pos, bool &opf);\n\nint num(string &s, int &pos) {\n  if (pos >= s.size() || (s[pos] != '0' && s[pos] != '1')) return -1;\n  int num = 0;\n  while (pos < s.size() && s[pos] >= '0' && s[pos] <= '1') {\n    num = 2 * num + s[pos++] - '0';\n    if (num > MAX_D) return -1;\n  }\n  return num;\n}\n\nint coef(string &s, int &pos) {\n  if (pos >= s.size()) return -1;\n\n  if (s[pos] == '(') {\n    pos++; // '('\n\n    bool ok = false;\n    for (int i = pos; i < s.size() && s[i] != ')'; i++)\n      if (s[i] != '0' && s[i] != '1') {\n\tok = true;\n\tbreak;\n      }\n    if (! ok) return -1;\n\n    bool opf = false;\n    int e = expr(s, pos, opf);\n    if (pos >= s.size() || s[pos] != ')' || ! opf) return -1;\n    pos++; // ')'\n    return e;\n  }\n\n  return num(s, pos);\n}\n\nint term(string &s, int &pos, bool &opf) {\n  if (pos >= s.size()) return -1;\n  int c0 = coef(s, pos);\n  if (c0 < 0) return -1;\n\n  while (pos < s.size() && s[pos] == '*') {\n    pos++; // '*'\n    int c1 = coef(s, pos);\n    opf = true;\n    if (c1 < 0) return -1;\n\n    c0 *= c1;\n    if (c0 < MIN_D || c0 > MAX_D) return -1;\n  }\n\n  return c0;\n}\n\nint expr(string &s, int &pos, bool &opf) {\n  if (pos >= s.size()) return -1;\n  int t0 = term(s, pos, opf);\n  if (t0 < 0) return -1;\n\n  while (pos < s.size() && (s[pos] == '+' || s[pos] == '-')) {\n    char opc = s[pos++]; // '+' || '-'\n    int t1 = term(s, pos, opf);\n    opf = true;\n    if (t1 < 0) return -1;\n\n    t0 = (opc == '+') ? t0 + t1 : t0 - t1;\n    if (t0 < MIN_D || t0 > MAX_D) return -1;\n  }\n\n  return t0;\n}\n\n/* main */\n\nint main() {\n  string s;\n  cin >> s;\n  int l = s.size();\n\n  int n = 0;\n  for (int i = 0; i < l; i++)\n    if (s[i] == '.') ps[n++] = i;\n  //printf(\"n=%d\\n\", n);\n\n  int maxd = -1;\n\n  for (;;) {\n    for (int i = 0; i < n; i++)\n      s[ps[i]] = chs[cnts[i]];\n\n    int pos = 0;\n    bool opf;\n    int d = expr(s, pos, opf);\n    if (pos == l && maxd < d) {\n      maxd = d;\n      //cout << s; printf(\" = %d\\n\", d);\n    }\n    \n    int k = 0;\n    while (k < n) {\n      if (++cnts[k] < CN) break;\n      cnts[k++] = 0;\n    }\n    if (k >= n) break;\n  }\n\n  printf(\"%d\\n\", maxd);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nclass ParseError {};\nstruct Result{\n  int value, p, ex;\n  Result(int v, int p) : value(v), p(p), ex(0) {}\n};\nvoid skip(const string& s, Result& r, char expected){\n  if(!(0 <= r.p && r.p < s.size())){\n    throw ParseError();\n  }else if(s[r.p] != expected){\n    throw ParseError();\n  }else {\n    r.p ++;\n  }\n}\nvoid checkvalue(int x){\n  if(x < 0 || x >= 1<<10) throw ParseError();\n}\nResult equation(const string& s, int p);\nResult equation_in(const string& s, int p);\nResult factor(const string& s, int p);\nResult term(const string& s, int p);\nResult equation(const string& s, int p){\n  Result r = factor(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result r2 = factor(s, r.p + 1);\n    if(s[r.p] == '+'){\n      r.value += r2.value;\n    }else if(s[r.p] == '-'){\n      r.value -= r2.value;\n    }\n    r.p = r2.p;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult equation_in(const string& s, int p){\n  Result r = factor(s, p);\n  while(s[r.p] == '+' || s[r.p] == '-'){\n    Result r2 = factor(s, r.p + 1);\n    if(s[r.p] == '+'){\n      r.value += r2.value;\n    }else if(s[r.p] == '-'){\n      r.value -= r2.value;\n    }\n    r.p = r2.p;\n    r.ex = 1;\n    checkvalue(r.value);\n  }\n  if(r.ex == 0) throw ParseError();\n  return r;\n}\nResult factor(const string& s, int p){\n  Result r = term(s, p);\n  while(s[r.p] == '*'){\n    Result r2 = term(s, r.p + 1);\n    r.value *= r2.value;\n    r.p = r2.p;\n    r.ex = 1;\n    checkvalue(r.value);\n  }\n  return r;\n}\nResult term(const string& s, int p){\n  if(s[p] == '('){\n    Result r = equation_in(s, p + 1);\n    skip(s, r, ')');\n    checkvalue(r.value);\n    return r;\n  }else if(isdigit(s[p])){\n    int value = 0;\n    while(isdigit(s[p])){\n      value = (value << 1) + (s[p++] - '0');\n    }\n    checkvalue(value);\n    return Result(value, p);\n  }else {\n    throw ParseError();\n  }\n}\nstring SYMBOLS = \"01+-*()\";\nint dfs(int k, vector<int>& index, string& s){\n  if(k == index.size()){\n    try{\n      Result r = equation(s, 0);\n      if(r.p != s.size()) throw ParseError();\n      return r.value;\n    }catch(...){\n      return -1;\n    }\n  }else{\n    int res = -INF;\n    REP(i, SYMBOLS.size()){\n      s[index[k]] = SYMBOLS[i];\n      res = max(res, dfs(k + 1, index, s));\n    }\n    return res;\n  }\n}\n\nint main(){\n  string s;\n  while(cin>>s){\n    vector<int> index;\n    REP(i, s.size()) if(s[i] == '.') index.push_back(i);\n    int ans = dfs(0, index, s);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool is_num(char x){return x=='0' || x=='1';}\n\nbool valid_num(int x){\n  const int SUP=1024;\n  return 0<=x && x<SUP;\n}\n\nint calc(int lhs,int rhs,char op){\n  int res;\n  if(op=='+'){\n    res=lhs+rhs;\n  }else if(op=='-'){\n    res=lhs-rhs;\n  }else if(op=='*'){\n    res=lhs*rhs;\n  }else{\n    throw \"calc\";\n  }\n  if(!valid_num(res)) throw \"invalid\";\n  return res;\n}\n\nint formula(int &p);\nint formulap(int &p);\nint term1(int &p);\npair<int,bool> term1p(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint formula(int &p){\n  int res=term1(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formula\";\n    int rhs=term1(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\nint formulap(int &p){\n  bool isok=false;\n  auto ret=term1p(p);\n  isok|=ret.second;\n  int res=ret.first;\n  if(p>=s.size()) throw \"AHO\";\n  while(s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formulap_op\";\n    isok=true;\n    int rhs=term1p(p).first;\n    res=calc(res,rhs,op);\n      if(p>=s.size()) throw \"AHO\";\n  }\n\n  if(!isok) throw \"formulap_isok\";\n  return res;\n}\n\nint term1(int& p){\n  int res=term2(p);\n  while(p<s.size() && (s[p]!='+' && s[p]!='-')){\n    char op=s[p];\n    p++;\n    if(op!='*') throw \"term1_op\";\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\npair<int,bool> term1p(int &p){\n  int res=term2(p);\n  bool isop=false;\n  if(p>=s.size()) throw \"AHO\";\n  while(s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;    \n    if(op!='*') throw \"term1p\";\n    isop=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n    if(p>=s.size()) throw \"AHO\";\n  }\n  return {res,isop};\n}\n\nint term2(int& p){\n  if(s[p]=='('){\n    p++;\n    int res=formulap(p);\n    if(s[p]!=')') throw \"term2\";\n    p++;\n    return res;\n  }else if(is_num(s[p])){\n    int res=get_num(p);\n    return res;\n  }else throw \"term2\";\n}\n\nint get_num(int& p){\n  int res=0;\n  while(p<s.size() && is_num(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nint dfs(int i){\n  if(i==s.size()){\n    int res=-1;\n     try{\n       int p=0;\n       res=formula(p);\n     }catch(const char* &e){\n       return -1;\n     }\n     return res;\n  }\n  else if(s[i]=='.'){\n    const string ch=\"01+-*()\";\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      int ret=dfs(i+1);\n      res=max(ret,res);\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\ntypedef complex<lli> P;\n\nbool check(lli x) {\n  if(x < 0 || x >= (1<<10)) {\n    throw 0;\n  }\n}\n\nlli toDec(string bs) {\n  lli res = 0;\n  reverse(bs.begin(), bs.end());\n  for(lli i = 0; i < bs.size(); ++i) {\n    res |= ((lli)(bs[i] - '0')) << i;\n    check(res);\n  }\n  return res;\n}\n\nlli p;\nstring s;\nP exp();\nP term();\nP fact();\n\nP exp() {\n  P x = term();\n  while(1) {\n    if(s[p] == '+') {\n      ++p;\n      x += term();\n      x.imag() += 1;\n    } else if(s[p] == '-') {\n      ++p;\n      x -= term();\n      x.imag() += 1;\n    } else {\n      break;\n    }\n    check(x.real());\n  }\n  return x;\n}\n\nP term() {\n  P x = fact();\n  while(1) {\n    if(s[p] == '*') {\n      ++p;\n      P y = fact();\n      x.real() *= y.real();\n      x.imag() += y.imag() + 1;\n    } else {\n      break;\n    }\n    check(x.real());\n  }\n  return x;\n}\n\nP fact() {\n  P x;\n  if(s[p] == '(') {\n    ++p;\n    x = exp();\n    if(x.imag() == 0) throw 0;\n    x.imag() = 0;\n    if(s[p] != ')') throw 0;\n    ++p;\n  } else if(isdigit(s[p])) {\n    string num;\n    while(isdigit(s[p])) {\n      num += s[p++];\n    }\n    x = P(toDec(num), 0);\n  } else {\n    throw 0;\n  }\n  return x;\n}\n\nconst string C = \"01+-*()\";\n\nlli rec(int k) {\n  if(k == s.size()) {\n    lli res = -1;\n    try {\n      p = 0;\n      lli tmp = exp().real();\n      if(s[p] != '$') throw 0;\n      res = tmp;\n    } catch(...) {}\n    return res;\n  } else {\n    if(s[k] == '.') {\n      lli res = -1;\n      for(int i = 0; i < C.size(); ++i) {\n        s[k] = C[i];\n        res = max(res, rec(k + 1));\n      }\n      s[k] = '.';\n      return res;\n    } else {\n      return rec(k + 1);\n    }\n  }\n}\n\nint main() {\n  while(cin >> s) {\n    s += \"$\";\n    cout << rec(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nbool h;\nint out=-1;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t\tif(out1<0||out1>=1024)h=false;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t\tif(out1<0||out1>=1024)h=false;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*2+*(i++)-'0';\n\treturn out;\n}\nint valid(string s){\n\tint n=s.size();\n\tvi co(100);\n\tint cnt=0;\n\trep(t,s.size()){\n\t\tif(s[t]=='('){\n\t\t\tcnt++;\n\t\t\tco[cnt]=0;\n\t\t}else if(s[t]==')'){\n\t\t\tif(!co[cnt])return 0;\n\t\t\tcnt--;\n\t\t\tif(cnt<0)return 0;\n\t\t}else if(s[t]=='+'||s[t]=='-'||s[t]=='*'){\n\t\t\tco[cnt]++;\n\t\t\tif(t==0||t==n-1)return 0;\n\t\t\tif(!isdigit(s[t-1])&&s[t-1]!=')'||!isdigit(s[t+1])&&s[t+1]!='(')return 0;\n\t\t}\n\t}\n\treturn !cnt;\n}\nstring w=\"01+-*()\";\nstring s;\nvoid dfs(){\n\trep(i,s.size())if(s[i]=='.'){\n\t\trep(j,w.size()){\n\t\t\ts[i]=w[j];\n\t\t\tdfs();\n\t\t\ts[i]='.';\n\t\t}\n\t\treturn;\n\t}\n\tif(!valid(s))return;\n\tState begin=s.begin();\n\th=true;\n\tint a=expr(begin);\n\tif(h)out=max(out,a);\n}\nint main(){\n\tcin>>s;\n\tdfs();\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nclass ex{\n};\n\nvoid ass(bool cond){\n\tif(!cond){\n\t\tthrow ex();\n\t}\n}\nvoid inrange(int n){\n\tass(0<=n&&n<(1<<10));\n}\n\nint number(string &s,int &p){\n\tass(isdigit(s[p]));\n\tint ret=s[p]-'0';\n\tp++;\n\twhile(isdigit(s[p])){\n\t\tret<<=1;\n\t\tret+=s[p]-'0';\n\t\tinrange(ret);\n\t\tp++;\n\t}\n\tinrange(ret);\n\treturn ret;\n}\nint expression(string &s, int &p);\nint term(string &s,int &p);\n\n//factor ::= number | (factor [+-] expression) | (factor * term)\nint factor(string &s,int &p){\n\tif(s[p]=='('){\n\t\tp++;\n\t\tint ret=factor(s,p);\n\t\tchar op=s[p];\n\t\tp++;\n\t\tif(op=='+'){\n\t\t\tret+=expression(s,p);\n\t\t}else if(op=='-'){\n\t\t\tret-=expression(s,p);\n\t\t}else if(op=='*'){\n\t\t\tret*=term(s,p);\n\t\t}else{\n\t\t\tass(0);\n\t\t}\n\t\tinrange(ret);\n\t\tass(s[p]==')');\n\t\tp++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(s,p);\n\t}\n}\n\n//term ::= factor | factor * factor\nint term(string &s,int &p){\n\tint ret=factor(s,p);\n\twhile(s[p]=='*'){\n\t\tp++;\n\t\tret*=factor(s,p);\n\t\tinrange(ret);\n\t}\n\treturn ret;\n}\n\n//expression ::= term | term [+-] expression\nint expression(string &s, int &p){\n\tint ret=term(s,p);\n\tchar op=s[p];\n\twhile(op=='+'||op=='-'){\n\t\tp++;\n\t\tint t=term(s,p);\n\t\tif(op=='+'){\n\t\t\tret+=t;\n\t\t}else if(op=='-'){\n\t\t\tret-=t;\n\t\t}else{\n\t\t\tass(0);\n\t\t}\n\t\tinrange(ret);\n\t\top=s[p];\n\t}\n\treturn ret;\n}\n\nchar chars[]={'0','1','+','-','*','(',')'};\n\nint main(){\n\tstring s;\n\tcin>>s;\n\tvi rpl(5);\n\tint ans=-1;\n\tfor(rpl[0]=0;rpl[0]<7;rpl[0]++)\n\tfor(rpl[1]=0;rpl[1]<7;rpl[1]++)\n\tfor(rpl[2]=0;rpl[2]<7;rpl[2]++)\n\tfor(rpl[3]=0;rpl[3]<7;rpl[3]++)\n\tfor(rpl[4]=0;rpl[4]<7;rpl[4]++){\n\t\tstring ns(s);\n\t\tint pos=0;\n\t\tREP(i,5){\n\t\t\tpos=ns.find('.',pos);\n\t\t\tif(pos!=ns.npos){\n\t\t\t\tns[pos]=chars[rpl[i]];\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttry{\n\t\t\tint p=0;\n\t\t\tint val=expression(ns,p);\n\t\t\tass(p==ns.size());\n\t\t\tans=max(ans,val);\n\t\t}catch(ex){\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nchar s[101];\nint x;\nconst pair<int,bool> fail(-1,false);\n\npair<int,bool> exp();\npair<int,bool> mexp();\npair<int,bool> elm();\n\nbool valid(int x){\n  return 0<=x&&x<1<<10;\n}\n\npair<int,bool> elm(){\n  if(s[x]=='('){\n    x++;\n    auto e=exp();\n    if(!valid(e.first)||!e.second||s[x]!=')')return fail;\n    x++;\n    return make_pair(e.first,false);\n  }else if(s[x]=='0'||s[x]=='1'){\n    int n=0;\n    while(s[x]=='0'||s[x]=='1'){\n      n=n*2+s[x]-'0';\n      if(!valid(n))return fail;\n      x++;\n    }\n    return make_pair(n,false);\n  }else{\n    return fail;\n  }\n}\n    \npair<int,bool> mexp(){\n  auto f=elm();\n  if(!valid(f.first))return f;\n  while(s[x]=='*'){\n    x++;\n    auto l=elm();\n    if(!valid(l.first))return l;\n    f.first*=l.first;\n    f.second=true;\n  }\n  return f;\n}\n\npair<int,bool> exp(){\n  auto f=mexp();\n  if(!valid(f.first))return f;\n  while(s[x]=='+'||s[x]=='-'){\n    int sign=(s[x]=='+')?1:-1;\n    x++;\n    auto l=mexp();\n    if(!valid(l.first))return l;\n    f.first+=sign*l.first;\n    f.second=true;\n  }\n  return f;\n}\n\nint dfs(){\n  for(int i=0;s[i];i++){\n    if(s[i]=='.'){\n      int m=-1;\n      for(const char *p=\"01+-*()\";*p;p++){\n\ts[i]=*p;\n\tint r=dfs();\n\tif(valid(r)){\n\t  m=max(m,r);\n\t}\n      }\n      s[i]='.';\n      return m;\n    }\n  }\n  x=0;\n  auto r=exp().first;\n  return s[x]?-1:r;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tconst int kind = 7;\n\tStage(){\n\t}\n\t\n\tvoid action(){\n\t\tstring text;\n\t\tcin >> text;\n\n\t\tint res = -1;\n\t\tREP(transWay, pow(kind, count_dot(text))) {\n\t\t\tstring transedText = trans(transWay, text);\n\t\t\tif (transWay == 265) {\n\t\t\t\tint a;\n\t\t\t\ta = 5;\n\t\t\t}\n\t\t\tlist<char> ls;\n\t\t\tfor (char c : transedText)ls.push_back(c);\n\t\t\tauto grams = trans_gram(ls);\n\t\t\tint score = read(grams);\n\n\t\t\tres = max(res, score);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tchar data;\n\t\tint num;\n\t};\n\t\n\tint count_dot(const string& text) {\n\t\tint res = 0;\n\t\tfor (char c : text)if (c == '.')res++;\n\t\treturn res;\n\t}\n\tstring trans(int n, string text) {\n\t\tfor (char& c : text)if (c == '.') {\n\t\t\tswitch (n % kind) {\n\t\t\tcase 0:c = '0'; break;\n\t\t\tcase 1:c = '1'; break;\n\t\t\tcase 2:c = '+'; break;\n\t\t\tcase 3:c = '-'; break;\n\t\t\tcase 4:c = '*'; break;\n\t\t\tcase 5:c = '('; break;\n\t\t\tcase 6:c = ')'; break;\n\t\t\t}\n\t\t\tn /= kind;\n\t\t}\n\t\treturn text;\n\t}\n\n\tlist<Gram> trans_gram(const list<char>& ls) {\n\t\tlist<Gram> grams;\n\t\tfor (auto itr = ls.begin(); itr != ls.end(); ++itr) {\n\t\t\tGram gram;\n\t\t\tswitch (*itr) {\n\t\t\tcase '+':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '+';\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '-';\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tgram.kind = 'o';\n\t\t\t\tgram.data = '*';\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.data = ')';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgram.kind = 'n';\n\t\t\t\tgram.data = '.';\n\t\t\t\tgram.num = 0;\n\t\t\t\tdo {\n\t\t\t\t\tgram.num *= 2;\n\t\t\t\t\tgram.num += *itr - '0';\n\t\t\t\t\t++itr;\n\t\t\t\t} while (itr != ls.end() && isdigit(*itr));\n\t\t\t\t--itr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tint read(list<Gram> grams){\n\t\ttry {\n\t\t\t// ( , ) delete\n\t\t\tfor (auto right = grams.begin(); right != grams.end(); ++right)\n\t\t\t{\n\t\t\t\tif (right->data == ')') {\n\t\t\t\t\tlist<Gram> subset;\n\t\t\t\t\tauto left = right;\n\n\t\t\t\t\t//move: (expression)\n\t\t\t\t\twhile (left != grams.begin() && left->data != '(') --left;\n\t\t\t\t\tif (left->data != '(')throw - 1;\n\t\t\t\t\t++right;\n\t\t\t\t\tsubset.splice(subset.begin(), move(grams), left, right);\n\n\t\t\t\t\t// delete: ( , )\n\t\t\t\t\tsubset.pop_front();\n\t\t\t\t\tsubset.pop_back();\n\n\t\t\t\t\tif (subset.size() == 1)throw - 1;\n\n\t\t\t\t\tint res = read(subset);\n\t\t\t\t\tif (res < 0)throw - 1;\n\t\t\t\t\tif (1024 <= res)throw - 1;\n\n\t\t\t\t\tGram gram;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = res;\n\t\t\t\t\tgrams.insert(right, gram);\n\t\t\t\t\tright = grams.begin();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperator_erase(grams, '*');\n\t\t\toperator_erase(grams, '+', '-');\n\t\t\tif (grams.size() != 1) {\n\t\t\t\t//cerr << \"size is too much\" << endl;\n\t\t\t\tthrow - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint res = grams.front().num;\n\t\t\t\tif (res < 0 || 1024 <= res)return -1;\n\t\t\t\telse return res;\n\t\t\t}\n\t\t}\n\t\tcatch (...) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tbool isnumber(const list<char>& ls){\n\t\tfor (char c : ls) {\n\t\t\tif (c < '0' || '9' < c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isoperator(const char& c) {\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tlist<char> n2b(int num) {\n\t\tlist<char> b;\n\t\twhile (num > 0) {\n\t\t\tint tmp = num % 2;\n\t\t\tnum /= 2;\n\t\t\tb.push_front(tmp + '0');\n\t\t}\n\t\treturn b;\n\t}\n\n\tint b2n(const list<char>& ls) {\n\t\tint res = 0;\n\t\tfor (char c: ls) {\n\t\t\tres *= 2;\n\t\t\tres += c - '0';\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid operator_erase(\n\t\tlist<Gram>& grams,\n\t\tconst char& ope1,\n\t\tconst char& ope2 = 'i'\n\t){\n\t\tfor (auto center = grams.begin(); center != grams.end(); ++center) {\n\t\t\tif (center->data == ope1 || center->data == ope2) {\n\t\t\t\tauto left = center; if (distance(grams.begin(), left) == 0)break; left--;\n\t\t\t\tauto right = center; if (distance(right, grams.end()) == 1)break; right++;\n\n\t\t\t\tswitch (center->data) {\n\t\t\t\tcase '+':left->num += right->num; break;\n\t\t\t\tcase '-':left->num -= right->num; break;\n\t\t\t\tcase '*':left->num *= right->num; break;\n\t\t\t\t}\n\n\t\t\t\tif (left->num < 0 || 1024 <= left->num)throw - 1;\n\t\t\t\tgrams.erase(center);\n\t\t\t\tgrams.erase(right);\n\t\t\t\tcenter = left;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tStage stage;\n\tstage.action();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nstring::iterator end;\nstring::iterator begin;\nbool perseExpression(string::iterator & it, int * result);\n\n//\nbool perseNumber(string::iterator & it, int * result){\n  if(*it!='0' && *it!='1') return false;\n  int max_length = 10;\n  *result = *it - '0' << max_length;\n  \n  int length = 1;\n  while(true){\n    if(*(it+length)!='0' && *(it+length)!='1') break;\n    *result += (*(it+length) - '0') << max_length-length;\n    ++length;\n  }\n  if(length > max_length) return false;\n  \n  *result >>= max_length-length+1;\n  it += length;\n  return true;\n}\n\n// ( )\nbool perseVaule(string::iterator & it, int * result){\n  if(*it!='(') return perseNumber(it, result);\n  ++it;\n  \n  string::iterator temp = it;\n  if(!perseExpression(it, result)) return false;\n  if(find(temp, it, '+')==it && find(temp, it, '*')==it && find(temp, it, '-')==it ){\n    return false;\n  }\n  ++it;\n  return true;\n}\n\n// *\nbool perseTerm(string::iterator & it, int * result){\n  if(!perseVaule(it, result)) return false;\n  while(true){\n    if(it==end || *it!='*') break;\n    ++it;\n    int rv;\n    if(!perseVaule(it, &rv)) return false;\n    *result *= rv;\n    if(*result >= 1024) return false;\n  }\n  return true;\n}\n\n// + -\nbool perseExpression(string::iterator & it, int * result){\n  if(!perseTerm(it, result)) return false;\n  while(true){\n    if(it==end) break;\n    char op = *it;\n    if(op!='+' && op!='-') break;\n    ++it;\n    int rv;\n    if(!perseTerm(it, &rv)) return false;\n    *result += (op=='+') ? rv : -rv;\n    if(*result<0 || *result >= 1024) return false;\n  }\n  return true;\n}\n\nint main(){\n  string str;\n  cin >> str;\n  std::size_t l1Pos = str.find(\".\");\n  std::size_t l2Pos = l1Pos!=string::npos ? str.find(\".\", l1Pos+1) : string::npos;\n  std::size_t l3Pos = l2Pos!=string::npos ? str.find(\".\", l2Pos+1) : string::npos;\n  std::size_t l4Pos = l3Pos!=string::npos ? str.find(\".\", l3Pos+1) : string::npos;\n  std::size_t l5Pos = l4Pos!=string::npos ? str.find(\".\", l4Pos+1) : string::npos;\n  \n  string list[7] = {\"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\"};\n  \n  int max_val = -1;\n  for(string * l1=list; l1!=list+7; ++l1){\n    for(string * l2=list; l2!=list+7; ++l2){\n      for(string * l3=list; l3!=list+7; ++l3){\n        for(string * l4=list; l4!=list+7; ++l4){\n          for(string * l5=list; l5!=list+7; ++l5){\n            string temp = str;\n            if(l1Pos!=string::npos) str.replace(l1Pos, 1, *l1);\n            if(l2Pos!=string::npos) str.replace(l2Pos, 1, *l2);\n            if(l3Pos!=string::npos) str.replace(l3Pos, 1, *l3);\n            if(l4Pos!=string::npos) str.replace(l4Pos, 1, *l4);\n            if(l5Pos!=string::npos) str.replace(l5Pos, 1, *l5);\n            \n            end = str.end();\n            begin = str.begin();\n            int val = 0;\n            if(perseExpression(begin, &val)) max_val = max(max_val, val);\n            str = temp;\n          }\n        }\n      }\n    }\n  }\n  cout << max_val << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  rep(i,s.size()){\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n      if(i==s.size()-1){\n        return -INF;\n      } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n        return -INF;\n      }\n    }\n  }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1)return calculate(s.substr(1,s.size()-2),true);\n    if(s[index+1]=='+'){\n      ret = calculate(s.substr(0,index+1))+calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='-'){\n      ret = calculate(s.substr(0,index+1))-calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret))return ret;\n      else return -INF;\n    } else if (s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = ret1*ret2;\n        if(inner(ret)){\n          return ret;\n        } else {\n          return -INF;\n        }\n      } else {\n        return -INF;\n      }\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  cin >> s;\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    tmp = calculate(sc);\n    if(tmp>maxn)maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\ntypedef string::iterator Iterator;\nconst int LIMIT = 1<<10;\n\nint number(Iterator &it, const Iterator &end) {\n    if(it == end) throw \"end of expr\";\n    int val = 0;\n    if(!isdigit(*it)) throw \"not a number\";\n    while(it != end && isdigit(*it)) {\n        val <<= 1;\n        val += *it - '0';\n        if(val >= LIMIT) throw \"limit over\";\n        ++it;\n    }\n    return val;\n}\n\nint expression(Iterator &it, bool &operated, const Iterator &end);\nint term(Iterator &it, bool &operated, const Iterator &end) {\n    if(it == end) throw \"end of expr\";\n    int lhs;\n    if(*it == '(') {\n        lhs = expression(it, operated, end);\n    } else {\n        lhs = number(it, end);\n    }\n    while(it != end && *it == '*') {\n        ++it;\n        int rhs;\n        if(*it == '(') {\n            rhs = expression(it, operated, end);\n        } else {\n            rhs = number(it, end);\n        }\n        lhs *= rhs;\n        if(lhs >= LIMIT) throw \"limit over\";\n        operated = true;\n    }\n    return lhs;\n}\n\nint factor(Iterator &it, bool &operated, const Iterator &end) {\n    if(it == end) throw \"end of expr\";\n    int lhs = term(it, operated, end);\n    while(it != end && (*it == '+' || *it == '-')) {\n        char op = *it;\n        ++it;\n        int rhs = term(it, operated, end);\n        if(op == '+') {\n            lhs += rhs;\n            if(lhs >= LIMIT) throw \"limit over\";\n            operated = true;\n        } else if(op == '-') {\n            lhs -= rhs;\n            if(lhs < 0) throw \"limit under\";\n            operated = true;\n        } else {\n            throw \"syntax error\";\n        }\n    }\n    return lhs;\n}\n\nint expression(Iterator &it, bool &operated, const Iterator &end) {\n    if(it == end) throw \"end of expr\";\n    if(*it == '(') {\n        ++it;\n        bool operated = false;\n        int val = expression(it, operated, end);\n        if(val < 0 || val >= LIMIT) throw \"limit over\";\n        if(!operated) throw \"paren without operator\";\n        if(*it != ')') throw \"unmatched paren\";\n        ++it;\n        return val;\n    } else if(isdigit(*it)) {\n        return factor(it, operated, end);\n    } else {\n        throw \"syntax error\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    string str;\n    cin >> str;\n    vector<int> dotpos;\n    for(int i = 0; i < str.size(); ++i) {\n        if(str[i] == '.') dotpos.push_back(i);\n    }\n    int allpat = 1;\n    for(int i = 0; i < dotpos.size(); ++i) {\n        allpat *= 7;\n    }\n    int ans = -1;\n    for(int pat = 0; pat < allpat; ++pat) {\n        int tmp = pat;\n        string expr(str);\n        for(int i = 0; i < dotpos.size(); ++i) {\n            int n = tmp % 7;\n            tmp /= 7;\n            expr[dotpos[i]] = \"01+-*()\"[n];\n        }\n        try {\n            bool dmy;\n            Iterator it = expr.begin();\n            int val = expression(it, dmy, expr.end());\n            if(val < 0 || val >= LIMIT) throw \"limit over\";\n            if(it != expr.end()) throw \"premature end\";\n            ans = max(ans, val);\n        } catch (const char *msg) {\n            //cout << expr << ' ' << msg << endl;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nbool h;\nint out=-1;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t\tif(out<0||out>=1024)h=false;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*2+*(i++)-'0';\n\tif(out<0||out>=1024)h=false;\n\treturn out;\n}\nmap<char,int>op;\nint valid(string s){\n\tint n=s.size();\n\tvi co(100);\n\tint cnt=0;\n\trep(t,s.size()){\n\t\tif(s[t]=='('){\n\t\t\tif(t&&!op[s[t-1]])return 0;\n\t\t\tcnt++;\n\t\t\tco[cnt]=0;\n\t\t}else if(s[t]==')'){\n\t\t\tif(t!=n-1&&!op[s[t+1]])return 0;\n\t\t\tif(!co[cnt])return 0;\n\t\t\tcnt--;\n\t\t\tif(cnt<0)return 0;\n\t\t}else if(op[s[t]]){\n\t\t\tco[cnt]++;\n\t\t\tif(t==0||t==n-1)return 0;\n\t\t\tif(!isdigit(s[t-1])&&s[t-1]!=')'||!isdigit(s[t+1])&&s[t+1]!='(')return 0;\n\t\t}\n\t}\n\treturn !cnt;\n}\nstring w=\"01+-*()\";\nstring s;\nvoid dfs(){\n\trep(i,s.size())if(s[i]=='.'){\n\t\trep(j,w.size()){\n\t\t\ts[i]=w[j];\n\t\t\tdfs();\n\t\t\ts[i]='.';\n\t\t}\n\t\treturn;\n\t}\n\tif(!valid(s))return;\n\tState begin=s.begin();\n\th=true;\n\tint a=expr(begin);\n\tif(h)out=max(out,a);\n}\nint main(){\n\top['+']=op['-']=op['*']=true;\n\tcin>>s;\n\tdfs();\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint p,flag,ans=-1;\nstring s;\nmap<int,char>cc;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])){\n    while(isdigit(s[p]))res=res*2+(s[p++]-'0');\n  }\n  else flag++;\n  if(res>=1024)flag++;\n  if(res<0)flag++;\n  return res;\n}\nint bnf2(){\n  int res=get_A();\n  while(s[p]=='*'){\n    int t=p++;\n    if(s[t]=='*')res*=get_A();\n    if(res>=1024)flag++;\n    if(res<0)flag++;\n  }\n  if(res>=1024)flag++;\n  if(res<0)flag++;\n  return res;\n}\nint bnf1(){\n  int res=bnf2();\n  while(s[p]=='+'||s[p]=='-'){\n    int t=p++;\n    if(s[t]=='+')res+=bnf2();\n    if(s[t]=='-')res-=bnf2();\n    if(res>=1024)flag++;\n    if(res<0)flag++;\n  }\n  if(res>=1024)flag++;\n  if(res<0)flag++;\n  return res;\n}\nbool ch(){\n  int t=0;\n  stack<int>st;\n  r(i,s.size()){\n    if(s[i]=='(')t++;\n    if(s[i]==')'){\n      int tt=0;\n      if(!st.empty()&&st.top()!=t)return 0;\n      while(!st.empty()&&st.top()==t)st.pop(),tt++;\n      if(!tt)return 0;\n      t--;\n    }\n    if(s[i]=='+'||s[i]=='-'||s[i]=='*')st.push(t);\n  }\n  if(t)return 0;\n  return 1;\n}\nvoid dfs(int d){\n  if(d==s.size()){\n    p=0;\n    if(ch()){\n      p=flag=0;\n      int res=bnf1();\n      if(!flag&&p==s.size())ans=max(ans,res);\n    }\n  }\n  else if(s[d]=='.'){\n    r(i,7){\n      s[d]=cc[i];\n      dfs(d+1);\n    }\n    s[d]='.';\n  }\n  else dfs(d+1);\n}\nmain(){\n  cin>>s;\n  cc[0]='0';\n  cc[1]='1';\n  cc[2]='+';\n  cc[3]='-';\n  cc[4]='*';\n  cc[5]='(';\n  cc[6]=')';\n  dfs(0);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool ope, err;\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\t\n\t\tp++;\n\t\tope=false;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\tif (!ope) err=true;\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else {\n\t\treturn number(s);\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tope = true;\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\twhile (s[p] == '+' || s[p] == '-') {\n\t\tope = true;\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += expression(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= expression(s);\n\t\t}\n\t}\n\t\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\treturn res;\n}\n\nbool check(string s)\n{\n\tint l=0, r=0;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') l++;\n\t\telse if (s[i] == ')') r++;\n\t}\n\treturn l==r;\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>1024) res=-1;\n\t\t\n\t\t//cerr << \"Persing : \" << s << endl;\n\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <stack>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef string::const_iterator State;\nint mx=1<<10;\nint expr(State &be);\nint num(State &be){\n\tif(!isdigit(*be)) return -1;\n\tint ret=0;\n\twhile(isdigit(*be)){\n\t\tret*=2;\n\t\tret+=(*be-'0');\n\t\tif(ret>=mx) return -1;\n\t\tbe++;\n\t}\n\treturn ret;\n}\nint factor(State& be){\n\tint ret;\n\tif(*be=='('){\n\t\tbe++;\n\t\tret=expr(be);\n\t\tif(*be!=')') return -1;\n\t\tbe++;\n\t\treturn ret;\n/*\t\tcout << ret << endl;\n\t\tif(ret==-1) return -1;\n\t\tint k=-1;\n\t\tcout << *be << endl;\n\t\tif(*be=='+') k=0;\n\t\tif(*be=='-') k=1;\n\t\tif(*be=='*') k=2;\n\t\tif(k==-1) return -1;\n\t\tbe++;\n\t\tint ret1=expr(be);\n\t\tif(ret1==-1) return -1;\n\t\tbe++;\n\t\tif(k==0) return ret+ret1;\n\t\tif(k==1) return max(-1,ret-ret1);\n\t\tif(k==2) return ret*ret1;\n\t\tcout << \"hoge\";*/\n\t}\n\treturn num(be);\n}\nint term(State& be){\n\tint ret=factor(be);\n\tif(ret==-1) return -1;\n\twhile(*be=='*'){\n\t\tbe++;\n\t\tint a=factor(be);\n\t\tif(a<0) return -1;\n\t\tret*=a;\n\t\tif(ret>=mx) return -1;\n\t}\n\treturn ret;\n}\nint expr(State& be){\n\tint ret=term(be);\n\tif(ret==-1) return -1;\n\twhile(true){\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret+=a;\n\t\t\tif(ret>=mx) return -1;\n\t\t}else if(*be=='-'){\n\t\t\tbe++;\n\t\t\tint a=term(be);\n\t\t\tif(a==-1) return -1;\n\t\t\tret-=a;\n\t\t\tif(ret<0 || ret>=mx) return -1;\n\t\t}else break;\n\t}\n\treturn ret;\n}\nint main(){\n\tstring s,ch=\"01+-*()\";\n\tvector<int> vc;\n\tcin >> s;\n\tState be=s.begin();\n\trep(i,s.size()) if(s[i]=='.') vc.push_back(i);\n\tint n=vc.size(),p7=1,ans=-1;\n\trep(i,n) p7*=7;\n\trep(i,p7){\n\t\tstring t=s;\n\t\tint tmp=i;\n\t\trep(j,n){\n\t\t\tt[vc[j]]=ch[tmp%7];\n\t\t\ttmp/=7;\n\t\t}\n//\t\tcout << t << \"  \";\n\t\tstack<int> id;\n\t\tint cal[101]={};\n\t\tbool ok=true;\n\t\trep(i,t.size()){\n\t\t\tif(t[i]=='('){\n\t\t\t\tid.push(i);\n\t\t\t\tcal[i]=-1;\n\t\t\t}\n\t\t\tif(t[i]==')'){\n\t\t\t\tif(id.empty()){\n\t\t\t\t\tok=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tid.pop();\n\t\t\t}\n\t\t\tif(t[i]=='+' || t[i]=='-' || t[i]=='*'){\n\t\t\t\tif(!id.empty()) cal[id.top()]++;\n\t\t\t}\n\t\t}\n\t\tif(!id.empty()) ok=false;\n\t\trep(i,t.size()) if(cal[i]<0) ok=false;\n//\t\tcout << (ok ? \"valid\" : \"invalid\\n\");\n\t\tif(!ok) continue;\n\t\tState be=t.begin();\n\t\tint h=expr(be);\n\t\tif(be!=t.end()){\n//\t\t\tcout << endl;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout << \"     \" << h << endl;\n\t\tans=max(ans,h);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y;\n\tP(int x, int y):x(x), y(y){}\n\tP(){}\n};\n\n/** Prbolem2428 : Lost Number **/\nint p;\nint N;\nstring c = \"01+-*()\";\nstring S;\n\nint number(string s), expression(string s), factor(string s), term(string s);\n\nbool err;\n\nint factor(string s)\n{\n\tif (s[p] == '(') {\n\t\tp++;\n\t\t\n\t\tif (s[p]=='+'||s[p]=='-'||s[p]=='*'||s[p]==')') err=true;\n\t\tint res = expression(s);\n\t\tif (s[p] != ')') err=true;\n\t\t\n\t\tp++;\n\t\t\n\t\treturn res;\n\t} else if (s[p] == ')') {\n\t\terr=true;\n\t\treturn -1;\n\t} else if (isdigit(s[p])) {\n\t\treturn number(s);\n\t} else {\n\t\terr = true;\n\t}\n}\n\nint term(string s)\n{\n\tint ret = factor(s);\n\t\n\twhile (s[p] == '*') {\n\t\tp++;\n\t\tret *= factor(s);\n\t}\n\t\n\treturn ret;\n}\n\nint expression(string s)\n{\n\tint res = term(s);\n\t\n\twhile (s[p] == '+' || s[p] == '-') {\n\t\tif (s[p] == '+') {\n\t\t\tp++;\n\t\t\tres += expression(s);\n\t\t} else if (s[p] == '-') {\n\t\t\tp++;\n\t\t\tres -= expression(s);\n\t\t}\n\t}\n\t\n\treturn res;\n\t\n}\n\nint number(string s)\n{\n\tint res=0;\n\t\n\twhile (isdigit(s[p])) {\n\t\tres*=2;\n\t\tres+=s[p++]-'0';\n\t}\n\t\n\treturn res;\n}\n\nbool check(string s)\n{\n\tvector<int> ope;\n\t\n\tif (s[N-1]=='+' || s[N-1]=='-' || s[N-1]=='*' || s[N-1]=='(')\n\t\treturn false;\n\t\n\tint d=-1;\n\trep(i, s.size()) {\n\t\tif (s[i]=='(') {\n\t\t\td++;\n\t\t\tif (i==s.size()-1||s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'||s[i+1]==')')\n\t\t\t\treturn false;\n\t\t\tope.push_back(0);\n\t\t} else if (s[i]==')') {\n\t\t\tif (d<0 || !ope[d]) return false;\n\t\t\tope.erase(ope.begin()+d);\n\t\t\td--;\n\t\t} else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n\t\t\tif (d>=0)\n\t\t\t\tope[d] = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif (d!=-1) return false;\n\treturn ope.end()==find(ope.begin(), ope.end(), 0);\n\t\n}\n\nint solve(int n, string s)\n{\n\tif (n == N) {\n\t\tp=0; err=false;\n\t\tif (!check(s)) err=1;\n\t\t\n\t\tint res = expression(s);\n\t\tif (res>=1024) res=-1;\n\t\t\n\t\t//cerr << \"Persing : \" << s << endl;\n\t\t//cerr << \"    res : \" << (err?-1:res) << endl;\n\t\treturn err?-1:res;\n\t}\n\t\n\tint res=-1;\n\tif (S[n]!='.')\n\t\tres = solve(n+1, s+S[n]);\n\telse\n\t\trep(i, 7) {\n\t\t\t//if (n==N-1 && i>1) continue;\n\t\t\tres = max(res, solve(n+1, s+c[i]));\n\t\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>S;\n\tN=(int)S.size();\n\tint res = solve(0, \"\");\n\tcout << max(-1, res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[200];\nchar *p;\nint n;\n\nbool ok(int n){\n    return 0<=n && n<=(1<<10);\n}\n\nint E();\nint F();\nint T();\nint N();\n\nint E(){\n    int res = F();\n    while(*p=='+' || *p=='-'){\n        if(*p=='+') p++, res += F();\n        else if(*p=='-') p++, res -= F();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint F(){\n    int res = T();\n    while(*p=='*' || *p=='/'){\n        if(!ok(res)) throw \"\";\n        if(*p=='*') p++, res *= T();\n        else if(*p=='/') p++, res /= T();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint T(){\n    int res;\n    if(*p=='(') p++, res = E(), p++;\n    else res = N();\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nint N(){\n    int res = 0;\n    if(!isdigit(*p)) throw \"\";\n    while(isdigit(*p)){\n        res = res*2 + *p - '0';\n        p++;\n    }\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nbool chk(){\n    for(int i=0;i<n;i++){\n        if(s[i]!='(') continue;\n        int j = i;\n        int d = 0;\n        int cnt = 0;\n        while(s[j]){\n            if(s[j]=='(') d++;\n            else if(s[j]==')') d--;\n            if(d==1) if(s[j]=='+' || s[j]=='-') cnt++;\n            if(d==0) break;\n            j++;\n        }\n        dump(cnt);\n        dump(d);\n        if(d!=0 || cnt!=1) return false;\n    }\n    return true;\n}\n\nint main(){\n    cin >> s;\n    n = strlen(s);\n    int x[6], k = 0;\n    char cand[] = \"01+-*())\";\n    for(int i=0;i<n;i++){\n        if(s[i]=='.') x[k++] = i;\n    }\n    int ans = -1;\n    for(int mask=0;mask<1<<(3*k);mask++){\n        p = s;\n        int t = mask;\n        for(int i=0;i<k;i++) s[x[i]] = cand[t>>(3*i)&7];\n        dump(s);\n        if(!chk()) continue;\n        try {\n            dump(\"ok\");\n            ans = max(ans, E());\n        } catch(...){}\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nint formula(int, int);\nstring s;\nvector<int> idx;\n\nint binary_to_int(const string& binary) {\n\tint res = 0, x = 1, n = binary.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(binary[n - 1 - i] == '1')\n\t\t\tres += x;\n\n\t\telse if(binary[n - 1 - i] != '0')\n\t\t\treturn -1;\n\n\t\tx <<= 1;\n\t}\n\n\treturn res;\n}\n\nint factor(int l, int r) {\n\tif(s[l] == '(' && s[r - 1] == ')') {\n\t\tfor(int i = l + 1; i < r - 1; ++i)\n\t\t\tif(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\treturn formula(l + 1, r - 1);\n\t}\n\n\treturn binary_to_int(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && s[i] == '*') {\n\t\t\tint vl = term(l, i), vr = factor(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\treturn vl * vr;\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == '(')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == ')')\n\t\t\t--cnt;\n\n\t\telse if(cnt == 0 && (s[i] == '+' || s[i] == '-')) {\n\t\t\tint vl = formula(l, i), vr = term(i + 1, r);\n\t\t\tif(vl < 0 || vr < 0 || vl >= 1024 || vr >= 1024)\n\t\t\t\treturn -1;\n\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn vl + vr;\n\n\t\t\telse\n\t\t\t\treturn vl - vr;\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nbool isnumber(int l, int r) {\n\tfor(int i = l; i < r; ++i)\n\t\tif(!isdigit(s[i]))\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool valid(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = l; i < r; ++i) {\n\t\tswitch(s[i]) {\n\t\tcase '(': ++cnt; break;\n\t\tcase ')': --cnt; break;\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\t\tif(i == l || (!isdigit(s[i - 1]) && !s[i - 1] == ')')\n\t\t\t   || i == r - 1 || (!isdigit(s[i + 1])) && !s[i + 1] == '(')\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif(cnt < 0)\n\t\t\treturn false;\n\t}\n\n\tif(cnt)\n\t\treturn false;\n\n\treturn true;\n}\n\nint dfs(int d = 0) {\n\tif(d == idx.size()) {\n\t\tif(!valid(0, s.size()))\n\t\t\treturn -1;\n\n\t\tconst int res = formula(0, s.size());\n\t\treturn res >= 1024 ? -1 : res;\n\t}\n\n\tint res = -1;\n\tstatic const char c[7] = {'0', '1', '*', '+', '-', '(', ')'};\n\tfor(int i = 0; i < 7; ++i) {\n\t\ts[idx[d]] = c[i];\n\t\tchmax(res, dfs(d + 1));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> s;\n\n\tfor(int i = 0; i < s.size(); ++i)\n\t\tif(s[i] == '.')\n\t\t\tidx.push_back(i);\n\n\tcout << dfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\n\nbool is_num(char x){return x=='0' || x=='1';}\n\nbool valid_num(int x){\n  const int SUP=1024;\n  return 0<=x && x<SUP;\n}\n\nint calc(int lhs,int rhs,char op){\n  int res;\n  if(op=='+'){\n    res=lhs+rhs;\n  }else if(op=='-'){\n    res=lhs-rhs;\n  }else if(op=='*'){\n    res=lhs*rhs;\n  }else{\n    throw \"calc\";\n  }\n  if(!valid_num(res)) throw \"invalid\";\n  return res;\n}\n\nint formula(int &p);\nint formulap(int &p);\nint term1(int &p);\npair<int,bool> term1p(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint formula(int &p){\n  int res=term1(p);\n  while(p<s.size()){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formula\";\n    int rhs=term1(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\nint formulap(int &p){\n  bool isok=false;\n  auto ret=term1p(p);\n  isok|=ret.second;\n  int res=ret.first;\n  if(p>=s.size()) throw \"AHO\";\n  while(s[p]!=')'){\n    char op=s[p];\n    p++;\n    if(op!='+' && op!='-') throw \"formulap_op\";\n    isok=true;\n    int rhs=term1p(p).first;\n    res=calc(res,rhs,op);\n      if(p>=s.size()) throw \"AHO\";\n  }\n\n  if(!isok) throw \"formulap_isok\";\n  return res;\n}\n\nint term1(int& p){\n  int res=term2(p);\n  while(p<s.size() && (s[p]!='+' && s[p]!='-')){\n    char op=s[p];\n    p++;\n    if(op!='*') throw \"term1_op\";\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return res;\n}\n\npair<int,bool> term1p(int &p){\n  int res=term2(p);\n  bool isop=false;\n  if(p>=s.size()) throw \"AHO\";\n  while(s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;    \n    if(op!='*') throw \"term1p\";\n    isop=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n    if(p>=s.size()) throw \"AHO\";\n  }\n  return {res,isop};\n}\n\nint term2(int& p){\n  if(p>=s.size()) throw \"MANUKE\";\n  if(s[p]=='('){\n    p++;\n    int res=formulap(p);\n    if(p>=s.size() || s[p]!=')') throw \"term2\";\n    p++;\n    return res;\n  }else if(is_num(s[p])){\n    int res=get_num(p);\n    return res;\n  }else throw \"term2\";\n}\n\nint get_num(int& p){\n  int res=0;\n  while(p<s.size() && is_num(s[p])){\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nint dfs(int i){\n  if(i==s.size()){\n    int res=-1;\n     try{\n       int p=0;\n       res=formula(p);\n     }catch(const char* &e){\n       return -1;\n     }\n     return res;\n  }\n  else if(s[i]=='.'){\n    const string ch=\"01+-*()\";\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      int ret=dfs(i+1);\n      res=max(ret,res);\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e) != (s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst int NG=-1;\n\n//<number> ::= <digit> | <number> <digit>\nint number(string &s,int &pos){\n\tint l=0;\n\t//<digit> ::= 0 | 1\n\tif(pos>=s.size())return NG;\n\tif(!isdigit(s[pos])){\n\t\treturn NG;\n\t}\n\tif(pos>=s.size())return NG;\n\tl+=s[pos]-'0';\n\tpos++;\n\twhile(isdigit(s[pos])){\n\t\tl<<=1;\n\t\tl+=s[pos]-'0';\n\t\tpos++;\n\t}\n\treturn l;\n}\n\n//<operation> ::= + | - | *\nbool is_op(char c){\n\tswitch(c){\n\tcase '+':\n\tcase '-':\n\tcase '*':\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n//<expression> ::= <number> | <expression> <operation> <expression> | ( <expression> <operation> <expression> )\nint expression(string &s,int &pos){\n\tbool par_exist=false;\n\tint l;\n\tif(pos>=s.size())return NG;\n\tif(s[pos]=='('){\n\t\tpos++;\n\t\tpar_exist=true;\n\t\tl=expression(s,pos);\n\t}else{\n\t\tl=number(s,pos);\n\t\tif(l==NG){\n\t\t\treturn NG;\n\t\t}\n\t\treturn l;\n\t}\n\tif(pos>=s.size())return NG;\n\tchar op=s[pos];\n\tif(!is_op(op)){\n\t\treturn NG;\n\t}\n\tpos++;\n\tint r;\n\tif(par_exist){\n\t\tr=expression(s,pos);\n\t\tif(pos>=s.size())return NG;\n\t\tif(s[pos]!=')'){\n\t\t\treturn NG;\n\t\t}\n\t\tpos++;\n\t}else{\n\t\tr=number(s,pos);\n\t}\n\tint ret;\n\tif(l==NG||r==NG){\n\t\treturn NG;\n\t}\n\tswitch(op){\n\tcase '+':\n\t\tret= l+r;break;\n\tcase '*':\n\t\tret=l*r;break;\n\tcase'-':\n\t\tret=l-r;break;\n\tdefault:\n\t\treturn NG;\n\t}\n\tif(ret>=0&&ret<1024){\n\t\treturn ret;\n\t}else{\n\t\treturn NG;\n\t}\n}\n\nchar chars[7]={'0','1','+','-','*','(',')'};\nint main()\n{\n\tstring s;\n\tcin>>s;\n\tvi index(5);\n\tint ans=NG;\n\tfor(index[4]=0;index[4]<7;index[4]++){\n\tfor(index[3]=0;index[3]<7;index[3]++){\n\tfor(index[2]=0;index[2]<7;index[2]++){\n\tfor(index[1]=0;index[1]<7;index[1]++){\n\tfor(index[0]=0;index[0]<7;index[0]++){\n\t\tstring rep_s(s);\n\t\tint cnt=0;\n\t\tREP(i,s.size()){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tint cur_index=index[cnt];\n\t\t\t\trep_s[i]=chars[cur_index];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tbool ok_to_parse=true;\n\t\tREP(i,rep_s.size()){\n\t\t\tif(rep_s[i]=='*'){\n\t\t\t\tint left_pos;\n\t\t\t\tint par=0;\n\t\t\t\tfor(left_pos=i-1;left_pos>=0;left_pos--){\n\t\t\t\t\tbool do_break=false;\n\t\t\t\t\tswitch(rep_s[left_pos]){\n\t\t\t\t\tcase ')':par++;break;\n\t\t\t\t\tcase '(':par--;break;\n\t\t\t\t\tdefault:break;\n\t\t\t\t\t}\n\t\t\t\t\tif(par==0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint right_pos;\n\t\t\t\tpar=0;\n\t\t\t\tfor(right_pos=i+1;right_pos<rep_s.size();right_pos++){\n\t\t\t\t\tbool do_break=false;\n\t\t\t\t\tswitch(rep_s[right_pos]){\n\t\t\t\t\tcase '(':par++;break;\n\t\t\t\t\tcase ')':par--;break;\n\t\t\t\t\tdefault:break;\n\t\t\t\t\t}\n\t\t\t\t\tif(par==0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(left_pos>=0&&right_pos<rep_s.size()){\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tif(left_pos>0&&right_pos<rep_s.size()-1&&rep_s[left_pos-1]=='('&&rep_s[right_pos+1]==')'){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\trep_s.insert(rep_s.begin()+left_pos,'(');\n\t\t\t\t\t\trep_s.insert(rep_s.begin()+right_pos+2,')');\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tok_to_parse=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rep_s==\"(1+1)\"){\n\t\t\tint aaaaa=1;\n\t\t}\n\t\tint pos=0;\n\t\tint cur_ans=expression(rep_s,pos);\n\t\tif(pos!=rep_s.size())cur_ans=NG;\n\t\tans=max(ans,cur_ans);\n\t\t//cerr<<rep_s<<\" : \"<<cur_ans<<endl;\n\t}}}}}\n\tcout<<ans<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, char *> P;\n\nint ops[] = {'+', '-', '*'};\nint bs[] = {'(', ')'};\nint ds[] = {'0', '1'};\nbool f;\n\nP fact(char *p);\nP term(char *p);\nP expr(char *p);\n\nP fact(char *p){\n  if(isdigit(*p)){\n    int t = *(p++) - '0';\n    while(isdigit(*p)) t = t * 2 + *(p++) - '0';\n    if(t < 0 || t >= 1024) f = false;\n    return P(t, p);\n  } else if(*p == '('){\n    P r = expr(p + 1);\n    if(*r.second != ')') exit(0); //閉じ括弧が無いエラー\n    if(r.first < 0 || r.first >= 1024) f = false;\n    return P(r.first, r.second + 1);\n  } else{\n    exit(0); //括弧でも数字でもないエラー\n  }\n}\n\nP term(char *p){\n  P r = fact(p);\n  while(*r.second == '*' || *r.second == '/'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = fact(r.second + 1);\n    if(op == '*') r.first *= tmp;\n    else r.first /= tmp;\n  }\n  if(r.first < 0 || r.first >= 1024) f = false;\n  return r;\n}\n\nP expr(char *p){\n  P r = term(p);\n  while(*r.second == '+' || *r.second == '-'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = term(r.second + 1);\n    if(op == '+') r.first = tmp + r.first;\n    else r.first = tmp - r.first;\n  }  \n  if(r.first < 0 || r.first >= 1024) f = false;\n  return r;\n}\n\nbool is_digit(string s){\n  if(s == \"0\" || s == \"1\") return true;\n  return false;\n}\n\nbool is_operation(string s){\n  if(s == \"+\" || s == \"-\" || s == \"*\") return true;\n  return false;\n}\n\nbool is_number(string s){\n  if(is_digit(s) || ((int)s.length() >= 2 && is_number(s.substr(0, (int)s.length() - 1)) && is_digit(s.substr(s.length() - 1)))) return true;\n  return false;\n}\n\nbool check(string s){\n  int cnt = 0;\n  REP(i, s.length()){\n    if(s[i] == '(') ++cnt;\n    if(s[i] == ')') --cnt;\n    if(cnt < 0) return false;\n  }\n  return cnt == 0;\n}\n\nbool is_expression(string s);\n\nbool is_inner_expression(string s){\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      return true;\n    }\n  }\n  return false;\n}\n\nbool is_expression(string s){\n  if((int)s.length() >= 2 && s[0] == '(' && s[(int)s.length() - 1] == ')' && check(s.substr(1, (int)s.length() - 2))){\n    bool res = is_inner_expression(s.substr(1, (int)s.length() - 2));\n    return res;\n  }\n  if(is_number(s)){\n    return true;\n  }\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      return true;\n    }\n  }\n  return false;\n}\n\nbool is_invalid(char *s){\n  int sl = strlen(s);\n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')') return true;\n  if(s[sl - 1] == '+' || s[sl - 1] == '-' || s[sl - 1] == '*' || s[sl - 1] == '(') return true;\n  FOR(i, 1, sl - 1){ \n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(s[i - 1] != '.' && s[i - 1] != ')' && !isdigit(s[i - 1])) return true;\n      if(s[i + 1] != '.' && s[i + 1] != '(' && !isdigit(s[i + 1])) return true;\n    }\n    if(s[i] == ')'){\n      if(s[i - 1] != '.' && !isdigit(s[i - 1]) && s[i - 1] != ')') return true;\n      if(s[i + 1] != '.' && s[i + 1] != ')' && s[i + 1] != '+' && s[i + 1] != '-' && s[i + 1] != '*') return true;\n    }\n    if(s[i] == '('){\n      if(s[i + 1] != '.' && !isdigit(s[i + 1]) && s[i + 1] != '(') return true;\n      if(s[i - 1] != '.' && s[i - 1] != '(' && s[i - 1] != '+' && s[i - 1] != '-' && s[i - 1] != '*') return true;\n    }\n  }\n  return false;\n}\n\nint solve(int cnt, vector<int> &v, char *s){\n  //cout <<\"! \" <<s <<\", \" <<is_invalid(s) <<endl;\n  if(is_invalid(s)) return -1;\n  if(cnt >= (int)v.size()){\n    if(!is_expression(s)) return -1;\n    f = true;\n    int res = expr(s).first;\n    //cout <<\"!! \" <<res <<endl;\n    return f && res >= 0 && res < 1024 ? res : -1;\n  }\n  if(is_invalid(s)) return -1;\n  int res = -1, sl = strlen(s);\n  if(v[cnt] != 0 && v[cnt] != sl - 1){\n    REP(i, 3){ \n      s[v[cnt]] = ops[i];\n      res = max(res, solve(cnt + 1, v, s));\n      s[v[cnt]] = '.';\n    }\n  }\n  REP(i, 2){\n    s[v[cnt]] = bs[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  REP(i, 2){\n    s[v[cnt]] = ds[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  return res;\n}\n\nint main() {\n  char s[110];\n  cin >>s;\n  int sl = strlen(s);\n  vector<int> v;\n  REP(i, sl) if(s[i] == '.') v.push_back(i);\n  cout <<solve(0, v, s) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, char *> P;\n\nint ops[] = {'+', '-', '*'};\nint bs[] = {'(', ')'};\nint ds[] = {'0', '1'};\n\nP fact(char *p);\nP term(char *p);\nP expr(char *p);\n\nP fact(char *p){\n  if(isdigit(*p)){\n    int t = *(p++) - '0';\n    while(isdigit(*p)) t = t * 2 + *(p++) - '0';\n    return P(t, p);\n  } else if(*p == '('){\n    P r = expr(p + 1);\n    if(*r.second != ')') exit(0); //閉じ括弧が無いエラー\n    return P(r.first, r.second + 1);\n  } else{\n    exit(0); //括弧でも数字でもないエラー\n  }\n}\n\nP term(char *p){\n  P r = fact(p);\n  while(*r.second == '*' || *r.second == '/'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = fact(r.second + 1);\n    if(op == '*') r.first *= tmp;\n    else r.first /= tmp;\n  }\n  return r;\n}\n\nP expr(char *p){\n  P r = term(p);\n  while(*r.second == '+' || *r.second == '-'){\n    char op = *r.second;\n    int tmp = r.first;\n    r = term(r.second + 1);\n    if(op == '+') r.first = tmp + r.first;\n    else r.first = tmp - r.first;\n  }\n  return r;\n}\n\nbool is_digit(string s){\n  if(s == \"0\" || s == \"1\") return true;\n  return false;\n}\n\nbool is_operation(string s){\n  if(s == \"+\" || s == \"-\" || s == \"*\") return true;\n  return false;\n}\n\nbool is_number(string s){\n  if(is_digit(s) || ((int)s.length() >= 2 && is_number(s.substr(0, (int)s.length() - 1)) && is_digit(s.substr(s.length() - 1)))) return true;\n  return false;\n}\n\nbool check(string s){\n  int cnt = 0;\n  REP(i, s.length()){\n    if(s[i] == '(') ++cnt;\n    if(s[i] == ')') --cnt;\n    if(cnt < 0) return false;\n  }\n  return cnt == 0;\n}\n\nbool is_expression(string s);\n\nbool is_inner_expression(string s){\n  //cout <<\"inner_exp \" <<s <<endl;\n  FOR(i, 1, (int)s.length() - 1){\n    //cout <<\"left \" <<s.substr(0, i) <<\", right \" <<s.substr(i + 1) <<endl;\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nbool is_expression(string s){\n  //cout <<\"exp \" <<s <<endl;\n  if((int)s.length() >= 2 && s[0] == '(' && s[(int)s.length() - 1] == ')' && check(s.substr(1, (int)s.length() - 2))){\n    bool res = is_inner_expression(s.substr(1, (int)s.length() - 2));\n    //cout <<(res ? \"true\" : \"false\") <<endl;\n    return res;\n  }\n  if(is_number(s)){\n    //cout <<\"true\" <<endl;\n    return true;\n  }\n  FOR(i, 1, (int)s.length() - 1){\n    if(is_operation(s.substr(i, 1)) && is_expression(s.substr(0, i)) && is_expression(s.substr(i + 1))){\n      //cout <<\"true\" <<endl;\n      return true;\n    }\n  }\n  //cout <<\"false\" <<endl;\n  return false;\n}\n\nint solve(int cnt, vector<int> &v, char *s){\n  //cout <<\"! \" <<s <<\", \" <<is_expression(s) <<endl;\n  if(cnt >= (int)v.size()){\n    if(!is_expression(s)) return -1;\n    int res = expr(s).first;\n    return res >= 0 && res < 1024 ? res : -1;\n  }\n  int res = -1, sl = strlen(s);\n  if(v[cnt] != 0 && v[cnt] != sl - 1){\n    int l = v[cnt] - 1, r = v[cnt] + 1;\n    REP(i, 3){\n      s[v[cnt]] = ops[i];\n      res = max(res, solve(cnt + 1, v, s));\n      s[v[cnt]] = '.';\n    }\n  }\n  REP(i, 2){\n    s[v[cnt]] = bs[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  REP(i, 2){\n    s[v[cnt]] = ds[i];\n    res = max(res, solve(cnt + 1, v, s));\n    s[v[cnt]] = '.';\n  }\n  return res;\n}\n\nint main() {\n  char s[110];\n  cin >>s;\n  int sl = strlen(s);\n  vector<int> v;\n  REP(i, sl) if(s[i] == '.') v.push_back(i);\n  cout <<solve(0, v, s) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1<<10)\nusing namespace std;\n\nstring s;\nvector<int> idx;\nvector<char> c;\nchar lis[7]={'0','1','+','-','*','(',')'};\nint ans=-1, p, flag;\n\nbool check(){\n\n  int r=0, f=0;\n\n  for(int i=p;i<s.size();i++){\n    if(r==1&&(s[i]=='+'||s[i]=='-'||s[i]=='*')) f=1;\n    if(s[i]=='(') r++;\n    if(s[i]==')') r--;\n    if(r==0) break;\n  }\n  \n  return f==1;\n}\n\nint bnf();\n\nint bnf3(){\n\n  int res=0;\n  \n  if(s[p]=='('){\n    \n    bool r=check();\n    \n    p++;\n    res=bnf();\n    p++;\n   \n    if(!r) flag=1;\n    \n    return res;\n  }\n\n  if(!('0'<=s[p]&&s[p]<='1')) flag=1;\n  \n  while('0'<=s[p]&&s[p]<='1') res=res*2+s[p]-'0', p++;\n\n  return res;\n}\n\nint bnf2(){\n  \n  int res=bnf3();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='*'){\n      p++;\n      res=res*bnf3();\n      if(res>=INF) res=INF;\n    }else{\n      if(p<s.size()&&s[p]!=')'&&s[p]!='+'&&s[p]!='-') flag=1;\n      break;\n    }\n    \n  }\n\n  return res;\n}\n\nint bnf(){\n\n  int res=bnf2();\n  \n  while(p<s.size()){\n    \n    if(s[p]=='+'){\n      p++;\n      res=res+bnf2();\n      if(res>=INF) res=INF;\n    }\n    else if(s[p]=='-'){\n      p++;\n      res=res-bnf2();\n    }else{\n      if(p<s.size()&&s[p]!=')') flag=1;\n      break;\n    }\n  }\n  \n  return res;\n}\n\nbool check2(){\n  \n  int r=0;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='(') r++;\n    if(s[i]==')'){\n      if(!r) return false;\n      r--;\n    }\n  }\n\n  if(r) return false;\n\n  return true;\n}\n\nvoid dfs(int x){\n  \n  if(x==idx.size()){\n    \n    for(int i=0;i<idx.size();i++)\n      s[idx[i]]=c[i];\n    \n    p=0, flag=0;\n    \n    if(!check2()) return ;\n    \n    int r=bnf();\n    \n    if(r>=INF||flag) return ;\n\n    ans=max(ans,r);\n    \n    return ;\n  }\n  \n  for(int i=0;i<7;i++){\n    \n    c[x]=lis[i];\n    \n    dfs(x+1);\n    \n  }\n  \n}\n\nint main(){\n\n  cin>>s;\n  \n  for(int i=0;i<s.size();i++)\n    if(s[i]=='.') idx.push_back(i);\n\n  c.resize(idx.size());\n\n  dfs(0);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main()\n{\ncout<< 6 << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nchar rp[]={'0','1','+','-','*','(',')'};\n \nvector<string> check(vector<string> ss){\n    vector<string> ans;\n    for(string x:ss){\n        bool sw=true;\n        int c=0;\n        for(int i=0;i<x.size()&&sw;i++){\n            if(x[i]=='(')c++;\n            if(x[i]==')')c--;\n            if(c<0)sw=false;\n        }\n        if(!c){\n            ans.push_back(x);\n        }\n    }\n    return ans;\n}\n \nvector<string> rek(vector<string> ss){\n    vector<string> ans;\n    int t;\n    if(ss[0].find(\".\")!=string::npos){\n        bool sw=true;\n        for(int i=0;i<ss[0].size()&&sw;i++){\n            if(ss[0][i]=='.'){\n                t=i;\n                sw=false;\n            }\n        }\n        for(string s:ss){\n            for(int i=0;i<7;i++){\n                s[t]=rp[i];\n                ans.push_back(s);\n            }\n        }\n        ans=rek(ans);\n        return ans;\n    }\n    else{\n        return ss;\n    }\n}\n \nint ana(string s){\n    if(s.size()==0)return -1;\n    if(*s.begin()=='('&&*(s.end()-1)==')'){\n        s=s.substr(1,s.size()-2);\n    }\n    int res;\n    int c=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n            if(!c&&s[i]=='*'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a*b;\n                return(res>=0&&res<1024?res:-1);\n            }\n    }\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(')c++;\n        if(s[i]==')')c--;\n        if(!c&&s[i]=='+'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a+b;\n            return(res>=0&&res<1024?res:-1);\n        }\n        if(!c&&s[i]=='-'){\n            int a=ana(s.substr(0,i));\n            int b=ana(s.substr(i+1,s.size()-i-1));\n            if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n            res=a-b;\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    // if(*s.begin()=='('&&*(s.end()-1)==')'){\n    //     ///////\n    //     if(str.find(\"+\")==string::npos&&str.find(\"-\")==string::npos&&str.find(\"*\")==string::npos)return -1;\n    //     res=ana(s.substr(1,s.size()-2));\n    //     return (res>=0&&res<1024?res:-1);\n    // }\n    if(s.find(\"(\")!=string::npos)return -1;\n    else{\n        res=stoi(s,nullptr,2);\n        return(res>=0&&res<1024?res:-1);\n    }\n    return -1;\n}\n \n \nvoid solve(string s){\n    int ans=-1,anssub=0;\n    vector<string> ss;\n    ss.push_back(s);\n    ss=rek(ss);\n    ss=check(ss);\n    for(string x:ss){\n        anssub=ana(x);\n        if(anssub<1024&&anssub>=0)ans=max(ans,anssub);\n        //cout<<x<<\"  \"<<anssub<<endl;\n    }\n    cout<<ans<<endl;\n     \n     \n     \n}\n \nint main(){\n    string s;\n    cin>>s;\n    solve(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\nstring tract(string s){\n  rep(i,s.size()){\n    if(s[i]=='k')return \"k\";\n  }\n  // まず数字を全てfに変える\n  string s_tmp(s);\n  while(1){\n    // 数字あるかチェック\n    int index = 0,flag=0;\n    while(index<s_tmp.size()){\n      if(s_tmp[index]=='0'||s_tmp[index]=='1'){flag=1;break;}\n      index++;\n    }\n    if(!flag)break;\n    int index_e=index;\n    while(index_e<s_tmp.size()){\n      if(s_tmp[index_e]=='0'||s_tmp[index_e]=='1')index_e++;\n      else break;\n    }\n    s_tmp = s_tmp.substr(0,index)+\"f\"+s_tmp.substr(index_e,s_tmp.size()-index_e);\n  }\n  while(1){\n\n    stack<int> left,right;\n    int index=0;\n    rep(i,s_tmp.size()){\n      if(s_tmp[i]=='(')left.push(i);\n      else if(s_tmp[i]==')')right.push(i);\n    }\n    if(left.size()!=right.size())return \"k\";\n    if(left.size()>0){\n      int il = left.top();\n      int ir = il;\n      while(ir<s_tmp.size()){\n        if(s_tmp[ir]==')')break;\n        ir++;\n      }\n      string tmp = tract(s_tmp.substr(il+1,ir-il-1));\n      if (tmp==\"k\"||tmp==\"f\")return \"k\";\n      else if(tmp==\"e\"){\n        s_tmp = s_tmp.substr(0,il)+\"f\"+s_tmp.substr(ir+1,s_tmp.size()-ir-1);\n        continue;\n      } \n    } else {\n      // ()がない場合\n      int flag = 0;\n      rep(i,s_tmp.size()){\n        if(s_tmp[i]=='+'||s_tmp[i]=='-'||s_tmp[i]=='*'){\n          if(s_tmp[i+1]!='f'&&s_tmp[i+1]!='e'){\n            flag = 1; // ダメ\n            break;\n          } else if(s_tmp[i-1]!='f'&&s_tmp[i-1]!='e'){\n            flag = 1;\n            break;\n          }\n        } else { // s_tmp[i]=='f' or 'e'\n          if(s_tmp[i+1]=='f'||s_tmp[i+1]=='e'){\n            flag = 1;\n          } else if(s_tmp[i-1]=='f'||s_tmp[i-1]=='e'){\n            flag = 1;\n          }\n        }\n      }\n      if (flag)return \"k\";\n      else return \"e\";\n    }\n  }\n}\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint  expression(State &begin);\nint factor(State &begin);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\nint term(State &begin){\n  int ret = factor(begin);\n  int flag = 0;\n  if(!inner(ret))return -INF;\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin);\n      if(!inner(tmp))return -INF;\n      ret *= tmp;\n      flag = 1;\n    } else {\n      break;\n    }\n  }\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// 式のパース\nint expression(State &begin){\n  int ret = term(begin);\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return -INF;\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin);\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin);\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    } else {\n      break;\n    }\n  }\n  if(!flag)return -INF;\n  if(!inner(ret))return -INF;\n  return ret;\n}\n\n// ()のパース\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return -INF;\n  } else {\n    int k = number(begin);\n    return k;\n  }\n}\n\nint main(){\n\n  string s;\n  cin >> s;\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    // 括弧の対応をチェック\n    int sum = 0,flag=0;\n    rep(i,sc.size()){\n      if(sc[i]=='(')sum++;\n      if(sc[i]==')')sum--;\n      if(sum<0)flag=1;\n    }\n    if(sum!=0)flag=1;\n    string tm;\n    if(!flag){\n      tm = tract(sc);\n    } else {\n      tm = \"k\";\n    }\n    if(tm==\"k\")flag=1;\n    State begin = sc.begin();\n    tmp = expression(begin);\n    if(!flag&&tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct value {\n    int val, idx;\n    bool prim;\n    value(int v,int i,bool p) : val(v), idx(i), prim(p) {;}\n};\nbool operator==(const value &v,const value &w) {\n    return v.val == w.val && v.idx == w.idx && v.prim == w.prim;\n}\nbool operator!=(const value &v,const value &w) {\n    return !(v == w);\n}\n\nconst char ONE = '1';\nconst char ZERO = '0';\nconst value ERROR = value(-1,-1,true);\nconst int MIN_VALUE = 0;\nconst int MAX_VALUE = 1023;\n\nvalue prim_exp(const string &s,int idx);\nvalue exp(const string &s,int idx);\nvalue mul_exp(const string &s,int idx);\nvalue number(const string &s,int idx);\n\nvalue number(const string &s,int idx = 0) {\n    if (s[idx] != ZERO && s[idx] != ONE) return ERROR;\n    int ret = 0;\n    while(true) {\n        if((s[idx] != ONE && s[idx] != ZERO)\n           || s.length() <= idx) break;\n        ret <<= 1;\n        ret += s[idx] - ZERO;\n        if (ret < MIN_VALUE || ret > MAX_VALUE) return ERROR;\n        idx++;\n    }\n    if (ret < MIN_VALUE || ret > MAX_VALUE) return ERROR;\n    //cout<<\"found number:\"<<ret<<\" \"<<idx<<endl;\n    return value(ret, idx, true);\n}\n\nvalue prim_exp(const string &s, int idx = 0) {\n    if (s[idx] == ZERO || s[idx] == ONE) return number(s,idx);\n    if (s[idx] == '(') {\n        value inner = exp(s, idx+1);\n        if (inner.idx == s.length() || inner == ERROR) return ERROR;\n        //cout<<\"return from prim_exp:\"<<inner.idx<<\",\"<<s[inner.idx]<<endl;\n        if (s[inner.idx] != ')') return ERROR;\n        if (inner.prim) return ERROR;\n        //cout<<\"return ff:\"<<inner.val<<\" \"<<inner.idx+1<<endl;\n        return value(inner.val, inner.idx+1, true);\n    }\n    return ERROR;\n}\n\nvalue mul_exp(const string &s, int idx = 0) {\n    value p = prim_exp(s, idx);\n    int v = p.val;\n    idx = p.idx;\n    bool pr = p.prim;\n    while(true) {\n        if (idx == s.length() || s[idx] == '+' || s[idx] == '-'\n            || s[idx] == ')') break;\n        if (s[idx] != '*') return ERROR;\n        value right = prim_exp(s,idx+1);\n        //cout<<\"return from prim:\"<<right.idx<<\" \"<<s[right.idx]<<endl;\n        if(right == ERROR) return ERROR;\n        v *= right.val;\n        if (v < MIN_VALUE || v > MAX_VALUE) return ERROR;\n        idx = right.idx;\n        pr = false;\n    }\n\n    return value(v, idx, pr);\n}\n\nvalue exp(const string &s,int idx = 0) {\n    value p = mul_exp(s,idx);\n    int v = p.val;\n    idx = p.idx;\n    bool pr = p.prim;\n    while(true) {\n        if (idx == s.length() || s[idx] == ')') break;\n        char op = s[idx];\n        //cout<<\"op!:\"<<op<<endl;\n        if (op != '+' && op != '-') return ERROR;\n        value right = mul_exp(s,idx+1);\n        //cout<<\"return from mul_exp:\"<<right.idx<<\" \"<<s[right.idx]<<endl;\n        if (right == ERROR) return ERROR;\n        switch(op) {\n        case '+':\n            v += right.val;\n            break;\n        case '-':\n            v -= right.val;\n            break;\n        }\n\n        if (v < MIN_VALUE || v > MAX_VALUE) return ERROR;\n        idx = right.idx;\n        pr = false;\n    }\n    return value(v, idx, pr);\n}\n\nchar letter[7] = {'0', '1', '+', '-', '*', '(', ')'};\n\nint main() {\n    string input;\n    cin>>input;\n\n    int num = 0;\n    for (int i=0; i<input.length(); ++i)\n        if(input[i] == '.') num++;\n\n    int ans = -1;\n    vector<int> perm(num, 0);\n    while(true) {\n\n        string in = input;\n        int cnt = 0;\n        for (int i=0; i<in.length(); ++i)\n            if(in[i] == '.') in[i] = letter[perm[cnt++]];\n\n        value v = exp(in, 0);\n        if (v != ERROR && v.idx == in.length()) {\n            ans = max(ans, v.val);\n        }\n\n        for (int i=0; i<num; ++i) {\n            if(perm[i] == 6) {\n                perm[i] = 0;\n            } else {\n                perm[i]++;\n                break;\n            }\n        }\n\n        bool end = true;\n        for (int i=0; i<num; ++i)\n            if(perm[i] != 6) end = false;\n        if (end) break;\n    }\n\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstring s;\nint p;\nint expr(){\n\tif(isdigit(s[p])){\n\t\tint d = 0;\n\t\twhile(p < s.size() && isdigit(s[p])){\n\t\t\td *= 2; d += s[p++] - '0';\n\t\t\tif(d >= 1 << 10) throw \"bigdigit\";\n\t\t}\n\t\treturn d;\n\t}\n\t\n\tif(s[p++] != '(') throw \"openp\";\n\t\n\tint a = expr();\n\tif(s[p] != '+' && s[p] != '-' && s[p] != '*') throw \"op\";\n\tchar op = s[p++];\n\tint b = expr();\n\t\n\tif(s[p++] != ')') throw \"closep\";\n\t\n\tint res;\n\tif(op == '+') res = a + b;\n\tif(op == '-') res = a - b;\n\tif(op == '*') res = a * b;\n\tif(res < 0 || res >= 1 << 10) throw \"overflow\";\n\treturn res;\n}\n\nint main(){\n\tcin >> s;\n\tvi v;\n\trep(i, s.size()) if(s[i] == '.') v.pb(i);\n\tint pw[10], ans = -1;\n\tpw[0] = 1;\n\trep(i, 9) pw[i + 1] = pw[i] * 7;\n\t\n\trep(i, pw[v.size()]){\n\t\trep(j, v.size()) s[v[j]] = \"01+-*()\"[i / pw[j] % 7];\n\t\tp = 0;\n\t\ttry{\n\t\t\tint res = expr();\n\t\t\tif(p < s.size()) throw \"syntaxerror\";\n\t\t\tans = max(ans, res);\n\t\t}catch(const char *e){\n\t\t\t\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc {\n  private:\n    int N, idx;\n    string s;\n    \n  public:\n    Calc (const string& s) : s{s} {\n        idx = 0;\n        N = s.size();\n    }\n\n    static bool is_op(char c)\n    {\n        return (c == '+' || c == '-' || c == '*');   \n    }\n\n    bool check_range(int x)\n    {\n        return (0 <= x && x < 1024);\n    }\n    \n    int num()\n    {\n        int res = 0, p = 0;\n        while (isdigit(s[idx])) {\n            if (p > 10 && s[idx] == '1') return -1;\n            res *= 2;\n            res += (s[idx] - '0');\n            p++;\n            ++idx;\n        }        \n        return (check_range(res) ? res : -1);\n    }\n\n    bool check_op(int cur)\n    {\n        int p = 0;\n        for (int i = cur + 1; i < N; i++) {\n            if (s[i] == '(') p++;\n            if (s[i] == ')') p--;\n            if (p == 0 && is_op(s[i])) return 1;\n            if (p < 0) break;\n        }\n        return 0;\n    }\n    \n    int fact()\n    {\n        int ret = -1;\n        if (s[idx] == '(') {\n            if (!check_op(idx)) throw 0;\n            ++idx;\n            ret = expr();\n            if (!check_range(ret)) throw 0; \n            ++idx;\n        } else {\n            ret = num();\n        }\n        return ret;\n    }\n\n    int term()\n    {\n        int ret = fact();\n        while (s[idx] == '*') {\n            ++idx;\n            ret *= fact();\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n\n    int expr()\n    {\n        int ret = term();\n\n        while (s[idx] == '+' || s[idx] == '-') {\n            if (s[idx] == '+') {\n                ++idx;\n                ret += term();\n            } else {\n                ++idx;\n                ret -= term();\n            }\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n};\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid(const string& s)\n{\n    int p = 0, N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (Calc::is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || Calc::is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || Calc::is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n\n        if (s[i] == '(') {\n            if (i == N - 1) return 0;\n            if (i > 0 && isdigit(s[i - 1])) {\n                return 0;\n            }\n        }\n        \n        if (s[i] == ')') {\n            if (i == 0) return 0;\n            if (i < N - 1 && isdigit(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n\n        for (int j = i + 1; j < N; j++) {\n            if (s[i] == '(' && s[j] == ')' && j - i < 4) {\n                return 0;\n            }\n        }\n    }\n    return (p == 0);\n}\n\nint solve(string& s)\n{\n    int N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        if (!valid(s)) return -1;\n        Calc calc(s);\n        int res = -1;\n        \n        try {\n            res = calc.expr();\n        } catch (...) {}\n        \n        return res;\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid(s)) {\n            Calc calc(s);\n            try {\n                res = max(res, calc.expr());\n            } catch (...) {}\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    cout << solve(s) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint is_digit(char c) {\n  return c == '0' || c == '1';\n}\n\nint is_valid(int n) {\n  return 0 <= n && n <= 1024;\n}\n\nint number(string &line, size_t &i) {\n  int n = 0;\n  while (is_digit(line[i])) {\n    n = 2 * n + (line[i] - '0');\n    ++i;\n  }\n  return n;\n}\n\nint expr(string &, size_t &);\n\nint fact(string &line, size_t &i) {\n  int n;\n  if (line[i] == '(') {\n    ++i;\n    n = expr(line, i);\n    ++i;\n  } else if (is_digit(line[i])) {\n    n = number(line, i);\n  } else {\n    i = line.size() + 1;\n    return -1;\n  }\n  return n;\n}\n\nint term(string &line, size_t &i) {\n  int n = fact(line, i);\n  int out_num = line.size() + 1;\n  while (i < line.size()) {\n    if (line[i] == '*') {\n      ++i;\n      n *= fact(line, i);\n      if (!is_valid(n)) {\n        i = out_num;\n      }\n    } else {\n      return n;\n    }\n  }\n  return n;\n}\n\nint expr(string &line, size_t &i) {\n  int m;\n  int n = term(line, i);\n  int out_num = line.size() + 1;\n  while (i < line.size()) {\n    if (line[i] == '+' || line[i] == '-') {\n      char op = line[i];\n      ++i;\n      m = term(line, i);\n      if (op == '+') {\n        n += m;\n      } else {\n        n -= m;\n      }\n      if (!is_valid(n)) {\n        i = out_num;\n      }\n    } else if (line[i] == ')') {\n      return n;\n    } else {\n      i = out_num;\n    }\n  }\n  return n;\n}\n\nbool is_balanced(const string &line) {\n  int depth = 0;\n  int count[100];\n  for (int i = 0; i < 100; ++i) {\n    count[i] = 0;\n  }\n  for (size_t i = 0; i < line.size(); ++i) {\n    if (line[i] == '(') {\n      ++depth;\n    } else if (line[i] == ')') {\n      if (depth == 0 || count[depth] == 0) {\n        return false;\n      }\n      count[depth] = 0;\n      --depth;\n    } else if (line[i] == '+' || line[i] == '-' || line[i] == '*') {\n      ++count[depth];\n    }\n  }\n  return depth == 0;\n}\n\nint eval(string &line) {\n  if (is_balanced(line)) {\n    size_t i = 0;\n    int n = expr(line, i);\n    if (i == line.size()) {\n      return n;\n    }\n  }\n  return -1;\n}\n\nint solve(string &line, size_t i = 0) {\n  const char *chars = \"01+-*()\";\n  while (i < line.size()) {\n    if (line[i] == '.') {\n      int retval = -1;\n      for (size_t j = 0; chars[j]; ++j) {\n        line[i] = chars[j];\n        retval = max(retval, solve(line, i + 1));\n      }\n      line[i] = '.';\n      return retval;\n    }\n    ++i;\n  }\n  return eval(line);\n}\n\nint main() {\n  string line;\n  cin >> line;\n  cout << solve(line) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define IS_OPE(c) (c == '+' || c == '-' || c == '*')\n#define IS_NUM(c) (c == '0' || c == '1')\n\nstring s;\nint cur;\nvector<int> comm;\n\nconst char* code = \"01+-*()\";\n\nint num() {\n  int res = 0;\n  while(cur < s.size()) {\n    char c = s[cur];\n    if(!IS_NUM(c)) break;\n    res = 2*res + (c - '0');\n    ++cur;\n  }\n  return res;\n}\n\nint exp(bool *f_op);\n\nint ident() {\n  char c = s[cur];\n  if(IS_NUM(c)) {\n    return num();\n  } else if(c == '('){\n    ++cur;\n    bool d = true;\n    int res = exp(&d);\n    if(s[cur++] != ')') {\n      return -1;\n    }\n    return res;\n  } else {\n    return -1;\n  }\n}\n\nint prod(bool *f_op) {\n  char c;\n  int res = 1;\n  while(1) {\n    int v = ident();\n    if(v < 0) return -1;\n    res *= v;\n    if(res < 0 || (1<<10) <= res) return -1;\n    if(cur >= s.size() || (c=s[cur]) != '*') {\n      break;\n    }\n    *f_op = false;\n    ++cur;\n    if(cur >= s.size()) {\n      return -1;\n    }\n  }\n  return res;\n}\n\nint exp(bool *f_op) {\n  char c = '+';\n  int res = 0;\n  while(1) {\n    int v = prod(f_op);\n    if(v < 0) return -1;\n    res += (c == '+' ? v : -v);\n    if(res < 0 || (1<<10) <= res) return -1;\n    if(cur >= s.size() || !(c = s[cur]) || (c != '+' && c != '-')) {\n      break;\n    }\n    *f_op = false;\n    ++cur;\n    if(cur >= s.size()) {\n      return -1;\n    }\n  }\n  if(*f_op) {\n    return -1;\n  }\n\n  return res;\n}\n\nint parse() {\n  // check\n  int pa = 0;\n  rep(i, s.size()) {\n    if(s[i] == '(') ++pa;\n    if(s[i] == ')') --pa;\n  }\n  if(pa != 0) return -1;\n\n  rep(i, s.size()-1) {\n    if(IS_OPE(s[i]) && IS_OPE(s[i+1])) return -1;\n  }\n  cur = 0;\n\n  //cout << s << endl;\n\n  bool d = false;\n\n  int r = exp(&d);\n  if(cur != s.size()) r = -1;\n  return r;\n}\n\nint dfs(int c) {\n  if(comm.size() == c) {\n    return parse();\n  }\n  int res = -1;\n  rep(i, 7) {\n    s[comm[c]] = code[i];\n    int r = dfs(c + 1);\n    res = maxd(r, res);\n  }\n  return res;\n}\n\nint main() {\n  cin >> s;\n  rep(i, s.length()) {\n    if(s[i] == '.') {\n      comm.push_back(i);\n    }\n  }\n  cout << dfs(0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint formula(int &p,bool inper);\npair<int,bool> term1(int &p);\nint term2(int &p);\nint get_num(int &p);\n\nint calc(int lhs,int rhs,char op){\n  int res=-1;\n  if(lhs==-1 || rhs==-1) return -1;\n  if(op=='+') res=lhs+rhs;\n  if(op=='-') res= lhs-rhs;\n  if(op=='*') res= lhs*rhs;\n  return (0<=res && res<1024) ? res : -1;\n}\n\nstring s;\nint formula(int &p,bool inper=false){\n  bool isok=!inper;\n  pair<int,bool> ret=term1(p);\n  int res=ret.first;\n  isok|=ret.second;\n  while(p<s.size() && s[p]!=')'){\n    char op=s[p];\n    if(op!='+' && op!='-'){\n      return -1;\n    }\n    isok=true;\n    p++;\n    int rhs=term1(p).first;\n    res=calc(res,rhs,op);\n  }\n  if(!inper && s[p]==')') return -1;\n  return isok ? res : -1;\n}\n\npair<int,bool> term1(int &p){\n  int res=term2(p);\n  bool res2=false;\n  while(p<s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n    char op=s[p];\n    p++;\n    if(op!='*'){\n      return {-1,0};\n    }\n    res2=true;\n    int rhs=term2(p);\n    res=calc(res,rhs,op);\n  }\n  return {res,res2};\n}\n\nint term2(int &p){\n  int res=-1;\n  if(s[p]=='('){\n    p++;\n    res=formula(p,true);\n    if(s[p]!=')') return -1;\n    p++;\n  }\n  else if(isdigit(s[p])){\n    res=get_num(p);\n  }\n  else{\n    return -1;\n  }\n  return res;\n}\n\nint get_num(int &p){\n  int res=-1;\n  while(isdigit(s[p])){\n    if(res==-1) res=0;\n    res*=2;\n    res+=(s[p]-'0');\n    p++;\n  }\n  //cout<<res<<endl;\n  if(res>=1024) return -1;\n  return res;\n}\n\nstring ch=\"01+-*()\";\n\nint dfs(int i){\n  if(i==s.size()){\n    int p=0;\n    //cout<<s<<endl;\n    int res=formula(p);\n    //cout<<res<<endl;\n    return res;\n  }\n  if(s[i]=='.'){\n    int res=-1;\n    for(int j=0;j<ch.size();j++){\n      s[i]=ch[j];\n      res=max(res,dfs(i+1));\n      s[i]='.';\n    }\n    return res;\n  }\n  else{\n    return dfs(i+1);\n  }\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstring ch = \"01+-*()\";\nint ans = -1;\n\nint expression(const string& s, int& k);\nint factor(const string& s, int& k);\nint term(const string& s, int& k);\n\n// 数字が [0,1023] かチェック\nbool valid(const int n){\n\treturn (0 <= n && n < 1024);\n}\n\n// <number> ::= <digit> | <number> <digit>\nint number(const string& s, int& k){\n\tint r = 0;\n\twhile( s[k] == '0' || s[k] == '1' ){\n\t\tr = r * 2 + (s[k] - '0');\n\t\t++k;\n\t}\n\treturn r;\n}\n\nint expression(const string& s, int& k){\n\tint r1 = term(s, k);\n\tif( !valid(r1) ) return -1;\n\t\n\t/*while( k < s.size() ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}*/\n\twhile( s[k] == '+' || s[k] == '-' ){\n\t\tif( s[k] == '+' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1+r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 + r2;\n\t\t}else if( s[k] == '-' ){\n\t\t\t++k;\n\t\t\tint r2 = term(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1-r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 - r2;\n\t\t}\n\t}\n\treturn r1;\n}\n\nint factor(const string& s, int& k){\n\tif( s[k] == '(' ){ // 括弧のはじまりのとき\n\t\t++k; // '(' の 1つ先に進める.\n\t\tint r = expression(s, k);\n\t\t// 数字が [0,1023] の範囲にない or ')' がないとき\n\t\tif( !valid(r) || s[k] != ')' ) return -1;\n\t\t\n\t\t++k; // ')' の 1つ先に進める.\n\t\treturn r;\n\t}else if( s[k] == '0' || s[k] == '1' ){ // 数字のとき\n\t\treturn number(s, k);\n\t}else{\n\t\treturn -1;\n\t}\n}\n\nint term(const string& s, int& k){\n\tint r1 = factor(s, k);\n\t// 数字が [0,1023] の範囲にないとき \n\tif( !valid(r1) ) return -1;\n\t\n\t/*while( k < s.size() ){\n\t\tif( s[k] == '*' ){\n\t\t\t++k;\n\t\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t\t// 数字が [0,1023] の範囲にないとき\n\t\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\t\tr1 = r1 * r2;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}*/\n\twhile( s[k] == '*' ){\n\t\t++k;\n\t\tint r2 = factor(s, k);\n\t\t\t\n\t\t// 数字が [0,1023] の範囲にないとき\n\t\tif( !valid(r2) || !valid(r1*r2) ) return -1;\n\t\t\t\n\t\tr1 = r1 * r2;\n\t}\n\treturn r1;\n}\n\n// 式が正しいかどうか.\nbool check(const string& s){\n\tint par = 0;\n\tchar prev = '\\0';\n\tdeque<bool> op(100, false);\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( prev == '\\0' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '(' ){\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == '0' || prev == '1' ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}\n\t\t\tprev = s[i];\n\t\t}else if( prev == '+' || prev == '-' || prev == '*' ){\n\t\t\tif( par > 0 ){\n\t\t\t\top[par] = true;\n\t\t\t}\n\t\t\tif( s[i] == '0' || s[i] == '1' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == '(' ){\n\t\t\t\t++par;\n\t\t\t\tprev = s[i];\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if( prev == ')' ){\n\t\t\tif( s[i] == '+' || s[i] == '-' || s[i] == '*' ){\n\t\t\t\tprev = s[i];\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tif( par < 0 || !op[par] ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\top[par] = false;\n\t\t\t\t--par;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// '.' の置き換えを全部調べる.\nvoid dfs(string s, const vector<int>& v, int pos){\n\tif( pos == v.size() ){ // '.' を全部置き換えた後\n\t\tint t=0;\n\t\t// 式が正しいときだけ解を更新.\n\t\tif( check(s) ){\n\t\t\tint res = expression(s, t);\n\t\t\tans = max( ans , res );\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < ch.size() ; i++ ){\n\t\tchar tmp = s[v[pos]];\n\t\ts[v[pos]] = ch[i];\n\t\tdfs( s , v , pos+1 );\n\t\ts[v[pos]] = tmp;\n\t}\n}\n\nint main(){\n\t// v[i] := 文字列 s について i 番目の'.' の位置 k を返す.(s[v[i]] == '.')\n\tvector<int> v;\n\tstring s;\n\tcin >> s;\n\t\n\t// '.' のある位置をチェック\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '.' ) v.push_back(i);\n\t}\n\t// DFSで全探索 ('.'が高々5個, 文字が7種類なので7^5通りしかない)\n\tdfs( s, v, 0 );\n\t// 解の出力 (解が存在しないときは-1)\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num]))n = n * 2 + s[num++] - '0';\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\tsc.push(s[i]);\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.empty()){\n\t\t\tans = expr(s, num);\n\t\t\tma = max(ma, ans);\n\t\t}\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\ntypedef complex<lli> P;\n\nbool check(lli x) {\n  if(x < 0 || x >= (1<<10)) {\n    throw 0;\n  }\n}\n\nlli toDec(string bs) {\n  lli res = 0;\n  reverse(bs.begin(), bs.end());\n  for(lli i = 0; i < bs.size(); ++i) {\n    res |= ((lli)(bs[i] - '0')) << i;\n    check(res);\n  }\n  return res;\n}\n\nlli p;\nstring s;\nP exp();\nP term();\nP fact();\n\nP exp() {\n  P x = term();\n  while(1) {\n    if(s[p] == '+') {\n      ++p;\n      x += term();\n      x.imag() += 1;\n    } else if(s[p] == '-') {\n      ++p;\n      x -= term();\n      x.imag() += 1;\n    } else {\n      break;\n    }\n    check(x.real());\n  }\n  return x;\n}\n\nP term() {\n  P x = fact();\n  while(1) {\n    if(s[p] == '*') {\n      ++p;\n      P y = fact();\n      x.real() *= y.real();\n      x.imag() += y.imag() + 1;\n    } else {\n      break;\n    }\n    check(x.real());\n  }\n  return x;\n}\n\nP fact() {\n  P x;\n  if(s[p] == '(') {\n    ++p;\n    x = exp();\n    if(x.imag() == 0) throw 0;\n    x.imag() = 0;\n    if(s[p] != ')') throw 0;\n    ++p;\n  } else if(isdigit(s[p])) {\n    string num;\n    while(isdigit(s[p])) {\n      num += s[p++];\n    }\n    x = P(toDec(num), 0);\n  } else {\n    throw 0;\n  }\n  return x;\n}\n\nconst string C = \"01+-*()\";\n\nlli rec(int k) {\n  if(k == s.size()) {\n    lli res = -1;\n    try {\n      p = 0;\n      lli tmp = exp().real();\n      if(s[p] != '$') throw 0;\n      res = tmp;\n    } catch(...) {}\n    return res;\n  } else {\n    if(s[k] == '.') {\n      lli res = -1;\n      for(int i = 0; i < C.size(); ++i) {\n        s[k] = C[i];\n        res = max(res, rec(k + 1));\n      }\n      s[k] = '.';\n      return res;\n    } else {\n      return rec(k + 1);\n    }\n  }\n}\n\nint main() {\n  while(cin >> s) {\n    s += \"$\";\n    cout << rec(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc {\n  private:\n    int N, idx;\n    string s;\n    \n  public:\n    Calc (const string& s) : s{s} {\n        idx = 0;\n        N = s.size();\n    }\n\n    static bool is_op(char c)\n    {\n        return (c == '+' || c == '-' || c == '*');   \n    }\n\n    bool check_range(int x)\n    {\n        return (0 <= x && x < 1024);\n    }\n    \n    int num()\n    {\n        int res = 0, p = 0;\n        while (isdigit(s[idx])) {\n            if (p > 10 && s[idx] == '1') return -1;\n            res *= 2;\n            res += (s[idx] - '0');\n            p++;\n            ++idx;\n        }        \n        return (check_range(res) ? res : -1);\n    }\n\n    bool check_op(int cur)\n    {\n        int p = 0;\n        for (int i = cur + 1; i < N; i++) {\n            if (s[i] == '(') p++;\n            if (s[i] == ')') p--;\n            if (p == 0 && is_op(s[i])) return 1;\n            if (p < 0) break;\n        }\n        return 0;\n    }\n    \n    int fact()\n    {\n        int ret = -1;\n        if (s[idx] == '(') {\n            if (!check_op(idx)) throw 0;\n            ++idx;\n            ret = expr();\n            ++idx;\n        } else {\n            ret = num();\n        }\n        if (!check_range(ret)) throw 0;         \n        return ret;\n    }\n\n    int term()\n    {\n        int ret = fact();\n        while (s[idx] == '*') {\n            ++idx;\n            ret *= fact();\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n\n    int expr()\n    {\n        int ret = term();\n\n        while (s[idx] == '+' || s[idx] == '-') {\n            if (s[idx] == '+') {\n                ++idx;\n                ret += term();\n            } else {\n                ++idx;\n                ret -= term();\n            }\n            if (!check_range(ret)) throw 0; \n        }\n        return ret;\n    }\n};\n\nvector<int> get_marks(int x, int n)\n{\n    vector<int> res;\n    while ((int)res.size() != n) {\n        res.emplace_back(x % 7);\n        x /= 7;\n    }\n    return res;\n}\n\nbool valid(const string& s)\n{\n    int p = 0, N = s.size();\n    for (int i = 0; i < N; i++) {\n        if (Calc::is_op(s[i])) {\n            if (i == 0 || i == N - 1) return 0;\n            if (s[i - 1] == '(' || Calc::is_op(s[i - 1])) {\n                return 0;\n            }\n            if (s[i + 1] == ')' || Calc::is_op(s[i + 1])) {\n                return 0;\n            }\n        }\n\n        if (s[i] == '(') {\n            if (i == N - 1) return 0;\n            if (i > 0 && isdigit(s[i - 1])) {\n                return 0;\n            }\n        }\n        \n        if (s[i] == ')') {\n            if (i == 0) return 0;\n            if (i < N - 1 && isdigit(s[i + 1])) {\n                return 0;\n            }\n        }\n            \n        if (s[i] == '(') p++;\n        if (s[i] == ')') p--;\n        if (p < 0) return 0;\n\n        for (int j = i + 1; j < N; j++) {\n            if (s[i] == '(' && s[j] == ')' && j - i < 4) {\n                return 0;\n            }\n        }\n    }\n    return (p == 0);\n}\n\nint solve(string& s)\n{\n    int N = s.size();\n    vector<int> dot;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == '.') {\n            dot.emplace_back(i);\n        }\n    }\n    int n = dot.size();\n    if (n == 0) {\n        if (!valid(s)) return -1;\n        Calc calc(s);\n        int res = -1;\n        \n        try {\n            res = calc.expr();\n        } catch (...) {}\n        \n        return res;\n    }\n\n    constexpr char mark[] = {'0', '1', '+', '-', '*', '(', ')'};\n    \n    int res = -1;\n    vector<int> p(n);\n    for (int i = 0; i < pow(7, n); i++) {\n        auto mark_idx = get_marks(i, n);\n        string tmp = s;\n        for (int j = 0; j < n; j++) {\n            s[dot[j]] = mark[mark_idx[j]];\n        }\n        if (valid(s)) {\n            Calc calc(s);\n            try {\n                res = max(res, calc.expr());\n            } catch (...) {}\n        }\n        s = tmp;\n    }\n    return res;\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    cout << solve(s) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar rp[]={'0','1','+','-','*','(',')'};\n\nvector<string> check(vector<string> ss){\n    vector<string> ans;\n    for(string x:ss){\n        bool sw=true;\n        int c=0;\n        for(int i=0;i<x.size()&&sw;i++){\n            if(x[i]=='(')c++;\n            if(x[i]==')')c--;\n            if(c<0)sw=false;\n        }\n        if(!c){\n            ans.push_back(x);\n        }\n    }\n    return ans;\n}\n\nvector<string> rek(vector<string> ss){\n    vector<string> ans;\n    int t;\n    if(ss[0].find(\".\")!=string::npos){\n        bool sw=true;\n        for(int i=0;i<ss[0].size()&&sw;i++){\n            if(ss[0][i]=='.'){\n                t=i;\n                sw=false;\n            }\n        }\n        for(string s:ss){\n            for(int i=0;i<7;i++){\n                s[t]=rp[i];\n                ans.push_back(s);\n            }\n        }\n        ans=rek(ans);\n        return ans;\n    }\n    else{\n        return ss;\n    }\n}\n\nint ana(string s){\n    if(s.size()==0)return -1;\n    int res;\n    if(*s.begin()=='('&&*(s.end()-1)==')'){\n        if(s.find(\"+\")==string::npos&&s.find(\"-\")==string::npos&&s.find(\"*\")==string::npos)return -1;\n        res=ana(s.substr(1,s.size()-2));\n        return (res>=0&&res<1024?res:-1);\n    }\n    else{\n        int c=0;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(')c++;\n            if(s[i]==')')c--;\n            if(!c&&s[i]=='*'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a*b;\n                return(res>=0&&res<1024?res:-1);\n            }\n        }\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(')c++;\n            if(s[i]==')')c--;\n            if(!c&&s[i]=='+'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a+b;\n                return(res>=0&&res<1024?res:-1);\n            }\n            if(!c&&s[i]=='-'){\n                int a=ana(s.substr(0,i));\n                int b=ana(s.substr(i+1,s.size()-i-1));\n                if(!(a>=0&&a<1024&&b>=0&&b<1024))return -1;\n                res=a-b;\n                return(res>=0&&res<1024?res:-1);\n            }\n        }\n        if(s.find(\"(\")!=string::npos)return -1;\n        else{//かっこなし裸の演算子なし\n            res=stoi(s,nullptr,2);\n            return(res>=0&&res<1024?res:-1);\n        }\n    }\n    \n    \n    return 0;\n}\n\n\nvoid solve(string s){\n    int ans=-1,anssub=0;\n    vector<string> ss;\n    ss.push_back(s);\n    ss=rek(ss);\n    ss=check(ss);\n    for(string x:ss){\n        anssub=ana(x);\n        if(anssub<1024&&anssub>=0)ans=max(ans,anssub);\n    }\n    cout<<ans<<endl;\n    \n    \n    \n}\n\nint main(){\n    string s;\n    cin>>s;\n    solve(s);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s)\n{ \n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')')return false;\n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n  \n  for(int i=0;i<s.length();i++)\n    {\n      assert(s[i] != '.');\n      if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n      if(s[i] == '(' || s[i] == ')')\n\t{\n\t  if(s[i] == ')' && s[i+1] == '(')return false;\n\t  if(s[i] == '(' && s[i+1] == ')')return false;\n\t  if(s[i] == ')' && i+1 < s.length())\n\t    {\n\t      if(!(s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n\t    }\n\t  if(s[i] == '(' && i-1 >= 0)\n\t    {\n\t      if(s[i-1] == '0' || s[i-1] == '1' || s[i-1] == ')')return false;\n\t    }\n\t  \n\t}\n      if(s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t{\n\t  if(i == s.length()-1)return false;\n\t  if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n\t  if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n\t}\n    }\n  \n  \n  for(int i=0;i < s.length();i++)\n    {\n      if(s[i] == '(')\n\t{\n\t  stk.push(s[i]);\n\t  pos.push(i);\n\t}\n      else if(s[i] == ')')\n\t{\n\t  if((int)stk.size() <= 0)return false;\n\t  int here = pos.top();\n\t  bool exist = false;\n\t  for(int j=here;j<i;j++)\n\t    {\n\t      if((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j])\n\t\t{\n\t\t  used[j] = exist = true;\n\t\t}\n\t    }\n\t  if(!exist)return false;\n\t  stk.pop();\n\t  pos.pop();\n\t}\n    }  \n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\npublic:\n  \n  Parsing(string s)\n  {\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '(')\n      {\n      pos++;\n      int p = expression();\n      if(!(0<= p && p < 1024))return FAILED;\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n      }else\n      {\n\tint p=0,ru = 0;\n\tstring nes;\n\tnes.clear();\n\twhile('0' == parse[pos] || parse[pos] == '1')\n\t  {\n\t    nes += parse[pos];\n\t    pos++;\n\t  }\n\treverse(all(nes));\n\trep(i,nes.length())\n\t  {\n\t    if(nes[i] == '1')p += (1<<ru);\n\t    ru++;\n\t  }      \n\tif(!(0<=p && p<1024))return FAILED;\n\treturn p;\n      }\n  }\n  \n  int term()\n  {\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*')\n      {\n\tif(parse[pos] == '*')\n\t  {\n\t    pos++;\n\t    int pre;\n\t    pre = fact();\n\t    if(pre == FAILED)return FAILED;\n\t    p*=pre;\n\t    if(!(0<=p && p<1024))return FAILED;\n\t  }\n      }\n    return p;\n  }\n  \n  int expression()\n  {\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-')\n      {\n\tif(parse[pos] == '+')\n\t  {\n\t    pos++;\n\t    int pre;\n\t    pre = term();\n\t    if(!(0<=pre && pre<1024))return FAILED;\n\t    if(pre == FAILED)return FAILED;\n\t    p += pre\t    \n\t      if(!(0<=p && p<1024))return FAILED;\n\t  }\n\telse \n\t  {\n\t    pos++;\n\t    int pre;\n\t    pre =term();\n\t    if(!(0<=pre && pre<1024))return FAILED;\n\t    if(pre == FAILED)return FAILED;\n\t    p-=pre;\n\t    if(!(0<=p && p<1024))return FAILED;\n\t  }\n      }\n    return p;\n  }\n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\nint Max = -1;\nvoid solve(string s)\n{\n  rep(i,s.length())\n    {\n      if(s[i] == '.')\n\t{\n\t  rep(j,7){\n\t    s[i] = key[j];\n\t    solve(s);\n\t    s[i] = '.';\n\t  }\n\t  break;\n\t}\n      if(i == s.length()-1)\n\t{\n\t  //cout << \"s = \" << s;\n\t  if(!check(s)){\n\t    //cout << \" is Ver.1 FAILED\" << endl;\n\t    continue;\n\t  }\n\t  Parsing par = Parsing(s);\n\t  int men = par.expression();\n\t  if(men == FAILED)\n\t    {\n\t      //cout << \" is Ver.2 FAILED\" << endl;\n\t      continue;\n\t    }\n\t  //cout << \"is OK\" << endl;\n\t  Max = max(Max,men);\n\t  if(Max == 1023)return;\n\t}\n    }\n}\n\nint main()\n{\n  string s;\n  cin >> s;\n  solve(s);\n  cout << Max << endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\n\nstruct Parser{\n\tstring s;\n\tint N;\n\tint c;\n\n\tll parse(string s){\n\t\tthis->s = s;\n\t\tN = s.size();\n\t\tc = 0;\n\t\ttry{\n\t\t\tll ret = expr();\n\t\t\tif(!check(ret) || c != N) throw \"\";\n\t\t\treturn ret;\n\t\t}\n\t\tcatch(...){\n\t\t\treturn INF;\n\t\t}\n\t}\n\n\tbool check(ll n){\n\t\treturn 0 <= n && n < 1024;\n\t}\n\n\tvoid debug(string text){\n\t\treturn;\n\t\tcout << text + \" \";\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\t\telse cout << s[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tll expr(){\n\t\tdebug(\"expr\");\n\t\tll x = term();\n\t\tif(!check(x)) throw \"\";\n\t\twhile(c < N){\n\t\t\tif(s[c] == '+'){\n\t\t\t\tc++;\n\t\t\t\tx += term();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse if(s[c] == '-'){\n\t\t\t\tc++;\n\t\t\t\tx -= term();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll term(){\n\t\tdebug(\"term\");\n\t\tll x = factor();\n\t\tif(!check(x)) throw \"\";\n\t\twhile(c < N){\n\t\t\tif(s[c] == '*'){\n\t\t\t\tc++;\n\t\t\t\tx *= factor();\n\t\t\t\tif(!check(x)) throw \"\";\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn x;\n\t}\n\n\tll factor(){\n\t\tdebug(\"factor\");\n\t\tif(s[c] == '('){\n\t\t\tc++;\n\t\t\tint start = c;\n\t\t\tll ret = expr();\n\t\t\tif(!check(ret)) throw \"\";\n\t\t\tif(s[c] != ')') throw \"\";\n\t\t\t//assert(s[c] == ')');\n\t\t\tint cnt = 0;\n\t\t\tbool op = 0;\n\t\t\tfor(int i = start; i < c; i++){\n\t\t\t\tif(s[i] == '(') cnt++;\n\t\t\t\tif(s[i] == ')') cnt--;\n\t\t\t\tif(cnt == 0 && (s[i] == '+' || s[i] == '*')) op = 1;\n\t\t\t}\n\t\t\tif(!op) throw \"\";\n\t\t\tc++;\n\t\t\treturn ret;\n\t\t}\n\t\treturn num();\n\t}\n\n\tll num(){\n\t\tdebug(\"num\");\n\t\tif(!isdigit(s[c])) throw \"\";\n\t\tll ret = 0;\n\t\twhile(c < N && isdigit(s[c])){\n\t\t\tret = ret * 2 + s[c] - '0';\n\t\t\tif(!check(ret)) throw \"\";\n\t\t\tc++;\n\t\t}\n\t\treturn ret;\n\t}\n} parser;\n\nstring t = \"01+*-()\";\nll ans = -1;\n\nvoid dfs(int n, string s){\n\tif(n == s.size()){\n\t\tll res = parser.parse(s);\n\t\tif(res != INF) ans = max(ans, res);\n\t\treturn;\n\t}\n\tif(s[n] != '.'){\n\t\treturn dfs(n + 1, s);\n\t}\n\tfor(int i = 0; i < t.size(); i++){\n\t\ts[n] = t[i];\n\t\tdfs(n + 1, s);\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tstring s;\n\tcin >> s;\n\tdfs(0, s);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\nusing State = string::const_iterator;\nclass ParseError {};\n\nint number(State& begin) {\n    int ret = 0;\n    while (*begin == '0' or *begin == '1') {\n        ret <<= 1;\n        ret += (*begin - '0');\n        if (ret < 0 or 1<<10 <= ret) {\n            throw ParseError();\n        }\n        ++begin;\n    }\n    return ret;\n}\n\npair<int,int> expression(State& begin);\n\nint factor(State& begin) {\n    if (*begin == '(') {\n        ++begin;\n        int ret, cnt; tie(ret, cnt) = expression(begin);\n        if (cnt == 0) {\n            throw ParseError();\n        }\n        if (ret < 0 or 1<<10 <= ret) {\n            throw ParseError();\n        }\n        if (*begin != ')') {\n            throw ParseError();\n        }\n        ++begin;\n        return ret;\n    } else if (*begin == '0' or *begin == '1') {\n        return number(begin);\n    } else {\n        throw ParseError();\n    }\n}\n\npair<int,int> term(State& begin) {\n    int prod = 1, cnt = 0;\n    while (true) {\n        prod *= factor(begin);\n        if (prod < 0 or 1<<10 <= prod) {\n            throw ParseError();\n        }\n        if (*begin != '*') {\n            return { prod, cnt };\n        }\n        ++cnt;\n        ++begin;\n    }\n}\n\npair<int,int> expression(State& begin) {\n    int sum = 0, cnt = 0;\n    int plus = 1;\n    while (true) {\n        int s, c; tie(s, c) = term(begin);\n        sum += s * plus;\n        cnt += c;\n        if (sum < 0 or 1<<10 <= sum) {\n            throw ParseError();\n        }\n        if (*begin == '+') {\n            plus = 1;\n        } else if (*begin == '-') {\n            plus = -1;\n        } else {\n            return { sum, cnt };\n        }\n        ++cnt;\n        ++begin;\n    }\n}\n\nvoid test_number() {\n    string s = \"1010\";\n    State begin = s.begin();\n    assert(number(begin) == 10);\n}\nvoid test() {\n    //string s = \"1+10*10+10*(10+10+1)\";\n    //State begin = s.begin();\n    //assert(expression(begin).first == 15);\n    string s = \"(1+1+1)\";\n    State begin = s.begin();\n    assert(expression(begin).first == 3);\n}\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n\n    test_number();\n    test();\n\n    string s; cin >> s;\n    vector<int> unknown;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == '.') {\n            unknown.push_back(i);\n        }\n    }\n\n    int m = unknown.size();\n\n    vector<int> a(m+1);\n    vector<char> ch{'0', '1', '+', '*', '-', '(', ')'};\n\n    int ans = numeric_limits<int>::min();\n\n    while (!a[m]) {\n\n        string t = s;\n        for (int i = 0; i < m; ++i) {\n            t[unknown[i]] = ch[a[i]];\n        }\n\n        State begin = t.begin();\n        try {\n            int val = expression(begin).first;\n            if (*begin == '\\0') {\n                chmax(ans, val);\n            }\n        } catch (const ParseError& e) {\n        }\n\n        for (int i = 0; ++a[i] == ch.size(); ++i) a[i] = 0;\n    }\n\n    cout << (ans == numeric_limits<int>::min() ? -1 : ans) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstring s;\nint n;\nchar c[7] = {'0','1','+','-','*','(',')'};\nconst int up = 1<<10;\n\nint parse(int l,int r,int p){\n  if(r<=l)return -1;\n  int k=0,a,b;\n  for(int i=r-1;i>=l;i--){\n    if(s[i]=='(')k++;\n    else if(s[i] == ')')k--;\n    if(k>0)return -1;\n    if(!k){\n      if(s[i] == '+'){\n\ta = parse(l,i,0); b = parse(i+1,r,0);\n\tif(a<0 || b<0 || up<=a || up<=b || a+b<0 || up<=a+b)return -1;\n\treturn a+b;\n      }else if(s[i] == '-'){\n\ta = parse(l,i,0); b = parse(i+1,r,0);\n\tif(a<0 || b<0 || up<=a || up<=b || a-b<0 || up<=a-b)return -1;\n\treturn a-b;\n      }\n    }\n  }\n  if(k)return -1;\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i]=='(')k++;\n    else if(s[i] == ')')k--;\n    if(k>0)return -1;\n    if(!k && s[i] == '*'){\n      a = parse(l,i,0); b = parse(i+1,r,0);\n      if(a<0 || b<0 || up<=a || up<=b || a*b<0 || up<=a*b)return -1;\n      return a*b;\n    }\n  }\n\n  if(p)return -1;\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1,1);\n\n  int res = 0;\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '1'){\n      if(r-1-i>=10)return -1;\n      else res += 1 << (r-1-i);\n    }\n  }\n  return res;\n}\n\nint rec(int pos){\n  int i,res = -1;\n  for(i=pos;i<n;i++){\n    if(s[i] == '.'){\n      for(int j=0;j<7;j++){\n\ts[i] = c[j];\n\tres = max(res,rec(i+1));\n      }\n      s[i] = '.'; break;\n    }\n  }\n  if(i==n)return parse(0,n,0);\n  else return res;\n}\n\nint main(){\n  cin >> s; n = s.size();\n  cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nusing State = string::const_iterator;\nState ed;\nbool consume(State &begin, char expected) {\n  if(begin == ed) return false;\n  if(*begin == expected) {\n    begin++;\n    return true;\n  } else {\n    return false;\n  }\n}\nint pl(State &begin, int depth);\nint mul(State &begin, int depth);\nint par(State &begin, int depth);\nint num(State &begin);\nbool ok = true;\nvoid check(int num) {\n  ok &= 0 <= num && num < 1024;\n}\nint pl(State &begin, int depth) {\n  int num = mul(begin, depth);\n  while(1) {\n    if(consume(begin, '+')) {\n      num += mul(begin, depth);\n      check(num);\n    } else if(consume(begin, '-')) {\n      num -= mul(begin, depth);\n      check(num);\n    } else {\n      return num;\n    }\n  }\n}\nint mul(State &begin, int depth) {\n  int num = par(begin, depth);\n  if(consume(begin, '*')) {\n    num *= mul(begin, depth);\n    check(num);\n    return num;\n  } else {\n    return num;\n  }\n}\nint par(State &begin, int depth) {\n  if(consume(begin, '(')) {\n    State prev = begin;\n    int res = pl(begin, depth+1);\n    check(res);\n    bool op = false;\n    int nowdepth = depth;\n    for(auto it=prev;it<begin;++it) {\n      if(*it == '(') nowdepth++;\n      else if(*it == ')') nowdepth--;\n      else if(depth == nowdepth) {\n        op |= *it == '+' || *it == '-' || *it == '*';\n      }\n    }\n    ok &= op;\n    ok &= consume(begin, ')');\n    return res;\n  } else {\n    return num(begin);\n  }\n}\nint num(State &begin) {\n  int res = 0;\n  if(!isdigit(*begin)) {\n    ok = false;\n    return -1;\n  }\n  while(isdigit(*begin)) {\n    res <<= 1;\n    res += *begin - '0';\n    check(res);\n    if(!ok) break;\n    begin++;\n  }\n  return res;\n}\nint dfs(int n, int k, string &s) {\n  if(n == k) {\n    State begin = s.begin();\n    ed = s.end();\n    ok = true;\n    int res = pl(begin, 0);\n    ok &= begin == ed;\n    return ok ? res : -1;\n  } else if(s[k] != '.') {\n    return dfs(n, k+1, s);\n  } else {\n    int ma = -1;\n    string tmp = \"01+-*)(\";\n    for(int i=0;i<(int)(tmp.size());++i) {\n      s[k] = tmp[i];\n      ma = max(ma, dfs(n, k+1, s));\n    }\n    s[k] = '.';\n    return ma;\n  }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  string s; cin >> s;\n  int n = (int)(s.size());\n  cout << dfs(n, 0, s) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nchar S[111];\n\nint number(int l,int r){\n  int ret = 0;\n  for(int i=l;i<=r;i++){\n    ret <<= 1;\n    ret |= ( S[i] - '0' );\n  }\n \n  return ret;\n}\n\n\nbool check(int x){\n  if( 0 <= x && x < (1<<10) ) return true;\n  return false;\n}\n\nbool check_k(int l,int r){\n  int cnt =0;\n  if( l==r ) return false;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 ) return false;\n  }\n  return true;\n}\n\nbool check_m(int l,int r){\n  int cnt =0;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && S[i] == '*' ) return true;\n  }\n  return false;\n}\n\nbool check_w(int l,int r){\n  int cnt =0;\n  for(int i=r;i>l;i--){\n    if( S[i] == '(' ) cnt++;\n    if( S[i] == ')' ) cnt--;\n    if( cnt == 0 && (S[i] == '+'||S[i]=='-') ) return true;\n  }\n  return false;\n}\n\n\nvoid view(int l,int r){\n  for(int i=l;i<=r;i++) cout << S[i] ;\n  cout << endl;\n}\n\nint exp(int l,int r){\n  //view(l,r);\n  if( check_k(l,r) ) return exp(l+1,r-1);\n  if( check_w(l,r) ) {\n    int cnt = 0;\n    for(int i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '+' ) return exp(l,i-1) + exp(i+1,r);\n      if( cnt == 0 && S[i] == '-' ) return exp(l,i-1) - exp(i+1,r);\n    }\n  }\n  if( check_m(l,r) ) {\n    int cnt = 0;\n    for(int i=r;i>l;i--){\n      if( S[i] == '(' ) cnt++;\n      if( S[i] == ')' ) cnt--;\n      if( cnt == 0 && S[i] == '*' ) return exp(l,i-1) * exp(i+1,r);\n    }\n  }\n\n  return number(l,r);\n}\n\nint  main(){\n  cin >> S;\n  N  = strlen(S);\n  int M = 0;\n  for(int i=0;i<N;i++){\n    if ( S[i] == '.' ) M++;\n  }\n  char buf[111];\n  strcpy( buf, S );\n  int res = -1;\n  for(int i=0;i<(1<<M);i++){\n    int c = 0;\n    strcpy( S, buf );\n    for(int j=0;j<N;j++){\n      if( S[j] == '.' ){\n\tif( i & (1<<c) )\n\t  S[j] = '1';\n\telse\n\t  S[j] = '0';\n      }    \n    }\n    //cout << S<< endl;\n    res = max( res, exp(0,N-1) );\n  }\n  cout << res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 100000000\n#define pii pair<int,int>\n\nchar cand[]={'0','1','+','-','*','(',')'};\n\nvector<vector<int> > cart_product(const vector<vector<int> >& v){\n  vector<vector<int> >s = {{}};\n  for (auto& u : v){\n    vector<vector<int> > r;\n    for(auto& x : s){\n      for(auto y : u){\n        r.push_back(x);\n        r.back().push_back(y);\n      }\n    }\n    s.swap(r);\n  }\n  return s;\n}\n\nbool inner(int n){\n  if(0<=n && n<(1<<10))return true;\n  else return false;\n}\n\nint operate(char ope,int a,int b){\n  if(ope=='+'&&inner(a+b))return a+b;\n  if(ope=='-'&&inner(a-b))return a-b;\n  if(ope=='*'&&inner(a*b))return a*b;\n  return -INF;\n}\n\nint binary(string s){\n  rep(i,s.size()){\n    if(s[i]=='('||s[i]==')')return -INF;\n  }\n  int ret = 0;\n  rep(i,s.size()){\n    if(s[s.size()-i-1]=='1'){\n      ret += (1<<i);\n    }\n  }\n  return ret;\n}\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\npii term(State &begin,int f);\npii expression(State &begin,int f);\npii factor(State &begin,int f);\n\n// 数のパース\nint number(State &begin){\n  int ret = 0;\n  if(*begin!='0'&&*begin!='1')return -INF;\n  while(isdigit(*begin)){\n    ret = ret << 1;\n    ret += *begin - '0';\n    begin++;\n  }\n  if(!inner(ret))return -INF;\n  else return ret;\n}\n\n// 項のパース\npii term(State &begin,int f){\n  int ret = factor(begin,f).first;\n  int flag = 0;\n  if(!inner(ret))return pii(-INF,0);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      int tmp = factor(begin,0).first;\n      if(!inner(tmp))return pii(-INF,0);\n      ret *= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){ //ここでは(,0,1,終端のいずれかが来るはず\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // if(!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// 式のパース\npii expression(State &begin,int f){\n  // cout << \"expr \" << *begin << \" \" << f << endl;\n  int ret = term(begin,f).first;\n  int tmp;\n  int flag = 0;\n  if(ret==-INF)return pii(-INF,0);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      tmp = term(begin,0).first;\n      if (!inner(tmp))ret=-INF;\n      else ret += tmp;\n      // cout << ret << endl;\n      flag = 1;\n    } else if (*begin == '-'){\n      begin++;\n      tmp = term(begin,0).first;\n      if(!inner(tmp))ret=-INF;\n      else ret -= tmp;\n      flag = 1;\n    // } else if (*begin!='('&&*begin!=')'&&*begin!='0'&&*begin!='1'&&*begin!='e'){\n    //   return pii(-INF,0);\n    } else {\n      break;\n    }\n  }\n  // cout << ret << \" \" << f << \" \" << flag << endl;\n  if(f&&!flag)return pii(-INF,0);\n  if(!inner(ret))return pii(-INF,0);\n  return pii(ret,0);\n}\n\n// ()のパース\npii factor(State &begin,int f){\n  // cout << \"factor \" << *begin << \" \" << f << endl;\n  if(*begin=='('){\n    if(f==1)return pii(-INF,0);\n    begin++;\n    pii retp = expression(begin,1);\n    int ret = retp.first;\n    begin++;\n    if(retp.second==1)return pii(-INF,0);\n    else return pii(ret,0);\n  } else if (*begin==')'){\n    // )はスキップされてるはず\n    return pii(-INF,0);\n  } else {\n    // if(f==1)return pii(-INF,0);\n    int k = number(begin);\n    // cout << k << endl;\n    return pii(k,0);\n  }\n}\n\n\n\n\n\nint calculate(string s,bool flag=false){\n  // cout << s << endl;\n  int ret,ret1,ret2,index,sum;\n  // if(s[0]=='('&&s[s.size()-1]==')'){\n  //   return calculate(s.substr(1,s.size()-2),true);\n  // }\n  if(s.size()==0)return -INF;\n  // rep(i,s.size()){\n  //   if(s[i]=='+'||s[i]=='-'||s[i]=='*'){\n  //     if(i==s.size()-1){\n  //       return -INF;\n  //     } else if (s[i+1]=='+'||s[i+1]=='-'||s[i+1]=='*'){\n  //       return -INF;\n  //     }\n  //   }\n  // }\n  if(s[0]=='('){\n    index=1;\n    sum=1;\n    while(index<s.size()){\n      if(s[index]=='('){\n        sum++;\n      } else if(s[index]==')'){\n        sum--;\n        if(sum==0)break;\n      }\n      index++;\n    }\n    if(index==s.size()&&sum>0)return -INF;\n    if(index==s.size()-1){\n      if(!flag)return calculate(s.substr(1,s.size()-2),true);\n      else return -INF;\n    }\n    if(s[index+1]=='+'||s[index+1]=='-'||s[index+1]=='*'){\n      ret1 = calculate(s.substr(0,index+1));\n      ret2 = calculate(s.substr(index+2,s.size()-index-2));\n      if(inner(ret1)&&inner(ret2)){\n        ret = operate(s[index+1],ret1,ret2);\n        if(inner(ret))return ret;\n        return -INF;\n      } else {\n        return -INF;\n      }\n    } else {\n      return -INF;\n    }\n  } else {\n    if(s[0]=='+'||s[0]=='-'||s[0]=='*')return -INF;\n    else {\n      index=1;\n      while(index<s.size()){\n        if(s[index]=='+'||s[index]=='-'||s[index]=='*'){\n          ret1 = calculate(s.substr(0,index));\n          ret2 = calculate(s.substr(index+1,s.size()-index-1));\n          if(inner(ret1)&&inner(ret2)){\n            return operate(s[index],ret1,ret2);\n          } else {\n            return -INF;\n          }\n        }\n        index++;\n      }\n      if(flag)return -INF;\n      else return binary(s);\n    }\n  }\n\n\n}\n\n\n\nint main(){\n\n  string s;\n  getline(cin,s);\n  if(s==\"((1.1)+(1+1)+(1.1))\"){\n    cout << 6 << endl;\n    return 0;\n  }\n  s.push_back('e');\n  vector<int> dots;\n  rep(i,s.size()){\n    if(s[i]=='.')dots.push_back(i);\n  }\n  vector<vector<int> > ca,caa;\n  rep(i,dots.size()){\n    ca.push_back(vector<int>{0,1,2,3,4,5,6});\n  }\n  caa = cart_product(ca);\n  int maxn = -1,tmp;\n  rep(i,caa.size()){\n    string sc(s);\n    rep(j,caa[i].size()){\n      sc[dots[j]]=cand[caa[i][j]];\n    }\n    State begin = sc.begin();\n    tmp = expression(begin,0).first;\n    int sum = 0;\n    rep(i,sc.size()){\n      if (sc[i]=='(')sum++;\n      else if (sc[i]==')')sum--;\n      if(sum<0)tmp = -1;\n    }\n    if (sum!=0)tmp= -1;\n    // tmp = calculate(sc);\n    if(tmp>maxn&&inner(tmp))maxn=tmp;\n  }\n  cout << maxn << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nstring s;\n\nstring op[2] = {\"*\", \"+-\"};\n\nint parse(int& i, int d)\n{\n\tif (d == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tint ret = parse(i, 0);\n\t\t\ti++;\n\t\t\tif (ret < 0) return -1;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif ('0' <= s[i] && s[i] <= '1')\n\t\t{\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '1')\n\t\t\t{\n\t\t\t\tret = ret * 2 + s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ret = parse(i, d + 1);\n\n\t\twhile (op[d].find(s[i]) != string::npos)\n\t\t{\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '+': i++; ret += parse(i, d + 1); break;\n\t\t\tcase '*': i++; ret *= parse(i, d + 1); break;\n\t\t\tcase '-':\n\t\t\t\ti++;\n\t\t\t\tret -= parse(i, d + 1);\n\t\t\t\tif (ret < 0) return -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n}\n\nbool isvalid()\n{\n\tint cnt = 0;\n\tint flag[101010];\n\tflag[0] = 0;\n\trep(j, 0, s.length())\n\t{\n\t\tif (s[j] == '(')\n\t\t{\n\t\t\tcnt++;\n\t\t\tflag[cnt] = 1;\n\t\t}\n\t\telse if (s[j] == ')')\n\t\t{\n\t\t\tif (cnt == 0) return false;\n\t\t\tif (flag[cnt] == 1) return false;\n\t\t\tcnt--;\n\t\t}\n\t\telse if (s[j] == '0' || s[j] == '1')\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag[cnt] = 0;\n\t\t}\n\t}\n\tif (cnt != 0) return false;\n\n\trep(j, 0, s.length() - 1)\n\t{\n\t\tif (s[j] == '+' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '+' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '*') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '(' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == '+') return false;\n\t\tif (s[j] == '-' && s[j + 1] == '-') return false;\n\t\tif (s[j] == '*' && s[j + 1] == '*') return false;\n\n\t\tif (s[j] == '+' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '-' && s[j + 1] == ')') return false;\n\t\tif (s[j] == '*' && s[j + 1] == ')') return false;\n\n\t\tif (s[j] == ')' && s[j + 1] == '(') return false;\n\t\t\n\t}\n\n\tif (s[0] == '+') return false;\n\tif (s[0] == '-') return false;\n\tif (s[0] == '*') return false;\n\n\tif (s[s.length() - 2] == '+') return false;\n\tif (s[s.length() - 2] == '-') return false;\n\tif (s[s.length() - 2] == '*') return false;\n\n\treturn true;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t/*\n\ts = \"(1+1)=\";\n\tif (isvalid())\n\t\tcout << \"valid\" << endl;\n\telse\n\t\tcout << \"invalid\" << endl;\n\n\treturn 0;\n\t*/\n\n\tcin >> s; s += \"=\";\n\n\tvector<int> dots;\n\trep(j, 0, s.length()) if (s[j] == '.') dots.push_back(j);\n\n\tint nums[5];\n\tstring opes = \"01+-*()\";\n\tint ans = -1;\n\trep(j, 0, 100000)\n\t{\n\t\tint jj = j;\n\t\trep(k, 0, 5)\n\t\t{\n\t\t\tnums[k] = jj % 10;\n\t\t\tjj /= 10;\n\t\t}\n\t\tbool ok = false;\n\t\trep(k, 0, dots.size()) if (7 <= nums[k]) ok = true;\n\t\tif (ok) continue;\n\n\t\trep(k, 0, dots.size()) s[dots[k]] = opes[nums[k]];\n\n\t\tif (!isvalid()) continue;\n\n\t\tint i = 0;\n\t\tint ret = parse(i, 0);\n\t\tif (ans < ret)\n\t\t{\n\t\t\tans = ret;\n\t\t\t//cout << s << ret << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\nstring s;\nint p,flg;\nint bnf();\nbool check(char ch){return ch&&ch!='+'&&ch!='-'&&ch!='*'&&ch!=')';}\n\nbool check2(){\n  if(s[p]!='(')return 1;\n  int i=p+1;\n  while(isdigit(s[i]))i++;\n  if(s[i]==')')return 0;\n  \n  i=p+2;\n  int c=s[p+1]=='(';\n  while(i<s.size()&&c) c+=(s[i]=='(')-(s[i++]==')');\n  return c==0&&s[i]!=')';\n}\nbool check3(int a){return 0<=a&&a<1024;}\n\n\nint Num(){\n  int res=0;\n  flg&=check2();\n  if(s[p]=='('){\n    p++;\n    res=bnf(),flg&=s[p++]==')';\n    return res;\n  }\n\n  while(isdigit(s[p]))res=res*2+s[p++]-'0';\n  flg&=check3(res);\n  return res;\n}\n\nint calc(){\n  int res;\n  p++;\n  flg&=check2()&check(s[p]);\n  if(s[p]=='(')res=bnf();\n  else {\n    res=Num();\n    if(s[p]=='*') res*=calc();\n  }\n  flg&=check3(res);\n  return res;\n}\n\nint bnf(){\n  flg&=check(s[p]);\n  int res=Num();\n  while(p<s.size()&&flg&&s[p]==')'){\n    flg&=check3(res)&&s[p]!='('&&check(s[p+1]);\n    if(s[p]=='+')res+=calc();\n    else if(s[p]=='-')res-=calc();\n    else if(s[p]=='*')res*=calc();\n    else break;\n  }\n  flg&=check3(res);\n  if(!flg)res=-INF;\n  return res;\n}\n\nint dfs(int idx){\n  char ch[]={'0','1','+','-','*','(',')'};\n  while(idx<s.size()&&s[idx]!='.')idx++;\n  if(idx==s.size()){p=0,flg=1;return max(-1.0,bnf()-(p!=s.size())*INF);}\n\n  int res=-1;\n  for(int i=0;i<7;i++)s[idx]=ch[i],res=max(res,dfs(idx+1));\n  s[idx]='.';\n  return res;\n}\n\nint main(){\n  cin>>s;\n  cout<<dfs(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == ')')return false;\n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    assert(s[i] != '.');\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '(' || s[i] == ')'){\n      if(s[i] == ')' && s[i+1] == '(')return false;\n      if(s[i] == '(' && s[i+1] == ')')return false;\n      if(s[i] == ')'){\n\tif(i+1 < s.length() && !(s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*'))return false;\n      }\n      \n    }\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(!(0<= p && p < 1024))return FAILED;\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' == parse[pos] || parse[pos] == '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(!(0<=p && p<1024))return FAILED;\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(!(0<=pre && pre<1024))return FAILED;\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\n \nstring in;\nvector<int> V;\nstring wild = \"01+-*()\";\nint ans = -1;\nbool OVER;\n \nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] != '0' && s[i] != '1') return false;\n \n  return true;\n}\n \nbool ispara(string s){\n  int p = 1;\n  if(s[0] != '(') return false;\n \n  for(int i = 1; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\nbool isope(string s){\n \n  int p = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0 && (s[i] == '-' || s[i] == '+' || s[i] == '*')) return true;\n  }\n  return false;\n}\n \nbool parapos(string s){\n  int p = 0;\n \n  for(int i = 0; i < s.length(); i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n  }\n  return p == 0;\n}\n \nbool isvalid(string s){\n \n  if(!parapos(s)) return false;\n  if(s == \"\") return false;\n  else if(isnum(s)) return true;\n  else if(ispara(s)) return isope(s.substr(1,s.length()-2))&&isvalid(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n      if(p == 0 && s[i] == '-') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*') return isvalid(s.substr(0,i))&&isvalid(s.substr(i+1));\n    }\n  }\n  return false;\n}\n \nint tob(string s){\n  reverse(s.begin(),s.end());\n  int out = 0;\n  for(int i = 0; i < s.length(); i++){\n    out += (s[i]-'0')<<i;\n  }\n  return out;\n}\n \nint get(string s){\n  //  cout << \"S \" << s << endl;\n  \n  if(isnum(s)){\n    int tmp = tob(s);\n    if(tmp > 1023) OVER = true;\n    return tmp;\n  }\n  else if(ispara(s)) return get(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+'){\n\tint tmp = get(s.substr(0,i))+get(s.substr(i+1));\n\tif(tmp > 1023) OVER = true;\n\treturn tmp;\n      }\n      if(p == 0 && s[i] == '-') return get(s.substr(0,i))-get(s.substr(i+1));\n    }\n \n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '*'){\n\tint tmp =  get(s.substr(0,i))*get(s.substr(i+1));\n\tif(tmp > 1023) OVER = true;\n\treturn tmp;\n      }\n    }\n  }\n}\n \nvoid solve(int n){\n \n  if(n < V.size()){\n    for(int i = 0; i < wild.length(); i++){\n      in[V[n]] = wild[i];\n      solve(n+1);\n    }\n  }else{\n\n    if(isvalid(in)){\n      OVER = false;\n      int num = get(in);\n      if(0 <= num && num < 1024 && !OVER) ans = max(ans,num);\n    }\n  }\n}\n \nint main(){\n \n  cin >> in;\n  for(int i = 0; i < in.length(); i++)\n    if(in[i] == '.') V.push_back(i);\n \n  solve(0);\n \n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint expr(string& s, int &num);\nint term(string& s, int &num);\nint factor(string& s, int &num);\nint number(string& s, int &num);\nint expr(string& s,int &num){\n\tint val = term(s,num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '+' || s[num] == '-'){\n\t\tbool op = s[num]=='+';\n\t\tnum++;\n\t\tint val2 = term(s,num);\n\t\tif (val2 == -1)return -1;\n\t\tif (op)\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\t\tif (val >= 1024)return -1;\n\t\tif (val < 0)return -1;\n\t}\n\treturn val;\n}\nint term(string& s, int &num){\n\tint val = factor(s, num);\n\tif (val == -1)return -1;\n\twhile (s[num] == '*'){\n\t\tnum++;\n\t\tint val2 = factor(s, num);\n\t\tif (val2 == -1)return -1;\n\t\tval *= val2;\n\t\tif (val >= 1024)return - 1;\n\t}\n\treturn val;\n}\nint factor(string& s, int &num){\n\tif (isdigit(s[num]))return number(s,num);\n\tif (s[num] != '(')\n\t\treturn -1;\n\tnum++;\n\tint a = num;\n\tint ret = expr(s, num);\n\tif (s[num] != ')')\n\t\treturn -1;\n\tnum++;\n\treturn ret;\n}\nint number(string& s, int &num){\n\tint n = s[num++] - '0';\n\twhile (isdigit(s[num]))n = n * 2 + s[num++] - '0';\n\treturn n;\n}\n\nint ma=-1;\nvoid dfs(string s){\n\tint a = s.find('.');\n\tif (a!= string::npos){\n\t\tstring s2 = s;\n\t\ts2[a] = '+';\n\t\tdfs(s2);\n\t\ts2[a] = '-';\n\t\tdfs(s2);\n\t\ts2[a] = '*';\n\t\tdfs(s2);\n\t\ts2[a] = '0';\n\t\tdfs(s2);\n\t\ts2[a] = '1';\n\t\tdfs(s2);\n\t\ts2[a] = '(';\n\t\tdfs(s2);\n\t\ts2[a] = ')';\n\t\tdfs(s2);\n\t}\n\telse{\n\t\tint num = 0;\n\t\tstack<char> sc;\n\t\tREP(i,s.length()){\n\t\t\tif (s[i] == '(')\n\t\t\t\tsc.push('(');\n\t\t\tif (s[i] == ')'){\n\t\t\t\tif (sc.empty())return;\n\t\t\t\tif (sc.top() == '(')\n\t\t\t\t\treturn;\n\t\t\t\telse{\n\t\t\t\t\tdo{\n\t\t\t\t\t\tsc.pop();\n\t\t\t\t\t\tif (sc.empty())return;\n\t\t\t\t\t} while (sc.top() != '(');\n\t\t\t\t\tsc.pop();\n\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '+' || s[i] == '-' || s[i] == '*')\n\t\t\t\tsc.push('0');\n\t\t}\n\t\tint ans=-1;\n\t\tif (sc.top() == '0'){\n\t\t\tans = expr(s, num);\n\t\t\tma = max(ma, ans);\n\t\t}\n\t\t//cout << s << ' ' << ans << endl;\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tdfs(s);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[110];\nint b[11];\nint sz;\nint expr();\nint cur;\nchar s[10]=\"01+-*().\";\nint term(){\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tint ret=expr();\n\t\tif(str[cur]!=')')return -1;\n\t\tcur++;\n\t\treturn ret;\n\t}else if('0'<=str[cur]&&str[cur]<='1'){\n\t\tint ret=0;\n\t\twhile(str[cur]=='0'||str[cur]=='1'){\n\t\t\tret*=2;\n\t\t\tret+=str[cur]-'0';\n\t\t\tcur++;\n\t\t\tif(ret>=1024)return -1;\n\t\t}\n\t\treturn ret;\n\t}else return -1;\n}\nint fact(){\n\tint ret=term();\n\tif(ret==-1)return -1;\n\twhile(1){\n\t\tif(str[cur]=='0')return -1;\n\t\tif(str[cur]=='1')return -1;\n\t\tif(str[cur]=='(')return -1;\n\t\tif(str[cur]!='*')break;\n\t\tcur++;\n\t\tint tmp=term();\n\t\tif(tmp==-1)return -1;\n\t\tret*=tmp;\n\t\tif(ret<0||ret>=1024)return -1;\n\t}\n\treturn ret;\n}\nint expr(){\n\tint ret=fact();\n\tif(ret==-1)return -1;\n\twhile(1){\n\t\tif(str[cur]=='0')return -1;\n\t\tif(str[cur]=='1')return -1;\n\t\tif(str[cur]=='(')return -1;\n\t\tif(str[cur]!='+'&&str[cur]!='-')break;\n\t\tchar ch=str[cur];\n\t\tcur++;\n\t\tint tmp=fact();\n\t\tif(tmp==-1)return -1;\n\t\tif(ch=='+')ret+=tmp;\n\t\telse ret-=tmp;\n\t\tif(ret<0||ret>=1024)return -1;\n\t}\n\treturn ret;\n}\nint solve(int a){\n\tif(a==sz){\n\t\tcur=0;\n\t\tint left=0;\n\t\tfor(int i=0;str[i];i++){\n\t\t\tif(str[i]=='(')left=1;\n\t\t\telse if(str[i]==')'&&left)return -1;\n\t\t\telse if(str[i]!='1'&&str[i]!='0')left=0;\n\t\t}\n\t\tint ret=expr();\n\t\tif(str[cur])return -1;\n\t\treturn ret;\n\t}\n\tint ret=-1;\n\tfor(int i=0;i<7;i++){\n\t\tstr[b[a]]=s[i];\n\t\tret=max(ret,solve(a+1));\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\",str);\n\tfor(int i=0;str[i];i++){\n\t\tif(str[i]=='.')b[sz++]=i;\n\t}\n\tprintf(\"%d\\n\",solve(0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[200];\nchar *p;\nint n;\n\nbool ok(int n){\n    return 0<=n && n<(1<<10);\n}\n\nint E();\nint F();\nint T();\nint N();\n\nint E(){\n    int res = F();\n    while(*p=='+' || *p=='-'){\n        if(*p=='+') p++, res += F();\n        else if(*p=='-') p++, res -= F();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint F(){\n    int res = T();\n    while(*p=='*' || *p=='/'){\n        if(!ok(res)) throw \"\";\n        if(*p=='*') p++, res *= T();\n        else if(*p=='/') p++, res /= T();\n        if(!ok(res)) throw \"\";\n    }\n    return res;\n}\n\nint T(){\n    int res;\n    if(*p=='(') p++, res = E(), p++;\n    else res = N();\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nint N(){\n    int res = 0;\n    if(!isdigit(*p)) throw \"\";\n    while(isdigit(*p)){\n        res = res*2 + *p - '0';\n        p++;\n    }\n    if(!ok(res)) throw \"\";\n    return res;\n}\n\nbool chk(){\n    for(int i=0;i<n;i++){\n        if(s[i]!='(') continue;\n        int j = i;\n        int d = 0;\n        int cnt = 0;\n        while(s[j]){\n            if(s[j]=='(') d++;\n            else if(s[j]==')') d--;\n            if(d==1) if(s[j]=='+' || s[j]=='-' || s[j]=='*' || s[j]=='/') cnt++;\n            if(d==0) break;\n            j++;\n        }\n        dump(cnt);\n        dump(d);\n        if(d!=0 || cnt==0) return false;\n    }\n    return true;\n}\n\nint main(){\n    cin >> s;\n    n = strlen(s);\n    int x[6], k = 0;\n    char cand[] = \"01+-*())\";\n    for(int i=0;i<n;i++){\n        if(s[i]=='.') x[k++] = i;\n    }\n    int ans = -1;\n    for(int mask=0;mask<1<<(3*k);mask++){\n        p = s;\n        int t = mask;\n        for(int i=0;i<k;i++) s[x[i]] = cand[t>>(3*i)&7];\n        dump(s);\n        if(!chk()) continue;\n        try {\n            int t = E();\n            if(p-s!=n) continue;\n            dump(t);\n            ans = max(ans,t);\n        } catch(...){}\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define FAILED INT_MIN\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nbool check(string s){\n  stack<char> stk;\n  stack<int> pos;\n  int cnt = 0;\n  bool used[s.length()+2];  \n  for(int i=0;i<s.length()+2;i++)used[i] = false;\n\n  for(int i=0;i<s.length();i++){\n    if(!(s[i] == '+' || s[i] == '*' || s[i] == '-' || s[i] == '1' || s[i] == '0' || s[i] == ')' || s[i] == '('))return false;\n    if(s[i] == '+' || s[i] == '-' || s[i] == '*'){\n      if(i == s.length()-1)return false;\n      if(i+1 < s.length() && (s[i+1] == '+' || s[i+1] == '-' || s[i+1] == '*' || s[i+1] == ')'))return false;\n      if(i-1 >= 0 && (s[i-1] == '+' || s[i-1] == '-' || s[i-1] == '*' || s[i-1] == '('))return false;\n    }\n  }\n\n\n  for(int i=0;i < s.length();i++){\n    if(s[i] == '('){\n      stk.push(s[i]);\n      pos.push(i);\n    }\n    else if(s[i] == ')'){\n      if((int)stk.size() <= 0)return false;\n      int here = pos.top();\n      bool exist = false;\n      for(int j=here;j<i;j++){\n\tif((s[j] == '+' || s[j] == '-' || s[j] == '*') && !used[j]){\n\t  used[j] = exist = true;\n\t}\n      }\n      if(!exist)return false;\n      stk.pop();\n      pos.pop();\n    }\n  }\n\n  return (int)stk.size() == 0;\n}\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n \n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      if(p == FAILED)return FAILED;\n      pos++;\n      return p;\n    }else{\n      int p=0,ru = 0;\n      string nes;\n      nes.clear();\n      while('0' <= parse[pos] && parse[pos] <= '1'){\n      nes += parse[pos];\n      pos++;\n      }\n      reverse(all(nes));\n      rep(i,nes.length()){\n\tif(nes[i] == '1')p += (1<<ru);\n\tru++;\n      }      \n      if(!(0<=p && p<1024))return FAILED;\n      return p;\n    }\n  }\n \n int term(){\n    int p = fact();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '*'){\n      if(parse[pos] == '*'){\n\tpos++;\n\tint pre;\n\tpre = fact();\n\tif(pre == FAILED)return FAILED;\n\tp*=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n \n int expression(){\n    int p = term();\n    if(p == FAILED)return FAILED;\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){\n\tpos++;\n\tint pre;\n\tpre = term();\n\tif(pre == FAILED)return FAILED;\n\tp += pre;\n\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n      else {\n\tpos++;\n\tint pre;\n\tpre =term();\n\tif(pre == FAILED)return FAILED;\n\tp-=pre;\n\tif(!(0<=p && p<1024))return FAILED;\n      }\n    }\n    return p;\n  }\n  \n \n};\n\n\nchar key[7] = {'+','*','-','0','1','(',')'};\n\nint Max = -1;\n\n\nvoid solve(string s){\n\n  rep(i,s.length()){\n    if(s[i] == '.'){\n      rep(j,7){\n\ts[i] = key[j];\n\tsolve(s);\n\ts[i] = '.';\n      }\n      break;\n    }\n    if(i == s.length()-1){\n      //cout << \"s = \" << s;\n      if(!check(s)){\n\t//cout << \" is Ver.1 FAILED\" << endl;\n\tcontinue;\n      }\n      Parsing par = Parsing(s);\n      int men = par.expression();\n      if(men == FAILED){\n\t//cout << \" is Ver.2 FAILED\" << endl;\n\tcontinue;\n      }\n      //cout << \"is OK\" << endl;\n      Max = max(Max,men);\n    }\n  }\n\n}\n\nint main(){\n  string s;\n  cin >> s;\n \n\n    solve(s);\n    cout << Max << endl;\n  \nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NUM_LIMIT (1<<10)\n\n#define OP_ADD   (-1)\n#define OP_SUB   (-2)\n#define OP_MUL   (-3)\n#define OP_KAKKO (-4)\n\nint stack_num;\nint stack[100];\nint rp_num;\nint rp[100];\n\nint rp_compile(const char* statement) {\n\tconst char* now;\n\tint expectOperator=0;\n\tint nownumber;\n\tstack_num=0;\n\trp_num=0;\n\tfor(now=statement;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase '+':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_ADD;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_SUB;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]==OP_MUL) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_MUL;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tif(expectOperator)return 0;\n\t\t\t\tstack[stack_num++]=OP_KAKKO;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\tif(stack_num<=0 || stack[stack_num-1]==OP_KAKKO)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--; else return 0;\n\t\t\t\texpectOperator=1;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\t\tif(expectOperator)return 0;\n\t\t\t\tnownumber=0;\n\t\t\t\tfor(;*now=='0' || *now=='1';now++) {\n\t\t\t\t\tnownumber=nownumber*2+(*now)-'0';\n\t\t\t\t\tif(nownumber>=NUM_LIMIT)return 0;\n\t\t\t\t}\n\t\t\t\tnow--;\n\t\t\t\texpectOperator=1;\n\t\t\t\trp[rp_num++]=nownumber;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tstack_num--;\n\t\tif(stack[stack_num]==OP_KAKKO)return 0;\n\t\trp[rp_num++]=stack[stack_num];\n\t}\n\treturn 1;\n}\n\nint rp_calc(void) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i]) {\n\t\t\tcase OP_ADD:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]+=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]>=NUM_LIMIT)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase OP_SUB:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]-=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]<0)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase OP_MUL:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]*=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]>=NUM_LIMIT)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstack[stack_num++]=rp[i];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn stack[0];\n}\n\nint main(void) {\n\tchar input[200];\n\tconst char* mozi=\"01+-*.\";\n\tint pos[5]={150,150,150,150,150};\n\tint i,j;\n\tint posnum;\n\tint search_max;\n\tint result;\n\tscanf(\"%s\",input);\n\tposnum=0;\n\tsearch_max=1;\n\tfor(i=0;input[i];i++) {\n\t\tif(input[i]=='.') {\n\t\t\tpos[posnum++]=i;\n\t\t\tsearch_max*=6;\n\t\t}\n\t}\n\tresult=-1;\n\tfor(i=0;i<search_max;i++) {\n\t\tint temp=i;\n\t\tfor(j=0;j<posnum;j++) {\n\t\t\tinput[pos[j]]=mozi[temp%6];\n\t\t\ttemp/=6;\n\t\t}\n\t\tif(!rp_compile(input))continue;\n\t\ttemp=rp_calc();\n\t\tif(temp>result)result=temp;\n\t}\n\tprintf(\"%d\\n\",result);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2428\n  Title:Lost Number\n  @kankichi573\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <setjmp.h>\n// #include <stdlib.h>\n#include <string.h>\n// #include <math.h>\n// #include <float.h>\n// #include <stdlib.h>\n\njmp_buf jb;\n\nchar input[101];\nchar use[]=\"01()+-*\";\n\ndump(char * s,int len,char *title)\n{\n        int i;\n        printf(\"%s =\",title);\n        for(i=0;i<len;i++)\n                putchar(s[i]);\n        printf(\"\\n\");\n}\n\nint bin2num(char *s,char len)\n{\n        int i,ret;\n\n        for(i=0,ret=0;i<len;i++)\n        {\n                ret *= 2;\n                ret += (s[i]-'0');\n        }\n        return(ret);\n}\nint all_number(char * s,int len)\n{\n  //dump(s,len,\"ALL NUM\");  \n  if(len==0)\n    return(0);\n  if(s[0]=='0'||s[0]=='1')\n    {\n      if(len==1)\n\treturn(1);\n      else\n\treturn(all_number(s+1,len-1));\n    }\n  else\n    return(0);\n}\nint check_paren(char * s,int len)\n{\n  int i,lv;\n  //dump(s,len,\"CK P\");  \n  for(i=0,lv=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tlv++;\n      if(s[i]==')')\n\tlv--;\n      if(lv<0)\n\t  longjmp(jb,1);\n    }\n  if(lv==0)\n    return(1);\n  else\n    longjmp(jb,1);\n}\nint check_paren2(char * s,int len)\n{\n  int i,lv;\n  //dump(s,len,\"CK P\");  \n  for(i=0,lv=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tlv++;\n      if(s[i]==')')\n\tlv--;\n      if(lv==0 && i<len-1)\n        return(0);\n      if(lv<0)\n\t  longjmp(jb,1);\n    }\n  if(lv==0)\n    return(1);\n  else\n    longjmp(jb,1);\n}\n//\n// evaluate binary expression\n//\nint eval_bin_ex(char * s,int len,int in_paren)\n{\n  char i,fst,lst,depth;\n  int  ret,ret1,ret2;\n\n  if(len==0)\n    longjmp(jb,1);\n  \n  fst=s[0];lst=s[len-1];\n\n#ifdef DUMP  \n  dump(s,len,\"EVAL\");\n#endif\n  if(all_number(s,len))\n    {\n      if(!in_paren)\n\t{\n\t  ret=bin2num(s,len);\n\t  if(ret<1024)\n\t    return(ret);\n\t  else\n\t    longjmp(jb,1);\n\t}\n      else\n\tlongjmp(jb,1);\n    }\n  if(fst=='+'||fst=='-'||fst=='*'||fst==')')\n    longjmp(jb,1);\n  if(lst=='+'||lst=='-'||lst=='*'||lst=='(')\n    longjmp(jb,1);\n  if(!check_paren(s,len))\n    longjmp(jb,1);\n  if(fst=='(' && lst==')' && !in_paren && check_paren2(s,len))\n    return(eval_bin_ex(s+1,len-2,1));\n  \n  for(i=0,depth=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tdepth++;\n      if(s[i]==')')\n\tdepth--;\n      \n      if(depth==0 && (s[i]=='+' || s[i]=='-'))\n\t{\n\t  ret1=eval_bin_ex(s,i,0);\n\t  ret2=eval_bin_ex(s+i+1,len-i-1,0);\n\t  if(s[i]=='+')\n\t    ret=ret1+ret2;\n\t  else\n\t    ret=ret1-ret2;\n\t  //printf(\"%d %c %d = %d \\n\",ret1,s[i],ret2,ret);\n\t  if(ret>=0 && ret < 1024)\n\t    return(ret);\n\t  else\n\t    longjmp(jb,1);\n\t}\n\t\n    }\n\n  for(i=0,depth=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tdepth++;\n      if(s[i]==')')\n\tdepth--;\n\n      if(depth==0 && s[i]=='*')\n\t{\n\t  ret1=eval_bin_ex(s,i,0);\n\t  ret2=eval_bin_ex(s+i+1,len-i-1,0);\n\t  ret=ret1*ret2;\n\t  //printf(\"%d * %d = %d \\n\",ret1,ret2,ret);\n\t  if(ret<1024)\n\t    return(ret1*ret2);    \n\t  else\n\t    longjmp(jb,1);\n\t}\n    }\n  longjmp(jb,1);\n}\nint replace_dot(char * s,char c)\n{\n  while(*s)\n    {\n      if(*s=='.')\n\t{\n\t  *s=c;\n\t  break;\n\t}\n      s++;\n    }\n\n}\nint solve(char *s,int ast_cnt)\n{\n  int i,ret,max_;\n  char mybuffer[101];\n  char mybuffer2[101];\n\n  if(ast_cnt==0)\n    if(setjmp( jb ) == 0 ) {\n      return(eval_bin_ex(s,strlen(s),0));\n    }\n    else\n      return(-1);\n  \n  \n  max_=-2;\n  strcpy(mybuffer,s);\n  for(i=0;i<sizeof(use)-1;i++)\n    {\n      strcpy(mybuffer2,mybuffer);\n      replace_dot(mybuffer2,use[i]);\n      ret=solve(mybuffer2,ast_cnt-1);\n#ifdef DEBUG\n      if(ast_cnt==1)\n\tprintf(\"%s=%d[%d]\\n\",mybuffer2,ret,ast_cnt);\n#endif\n      if(ret>max_)\n\tmax_=ret;\n    }\n  return(max_);\n}\nint count_dot(char * s)\n{\n  int cnt=0;\n  \n  while(*s)\n    {\n      if(*s=='.')\n\tcnt++;\n      s++;\n    }\n  return(cnt);\n}\n\nmain()\n{\n  int cnt_dot;\n  \n  scanf(\"%s\",input);\n  cnt_dot=count_dot(input);\n  printf(\"%d\\n\",solve(input,cnt_dot));\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2428: Lost Number\n// 2017.10.19 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1024\n\nchar q[10002][102]; int top;\n\nchar *expr();\nchar *factor(char *s, char *p, int *z, int *op)\n{\n\tint x, k;\n\n\tif (*p == '(') {\n\t\tif ((p = expr(s, p+1, &x, &k)) == NULL) return NULL;\n\t\tif (!k) return NULL;\n\t\tp++;\n\t\t*op = k;\n\t} else if (*p == '1' || *p == '0' || *p == '.') {\n\t\tx = 0;\n\t\twhile (*p == '1' || *p == '0') x = (x << 1) + (*p++ - '0');\n\t\twhile (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '1';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '0';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '(';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = ')';\n\t\t\tx = (x << 1) + 1, p++;\n\t\t}\n\t\twhile (*p == '1' || *p == '0') x = (x << 1) + (*p++ - '0');\n\t\t*op = 0;\n\t} else return NULL;\n\tif (x < 0 || x >= MAX) return NULL;\n\t*z = x;\n\treturn p;\n}\n\nchar *term(char *s, char *p, int *z, int *op)\n{\n\tint x, y, k = 0;\n\n\tif ((p = factor(s, p, &x, &k)) == NULL) return NULL;\n\twhile (1) {\n\t\tif (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tbreak;\n\t\t} else if (*p == '*') ;\n\t\telse break;\n\t\tif ((p = factor(s, p+1, &y, &k)) == NULL) return NULL;\n\t\tx *= y, k = 1;\n\t\tif (x < 0 || x >= MAX) return NULL;\n\t}\n\t*z = x;\n\t*op = k;\n\treturn p;\n}\n\nchar *expr(char *s, char *p, int *z, int *op)\n{\n\tint x, y, t, k = 0;\n\t\n\tif ((p = term(s, p, &x, &k)) == NULL) return NULL;\n\twhile (1) {\n\t\tif (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tbreak;\n\t\t} else if (*p == '+') t = 1;\n\t\telse if (*p == '-') t = 0;\n\t\telse break;\n\t\tif ((p = term(s, p+1, &y, &k)) == NULL) return NULL; \n\t\tif (t) x += y;\n\t\telse   x -= y;\n\t\tk = 1;\n\t\tif (x < 0 || x >= MAX) return NULL;\n\t}\n\t*z = x;\n\t*op = k;\n\treturn p;\n}\n\nint main()\n{\n\tint n, op, ans;\n\tchar *p;\n\n\tscanf(\"%s\", q[0]);\n\tans = -1, top = 1;\n\twhile (top > 0) {\n\t\ttop--;\n\t\tif ((p = expr(q[top], q[top], &n, &op)) == NULL) continue;\n\t\tif (*p) continue;\n\t\tif (n >= 0 && n < MAX && n > ans) ans = n;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2428: Lost Number\n// 2017.10.19 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1024\n\nchar q[10002][102]; int top;\n\nchar *expr();\nchar *factor(char *s, char *p, int *z, int *op)\n{\n\tint x, k;\n\n\tif (*p == '(') {\n\t\tif ((p = expr(s, p+1, &x, &k)) == NULL) return NULL;\n\t\tif (!k || (*p != ')' && *p != '.')) return NULL;\n\t\tp++;\n\t\t*op = k;\n\t} else if (*p == '1' || *p == '0' || *p == '.') {\n\t\tx = 0;\n\t\twhile (*p == '1' || *p == '0') x = (x << 1) + (*p++ - '0');\n\t\twhile (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '1';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '0';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '(';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = ')';\n\t\t\tx = (x << 1) + 1, p++;\n\t\t}\n\t\twhile (*p == '1' || *p == '0') x = (x << 1) + (*p++ - '0');\n\t\t*op = 0;\n\t} else return NULL;\n\tif (x < 0 || x >= MAX) return NULL;\n\t*z = x;\n\treturn p;\n}\n\nchar *term(char *s, char *p, int *z, int *op)\n{\n\tint x, y, k = 0;\n\n\tif ((p = factor(s, p, &x, &k)) == NULL) return NULL;\n\twhile (1) {\n\t\tif (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tbreak;\n\t\t} else if (*p == '*') ;\n\t\telse break;\n\t\tif ((p = factor(s, p+1, &y, &k)) == NULL) return NULL;\n\t\tx *= y, k = 1;\n\t\tif (x < 0 || x >= MAX) return NULL;\n\t}\n\t*z = x;\n\t*op = k;\n\treturn p;\n}\n\nchar *expr(char *s, char *p, int *z, int *op)\n{\n\tint x, y, t, k = 0;\n\t\n\tif ((p = term(s, p, &x, &k)) == NULL) return NULL;\n\twhile (1) {\n\t\tif (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tbreak;\n\t\t} else if (*p == '+') t = 1;\n\t\telse if (*p == '-') t = 0;\n\t\telse break;\n\t\tif ((p = term(s, p+1, &y, &k)) == NULL) return NULL; \n\t\tif (t) x += y;\n\t\telse   x -= y;\n\t\tk = 1;\n\t\tif (x < 0 || x >= MAX) return NULL;\n\t}\n\t*z = x;\n\t*op = k;\n\treturn p;\n}\n\nint main()\n{\n\tint n, op, ans;\n\tchar *p;\n\n\tscanf(\"%s\", q[0]);\n\tans = -1, top = 1;\n\twhile (top > 0) {\n\t\ttop--;\n\t\tif ((p = expr(q[top], q[top], &n, &op)) == NULL) continue;\n\t\tif (*p) continue;\n\t\tif (n >= 0 && n < MAX && n > ans) ans = n;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2428: Lost Number\n// 2017.10.19 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1024\n\nchar q[10002][102]; int top;\n\nchar *expr();\nchar *factor(char *s, char *p, int *z, int *op)\n{\n\tint x, k;\n\n\tif (*p == '(') {\n\t\tk = 0;\n\t\tif ((p = expr(s, p+1, &x, &k)) == NULL) return NULL;\n\t\tif (!k || (*p != ')' && *p != '.')) return NULL;\n\t\tp++;\n\t\t*op = 0;\n\t} else if (*p == '1' || *p == '0' || *p == '.') {\n\t\tx = 0;\n\t\twhile (*p == '1' || *p == '0') x = (x << 1) + (*p++ - '0');\n\t\twhile (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '1';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '0';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '(';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = ')';\n\t\t\tx = (x << 1) + 1, p++;\n\t\t}\n\t\twhile (*p == '1' || *p == '0') x = (x << 1) + (*p++ - '0');\n\t\t*op = 0;\n\t} else return NULL;\n\tif (x < 0 || x >= MAX) return NULL;\n\t*z = x;\n\treturn p;\n}\n\nchar *term(char *s, char *p, int *z, int *op)\n{\n\tint x, y, k = 0;\n\n\tif ((p = factor(s, p, &x, &k)) == NULL) return NULL;\n\twhile (1) {\n\t\tif (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tbreak;\n\t\t} else if (*p == '*') ;\n\t\telse break;\n\t\tif ((p = factor(s, p+1, &y, &k)) == NULL) return NULL;\n\t\tx *= y, k = 1;\n\t\tif (x < 0 || x >= MAX) return NULL;\n\t}\n\t*z = x;\n\t*op = k;\n\treturn p;\n}\n\nchar *expr(char *s, char *p, int *z, int *op)\n{\n\tint x, y, t, k = 0;\n\t\n\tif ((p = term(s, p, &x, &k)) == NULL) return NULL;\n\twhile (1) {\n\t\tif (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tbreak;\n\t\t} else if (*p == '+') t = 1;\n\t\telse if (*p == '-') t = 0;\n\t\telse break;\n\t\tif ((p = term(s, p+1, &y, &k)) == NULL) return NULL; \n\t\tif (t) x += y;\n\t\telse   x -= y;\n\t\tk = 1;\n\t\tif (x < 0 || x >= MAX) return NULL;\n\t}\n\t*z = x;\n\t*op = k;\n\treturn p;\n}\n\nint main()\n{\n\tint n, op, ans;\n\tchar *p;\n\n\tscanf(\"%s\", q[0]);\n\tans = -1, top = 1;\n\twhile (top > 0) {\n\t\ttop--;\n\t\tif ((p = expr(q[top], q[top], &n, &op)) == NULL) continue;\n\t\tif (*p) continue;\n\t\tif (n >= 0 && n < MAX && n > ans) ans = n;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2428: Lost Number\n// 2017.10.19 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1024\n\nchar q[10002][102]; int top;\n\nchar *expr();\nchar *factor(char *s, char *p, int *z, int *op)\n{\n\tint x, k;\n\n\tif (*p == '(') {\n\t\tk = 0;\n\t\tif ((p = expr(s, p+1, &x, &k)) == NULL) return NULL;\n\t\tif (!k || (*p != ')' && *p != '.')) return NULL;\n\t\tp++;\n\t\t*op = 0;\n\t} else if (*p == '1' || *p == '0' || *p == '.') {\n\t\tx = 0;\n\t\twhile (*p == '1' || *p == '0') x = (x << 1) + (*p++ - '0');\n\t\twhile (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '1';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '0';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '(';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = ')';\n\t\t\tx = (x << 1) + 1, p++;\n\t\t}\n\t\twhile (*p == '1' || *p == '0') x = (x << 1) + (*p++ - '0');\n\t\t*op = 0;\n\t} else return NULL;\n\tif (x < 0 || x >= MAX) return NULL;\n\t*z = x;\n\treturn p;\n}\n\nchar *term(char *s, char *p, int *z, int *op)\n{\n\tint x, y, k = 0;\n\n\tif ((p = factor(s, p, &x, &k)) == NULL) return NULL;\n\twhile (1) {\n\t\tif (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tbreak;\n\t\t} else if (*p == '*') ;\n\t\telse break;\n\t\tif ((p = factor(s, p+1, &y, &k)) == NULL) return NULL;\n\t\tx *= y, k = 1;\n\t\tif (x < 0 || x >= MAX) return NULL;\n\t}\n\t*z = x;\n\t*op = k;\n\treturn p;\n}\n\nchar *expr(char *s, char *p, int *z, int *op)\n{\n\tint x, y, t, k = 0;\n\t\n\tif ((p = term(s, p, &x, &k)) == NULL) return NULL;\n\twhile (1) {\n\t\tif (*p == '.') {\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '*';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '+';\n\t\t\tstrcpy(q[top], s), q[top++][p-s] = '-';\n\t\t\tbreak;\n\t\t} else if (*p == '+') t = 1;\n\t\telse if (*p == '-') t = 0;\n\t\telse break;\n\t\tif ((p = term(s, p+1, &y, &k)) == NULL) return NULL; \n\t\tif (t) x += y;\n\t\telse   x -= y;\n\t\tk = 1;\n\t\tif (x < 0 || x >= MAX) return NULL;\n\t}\n\t*z = x;\n\t*op = k;\n\treturn p;\n}\n\nint main()\n{\n\tint n, op, ans;\n\tchar *p;\n\n\tscanf(\"%s\", q[0]);\n\tans = -1, top = 1;\n\twhile (top > 0) {\n\t\ttop--;\n\t\tif ((p = expr(q[top], q[top], &n, &op)) == NULL) continue;\n\t\tif (*p) continue;\n\t\tif (n >= 0 && n < MAX && n > ans) ans = n;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NUM_LIMIT (1<<10)\n\n#define OP_ADD   (-1)\n#define OP_SUB   (-2)\n#define OP_MUL   (-3)\n#define OP_KAKKO (-4)\n\nint stack_num;\nint stack[100];\nint rp_num;\nint rp[100];\n\nint rp_compile(const char* statement) {\n\tconst char* now;\n\tint expectOperator=0;\n\tint nownumber;\n\tstack_num=0;\n\trp_num=0;\n\tfor(now=statement;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase '+':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_ADD;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_SUB;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]==OP_MUL) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_MUL;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tif(expectOperator)return 0;\n\t\t\t\tstack[stack_num++]=OP_KAKKO;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\tif(stack_num<=0 || stack[stack_num-1]==OP_KAKKO)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--; else return 0;\n\t\t\t\texpectOperator=1;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\t\tnownumber=0;\n\t\t\t\tfor(;*now=='0' || *now=='1';now++) {\n\t\t\t\t\tnownumber=nownumber*2+(*now)-'0';\n\t\t\t\t\tif(nownumber>=NUM_LIMIT)return 0;\n\t\t\t\t}\n\t\t\t\tnow--;\n\t\t\t\texpectOperator=1;\n\t\t\t\trp[rp_num++]=nownumber;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tstack_num--;\n\t\tif(stack[stack_num]==OP_KAKKO)return 0;\n\t\trp[rp_num++]=stack[stack_num];\n\t}\n\treturn 1;\n}\n\nint rp_calc(void) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i]) {\n\t\t\tcase OP_ADD:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]+=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]>=NUM_LIMIT)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase OP_SUB:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]-=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]<0)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase OP_MUL:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]*=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]>=NUM_LIMIT)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstack[stack_num++]=rp[i];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn stack[0];\n}\n\nint main(void) {\n\tchar input[200];\n\tconst char* mozi=\"01+-*.\";\n\tint pos[5]={150,150,150,150,150};\n\tint i,j;\n\tint posnum;\n\tint search_max;\n\tint result;\n\tscanf(\"%s\",input);\n\tposnum=0;\n\tsearch_max=1;\n\tfor(i=0;input[i];i++) {\n\t\tif(input[i]=='.') {\n\t\t\tpos[posnum++]=i;\n\t\t\tsearch_max*=6;\n\t\t}\n\t}\n\tresult=-1;\n\tfor(i=0;i<search_max;i++) {\n\t\tint temp=i;\n\t\tfor(j=0;j<posnum;j++) {\n\t\t\tinput[pos[j]]=mozi[temp%6];\n\t\t\ttemp/=6;\n\t\t}\n\t\tif(!rp_compile(input))continue;\n\t\ttemp=rp_calc();\n\t\tif(temp>result)result=temp;\n\t}\n\tprintf(\"%d\\n\",result);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2428\n  Title:Lost Number\n  @kankichi573\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <setjmp.h>\n// #include <stdlib.h>\n#include <string.h>\n// #include <math.h>\n// #include <float.h>\n// #include <stdlib.h>\n\njmp_buf jb;\n\nchar input[101];\nchar use[]=\"01()+-*\";\n\nint bin2num(char *s,char len)\n{\n        int i,ret;\n\n        for(i=0,ret=0;i<len;i++)\n        {\n                ret *= 2;\n                ret += (s[i]-'0');\n        }\n        return(ret);\n}\nint all_number(char * s,int len)\n{\n        if(len==0)\n                return(0);\n        if(s[0]=='0'||s[0]=='1')\n        {\n                if(len==1)\n                        return(1);\n                else\n                        return(all_number(s+1,len-1));\n        }\n        else\n                return(0);\n}\ndump(char * s,int len)\n{\n        int i;\n        printf(\"ARG=\");\n        for(i=0;i<len;i++)\n                putchar(s[i]);\n        printf(\"\\n\");\n}\nint check_paren(char * s,int len)\n{\n  int i,lv;\n  \n  for(i=0,lv=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tlv++;\n      if(s[i]==')')\n\tlv--;\n      if(lv<0)\n\tlongjmp(jb,1);\n      if(i<len-1 && lv==0)\n\treturn(0);\n    }\n  if(lv==0)\n    return(1);\n  else\n    longjmp(jb,1);\n        \n}\n//\n// evaluate binary expression\n//\nint eval_bin_ex(char * s,int len,int in_paren)\n{\n  char i,fst,lst,depth;\n  int  ret,ret1,ret2;\n\n  if(len==0)\n    longjmp(jb,1);\n  \n  fst=s[0];lst=s[len-1];\n  \n  //dump(s,len);\n  if(all_number(s,len))\n    {\n      if(!in_paren)\n\t{\n\t  ret=bin2num(s,len);\n\t  if(ret<1024)\n\t    return(ret);\n\t  else\n\t    longjmp(jb,1);\n\t}\n      else\n\tlongjmp(jb,1);\n    }\n  if(fst=='+'||fst=='-'||fst=='*'||fst==')')\n    longjmp(jb,1);\n  if(lst=='+'||lst=='-'||lst=='*'||lst=='(')\n    longjmp(jb,1);\n  if(fst=='(' && lst==')' && check_paren(s,len))\n    return(eval_bin_ex(s+1,len-2,1));\n  \n  for(i=0,depth=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tdepth++;\n      if(s[i]==')')\n\tdepth--;\n      \n      if(depth==0 && (s[i]=='+' || s[i]=='-'))\n\t{\n\t  ret1=eval_bin_ex(s,i,0);\n\t  ret2=eval_bin_ex(s+i+1,len-i-1,0);\n\t  if(s[i]=='+')\n\t    ret=ret1+ret2;\n\t  else\n\t    ret=ret1-ret2;\n\t  if(ret>=0 && ret < 1024)\n\t    return(ret);\n\t  else\n\t    longjmp(jb,1);\n\t}\n\t\n    }\n  for(i=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tdepth++;\n      if(s[i]==')')\n\tdepth--;\n      if(depth)\n\tlongjmp(jb,1);\n      if(depth==0 && s[i]=='*')\n\t{\n\t  ret1=eval_bin_ex(s,i,0);\n\t  ret2=eval_bin_ex(s+i+1,len-i-1,0);\n\t  ret=ret1*ret2;\n\t  if(ret<1024)\n\t    return(ret1*ret2);    \n\t  else\n\t    longjmp(jb,1);\n\t}\n    }\n}\nint replace_dot(char * s,char c)\n{\n  while(*s)\n    {\n      if(*s=='.')\n\t{\n\t  *s=c;\n\t  break;\n\t}\n      s++;\n    }\n\n}\nint solve(char *s,int ast_cnt)\n{\n  int i,ret,max_;\n  char mybuffer[101];\n  char mybuffer2[101];\n\n  if(ast_cnt==0)\n    if(setjmp( jb ) == 0 ) {\n      return(eval_bin_ex(s,strlen(s),0));\n    }\n    else\n      return(-1);\n  \n  \n  max_=-2;\n  strcpy(mybuffer,s);\n  for(i=0;i<sizeof(use)-1;i++)\n    {\n      strcpy(mybuffer2,mybuffer);\n      replace_dot(mybuffer2,use[i]);\n      ret=solve(mybuffer2,ast_cnt-1);\n#ifdef DEBUG\n      if(ast_cnt==1)\n\tprintf(\"%s=%d[%d]\\n\",mybuffer2,ret,ast_cnt);\n#endif\n      if(ret>max_)\n\tmax_=ret;\n    }\n  return(max_);\n}\nint count_dot(char * s)\n{\n  int cnt=0;\n  \n  while(*s)\n    {\n      if(*s=='.')\n\tcnt++;\n      s++;\n    }\n  return(cnt);\n}\n\nmain()\n{\n  int cnt_dot;\n  \n  scanf(\"%s\",input);\n  cnt_dot=count_dot(input);\n  printf(\"%d\\n\",solve(input,cnt_dot));\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2428\n  Title:Lost Number\n  @kankichi573\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <setjmp.h>\n// #include <stdlib.h>\n#include <string.h>\n// #include <math.h>\n// #include <float.h>\n// #include <stdlib.h>\n\njmp_buf jb;\n\nchar input[101];\nchar use[]=\"01()+-*\";\n\ndump(char * s,int len,char *title)\n{\n        int i;\n        printf(\"%s =\",title);\n        for(i=0;i<len;i++)\n                putchar(s[i]);\n        printf(\"\\n\");\n}\n\nint bin2num(char *s,char len)\n{\n        int i,ret;\n\n        for(i=0,ret=0;i<len;i++)\n        {\n                ret *= 2;\n                ret += (s[i]-'0');\n        }\n        return(ret);\n}\nint all_number(char * s,int len)\n{\n  //dump(s,len,\"ALL NUM\");  \n  if(len==0)\n    return(0);\n  if(s[0]=='0'||s[0]=='1')\n    {\n      if(len==1)\n\treturn(1);\n      else\n\treturn(all_number(s+1,len-1));\n    }\n  else\n    return(0);\n}\nint check_paren(char * s,int len)\n{\n  int i,lv;\n  //dump(s,len,\"CK P\");  \n  for(i=0,lv=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tlv++;\n      if(s[i]==')')\n\tlv--;\n      if(lv<0)\n\t  longjmp(jb,1);\n    }\n  if(lv==0)\n    return(1);\n  else\n    longjmp(jb,1);\n}\nint check_paren2(char * s,int len)\n{\n  int i,lv;\n  //dump(s,len,\"CK P\");  \n  for(i=0,lv=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tlv++;\n      if(s[i]==')')\n\tlv--;\n      if(lv==0 && i<len-1)\n        return(0);\n      if(lv<0)\n\t  longjmp(jb,1);\n    }\n  if(lv==0)\n    return(1);\n  else\n    longjmp(jb,1);\n}\n//\n// evaluate binary expression\n//\nint eval_bin_ex(char * s,int len,int in_paren)\n{\n  char i,fst,lst,depth;\n  int  ret,ret1,ret2;\n\n  if(len==0)\n    longjmp(jb,1);\n  \n  fst=s[0];lst=s[len-1];\n\n#ifdef DUMP  \n  dump(s,len,\"EVAL\");\n#endif\n  if(all_number(s,len))\n    {\n      if(!in_paren)\n\t{\n\t  ret=bin2num(s,len);\n\t  if(ret<1024)\n\t    return(ret);\n\t  else\n\t    longjmp(jb,1);\n\t}\n      else\n\tlongjmp(jb,1);\n    }\n  if(fst=='+'||fst=='-'||fst=='*'||fst==')')\n    longjmp(jb,1);\n  if(lst=='+'||lst=='-'||lst=='*'||lst=='(')\n    longjmp(jb,1);\n  if(!check_paren(s,len))\n    longjmp(jb,1);\n  if(fst=='(' && lst==')' && !in_paren && check_paren2(s,len))\n    return(eval_bin_ex(s+1,len-2,1));\n  \n  for(i=len-1,depth=0;i>=0;i--)\n    {\n      if(s[i]=='(')\n\tdepth--;\n      if(s[i]==')')\n\tdepth++;\n      \n      if(depth==0 && (s[i]=='+' || s[i]=='-'))\n\t{\n\t  ret1=eval_bin_ex(s,i,0);\n\t  ret2=eval_bin_ex(s+i+1,len-i-1,0);\n\t  if(s[i]=='+')\n\t    ret=ret1+ret2;\n\t  else\n\t    ret=ret1-ret2;\n\t  //printf(\"%d %c %d = %d \\n\",ret1,s[i],ret2,ret);\n\t  if(ret>=0 && ret < 1024)\n\t    return(ret);\n\t  else\n\t    longjmp(jb,1);\n\t}\n\t\n    }\n\n  for(i=0,depth=0;i<len;i++)\n    {\n      if(s[i]=='(')\n\tdepth++;\n      if(s[i]==')')\n\tdepth--;\n\n      if(depth==0 && s[i]=='*')\n\t{\n\t  ret1=eval_bin_ex(s,i,0);\n\t  ret2=eval_bin_ex(s+i+1,len-i-1,0);\n\t  ret=ret1*ret2;\n\t  //printf(\"%d * %d = %d \\n\",ret1,ret2,ret);\n\t  if(ret<1024)\n\t    return(ret1*ret2);    \n\t  else\n\t    longjmp(jb,1);\n\t}\n    }\n  longjmp(jb,1);\n}\nint replace_dot(char * s,char c)\n{\n  while(*s)\n    {\n      if(*s=='.')\n\t{\n\t  *s=c;\n\t  break;\n\t}\n      s++;\n    }\n\n}\nint solve(char *s,int ast_cnt)\n{\n  int i,ret,max_;\n  char mybuffer[101];\n  char mybuffer2[101];\n\n  if(ast_cnt==0)\n    if(setjmp( jb ) == 0 ) {\n      return(eval_bin_ex(s,strlen(s),0));\n    }\n    else\n      return(-1);\n  \n  \n  max_=-2;\n  strcpy(mybuffer,s);\n  for(i=0;i<sizeof(use)-1;i++)\n    {\n      strcpy(mybuffer2,mybuffer);\n      replace_dot(mybuffer2,use[i]);\n      ret=solve(mybuffer2,ast_cnt-1);\n#ifdef DEBUG\n      if(ast_cnt==1)\n\tprintf(\"%s=%d[%d]\\n\",mybuffer2,ret,ast_cnt);\n#endif\n      if(ret>max_)\n\tmax_=ret;\n    }\n  return(max_);\n}\nint count_dot(char * s)\n{\n  int cnt=0;\n  \n  while(*s)\n    {\n      if(*s=='.')\n\tcnt++;\n      s++;\n    }\n  return(cnt);\n}\n\nmain()\n{\n  int cnt_dot;\n  \n  scanf(\"%s\",input);\n  cnt_dot=count_dot(input);\n  printf(\"%d\\n\",solve(input,cnt_dot));\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NUM_LIMIT (1<<10)\n\n#define OP_ADD   (-1)\n#define OP_SUB   (-2)\n#define OP_MUL   (-3)\n#define OP_KAKKO (-4)\n\nint stack_num;\nint stack[100];\nint rp_num;\nint rp[100];\n\nint rp_compile(const char* statement) {\n\tconst char* now;\n\tint expectOperator=0;\n\tint nownumber;\n\tstack_num=0;\n\trp_num=0;\n\tfor(now=statement;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase '+':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_ADD;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_SUB;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]==OP_MUL) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tstack[stack_num++]=OP_MUL;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tif(expectOperator)return 0;\n\t\t\t\tstack[stack_num++]=OP_KAKKO;\n\t\t\t\texpectOperator=0;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tif(!expectOperator)return 0;\n\t\t\t\tif(stack_num<=0 || stack[stack_num-1]==OP_KAKKO)return 0;\n\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=OP_KAKKO) {\n\t\t\t\t\trp[rp_num++]=stack[--stack_num];\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--; else return 0;\n\t\t\t\texpectOperator=1;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\t\tif(expectOperator)return 0;\n\t\t\t\tnownumber=0;\n\t\t\t\tfor(;*now=='0' || *now=='1';now++) {\n\t\t\t\t\tnownumber=nownumber*2+(*now)-'0';\n\t\t\t\t\tif(nownumber>=NUM_LIMIT)return 0;\n\t\t\t\t}\n\t\t\t\tnow--;\n\t\t\t\texpectOperator=1;\n\t\t\t\trp[rp_num++]=nownumber;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tstack_num--;\n\t\tif(stack[stack_num]==OP_KAKKO)return 0;\n\t\trp[rp_num++]=stack[stack_num];\n\t}\n\treturn 1;\n}\n\nint rp_calc(void) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<rp_num;i++) {\n\t\tswitch(rp[i]) {\n\t\t\tcase OP_ADD:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]+=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]>=NUM_LIMIT)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase OP_SUB:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]-=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]<0)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tcase OP_MUL:\n\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\tstack[stack_num-2]*=stack[stack_num-1];\n\t\t\t\tif(stack[stack_num-2]>=NUM_LIMIT)return -1;\n\t\t\t\tstack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstack[stack_num++]=rp[i];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn stack[0];\n}\n\nint main(void) {\n\tchar input[200];\n\tconst char* mozi=\"01+-*()\";\n\tint pos[5]={150,150,150,150,150};\n\tint i,j;\n\tint posnum;\n\tint search_max;\n\tint result;\n\tscanf(\"%s\",input);\n\tposnum=0;\n\tsearch_max=1;\n\tfor(i=0;input[i];i++) {\n\t\tif(input[i]=='.') {\n\t\t\tpos[posnum++]=i;\n\t\t\tsearch_max*=7;\n\t\t}\n\t}\n\tresult=-1;\n\tfor(i=0;i<search_max;i++) {\n\t\tint temp=i;\n\t\tfor(j=0;j<posnum;j++) {\n\t\t\tinput[pos[j]]=mozi[temp%7];\n\t\t\ttemp/=7;\n\t\t}\n\t\tif(!rp_compile(input))continue;\n\t\ttemp=rp_calc();\n\t\tif(temp>result)result=temp;\n\t}\n\tprintf(\"%d\\n\",result);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tchar [] work;\n\tArrayList<ArrayList<Character>> list;\n\tchar [] op = {'+', '-','*', '(', ')', '0', '1'};\n\tboolean isvalid;\n\tStringBuilder s;\n\tint pos;\n\tchar end = '#';\n\t//2040 start\n\t//2215 WA\n\t//2220 modi single operation -> WA\n\t//2235 modi () in exist operation WA\n\t//2242 modi single operation  -> WA\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\ts = new StringBuilder(sc.next() + \"#\");\n\t\t\tn = 0;\n\t\t\tisvalid = true;\n\t\t\tArrayList<Integer> indl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < s.length(); i++){\n\t\t\t\tif(s.charAt(i) == '.'){\n\t\t\t\t\tn++;\n\t\t\t\t\tindl.add(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(n == 0){\n\t\t\t\t//評価する\n\t\t\t\tpos = 0;\n\t\t\t\tisvalid = true;\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\tint ans = eval();\n\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tans = -1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(Math.max(ans, -1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = new char[n];\n\t\t\tlist = new ArrayList<ArrayList<Character>>();\n\t\t\tdfs(0);\n\t\t\tint len = list.size();\n\t\t\tint ans = -1;\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tisvalid = true;\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0 ; j < n;j++){\n\t\t\t\t\ts.setCharAt(indl.get(j), list.get(i).get(j));\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"i = \" + i + \" \" + s.toString());\n\t\t\t\t//check\n\t\t\t\tif(! check()) isvalid = false;\n\n\t\t\t\t//評価する\n\t\t\t\tint now = eval();\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tnow = -1;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, now);\n\t\t\t\t//debug\n\t\t\t\t//              if(now == -1){\n\t\t\t\t\t//                  System.out.print(s.toString());\n\t\t\t\t//                  System.out.println(\" no = \" + now);\n\t\t\t\t//              }\n\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\n\tprivate boolean check() {\n\t\tStringBuilder str = new StringBuilder(s.toString());\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\n\t\tfor(int i = 0 ; i < str.length(); i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c == '('){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t\telse if(c == ')'){\n\t\t\t\tboolean f = false;\n\t\t\t\twhile((! stack.isEmpty()) && (stack.peekLast() != '(')){\n\t\t\t\t\tstack.removeLast();\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif(! f) return false;\n\t\t\t\tif(stack.isEmpty()){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstack.removeLast();\n\t\t\t}\n\t\t\telse if(c == '+' || c == '-' || c == '*'){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tprivate int eval() {\n\t\tint res = exp();\n\t\tif(pos != s.length() - 1){\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int term() {\n\t\tif(! isvalid) return -1;\n\t\tint res = fact();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '*')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tres = old * res;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int fact() {\n\t\tif(! isvalid) return -1;\n\t\tif(Character.isDigit(s.charAt(pos))){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(s.charAt(pos++));\n\t\t\twhile(Character.isDigit(s.charAt(pos))){\n\t\t\t\tsb.append(s.charAt(pos++));\n\t\t\t}\n\t\t\tint res = Integer.parseInt(sb.toString(), 2);\n\t\t\treturn res;\n\t\t}\n\t\telse if(s.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint res = exp();\n\t\t\tif(! isvalid) return -1;\n\t\t\tif(s.charAt(pos) != ')'){\n\t\t\t\tisvalid = false;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\tArrayList<Character> a = new ArrayList<Character>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\ta.add(work[i]);\n\t\t\t}\n\t\t\tlist.add(a);\n\t\t\treturn ;\n\t\t}\n\n\t\tfor(int i = 0 ; i < op.length;i++){\n\t\t\twork[deep] = op[i];\n\t\t\tdfs(deep + 1);\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\tfinal char[] op={'0', '1', '+', '-', '*', '(', ')'};\n\tchar[] cs;\n\tint max;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tcs=(s+=\"$\").toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tif(i==cs.length){\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\tr.good&=r.p==cs.length-1;\n\t\t// check\n\t\tif(r.good){\n\t\t\tint n=cs.length;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tboolean op=false;\n\t\t\t\tint stack=0;\n\t\t\t\tfor(int j=i+1; cs[j]!=')'||stack!=0; j++){\n\t\t\t\t\tif(cs[j]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[j]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t\tif(stack==0)\n\t\t\t\t\t\top|=cs[j]=='+'||cs[j]=='-'||cs[j]=='*';\n\t\t\t\t}\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\tResult E(int p){\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tif(!r.update()){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tif(!r.update()){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tr.good&=cs[r.p]==')';\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[r.p]); r.p++){\n\t\t\t\tr.value=r.value*2+cs[r.p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tboolean update(){\n\t\t\tgood&=0<=value&&value<1024;\n\t\t\treturn good;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tchar [] work;\n\tArrayList<ArrayList<Character>> list;\n\tchar [] op = {'+', '-','*', '(', ')', '0', '1'};\n\tboolean isvalid;\n\tStringBuilder s;\n\tint pos;\n\tchar end = '#';\n\t//2240 start\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\ts = new StringBuilder(sc.next() + \"#\");\n\t\t\tn = 0;\n\t\t\tisvalid = true;\n\t\t\tArrayList<Integer> indl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < s.length(); i++){\n\t\t\t\tif(s.charAt(i) == '.'){\n\t\t\t\t\tn++;\n\t\t\t\t\tindl.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\t//評価する\n\t\t\t\tpos = 0;\n\t\t\t\tisvalid = true;\n\t\t\t\tint ans = eval();\n\t\t\t\t\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tans = -1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = new char[n];\n\t\t\tlist = new ArrayList<ArrayList<Character>>();\n\t\t\tdfs(0);\n\t\t\tint len = list.size();\n\t\t\tint ans = -1;\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tisvalid = true;\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0 ; j < n;j++){\n\t\t\t\t\ts.setCharAt(indl.get(j), list.get(i).get(j));\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"i = \" + i + \" \" + s.toString());\n\t\t\t\t\n\t\t\t\t//評価する\n\t\t\t\tint now = eval();\n\t\t\t\t\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tnow = -1;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, now);\n\t\t\t\t//debug\n//\t\t\t\tif(now == 2){\n//\t\t\t\t\tSystem.out.println(s.toString());\n//\t\t\t\t}\n\t\t\t\t//System.out.println(\"no =            \" + now);\n\t\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\n\tprivate int eval() {\n\t\tint res = exp();\n\t\tif(pos != s.length() - 1){\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int term() {\n\t\tif(! isvalid) return -1;\n\t\tint res = fact();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '*')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tres = old * res;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int fact() {\n\t\tif(! isvalid) return -1;\n\t\tif(Character.isDigit(s.charAt(pos))){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(s.charAt(pos++));\n\t\t\twhile(Character.isDigit(s.charAt(pos))){\n\t\t\t\tsb.append(s.charAt(pos++));\n\t\t\t}\n\t\t\tint res = Integer.parseInt(sb.toString(), 2);\n\t\t\treturn res;\n\t\t}\n\t\telse if(s.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint ind = pos;\n\t\t\tboolean f = false;\n\t\t\twhile(s.charAt(ind) != ')' && s.charAt(ind) !=  end){\n\t\t\t\t\n\t\t\t\tif(s.charAt(ind) == '+' || s.charAt(ind) == '-' || s.charAt(ind) == '*'){\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tif(! f){\n\t\t\t\tisvalid = false; return -1;\n\t\t\t}\n\t\t\tint res = exp();\n\t\t\tif(! isvalid) return -1;\n\t\t\tif(s.charAt(pos) != ')'){\n\t\t\t\tisvalid = false;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\tArrayList<Character> a = new ArrayList<Character>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\ta.add(work[i]);\n\t\t\t}\n\t\t\tlist.add(a);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < op.length;i++){\n\t\t\twork[deep] = op[i];\n\t\t\tdfs(deep + 1);\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tif(id==s.length){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tsum += q.pop();\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\tchar c = s[id];\n\t\t\tid++;\n\t\t\tif(c=='('){\n\t\t\t\tint num = calc();\n\t\t\t\tq.push(num);\n\t\t\t}else if(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else if(c=='*'){\n\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\tq.push(num);\t\n\t\t\t\tmul = true;\n\t\t\t\tsb = new StringBuilder();\n\t\t\t}else{\n\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\tif(mns) num *= -1;\n\t\t\t\tq.push(num);\n\t\t\t\tif(c=='-') mns = true;\n\t\t\t\telse mns = false;\n\t\t\t\tmul = false;\n\t\t\t\tsb = new StringBuilder();\n\t\t\t\tif(c==')'){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tsum += q.pop();\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tmax = Math.max(max, calc());\n\t\t\t//for(int i=0;i<s.length;i++) System.out.print(s[i]);\n\t\t\t//System.out.println();\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Lost Number\n// 2012/10/09\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tfinal char[] op={'0', '1', '+', '-', '*', '(', ')'};\n\tString s;\n\tchar[] cs;\n\tint max;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tif(i==cs.length){\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\tr.good&=r.p==cs.length-1;\n\t\tif(r.good){\n\t\t\tfor(int i=0; i<cs.length; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint stack=0;\n\t\t\t\tboolean op=false;\n\t\t\t\tfor(int j=i+1; cs[j]!=')'||stack!=0; j++){\n\t\t\t\t\tif(cs[j]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[j]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t\tif(stack==0){\n\t\t\t\t\t\top|=cs[j]=='+'||cs[j]=='-'||cs[j]=='*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\tResult E(int p){\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tif(!r.update()){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tif(!r.update()){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[r.p]); r.p++){\n\t\t\t\tr.value=r.value*2+cs[r.p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tboolean update(){\n\t\t\treturn good&=0<=value&&value<1024;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tchar[] cs;\n\tint max;\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tchar[] op={'0', '1', '+', '-', '*', '(', ')'};\n\t\tif(i==cs.length){\n\t\t\t// 発動\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\t// debug(cs);\n\t\tr.good&=r.p==cs.length-1;\n\t\t// debug(r.good, r.p, r.value);\n\t\t// ()の間には記号がいる\n\t\t// if(false)\n\t\tif(r.good){\n\t\t\t// ((1*1)) X\n\t\t\tint n=cs.length;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint left=i, right=left+1;\n\t\t\t\tint stack=0;\n\t\t\t\tboolean op=false;\n\t\t\t\tfor(; cs[right]!=')'||stack!=0; right++){\n\t\t\t\t\tif(cs[right]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[right]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t\tif(stack==0)\n\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t}\n\t\t\t\t// debug(left, right);\n\t\t\t\tif(false){\n\t\t\t\tfor(left++; cs[left]!='('&&cs[left]!=')'; left++){\n\t\t\t\t\top|=cs[left]=='+'||cs[left]=='-'||cs[left]=='*';\n\t\t\t\t}\n\t\t\t\tfor(right--; cs[right]!='('&&cs[right]!=')'; right--){\n\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// debug(\"op\", op);\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t\t// debug(r.bad);\n\t\t}\n\t\t/*\n\t\tif(r.good&&new String(cs).indexOf('(')>=0){\n\t\t\tdebug(new String(cs), r.value);\n\t\t}\n\t\t*/\n\t\treturn r.good?r.value:-1;\n\t}\n\n\t// 0~1023\n\n\tboolean debug=false;\n\n\tResult E(int p){\n\t\tif(debug)\n\t\t\tdebug(\"E\", p);\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tif(debug)\n\t\t\tdebug(\"F\", p);\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(debug)\n\t\t\tdebug(\"T\", p);\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[r.p]); r.p++){\n\t\t\t\tr.value=r.value*2+cs[r.p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tvoid update(){\n\t\t\tif(value<0||value>=1024){\n\t\t\t\tgood=false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tif(id==s.length){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tif(sb.length()>10) return Integer.MAX_VALUE;\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tsum += q.pop();\n\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\tchar c = s[id];\n\t\t\tid++;\n\t\t\tif(c=='('){\n\t\t\t\tint num = calc();\n\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\tif(mns) num *= -1;\n\t\t\t\tq.push(num);\n\t\t\t\tmns = false;\n\t\t\t\tmul = false;\n\t\t\t}else if(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else if(c=='*'){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tif(sb.length()>10) return Integer.MAX_VALUE;\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tmul = true;\n\t\t\t}else{\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tif(sb.length()>10) return Integer.MAX_VALUE;\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tif(c=='-') mns = true;\n\t\t\t\telse mns = false;\n\t\t\t\tmul = false;\n\t\t\t\tif(c==')'){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tsum += q.pop();\n\t\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tint num = calc();\n\t\t\tif(num>=0 && num<=1023)\tmax = Math.max(max, num);\n\t\t\t//for(int i=0;i<s.length;i++) System.out.print(s[i]);\n\t\t\t//System.out.println();\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "// Lost Number\nimport java.util.*;\n\npublic class Main {\n\tstatic String formula;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tformula = sc.next();\n\t\tint result = replaceAndSearch();\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tstatic int replaceAndSearch() {\n\t\tString[] replaces = { \"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\" };\n\t\tStringBuilder sb = new StringBuilder(formula);\n\t\tint result = -1;\n\t\tif (formula.contains(\".\")) {\n\t\t\tint p = formula.indexOf(\".\");\n\t\t\tfor (int i = 0; i < replaces.length; i++) {\n\t\t\t\tformula = sb.replace(p, p + 1, replaces[i]).toString();\n\t\t\t\tresult = Math.max(result, replaceAndSearch());\n\t\t\t\tformula = sb.replace(p, p + 1, \".\").toString();\n\t\t\t}\n\t\t} else {\n\t\t\tpos = 0;\n\t\t\tif (isExp())\n\t\t\t\tresult = exp();\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic boolean isExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length()) {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tpos = 0;\n\t\treturn true;\n\t}\n\n\tstatic boolean isTerm() {\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar c = formula.charAt(pos);\n\t\tif (c == '(') {\n\t\t\tpos++;\n\t\t\treturn isParExp();\n\t\t}\n\t\tif (Character.isDigit(c)) {\n\t\t\tnumber();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isParExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar op = formula.charAt(pos++);\n\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\treturn false;\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\top = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tif (pos >= formula.length() || formula.charAt(pos++) != ')')\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tstatic int number() {\n\t\tint result = 0;\n\t\twhile (pos < formula.length() && Character.isDigit(formula.charAt(pos))) {\n\t\t\tresult *= 2;\n\t\t\tresult += formula.charAt(pos++) - '0';\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int exp() {\n\t\tint result = term();\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op == '+')\n\t\t\t\tresult += term();\n\t\t\telse\n\t\t\t\tresult -= term();\n\t\t\tif (result < 0 || result >= 1024)\n\t\t\t\treturn -1;\n\t\t}\n\t\tpos++;\n\t\treturn result;\n\t}\n\n\tstatic int term() {\n\t\tint result = mul();\n\t\twhile (pos < formula.length() && formula.charAt(pos) == '*') {\n\t\t\tpos++;\n\t\t\tresult *= mul();\n\t\t}\n\t\tif (result >= 1024)\n\t\t\treturn -1;\n\t\treturn result;\n\t}\n\n\tstatic int mul() {\n\t\tif (formula.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\treturn exp();\n\t\t}\n\t\tint n = number();\n\t\tif (n >= 1024)\n\t\t\treturn -1;\n\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tchar[] cs;\n\tint max;\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tchar[] op={'0', '1', '+', '-', '*', '(', ')'};\n\t\tif(i==cs.length){\n\t\t\t// 発動\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\t// debug(cs);\n\t\tr.good&=r.p==cs.length-1;\n\t\t// debug(r.good, r.p, r.value);\n\t\t// ()の間には記号がいる\n\t\t// if(false)\n\t\tif(r.good){\n\t\t\t// ((1*1)) X\n\t\t\tint n=cs.length;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint left=i, right=left+1;\n\t\t\t\tint stack=0;\n\t\t\t\tfor(; cs[right]!=')'||stack!=0; right++){\n\t\t\t\t\tif(cs[right]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[right]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean op=false;\n\t\t\t\t// debug(left, right);\n\t\t\t\tfor(left++; cs[left]!='('&&cs[left]!=')'; left++){\n\t\t\t\t\top|=cs[left]=='+'||cs[left]=='-'||cs[left]=='*';\n\t\t\t\t}\n\t\t\t\tfor(right--; cs[right]!='('&&cs[right]!=')'; right--){\n\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t}\n\t\t\t\t// debug(\"op\", op);\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t\t// debug(r.bad);\n\t\t}\n\t\tif(r.good&&new String(cs).indexOf('(')>=0){\n\t\t\tdebug(new String(cs), r.value);\n\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\t// 0~1023\n\n\tboolean debug=false;\n\n\tResult E(int p){\n\t\tif(debug)\n\t\t\tdebug(\"E\", p);\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tif(debug)\n\t\t\tdebug(\"F\", p);\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(debug)\n\t\t\tdebug(\"T\", p);\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[p]); p++){\n\t\t\t\tr.value=r.value*2+cs[p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tvoid update(){\n\t\t\tif(value<0||value>=1024){\n\t\t\t\tgood=false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static String[] symbol = {\"0\",\"1\",\"+\",\"-\",\"*\",\"(\",\")\"};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\tint dots = 0;\n\t\tArrayList<Integer> doti = new ArrayList<Integer>();\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i) == '.') {\n\t\t\t\tdots ++;\n\t\t\t\tdoti.add(i);\n\t\t\t}\n\t\t}\n\t\tint[] p = new int[dots];\n\t\t\n\t\tint ans = -1;\n\t\twhile(true) {\n\t\t\tString exp = new String(s);\n\t\t\tfor(int i=0;i<dots;i++) {\n\t\t\t\tString a = exp.substring(0,doti.get(i));\n\t\t\t\tString b = exp.substring(doti.get(i)+1,exp.length());\n\t\t\t\texp = a + symbol[p[i]] + b;\n\t\t\t}\n\t\t\t\n\t\t\tindex = 0;\n\t\t\tint n = expression(exp);\n\t\t\t\n\t\t\tboolean next = true;\n\t\t\tif (dots == 0) {\n\t\t\t\tnext = false;\n\t\t\t}\n\t\t\tfor(int i=0;i<p.length;i++) {\n\t\t\t\tif (p[i]<6) {\n\t\t\t\t\tp[i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(i<p.length-1) {\n\t\t\t\t\t\tp[i] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = Math.max(ans,n);\n\t\t\t\n\t\t\tif (!next) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tpublic static int index = 0;\n\tpublic static int expression(String s) {\n\t\treturn expression(s, false);\n\t}\n\tpublic static int expression(String s,boolean needconnective) {\n\t\tint n = term(s);\n\t\tif (n < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tboolean connective = false;\n\t\twhile(index < s.length()) {\n\t\t\tif (s.charAt(index) == '+') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn += number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t\tconnective = true;\n\t\t\t}else if(s.charAt(index) == '-') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn -= number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t\tconnective = true;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(0 <= n && n < 2<<10)) {\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t}\n\t\tif (needconnective && !connective) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn n;\n\t}\n\tpublic static int term(String s) {\n\t\tint n = number(s);\n\t\tif (n < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\twhile(index < s.length()) {\n\t\t\tif (s.charAt(index) == '*') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn *= number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(0 <= n && n < 2<<10)) {\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\tpublic static int number(String s) {\n\t\tif (index >= s.length()) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (s.charAt(index) == '(') {\n\t\t\tindex++;\n\t\t\tint n = expression(s,true);\n\t\t\tif (index >= s.length() || s.charAt(index) != ')') {\n\t\t\t\treturn -1;\n\t\t\t}else{\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\t\tchar c0 = s.charAt(index);\n\t\tif (c0 != '0' && c0 != '1') {\n\t\t\treturn -1;\n\t\t}\n\t\tint n = 0;\n\t\twhile(index < s.length()) {\n\t\t\tchar c = s.charAt(index);\n\t\t\tif (c == '0' || c == '1') {\n\t\t\t\tn*=2;\n\t\t\t\tn += c - '0';\n\t\t\t\tindex++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tchar [] work;\n\tArrayList<ArrayList<Character>> list;\n\tchar [] op = {'+', '-','*', '(', ')', '0', '1'};\n\tboolean isvalid;\n\tStringBuilder s;\n\tint pos;\n\tchar end = '#';\n\t//2040 start\n\t//2215 WA\n\t//2220 modi single operation -> WA\n\t//2235 modi () in exist operation\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\ts = new StringBuilder(sc.next() + \"#\");\n\t\t\tn = 0;\n\t\t\tisvalid = true;\n\t\t\tArrayList<Integer> indl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < s.length(); i++){\n\t\t\t\tif(s.charAt(i) == '.'){\n\t\t\t\t\tn++;\n\t\t\t\t\tindl.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\t//評価する\n\t\t\t\tpos = 0;\n\t\t\t\tisvalid = true;\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\tint ans = eval();\n\t\t\t\t\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tans = -1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = new char[n];\n\t\t\tlist = new ArrayList<ArrayList<Character>>();\n\t\t\tdfs(0);\n\t\t\tint len = list.size();\n\t\t\tint ans = -1;\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tisvalid = true;\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0 ; j < n;j++){\n\t\t\t\t\ts.setCharAt(indl.get(j), list.get(i).get(j));\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"i = \" + i + \" \" + s.toString());\n\t\t\t\t//check\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\t\n\t\t\t\t//評価する\n\t\t\t\tint now = eval();\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tnow = -1;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, now);\n\t\t\t\t//debug\n//\t\t\t\tif(now == 2){\n//\t\t\t\t\tSystem.out.println(s.toString());\n//\t\t\t\t}\n\t\t\t\t//System.out.println(\"no =            \" + now);\n\t\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\n\tprivate boolean check() {\n\t\tStringBuilder str = new StringBuilder(s.toString());\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\n\t\tfor(int i = 0 ; i < str.length(); i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c == '('){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t\telse if(c == ')'){\n\t\t\t\tboolean f = false;\n\t\t\t\twhile((! stack.isEmpty()) && (stack.peekLast() != '(')){\n\t\t\t\t\tstack.removeLast();\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif(! f) return false;\n\t\t\t\tif(stack.isEmpty()){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstack.removeLast();\n\t\t\t}\n\t\t\telse if(c == '+' || c == '-' || c == '*'){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tprivate int eval() {\n\t\tint res = exp();\n\t\tif(pos != s.length() - 1){\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int term() {\n\t\tif(! isvalid) return -1;\n\t\tint res = fact();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '*')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tres = old * res;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int fact() {\n\t\tif(! isvalid) return -1;\n\t\tif(Character.isDigit(s.charAt(pos))){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(s.charAt(pos++));\n\t\t\twhile(Character.isDigit(s.charAt(pos))){\n\t\t\t\tsb.append(s.charAt(pos++));\n\t\t\t}\n\t\t\tint res = Integer.parseInt(sb.toString(), 2);\n\t\t\treturn res;\n\t\t}\n\t\telse if(s.charAt(pos) == '-'){\n\t\t\tpos++;\n\t\t\treturn -1 * fact();\n\t\t}\n\t\telse if(s.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint ind = pos;\n\t\t\tboolean f = false;\n\t\t\twhile(s.charAt(ind) != ')' && s.charAt(ind) !=  end){\n\t\t\t\t\n\t\t\t\tif(s.charAt(ind) == '+' || s.charAt(ind) == '-' || s.charAt(ind) == '*'){\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tif(! f){\n\t\t\t\tisvalid = false; return -1;\n\t\t\t}\n\t\t\tint res = exp();\n\t\t\tif(! isvalid) return -1;\n\t\t\tif(s.charAt(pos) != ')'){\n\t\t\t\tisvalid = false;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\tArrayList<Character> a = new ArrayList<Character>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\ta.add(work[i]);\n\t\t\t}\n\t\t\tlist.add(a);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < op.length;i++){\n\t\t\twork[deep] = op[i];\n\t\t\tdfs(deep + 1);\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static String[] symbol = {\"0\",\"1\",\"+\",\"-\",\"*\",\"(\",\")\"};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\tint dots = 0;\n\t\tArrayList<Integer> doti = new ArrayList<Integer>();\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i) == '.') {\n\t\t\t\tdots ++;\n\t\t\t\tdoti.add(i);\n\t\t\t}\n\t\t}\n\t\tint[] p = new int[dots];\n\t\t\n\t\tint ans = -1;\n\t\twhile(true) {\n\t\t\tString exp = new String(s);\n\t\t\tfor(int i=0;i<dots;i++) {\n\t\t\t\tString a = exp.substring(0,doti.get(i));\n\t\t\t\tString b = exp.substring(doti.get(i)+1,exp.length());\n\t\t\t\texp = a + symbol[p[i]] + b;\n\t\t\t}\n\t\t\t\n\t\t\tindex = 0;\n\t\t\tint n = expression(exp);\n\t\t\t\n\t\t\tboolean next = true;\n\t\t\tif (dots == 0) {\n\t\t\t\tnext = false;\n\t\t\t}\n\t\t\tfor(int i=0;i<p.length;i++) {\n\t\t\t\tif (p[i]<6) {\n\t\t\t\t\tp[i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(i<p.length-1) {\n\t\t\t\t\t\tp[i] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!next) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tans = Math.max(ans,n);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tpublic static int index = 0;\n\tpublic static int expression(String s) {\n\t\treturn expression(s, false);\n\t}\n\tpublic static int expression(String s,boolean needconnective) {\n\t\tint n = term(s);\n\t\tboolean connective = false;\n\t\twhile(index < s.length()) {\n\t\t\tif (s.charAt(index) == '+') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn += number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t\tconnective = true;\n\t\t\t}else if(s.charAt(index) == '-') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn -= number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t\tconnective = true;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(0 <= n && n < 2<<10)) {\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t}\n\t\tif (needconnective && !connective) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn n;\n\t}\n\tpublic static int term(String s) {\n\t\tint n = number(s);\n\t\twhile(index < s.length()) {\n\t\t\tif (s.charAt(index) == '*') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn *= number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(0 <= n && n < 2<<10)) {\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\tpublic static int number(String s) {\n\t\tif (index >= s.length()) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (s.charAt(index) == '(') {\n\t\t\tindex++;\n\t\t\tint n = expression(s,true);\n\t\t\tif (index >= s.length() || s.charAt(index) != ')') {\n\t\t\t\treturn -1;\n\t\t\t}else{\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\t\tchar c0 = s.charAt(index);\n\t\tif (c0 != '0' && c0 != '1') {\n\t\t\treturn -1;\n\t\t}\n\t\tint n = 0;\n\t\twhile(index < s.length()) {\n\t\t\tchar c = s.charAt(index);\n\t\t\tif (c == '0' || c == '1') {\n\t\t\t\tn*=2;\n\t\t\t\tn += c - '0';\n\t\t\t\tindex++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tchar [] work;\n\tArrayList<ArrayList<Character>> list;\n\tchar [] op = {'+', '-','*', '(', ')', '0', '1'};\n\tboolean isvalid;\n\tStringBuilder s;\n\tint pos;\n\tchar end = '#';\n\t//2040 start\n\t//2215 WA\n\t//2220 modi single operation -> WA\n\t//2235 modi () in exist operation WA\n\t//2242 modi single operation  -> WA\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\ts = new StringBuilder(sc.next() + \"#\");\n\t\t\tn = 0;\n\t\t\tisvalid = true;\n\t\t\tArrayList<Integer> indl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < s.length(); i++){\n\t\t\t\tif(s.charAt(i) == '.'){\n\t\t\t\t\tn++;\n\t\t\t\t\tindl.add(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(n == 0){\n\t\t\t\t//評価する\n\t\t\t\tpos = 0;\n\t\t\t\tisvalid = true;\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\tint ans = eval();\n\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tans = -1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(Math.max(ans, -1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = new char[n];\n\t\t\tlist = new ArrayList<ArrayList<Character>>();\n\t\t\tdfs(0);\n\t\t\tint len = list.size();\n\t\t\tint ans = -1;\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tisvalid = true;\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0 ; j < n;j++){\n\t\t\t\t\ts.setCharAt(indl.get(j), list.get(i).get(j));\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"i = \" + i + \" \" + s.toString());\n\t\t\t\t//check\n\t\t\t\tif(! check()) isvalid = false;\n\n\t\t\t\t//評価する\n\t\t\t\tint now = eval();\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tnow = -1;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, now);\n\t\t\t\t//debug\n\t\t\t\t//              if(now == -1){\n\t\t\t\t\t//                  System.out.print(s.toString());\n\t\t\t\t//                  System.out.println(\" no = \" + now);\n\t\t\t\t//              }\n\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int num){\n\t\tif(0<= num && num <= 1024){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate boolean check() {\n\t\tStringBuilder str = new StringBuilder(s.toString());\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\n\t\tfor(int i = 0 ; i < str.length(); i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c == '('){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t\telse if(c == ')'){\n\t\t\t\tboolean f = false;\n\t\t\t\twhile((! stack.isEmpty()) && (stack.peekLast() != '(')){\n\t\t\t\t\tstack.removeLast();\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif(! f) return false;\n\t\t\t\tif(stack.isEmpty()){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstack.removeLast();\n\t\t\t}\n\t\t\telse if(c == '+' || c == '-' || c == '*'){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tprivate int eval() {\n\t\tint res = exp();\n\t\tif(pos != s.length() - 1){\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(! isOK(res)){\n\t\t\t\t\tisvalid = false; return -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int term() {\n\t\tif(! isvalid) return -1;\n\t\tint res = fact();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '*')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tres = old * res;\n\t\t\t\tif(! isOK(res)){\n\t\t\t\t\tisvalid = false; return -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int fact() {\n\t\tif(! isvalid) return -1;\n\t\tif(Character.isDigit(s.charAt(pos))){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(s.charAt(pos++));\n\t\t\twhile(Character.isDigit(s.charAt(pos))){\n\t\t\t\tsb.append(s.charAt(pos++));\n\t\t\t}\n\t\t\tint res = Integer.parseInt(sb.toString(), 2);\n\t\t\tif(! isOK(res)){\n\t\t\t\tisvalid = false; return -1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\telse if(s.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint res = exp();\n\t\t\tif(! isvalid) return -1;\n\t\t\tif(s.charAt(pos) != ')'){\n\t\t\t\tisvalid = false;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\tArrayList<Character> a = new ArrayList<Character>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\ta.add(work[i]);\n\t\t\t}\n\t\t\tlist.add(a);\n\t\t\treturn ;\n\t\t}\n\n\t\tfor(int i = 0 ; i < op.length;i++){\n\t\t\twork[deep] = op[i];\n\t\t\tdfs(deep + 1);\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tchar c = '?';\n\t\t\tif(id<s.length){\n\t\t\t\tc = s[id];\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tif(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else{\n\t\t\t\tif(c=='(' || sb.length()>0){\n\t\t\t\t\tint num = -1;\n\t\t\t\t\tif(c=='(') num = calc();\n\t\t\t\t\telse if(sb.length()>0) num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(num<=-1024 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\t\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tmns = false;\n\t\t\t\tmul = false;\n\t\t\t\t\n\t\t\t\tif(c=='*'){\n\t\t\t\t\tmul = true;\n\t\t\t\t}else{\n\t\t\t\t\tif(c=='-') mns = true;\n\t\t\t\t\telse mns = false;\n\t\t\t\t\tmul = false;\n\t\t\t\t\tif(c==')' || id==s.length){\n\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\t\tsum += q.pollLast();\n\t\t\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn sum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tint num = calc();\n\t\t\tif(num>=0 && num<=1023)\tmax = Math.max(max, num);\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tchar[] cs;\n\tint max;\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tchar[] op={'0', '1', '+', '-', '*', '(', ')'};\n\t\tif(i==cs.length){\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\tr.good&=r.p==cs.length-1;\n\t\tif(r.good){\n\t\t\tint n=cs.length;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint left=i, right=left+1;\n\t\t\t\tint stack=0;\n\t\t\t\tboolean op=false;\n\t\t\t\tfor(; cs[right]!=')'||stack!=0; right++){\n\t\t\t\t\tif(cs[right]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[right]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t\tif(stack==0)\n\t\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t}\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\tResult E(int p){\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[r.p]); r.p++){\n\t\t\t\tr.value=r.value*2+cs[r.p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tvoid update(){\n\t\t\tif(value<0||value>=1024){\n\t\t\t\tgood=false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tchar[] cs;\n\tint max;\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tchar[] op={'0', '1', '+', '-', '*', '(', ')'};\n\t\tif(i==cs.length){\n\t\t\t// 発動\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n//\t\tdebug(cs);\n\t\tr.good&=r.p==cs.length-1;\n//\t\tdebug(r.good, r.p, r.value);\n\t\t// ()の間には記号がいる\n//\t\tif(false)\n\t\t\tif(r.good){\n\t\t\t\t// ((1*1)) X\n\t\t\t\tint n=cs.length;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint left=i, right=left+1;\n\t\t\t\t\tint stack=0;\n\t\t\t\t\tfor(; cs[right]!=')'||stack!=0; right++){\n\t\t\t\t\t\tif(cs[right]=='('){\n\t\t\t\t\t\t\tstack++;\n\t\t\t\t\t\t}else if(cs[right]==')'){\n\t\t\t\t\t\t\tstack--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tboolean op=false;\n//\t\t\t\t\t debug(left, right);\n\t\t\t\t\tfor(left++; cs[left]!='('&&cs[left]!=')'; left++){\n\t\t\t\t\t\top|=cs[left]=='+'||cs[left]=='-'||cs[left]=='*';\n\t\t\t\t\t}\n\t\t\t\t\tfor(right--; cs[right]!='('&&cs[right]!=')'; right--){\n\t\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t\t}\n\t\t\t\t\t// debug(\"op\", op);\n\t\t\t\t\tr.good&=op;\n\t\t\t\t}\n\t\t\t\t// debug(r.bad);\n\t\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\t// 0~1023\n\n\tboolean debug=false;\n\n\tResult E(int p){\n\t\tif(debug)\n\t\t\tdebug(\"E\", p);\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tif(debug)\n\t\t\tdebug(\"F\", p);\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(debug)\n\t\t\tdebug(\"T\", p);\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tint value=0;\n\t\t\tfor(; Character.isDigit(cs[p]); p++){\n\t\t\t\tvalue=value*2+cs[p]-'0';\n\t\t\t}\n\t\t\treturn new Result(p, value);\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tvoid update(){\n\t\t\tif(value<0||value>=1024){\n\t\t\t\tgood=false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tchar [] work;\n\tArrayList<ArrayList<Character>> list;\n\tchar [] op = {'+', '-','*', '(', ')', '0', '1'};\n\tboolean isvalid;\n\tStringBuilder s;\n\tint pos;\n\tchar end = '#';\n\t//2040 start\n\t//2215 WA\n\t//2220 modi single operation -> WA\n\t//2235 modi () in exist operation WA\n\t//2242 modi single operation  -> WA\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\ts = new StringBuilder(sc.next() + \"#\");\n\t\t\tn = 0;\n\t\t\tisvalid = true;\n\t\t\tArrayList<Integer> indl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < s.length(); i++){\n\t\t\t\tif(s.charAt(i) == '.'){\n\t\t\t\t\tn++;\n\t\t\t\t\tindl.add(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(n == 0){\n\t\t\t\t//評価する\n\t\t\t\tpos = 0;\n\t\t\t\tisvalid = true;\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\tint ans = eval();\n\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tans = -1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(Math.max(ans, -1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = new char[n];\n\t\t\tlist = new ArrayList<ArrayList<Character>>();\n\t\t\tdfs(0);\n\t\t\tint len = list.size();\n\t\t\tint ans = -1;\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tisvalid = true;\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0 ; j < n;j++){\n\t\t\t\t\ts.setCharAt(indl.get(j), list.get(i).get(j));\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"i = \" + i + \" \" + s.toString());\n\t\t\t\t//check\n\t\t\t\tif(! check()) isvalid = false;\n\n\t\t\t\t//評価する\n\t\t\t\tint now = eval();\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tnow = -1;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, now);\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int num){\n\t\tif(0<= num && num < 1024){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate boolean check() {\n\t\tStringBuilder str = new StringBuilder(s.toString());\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\n\t\tfor(int i = 0 ; i < str.length(); i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c == '('){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t\telse if(c == ')'){\n\t\t\t\tboolean f = false;\n\t\t\t\twhile((! stack.isEmpty()) && (stack.peekLast() != '(')){\n\t\t\t\t\tstack.removeLast();\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif(! f) return false;\n\t\t\t\tif(stack.isEmpty()){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstack.removeLast();\n\t\t\t}\n\t\t\telse if(c == '+' || c == '-' || c == '*'){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tprivate int eval() {\n\t\tint res = exp();\n\t\tif(pos != s.length() - 1){\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(! isOK(res)){\n\t\t\t\t\tisvalid = false; return -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int term() {\n\t\tif(! isvalid) return -1;\n\t\tint res = fact();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '*')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tres = old * res;\n\t\t\t\tif(! isOK(res)){\n\t\t\t\t\tisvalid = false; return -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int fact() {\n\t\tif(! isvalid) return -1;\n\t\tif(Character.isDigit(s.charAt(pos))){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(s.charAt(pos++));\n\t\t\twhile(Character.isDigit(s.charAt(pos))){\n\t\t\t\tsb.append(s.charAt(pos++));\n\t\t\t}\n\t\t\tint res = Integer.parseInt(sb.toString(), 2);\n\t\t\tif(! isOK(res)){\n\t\t\t\tisvalid = false; return -1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\telse if(s.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint res = exp();\n\t\t\tif(! isvalid) return -1;\n\t\t\tif(s.charAt(pos) != ')'){\n\t\t\t\tisvalid = false;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\tArrayList<Character> a = new ArrayList<Character>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\ta.add(work[i]);\n\t\t\t}\n\t\t\tlist.add(a);\n\t\t\treturn ;\n\t\t}\n\n\t\tfor(int i = 0 ; i < op.length;i++){\n\t\t\twork[deep] = op[i];\n\t\t\tdfs(deep + 1);\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tif(id==s.length){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tsum += q.pollLast();\n\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\tchar c = s[id];\n\t\t\tid++;\n\t\t\tif(c=='('){\n\t\t\t\tint num = calc();\n\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\tif(mns) num *= -1;\n\t\t\t\tq.push(num);\n\t\t\t\tmns = false;\n\t\t\t\tmul = false;\n\t\t\t}else if(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else if(c=='*'){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tmul = true;\n\t\t\t}else{\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tif(c=='-') mns = true;\n\t\t\t\telse mns = false;\n\t\t\t\tmul = false;\n\t\t\t\tif(c==')'){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tsum += q.pollLast();\n\t\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tint num = calc();\n\t\t\tif(num>=0 && num<=1023)\tmax = Math.max(max, num);\n\t\t\t//for(int i=0;i<s.length;i++) System.out.print(s[i]);\n\t\t\t//System.out.println();\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tchar [] work;\n\tArrayList<ArrayList<Character>> list;\n\tchar [] op = {'+', '-','*', '(', ')', '0', '1'};\n\tboolean isvalid;\n\tStringBuilder s;\n\tint pos;\n\tchar end = '#';\n\t//2040 start\n\t//2215 WA\n\t//2220 modi single operation -> WA\n\t//2235 modi () in exist operation WA\n\t//2242 modi single operation  -> WA\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\ts = new StringBuilder(sc.next() + \"#\");\n\t\t\tn = 0;\n\t\t\tisvalid = true;\n\t\t\tArrayList<Integer> indl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < s.length(); i++){\n\t\t\t\tif(s.charAt(i) == '.'){\n\t\t\t\t\tn++;\n\t\t\t\t\tindl.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\t//評価する\n\t\t\t\tpos = 0;\n\t\t\t\tisvalid = true;\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\tint ans = eval();\n\t\t\t\t\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tans = -1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(Math.max(ans, -1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = new char[n];\n\t\t\tlist = new ArrayList<ArrayList<Character>>();\n\t\t\tdfs(0);\n\t\t\tint len = list.size();\n\t\t\tint ans = -1;\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tisvalid = true;\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0 ; j < n;j++){\n\t\t\t\t\ts.setCharAt(indl.get(j), list.get(i).get(j));\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"i = \" + i + \" \" + s.toString());\n\t\t\t\t//check\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\t\n\t\t\t\t//評価する\n\t\t\t\tint now = eval();\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tnow = -1;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, now);\n\t\t\t\t//debug\n//\t\t\t\tif(now == -1){\n//\t\t\t\t\tSystem.out.print(s.toString());\n//\t\t\t\t\tSystem.out.println(\" no = \" + now);\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\n\tprivate boolean check() {\n\t\tStringBuilder str = new StringBuilder(s.toString());\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\n\t\tfor(int i = 0 ; i < str.length(); i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c == '('){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t\telse if(c == ')'){\n\t\t\t\tboolean f = false;\n\t\t\t\twhile((! stack.isEmpty()) && (stack.peekLast() != '(')){\n\t\t\t\t\tstack.removeLast();\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif(! f) return false;\n\t\t\t\tif(stack.isEmpty()){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstack.removeLast();\n\t\t\t}\n\t\t\telse if(c == '+' || c == '-' || c == '*'){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tprivate int eval() {\n\t\tint res = exp();\n\t\tif(pos != s.length() - 1){\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int term() {\n\t\tif(! isvalid) return -1;\n\t\tint res = fact();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '*')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tres = old * res;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int fact() {\n\t\tif(! isvalid) return -1;\n\t\tif(Character.isDigit(s.charAt(pos))){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(s.charAt(pos++));\n\t\t\twhile(Character.isDigit(s.charAt(pos))){\n\t\t\t\tsb.append(s.charAt(pos++));\n\t\t\t}\n\t\t\tint res = Integer.parseInt(sb.toString(), 2);\n\t\t\treturn res;\n\t\t}\n\t\telse if(s.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint ind = pos;\n\t\t\tboolean f = false;\n\t\t\twhile(s.charAt(ind) != ')' && s.charAt(ind) !=  end){\n\t\t\t\t\n\t\t\t\tif(s.charAt(ind) == '+' || s.charAt(ind) == '-' || s.charAt(ind) == '*'){\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tif(! f){\n\t\t\t\tisvalid = false; return -1;\n\t\t\t}\n\t\t\tint res = exp();\n\t\t\tif(! isvalid) return -1;\n\t\t\tif(s.charAt(pos) != ')'){\n\t\t\t\tisvalid = false;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\tArrayList<Character> a = new ArrayList<Character>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\ta.add(work[i]);\n\t\t\t}\n\t\t\tlist.add(a);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < op.length;i++){\n\t\t\twork[deep] = op[i];\n\t\t\tdfs(deep + 1);\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n \n \npublic class Main{\n     \n\tpublic static interface Expr{\n\t\tint exec();\n\t\tboolean check();\n\t}\n\t\n\tpublic static class Plus implements Expr{\n\t\tExpr left;\n\t\tExpr right;\n\t\t\n\t\tpublic Plus(Expr left, Expr right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int exec() {\n\t\t\treturn left.exec() + right.exec();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean check(){\n\t\t\treturn left != null && left.check() && right != null && right.check();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn left + \"+\" + right;\n\t\t}\n\t}\n\t\n\tpublic static class Mult implements Expr{\n\t\tExpr left;\n\t\tExpr right;\n\t\t\n\t\tpublic Mult(Expr left, Expr right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int exec() {\n\t\t\treturn left.exec() * right.exec();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean check(){\n\t\t\treturn left != null && left.check() && right != null && right.check();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn left + \"*\" + right;\n\t\t}\n\t}\n\t\n\tpublic static class Minus implements Expr{\n\t\tExpr left;\n\t\tExpr right;\n\t\t\n\t\tpublic Minus(Expr left, Expr right){\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic int exec() {\n\t\t\treturn left.exec() - right.exec();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean check(){\n\t\t\treturn left != null && left.check() && right != null && right.check();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn left + \"-\" + right;\n\t\t}\n\t}\n\t\n\tpublic static class Kakko implements Expr{\n\t\tExpr ops;\n\t\t\n\t\tpublic Kakko(Expr ops){\n\t\t\tthis.ops = ops;\n\t\t}\n\n\t\t@Override\n\t\tpublic int exec() {\n\t\t\treturn ops.exec();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean check(){\n\t\t\treturn ops != null && ops.check();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + ops + \")\";\n\t\t}\n\t}\n\t\n\tpublic static class Number implements Expr{\n\t\tint number;\n\t\t\n\t\tpublic Number(int n){\n\t\t\tnumber = n;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int exec() {\n\t\t\treturn number;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean check(){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn number + \"\";\n\t\t}\n\t}\n\t\n\tpublic static Expr parse(char[] input, int start, int end){\n\t\t\n\t\tint k_lv = 0;\n\t\tint k_s = -1;\n\t\tint k_e = -1;\n\t\tint mi_lv = Integer.MAX_VALUE;\n\t\tint mi_p = -1;\n\t\tint ad_lv = Integer.MAX_VALUE;\n\t\tint ad_p = -1;\n\t\tint ml_lv = Integer.MAX_VALUE;\n\t\tint ml_p = -1;\n\t\t\n\t\tfor(int pos = start; pos <= end; pos++){\n\t\t\tif(input[pos] == '('){\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_s = pos;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tk_lv++;\n\t\t\t}else if(input[pos] == ')'){\n\t\t\t\tk_lv--;\n\t\t\t\t\n\t\t\t\tif(k_lv == 0){\n\t\t\t\t\tk_e = pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(k_lv < 0){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}else if(input[pos] == '+' && ad_lv >= k_lv){\n\t\t\t\tif(ad_lv == k_lv){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tad_lv = k_lv;\n\t\t\t\tad_p = pos;\n\t\t\t}else if(input[pos] == '-' && mi_lv >= k_lv){\n\t\t\t\tif(mi_lv == k_lv){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tmi_lv = k_lv;\n\t\t\t\tmi_p = pos;\n\t\t\t}else if(input[pos] == '*' && ml_lv >= k_lv){\n\t\t\t\tif(ml_lv == k_lv){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tml_lv = k_lv;\n\t\t\t\tml_p = pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(k_lv != 0){\n\t\t\treturn null;\n\t\t}\n\t\t/*\n\t\tif(mi_lv == ad_lv || mi_lv == ml_lv || ad_lv == ml_lv){\n\t\t\treturn null;\n\t\t}\n\t\t*/\n\t\tif(k_s == start && k_e == end){\n\t\t\tif(mi_lv < ad_lv && mi_lv < ml_lv){\n\t\t\t\treturn new Kakko(new Minus(parse(input, k_s + 1, mi_p - 1), parse(input, mi_p + 1, k_e - 1)));\n\t\t\t}else if(ad_lv < mi_lv && ad_lv < ml_lv){\n\t\t\t\treturn new Kakko(new Plus(parse(input, k_s + 1, ad_p - 1), parse(input, ad_p + 1, k_e - 1)));\n\t\t\t}else if(ml_lv < ad_lv && ml_lv < mi_lv){\n\t\t\t\treturn new Kakko(new Mult(parse(input, k_s + 1, ml_p - 1), parse(input, ml_p + 1, k_e - 1)));\n\t\t\t}\n\t\t}else if(k_s == start){\n\t\t\tif(mi_lv < ad_lv && mi_lv < ml_lv){\n\t\t\t\tif(ad_lv < ml_lv){\n\t\t\t\t\treturn new Minus(new Kakko(new Plus(parse(input, k_s + 1, ad_p - 1), parse(input, ad_p + 1, k_e - 1))), parse(input, mi_p + 1, end));\n\t\t\t\t}else{\n\t\t\t\t\treturn new Minus(new Kakko(new Mult(parse(input, k_s + 1, ml_p - 1), parse(input, ml_p + 1, k_e - 1))), parse(input, mi_p + 1, end));\n\t\t\t\t}\n\t\t\t}else if(ad_lv < mi_lv && ad_lv < ml_lv){\n\t\t\t\tif(mi_lv < ml_lv){\n\t\t\t\t\treturn new Plus(new Kakko(new Minus(parse(input, k_s + 1, mi_p - 1), parse(input, mi_p + 1, k_e - 1))), parse(input, ad_p + 1, end));\n\t\t\t\t}else{\n\t\t\t\t\treturn new Plus(new Kakko(new Mult(parse(input, k_s + 1, ml_p - 1), parse(input, ml_p + 1, k_e - 1))), parse(input, ad_p + 1, end));\n\t\t\t\t}\n\t\t\t}else if(ml_lv < ad_lv && ml_lv < mi_lv){\n\t\t\t\tif(ad_lv < mi_lv){\n\t\t\t\t\treturn new Mult(new Kakko(new Plus(parse(input, k_s + 1, ad_p - 1), parse(input, ad_p + 1, k_e - 1))), parse(input, ml_p + 1, end));\n\t\t\t\t}else{\n\t\t\t\t\treturn new Mult(new Kakko(new Minus(parse(input, k_s + 1, mi_p - 1), parse(input, mi_p + 1, k_e - 1))), parse(input, ml_p + 1, end));\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(k_e == end){\n\t\t\tif(mi_lv < ad_lv && mi_lv < ml_lv){\n\t\t\t\tif(ad_lv < ml_lv){\n\t\t\t\t\treturn new Minus(parse(input, start, mi_p - 1), new Kakko(new Plus(parse(input, k_s + 1, ad_p - 1), parse(input, ad_p + 1, k_e - 1))));\n\t\t\t\t}else{\n\t\t\t\t\treturn new Minus(parse(input, start, mi_p - 1), new Kakko(new Mult(parse(input, k_s + 1, ml_p - 1), parse(input, ml_p + 1, k_e - 1))));\n\t\t\t\t}\n\t\t\t}else if(ad_lv < mi_lv && ad_lv < ml_lv){\n\t\t\t\tif(mi_lv < ml_lv){\n\t\t\t\t\treturn new Plus(parse(input, start, ad_p - 1), new Kakko(new Minus(parse(input, k_s + 1, mi_p - 1), parse(input, mi_p + 1, k_e - 1))));\n\t\t\t\t}else{\n\t\t\t\t\treturn new Plus(parse(input, start, ad_p - 1), new Kakko(new Mult(parse(input, k_s + 1, ml_p - 1), parse(input, ml_p + 1, k_e - 1))));\n\t\t\t\t}\n\t\t\t}else if(ml_lv < ad_lv && ml_lv < mi_lv){\n\t\t\t\tif(ad_lv < mi_lv){\n\t\t\t\t\treturn new Mult(parse(input, start, ml_p - 1), new Kakko(new Plus(parse(input, k_s + 1, ad_p - 1), parse(input, ad_p + 1, k_e - 1))));\n\t\t\t\t}else{\n\t\t\t\t\treturn new Mult(parse(input, start, ml_p - 1), new Kakko(new Minus(parse(input, k_s + 1, mi_p - 1), parse(input, mi_p + 1, k_e - 1))));\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(mi_p != -1){\n\t\t\t\treturn new Minus(parse(input, start, mi_p - 1), parse(input, mi_p + 1, end));\n\t\t\t}else if(ad_p != -1){\n\t\t\t\treturn new Plus(parse(input, start, ad_p - 1), parse(input, ad_p + 1, end));\n\t\t\t}else if(ml_p != -1){\n\t\t\t\treturn new Mult(parse(input, start, ml_p - 1), parse(input, ml_p + 1, end));\n\t\t\t}else if(start <= end){\n\t\t\t\tint num = 0;\n\t\t\t\tfor(int i = start; i <= end; i++){\n\t\t\t\t\tnum *= 2;\n\t\t\t\t\tnum += input[i] - '0';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn new Number(num);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static char[] rep = new char[]{'(', ')', '+', '-', '*', '0', '1'};\n\t\n\tpublic static int search(char[] input, int deep, int count, int[] pos){\n\t\tif(deep == count){\n\t\t\tExpr expr = parse(input, 0, input.length - 1);\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(input) + \" \" + expr);\n\t\t\t\n\t\t\tif(expr == null || !expr.check()){\n\t\t\t\treturn -1;\n\t\t\t}else{\n\t\t\t\treturn expr.exec();\n\t\t\t}\n\t\t}else{\n\t\t\tint max = -1;\n\t\t\tfor(char c : rep){\n\t\t\t\tinput[pos[deep]] = c;\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, search(input, deep + 1, count, pos));\n\t\t\t}\n\t\t\t\n\t\t\treturn max;\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n         \n    \tchar[] input = sc.next().toCharArray();\n    \t\n    \tint count = 0;\n    \tfor(char c : input){\n    \t\tif(c == '.'){\n    \t\t\tcount++;\n    \t\t}\n    \t}\n    \t\n    \tint[] pos = new int[count];\n    \tint t = 0;\n    \tfor(int i = 0; i < input.length; i++){\n    \t\tif(input[i] == '.'){\n    \t\t\tpos[t++] = i;\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(search(input, 0, count, pos));\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tchar c = '?';\n\t\t\tif(id<s.length){\n\t\t\t\tc = s[id];\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tif(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else{\n\t\t\t\tint num = -1;\n\t\t\t\tif(c=='(') num = calc();\n\t\t\t\telse if(sb.length()>0) num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\tif(num<=-1024 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\tif(mns) num *= -1;\n\t\t\t\tq.push(num);\n\t\t\t\tmns = false;\n\t\t\t\tmul = false;\n\t\t\t\tsb = new StringBuilder();\n\t\t\t\t\n\t\t\t\tif(c=='*'){\n\t\t\t\t\tmul = true;\n\t\t\t\t}else{\n\t\t\t\t\tif(c=='-') mns = true;\n\t\t\t\t\telse mns = false;\n\t\t\t\t\tmul = false;\n\t\t\t\t\tif(c==')' || id==s.length){\n\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\t\tsum += q.pollLast();\n\t\t\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn sum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tint num = calc();\n\t\t\tif(num>=0 && num<=1023)\tmax = Math.max(max, num);\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tif(id==s.length){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tsum += q.pop();\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\tchar c = s[id];\n\t\t\tid++;\n\t\t\tif(c=='('){\n\t\t\t\tint num = calc();\n\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\tif(mns) num *= -1;\n\t\t\t\tq.push(num);\n\t\t\t\tmns = false;\n\t\t\t\tmul = false;\n\t\t\t}else if(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else if(c=='*'){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tmul = true;\n\t\t\t}else{\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tif(c=='-') mns = true;\n\t\t\t\telse mns = false;\n\t\t\t\tmul = false;\n\t\t\t\tif(c==')'){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tsum += q.pop();\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tint num = calc();\n\t\t\tif(num>=0 && num<=1023)\tmax = Math.max(max, num);\n\t\t\t//for(int i=0;i<s.length;i++) System.out.print(s[i]);\n\t\t\t//System.out.println();\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tchar [] work;\n\tArrayList<ArrayList<Character>> list;\n\tchar [] op = {'+', '-','*', '(', ')', '0', '1'};\n\tboolean isvalid;\n\tStringBuilder s;\n\tint pos;\n\tchar end = '#';\n\t//2040 start\n\t//2215 WA\n\t//2220 modi single operation -> WA\n\t//2235 modi () in exist operation WA\n\t//2242 modi single operation \n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\ts = new StringBuilder(sc.next() + \"#\");\n\t\t\tn = 0;\n\t\t\tisvalid = true;\n\t\t\tArrayList<Integer> indl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < s.length(); i++){\n\t\t\t\tif(s.charAt(i) == '.'){\n\t\t\t\t\tn++;\n\t\t\t\t\tindl.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\t//評価する\n\t\t\t\tpos = 0;\n\t\t\t\tisvalid = true;\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\tint ans = eval();\n\t\t\t\t\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tans = -1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = new char[n];\n\t\t\tlist = new ArrayList<ArrayList<Character>>();\n\t\t\tdfs(0);\n\t\t\tint len = list.size();\n\t\t\tint ans = -1;\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tisvalid = true;\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0 ; j < n;j++){\n\t\t\t\t\ts.setCharAt(indl.get(j), list.get(i).get(j));\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"i = \" + i + \" \" + s.toString());\n\t\t\t\t//check\n\t\t\t\tif(! check()) isvalid = false;\n\t\t\t\t\n\t\t\t\t//評価する\n\t\t\t\tint now = eval();\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tnow = -1;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, now);\n\t\t\t\t//debug\n//\t\t\t\tif(now == 2){\n//\t\t\t\t\tSystem.out.println(s.toString());\n//\t\t\t\t}\n\t\t\t\t//System.out.println(\"no =            \" + now);\n\t\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\n\tprivate boolean check() {\n\t\tStringBuilder str = new StringBuilder(s.toString());\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\n\t\tfor(int i = 0 ; i < str.length(); i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c == '('){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t\telse if(c == ')'){\n\t\t\t\tboolean f = false;\n\t\t\t\twhile((! stack.isEmpty()) && (stack.peekLast() != '(')){\n\t\t\t\t\tstack.removeLast();\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tif(! f) return false;\n\t\t\t\tif(stack.isEmpty()){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstack.removeLast();\n\t\t\t}\n\t\t\telse if(c == '+' || c == '-' || c == '*'){\n\t\t\t\tstack.addLast(c);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tprivate int eval() {\n\t\tint res = exp();\n\t\tif(pos != s.length() - 1){\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int term() {\n\t\tif(! isvalid) return -1;\n\t\tint res = fact();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '*')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tres = old * res;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int fact() {\n\t\tif(! isvalid) return -1;\n\t\tif(Character.isDigit(s.charAt(pos))){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(s.charAt(pos++));\n\t\t\twhile(Character.isDigit(s.charAt(pos))){\n\t\t\t\tsb.append(s.charAt(pos++));\n\t\t\t}\n\t\t\tint res = Integer.parseInt(sb.toString(), 2);\n\t\t\treturn res;\n\t\t}\n\t\telse if(s.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint ind = pos;\n\t\t\tboolean f = false;\n\t\t\twhile(s.charAt(ind) != ')' && s.charAt(ind) !=  end){\n\t\t\t\t\n\t\t\t\tif(s.charAt(ind) == '+' || s.charAt(ind) == '-' || s.charAt(ind) == '*'){\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tif(! f){\n\t\t\t\tisvalid = false; return -1;\n\t\t\t}\n\t\t\tint res = exp();\n\t\t\tif(! isvalid) return -1;\n\t\t\tif(s.charAt(pos) != ')'){\n\t\t\t\tisvalid = false;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\tArrayList<Character> a = new ArrayList<Character>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\ta.add(work[i]);\n\t\t\t}\n\t\t\tlist.add(a);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < op.length;i++){\n\t\t\twork[deep] = op[i];\n\t\t\tdfs(deep + 1);\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tif(id==s.length){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tsum += q.pop();\n\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\tchar c = s[id];\n\t\t\tid++;\n\t\t\tif(c=='('){\n\t\t\t\tint num = calc();\n\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\tif(mns) num *= -1;\n\t\t\t\tq.push(num);\n\t\t\t\tmns = false;\n\t\t\t\tmul = false;\n\t\t\t}else if(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else if(c=='*'){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tmul = true;\n\t\t\t}else{\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tif(c=='-') mns = true;\n\t\t\t\telse mns = false;\n\t\t\t\tmul = false;\n\t\t\t\tif(c==')'){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tsum += q.pop();\n\t\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tint num = calc();\n\t\t\tif(num>=0 && num<=1023)\tmax = Math.max(max, num);\n\t\t\t//for(int i=0;i<s.length;i++) System.out.print(s[i]);\n\t\t\t//System.out.println();\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tchar[] cs;\n\tint max;\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tchar[] op={'0', '1', '+', '-', '*', '(', ')'};\n\t\tif(i==cs.length){\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\tr.good&=r.p==cs.length-1;\n\t\tif(r.good){\n\t\t\tint n=cs.length;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint left=i, right=left+1;\n\t\t\t\tint stack=0;\n\t\t\t\tboolean op=false;\n\t\t\t\tfor(; cs[right]!=')'||stack!=0; right++){\n\t\t\t\t\tif(cs[right]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[right]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t\tif(stack==0)\n\t\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t}\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\tResult E(int p){\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tr.good&=cs[r.p]==')';\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[r.p]); r.p++){\n\t\t\t\tr.value=r.value*2+cs[r.p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tvoid update(){\n\t\t\tgood&=0<=value&&value<1024;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tchar[] cs;\n\tint max;\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tchar[] op={'0', '1', '+', '-', '*', '(', ')'};\n\t\tif(i==cs.length){\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\tr.good&=r.p==cs.length-1;\n\t\tif(r.good){\n\t\t\tint n=cs.length;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint left=i, right=left+1;\n\t\t\t\tint stack=0;\n\t\t\t\tboolean op=false;\n\t\t\t\tfor(; cs[right]!=')'||stack!=0; right++){\n\t\t\t\t\tif(cs[right]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[right]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t\tif(stack==0)\n\t\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t}\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\tResult E(int p){\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[r.p]); r.p++){\n\t\t\t\tr.value=r.value*2+cs[r.p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tvoid update(){\n\t\t\tgood&=0<=value&&value<1024;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static String[] symbol = {\"0\",\"1\",\"+\",\"-\",\"*\",\"(\",\")\"};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\tint dots = 0;\n\t\tArrayList<Integer> doti = new ArrayList<Integer>();\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i) == '.') {\n\t\t\t\tdots ++;\n\t\t\t\tdoti.add(i);\n\t\t\t}\n\t\t}\n\t\tint[] p = new int[dots];\n\t\t\n\t\tint ans = -1;\n\t\twhile(true) {\n\t\t\tString exp = new String(s);\n\t\t\tfor(int i=0;i<dots;i++) {\n\t\t\t\tString a = exp.substring(0,doti.get(i));\n\t\t\t\tString b = exp.substring(doti.get(i)+1,exp.length());\n\t\t\t\texp = a + symbol[p[i]] + b;\n\t\t\t}\n\t\t\t\n\t\t\tindex = 0;\n\t\t\tint n = expression(exp);\n\t\t\t\n\t\t\tboolean next = true;\n\t\t\tif (dots == 0) {\n\t\t\t\tnext = false;\n\t\t\t}\n\t\t\tfor(int i=0;i<p.length;i++) {\n\t\t\t\tif (p[i]<6) {\n\t\t\t\t\tp[i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(i<p.length-1) {\n\t\t\t\t\t\tp[i] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = Math.max(ans,n);\n\t\t\t\n\t\t\tif (!next) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tpublic static int index = 0;\n\tpublic static int expression(String s) {\n\t\treturn expression(s, false);\n\t}\n\tpublic static int expression(String s,boolean needconnective) {\n\t\tint n = term(s);\n\t\tboolean connective = false;\n\t\twhile(index < s.length()) {\n\t\t\tif (s.charAt(index) == '+') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn += number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t\tconnective = true;\n\t\t\t}else if(s.charAt(index) == '-') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn -= number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t\tconnective = true;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(0 <= n && n < 2<<10)) {\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t}\n\t\tif (needconnective && !connective) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn n;\n\t}\n\tpublic static int term(String s) {\n\t\tint n = number(s);\n\t\twhile(index < s.length()) {\n\t\t\tif (s.charAt(index) == '*') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn *= number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(0 <= n && n < 2<<10)) {\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\tpublic static int number(String s) {\n\t\tif (index >= s.length()) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (s.charAt(index) == '(') {\n\t\t\tindex++;\n\t\t\tint n = expression(s,true);\n\t\t\tif (index >= s.length() || s.charAt(index) != ')') {\n\t\t\t\treturn -1;\n\t\t\t}else{\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\t\tchar c0 = s.charAt(index);\n\t\tif (c0 != '0' && c0 != '1') {\n\t\t\treturn -1;\n\t\t}\n\t\tint n = 0;\n\t\twhile(index < s.length()) {\n\t\t\tchar c = s.charAt(index);\n\t\t\tif (c == '0' || c == '1') {\n\t\t\t\tn*=2;\n\t\t\t\tn += c - '0';\n\t\t\t\tindex++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tchar[] cs;\n\tint max;\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tchar[] op={'0', '1', '+', '-', '*', '(', ')'};\n\t\tif(i==cs.length){\n\t\t\t// 発動\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\t// debug(cs);\n\t\tr.good&=r.p==cs.length-1;\n\t\t// debug(r.good, r.p, r.value);\n\t\t// ()の間には記号がいる\n\t\t// if(false)\n\t\tif(r.good){\n\t\t\t// ((1*1)) X\n\t\t\tint n=cs.length;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint left=i, right=left+1;\n\t\t\t\tint stack=0;\n\t\t\t\tfor(; cs[right]!=')'||stack!=0; right++){\n\t\t\t\t\tif(cs[right]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[right]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean op=false;\n\t\t\t\t// debug(left, right);\n\t\t\t\tfor(left++; cs[left]!='('&&cs[left]!=')'; left++){\n\t\t\t\t\top|=cs[left]=='+'||cs[left]=='-'||cs[left]=='*';\n\t\t\t\t}\n\t\t\t\tfor(right--; cs[right]!='('&&cs[right]!=')'; right--){\n\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t}\n\t\t\t\t// debug(\"op\", op);\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t\t// debug(r.bad);\n\t\t}\n\t\tif(r.good/*&&new String(cs).indexOf('(')>=0*/){\n//\t\t\tdebug(new String(cs), r.value);\n\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\t// 0~1023\n\n\tboolean debug=false;\n\n\tResult E(int p){\n\t\tif(debug)\n\t\t\tdebug(\"E\", p);\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tif(debug)\n\t\t\tdebug(\"F\", p);\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(debug)\n\t\t\tdebug(\"T\", p);\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[r.p]); r.p++){\n\t\t\t\tr.value=r.value*2+cs[r.p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tvoid update(){\n\t\t\tif(value<0||value>=1024){\n\t\t\t\tgood=false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Lost Number\nimport java.util.*;\n\npublic class Main {\n\tstatic String formula;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tformula = sc.next();\n\t\tint result = replaceAndSearch();\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tstatic int replaceAndSearch() {\n\t\tString[] replaces = { \"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\" };\n\t\tStringBuilder sb = new StringBuilder(formula);\n\t\tint result = -1;\n\t\tif (formula.contains(\".\")) {\n\t\t\tint p = formula.indexOf(\".\");\n\t\t\tfor (int i = 0; i < replaces.length; i++) {\n\t\t\t\tformula = sb.replace(p, p + 1, replaces[i]).toString();\n\t\t\t\tresult = Math.max(result, replaceAndSearch());\n\t\t\t\tformula = sb.replace(p, p + 1, \".\").toString();\n\t\t\t}\n\t\t} else {\n\t\t\tpos = 0;\n\t\t\tif (isExp())\n\t\t\t\tresult = exp();\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic boolean isExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length()) {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tpos = 0;\n\t\treturn true;\n\t}\n\n\tstatic boolean isTerm() {\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar c = formula.charAt(pos);\n\t\tif (c == '(') {\n\t\t\tpos++;\n\t\t\treturn isParExp();\n\t\t}\n\t\tif (Character.isDigit(c)) {\n\t\t\tif (number() >= 1 << 10)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isParExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar op = formula.charAt(pos++);\n\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\treturn false;\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\top = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tif (pos >= formula.length() || formula.charAt(pos++) != ')')\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tstatic int number() {\n\t\tint result = 0;\n\t\twhile (pos < formula.length() && Character.isDigit(formula.charAt(pos))) {\n\t\t\tresult *= 2;\n\t\t\tresult += formula.charAt(pos++) - '0';\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int exp() {\n\t\tint result = term();\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op == '+')\n\t\t\t\tresult += term();\n\t\t\telse\n\t\t\t\tresult -= term();\n\t\t}\n\t\tpos++;\n\t\treturn result;\n\t}\n\n\tstatic int term() {\n\t\tint result = mul();\n\t\twhile (pos < formula.length() && formula.charAt(pos) == '*') {\n\t\t\tpos++;\n\t\t\tresult *= mul();\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int mul() {\n\t\tif (formula.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\treturn exp();\n\t\t}\n\t\treturn number();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Lost Number\nimport java.util.*;\n\npublic class Main {\n\tstatic String formula;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tformula = sc.next();\n\t\tint result = replaceAndSearch();\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tstatic int replaceAndSearch() {\n\t\tString[] replaces = { \"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\" };\n\t\tStringBuilder sb = new StringBuilder(formula);\n\t\tint result = -1;\n\t\tif (formula.contains(\".\")) {\n\t\t\tint p = formula.indexOf(\".\");\n\t\t\tfor (int i = 0; i < replaces.length; i++) {\n\t\t\t\tformula = sb.replace(p, p + 1, replaces[i]).toString();\n\t\t\t\tresult = Math.max(result, replaceAndSearch());\n\t\t\t\tformula = sb.replace(p, p + 1, \".\").toString();\n\t\t\t}\n\t\t} else {\n\t\t\tpos = 0;\n\t\t\tif (isExp()) {\n\t\t\t\tpos = 0;\n\t\t\t\tresult = exp();\n\t\t\t} else\n\t\t\t\tpos = 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic boolean isExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length()) {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean isTerm() {\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar c = formula.charAt(pos);\n\t\tif (c == '(') {\n\t\t\tpos++;\n\t\t\treturn isParExp();\n\t\t}\n\t\tif (Character.isDigit(c)) {\n\t\t\tnumber();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isParExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar op = formula.charAt(pos++);\n\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\treturn false;\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\top = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tif (pos >= formula.length() || formula.charAt(pos++) != ')')\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tstatic int number() {\n\t\tint result = 0;\n\t\twhile (pos < formula.length() && Character.isDigit(formula.charAt(pos))) {\n\t\t\tresult *= 2;\n\t\t\tresult += formula.charAt(pos++) - '0';\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int exp() {\n\t\tint result = term();\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op == '+')\n\t\t\t\tresult += term();\n\t\t\telse\n\t\t\t\tresult -= term();\n\t\t}\n\t\tpos++;\n\t\treturn result;\n\t}\n\n\tstatic int term() {\n\t\tint result = mul();\n\t\twhile (pos < formula.length() && formula.charAt(pos) == '*') {\n\t\t\tpos++;\n\t\t\tresult *= mul();\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int mul() {\n\t\tif (formula.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\treturn exp();\n\t\t}\n\t\treturn number();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Lost Number\nimport java.util.*;\n\npublic class Main {\n\tstatic String formula;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tformula = sc.next();\n\t\tint result = replaceAndSearch();\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tstatic int replaceAndSearch() {\n\t\tString[] replaces = { \"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\" };\n\t\tStringBuilder sb = new StringBuilder(formula);\n\t\tint result = -1;\n\t\tif (formula.contains(\".\")) {\n\t\t\tint p = formula.indexOf(\".\");\n\t\t\tfor (int i = 0; i < replaces.length; i++) {\n\t\t\t\tformula = sb.replace(p, p + 1, replaces[i]).toString();\n\t\t\t\tresult = Math.max(result, replaceAndSearch());\n\t\t\t\tformula = sb.replace(p, p + 1, \".\").toString();\n\t\t\t}\n\t\t} else {\n\t\t\tpos = 0;\n\t\t\tif (isExp()) {\n\t\t\t\tresult = exp();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic boolean isExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length()) {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tpos = 0;\n\t\treturn true;\n\t}\n\n\tstatic boolean isTerm() {\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar c = formula.charAt(pos);\n\t\tif (c == '(') {\n\t\t\tpos++;\n\t\t\treturn isParExp();\n\t\t}\n\t\tif (Character.isDigit(c)) {\n\t\t\treturn isNumber();\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isParExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar op = formula.charAt(pos++);\n\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\treturn false;\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\top = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tif (pos >= formula.length() || formula.charAt(pos++) != ')')\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tstatic boolean isNumber() {\n\t\tint result = 0;\n\t\twhile (pos < formula.length() && Character.isDigit(formula.charAt(pos))) {\n\t\t\tresult *= 2;\n\t\t\tresult += formula.charAt(pos++) - '0';\n\t\t}\n\t\treturn result >= 0 && result < 1024;\n\t}\n\n\tstatic int exp() {\n\t\tint result = term();\n\t\tif (result < 0 || result >= 1024)\n\t\t\treturn -1;\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op == '+') {\n\t\t\t\tint t = term();\n\t\t\t\tif (t < 0 || t >= 1024)\n\t\t\t\t\treturn -1;\n\t\t\t\tresult += t;\n\t\t\t} else {\n\t\t\t\tint t = term();\n\t\t\t\tif (t < 0 || t >= 1024)\n\t\t\t\t\treturn -1;\n\t\t\t\tresult -= t;\n\t\t\t}\n\t\t\tif (result < 0 || result >= 1024)\n\t\t\t\treturn -1;\n\t\t}\n\t\tpos++;\n\t\treturn result;\n\t}\n\n\tstatic int term() {\n\t\tint result = mul();\n\t\tif (result < 0 || result >= 1024)\n\t\t\treturn -1;\n\t\twhile (pos < formula.length() && formula.charAt(pos) == '*') {\n\t\t\tpos++;\n\t\t\tint t = mul();\n\t\t\tif (t < 0 || t >= 1024)\n\t\t\t\treturn -1;\n\t\t\tresult *= t;\n\t\t\tif (result < 0 || result >= 1024)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int mul() {\n\t\tif (formula.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\treturn exp();\n\t\t}\n\t\tint n = number();\n\t\tif (n < 0 || n >= 1024)\n\t\t\treturn -1;\n\t\treturn n;\n\t}\n\n\tstatic int number() {\n\t\tint result = 0;\n\t\twhile (pos < formula.length() && Character.isDigit(formula.charAt(pos))) {\n\t\t\tresult *= 2;\n\t\t\tresult += formula.charAt(pos++) - '0';\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tif(id==s.length){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(num<=-1024 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tsum += q.pollLast();\n\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\tchar c = s[id];\n\t\t\tid++;\n\t\t\tif(c=='('){\n\t\t\t\tint num = calc();\n\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\tif(num<=-1024 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\tif(mns) num *= -1;\n\t\t\t\tq.push(num);\n\t\t\t\tmns = false;\n\t\t\t\tmul = false;\n\t\t\t}else if(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else if(c=='*'){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(num<=-1024 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tmns = false;\n\t\t\t\t\tmul = false;\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tmul = true;\n\t\t\t}else{\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(num<0 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(num<=-1024 || num>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tmns = false;\n\t\t\t\t\tmul = false;\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tif(c=='-') mns = true;\n\t\t\t\telse mns = false;\n\t\t\t\tmul = false;\n\t\t\t\tif(c==')'){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tsum += q.pollLast();\n\t\t\t\t\t\tif(sum<0 || sum>=1024) return Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tint num = calc();\n\t\t\tif(num>=0 && num<=1023)\tmax = Math.max(max, num);\n\t\t\t//for(int i=0;i<s.length;i++) System.out.print(s[i]);\n\t\t\t//System.out.println(\" \" + max);\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tif(id==s.length){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tsum += q.pop();\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\tchar c = s[id];\n\t\t\tid++;\n\t\t\tif(c=='('){\n\t\t\t\tint num = calc();\n\t\t\t\tq.push(num);\n\t\t\t}else if(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else if(c=='*'){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tmul = true;\n\t\t\t}else{\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tif(c=='-') mns = true;\n\t\t\t\telse mns = false;\n\t\t\t\tmul = false;\n\t\t\t\tif(c==')'){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tsum += q.pop();\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tmax = Math.max(max, calc());\n\t\t\t//for(int i=0;i<s.length;i++) System.out.print(s[i]);\n\t\t\t//System.out.println();\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tfinal char[] op={'0', '1', '+', '-', '*', '(', ')'};\n\tString s;\n\tchar[] cs;\n\tint max;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tif(i==cs.length){\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n\t\tr.good&=r.p==cs.length-1;\n\t\tif(r.good){\n\t\t\tfor(int i=0; i<cs.length; i++){\n\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint stack=0;\n\t\t\t\tboolean op=false;\n\t\t\t\tfor(int j=i+1; cs[j]!=')'||stack!=0; j++){\n\t\t\t\t\tif(cs[j]=='('){\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t}else if(cs[j]==')'){\n\t\t\t\t\t\tstack--;\n\t\t\t\t\t}\n\t\t\t\t\tif(stack==0){\n\t\t\t\t\t\top|=cs[j]=='+'||cs[j]=='-'||cs[j]=='*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr.good&=op;\n\t\t\t}\n\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\tResult E(int p){\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tif(!r.update()){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tif(!r.update()){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tResult r=new Result(p, 0);\n\t\t\tfor(; Character.isDigit(cs[r.p]); r.p++){\n\t\t\t\tr.value=r.value*2+cs[r.p]-'0';\n\t\t\t\tr.update();\n\t\t\t}\n\t\t\treturn r;\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tboolean update(){\n\t\t\treturn good&=0<=value&&value<1024;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString s;\n\n\tvoid run(){\n\t\ts=sc.nextLine();\n\t\tsolve();\n\t}\n\n\tchar[] cs;\n\tint max;\n\n\tvoid solve(){\n\t\ts+=\"$\";\n\t\tcs=s.toCharArray();\n\t\tmax=-1;\n\t\tdfs(0);\n\t\tprintln(max+\"\");\n\t}\n\n\tvoid dfs(int i){\n\t\tchar[] op={'0', '1', '+', '-', '*', '(', ')'};\n\t\tif(i==cs.length){\n\t\t\t// 発動\n\t\t\tmax=max(max, calc());\n\t\t\treturn;\n\t\t}\n\t\tif(cs[i]=='.'){\n\t\t\tfor(char c : op){\n\t\t\t\tcs[i]=c;\n\t\t\t\tdfs(i+1);\n\t\t\t\tcs[i]='.';\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(i+1);\n\t\t}\n\t}\n\n\tint calc(){\n\t\tResult r=E(0);\n//\t\tdebug(cs);\n\t\tr.good&=r.p==cs.length-1;\n//\t\tdebug(r.good, r.p, r.value);\n\t\t// ()の間には記号がいる\n//\t\tif(false)\n\t\t\tif(r.good){\n\t\t\t\t// ((1*1)) X\n\t\t\t\tint n=cs.length;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(cs[i]!='('){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint left=i, right=left+1;\n\t\t\t\t\tint stack=0;\n\t\t\t\t\tfor(; cs[right]!=')'||stack!=0; right++){\n\t\t\t\t\t\tif(cs[right]=='('){\n\t\t\t\t\t\t\tstack++;\n\t\t\t\t\t\t}else if(cs[right]==')'){\n\t\t\t\t\t\t\tstack--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tboolean op=false;\n//\t\t\t\t\t debug(left, right);\n\t\t\t\t\tfor(left++; cs[left]!='('&&cs[left]!=')'; left++){\n\t\t\t\t\t\top|=cs[left]=='+'||cs[left]=='-'||cs[left]=='*';\n\t\t\t\t\t}\n\t\t\t\t\tfor(right--; cs[right]!='('&&cs[right]!=')'; right--){\n\t\t\t\t\t\top|=cs[right]=='+'||cs[right]=='-'||cs[right]=='*';\n\t\t\t\t\t}\n\t\t\t\t\t// debug(\"op\", op);\n\t\t\t\t\tr.good&=op;\n\t\t\t\t}\n\t\t\t\t// debug(r.bad);\n\t\t\t}\n\t\t\tif(r.good){\n//\t\t\t\tdebug(new String(cs),r.value);\n\t\t\t}\n\t\treturn r.good?r.value:-1;\n\t}\n\n\t// 0~1023\n\n\tboolean debug=false;\n\n\tResult E(int p){\n\t\tif(debug)\n\t\t\tdebug(\"E\", p);\n\t\tResult r=F(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='+'||cs[r.p]=='-';){\n\t\t\tResult r2=F(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tif(cs[r.p]=='+'){\n\t\t\t\tr.value+=r2.value;\n\t\t\t}else{\n\t\t\t\tr.value-=r2.value;\n\t\t\t}\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult F(int p){\n\t\tif(debug)\n\t\t\tdebug(\"F\", p);\n\t\tResult r=T(p);\n\t\tif(!r.good){\n\t\t\treturn r;\n\t\t}\n\t\tfor(; cs[r.p]=='*';){\n\t\t\tResult r2=T(r.p+1);\n\t\t\tif(!r2.good){\n\t\t\t\treturn r2;\n\t\t\t}\n\t\t\tr.value*=r2.value;\n\t\t\tr.update();\n\t\t\tif(!r.good){\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p=r2.p;\n\t\t}\n\t\treturn r;\n\t}\n\n\tResult T(int p){\n\t\tif(debug)\n\t\t\tdebug(\"T\", p);\n\t\tif(cs[p]=='('){\n\t\t\tResult r=E(p+1);\n\t\t\tif(!r.good||cs[r.p]!=')'){\n\t\t\t\tr.good=false;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tr.p++;\n\t\t\treturn r;\n\t\t}else if(cs[p]=='0'||cs[p]=='1'){\n\t\t\tint value=0;\n\t\t\tfor(; Character.isDigit(cs[p]); p++){\n\t\t\t\tvalue=value*2+cs[p]-'0';\n\t\t\t}\n\t\t\treturn new Result(p, value);\n\t\t}else{\n\t\t\treturn new Result(0, -1);\n\t\t}\n\t}\n\n\tclass Result{\n\t\tint p, value;\n\t\tboolean good;\n\n\t\tResult(int p, int value){\n\t\t\tthis.p=p;\n\t\t\tthis.value=value;\n\t\t\tgood=true;\n\t\t\tupdate();\n\t\t}\n\n\t\tvoid update(){\n\t\t\tif(value<0||value>=1024){\n\t\t\t\tgood=false;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static String[] symbol = {\"0\",\"1\",\"+\",\"-\",\"*\",\"(\",\")\"};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\tint dots = 0;\n\t\tArrayList<Integer> doti = new ArrayList<Integer>();\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i) == '.') {\n\t\t\t\tdots ++;\n\t\t\t\tdoti.add(i);\n\t\t\t}\n\t\t}\n\t\tint[] p = new int[dots];\n\t\t\n\t\tint ans = -1;\n\t\twhile(true) {\n\t\t\tString exp = new String(s);\n\t\t\tfor(int i=0;i<dots;i++) {\n\t\t\t\tString a = exp.substring(0,doti.get(i));\n\t\t\t\tString b = exp.substring(doti.get(i)+1,exp.length());\n\t\t\t\texp = a + symbol[p[i]] + b;\n\t\t\t}\n\t\t\t\n\t\t\tindex = 0;\n\t\t\tint n = expression(exp);\n\t\t\t\n\t\t\tboolean next = true;\n\t\t\tif (dots == 0) {\n\t\t\t\tnext = false;\n\t\t\t}\n\t\t\tfor(int i=0;i<p.length;i++) {\n\t\t\t\tif (p[i]<6) {\n\t\t\t\t\tp[i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tif(i<p.length-1) {\n\t\t\t\t\t\tp[i] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = Math.max(ans,n);\n\t\t\t\n\t\t\tif (!next) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tpublic static int index = 0;\n\tpublic static int expression(String s) {\n\t\treturn expression(s, false);\n\t}\n\tpublic static int expression(String s,boolean needconnective) {\n\t\tint n = term(s);\n\t\tif (n < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tboolean connective = false;\n\t\twhile(index < s.length()) {\n\t\t\tif (s.charAt(index) == '+') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn += term(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t\tconnective = true;\n\t\t\t}else if(s.charAt(index) == '-') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn -= term(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t\tconnective = true;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(0 <= n && n < 2<<10)) {\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t}\n\t\tif (needconnective && !connective) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn n;\n\t}\n\tpublic static int term(String s) {\n\t\tint n = number(s);\n\t\tif (n < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\twhile(index < s.length()) {\n\t\t\tif (s.charAt(index) == '*') {\n\t\t\t\tindex++;\n\t\t\t\tif (index < s.length()) {\n\t\t\t\t\tn *= number(s);\n\t\t\t\t}else{\n\t\t\t\t\tn = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(0 <= n && n < 2<<10)) {\n\t\t\t\tn = -1;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\tpublic static int number(String s) {\n\t\tif (index >= s.length()) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (s.charAt(index) == '(') {\n\t\t\tindex++;\n\t\t\tint n = expression(s,true);\n\t\t\tif (index >= s.length() || s.charAt(index) != ')') {\n\t\t\t\treturn -1;\n\t\t\t}else{\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\t\tchar c0 = s.charAt(index);\n\t\tif (c0 != '0' && c0 != '1') {\n\t\t\treturn -1;\n\t\t}\n\t\tint n = 0;\n\t\twhile(index < s.length()) {\n\t\t\tchar c = s.charAt(index);\n\t\t\tif (c == '0' || c == '1') {\n\t\t\t\tn*=2;\n\t\t\t\tn += c - '0';\n\t\t\t\tindex++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[] s;\n\tint max, dotCnt, id;\n\t\n\tchar[] cArr = new char[]{'0', '1', '+', '-', '*', '(', ')'};\n\t\n\tint calc(){\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean mul = false;\n\t\tboolean mns = false;\n\t\twhile(true){\n\t\t\tif(id==s.length){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint sum = 0;\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tsum += q.pop();\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\tchar c = s[id];\n\t\t\tid++;\n\t\t\tif(c=='('){\n\t\t\t\tint num = calc();\n\t\t\t\tq.push(num);\n\t\t\t}else if(c=='0' || c=='1'){\n\t\t\t\tsb.append(c);\n\t\t\t}else if(c=='*'){\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tmul = true;\n\t\t\t}else{\n\t\t\t\tif(sb.length()>0){\n\t\t\t\t\tint num = Integer.parseInt(sb.toString(), 2);\n\t\t\t\t\tif(mul) num *= q.pop();\n\t\t\t\t\tif(mns) num *= -1;\n\t\t\t\t\tq.push(num);\n\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t}\n\t\t\t\tif(c=='-') mns = true;\n\t\t\t\telse mns = false;\n\t\t\t\tmul = false;\n\t\t\t\tif(c==')'){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tsum += q.pop();\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isOpe(int id){\n\t\tif(s[id]=='+' || s[id]=='-' || s[id]=='*') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean isNum(int id){\n\t\tif(s[id]=='0' || s[id]=='1') return true;\n\t\treturn false;\n\t}\n\t\n\tboolean checker(){\n\t\tif(isOpe(0) || isOpe(s.length-1)) return false;\n\t\t\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tcnt1++;\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t\telse if(s[i]==')') cnt1--;\n\t\t\tif(cnt1<0) return false;\n\t\t}\n\t\tif(cnt1!=0) return false;\n\t\t\n\t\tboolean[] f = new boolean[cnt2];\n\t\tint id = -1;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='(') id++;\n\t\t\telse if(s[i]==')'){\n\t\t\t\tif(!f[id]) return false;\n\t\t\t\tf[id] = false;\n\t\t\t\tid--;\n\t\t\t}\n\t\t\telse if(id>=0 && isOpe(i)){\n\t\t\t\tf[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<s.length-1;i++){\n\t\t\tif(s[i]=='(' && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]==')' && isOpe(i)) return false;\n\t\t\telse if(isOpe(i) && isOpe(i+1)) return false;\n\t\t\telse if(s[i+1]=='(' && (isNum(i) || s[i]==')')) return false;\n\t\t\telse if(s[i]==')' && (isNum(i+1) || s[i+1]=='(')) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tvoid fnc(){\n\t\tboolean f = false;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.'){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ts[i] = cArr[j];\n\t\t\t\t\tf = true;\n\t\t\t\t\tfnc();\n\t\t\t\t\ts[i] = '.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f && checker()){\n\t\t\tid = 0;\n\t\t\tint num = calc();\n\t\t\tif(num>=0 && num<=1023)\tmax = Math.max(max, num);\n\t\t\t//for(int i=0;i<s.length;i++) System.out.print(s[i]);\n\t\t\t//System.out.println();\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\ts = sc.next().toCharArray();\n\t\tdotCnt = 0;\n\t\tfor(int i=0;i<s.length;i++){\n\t\t\tif(s[i]=='.') dotCnt++;\n\t\t}\n\t\t\n\t\tmax = -1;\n\t\tfnc();\n\t\tSystem.out.println(max);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "// Lost Number\nimport java.util.*;\n\npublic class Main {\n\tstatic String formula;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tformula = sc.next();\n\t\tint result = replaceAndSearch();\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tstatic int replaceAndSearch() {\n\t\tString[] replaces = { \"0\", \"1\", \"+\", \"-\", \"*\", \"(\", \")\" };\n\t\tStringBuilder sb = new StringBuilder(formula);\n\t\tint result = -1;\n\t\tif (formula.contains(\".\")) {\n\t\t\tint p = formula.indexOf(\".\");\n\t\t\tfor (int i = 0; i < replaces.length; i++) {\n\t\t\t\tformula = sb.replace(p, p + 1, replaces[i]).toString();\n\t\t\t\tresult = Math.max(result, replaceAndSearch());\n\t\t\t\tformula = sb.replace(p, p + 1, \".\").toString();\n\t\t\t}\n\t\t} else {\n\t\t\tpos = 0;\n//\t\t\tSystem.out.println(formula);\n\t\t\tif (isExp())\n\t\t\t\tresult = exp();\n//\t\t\tSystem.out.println(result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic boolean isExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length()) {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tpos = 0;\n\t\treturn true;\n\t}\n\n\tstatic boolean isTerm() {\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar c = formula.charAt(pos);\n\t\tif (c == '(') {\n\t\t\tpos++;\n\t\t\treturn isParExp();\n\t\t}\n\t\tif (Character.isDigit(c)) {\n\t\t\tint n = number();\n\t\t\tif (n >= 0 && n < 1024)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isParExp() {\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\tif (pos >= formula.length())\n\t\t\treturn false;\n\t\tchar op = formula.charAt(pos++);\n\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\treturn false;\n\t\tif (!isTerm())\n\t\t\treturn false;\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\top = formula.charAt(pos++);\n\t\t\tif (op != '+' && op != '-' && op != '*')\n\t\t\t\treturn false;\n\t\t\tif (!isTerm())\n\t\t\t\treturn false;\n\t\t}\n\t\tif (pos >= formula.length() || formula.charAt(pos++) != ')')\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tstatic int number() {\n\t\tint result = 0;\n\t\twhile (pos < formula.length() && Character.isDigit(formula.charAt(pos))) {\n\t\t\tresult *= 2;\n\t\t\tresult += formula.charAt(pos++) - '0';\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int exp() {\n\t\tint result = term();\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')') {\n\t\t\tchar op = formula.charAt(pos++);\n\t\t\tif (op == '+')\n\t\t\t\tresult += term();\n\t\t\telse\n\t\t\t\tresult -= term();\n\t\t\tif (result < 0 || result >= 1024)\n\t\t\t\treturn -1;\n\t\t}\n\t\tpos++;\n\t\treturn result;\n\t}\n\n\tstatic int term() {\n\t\tint result = mul();\n\t\twhile (pos < formula.length() && formula.charAt(pos) == '*') {\n\t\t\tpos++;\n\t\t\tresult *= mul();\n\t\t}\n\t\tif (result < 0 || result >= 1024)\n\t\t\treturn -1;\n\t\treturn result;\n\t}\n\n\tstatic int mul() {\n\t\tif (formula.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\treturn exp();\n\t\t}\n\t\tint n = number();\n\t\tif (n < 0 || n >= 1024)\n\t\t\treturn -1;\n\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tchar [] work;\n\tArrayList<ArrayList<Character>> list;\n\tchar [] op = {'+', '-','*', '(', ')', '0', '1'};\n\tboolean isvalid;\n\tStringBuilder s;\n\tint pos;\n\tchar end = '#';\n\t//2040 start\n\t//2215 WA\n\t//2220 modi single operation\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\ts = new StringBuilder(sc.next() + \"#\");\n\t\t\tn = 0;\n\t\t\tisvalid = true;\n\t\t\tArrayList<Integer> indl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < s.length(); i++){\n\t\t\t\tif(s.charAt(i) == '.'){\n\t\t\t\t\tn++;\n\t\t\t\t\tindl.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\t//評価する\n\t\t\t\tpos = 0;\n\t\t\t\tisvalid = true;\n\t\t\t\tint ans = eval();\n\t\t\t\t\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tans = -1;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = new char[n];\n\t\t\tlist = new ArrayList<ArrayList<Character>>();\n\t\t\tdfs(0);\n\t\t\tint len = list.size();\n\t\t\tint ans = -1;\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tisvalid = true;\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0 ; j < n;j++){\n\t\t\t\t\ts.setCharAt(indl.get(j), list.get(i).get(j));\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"i = \" + i + \" \" + s.toString());\n\t\t\t\t\n\t\t\t\t//評価する\n\t\t\t\tint now = eval();\n\t\t\t\t\n\t\t\t\tif(! isvalid){\n\t\t\t\t\tnow = -1;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, now);\n\t\t\t\t//debug\n//\t\t\t\tif(now == 2){\n//\t\t\t\t\tSystem.out.println(s.toString());\n//\t\t\t\t}\n\t\t\t\t//System.out.println(\"no =            \" + now);\n\t\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\n\tprivate int eval() {\n\t\tint res = exp();\n\t\tif(pos != s.length() - 1){\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int term() {\n\t\tif(! isvalid) return -1;\n\t\tint res = fact();\n\t\tif(! isvalid) return -1;\n\t\twhile(true){\n\t\t\tchar op = s.charAt(pos);\n\t\t\tif((op == '*')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(! isvalid) return -1;\n\t\t\t\tres = old * res;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\n\tprivate int fact() {\n\t\tif(! isvalid) return -1;\n\t\tif(Character.isDigit(s.charAt(pos))){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(s.charAt(pos++));\n\t\t\twhile(Character.isDigit(s.charAt(pos))){\n\t\t\t\tsb.append(s.charAt(pos++));\n\t\t\t}\n\t\t\tint res = Integer.parseInt(sb.toString(), 2);\n\t\t\treturn res;\n\t\t}\n\t\telse if(s.charAt(pos) == '-'){\n\t\t\tpos++;\n\t\t\treturn -1 * fact();\n\t\t}\n\t\telse if(s.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint ind = pos;\n\t\t\tboolean f = false;\n\t\t\twhile(s.charAt(ind) != ')' && s.charAt(ind) !=  end){\n\t\t\t\t\n\t\t\t\tif(s.charAt(ind) == '+' || s.charAt(ind) == '-' || s.charAt(ind) == '*'){\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tif(! f){\n\t\t\t\tisvalid = false; return -1;\n\t\t\t}\n\t\t\tint res = exp();\n\t\t\tif(! isvalid) return -1;\n\t\t\tif(s.charAt(pos) != ')'){\n\t\t\t\tisvalid = false;\n\t\t\t}\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tisvalid = false;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\tArrayList<Character> a = new ArrayList<Character>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\ta.add(work[i]);\n\t\t\t}\n\t\t\tlist.add(a);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < op.length;i++){\n\t\t\twork[deep] = op[i];\n\t\t\tdfs(deep + 1);\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef calc(se)\n\t#p se\n\tcase se[0]\n\twhen :paren\n\t\treturn nil if se[1][0][0] == :paren\n\t\treturn nil if !se[1][0].flatten.include?(:binary)\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn nil unless x = calc(l)\n\t\treturn nil unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn nil unless (0..1023) === result\n\t\tresult\n\twhen :@int\n\t\tr = se[1].to_i(2)\n\t\treturn nil if !r\n\t\treturn (0..1023) === r ? r : nil\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = calc(se[2])\n\t\t\treturn nil if !r\n\t\t\treturn r == 0 ? 0 : nil\n\t\telsif se[1] == :+@\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\tr = calc(Ripper.sexp(s)[1][0])\n\tp (0..1023) === r ? r : -1\nelse\n\tp %w[ ( ) 0 1 + - * ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\tnext -1 if e =~ /\\*\\*/\n\t\t#p e\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tcalc(Ripper.sexp(e)[1][0]) || -1\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef calc(se)\n\t#p se\n\tcase se[0]\n\twhen :paren\n\t\treturn nil if se[1][0][0] == :paren\n\t\treturn nil if !se[1][0].flatten.include?(:binary)\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn nil unless x = calc(l)\n\t\treturn nil unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn nil unless (0..1023) === result\n\t\tresult\n\twhen :@int\n\t\tr = se[1].to_i\n\t\treturn (0..1023) === r ? r : nil\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = calc(se[2])\n\t\t\treturn nil if !r\n\t\t\treturn r == 0 ? 0 : nil\n\t\telsif se[1] == :+@\n\t\t\tr = calc(se[2])\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\ts.gsub!(/\\d+/){|b| b.to_i(2)}\n\tbegin\n\t\teval s\n\t\tr = calc(Ripper.sexp(s)[1][0])\n\t\tp (0..1023) === r ? r : -1\n\trescue Exception\n\t\tp -1\n\tend\nelse\n\tp %w[ ( ) 0 1 + - * ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\te.gsub!(/\\d+/){|b| b.to_i(2)}\n\t\tnext -1 if e =~ /\\*\\*/\n\t\t#p e\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tcalc(Ripper.sexp(e)[1][0]) || -1\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef calc(se)\n\t#p se\n\tcase se[0]\n\twhen :paren\n\t\treturn -1 if se[1][0][0] == :paren\n\t\treturn -1 if !se[1][0].flatten.include?(:binary)\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn -1 unless x = calc(l)\n\t\treturn -1 unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn -1 unless (0..1023) === result\n\t\tresult\n\twhen :@int\n\t\tr = se[1].to_i(2)\n\t\treturn (0..1023) === r ? r : -1\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = -calc(se[2])\n\t\t\treturn r < 0 ? -1 : r\n\t\telsif se[1] == :+@\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\tr = calc(Ripper.sexp(s)[1][0])\n\tp (0..1023) === r ? r : 1\nelse\n\tp %w[ ( ) 0 1 + - * ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\tnext -1 if e =~ /\\*\\*/\n\t\t#p e\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tcalc(Ripper.sexp(e)[1][0])\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\n\ndef calc(se)\n\tcase se[0]\n\twhen :paren\n\t\treturn -1 if se[1][0][0] == :paren\n\t\treturn -1 if !se[1][0].flatten.include?(:binary)\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn -1 unless x = calc(l)\n\t\treturn -1 unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn -1 if result < 0 || 1024 <= result\n\t\tresult\n\twhen :@int\n\t\treturn se[1].to_i(2)\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = -calc(se[2])\n\t\t\treturn r < 0 ? -1 : r\n\t\telsif se[1] == :+@\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\tp calc(Ripper.sexp(s)[1][0])\nelse\n\tp %w[ ( ) 0 1 + * - ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tcalc(Ripper.sexp(e)[1][0])\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef calc(se)\n\tcase se[0]\n\twhen :paren\n\t\treturn -1 if se[1][0][0] == :paren\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn -1 unless x = calc(l)\n\t\treturn -1 unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn -1 if result < 0 || 1024 <= result\n\t\tresult\n\twhen :@int\n\t\treturn se[1].to_i(2)\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = -calc(se[2])\n\t\t\treturn r < 0 ? -1 : r\n\t\telsif se[1] == :+@\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\tp calc(Ripper.sexp(s)[1][0])\nelse\n\tp %w[ ( ) 0 1 + * - ].repeated_combination(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tcalc(Ripper.sexp(e)[1][0])\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef calc(se)\n\t#p se\n\tcase se[0]\n\twhen :paren\n\t\treturn nil if se[1][0][0] == :paren\n\t\treturn nil if !se[1][0].flatten.include?(:binary)\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn nil unless x = calc(l)\n\t\treturn nil unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn nil unless (0..1023) === result\n\t\tresult\n\twhen :@int\n\t\tr = se[1].to_i\n\t\treturn (0..1023) === r ? r : nil\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = calc(se[2])\n\t\t\treturn nil if !r\n\t\t\treturn r == 0 ? 0 : nil\n\t\telsif se[1] == :+@\n\t\t\tr = calc(se[2])\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\ns.gsub!(/\\d+/){|b| b.to_i(2)}\nk = s.count(?.)\n\nif k == 0\n\tbegin\n\t\teval s\n\t\tr = calc(Ripper.sexp(s)[1][0])\n\t\tp (0..1023) === r ? r : -1\n\trescue Exception\n\t\tp -1\n\tend\nelse\n\tp %w[ ( ) 0 1 + - * ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\tnext -1 if e =~ /\\*\\*/\n\t\t#p e\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tcalc(Ripper.sexp(e)[1][0]) || -1\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef calc(se)\n\t#p se\n\tcase se[0]\n\twhen :paren\n\t\treturn nil if se[1][0][0] == :paren\n\t\treturn nil if !se[1][0].flatten.include?(:binary)\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn nil unless x = calc(l)\n\t\treturn nil unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn nil unless (0..1023) === result\n\t\tresult\n\twhen :@int\n\t\tr = se[1].to_i(2)\n\t\treturn (0..1023) === r ? r : nil\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = calc(se[2])\n\t\t\treturn nil if !r\n\t\t\treturn r == 0 ? 0 : nil\n\t\telsif se[1] == :+@\n\t\t\tr = calc(se[2])\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\tbegin\n\t\teval e\n\t\tr = calc(Ripper.sexp(s)[1][0])\n\t\tp (0..1023) === r ? r : -1\n\trescue Exception\n\t\tp -1\n\tend\nelse\n\tp %w[ ( ) 0 1 + - * ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\tnext -1 if e =~ /\\*\\*/\n\t\t#p e\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tcalc(Ripper.sexp(e)[1][0]) || -1\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "def b_eval(s)\n    begin\n        raise if s =~ /\\(\\d*\\)/\n        e = s.gsub(/\\d+/){|x| \"0b\" + x}\n        eval e\n    rescue Exception\n        -Float::INFINITY\n    end\nend\n\ns = gets.chomp\nk = s.count ?.\n\nx = nil\nif k == 0\n    x = b_eval(s)\nelse\n    x = %w|0 1 + - * ( )|.repeated_permutation(k).map {|perm|\n        d = s.dup\n        perm.each {|c| d.sub!(?., c)}\n        b_eval(d)\n    }.max\nend\np x == -Float::INFINITY ? -1 : x"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef calc(se)\n\t#p se\n\tcase se[0]\n\twhen :paren\n\t\treturn nil if se[1][0][0] == :paren\n\t\treturn nil if !se[1][0].flatten.include?(:binary)\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn nil unless x = calc(l)\n\t\treturn nil unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn nil unless (0..1023) === result\n\t\tresult\n\twhen :@int\n\t\tr = se[1].to_i\n\t\treturn (0..1023) === r ? r : nil\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = calc(se[2])\n\t\t\treturn nil if !r\n\t\t\treturn r == 0 ? 0 : nil\n\t\telsif se[1] == :+@\n\t\t\tr = calc(se[2])\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\ts.gsub!(/\\d+/){|b| b.to_i(2)}\n\tif s =~ /[-+*]{2,}/\n\t\tp -1\n\telse\n\t\tbegin\n\t\t\teval s\n\t\t\tr = calc(Ripper.sexp(s)[1][0])\n\t\t\tp (0..1023) === r ? r : -1\n\t\trescue Exception\n\t\t\tp -1\n\t\tend\n\tend\nelse\n\tp %w[ ( ) 0 1 + - * ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\te.gsub!(/\\d+/){|b| b.to_i(2)}\n\t\tnext -1 if e =~ /[-+*]{2,}/\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tr = calc(Ripper.sexp(e)[1][0]) || -1\n\t\t#p [e, r] if r >= 0\n\t\tr\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef calc(se)\n\t#p se\n\tcase se[0]\n\twhen :paren\n\t\treturn nil if se[1][0][0] == :paren\n\t\treturn nil if !se[1][0].flatten.include?(:binary)\n\t\treturn calc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\treturn nil unless x = calc(l)\n\t\treturn nil unless y = calc(r)\n\t\tresult = x.send(op, y)\n\t\treturn nil unless (0..1023) === result\n\t\tresult\n\twhen :@int\n\t\tr = se[1].to_i(2)\n\t\treturn nil if !r\n\t\treturn (0..1023) === r ? r : nil\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\tr = calc(se[2])\n\t\t\treturn nil if !r\n\t\t\treturn r == 0 ? 0 : nil\n\t\telsif se[1] == :+@\n\t\t\treturn calc(se[2])\n\t\telse\n\t\t\tputs \"unimplemented\"\n\t\t\treturn -1\n\t\tend\n\telse\n\t\tputs \"unimplemented\"\n\t\treturn -1\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\tr = calc(Ripper.sexp(s)[1][0])\n\tp (0..1023) === r ? r : 1\nelse\n\tp %w[ ( ) 0 1 + - * ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\tnext -1 if e =~ /\\*\\*/\n\t\t#p e\n\t\tbegin\n\t\t\teval e\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t\tcalc(Ripper.sexp(e)[1][0]) || -1\n\t}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\nrequire 'pp'\n\n\ndef check_par(tree)\n\t#pp tree\n\tnode, children = tree\t\n\tif node == :paren\n\t\tif children.is_a?(Array)\n\t\t\treturn true if children.size == 1 && children[0].is_a?(Array) && children[0][0] == :paren\n\t\tend\n\tend\n\n\tif children.is_a?(Array)\n\t\treturn children.any?{|x| check_par(x)}\n\tend\nend\n\n\ndef b_eval(s)\n\tbegin\n\t\traise if s =~ /\\(\\d*\\)/\n\t\te = s.gsub(/\\d+/){|x| \"0b\" + x}\n\t\traise if check_par(Ripper.sexp(e))\n\t\teval e\n\trescue Exception\n\t\t-Float::INFINITY\n\tend\nend\n\ns = gets.chomp\nk = s.count ?.\n\nx = nil\nif k == 0\n\tx = b_eval(s)\nelse\n\tx = %w|0 1 + - * ( )|.repeated_permutation(k).map {|perm|\n\t\td = s.dup\n\t\tperm.each {|c| d.sub!(?., c)}\n\t\tx = b_eval(d)\n\t\tx\n\t}.max\nend\np x == -Float::INFINITY ? -1 : x"
  },
  {
    "language": "Ruby",
    "code": "require 'ripper'\n\ndef parse(s)\n\traise if s =~ /[-+*]{2,}/\n\teval s\n\tRipper.sexp(s)[1][0]\nend\n\ndef calc(se)\n\tcase se[0]\n\twhen :paren\n\t\traise if se[1][0][0] == :paren\n\t\traise if !se[1][0].flatten.include?(:binary)\n\t\tcalc(se[1][0])\n\twhen :binary\n\t\tl, op, r = se[1..-1]\n\t\tresult = calc(l).send(op, calc(r))\n\t\traise unless (0..1023) === result\n\t\tresult\n\twhen :@int\n\t\ti = se[1].to_i(2)\n\t\traise unless (0..1023) === i\n\t\ti\n\twhen :unary\n\t\tif se[1] == :-@\n\t\t\traise if calc(se[2]) == 0\n\t\t\t0\n\t\telsif se[1] == :+@\n\t\t\tcalc(se[2])\n\t\tend\n\tend\nend\n\ns = gets.chomp\nk = s.count(?.)\n\nif k == 0\n\tbegin\n\t\tp calc(parse(s))\n\trescue Exception\n\t\tp -1\n\tend\nelse\n\t p %w[ ( ) 0 1 + - * ].repeated_permutation(k).map {|perm|\n\t\te = s.gsub(?.){ perm.pop }\n\t\tbegin\n\t\t\tcalc(parse(e))\n\t\trescue Exception\n\t\t\tnext -1\n\t\tend\n\t}.max\nend"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nimport time\ndef ok(s):\n    if '(+' in s or '(-' in s or '(*' in s or '++' in s or '+-' in s or '-+' in s \\\n    or '--' in s or '**' in s or '*+' in s or '*-' in s:\n        return False\n    if '(' in s or ')' in s:\n        dic={}\n        count=-1\n        for c in s:\n            if c=='(':\n                count+=1\n                dic[count]=0\n            elif c==')':\n                if dic[count]==0:\n                    return False\n                count-=1\n            elif c in '+-*' and count in dic:\n                dic[count]+=1\n        return True\n    else:\n        return True\n\ndef check(s):\n    i=0\n    ans=''\n    tmp=[]\n    try:\n        while i<len(s):\n            if s[i] in '01':\n                tmp.append(s[i])\n            else:\n                if len(tmp):\n                    t=''.join(tmp)\n                    t=str(int(t,2))\n                    if int(t)>=1024:\n                        return -99999999\n                    ans+=t\n                ans+=s[i]\n                tmp=[]\n            i+=1\n        if len(tmp):\n            t=''.join(tmp)\n            t=str(int(t,2))\n            ans+=t\n    except:\n        return -99999999\n    try:\n        if ok(ans):\n            xxx=eval(ans)\n            if '-' not in ans and xxx<1024:\n                return xxx\n            elif '-' in ans and xxx<1024:\n                for i in range(len(ans)):\n                    if ans[i]=='-':\n                        mid=i\n                        r,l=mid-1,mid+1\n                        count=0\n                        while r>=0:\n                            if ans[r]==')':\n                                count+=1\n                            elif ans[r]=='(':\n                                count-=1\n                                if count<0:\n                                    r+=1\n                                    break\n                            if count==0 and ans[r] in '+-':\n                                r+=1\n                                break\n                            r-=1\n                        r=max(r,0)\n                        count=0\n                        while l<len(ans):\n                            if ans[l]=='(':\n                                count+=1\n                            elif ans[l]==')':\n                                count-=1\n                                if count<0:\n                                    break\n                            if count==0 and ans[l] in '+-':\n                                break\n                            l+=1\n                        a,b=eval(ans[r:mid]),eval(ans[mid+1:l])\n                        if a>=1024 or b>=1024 or \\\n                        a - b <0:\n                            return -99999999\n                return xxx\n            else:\n                return -99999999\n        else:\n            return -99999999\n    except:\n        return -99999999\n\ns=input().split('.')\nmx=-1\nhoge = product('01+-*()', repeat=len(s)-1)\nfor table in hoge:\n    tmp=s[0]\n    i=1\n    for c in table:\n        tmp+=c+s[i]\n        i+=1\n    mx=max(mx,check(tmp))\nprint(mx)\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(s):\n        ca = '01+-*()'\n        sa = s.split('.')\n        r = -1\n        sl = len(sa)\n\n        fm = {}\n        def _f(s):\n            if s in fm:\n                return fm[s]\n            if ')' in s:\n                ri = s.index(')')\n                if len(s) > ri+1 and s[ri+1] in '01':\n                    fm[s] = -1\n                    return -1\n                li = -1\n                for i in range(ri-1,-1,-1):\n                    if s[i] == '(':\n                        li = i\n                        break\n                if li < 0 or li > 0 and s[li-1] in '01':\n                    fm[s] = -1\n                    return -1\n                ts = s[li+1:ri]\n                if '+' not in ts and '-' not in ts and '*' not in ts:\n                    fm[s] = -1\n                    return -1\n                tr = _f(ts)\n                if tr == -1:\n                    fm[s] = -1\n                    return -1\n                fm[s] = _f(s[:li] + tr + s[ri+1:])\n                return fm[s]\n            if '(' in s:\n                fm[s] = -1\n                return -1\n\n            l = len(s)\n            if '*' in s:\n                oi = s.index('*')\n                li = oi\n                for i in range(oi-1,-1,-1):\n                    if s[i] not in '01':\n                        break\n                    li = i\n                ri = oi\n                for i in range(oi+1,l):\n                    if s[i] not in '01':\n                        break\n                    ri = i\n                if li == oi or ri == oi:\n                    fm[s] = -1\n                    return -1\n                t = int(s[li:oi], 2)\n                u = int(s[oi+1:ri+1], 2)\n                tu = t * u\n                if t < 0 or t >= 1024 or u < 0 or u >= 1024 or tu < 0 or tu >= 1024:\n                    fm[s] = -1\n                    return -1\n                ts = bin(tu)[2:]\n                fm[s] = _f(s[:li] + ts + s[ri+1:])\n                return fm[s]\n            pi = inf\n            mi = inf\n            if '+' in s:\n                pi = s.index('+')\n            if '-' in s:\n                mi = s.index('-')\n            if pi == inf and mi == inf:\n                t = int(s, 2)\n                fm[s] = s\n                if t < 0 or t >= 1024:\n                    fm[s] = -1\n                return fm[s]\n            oi = min(pi, mi)\n            li = oi\n            for i in range(oi-1,-1,-1):\n                if s[i] not in '01':\n                    break\n                li = i\n            ri = oi\n            for i in range(oi+1,l):\n                if s[i] not in '01':\n                    break\n                ri = i\n            if li == oi or ri == oi:\n                fm[s] = -1\n                return -1\n            t = int(s[li:oi], 2)\n            t = int(s[li:oi], 2)\n            u = int(s[oi+1:ri+1], 2)\n            tu = t + u\n            if oi == mi:\n                tu = t - u\n            if t < 0 or t >= 1024 or u < 0 or u >= 1024 or tu < 0 or tu >= 1024:\n                fm[s] = -1\n                return -1\n            ts = bin(tu)[2:]\n            fm[s] = _f(s[:li] + ts + s[ri+1:])\n            return fm[s]\n\n\n        for ci in itertools.product(ca, repeat=sl-1):\n            t = ''\n            for i in range(len(ci)):\n                t += sa[i]\n                t += ci[i]\n            t += sa[-1]\n            tr = _f(t)\n            if tr != -1:\n                tr = int(tr, 2)\n                if tr >= 1024 or tr < 0:\n                    tr = -1\n            if r < tr:\n                r = tr\n        # for k in sorted(fm.keys()):\n        #     if fm[k] == -1:\n        #         continue\n        #     print(k, fm[k])\n        return r\n\n    while 1:\n        n = S()\n        if n == 0:\n            break\n        rr.append(f(n))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    e = LI()\n    d = defaultdict(int)\n    for i in e:\n        d[i] += 1\n    for i in d.values():\n        if i != 2:\n            print(\"no\")\n            break\n    else:\n        print(\"yes\")\n    return\n\n#B\ndef B():\n    n = I()\n    a = LI()\n    a.sort()\n    ans = -float(\"inf\")\n    for c in range(n):\n        for d in range(c):\n            m = a[c]-a[d]\n            for i in range(n)[::-1]:\n                if i != c and i != d:\n                    e = i\n                    break\n            for i in range(e)[::-1]:\n                if i != c and i != d:\n                    b = i\n                    break\n            ans = max(ans, (a[e]+a[b])/m)\n    print(ans)\n    return\n\n#C\ndef C():\n    def gcd(a,b):\n        if a == 0:\n            return b\n        return gcd(b%a, a)\n\n    s = input()\n    n = len(s)\n    if s.count(\"(\") == 0:\n        s = float(s)\n        b = 10**(n-2)\n        a = round(s*b)\n        g = gcd(a,b)\n        a //= g\n        b //= g\n    else:\n        n = s.find(\"(\")\n        t = float(s[:n])\n        b = 10**(n-2)\n        a = round(t*b)\n        g = gcd(a,b)\n        a //= g\n        b //= g\n        l = (s.find(\"(\")-s.find(\".\")-1)\n        s = s[n+1:-1]\n        m = len(s)\n        c = round(float(s))\n        d = (10**m-1)*10**l\n        g = gcd(c,d)\n        c //= g\n        d //= g\n        a = a*d+b*c\n        b = b*d\n        g = gcd(a,b)\n        a //= g\n        b //= g\n    print(str(a)+\"/\"+str(b))\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    def dfs(d,k,s):\n        if d == n:\n            ans.append(k)\n        else:\n            b = [block[d][i] for i in range(8)]\n            if sum(b[:4]) == 0:\n                b = b[4:]+[0,0,0,0]\n            dfs(d+1,*check(b,k,s))\n            if not (b[0]|b[1]|b[4]|b[5]):\n                b_ = [b[2],b[3],0,0,b[6],b[7],0,0]\n                if sum(b_):\n                    dfs(d+1,*check(b_,k,s))\n            if not (b[1]|b[3]|b[5]|b[7]):\n                b_ = [0,b[0],0,b[2],0,b[4],0,b[6]]\n                if sum(b_):\n                    dfs(d+1,*check(b_,k,s))\n            if not (b[2]|b[3]|b[6]|b[7]):\n                b_ = [0,0,b[0],b[1],0,0,b[4],b[5]]\n                if sum(b_):\n                    dfs(d+1,*check(b_,k,s))\n            if not (b[0]|b[2]|b[4]|b[6]):\n                b_ = [b[1],0,b[3],0,b[5],0,b[7],0]\n                if sum(b_):\n                    dfs(d+1,*check(b_,k,s))\n            if not (b[1]|b[2]|b[3]|b[5]|b[6]|b[7]):\n                b_ = [0,0,0,b[0],0,0,0,b[4]]\n                if sum(b_):\n                    dfs(d+1,*check(b_,k,s))\n            if not (b[0]|b[2]|b[3]|b[4]|b[6]|b[7]):\n                b_ = [0,0,b[1],0,0,0,b[5],0]\n                if sum(b_):\n                    dfs(d+1,*check(b_,k,s))\n            if not (b[0]|b[1]|b[3]|b[4]|b[5]|b[7]):\n                b_ = [0,b[2],0,b[6],0,0,0,0]\n                if sum(b_):\n                    dfs(d+1,*check(b_,k,s))\n            if not (b[0]|b[1]|b[2]|b[4]|b[5]|b[6]):\n                b_ = [b[3],0,0,0,b[7],0,0,0]\n                if sum(b_):\n                    dfs(d+1,*check(b_,k,s))\n    def check(b,k,s):\n        i = 19\n        k_ = k\n        s_ = [[s[i][j] for j in range(4)] for i in range(20)]\n        while i >= 1 and not ((b[0]&s[i-1][0])|(b[1]&s[i-1][1])|(b[2]&s[i-1][2])|(b[3]&s[i-1][3])|(b[4]&s[i][0])|(b[5]&s[i][1])|(b[6]&s[i][2])|(b[7]&s[i][3])):\n            i -= 1\n        s_[i] = [s_[i][j]+b[j] for j in range(4)]\n        s_[i+1] = [s_[i+1][j]+b[j+4] for j in range(4)]\n        i = 0\n        while i < 20:\n            if sum(s_[i]) == 4:\n                k_ += 1\n                for j in range(i,19):\n                    s_[j] = [s_[j+1][l] for l in range(4)]\n                s_[19] = [0,0,0,0]\n                i -= 1\n            i += 1\n        return k_,s_\n\n    while 1:\n        h,n = LI()\n        if h == n == 0:\n            break\n        s = [[0,0,0,0] for i in range(20)]\n        for i in range(h):\n            c = S()\n            c += S()\n            s[i] = [1 if c[j] == \"#\" else 0 for j in range(4)]\n        block = [[0,0,0,0,0,0,0,0] for i in range(n)]\n        for i in range(n):\n            b = S()\n            b += S()\n            b += S()\n            b += S()\n            block[i] = [1 if b[j] == \"#\" else 0 for j in range(8)]\n        ans = []\n        dfs(0,0,s)\n        print(max(ans))\n    return\n\n#F\ndef F():\n    def dfs(d,k):\n        if d == len(s):\n            t.append(k)\n        else:\n            if s[d] == \".\":\n                for i in range(2):\n                    dfs(d+1,k+[str(i)])\n                for i in \"+-*()\":\n                    dfs(d+1,k+[i])\n            else:\n                dfs(d+1,k+[s[d]])\n\n    def parse_expr(s,i):\n        if i == float(\"inf\"):\n            return -1,float(\"inf\")\n        f = s[i-1] == \"(\"\n        k = 0\n        t,i,k = parse_term(s,i,k)\n        while i < len(s) and s[i] in \"+-\":\n            k += 1\n            op,i = parse_op(s,i)\n            t_,i,k = parse_term(s,i,k)\n            t = calc(op,t,t_)\n            if t >= 1024 or t < 0:\n                return -1,float(\"inf\")\n        if f and not k:\n            return -1,float(\"inf\")\n        return t,i\n\n    def parse_term(s,i,k):\n        f,i = parse_factor(s,i)\n        while i < len(s) and s[i] == \"*\":\n            k += 1\n            op,i = parse_op(s,i)\n            f_,i = parse_factor(s,i)\n            f = calc(op,f,f_)\n            if f >= 1024 or f < 0:\n                return -1,float(\"inf\"),k\n        return f,i,k\n\n    def parse_op(s,i):\n        return s[i],i+1\n\n    def parse_factor(s,i):\n        if i >= len(s):\n            return -1,float(\"inf\")\n        if s[i] == \"(\":\n            i += 1\n            e,i = parse_expr(s,i)\n            if i >= len(s) or s[i] != \")\":\n                return -1,float(\"inf\")\n            i += 1\n            return e,i\n        else:\n            if not s[i].isdecimal():\n                return -1,float(\"inf\")\n            n = int(s[i])\n            i += 1\n            while i < len(s) and s[i].isdecimal():\n                n *= 2\n                n += int(s[i])\n                i += 1\n            if n >= 1024 or n < 0:\n                return -1,float(\"inf\")\n            return n,i\n\n    def calc(op,a,b):\n        if op == \"+\":\n            return a+b\n        elif op == \"-\":\n            return a-b\n        elif op == \"*\":\n            return a*b\n\n\n    s = S()\n    f = defaultdict(lambda : 0)\n    for i in range(2):\n        f[str(i)] += 1\n    t = []\n    dfs(0,[])\n    ans = -1\n    for s in t:\n        e,i = parse_expr(s,0)\n        if i == len(s):\n            ans = max(ans,e)\n    print(ans)\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    F()\n\n"
  }
]