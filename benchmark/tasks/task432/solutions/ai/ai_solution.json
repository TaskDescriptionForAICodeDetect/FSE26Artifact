[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_LEN 105\n#define MAX_DOTS 5\n\nchar ops[] = {'0', '1', '+', '-', '*', '(', ')'};\nint max_result = -1;\n\ntypedef struct {\n    char expr[MAX_LEN];\n    int dot_pos[MAX_DOTS];\n    int dot_count;\n} Expression;\n\nint is_digit(char c) {\n    return c == '0' || c == '1';\n}\n\nint is_op(char c) {\n    return c == '+' || c == '-' || c == '*';\n}\n\nint precedence(char op) {\n    if (op == '*' ) return 2;\n    if (op == '+' || op == '-') return 1;\n    return 0;\n}\n\nint apply_op(int a, int b, char op) {\n    switch(op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n    }\n    return 0;\n}\n\nint evaluate(char* expr) {\n    int i;\n    int len = strlen(expr);\n    int num_stack[MAX_LEN];\n    char op_stack[MAX_LEN];\n    int num_top = -1;\n    int op_top = -1;\n\n    for (i = 0; i < len; i++) {\n        if (expr[i] == ' ') {\n            continue;\n        } else if (expr[i] == '(') {\n            op_stack[++op_top] = expr[i];\n        } else if (is_digit(expr[i])) {\n            int num = 0;\n            while (i < len && is_digit(expr[i])) {\n                num = num * 2 + (expr[i] - '0');\n                i++;\n            }\n            num_stack[++num_top] = num;\n            i--;\n        } else if (expr[i] == ')') {\n            while (op_top >= 0 && op_stack[op_top] != '(') {\n                int b = num_stack[num_top--];\n                int a = num_stack[num_top--];\n                char op = op_stack[op_top--];\n                int res = apply_op(a, b, op);\n                if (res < 0 || res >= (1 << 10)) return -1;\n                num_stack[++num_top] = res;\n            }\n            if (op_top >= 0 && op_stack[op_top] == '(') {\n                op_top--;\n            } else {\n                return -1;\n            }\n        } else if (is_op(expr[i])) {\n            while (op_top >= 0 && precedence(op_stack[op_top]) >= precedence(expr[i])) {\n                int b = num_stack[num_top--];\n                int a = num_stack[num_top--];\n                char op = op_stack[op_top--];\n                int res = apply_op(a, b, op);\n                if (res < 0 || res >= (1 << 10)) return -1;\n                num_stack[++num_top] = res;\n            }\n            op_stack[++op_top] = expr[i];\n        } else {\n            return -1;\n        }\n    }\n\n    while (op_top >= 0) {\n        int b = num_stack[num_top--];\n        int a = num_stack[num_top--];\n        char op = op_stack[op_top--];\n        int res = apply_op(a, b, op);\n        if (res < 0 || res >= (1 << 10)) return -1;\n        num_stack[++num_top] = res;\n    }\n\n    if (num_top != 0 || op_top != -1) return -1;\n    return num_stack[num_top];\n}\n\nvoid generate_combinations(Expression* exp, int pos) {\n    if (pos == exp->dot_count) {\n        int res = evaluate(exp->expr);\n        if (res != -1 && res > max_result) {\n            max_result = res;\n        }\n        return;\n    }\n\n    int dot_pos = exp->dot_pos[pos];\n    for (int i = 0; i < 7; i++) {\n        exp->expr[dot_pos] = ops[i];\n        generate_combinations(exp, pos + 1);\n    }\n}\n\nint main() {\n    char input[MAX_LEN];\n    fgets(input, MAX_LEN, stdin);\n    input[strcspn(input, \"\\n\")] = '\\0';\n\n    Expression exp;\n    exp.dot_count = 0;\n    strcpy(exp.expr, input);\n\n    for (int i = 0; exp.expr[i]; i++) {\n        if (exp.expr[i] == '.') {\n            exp.dot_pos[exp.dot_count++] = i;\n            if (exp.dot_count > MAX_DOTS) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n    }\n\n    generate_combinations(&exp, 0);\n    printf(\"%d\\n\", max_result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:32:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstring ops = \"+-*\";\nstring digits = \"01\";\n\nvector<string> generate_replacements(const string& s, int pos) {\n    vector<string> res;\n    if (pos >= s.size()) {\n        res.push_back(s);\n        return res;\n    }\n    if (s[pos] != '.') {\n        res = generate_replacements(s, pos + 1);\n        return res;\n    }\n    string temp = s;\n    for (char c : digits + ops + \"()\") {\n        temp[pos] = c;\n        auto sub_res = generate_replacements(temp, pos + 1);\n        res.insert(res.end(), sub_res.begin(), sub_res.end());\n    }\n    return res;\n}\n\nbool is_valid(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        else if (c == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}\n\nint evaluate_expression(const string& expr, int& pos);\n\nint evaluate_term(const string& expr, int& pos) {\n    int value = evaluate_expression(expr, pos);\n    while (pos < expr.size() && (expr[pos] == '*' || expr[pos] == '/' || expr[pos] == '+' || expr[pos] == '-')) {\n        char op = expr[pos++];\n        int next_value = evaluate_expression(expr, pos);\n        if (op == '*') {\n            value *= next_value;\n        } else if (op == '/') {\n            if (next_value == 0) return -1;\n            value /= next_value;\n        } else if (op == '+') {\n            value += next_value;\n        } else if (op == '-') {\n            value -= next_value;\n        }\n    }\n    return value;\n}\n\nint evaluate_expression(const string& expr, int& pos) {\n    if (pos >= expr.size()) return -1;\n    int value;\n    if (expr[pos] == '(') {\n        pos++;\n        value = evaluate_term(expr, pos);\n        if (pos >= expr.size() || expr[pos] != ')') return -1;\n        pos++;\n    } else {\n        if (expr[pos] != '0' && expr[pos] != '1') return -1;\n        int num = 0;\n        while (pos < expr.size() && (expr[pos] == '0' || expr[pos] == '1')) {\n            num = num * 2 + (expr[pos] - '0');\n            pos++;\n        }\n        value = num;\n    }\n    return value;\n}\n\nint evaluate(const string& expr) {\n    int pos = 0;\n    int value = evaluate_term(expr, pos);\n    if (pos != expr.size()) return -1;\n    return value;\n}\n\nint main() {\n    string s;\n    getline(cin, s);\n    auto replacements = generate_replacements(s, 0);\n    int max_val = -1;\n    for (const auto& expr : replacements) {\n        if (!is_valid(expr)) continue;\n        int val = evaluate(expr);\n        if (val >= 0 && val < (1 << 10)) {\n            if (val > max_val) {\n                max_val = val;\n            }\n        }\n    }\n    cout << max_val << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:33:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TheLostNumbers {\n    private static final Set<Character> DIGITS = new HashSet<>(Arrays.asList('0', '1'));\n    private static final Set<Character> OPS = new HashSet<>(Arrays.asList('+', '-', '*'));\n    private static final int MAX_NUM = (1 << 10) - 1;\n\n    private static int maxResult = -1;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String expression = scanner.nextLine();\n        scanner.close();\n\n        List<Integer> dotIndices = new ArrayList<>();\n        for (int i = 0; i < expression.length(); i++) {\n            if (expression.charAt(i) == '.') {\n                dotIndices.add(i);\n            }\n        }\n\n        char[] chars = expression.toCharArray();\n        generateAllPossibilities(chars, dotIndices, 0);\n        System.out.println(maxResult);\n    }\n\n    private static void generateAllPossibilities(char[] chars, List<Integer> dotIndices, int index) {\n        if (index == dotIndices.size()) {\n            String expr = new String(chars);\n            if (isValidExpression(expr)) {\n                try {\n                    int result = evaluate(expr);\n                    if (result >= 0 && result <= MAX_NUM) {\n                        maxResult = Math.max(maxResult, result);\n                    }\n                } catch (Exception e) {\n                    // Ignore invalid expressions during evaluation\n                }\n            }\n            return;\n        }\n\n        int dotPos = dotIndices.get(index);\n        for (char c : \"01+-*()\".toCharArray()) {\n            chars[dotPos] = c;\n            generateAllPossibilities(chars, dotIndices, index + 1);\n        }\n    }\n\n    private static boolean isValidExpression(String expr) {\n        Stack<Character> stack = new Stack<>();\n        boolean expectDigitOrOpenParen = true;\n\n        for (int i = 0; i < expr.length(); i++) {\n            char c = expr.charAt(i);\n            if (expectDigitOrOpenParen) {\n                if (c == '(') {\n                    stack.push(c);\n                } else if (DIGITS.contains(c)) {\n                    expectDigitOrOpenParen = false;\n                } else {\n                    return false;\n                }\n            } else {\n                if (OPS.contains(c)) {\n                    expectDigitOrOpenParen = true;\n                } else if (c == ')') {\n                    if (stack.isEmpty() || stack.pop() != '(') {\n                        return false;\n                    }\n                } else if (DIGITS.contains(c)) {\n                    return false;\n                }\n            }\n        }\n\n        if (expectDigitOrOpenParen) {\n            return false;\n        }\n\n        return stack.isEmpty();\n    }\n\n    private static int evaluate(String expr) {\n        return evaluateExpression(expr);\n    }\n\n    private static int evaluateExpression(String expr) {\n        List<String> tokens = tokenize(expr);\n        Stack<Integer> values = new Stack<>();\n        Stack<String> ops = new Stack<>();\n\n        for (String token : tokens) {\n            if (token.equals(\"(\")) {\n                ops.push(token);\n            } else if (token.equals(\")\")) {\n                while (!ops.peek().equals(\"(\")) {\n                    values.push(applyOp(ops.pop(), values.pop(), values.pop()));\n                }\n                ops.pop();\n            } else if (token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\")) {\n                while (!ops.isEmpty() && hasPrecedence(token, ops.peek())) {\n                    values.push(applyOp(ops.pop(), values.pop(), values.pop()));\n                }\n                ops.push(token);\n            } else {\n                values.push(Integer.parseInt(token, 2));\n            }\n        }\n\n        while (!ops.isEmpty()) {\n            values.push(applyOp(ops.pop(), values.pop(), values.pop()));\n        }\n\n        return values.pop();\n    }\n\n    private static List<String> tokenize(String expr) {\n        List<String> tokens = new ArrayList<>();\n        StringBuilder current = new StringBuilder();\n\n        for (int i = 0; i < expr.length(); i++) {\n            char c = expr.charAt(i);\n            if (DIGITS.contains(c)) {\n                current.append(c);\n            } else {\n                if (current.length() > 0) {\n                    tokens.add(current.toString());\n                    current = new StringBuilder();\n                }\n                if (c != ' ') {\n                    tokens.add(String.valueOf(c));\n                }\n            }\n        }\n\n        if (current.length() > 0) {\n            tokens.add(current.toString());\n        }\n\n        return tokens;\n    }\n\n    private static boolean hasPrecedence(String op1, String op2) {\n        if (op2.equals(\"(\") || op2.equals(\")\")) {\n            return false;\n        }\n        return (op1.equals(\"*\") && (op2.equals(\"+\") || op2.equals(\"-\"))) ? false : true;\n    }\n\n    private static int applyOp(String op, int b, int a) {\n        switch (op) {\n            case \"+\":\n                return a + b;\n            case \"-\":\n                return a - b;\n            case \"*\":\n                return a * b;\n        }\n        return 0;\n    }\n}",
    "timestamp": "2025-08-05 21:34:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LostNumbers {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String expression = scanner.nextLine();\n        scanner.close();\n\n        System.out.println(findMaxResult(expression));\n    }\n\n    private static long findMaxResult(String expression) {\n        List<String> replacements = generateReplacements(expression);\n        long maxResult = Long.MIN_VALUE;\n        boolean foundValid = false;\n\n        for (String replacement : replacements) {\n            try {\n                long result = evaluateExpression(replacement);\n                if (result < 1024) {\n                    maxResult = Math.max(maxResult, result);\n                    foundValid = true;\n                }\n            } catch (Exception e) {\n                // Invalid expression, ignore\n            }\n        }\n\n        return foundValid ? maxResult : -1;\n    }\n\n    private static List<String> generateReplacements(String expression) {\n        List<String> replacements = new ArrayList<>();\n        generateReplacementsHelper(expression.toCharArray(), 0, replacements);\n        return replacements;\n    }\n\n    private static void generateReplacementsHelper(char[] expr, int index, List<String> replacements) {\n        if (index == expr.length) {\n            replacements.add(new String(expr));\n            return;\n        }\n\n        if (expr[index] == '.') {\n            char[] options = {'0', '1', '+', '-', '*', '(', ')'};\n            for (char option : options) {\n                expr[index] = option;\n                generateReplacementsHelper(expr, index + 1, replacements);\n            }\n            expr[index] = '.';\n        } else {\n            generateReplacementsHelper(expr, index + 1, replacements);\n        }\n    }\n\n    private static long evaluateExpression(String expression) {\n        return evaluate(expression, 0, expression.length() - 1);\n    }\n\n    private static long evaluate(String expr, int start, int end) {\n        while (start < end && expr.charAt(start) == '(' && expr.charAt(end) == ')') {\n            start++;\n            end--;\n        }\n\n        for (int i = end; i >= start; i--) {\n            if (expr.charAt(i) == ')') {\n                int depth = 1;\n                int j = i - 1;\n                while (j >= start && depth > 0) {\n                    if (expr.charAt(j) == ')') depth++;\n                    if (expr.charAt(j) == '(') depth--;\n                    j--;\n                }\n                if (depth == 0) {\n                    long left = evaluate(expr, start, j);\n                    long right = evaluate(expr, i + 1, end);\n                    char op = findOperator(expr, j + 1, i - 1);\n                    return performOperation(left, right, op);\n                }\n            }\n        }\n\n        for (int i = end; i >= start; i--) {\n            if (expr.charAt(i) == '*') {\n                long left = evaluate(expr, start, i - 1);\n                long right = evaluate(expr, i + 1, end);\n                return left * right;\n            }\n        }\n\n        for (int i = start; i <= end; i++) {\n            if (expr.charAt(i) == '+') {\n                long left = evaluate(expr, start, i - 1);\n                long right = evaluate(expr, i + 1, end);\n                return left + right;\n            }\n            if (expr.charAt(i) == '-') {\n                long left = evaluate(expr, start, i - 1);\n                long right = evaluate(expr, i + 1, end);\n                return left - right;\n            }\n        }\n\n        return Long.parseLong(expr.substring(start, end + 1), 2);\n    }\n\n    private static char findOperator(String expr, int start, int end) {\n        for (int i = start; i <= end; i++) {\n            char c = expr.charAt(i);\n            if (c == '+' || c == '-' || c == '*') return c;\n        }\n        return '+';\n    }\n\n    private static long performOperation(long left, long right, char op) {\n        switch (op) {\n            case '+': return left + right;\n            case '-': return left - right;\n            case '*': return left * right;\n            default: return 0;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:35:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_LEN 105\n#define MAX_COMBINATIONS 32\n\nint max_result = INT_MIN;\n\nint parse_number(char* expr, int* start) {\n    int num = 0;\n    while (expr[*start] >= '0' && expr[*start] <= '1') {\n        num = num * 2 + (expr[*start] - '0');\n        (*start)++;\n        if (num >= 1024) return -1;\n    }\n    return num;\n}\n\nint evaluate(char* expr) {\n    int len = strlen(expr);\n    int result = 0, current = 0;\n    char op = '+';\n    int i = 0;\n\n    while (i < len) {\n        if (expr[i] >= '0' && expr[i] <= '1') {\n            current = parse_number(expr, &i);\n            if (current == -1) return -1;\n\n            switch (op) {\n                case '+': result += current; break;\n                case '-': result -= current; break;\n                case '*': result *= current; break;\n            }\n\n            if (result < 0 || result >= 1024) return -1;\n        }\n        else if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') {\n            op = expr[i++];\n        }\n        else {\n            i++;\n        }\n    }\n\n    return result;\n}\n\nvoid backtrack(char* original, char* current, int dot_count) {\n    if (dot_count == 0) {\n        int res = evaluate(current);\n        if (res != -1) {\n            max_result = (res > max_result) ? res : max_result;\n        }\n        return;\n    }\n\n    for (int i = 0; original[i]; i++) {\n        if (original[i] == '.') {\n            for (char replacement : {'0', '1', '+', '-', '*', '(', ')'}) {\n                current[i] = replacement;\n                original[i] = replacement;\n                backtrack(original, current, dot_count - 1);\n                original[i] = '.';\n            }\n            current[i] = '.';\n            break;\n        }\n    }\n}\n\nint main() {\n    char original[MAX_LEN], current[MAX_LEN];\n    int dot_count = 0;\n\n    scanf(\"%s\", original);\n    strcpy(current, original);\n\n    for (int i = 0; original[i]; i++) {\n        if (original[i] == '.') dot_count++;\n    }\n\n    backtrack(original, current, dot_count);\n\n    printf(\"%d\\n\", (max_result == INT_MIN) ? -1 : max_result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nbool isValidNumber(const string& num) {\n    if (num.empty() || num.length() > 10) return false;\n    long long val = stoll(num);\n    return val >= 0 && val < (1 << 10);\n}\n\nlong long calculate(long long a, long long b, char op) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        default: return 0;\n    }\n}\n\nlong long evaluateExpression(const string& expr) {\n    vector<long long> nums;\n    vector<char> ops;\n    \n    for (int i = 0; i < expr.length(); i++) {\n        if (isdigit(expr[i])) {\n            int j = i;\n            while (j < expr.length() && isdigit(expr[j])) j++;\n            string num = expr.substr(i, j - i);\n            \n            if (!isValidNumber(num)) return LLONG_MIN;\n            nums.push_back(stoll(num));\n            i = j - 1;\n        } else if (expr[i] == '+' || expr[i] == '-' || expr[i] == '*') {\n            while (!ops.empty() && ((expr[i] != '*' && (ops.back() == '*' || ops.back() == '-')) || \n                   (expr[i] == '+' && ops.back() == '-'))) {\n                long long b = nums.back(); nums.pop_back();\n                long long a = nums.back(); nums.pop_back();\n                char op = ops.back(); ops.pop_back();\n                nums.push_back(calculate(a, b, op));\n            }\n            ops.push_back(expr[i]);\n        }\n    }\n    \n    while (!ops.empty()) {\n        long long b = nums.back(); nums.pop_back();\n        long long a = nums.back(); nums.pop_back();\n        char op = ops.back(); ops.pop_back();\n        nums.push_back(calculate(a, b, op));\n    }\n    \n    return nums[0];\n}\n\nlong long solve(const string& expr) {\n    vector<int> dotPositions;\n    for (int i = 0; i < expr.length(); i++) {\n        if (expr[i] == '.') dotPositions.push_back(i);\n    }\n    \n    long long maxResult = LLONG_MIN;\n    int dotCount = dotPositions.size();\n    \n    for (int mask = 0; mask < (1 << (2 * dotCount)); mask++) {\n        string modifiedExpr = expr;\n        for (int i = 0; i < dotCount; i++) {\n            int digit = (mask >> (2 * i)) & 3;\n            modifiedExpr[dotPositions[i]] = '0' + digit;\n        }\n        \n        if (modifiedExpr.find('.') == string::npos) {\n            long long result = evaluateExpression(modifiedExpr);\n            maxResult = max(maxResult, result);\n        }\n    }\n    \n    return maxResult == LLONG_MIN ? -1 : maxResult;\n}\n\nint main() {\n    string expression;\n    getline(cin, expression);\n    \n    cout << solve(expression) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate_binary_expression(expr):\n    def calculate(tokens):\n        if not tokens:\n            return 0\n        # Operator precedence handling\n        def precedence(op):\n            if op == '+' or op == '-':\n                return 1\n            if op == '*':\n                return 2\n            return 0\n\n        # Applying operator on two numbers\n        def apply_op(a, b, op):\n            if op == '+':\n                return a + b\n            if op == '-':\n                return a - b\n            if op == '*':\n                return a * b\n\n        values = []\n        ops = []\n        i = 0\n\n        while i < len(tokens):\n            if isinstance(tokens[i], int):\n                values.append(tokens[i])\n            elif tokens[i] == '(':\n                ops.append(tokens[i])\n            elif tokens[i] == ')':\n                while len(ops) != 0 and ops[-1] != '(':\n                    val2 = values.pop()\n                    val1 = values.pop()\n                    op = ops.pop()\n                    values.append(apply_op(val1, val2, op))\n                ops.pop()\n            else:\n                while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])):\n                    val2 = values.pop()\n                    val1 = values.pop()\n                    op = ops.pop()\n                    values.append(apply_op(val1, val2, op))\n                ops.append(tokens[i])\n            i += 1\n\n        while len(ops) != 0:\n            val2 = values.pop()\n            val1 = values.pop()\n            op = ops.pop()\n            values.append(apply_op(val1, val2, op))\n\n        return values[-1]\n\n    def tokenize(expr):\n        tokens = []\n        i = 0\n        while i < len(expr):\n            if expr[i] in '01':\n                num = ''\n                while i < len(expr) and expr[i] in '01':\n                    num += expr[i]\n                    i += 1\n                tokens.append(int(num, 2))\n            elif expr[i] in '+-*()':\n                tokens.append(expr[i])\n                i += 1\n            else:\n                i += 1\n        return tokens\n\n    try:\n        return calculate(tokenize(expr))\n    except:\n        return float('-inf')\n\ndef solve_lost_numbers(expression):\n    import itertools\n\n    def all_valid_expressions(expr):\n        possibilities = []\n        dot_count = expr.count('.')\n        for replacement in itertools.product('01+-*()', repeat=dot_count):\n            new_expr = expr\n            for char in replacement:\n                new_expr = new_expr.replace('.', char, 1)\n            if is_valid_expression(new_expr):\n                possibilities.append(new_expr)\n        return possibilities\n\n    def is_valid_expression(expr):\n        # It should not start with operator and should have balanced parentheses\n        if expr[0] in '+-*()' or expr[-1] in '+-*(':\n            return False\n        balance = 0\n        for ch in expr:\n            if ch == '(':\n                balance += 1\n            if ch == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    max_value = float('-inf')\n    valid_expressions = all_valid_expressions(expression)\n\n    for expr in valid_expressions:\n        value = evaluate_binary_expression(expr)\n        if 0 <= value < 1024:\n            max_value = max(max_value, value)\n\n    if max_value == float('-inf'):\n        return -1\n    else:\n        return max_value\n\n# Example usage\nexpression = input().strip()\nprint(solve_lost_numbers(expression))",
    "timestamp": "2025-08-13 06:52:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\npublic class LostNumbers {\n\n    private static final int MAX_VALUE = 1023;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String expression = scanner.nextLine();\n        scanner.close();\n        int maxResult = findMaxResult(expression);\n        System.out.println(maxResult);\n    }\n\n    private static int findMaxResult(String expression) {\n        List<String> possibilities = generatePossibilities(expression);\n        int maxResult = -1;\n        for (String expr : possibilities) {\n            try {\n                int result = evaluateExpression(expr);\n                if (result > maxResult) {\n                    maxResult = result;\n                }\n            } catch (ArithmeticException ignored) {\n                // Ignore invalid calculations\n            }\n        }\n        return maxResult;\n    }\n\n    private static List<String> generatePossibilities(String expression) {\n        List<String> results = new ArrayList<>();\n        generate(expression.toCharArray(), 0, results);\n        return results;\n    }\n\n    private static void generate(char[] expr, int pos, List<String> results) {\n        if (pos == expr.length) {\n            String exprStr = new String(expr);\n            if (isValid(exprStr)) {\n                results.add(exprStr);\n            }\n            return;\n        }\n\n        if (expr[pos] == '.') {\n            for (char c : new char[] {'0', '1', '+', '-', '*', '(', ')'}) {\n                expr[pos] = c;\n                generate(expr, pos + 1, results);\n                expr[pos] = '.';  // reset for next iteration\n            }\n        } else {\n            generate(expr, pos + 1, results);\n        }\n    }\n\n    private static boolean isValid(String expr) {\n        // Ensures parentheses are balanced in the expression\n        int count = 0;\n        for (char c : expr.toCharArray()) {\n            if (c == '(') count++;\n            if (c == ')') count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n\n    private static int evaluateExpression(String expr) {\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        Matcher matcher = pattern.matcher(expr);\n\n        while (matcher.find()) {\n            int number = Integer.parseInt(matcher.group(), 2); // binary to int\n            if (number > MAX_VALUE) {\n                throw new ArithmeticException(\"Overflow\");\n            }\n        }\n\n        while (expr.contains(\"(\")) {\n            expr = evaluateParentheses(expr);\n        }\n\n        String[] tokens = expr.split(\"(?=[-+*])|(?<=[-+*])\");\n        return evaluateTokens(tokens);\n    }\n\n    private static String evaluateParentheses(String expr) {\n        int closing = expr.indexOf(')');\n        int opening = expr.lastIndexOf('(', closing);\n        String subExpr = expr.substring(opening + 1, closing);\n        int value = evaluateTokens(subExpr.split(\"(?=[-+*])|(?<=[-+*])\"));\n        return expr.substring(0, opening) + value + expr.substring(closing + 1);\n    }\n\n    private static int evaluateTokens(String[] tokens) {\n        Stack<Integer> values = new Stack<>();\n        Stack<Character> ops = new Stack<>();\n\n        for (String token : tokens) {\n            if (token.isEmpty()) continue;\n            if (isOperator(token.charAt(0))) {\n                while (!ops.isEmpty() && precedence(ops.peek()) >= precedence(token.charAt(0))) {\n                    int b = values.pop();\n                    int a = values.pop();\n                    char op = ops.pop();\n                    values.push(applyOp(op, a, b));\n                }\n                ops.push(token.charAt(0));\n            } else {\n                values.push(Integer.parseInt(token, 2)); // binary to int\n            }\n        }\n\n        while (!ops.isEmpty()) {\n            int b = values.pop();\n            int a = values.pop();\n            char op = ops.pop();\n            values.push(applyOp(op, a, b));\n        }\n\n        return values.pop();\n    }\n\n    private static boolean isOperator(char c) {\n        return c == '+' || c == '-' || c == '*';\n    }\n\n    private static int precedence(char op) {\n        if (op == '+') return 1;\n        if (op == '-') return 1;\n        if (op == '*') return 2;\n        return 0;\n    }\n\n    private static int applyOp(char op, int a, int b) {\n        switch (op) {\n            case '+': return Math.min(MAX_VALUE, a + b);\n            case '-': return Math.max(0, a - b);\n            case '*': return Math.min(MAX_VALUE, a * b);\n            default: throw new UnsupportedOperationException(\"Invalid operation\");\n        }\n    }\n}",
    "timestamp": "2025-08-13 06:52:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nint max_result = INT_MIN;\n\n// Evaluate expression from left to right, considering multiplication precedence.\nint evaluate_expression(char *expr) {\n    int n = strlen(expr);\n    int result = 0, last_mul = 1;\n    char operation = '+';\n    \n    for (int i = 0; i < n; ++i) {\n        if (expr[i] == '+' || expr[i] == '-') {\n            if (operation == '+') result += last_mul;\n            else if (operation == '-') result -= last_mul;\n            last_mul = 0;\n            operation = expr[i];\n        } else if (expr[i] == '*') {\n            operation = '*';\n        } else if (expr[i] == '0' || expr[i] == '1') {\n            int value = expr[i] - '0';\n            if (operation == '*') last_mul *= value;\n            else last_mul = value;\n        }\n    }\n    \n    if (operation == '+') result += last_mul;\n    else if (operation == '-') result -= last_mul;\n    \n    return result;\n}\n\n// Check if the current expression is valid and update maximum result.\nvoid check_expression(char *expr) {\n    int result = evaluate_expression(expr);\n    if (result >= 0 && result < 1024) {\n        if (result > max_result) {\n            max_result = result;\n        }\n    }\n}\n\n// Recursively fill positions of '.' with '0' and '1'.\nvoid fill_characters(char *expr, int pos) {\n    if (pos == strlen(expr)) {\n        check_expression(expr);\n        return;\n    }\n    \n    if (expr[pos] == '.') {\n        expr[pos] = '0';\n        fill_characters(expr, pos + 1);\n        expr[pos] = '1';\n        fill_characters(expr, pos + 1);\n        expr[pos] = '.';\n    } else {\n        fill_characters(expr, pos + 1);\n    }\n}\n\nint main() {\n    char expression[101];\n    scanf(\"%s\", expression);\n\n    fill_characters(expression, 0);\n\n    if (max_result == INT_MIN) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", max_result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:52:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate(expression):\n    try:\n        return int(eval(expression))\n    except:\n        return float('-inf')\n\ndef generate_combinations(expr):\n    dot_indices = [i for i in range(len(expr)) if expr[i] == '.']\n    \n    if not dot_indices:\n        return [expr]\n    \n    combinations = []\n    for replace_ops in product(['0', '1'], repeat=len(dot_indices)):\n        current_expr = list(expr)\n        for idx, op in zip(dot_indices, replace_ops):\n            current_expr[idx] = op\n        combinations.append(''.join(current_expr))\n    \n    return combinations\n\ndef max_calculation(expr):\n    max_result = float('-inf')\n    valid_exprs = generate_combinations(expr)\n    \n    for candidate in valid_exprs:\n        try:\n            if is_valid_binary_expr(candidate):\n                result = evaluate(candidate.replace('*', '*').replace('-', '-'))\n                max_result = max(max_result, result)\n        except:\n            continue\n    \n    return max_result if max_result != float('-inf') else -1\n\ndef is_valid_binary_expr(expr):\n    if not expr:\n        return False\n    \n    # Check for valid binary numbers\n    for part in re.findall(r'\\d+', expr):\n        if part and part[0] == '0' and len(part) > 1:\n            return False\n        try:\n            num = int(part)\n            if num >= 1024:\n                return False\n        except:\n            return False\n    \n    return True\n\nfrom itertools import product\nimport re\n\ndef solution():\n    expr = input().strip()\n    print(max_calculation(expr))\n\nsolution()",
    "timestamp": "2025-08-13 06:53:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom itertools import product\n\ndef evaluate(expr):\n    try:\n        # Check for invalid characters or unbalanced parentheses\n        allowed_chars = {'0', '1', '+', '-', '*', '(', ')'}\n        for c in expr:\n            if c not in allowed_chars:\n                return -1\n        # Check balanced parentheses\n        balance = 0\n        for c in expr:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            if balance < 0:\n                return -1\n        if balance != 0:\n            return -1\n        # Evaluate the expression\n        result = eval_expr(expr)\n        if result is None or result < 0 or result >= (1 << 10):\n            return -1\n        return result\n    except:\n        return -1\n\ndef eval_expr(s):\n    # Tokenize\n    tokens = []\n    i = 0\n    n = len(s)\n    while i < n:\n        if s[i] in '()+-*':\n            tokens.append(s[i])\n            i += 1\n        elif s[i] in '01':\n            j = i\n            while j < n and s[j] in '01':\n                j += 1\n            num_str = s[i:j]\n            if not num_str:\n                return None\n            num = int(num_str, 2)\n            if num >= (1 << 10):\n                return None\n            tokens.append(num)\n            i = j\n        else:\n            return None\n    # Evaluate with precedence\n    return evaluate_tokens(tokens)\n\ndef evaluate_tokens(tokens):\n    # First evaluate parentheses\n    stack = []\n    output = []\n    for token in tokens:\n        if token == '(':\n            stack.append(token)\n        elif token == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            if not stack:\n                return None\n            stack.pop()  # Remove '('\n        elif token in '+-*':\n            while stack and stack[-1] != '(' and precedence(stack[-1]) >= precedence(token):\n                output.append(stack.pop())\n            stack.append(token)\n        else:\n            output.append(token)\n    while stack:\n        if stack[-1] == '(':\n            return None\n        output.append(stack.pop())\n    # Evaluate postfix\n    eval_stack = []\n    for token in output:\n        if token in '+-*':\n            if len(eval_stack) < 2:\n                return None\n            b = eval_stack.pop()\n            a = eval_stack.pop()\n            if token == '+':\n                res = a + b\n            elif token == '-':\n                res = a - b\n            elif token == '*':\n                res = a * b\n            else:\n                return None\n            if res < 0 or res >= (1 << 10):\n                return None\n            eval_stack.append(res)\n        else:\n            eval_stack.append(token)\n    if len(eval_stack) != 1:\n        return None\n    return eval_stack[0]\n\ndef precedence(op):\n    if op == '*':\n        return 2\n    elif op in '+-':\n        return 1\n    else:\n        return 0\n\ndef solve():\n    expr = sys.stdin.readline().strip()\n    dots = [i for i, c in enumerate(expr) if c == '.']\n    max_result = -1\n    # Generate all possible replacements for dots\n    replacements = product('01+-*()', repeat=len(dots))\n    for rep in replacements:\n        temp_expr = list(expr)\n        for i, pos in enumerate(dots):\n            temp_expr[pos] = rep[i]\n        temp_expr_str = ''.join(temp_expr)\n        res = evaluate(temp_expr_str)\n        if res > max_result:\n            max_result = res\n    print(max_result)\n\nsolve()",
    "timestamp": "2025-08-13 06:53:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint evaluate(string &s, int l, int r) {\n    vector<int> nums;\n    vector<char> ops;\n    int i = l;\n    \n    while (i <= r) {\n        if (s[i] == '(') {\n            int open = 1;\n            int j = i + 1;\n            while (j <= r && open > 0) {\n                if (s[j] == '(') open++;\n                else if (s[j] == ')') open--;\n                j++;\n            }\n            nums.push_back(evaluate(s, i + 1, j - 2));\n            i = j;\n        } else if (s[i] == '+' || s[i] == '-' || s[i] == '*') {\n            ops.push_back(s[i]);\n            i++;\n        } else {\n            int num = 0;\n            while (i <= r && isdigit(s[i])) {\n                num = num * 2 + (s[i] - '0');\n                i++;\n            }\n            nums.push_back(num);\n        }\n    }\n    \n    for (int k = 0; k < ops.size(); ++k) {\n        if (ops[k] == '*') {\n            nums[k] = nums[k] * nums[k + 1];\n            nums.erase(nums.begin() + k + 1);\n            ops.erase(ops.begin() + k);\n            k--;\n        }\n    }\n    \n    int result = nums[0];\n    for (int k = 0; k < ops.size(); ++k) {\n        if (ops[k] == '+') result += nums[k + 1];\n        else result -= nums[k + 1];\n    }\n    \n    return result;\n}\n\nbool isValidChar(char ch) {\n    return ch == '0' || ch == '1' || ch == '+' || ch == '-' || ch == '*' || ch == '(' || ch == ')';\n}\n\nint solve(string &expression, vector<int> &indices, int depth) {\n    if (depth == indices.size()) {\n        return evaluate(expression, 0, expression.size() - 1);\n    }\n    \n    int maxValue = INT_MIN;\n    \n    for (char replace = '0'; replace <= '1'; ++replace) {\n        expression[indices[depth]] = replace;\n        int result = solve(expression, indices, depth + 1);\n        maxValue = max(maxValue, result);\n    }\n    \n    return maxValue;\n}\n\nint main() {\n    string expression;\n    cin >> expression;\n    \n    vector<int> unknownIndices;\n    for (int i = 0; i < expression.size(); ++i) {\n        if (expression[i] == '.') {\n            unknownIndices.push_back(i);\n        }\n    }\n    \n    int maxResult = solve(expression, unknownIndices, 0);\n    cout << (maxResult >= 0 ? maxResult : -1) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:34:41"
  }
]